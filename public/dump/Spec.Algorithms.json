[{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"Await","params":[{"name":"value","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _asyncContext_ be the running execution context.\n  1. Let _promise_ be ? PromiseResolve(%Promise%, _value_).\n  1. Let _fulfilledClosure_ be a new Abstract Closure with parameters (_value_) that captures _asyncContext_ and performs the following steps when called:\n    1. Let _prevContext_ be the running execution context.\n    1. Suspend _prevContext_.\n    1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.\n    1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _asyncContext_</emu-meta> using NormalCompletion(_value_) as the result of the operation that suspended it.\n    1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context..\n    1. Return *undefined*.\n  1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 1, *\"\"*, « »).\n  1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _asyncContext_ and performs the following steps when called:\n    1. Let _prevContext_ be the running execution context.\n    1. Suspend _prevContext_.\n    1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.\n    1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _asyncContext_</emu-meta> using ThrowCompletion(_reason_) as the result of the operation that suspended it.\n    1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context..\n    1. Return *undefined*.\n  1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *\"\"*, « »).\n  1. Perform PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_).\n  1. Remove _asyncContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n  1. Set the code evaluation state of _asyncContext_ such that when evaluation is resumed with a _completion_ the following steps will be performed:return _completion_.\n  1. Return NormalCompletion(~unused~).\n  1. NOTE: This returns to the evaluation of the operation that had most previously resumed evaluation of _asyncContext_.","code":"\n    1. Let _asyncContext_ be the running execution context.\n    1. Let _promise_ be ? PromiseResolve(%Promise%, _value_).\n    1. Let _fulfilledClosure_ be a new Abstract Closure with parameters (_value_) that captures _asyncContext_ and performs the following steps when called:\n      1. Let _prevContext_ be the running execution context.\n      1. Suspend _prevContext_.\n      1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.\n      1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _asyncContext_</emu-meta> using NormalCompletion(_value_) as the result of the operation that suspended it.\n      1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context.\n      1. Return *undefined*.\n    1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 1, *\"\"*, « »).\n    1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _asyncContext_ and performs the following steps when called:\n      1. Let _prevContext_ be the running execution context.\n      1. Suspend _prevContext_.\n      1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.\n      1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _asyncContext_</emu-meta> using ThrowCompletion(_reason_) as the result of the operation that suspended it.\n      1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context.\n      1. Return *undefined*.\n    1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *\"\"*, « »).\n    1. Perform PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_).\n    1. Remove _asyncContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n    1. Set the code evaluation state of _asyncContext_ such that when evaluation is resumed with a Completion Record _completion_, the following steps of the algorithm that invoked Await will be performed, with _completion_ available.\n    1. Return NormalCompletion(~unused~).\n    1. NOTE: This returns to the evaluation of the operation that had most previously resumed evaluation of _asyncContext_.\n  "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"RunJobs","params":[],"retTy":"Unknown"}},"body":"\n  1. Perform ? InitializeHostDefinedRealm().\n  1. Let _scriptEvaluationJob_ be a new Abstract Closure with no parameters that captures  and performs the following steps when called:\n    1. Let _sourceText_ be the source code of a script.\n    1. Let _script_ be ParseScript(_sourceText_, the current Realm Record, ~empty~).\n    1. Perform ? ScriptEvaluation(_script_).\n    1. Return *undefined*.\n  1. Perform HostEnqueuePromiseJob(_scriptEvaluationJob_, the current Realm Record).\n  1. Let _errors_ be *undefined*.\n  1. Repeat, \n    1. Suspend the running execution context and remove it from the execution context stack.\n    1. Assert: The execution context stack is empty..\n    1. Let _nextQueue_ be a non-empty Job Queue chosen in an implementation-defined manner.\n    1. If all Job Queues are empty, the result is implementation-defined.\n    1. Let _nextPending_ be the PendingJob record at the front of _nextQueue_. Remove that record from _nextQueue_.\n    1. Let _newContext_ be ExecutionContext { }.\n    1. Set _newContext_.Function to *null*.\n    1. Set _newContext_.Realm to _nextPending_.[[Realm]].\n    1. Set _newContext_.ScriptOrModule to _nextPending_.[[ScriptOrModule]].\n    1. Push _newContext_ onto the execution context stack; _newContext_ is now the running execution context.\n    1. Let _job_ be _nextPending_.[[Job]].\n    1. Let _result_ be _job_().\n    1. If _result_ is an abrupt completion, then\n      1. If _errors_ is *undefined*, set _errors_ to « _result_.[[Value]] ».\n      1. Else, append _result_.[[Value]] to _errors_.","code":"\n    1. Perform ? InitializeHostDefinedRealm().\n    1. Let _scriptEvaluationJob_ be a new Abstract Closure with no parameters that captures nothing and performs the following steps when called:\n      1. Let _sourceText_ be the source code of a script.\n      1. Let _script_ be ParseScript(_sourceText_, the current Realm Record, ~empty~).\n      1. Perform ? ScriptEvaluation(_script_).\n      1. Return *undefined*.\n    1. Perform HostEnqueuePromiseJob(_scriptEvaluationJob_, the current Realm Record).\n    1. Let _errors_ be *undefined*.\n    1. Repeat,\n      1. Suspend the running execution context and remove it from the execution context stack.\n      1. Assert: The execution context stack is empty.\n      1. Let _nextQueue_ be a non-empty Job Queue chosen in an implementation-defined manner.\n      1. If all Job Queues are empty, the result is implementation-defined.\n      1. Let _nextPending_ be the PendingJob record at the front of _nextQueue_. Remove that record from _nextQueue_.\n      1. Let _newContext_ be a new execution context.\n      1. Set _newContext_'s Function to *null*.\n      1. Set _newContext_'s Realm to _nextPending_.[[Realm]].\n      1. Set _newContext_'s ScriptOrModule to _nextPending_.[[ScriptOrModule]].\n      1. Push _newContext_ onto the execution context stack; _newContext_ is now the running execution context.\n      1. Let _job_ be _nextPending_.[[Job]].\n      1. Let _result_ be _job_().\n      1. If _result_ is an abrupt completion,\n        1. If _errors_ is *undefined*, set _errors_ to « _result_.[[Value]] ».\n        1. Otherwise, append _result_.[[Value]] to _errors_.\n  "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"Completion","params":[{"name":"completionRecord","ty":"Completion","kind":{"Normal":{}}}],"retTy":"Completion"}},"body":"\n  1. Assert: _completionRecord_ is a Completion.\n  1. Return _completionRecord_.","code":"\n          1. Assert: _completionRecord_ is a Completion Record.\n          1. Return _completionRecord_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"StringIndexOf","params":[{"name":"string","ty":"String","kind":{"Normal":{}}},{"name":"searchValue","ty":"String","kind":{"Normal":{}}},{"name":"fromIndex","ty":"NonNegInt","kind":{"Normal":{}}}],"retTy":"Int"}},"body":"\n  1. Let _len_ be the length of _string_.\n  1. If _searchValue_ is *\"\"* and _fromIndex_ ≤ _len_, return _fromIndex_.\n  1. Let _searchLen_ be the length of _searchValue_.\n  1. For each integer _i_ such that _fromIndex_ ≤ _i_ ≤ _len_ - _searchLen_, in ascending order, do\n    1. Let _candidate_ be the substring of _string_ from _i_ to _i_ + _searchLen_.\n    1. If _candidate_ is _searchValue_, return _i_.\n  1. Return -1.","code":"\n          1. Let _len_ be the length of _string_.\n          1. If _searchValue_ is the empty String and _fromIndex_ ≤ _len_, return _fromIndex_.\n          1. Let _searchLen_ be the length of _searchValue_.\n          1. For each integer _i_ such that _fromIndex_ ≤ _i_ ≤ _len_ - _searchLen_, in ascending order, do\n            1. Let _candidate_ be the substring of _string_ from _i_ to _i_ + _searchLen_.\n            1. If _candidate_ is _searchValue_, return _i_.\n          1. Return -1.\n        "},{"head":{"NumericMethodHead":{"baseTy":"Number","name":"unaryMinus","params":[{"name":"x","ty":"Number","kind":{"Normal":{}}}],"retTy":"Number"}},"body":"\n  1. If _x_ is *NaN*, return *NaN*.\n  1. Return -_x_.","code":"\n            1. If _x_ is *NaN*, return *NaN*.\n            1. Return the result of negating _x_; that is, compute a Number with the same magnitude but opposite sign.\n          "},{"head":{"NumericMethodHead":{"baseTy":"Number","name":"bitwiseNOT","params":[{"name":"x","ty":"Number","kind":{"Normal":{}}}],"retTy":"Number[Int]"}},"body":"\n  1. Let _oldValue_ be ! ToInt32(_x_).\n  1. Return the result of applying bitwise complement to _oldValue_. The mathematical value of the result is exactly representable as a 32-bit two's complement bit string.","code":"\n            1. Let _oldValue_ be ! ToInt32(_x_).\n            1. Return the result of applying bitwise complement to _oldValue_. The mathematical value of the result is exactly representable as a 32-bit two's complement bit string.\n          "},{"head":{"NumericMethodHead":{"baseTy":"Number","name":"exponentiate","params":[{"name":"base","ty":"Number","kind":{"Normal":{}}},{"name":"exponent","ty":"Number","kind":{"Normal":{}}}],"retTy":"Number"}},"body":"\n  1. If _exponent_ is *NaN*, return *NaN*.\n  1. If _exponent_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.\n  1. If _base_ is *NaN*, return *NaN*.\n  1. If _base_ is *+∞*<sub>𝔽</sub>, then\n    1. If _exponent_ > *+0*<sub>𝔽</sub>, return *+∞*<sub>𝔽</sub>.\n    1. Else, return *+0*<sub>𝔽</sub>.\n  1. If _base_ is *-∞*<sub>𝔽</sub>, then\n    1. If _exponent_ > *+0*<sub>𝔽</sub>, then\n      1. If _exponent_ is an odd integral Number, return *-∞*<sub>𝔽</sub>. Otherwise, return *+∞*<sub>𝔽</sub>.\n    1. Else,\n      1. If _exponent_ is an odd integral Number, return *-0*<sub>𝔽</sub>. Otherwise, return *+0*<sub>𝔽</sub>.\n  1. If _base_ is *+0*<sub>𝔽</sub>, then\n    1. If _exponent_ > *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n    1. Else, return *+∞*<sub>𝔽</sub>.\n  1. If _base_ is *-0*<sub>𝔽</sub>, then\n    1. If _exponent_ > *+0*<sub>𝔽</sub>, then\n      1. If _exponent_ is an odd integral Number, return *-0*<sub>𝔽</sub>. Otherwise, return *+0*<sub>𝔽</sub>.\n    1. Else,\n      1. If _exponent_ is an odd integral Number, return *-∞*<sub>𝔽</sub>. Otherwise, return *+∞*<sub>𝔽</sub>.\n  1. Assert: _base_ is finite and is neither *+0*<sub>𝔽</sub> nor *-0*<sub>𝔽</sub>..\n  1. If _exponent_ is *+∞*<sub>𝔽</sub>, then\n    1. If abs(ℝ(_base_)) > 1, return *+∞*<sub>𝔽</sub>.\n    1. If abs(ℝ(_base_)) = 1, return *NaN*.\n    1. If abs(ℝ(_base_)) < 1, return *+0*<sub>𝔽</sub>.\n  1. If _exponent_ is *-∞*<sub>𝔽</sub>, then\n    1. If abs(ℝ(_base_)) > 1, return *+0*<sub>𝔽</sub>.\n    1. If abs(ℝ(_base_)) = 1, return *NaN*.\n    1. If abs(ℝ(_base_)) < 1, return *+∞*<sub>𝔽</sub>.\n  1. Assert: _exponent_ is finite and is neither *+0*<sub>𝔽</sub> nor *-0*<sub>𝔽</sub>..\n  1. If _base_ < *-0*<sub>𝔽</sub> and _exponent_ is not a Number[Int], return *NaN*.\n  1. Return an implementation-approximated Number value representing the raising ℝ(_base_) to the ℝ(_exponent_) power.","code":"\n            1. If _exponent_ is *NaN*, return *NaN*.\n            1. If _exponent_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.\n            1. If _base_ is *NaN*, return *NaN*.\n            1. If _base_ is *+∞*<sub>𝔽</sub>, then\n              1. If _exponent_ > *+0*<sub>𝔽</sub>, return *+∞*<sub>𝔽</sub>. Otherwise, return *+0*<sub>𝔽</sub>.\n            1. If _base_ is *-∞*<sub>𝔽</sub>, then\n              1. If _exponent_ > *+0*<sub>𝔽</sub>, then\n                1. If _exponent_ is an odd integral Number, return *-∞*<sub>𝔽</sub>. Otherwise, return *+∞*<sub>𝔽</sub>.\n              1. Else,\n                1. If _exponent_ is an odd integral Number, return *-0*<sub>𝔽</sub>. Otherwise, return *+0*<sub>𝔽</sub>.\n            1. If _base_ is *+0*<sub>𝔽</sub>, then\n              1. If _exponent_ > *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>. Otherwise, return *+∞*<sub>𝔽</sub>.\n            1. If _base_ is *-0*<sub>𝔽</sub>, then\n              1. If _exponent_ > *+0*<sub>𝔽</sub>, then\n                1. If _exponent_ is an odd integral Number, return *-0*<sub>𝔽</sub>. Otherwise, return *+0*<sub>𝔽</sub>.\n              1. Else,\n                1. If _exponent_ is an odd integral Number, return *-∞*<sub>𝔽</sub>. Otherwise, return *+∞*<sub>𝔽</sub>.\n            1. Assert: _base_ is finite and is neither *+0*<sub>𝔽</sub> nor *-0*<sub>𝔽</sub>.\n            1. If _exponent_ is *+∞*<sub>𝔽</sub>, then\n              1. If abs(ℝ(_base_)) > 1, return *+∞*<sub>𝔽</sub>.\n              1. If abs(ℝ(_base_)) = 1, return *NaN*.\n              1. If abs(ℝ(_base_)) < 1, return *+0*<sub>𝔽</sub>.\n            1. If _exponent_ is *-∞*<sub>𝔽</sub>, then\n              1. If abs(ℝ(_base_)) > 1, return *+0*<sub>𝔽</sub>.\n              1. If abs(ℝ(_base_)) = 1, return *NaN*.\n              1. If abs(ℝ(_base_)) < 1, return *+∞*<sub>𝔽</sub>.\n            1. Assert: _exponent_ is finite and is neither *+0*<sub>𝔽</sub> nor *-0*<sub>𝔽</sub>.\n            1. If _base_ < *-0*<sub>𝔽</sub> and _exponent_ is not an integral Number, return *NaN*.\n            1. Return an implementation-approximated Number value representing the result of raising ℝ(_base_) to the ℝ(_exponent_) power.\n          "},{"head":{"NumericMethodHead":{"baseTy":"Number","name":"multiply","params":[{"name":"x","ty":"Number","kind":{"Normal":{}}},{"name":"y","ty":"Number","kind":{"Normal":{}}}],"retTy":"Number"}},"body":"\n  1. If _x_ is *NaN* or _y_ is *NaN*, return *NaN*.\n  1. If _x_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, then\n    1. If _y_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *NaN*.\n    1. If _y_ > *+0*<sub>𝔽</sub>, return _x_.\n    1. Return -_x_.\n  1. If _y_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, then\n    1. If _x_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *NaN*.\n    1. If _x_ > *+0*<sub>𝔽</sub>, return _y_.\n    1. Return -_y_.\n  1. If _x_ is *-0*<sub>𝔽</sub>, then\n    1. If _y_ is *-0*<sub>𝔽</sub> or _y_ < *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n    1. Else, return *-0*<sub>𝔽</sub>.\n  1. If _y_ is *-0*<sub>𝔽</sub>, then\n    1. If _x_ < *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n    1. Else, return *-0*<sub>𝔽</sub>.\n  1. Return 𝔽(ℝ(_x_) × ℝ(_y_)).","code":"\n            1. If _x_ is *NaN* or _y_ is *NaN*, return *NaN*.\n            1. If _x_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, then\n              1. If _y_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *NaN*.\n              1. If _y_ > *+0*<sub>𝔽</sub>, return _x_.\n              1. Return -_x_.\n            1. If _y_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, then\n              1. If _x_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *NaN*.\n              1. If _x_ > *+0*<sub>𝔽</sub>, return _y_.\n              1. Return -_y_.\n            1. If _x_ is *-0*<sub>𝔽</sub>, then\n              1. If _y_ is *-0*<sub>𝔽</sub> or _y_ < *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n              1. Else, return *-0*<sub>𝔽</sub>.\n            1. If _y_ is *-0*<sub>𝔽</sub>, then\n              1. If _x_ < *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n              1. Else, return *-0*<sub>𝔽</sub>.\n            1. Return 𝔽(ℝ(_x_) × ℝ(_y_)).\n          "},{"head":{"NumericMethodHead":{"baseTy":"Number","name":"divide","params":[{"name":"x","ty":"Number","kind":{"Normal":{}}},{"name":"y","ty":"Number","kind":{"Normal":{}}}],"retTy":"Number"}},"body":"\n  1. If _x_ is *NaN* or _y_ is *NaN*, return *NaN*.\n  1. If _x_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, then\n    1. If _y_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return *NaN*.\n    1. If _y_ is *+0*<sub>𝔽</sub> or _y_ > *+0*<sub>𝔽</sub>, return _x_.\n    1. Return -_x_.\n  1. If _y_ is *+∞*<sub>𝔽</sub>, then\n    1. If _x_ is *+0*<sub>𝔽</sub> or _x_ > *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n    1. Else, return *-0*<sub>𝔽</sub>.\n  1. If _y_ is *-∞*<sub>𝔽</sub>, then\n    1. If _x_ is *+0*<sub>𝔽</sub> or _x_ > *+0*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.\n    1. Else, return *+0*<sub>𝔽</sub>.\n  1. If _x_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, then\n    1. If _y_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *NaN*.\n    1. If _y_ > *+0*<sub>𝔽</sub>, return _x_.\n    1. Return -_x_.\n  1. If _y_ is *+0*<sub>𝔽</sub>, then\n    1. If _x_ > *+0*<sub>𝔽</sub>, return *+∞*<sub>𝔽</sub>.\n    1. Else, return *-∞*<sub>𝔽</sub>.\n  1. If _y_ is *-0*<sub>𝔽</sub>, then\n    1. If _x_ > *+0*<sub>𝔽</sub>, return *-∞*<sub>𝔽</sub>.\n    1. Else, return *+∞*<sub>𝔽</sub>.\n  1. Return 𝔽(ℝ(_x_) / ℝ(_y_)).","code":"\n            1. If _x_ is *NaN* or _y_ is *NaN*, return *NaN*.\n            1. If _x_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, then\n              1. If _y_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return *NaN*.\n              1. If _y_ is *+0*<sub>𝔽</sub> or _y_ > *+0*<sub>𝔽</sub>, return _x_.\n              1. Return -_x_.\n            1. If _y_ is *+∞*<sub>𝔽</sub>, then\n              1. If _x_ is *+0*<sub>𝔽</sub> or _x_ > *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>. Otherwise, return *-0*<sub>𝔽</sub>.\n            1. If _y_ is *-∞*<sub>𝔽</sub>, then\n              1. If _x_ is *+0*<sub>𝔽</sub> or _x_ > *+0*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>. Otherwise, return *+0*<sub>𝔽</sub>.\n            1. If _x_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, then\n              1. If _y_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *NaN*.\n              1. If _y_ > *+0*<sub>𝔽</sub>, return _x_.\n              1. Return -_x_.\n            1. If _y_ is *+0*<sub>𝔽</sub>, then\n              1. If _x_ > *+0*<sub>𝔽</sub>, return *+∞*<sub>𝔽</sub>. Otherwise, return *-∞*<sub>𝔽</sub>.\n            1. If _y_ is *-0*<sub>𝔽</sub>, then\n              1. If _x_ > *+0*<sub>𝔽</sub>, return *-∞*<sub>𝔽</sub>. Otherwise, return *+∞*<sub>𝔽</sub>.\n            1. Return 𝔽(ℝ(_x_) / ℝ(_y_)).\n          "},{"head":{"NumericMethodHead":{"baseTy":"Number","name":"remainder","params":[{"name":"n","ty":"Number","kind":{"Normal":{}}},{"name":"d","ty":"Number","kind":{"Normal":{}}}],"retTy":"Number"}},"body":"\n  1. If _n_ is *NaN* or _d_ is *NaN*, return *NaN*.\n  1. If _n_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return *NaN*.\n  1. If _d_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return _n_.\n  1. If _d_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *NaN*.\n  1. If _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return _n_.\n  1. Assert: _n_ and _d_ are finite and non-zero..\n  1. Let _quotient_ be ℝ(_n_) / ℝ(_d_).\n  1. Let _q_ be truncate(_quotient_).\n  1. Let _r_ be ℝ(_n_) - ℝ(_d_) × _q_.\n  1. If _r_ = 0 and _n_ < *-0*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.\n  1. Return 𝔽(_r_).","code":"\n            1. If _n_ is *NaN* or _d_ is *NaN*, return *NaN*.\n            1. If _n_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return *NaN*.\n            1. If _d_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return _n_.\n            1. If _d_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *NaN*.\n            1. If _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return _n_.\n            1. Assert: _n_ and _d_ are finite and non-zero.\n            1. Let _quotient_ be ℝ(_n_) / ℝ(_d_).\n            1. Let _q_ be truncate(_quotient_).\n            1. Let _r_ be ℝ(_n_) - (ℝ(_d_) × _q_).\n            1. If _r_ = 0 and _n_ < *-0*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.\n            1. Return 𝔽(_r_).\n          "},{"head":{"NumericMethodHead":{"baseTy":"Number","name":"add","params":[{"name":"x","ty":"Number","kind":{"Normal":{}}},{"name":"y","ty":"Number","kind":{"Normal":{}}}],"retTy":"Number"}},"body":"\n  1. If _x_ is *NaN* or _y_ is *NaN*, return *NaN*.\n  1. If _x_ is *+∞*<sub>𝔽</sub> and _y_ is *-∞*<sub>𝔽</sub>, return *NaN*.\n  1. If _x_ is *-∞*<sub>𝔽</sub> and _y_ is *+∞*<sub>𝔽</sub>, return *NaN*.\n  1. If _x_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return _x_.\n  1. If _y_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return _y_.\n  1. Assert: _x_ and _y_ are both finite..\n  1. If _x_ is *-0*<sub>𝔽</sub> and _y_ is *-0*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.\n  1. Return 𝔽(ℝ(_x_) + ℝ(_y_)).","code":"\n            1. If _x_ is *NaN* or _y_ is *NaN*, return *NaN*.\n            1. If _x_ is *+∞*<sub>𝔽</sub> and _y_ is *-∞*<sub>𝔽</sub>, return *NaN*.\n            1. If _x_ is *-∞*<sub>𝔽</sub> and _y_ is *+∞*<sub>𝔽</sub>, return *NaN*.\n            1. If _x_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return _x_.\n            1. If _y_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return _y_.\n            1. Assert: _x_ and _y_ are both finite.\n            1. If _x_ is *-0*<sub>𝔽</sub> and _y_ is *-0*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.\n            1. Return 𝔽(ℝ(_x_) + ℝ(_y_)).\n          "},{"head":{"NumericMethodHead":{"baseTy":"Number","name":"subtract","params":[{"name":"x","ty":"Number","kind":{"Normal":{}}},{"name":"y","ty":"Number","kind":{"Normal":{}}}],"retTy":"Number"}},"body":"\n  1. Return Number::add(_x_, Number::unaryMinus(_y_)).","code":"\n            1. Return Number::add(_x_, Number::unaryMinus(_y_)).\n          "},{"head":{"NumericMethodHead":{"baseTy":"Number","name":"leftShift","params":[{"name":"x","ty":"Number","kind":{"Normal":{}}},{"name":"y","ty":"Number","kind":{"Normal":{}}}],"retTy":"Number[Int]"}},"body":"\n  1. Let _lnum_ be ! ToInt32(_x_).\n  1. Let _rnum_ be ! ToUint32(_y_).\n  1. Let _shiftCount_ be ℝ(_rnum_) modulo 32.\n  1. Return the result of left shifting _lnum_ by _shiftCount_ bits. The mathematical value of the result is exactly representable as a 32-bit two's complement bit string.","code":"\n            1. Let _lnum_ be ! ToInt32(_x_).\n            1. Let _rnum_ be ! ToUint32(_y_).\n            1. Let _shiftCount_ be ℝ(_rnum_) modulo 32.\n            1. Return the result of left shifting _lnum_ by _shiftCount_ bits. The mathematical value of the result is exactly representable as a 32-bit two's complement bit string.\n          "},{"head":{"NumericMethodHead":{"baseTy":"Number","name":"signedRightShift","params":[{"name":"x","ty":"Number","kind":{"Normal":{}}},{"name":"y","ty":"Number","kind":{"Normal":{}}}],"retTy":"Number[Int]"}},"body":"\n  1. Let _lnum_ be ! ToInt32(_x_).\n  1. Let _rnum_ be ! ToUint32(_y_).\n  1. Let _shiftCount_ be ℝ(_rnum_) modulo 32.\n  1. Return the result of performing a sign-extending right shift of _lnum_ by _shiftCount_ bits. The most significant bit is propagated. The mathematical value of the result is exactly representable as a 32-bit two's complement bit string.","code":"\n            1. Let _lnum_ be ! ToInt32(_x_).\n            1. Let _rnum_ be ! ToUint32(_y_).\n            1. Let _shiftCount_ be ℝ(_rnum_) modulo 32.\n            1. Return the result of performing a sign-extending right shift of _lnum_ by _shiftCount_ bits. The most significant bit is propagated. The mathematical value of the result is exactly representable as a 32-bit two's complement bit string.\n          "},{"head":{"NumericMethodHead":{"baseTy":"Number","name":"unsignedRightShift","params":[{"name":"x","ty":"Number","kind":{"Normal":{}}},{"name":"y","ty":"Number","kind":{"Normal":{}}}],"retTy":"Number[Int]"}},"body":"\n  1. Let _lnum_ be ! ToUint32(_x_).\n  1. Let _rnum_ be ! ToUint32(_y_).\n  1. Let _shiftCount_ be ℝ(_rnum_) modulo 32.\n  1. Return the result of performing a zero-filling right shift of _lnum_ by _shiftCount_ bits. Vacated bits are filled with zero. The mathematical value of the result is exactly representable as a 32-bit unsigned bit string.","code":"\n            1. Let _lnum_ be ! ToUint32(_x_).\n            1. Let _rnum_ be ! ToUint32(_y_).\n            1. Let _shiftCount_ be ℝ(_rnum_) modulo 32.\n            1. Return the result of performing a zero-filling right shift of _lnum_ by _shiftCount_ bits. Vacated bits are filled with zero. The mathematical value of the result is exactly representable as a 32-bit unsigned bit string.\n          "},{"head":{"NumericMethodHead":{"baseTy":"Number","name":"lessThan","params":[{"name":"x","ty":"Number","kind":{"Normal":{}}},{"name":"y","ty":"Number","kind":{"Normal":{}}}],"retTy":"Boolean | Undefined"}},"body":"\n  1. If _x_ is *NaN*, return *undefined*.\n  1. If _y_ is *NaN*, return *undefined*.\n  1. If _x_ is _y_, return *false*.\n  1. If _x_ is *+0*<sub>𝔽</sub> and _y_ is *-0*<sub>𝔽</sub>, return *false*.\n  1. If _x_ is *-0*<sub>𝔽</sub> and _y_ is *+0*<sub>𝔽</sub>, return *false*.\n  1. If _x_ is *+∞*<sub>𝔽</sub>, return *false*.\n  1. If _y_ is *+∞*<sub>𝔽</sub>, return *true*.\n  1. If _y_ is *-∞*<sub>𝔽</sub>, return *false*.\n  1. If _x_ is *-∞*<sub>𝔽</sub>, return *true*.\n  1. Assert: _x_ and _y_ are finite..\n  1. If ℝ(_x_) < ℝ(_y_), return *true*.\n  1. Else, return *false*.","code":"\n            1. If _x_ is *NaN*, return *undefined*.\n            1. If _y_ is *NaN*, return *undefined*.\n            1. If _x_ is _y_, return *false*.\n            1. If _x_ is *+0*<sub>𝔽</sub> and _y_ is *-0*<sub>𝔽</sub>, return *false*.\n            1. If _x_ is *-0*<sub>𝔽</sub> and _y_ is *+0*<sub>𝔽</sub>, return *false*.\n            1. If _x_ is *+∞*<sub>𝔽</sub>, return *false*.\n            1. If _y_ is *+∞*<sub>𝔽</sub>, return *true*.\n            1. If _y_ is *-∞*<sub>𝔽</sub>, return *false*.\n            1. If _x_ is *-∞*<sub>𝔽</sub>, return *true*.\n            1. Assert: _x_ and _y_ are finite.\n            1. If ℝ(_x_) < ℝ(_y_), return *true*. Otherwise, return *false*.\n          "},{"head":{"NumericMethodHead":{"baseTy":"Number","name":"equal","params":[{"name":"x","ty":"Number","kind":{"Normal":{}}},{"name":"y","ty":"Number","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _x_ is *NaN*, return *false*.\n  1. If _y_ is *NaN*, return *false*.\n  1. If _x_ is _y_, return *true*.\n  1. If _x_ is *+0*<sub>𝔽</sub> and _y_ is *-0*<sub>𝔽</sub>, return *true*.\n  1. If _x_ is *-0*<sub>𝔽</sub> and _y_ is *+0*<sub>𝔽</sub>, return *true*.\n  1. Return *false*.","code":"\n            1. If _x_ is *NaN*, return *false*.\n            1. If _y_ is *NaN*, return *false*.\n            1. If _x_ is _y_, return *true*.\n            1. If _x_ is *+0*<sub>𝔽</sub> and _y_ is *-0*<sub>𝔽</sub>, return *true*.\n            1. If _x_ is *-0*<sub>𝔽</sub> and _y_ is *+0*<sub>𝔽</sub>, return *true*.\n            1. Return *false*.\n          "},{"head":{"NumericMethodHead":{"baseTy":"Number","name":"sameValue","params":[{"name":"x","ty":"Number","kind":{"Normal":{}}},{"name":"y","ty":"Number","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _x_ is *NaN* and _y_ is *NaN*, return *true*.\n  1. If _x_ is *+0*<sub>𝔽</sub> and _y_ is *-0*<sub>𝔽</sub>, return *false*.\n  1. If _x_ is *-0*<sub>𝔽</sub> and _y_ is *+0*<sub>𝔽</sub>, return *false*.\n  1. If _x_ is _y_, return *true*.\n  1. Return *false*.","code":"\n            1. If _x_ is *NaN* and _y_ is *NaN*, return *true*.\n            1. If _x_ is *+0*<sub>𝔽</sub> and _y_ is *-0*<sub>𝔽</sub>, return *false*.\n            1. If _x_ is *-0*<sub>𝔽</sub> and _y_ is *+0*<sub>𝔽</sub>, return *false*.\n            1. If _x_ is _y_, return *true*.\n            1. Return *false*.\n          "},{"head":{"NumericMethodHead":{"baseTy":"Number","name":"sameValueZero","params":[{"name":"x","ty":"Number","kind":{"Normal":{}}},{"name":"y","ty":"Number","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _x_ is *NaN* and _y_ is *NaN*, return *true*.\n  1. If _x_ is *+0*<sub>𝔽</sub> and _y_ is *-0*<sub>𝔽</sub>, return *true*.\n  1. If _x_ is *-0*<sub>𝔽</sub> and _y_ is *+0*<sub>𝔽</sub>, return *true*.\n  1. If _x_ is _y_, return *true*.\n  1. Return *false*.","code":"\n            1. If _x_ is *NaN* and _y_ is *NaN*, return *true*.\n            1. If _x_ is *+0*<sub>𝔽</sub> and _y_ is *-0*<sub>𝔽</sub>, return *true*.\n            1. If _x_ is *-0*<sub>𝔽</sub> and _y_ is *+0*<sub>𝔽</sub>, return *true*.\n            1. If _x_ is _y_, return *true*.\n            1. Return *false*.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"NumberBitwiseOp","params":[{"name":"op","ty":"Unknown[\"`&`, `^`, or `|`\"]","kind":{"Normal":{}}},{"name":"x","ty":"Number","kind":{"Normal":{}}},{"name":"y","ty":"Number","kind":{"Normal":{}}}],"retTy":"Number[Int]"}},"body":"\n  1. Let _lnum_ be ! ToInt32(_x_).\n  1. Let _rnum_ be ! ToInt32(_y_).\n  1. Let _lbits_ be ℝ(_lnum_).\n  1. Let _rbits_ be ℝ(_rnum_).\n  1. If _op_ is `&`, then\n    1. Let _result_ be the result of applying the bitwise AND operation to _lbits_ and _rbits_.\n  1. Else if _op_ is `^`, then\n    1. Let _result_ be the result of applying the bitwise exclusive OR (XOR) operation to _lbits_ and _rbits_.\n  1. Else,\n    1. Assert: _op_ is `|`.\n    1. Let _result_ be the result of applying the bitwise inclusive OR operation to _lbits_ and _rbits_.\n  1. Return the Number value for the integer represented by the 32-bit two's complement bit string _result_.","code":"\n            1. Let _lnum_ be ! ToInt32(_x_).\n            1. Let _rnum_ be ! ToInt32(_y_).\n            1. Let _lbits_ be the 32-bit two's complement bit string representing ℝ(_lnum_).\n            1. Let _rbits_ be the 32-bit two's complement bit string representing ℝ(_rnum_).\n            1. If _op_ is `&`, then\n              1. Let _result_ be the result of applying the bitwise AND operation to _lbits_ and _rbits_.\n            1. Else if _op_ is `^`, then\n              1. Let _result_ be the result of applying the bitwise exclusive OR (XOR) operation to _lbits_ and _rbits_.\n            1. Else,\n              1. Assert: _op_ is `|`.\n              1. Let _result_ be the result of applying the bitwise inclusive OR operation to _lbits_ and _rbits_.\n            1. Return the Number value for the integer represented by the 32-bit two's complement bit string _result_.\n          "},{"head":{"NumericMethodHead":{"baseTy":"Number","name":"bitwiseAND","params":[{"name":"x","ty":"Number","kind":{"Normal":{}}},{"name":"y","ty":"Number","kind":{"Normal":{}}}],"retTy":"Number[Int]"}},"body":"\n  1. Return NumberBitwiseOp(`&`, _x_, _y_).","code":"\n            1. Return NumberBitwiseOp(`&`, _x_, _y_).\n          "},{"head":{"NumericMethodHead":{"baseTy":"Number","name":"bitwiseXOR","params":[{"name":"x","ty":"Number","kind":{"Normal":{}}},{"name":"y","ty":"Number","kind":{"Normal":{}}}],"retTy":"Number[Int]"}},"body":"\n  1. Return NumberBitwiseOp(`^`, _x_, _y_).","code":"\n            1. Return NumberBitwiseOp(`^`, _x_, _y_).\n          "},{"head":{"NumericMethodHead":{"baseTy":"Number","name":"bitwiseOR","params":[{"name":"x","ty":"Number","kind":{"Normal":{}}},{"name":"y","ty":"Number","kind":{"Normal":{}}}],"retTy":"Number[Int]"}},"body":"\n  1. Return NumberBitwiseOp(`|`, _x_, _y_).","code":"\n            1. Return NumberBitwiseOp(`|`, _x_, _y_).\n          "},{"head":{"NumericMethodHead":{"baseTy":"Number","name":"toString","params":[{"name":"x","ty":"Number","kind":{"Normal":{}}},{"name":"radix","ty":"Unknown[\"an integer in the inclusive interval from 2 to 36\"]","kind":{"Normal":{}}}],"retTy":"String"}},"body":"\n  1. If _x_ is *NaN*, return *\"NaN\"*.\n  1. If _x_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *\"0\"*.\n  1. If _x_ < *-0*<sub>𝔽</sub>, return the string-concatenation of *\"-\"* and Number::toString(-_x_, _radix_).\n  1. If _x_ is *+∞*<sub>𝔽</sub>, return *\"Infinity\"*.\n  1. [id=\"step-number-tostring-intermediate-values\"] Let _n_, _k_, and _s_ be integers such that _k_ ≥ 1, _radix_<sup>_k_ - 1</sup> ≤ _s_ < _radix_<sup>_k_</sup>, 𝔽(_s_ × _radix_<sup>_n_ - _k_</sup>) is _x_, and _k_ is as small as possible. Note that _k_ is the number of digits in the representation of _s_ using radix _radix_, that _s_ is not divisible by _radix_, and that the least significant digit of _s_ is not necessarily uniquely determined by these criteria.\n  1. If _radix_ ≠ 10 or _n_ is in the inclusive interval from -5 to 21, then\n    1. If _n_ ≥ _k_, then\n      1. Return the string-concatenation of:\n        * the code units of the _k_ digits of the representation of _s_ using radix _radix_\n        * _n_ - _k_ occurrences of the code unit 0x0030 (DIGIT ZERO)\n    1. Else if _n_ > 0, then\n      1. Return the string-concatenation of:\n        * the code units of the most significant _n_ digits of the representation of _s_ using radix _radix_\n        * 0x002e (FULL STOP)\n        * the code units of the remaining _k_ - _n_ digits of the representation of _s_ using radix _radix_\n    1. Else,\n      1. Assert: _n_ ≤ 0.\n      1. Return the string-concatenation of:\n        * 0x0030 (DIGIT ZERO)\n        * 0x002e (FULL STOP)\n        * -_n_ occurrences of the code unit 0x0030 (DIGIT ZERO)\n        * the code units of the _k_ digits of the representation of _s_ using radix _radix_\n  1. NOTE: In this case, the input will be represented using scientific E notation, such as `1.2e+3`.\n  1. Assert: _radix_ is 10.\n  1. If _n_ < 0, then\n    1. Let _exponentSign_ be the code unit 0x002D (HYPHEN-MINUS).\n  1. Else,\n    1. Let _exponentSign_ be 0x002b (PLUS SIGN).\n  1. If _k_ = 1, then\n    1. Return the string-concatenation of:\n      * the code unit of the single digit of _s_\n      * 0x0065 (LATIN SMALL LETTER E)\n      * _exponentSign_\n      * the code units of the decimal representation of abs(_n_ - 1)\n  1. Return the string-concatenation of:\n    * the code unit of the most significant digit of the decimal representation of _s_\n    * 0x002e (FULL STOP)\n    * the code units of the remaining _k_ - 1 digits of the decimal representation of _s_\n    * 0x0065 (LATIN SMALL LETTER E)\n    * _exponentSign_\n    * the code units of the decimal representation of abs(_n_ - 1)","code":"\n            1. If _x_ is *NaN*, return *\"NaN\"*.\n            1. If _x_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *\"0\"*.\n            1. If _x_ < *-0*<sub>𝔽</sub>, return the string-concatenation of *\"-\"* and Number::toString(-_x_, _radix_).\n            1. If _x_ is *+∞*<sub>𝔽</sub>, return *\"Infinity\"*.\n            1. [id=\"step-number-tostring-intermediate-values\"] Let _n_, _k_, and _s_ be integers such that _k_ ≥ 1, _radix_<sup>_k_ - 1</sup> ≤ _s_ < _radix_<sup>_k_</sup>, 𝔽(_s_ × _radix_<sup>_n_ - _k_</sup>) is _x_, and _k_ is as small as possible. Note that _k_ is the number of digits in the representation of _s_ using radix _radix_, that _s_ is not divisible by _radix_, and that the least significant digit of _s_ is not necessarily uniquely determined by these criteria.\n            1. If _radix_ ≠ 10 or _n_ is in the inclusive interval from -5 to 21, then\n              1. If _n_ ≥ _k_, then\n                1. Return the string-concatenation of:\n                  * the code units of the _k_ digits of the representation of _s_ using radix _radix_\n                  * _n_ - _k_ occurrences of the code unit 0x0030 (DIGIT ZERO)\n              1. Else if _n_ > 0, then\n                1. Return the string-concatenation of:\n                  * the code units of the most significant _n_ digits of the representation of _s_ using radix _radix_\n                  * the code unit 0x002E (FULL STOP)\n                  * the code units of the remaining _k_ - _n_ digits of the representation of _s_ using radix _radix_\n              1. Else,\n                1. Assert: _n_ ≤ 0.\n                1. Return the string-concatenation of:\n                  * the code unit 0x0030 (DIGIT ZERO)\n                  * the code unit 0x002E (FULL STOP)\n                  * -_n_ occurrences of the code unit 0x0030 (DIGIT ZERO)\n                  * the code units of the _k_ digits of the representation of _s_ using radix _radix_\n            1. NOTE: In this case, the input will be represented using scientific E notation, such as `1.2e+3`.\n            1. Assert: _radix_ is 10.\n            1. If _n_ < 0, then\n              1. Let _exponentSign_ be the code unit 0x002D (HYPHEN-MINUS).\n            1. Else,\n              1. Let _exponentSign_ be the code unit 0x002B (PLUS SIGN).\n            1. If _k_ = 1, then\n              1. Return the string-concatenation of:\n                * the code unit of the single digit of _s_\n                * the code unit 0x0065 (LATIN SMALL LETTER E)\n                * _exponentSign_\n                * the code units of the decimal representation of abs(_n_ - 1)\n            1. Return the string-concatenation of:\n              * the code unit of the most significant digit of the decimal representation of _s_\n              * the code unit 0x002E (FULL STOP)\n              * the code units of the remaining _k_ - 1 digits of the decimal representation of _s_\n              * the code unit 0x0065 (LATIN SMALL LETTER E)\n              * _exponentSign_\n              * the code units of the decimal representation of abs(_n_ - 1)\n          "},{"head":{"NumericMethodHead":{"baseTy":"BigInt","name":"unaryMinus","params":[{"name":"x","ty":"BigInt","kind":{"Normal":{}}}],"retTy":"BigInt"}},"body":"\n  1. If _x_ is *0*<sub>ℤ</sub>, return *0*<sub>ℤ</sub>.\n  1. Return -_x_.","code":"\n            1. If _x_ is *0*<sub>ℤ</sub>, return *0*<sub>ℤ</sub>.\n            1. Return -_x_.\n          "},{"head":{"NumericMethodHead":{"baseTy":"BigInt","name":"bitwiseNOT","params":[{"name":"x","ty":"BigInt","kind":{"Normal":{}}}],"retTy":"BigInt"}},"body":"\n  1. Return -_x_ - *1*<sub>ℤ</sub>.","code":"\n            1. Return -_x_ - *1*<sub>ℤ</sub>.\n          "},{"head":{"NumericMethodHead":{"baseTy":"BigInt","name":"exponentiate","params":[{"name":"base","ty":"BigInt","kind":{"Normal":{}}},{"name":"exponent","ty":"BigInt","kind":{"Normal":{}}}],"retTy":"Normal[BigInt] | Throw"}},"body":"\n  1. If _exponent_ < *0*<sub>ℤ</sub>, throw a *RangeError* exception.\n  1. If _base_ is *0*<sub>ℤ</sub> and _exponent_ is *0*<sub>ℤ</sub>, return *1*<sub>ℤ</sub>.\n  1. Return the raising _base_ to the _exponent_ power.","code":"\n            1. If _exponent_ < *0*<sub>ℤ</sub>, throw a *RangeError* exception.\n            1. If _base_ is *0*<sub>ℤ</sub> and _exponent_ is *0*<sub>ℤ</sub>, return *1*<sub>ℤ</sub>.\n            1. Return _base_ raised to the power _exponent_.\n          "},{"head":{"NumericMethodHead":{"baseTy":"BigInt","name":"multiply","params":[{"name":"x","ty":"BigInt","kind":{"Normal":{}}},{"name":"y","ty":"BigInt","kind":{"Normal":{}}}],"retTy":"BigInt"}},"body":"\n  1. Return _x_ × _y_.","code":"\n            1. Return _x_ × _y_.\n          "},{"head":{"NumericMethodHead":{"baseTy":"BigInt","name":"divide","params":[{"name":"x","ty":"BigInt","kind":{"Normal":{}}},{"name":"y","ty":"BigInt","kind":{"Normal":{}}}],"retTy":"Normal[BigInt] | Throw"}},"body":"\n  1. If _y_ is *0*<sub>ℤ</sub>, throw a *RangeError* exception.\n  1. Let _quotient_ be ℝ(_x_) / ℝ(_y_).\n  1. Return ℤ(truncate(_quotient_)).","code":"\n            1. If _y_ is *0*<sub>ℤ</sub>, throw a *RangeError* exception.\n            1. Let _quotient_ be ℝ(_x_) / ℝ(_y_).\n            1. Return ℤ(truncate(_quotient_)).\n          "},{"head":{"NumericMethodHead":{"baseTy":"BigInt","name":"remainder","params":[{"name":"n","ty":"BigInt","kind":{"Normal":{}}},{"name":"d","ty":"BigInt","kind":{"Normal":{}}}],"retTy":"Normal[BigInt] | Throw"}},"body":"\n  1. If _d_ is *0*<sub>ℤ</sub>, throw a *RangeError* exception.\n  1. If _n_ is *0*<sub>ℤ</sub>, return *0*<sub>ℤ</sub>.\n  1. Let _quotient_ be ℝ(_n_) / ℝ(_d_).\n  1. Let _q_ be ℤ(truncate(_quotient_)).\n  1. Return _n_ - _d_ × _q_.","code":"\n            1. If _d_ is *0*<sub>ℤ</sub>, throw a *RangeError* exception.\n            1. If _n_ is *0*<sub>ℤ</sub>, return *0*<sub>ℤ</sub>.\n            1. Let _quotient_ be ℝ(_n_) / ℝ(_d_).\n            1. Let _q_ be ℤ(truncate(_quotient_)).\n            1. Return _n_ - (_d_ × _q_).\n          "},{"head":{"NumericMethodHead":{"baseTy":"BigInt","name":"add","params":[{"name":"x","ty":"BigInt","kind":{"Normal":{}}},{"name":"y","ty":"BigInt","kind":{"Normal":{}}}],"retTy":"BigInt"}},"body":"\n  1. Return _x_ + _y_.","code":"\n            1. Return _x_ + _y_.\n          "},{"head":{"NumericMethodHead":{"baseTy":"BigInt","name":"subtract","params":[{"name":"x","ty":"BigInt","kind":{"Normal":{}}},{"name":"y","ty":"BigInt","kind":{"Normal":{}}}],"retTy":"BigInt"}},"body":"\n  1. Return _x_ - _y_.","code":"\n            1. Return _x_ - _y_.\n          "},{"head":{"NumericMethodHead":{"baseTy":"BigInt","name":"leftShift","params":[{"name":"x","ty":"BigInt","kind":{"Normal":{}}},{"name":"y","ty":"BigInt","kind":{"Normal":{}}}],"retTy":"BigInt"}},"body":"\n  1. If _y_ < *0*<sub>ℤ</sub>, then\n    1. Return ℤ(floor(ℝ(_x_) / 2<sup>(-ℝ(_y_))</sup>)).\n  1. Return _x_ × *2*<sub>ℤ</sub><sup>_y_</sup>.","code":"\n            1. If _y_ < *0*<sub>ℤ</sub>, then\n              1. Return ℤ(floor(ℝ(_x_) / 2<sup>-ℝ(_y_)</sup>)).\n            1. Return _x_ × *2*<sub>ℤ</sub><sup>_y_</sup>.\n          "},{"head":{"NumericMethodHead":{"baseTy":"BigInt","name":"signedRightShift","params":[{"name":"x","ty":"BigInt","kind":{"Normal":{}}},{"name":"y","ty":"BigInt","kind":{"Normal":{}}}],"retTy":"BigInt"}},"body":"\n  1. Return BigInt::leftShift(_x_, -_y_).","code":"\n            1. Return BigInt::leftShift(_x_, -_y_).\n          "},{"head":{"NumericMethodHead":{"baseTy":"BigInt","name":"unsignedRightShift","params":[{"name":"x","ty":"BigInt","kind":{"Normal":{}}},{"name":"y","ty":"BigInt","kind":{"Normal":{}}}],"retTy":"Throw"}},"body":"\n  1. Throw a *TypeError* exception.","code":"\n            1. Throw a *TypeError* exception.\n          "},{"head":{"NumericMethodHead":{"baseTy":"BigInt","name":"lessThan","params":[{"name":"x","ty":"BigInt","kind":{"Normal":{}}},{"name":"y","ty":"BigInt","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If ℝ(_x_) < ℝ(_y_), return *true*.\n  1. Else, return *false*.","code":"\n            1. If ℝ(_x_) < ℝ(_y_), return *true*; otherwise return *false*.\n          "},{"head":{"NumericMethodHead":{"baseTy":"BigInt","name":"equal","params":[{"name":"x","ty":"BigInt","kind":{"Normal":{}}},{"name":"y","ty":"BigInt","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If ℝ(_x_) = ℝ(_y_), return *true*.\n  1. Else, return *false*.","code":"\n            1. If ℝ(_x_) = ℝ(_y_), return *true*; otherwise return *false*.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"BinaryAnd","params":[{"name":"x","ty":"Math[0, 1]","kind":{"Normal":{}}},{"name":"y","ty":"Math[0, 1]","kind":{"Normal":{}}}],"retTy":"Math[0, 1]"}},"body":"\n  1. If _x_ = 1 and _y_ = 1, return 1.\n  1. Else, return 0.","code":"\n            1. If _x_ = 1 and _y_ = 1, return 1.\n            1. Else, return 0.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"BinaryOr","params":[{"name":"x","ty":"Math[0, 1]","kind":{"Normal":{}}},{"name":"y","ty":"Math[0, 1]","kind":{"Normal":{}}}],"retTy":"Math[0, 1]"}},"body":"\n  1. If _x_ = 1 or _y_ = 1, return 1.\n  1. Else, return 0.","code":"\n            1. If _x_ = 1 or _y_ = 1, return 1.\n            1. Else, return 0.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"BinaryXor","params":[{"name":"x","ty":"Math[0, 1]","kind":{"Normal":{}}},{"name":"y","ty":"Math[0, 1]","kind":{"Normal":{}}}],"retTy":"Math[0, 1]"}},"body":"\n  1. If _x_ = 1 and _y_ = 0, return 1.\n  1. Else if _x_ = 0 and _y_ = 1, return 1.\n  1. Else, return 0.","code":"\n            1. If _x_ = 1 and _y_ = 0, return 1.\n            1. Else if _x_ = 0 and _y_ = 1, return 1.\n            1. Else, return 0.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"BigIntBitwiseOp","params":[{"name":"op","ty":"Unknown[\"`&`, `^`, or `|`\"]","kind":{"Normal":{}}},{"name":"x","ty":"BigInt","kind":{"Normal":{}}},{"name":"y","ty":"BigInt","kind":{"Normal":{}}}],"retTy":"BigInt"}},"body":"\n  1. Set _x_ to ℝ(_x_).\n  1. Set _y_ to ℝ(_y_).\n  1. Let _result_ be 0.\n  1. Let _shift_ be 0.\n  1. Repeat, until (_x_ = 0 or _x_ = -1) and (_y_ = 0 or _y_ = -1),\n    1. Let _xDigit_ be _x_ modulo 2.\n    1. Let _yDigit_ be _y_ modulo 2.\n    1. If _op_ is `&`, then\n      1. Set _result_ to _result_ + 2<sup>_shift_</sup> × BinaryAnd(_xDigit_, _yDigit_).\n    1. Else if _op_ is `|`, then\n      1. Set _result_ to _result_ + 2<sup>_shift_</sup> × BinaryOr(_xDigit_, _yDigit_).\n    1. Else,\n      1. Assert: _op_ is `^`.\n      1. Set _result_ to _result_ + 2<sup>_shift_</sup> × BinaryXor(_xDigit_, _yDigit_).\n    1. Set _shift_ to _shift_ + 1.\n    1. Set _x_ to (_x_ - _xDigit_) / 2.\n    1. Set _y_ to (_y_ - _yDigit_) / 2.\n  1. If _op_ is `&`, then\n    1. Let _tmp_ be BinaryAnd(_x_ modulo 2, _y_ modulo 2).\n  1. Else if _op_ is `|`, then\n    1. Let _tmp_ be BinaryOr(_x_ modulo 2, _y_ modulo 2).\n  1. Else,\n    1. Assert: _op_ is `^`.\n    1. Let _tmp_ be BinaryXor(_x_ modulo 2, _y_ modulo 2).\n  1. If _tmp_ ≠ 0, then\n    1. Set _result_ to _result_ - 2<sup>_shift_</sup>.\n    1. NOTE: This extends the sign.\n  1. Return ℤ(_result_).","code":"\n            1. Set _x_ to ℝ(_x_).\n            1. Set _y_ to ℝ(_y_).\n            1. Let _result_ be 0.\n            1. Let _shift_ be 0.\n            1. Repeat, until (_x_ = 0 or _x_ = -1) and (_y_ = 0 or _y_ = -1),\n              1. Let _xDigit_ be _x_ modulo 2.\n              1. Let _yDigit_ be _y_ modulo 2.\n              1. If _op_ is `&`, then\n                1. Set _result_ to _result_ + 2<sup>_shift_</sup> × BinaryAnd(_xDigit_, _yDigit_).\n              1. Else if _op_ is `|`, then\n                1. Set _result_ to _result_ + 2<sup>_shift_</sup> × BinaryOr(_xDigit_, _yDigit_).\n              1. Else,\n                1. Assert: _op_ is `^`.\n                1. Set _result_ to _result_ + 2<sup>_shift_</sup> × BinaryXor(_xDigit_, _yDigit_).\n              1. Set _shift_ to _shift_ + 1.\n              1. Set _x_ to (_x_ - _xDigit_) / 2.\n              1. Set _y_ to (_y_ - _yDigit_) / 2.\n            1. If _op_ is `&`, then\n              1. Let _tmp_ be BinaryAnd(_x_ modulo 2, _y_ modulo 2).\n            1. Else if _op_ is `|`, then\n              1. Let _tmp_ be BinaryOr(_x_ modulo 2, _y_ modulo 2).\n            1. Else,\n              1. Assert: _op_ is `^`.\n              1. Let _tmp_ be BinaryXor(_x_ modulo 2, _y_ modulo 2).\n            1. If _tmp_ ≠ 0, then\n              1. Set _result_ to _result_ - 2<sup>_shift_</sup>.\n              1. NOTE: This extends the sign.\n            1. Return the BigInt value for _result_.\n          "},{"head":{"NumericMethodHead":{"baseTy":"BigInt","name":"bitwiseAND","params":[{"name":"x","ty":"BigInt","kind":{"Normal":{}}},{"name":"y","ty":"BigInt","kind":{"Normal":{}}}],"retTy":"BigInt"}},"body":"\n  1. Return BigIntBitwiseOp(`&`, _x_, _y_).","code":"\n            1. Return BigIntBitwiseOp(`&`, _x_, _y_).\n          "},{"head":{"NumericMethodHead":{"baseTy":"BigInt","name":"bitwiseXOR","params":[{"name":"x","ty":"BigInt","kind":{"Normal":{}}},{"name":"y","ty":"BigInt","kind":{"Normal":{}}}],"retTy":"BigInt"}},"body":"\n  1. Return BigIntBitwiseOp(`^`, _x_, _y_).","code":"\n            1. Return BigIntBitwiseOp(`^`, _x_, _y_).\n          "},{"head":{"NumericMethodHead":{"baseTy":"BigInt","name":"bitwiseOR","params":[{"name":"x","ty":"BigInt","kind":{"Normal":{}}},{"name":"y","ty":"BigInt","kind":{"Normal":{}}}],"retTy":"BigInt"}},"body":"\n  1. Return BigIntBitwiseOp(`|`, _x_, _y_).","code":"\n            1. Return BigIntBitwiseOp(`|`, _x_, _y_).\n          "},{"head":{"NumericMethodHead":{"baseTy":"BigInt","name":"toString","params":[{"name":"x","ty":"BigInt","kind":{"Normal":{}}},{"name":"radix","ty":"Unknown[\"an integer in the inclusive interval from 2 to 36\"]","kind":{"Normal":{}}}],"retTy":"String"}},"body":"\n  1. If _x_ < *0*<sub>ℤ</sub>, return the string-concatenation of *\"-\"* and BigInt::toString(-_x_, _radix_).\n  1. Return the String value consisting of the representation of _x_ using radix _radix_.","code":"\n            1. If _x_ < *0*<sub>ℤ</sub>, return the string-concatenation of *\"-\"* and BigInt::toString(-_x_, _radix_).\n            1. Return the String value consisting of the representation of _x_ using radix _radix_.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"NormalCompletion","params":[{"name":"value","ty":"Unknown[\"any value except a Completion Record\"]","kind":{"Normal":{}}}],"retTy":"Normal"}},"body":"\n  1. Return Completion Record { [[Type]]: ~normal~, [[Value]]: _value_, [[Target]]: ~empty~ }.","code":"\n          1. Return Completion Record { [[Type]]: ~normal~, [[Value]]: _value_, [[Target]]: ~empty~ }.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ThrowCompletion","params":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Throw"}},"body":"\n  1. Return Completion Record { [[Type]]: ~throw~, [[Value]]: _value_, [[Target]]: ~empty~ }.","code":"\n          1. Return Completion Record { [[Type]]: ~throw~, [[Value]]: _value_, [[Target]]: ~empty~ }.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"UpdateEmpty","params":[{"name":"completionRecord","ty":"Completion","kind":{"Normal":{}}},{"name":"value","ty":"Unknown[\"any value except a Completion Record\"]","kind":{"Normal":{}}}],"retTy":"Completion"}},"body":"\n  1. Assert: If _completionRecord_ is either a Return or a Throw, then _completionRecord_.[[Value]] is not ~empty~.\n  1. If _completionRecord_.[[Value]] is not ~empty~, return ? _completionRecord_.\n  1. Return Completion Record { [[Type]]: _completionRecord_.[[Type]], [[Value]]: _value_, [[Target]]: _completionRecord_.[[Target]] }.","code":"\n          1. Assert: If _completionRecord_ is either a return completion or a throw completion, then _completionRecord_.[[Value]] is not ~empty~.\n          1. If _completionRecord_.[[Value]] is not ~empty~, return ? _completionRecord_.\n          1. Return Completion Record { [[Type]]: _completionRecord_.[[Type]], [[Value]]: _value_, [[Target]]: _completionRecord_.[[Target]] }.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsPropertyReference","params":[{"name":"V","ty":"Record[ReferenceRecord]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _V_.[[Base]] is ~unresolvable~, return *false*.\n  1. If _V_.[[Base]] is a Record[EnvironmentRecord], return *false*.\n  1. Else, return *true*.","code":"\n          1. If _V_.[[Base]] is ~unresolvable~, return *false*.\n          1. If _V_.[[Base]] is an Environment Record, return *false*; otherwise return *true*.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsUnresolvableReference","params":[{"name":"V","ty":"Record[ReferenceRecord]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _V_.[[Base]] is ~unresolvable~, return *true*.\n  1. Else, return *false*.","code":"\n          1. If _V_.[[Base]] is ~unresolvable~, return *true*; otherwise return *false*.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsSuperReference","params":[{"name":"V","ty":"Record[ReferenceRecord]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _V_.[[ThisValue]] is not ~empty~, return *true*.\n  1. Else, return *false*.","code":"\n          1. If _V_.[[ThisValue]] is not ~empty~, return *true*; otherwise return *false*.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsPrivateReference","params":[{"name":"V","ty":"Record[ReferenceRecord]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _V_.[[ReferencedName]] is a Record[PrivateName], return *true*.\n  1. Else, return *false*.","code":"\n          1. If _V_.[[ReferencedName]] is a Private Name, return *true*; otherwise return *false*.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetValue","params":[{"name":"V","ty":"ESValue | Record[ReferenceRecord]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. If _V_ is not a Record[ReferenceRecord], return _V_.\n  1. If IsUnresolvableReference(_V_) is *true*, throw a *ReferenceError* exception.\n  1. If IsPropertyReference(_V_) is *true*, then\n    1. [id=\"step-getvalue-toobject\"] Let _baseObj_ be ? ToObject(_V_.[[Base]]).\n    1. If IsPrivateReference(_V_) is *true*, then\n      1. Return ? PrivateGet(_baseObj_, _V_.[[ReferencedName]]).\n    1. Return ? _baseObj_.[[Get]](_V_.[[ReferencedName]], GetThisValue(_V_)).\n  1. Else,\n    1. Let _base_ be _V_.[[Base]].\n    1. Assert: _base_ is a Record[EnvironmentRecord].\n    1. Return ? _base_.GetBindingValue(_V_.[[ReferencedName]], _V_.[[Strict]]).","code":"\n          1. If _V_ is not a Reference Record, return _V_.\n          1. If IsUnresolvableReference(_V_) is *true*, throw a *ReferenceError* exception.\n          1. If IsPropertyReference(_V_) is *true*, then\n            1. [id=\"step-getvalue-toobject\"] Let _baseObj_ be ? ToObject(_V_.[[Base]]).\n            1. If IsPrivateReference(_V_) is *true*, then\n              1. Return ? PrivateGet(_baseObj_, _V_.[[ReferencedName]]).\n            1. Return ? <emu-meta effects=\"user-code\">_baseObj_.[[Get]]</emu-meta>(_V_.[[ReferencedName]], GetThisValue(_V_)).\n          1. Else,\n            1. Let _base_ be _V_.[[Base]].\n            1. Assert: _base_ is an Environment Record.\n            1. Return ? <emu-meta effects=\"user-code\">_base_.GetBindingValue</emu-meta>(_V_.[[ReferencedName]], _V_.[[Strict]]) (see <emu-xref href=\"#sec-environment-records\"></emu-xref>).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"PutValue","params":[{"name":"V","ty":"ESValue | Record[ReferenceRecord]","kind":{"Normal":{}}},{"name":"W","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. If _V_ is not a Record[ReferenceRecord], throw a *ReferenceError* exception.\n  1. If IsUnresolvableReference(_V_) is *true*, then\n    1. If _V_.[[Strict]] is *true*, throw a *ReferenceError* exception.\n    1. Let _globalObj_ be GetGlobalObject().\n    1. Perform ? Set(_globalObj_, _V_.[[ReferencedName]], _W_, *false*).\n    1. Return ~unused~.\n  1. If IsPropertyReference(_V_) is *true*, then\n    1. [id=\"step-putvalue-toobject\"] Let _baseObj_ be ? ToObject(_V_.[[Base]]).\n    1. If IsPrivateReference(_V_) is *true*, then\n      1. Return ? PrivateSet(_baseObj_, _V_.[[ReferencedName]], _W_).\n    1. Let _succeeded_ be ? _baseObj_.[[Set]](_V_.[[ReferencedName]], _W_, GetThisValue(_V_)).\n    1. If _succeeded_ is *false* and _V_.[[Strict]] is *true*, throw a *TypeError* exception.\n    1. Return ~unused~.\n  1. Else,\n    1. Let _base_ be _V_.[[Base]].\n    1. Assert: _base_ is a Record[EnvironmentRecord].\n    1. Return ? _base_.SetMutableBinding(_V_.[[ReferencedName]], _W_, _V_.[[Strict]]).","code":"\n          1. If _V_ is not a Reference Record, throw a *ReferenceError* exception.\n          1. If IsUnresolvableReference(_V_) is *true*, then\n            1. If _V_.[[Strict]] is *true*, throw a *ReferenceError* exception.\n            1. Let _globalObj_ be GetGlobalObject().\n            1. Perform ? Set(_globalObj_, _V_.[[ReferencedName]], _W_, *false*).\n            1. Return ~unused~.\n          1. If IsPropertyReference(_V_) is *true*, then\n            1. [id=\"step-putvalue-toobject\"] Let _baseObj_ be ? ToObject(_V_.[[Base]]).\n            1. If IsPrivateReference(_V_) is *true*, then\n              1. Return ? PrivateSet(_baseObj_, _V_.[[ReferencedName]], _W_).\n            1. Let _succeeded_ be ? <emu-meta effects=\"user-code\">_baseObj_.[[Set]]</emu-meta>(_V_.[[ReferencedName]], _W_, GetThisValue(_V_)).\n            1. If _succeeded_ is *false* and _V_.[[Strict]] is *true*, throw a *TypeError* exception.\n            1. Return ~unused~.\n          1. Else,\n            1. Let _base_ be _V_.[[Base]].\n            1. Assert: _base_ is an Environment Record.\n            1. Return ? <emu-meta effects=\"user-code\">_base_.SetMutableBinding</emu-meta>(_V_.[[ReferencedName]], _W_, _V_.[[Strict]]) (see <emu-xref href=\"#sec-environment-records\"></emu-xref>).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetThisValue","params":[{"name":"V","ty":"Record[ReferenceRecord]","kind":{"Normal":{}}}],"retTy":"ESValue"}},"body":"\n  1. Assert: IsPropertyReference(_V_) is *true*.\n  1. If IsSuperReference(_V_) is *true*, return _V_.[[ThisValue]].\n  1. Else, return _V_.[[Base]].","code":"\n          1. Assert: IsPropertyReference(_V_) is *true*.\n          1. If IsSuperReference(_V_) is *true*, return _V_.[[ThisValue]]; otherwise return _V_.[[Base]].\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"InitializeReferencedBinding","params":[{"name":"V","ty":"Record[ReferenceRecord]","kind":{"Normal":{}}},{"name":"W","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Assert: IsUnresolvableReference(_V_) is *false*.\n  1. Let _base_ be _V_.[[Base]].\n  1. Assert: _base_ is a Record[EnvironmentRecord].\n  1. Return ? _base_.InitializeBinding(_V_.[[ReferencedName]], _W_).","code":"\n          1. Assert: IsUnresolvableReference(_V_) is *false*.\n          1. Let _base_ be _V_.[[Base]].\n          1. Assert: _base_ is an Environment Record.\n          1. Return ? _base_.InitializeBinding(_V_.[[ReferencedName]], _W_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"MakePrivateReference","params":[{"name":"baseValue","ty":"ESValue","kind":{"Normal":{}}},{"name":"privateIdentifier","ty":"String","kind":{"Normal":{}}}],"retTy":"Record[ReferenceRecord]"}},"body":"\n  1. Let _privEnv_ be the running execution context.PrivateEnvironment.\n  1. Assert: _privEnv_ is not *null*.\n  1. Let _privateName_ be ResolvePrivateIdentifier(_privEnv_, _privateIdentifier_).\n  1. Return Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _privateName_, [[Strict]]: *true*, [[ThisValue]]: ~empty~ }.","code":"\n          1. Let _privEnv_ be the running execution context's PrivateEnvironment.\n          1. Assert: _privEnv_ is not *null*.\n          1. Let _privateName_ be ResolvePrivateIdentifier(_privEnv_, _privateIdentifier_).\n          1. Return the Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _privateName_, [[Strict]]: *true*, [[ThisValue]]: ~empty~ }.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsAccessorDescriptor","params":[{"name":"Desc","ty":"Record[PropertyDescriptor] | Undefined","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _Desc_ is *undefined*, return *false*.\n  1. If _Desc_ has a [[Get]] internal slot, return *true*.\n  1. If _Desc_ has a [[Set]] internal slot, return *true*.\n  1. Return *false*.","code":"\n          1. If _Desc_ is *undefined*, return *false*.\n          1. If _Desc_ has a [[Get]] field, return *true*.\n          1. If _Desc_ has a [[Set]] field, return *true*.\n          1. Return *false*.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsDataDescriptor","params":[{"name":"Desc","ty":"Record[PropertyDescriptor] | Undefined","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _Desc_ is *undefined*, return *false*.\n  1. If _Desc_ has a [[Value]] internal slot, return *true*.\n  1. If _Desc_ has a [[Writable]] internal slot, return *true*.\n  1. Return *false*.","code":"\n          1. If _Desc_ is *undefined*, return *false*.\n          1. If _Desc_ has a [[Value]] field, return *true*.\n          1. If _Desc_ has a [[Writable]] field, return *true*.\n          1. Return *false*.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsGenericDescriptor","params":[{"name":"Desc","ty":"Record[PropertyDescriptor] | Undefined","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _Desc_ is *undefined*, return *false*.\n  1. If IsAccessorDescriptor(_Desc_) is *true*, return *false*.\n  1. If IsDataDescriptor(_Desc_) is *true*, return *false*.\n  1. Return *true*.","code":"\n          1. If _Desc_ is *undefined*, return *false*.\n          1. If IsAccessorDescriptor(_Desc_) is *true*, return *false*.\n          1. If IsDataDescriptor(_Desc_) is *true*, return *false*.\n          1. Return *true*.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"FromPropertyDescriptor","params":[{"name":"Desc","ty":"Record[PropertyDescriptor] | Undefined","kind":{"Normal":{}}}],"retTy":"Record[Object] | Undefined"}},"body":"\n  1. If _Desc_ is *undefined*, return *undefined*.\n  1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).\n  1. Assert: _obj_ is an extensible ordinary object with no own properties..\n  1. If _Desc_ has a [[Value]] internal slot, then\n    1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"value\"*, _Desc_.[[Value]]).\n  1. If _Desc_ has a [[Writable]] internal slot, then\n    1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"writable\"*, _Desc_.[[Writable]]).\n  1. If _Desc_ has a [[Get]] internal slot, then\n    1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"get\"*, _Desc_.[[Get]]).\n  1. If _Desc_ has a [[Set]] internal slot, then\n    1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"set\"*, _Desc_.[[Set]]).\n  1. If _Desc_ has a [[Enumerable]] internal slot, then\n    1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"enumerable\"*, _Desc_.[[Enumerable]]).\n  1. If _Desc_ has a [[Configurable]] internal slot, then\n    1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"configurable\"*, _Desc_.[[Configurable]]).\n  1. Return _obj_.","code":"\n          1. If _Desc_ is *undefined*, return *undefined*.\n          1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).\n          1. Assert: _obj_ is an extensible ordinary object with no own properties.\n          1. If _Desc_ has a [[Value]] field, then\n            1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"value\"*, _Desc_.[[Value]]).\n          1. If _Desc_ has a [[Writable]] field, then\n            1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"writable\"*, _Desc_.[[Writable]]).\n          1. If _Desc_ has a [[Get]] field, then\n            1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"get\"*, _Desc_.[[Get]]).\n          1. If _Desc_ has a [[Set]] field, then\n            1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"set\"*, _Desc_.[[Set]]).\n          1. If _Desc_ has an [[Enumerable]] field, then\n            1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"enumerable\"*, _Desc_.[[Enumerable]]).\n          1. If _Desc_ has a [[Configurable]] field, then\n            1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"configurable\"*, _Desc_.[[Configurable]]).\n          1. Return _obj_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ToPropertyDescriptor","params":[{"name":"Obj","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Record[PropertyDescriptor]] | Throw"}},"body":"\n  1. If _Obj_ is not a Record[Object], throw a *TypeError* exception.\n  1. Let _desc_ be Property Descriptor { }.\n  1. Let _hasEnumerable_ be ? HasProperty(_Obj_, *\"enumerable\"*).\n  1. If _hasEnumerable_ is *true*, then\n    1. Let _enumerable_ be ToBoolean(? Get(_Obj_, *\"enumerable\"*)).\n    1. Set _desc_.[[Enumerable]] to _enumerable_.\n  1. Let _hasConfigurable_ be ? HasProperty(_Obj_, *\"configurable\"*).\n  1. If _hasConfigurable_ is *true*, then\n    1. Let _configurable_ be ToBoolean(? Get(_Obj_, *\"configurable\"*)).\n    1. Set _desc_.[[Configurable]] to _configurable_.\n  1. Let _hasValue_ be ? HasProperty(_Obj_, *\"value\"*).\n  1. If _hasValue_ is *true*, then\n    1. Let _value_ be ? Get(_Obj_, *\"value\"*).\n    1. Set _desc_.[[Value]] to _value_.\n  1. Let _hasWritable_ be ? HasProperty(_Obj_, *\"writable\"*).\n  1. If _hasWritable_ is *true*, then\n    1. Let _writable_ be ToBoolean(? Get(_Obj_, *\"writable\"*)).\n    1. Set _desc_.[[Writable]] to _writable_.\n  1. Let _hasGet_ be ? HasProperty(_Obj_, *\"get\"*).\n  1. If _hasGet_ is *true*, then\n    1. Let _getter_ be ? Get(_Obj_, *\"get\"*).\n    1. If IsCallable(_getter_) is *false* and _getter_ is not *undefined*, throw a *TypeError* exception.\n    1. Set _desc_.[[Get]] to _getter_.\n  1. Let _hasSet_ be ? HasProperty(_Obj_, *\"set\"*).\n  1. If _hasSet_ is *true*, then\n    1. Let _setter_ be ? Get(_Obj_, *\"set\"*).\n    1. If IsCallable(_setter_) is *false* and _setter_ is not *undefined*, throw a *TypeError* exception.\n    1. Set _desc_.[[Set]] to _setter_.\n  1. If _desc_ has a [[Get]] internal slot or _desc_ has a [[Set]] internal slot, then\n    1. If _desc_ has a [[Value]] internal slot or _desc_ has a [[Writable]] internal slot, throw a *TypeError* exception.\n  1. Return _desc_.","code":"\n          1. If _Obj_ is not an Object, throw a *TypeError* exception.\n          1. Let _desc_ be a new Property Descriptor that initially has no fields.\n          1. Let _hasEnumerable_ be ? HasProperty(_Obj_, *\"enumerable\"*).\n          1. If _hasEnumerable_ is *true*, then\n            1. Let _enumerable_ be ToBoolean(? Get(_Obj_, *\"enumerable\"*)).\n            1. Set _desc_.[[Enumerable]] to _enumerable_.\n          1. Let _hasConfigurable_ be ? HasProperty(_Obj_, *\"configurable\"*).\n          1. If _hasConfigurable_ is *true*, then\n            1. Let _configurable_ be ToBoolean(? Get(_Obj_, *\"configurable\"*)).\n            1. Set _desc_.[[Configurable]] to _configurable_.\n          1. Let _hasValue_ be ? HasProperty(_Obj_, *\"value\"*).\n          1. If _hasValue_ is *true*, then\n            1. Let _value_ be ? Get(_Obj_, *\"value\"*).\n            1. Set _desc_.[[Value]] to _value_.\n          1. Let _hasWritable_ be ? HasProperty(_Obj_, *\"writable\"*).\n          1. If _hasWritable_ is *true*, then\n            1. Let _writable_ be ToBoolean(? Get(_Obj_, *\"writable\"*)).\n            1. Set _desc_.[[Writable]] to _writable_.\n          1. Let _hasGet_ be ? HasProperty(_Obj_, *\"get\"*).\n          1. If _hasGet_ is *true*, then\n            1. Let _getter_ be ? Get(_Obj_, *\"get\"*).\n            1. If IsCallable(_getter_) is *false* and _getter_ is not *undefined*, throw a *TypeError* exception.\n            1. Set _desc_.[[Get]] to _getter_.\n          1. Let _hasSet_ be ? HasProperty(_Obj_, *\"set\"*).\n          1. If _hasSet_ is *true*, then\n            1. Let _setter_ be ? Get(_Obj_, *\"set\"*).\n            1. If IsCallable(_setter_) is *false* and _setter_ is not *undefined*, throw a *TypeError* exception.\n            1. Set _desc_.[[Set]] to _setter_.\n          1. If _desc_ has a [[Get]] field or _desc_ has a [[Set]] field, then\n            1. If _desc_ has a [[Value]] field or _desc_ has a [[Writable]] field, throw a *TypeError* exception.\n          1. Return _desc_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CompletePropertyDescriptor","params":[{"name":"Desc","ty":"Record[PropertyDescriptor]","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Let _like_ be Record { [[Value]]: *undefined*, [[Writable]]: *false*, [[Get]]: *undefined*, [[Set]]: *undefined*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.\n  1. If IsGenericDescriptor(_Desc_) is *true* or IsDataDescriptor(_Desc_) is *true*, then\n    1. If _Desc_ does not have a [[Value]] internal slot, set _Desc_.[[Value]] to _like_.[[Value]].\n    1. If _Desc_ does not have a [[Writable]] internal slot, set _Desc_.[[Writable]] to _like_.[[Writable]].\n  1. Else,\n    1. If _Desc_ does not have a [[Get]] internal slot, set _Desc_.[[Get]] to _like_.[[Get]].\n    1. If _Desc_ does not have a [[Set]] internal slot, set _Desc_.[[Set]] to _like_.[[Set]].\n  1. If _Desc_ does not have a [[Enumerable]] internal slot, set _Desc_.[[Enumerable]] to _like_.[[Enumerable]].\n  1. If _Desc_ does not have a [[Configurable]] internal slot, set _Desc_.[[Configurable]] to _like_.[[Configurable]].\n  1. Return ~unused~.","code":"\n          1. Let _like_ be the Record { [[Value]]: *undefined*, [[Writable]]: *false*, [[Get]]: *undefined*, [[Set]]: *undefined*, [[Enumerable]]: *false*, [[Configurable]]: *false* }.\n          1. If IsGenericDescriptor(_Desc_) is *true* or IsDataDescriptor(_Desc_) is *true*, then\n            1. If _Desc_ does not have a [[Value]] field, set _Desc_.[[Value]] to _like_.[[Value]].\n            1. If _Desc_ does not have a [[Writable]] field, set _Desc_.[[Writable]] to _like_.[[Writable]].\n          1. Else,\n            1. If _Desc_ does not have a [[Get]] field, set _Desc_.[[Get]] to _like_.[[Get]].\n            1. If _Desc_ does not have a [[Set]] field, set _Desc_.[[Set]] to _like_.[[Set]].\n          1. If _Desc_ does not have an [[Enumerable]] field, set _Desc_.[[Enumerable]] to _like_.[[Enumerable]].\n          1. If _Desc_ does not have a [[Configurable]] field, set _Desc_.[[Configurable]] to _like_.[[Configurable]].\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CreateByteDataBlock","params":[{"name":"size","ty":"NonNegInt","kind":{"Normal":{}}}],"retTy":"Normal[Record[DataBlock]] | Throw"}},"body":"\n  1. If _size_ > 2<sup>53</sup> - 1, throw a *RangeError* exception.\n  1. Let _db_ be a new Data Block value consisting of _size_ bytes. If it is impossible to create such a Data Block, throw a *RangeError* exception.\n  1. Set all of the bytes of _db_ to 0.\n  1. Return _db_.","code":"\n          1. If _size_ > 2<sup>53</sup> - 1, throw a *RangeError* exception.\n          1. Let _db_ be a new Data Block value consisting of _size_ bytes. If it is impossible to create such a Data Block, throw a *RangeError* exception.\n          1. Set all of the bytes of _db_ to 0.\n          1. Return _db_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CreateSharedByteDataBlock","params":[{"name":"size","ty":"NonNegInt","kind":{"Normal":{}}}],"retTy":"Normal[Record[SharedDataBlock]] | Throw"}},"body":"\n  1. Let _db_ be a new Shared Data Block value consisting of _size_ bytes. If it is impossible to create such a Shared Data Block, throw a *RangeError* exception.\n  1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\n  1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\n  1. Let _zero_ be « 0 ».\n  1. For each index _i_ of _db_, do\n    1. Append WriteSharedMemory { [[Order]]: ~init~, [[NoTear]]: *true*, [[Block]]: _db_, [[ByteIndex]]: _i_, [[ElementSize]]: 1, [[Payload]]: _zero_ } to _eventsRecord_.[[EventList]].\n  1. Return _db_.","code":"\n          1. Let _db_ be a new Shared Data Block value consisting of _size_ bytes. If it is impossible to create such a Shared Data Block, throw a *RangeError* exception.\n          1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\n          1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\n          1. Let _zero_ be « 0 ».\n          1. For each index _i_ of _db_, do\n            1. Append WriteSharedMemory { [[Order]]: ~init~, [[NoTear]]: *true*, [[Block]]: _db_, [[ByteIndex]]: _i_, [[ElementSize]]: 1, [[Payload]]: _zero_ } to _eventsRecord_.[[EventList]].\n          1. Return _db_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CopyDataBlockBytes","params":[{"name":"toBlock","ty":"Record[DataBlock | SharedDataBlock]","kind":{"Normal":{}}},{"name":"toIndex","ty":"NonNegInt","kind":{"Normal":{}}},{"name":"fromBlock","ty":"Record[DataBlock | SharedDataBlock]","kind":{"Normal":{}}},{"name":"fromIndex","ty":"NonNegInt","kind":{"Normal":{}}},{"name":"count","ty":"NonNegInt","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Assert: _fromBlock_ and _toBlock_ are distinct values..\n  1. Let _fromSize_ be the number of bytes in _fromBlock_.\n  1. Assert: _fromIndex_ + _count_ ≤ _fromSize_.\n  1. Let _toSize_ be the number of bytes in _toBlock_.\n  1. Assert: _toIndex_ + _count_ ≤ _toSize_.\n  1. Repeat, while _count_ > 0,\n    1. If _fromBlock_ is a Record[SharedDataBlock], then\n      1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\n      1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\n      1. Let _bytes_ be a List whose sole element is a nondeterministically chosen byte value.\n      1. NOTE: In implementations, _bytes_ is the result of a non-atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.\n      1. Let _readEvent_ be ReadSharedMemory { [[Order]]: ~unordered~, [[NoTear]]: *true*, [[Block]]: _fromBlock_, [[ByteIndex]]: _fromIndex_, [[ElementSize]]: 1 }.\n      1. Append _readEvent_ to _eventsRecord_.[[EventList]].\n      1. Append Chosen Value Record { [[Event]]: _readEvent_, [[ChosenValue]]: _bytes_ } to _execution_.[[ChosenValues]].\n      1. If _toBlock_ is a Record[SharedDataBlock], then\n        1. Append WriteSharedMemory { [[Order]]: ~unordered~, [[NoTear]]: *true*, [[Block]]: _toBlock_, [[ByteIndex]]: _toIndex_, [[ElementSize]]: 1, [[Payload]]: _bytes_ } to _eventsRecord_.[[EventList]].\n      1. Else,\n        1. Set _toBlock_[_toIndex_] to _bytes_[0].\n    1. Else,\n      1. Assert: _toBlock_ is not a Record[SharedDataBlock].\n      1. Set _toBlock_[_toIndex_] to _fromBlock_[_fromIndex_].\n    1. Set _toIndex_ to _toIndex_ + 1.\n    1. Set _fromIndex_ to _fromIndex_ + 1.\n    1. Set _count_ to _count_ - 1.\n  1. Return ~unused~.","code":"\n          1. Assert: _fromBlock_ and _toBlock_ are distinct values.\n          1. Let _fromSize_ be the number of bytes in _fromBlock_.\n          1. Assert: _fromIndex_ + _count_ ≤ _fromSize_.\n          1. Let _toSize_ be the number of bytes in _toBlock_.\n          1. Assert: _toIndex_ + _count_ ≤ _toSize_.\n          1. Repeat, while _count_ > 0,\n            1. If _fromBlock_ is a Shared Data Block, then\n              1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\n              1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\n              1. Let _bytes_ be a List whose sole element is a nondeterministically chosen byte value.\n              1. NOTE: In implementations, _bytes_ is the result of a non-atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.\n              1. Let _readEvent_ be ReadSharedMemory { [[Order]]: ~unordered~, [[NoTear]]: *true*, [[Block]]: _fromBlock_, [[ByteIndex]]: _fromIndex_, [[ElementSize]]: 1 }.\n              1. Append _readEvent_ to _eventsRecord_.[[EventList]].\n              1. Append Chosen Value Record { [[Event]]: _readEvent_, [[ChosenValue]]: _bytes_ } to _execution_.[[ChosenValues]].\n              1. If _toBlock_ is a Shared Data Block, then\n                1. Append WriteSharedMemory { [[Order]]: ~unordered~, [[NoTear]]: *true*, [[Block]]: _toBlock_, [[ByteIndex]]: _toIndex_, [[ElementSize]]: 1, [[Payload]]: _bytes_ } to _eventsRecord_.[[EventList]].\n              1. Else,\n                1. Set _toBlock_[_toIndex_] to _bytes_[0].\n            1. Else,\n              1. Assert: _toBlock_ is not a Shared Data Block.\n              1. Set _toBlock_[_toIndex_] to _fromBlock_[_fromIndex_].\n            1. Set _toIndex_ to _toIndex_ + 1.\n            1. Set _fromIndex_ to _fromIndex_ + 1.\n            1. Set _count_ to _count_ - 1.\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ToPrimitive","params":[{"name":"input","ty":"ESValue","kind":{"Normal":{}}},{"name":"preferredType","ty":"Enum[~number~, ~string~]","kind":{"Optional":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. If _input_ is a Record[Object], then\n    1. Let _exoticToPrim_ be ? GetMethod(_input_, @@toPrimitive).\n    1. If _exoticToPrim_ is not *undefined*, then\n      1. If _preferredType_ is not present, then\n        1. Let _hint_ be *\"default\"*.\n      1. Else if _preferredType_ is ~string~, then\n        1. Let _hint_ be *\"string\"*.\n      1. Else,\n        1. Assert: _preferredType_ is ~number~.\n        1. Let _hint_ be *\"number\"*.\n      1. Let _result_ be ? Call(_exoticToPrim_, _input_, « _hint_ »).\n      1. If _result_ is not a Record[Object], return _result_.\n      1. Throw a *TypeError* exception.\n    1. If _preferredType_ is not present, let _preferredType_ be ~number~.\n    1. Return ? OrdinaryToPrimitive(_input_, _preferredType_).\n  1. Return _input_.","code":"\n        1. If _input_ is an Object, then\n          1. Let _exoticToPrim_ be ? GetMethod(_input_, @@toPrimitive).\n          1. If _exoticToPrim_ is not *undefined*, then\n            1. If _preferredType_ is not present, then\n              1. Let _hint_ be *\"default\"*.\n            1. Else if _preferredType_ is ~string~, then\n              1. Let _hint_ be *\"string\"*.\n            1. Else,\n              1. Assert: _preferredType_ is ~number~.\n              1. Let _hint_ be *\"number\"*.\n            1. Let _result_ be ? Call(_exoticToPrim_, _input_, « _hint_ »).\n            1. If _result_ is not an Object, return _result_.\n            1. Throw a *TypeError* exception.\n          1. If _preferredType_ is not present, let _preferredType_ be ~number~.\n          1. Return ? OrdinaryToPrimitive(_input_, _preferredType_).\n        1. Return _input_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"OrdinaryToPrimitive","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"hint","ty":"Enum[~number~, ~string~]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. If _hint_ is ~string~, then\n    1. Let _methodNames_ be « *\"toString\"*, *\"valueOf\"* ».\n  1. Else,\n    1. Let _methodNames_ be « *\"valueOf\"*, *\"toString\"* ».\n  1. For each _name_ of _methodNames_, do\n    1. Let _method_ be ? Get(_O_, _name_).\n    1. If IsCallable(_method_) is *true*, then\n      1. Let _result_ be ? Call(_method_, _O_).\n      1. If _result_ is not a Record[Object], return _result_.\n  1. Throw a *TypeError* exception.","code":"\n          1. If _hint_ is ~string~, then\n            1. Let _methodNames_ be « *\"toString\"*, *\"valueOf\"* ».\n          1. Else,\n            1. Let _methodNames_ be « *\"valueOf\"*, *\"toString\"* ».\n          1. For each element _name_ of _methodNames_, do\n            1. Let _method_ be ? Get(_O_, _name_).\n            1. If IsCallable(_method_) is *true*, then\n              1. Let _result_ be ? Call(_method_, _O_).\n              1. If _result_ is not an Object, return _result_.\n          1. Throw a *TypeError* exception.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ToBoolean","params":[{"name":"argument","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _argument_ is a Boolean, return _argument_.\n  1. If _argument_ is either *undefined*, *null*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, *NaN*, *0*<sub>ℤ</sub>, or *\"\"*, return *false*.\n  1. [id=\"step-to-boolean-web-compat-insertion-point\"] NOTE: This step is replaced in section <emu-xref href=\"#sec-IsHTMLDDA-internal-slot-to-boolean\"></emu-xref>.\n  1. Return *true*.","code":"\n        1. If _argument_ is a Boolean, return _argument_.\n        1. If _argument_ is one of *undefined*, *null*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, *NaN*, *0*<sub>ℤ</sub>, or the empty String, return *false*.\n        1. [id=\"step-to-boolean-web-compat-insertion-point\"] NOTE: This step is replaced in section <emu-xref href=\"#sec-IsHTMLDDA-internal-slot-to-boolean\"></emu-xref>.\n        1. Return *true*.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ToNumeric","params":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Number | BigInt] | Throw"}},"body":"\n  1. Let _primValue_ be ? ToPrimitive(_value_, ~number~).\n  1. If _primValue_ is a BigInt, return _primValue_.\n  1. Return ? ToNumber(_primValue_).","code":"\n        1. Let _primValue_ be ? ToPrimitive(_value_, ~number~).\n        1. If _primValue_ is a BigInt, return _primValue_.\n        1. Return ? <emu-meta suppress-effects=\"user-code\">ToNumber(_primValue_)</emu-meta>.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ToNumber","params":[{"name":"argument","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Number] | Throw"}},"body":"\n  1. If _argument_ is a Number, return _argument_.\n  1. If _argument_ is either a Record[Symbol] or a BigInt, throw a *TypeError* exception.\n  1. If _argument_ is *undefined*, return *NaN*.\n  1. If _argument_ is either *null* or *false*, return *+0*<sub>𝔽</sub>.\n  1. If _argument_ is *true*, return *1*<sub>𝔽</sub>.\n  1. If _argument_ is a String, return StringToNumber(_argument_).\n  1. Assert: _argument_ is a Record[Object].\n  1. Let _primValue_ be ? ToPrimitive(_argument_, ~number~).\n  1. Assert: _primValue_ is not a Record[Object].\n  1. Return ? ToNumber(_primValue_).","code":"\n        1. If _argument_ is a Number, return _argument_.\n        1. If _argument_ is either a Symbol or a BigInt, throw a *TypeError* exception.\n        1. If _argument_ is *undefined*, return *NaN*.\n        1. If _argument_ is either *null* or *false*, return *+0*<sub>𝔽</sub>.\n        1. If _argument_ is *true*, return *1*<sub>𝔽</sub>.\n        1. If _argument_ is a String, return StringToNumber(_argument_).\n        1. Assert: _argument_ is an Object.\n        1. Let _primValue_ be ? ToPrimitive(_argument_, ~number~).\n        1. Assert: _primValue_ is not an Object.\n        1. Return ? ToNumber(_primValue_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"StringToNumber","params":[{"name":"str","ty":"String","kind":{"Normal":{}}}],"retTy":"Number"}},"body":"\n  1. Let _text_ be StringToCodePoints(_str_).\n  1. Let _literal_ be ParseText(_text_, |StringNumericLiteral|).\n  1. If _literal_ is a List[Record[Error]], return *NaN*.\n  1. Return StringNumericValue of _literal_.","code":"\n            1. Let _text_ be StringToCodePoints(_str_).\n            1. Let _literal_ be ParseText(_text_, |StringNumericLiteral|).\n            1. If _literal_ is a List of errors, return *NaN*.\n            1. Return StringNumericValue of _literal_.\n          "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StringNumericLiteral","idx":0,"subIdx":0,"rhsParams":[{"name":"StrWhiteSpace","ty":"Ast[StrWhiteSpace]","kind":{"Normal":{}}}]},"methodName":"StringNumericValue","isStatic":false,"withParams":[],"retTy":"Number"}},"body":"\n  1. Return *+0*<sub>𝔽</sub>.","code":"\n            1. Return *+0*<sub>𝔽</sub>.\n          "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StringNumericLiteral","idx":0,"subIdx":1,"rhsParams":[{"name":"StrWhiteSpace","ty":"Ast[StrWhiteSpace]","kind":{"Normal":{}}}]},"methodName":"StringNumericValue","isStatic":false,"withParams":[],"retTy":"Number"}},"body":"\n  1. Return *+0*<sub>𝔽</sub>.","code":"\n            1. Return *+0*<sub>𝔽</sub>.\n          "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StringNumericLiteral","idx":1,"subIdx":0,"rhsParams":[{"name":"StrWhiteSpace","ty":"Ast[StrWhiteSpace]","kind":{"Normal":{}}},{"name":"StrNumericLiteral","ty":"Ast[StrNumericLiteral]","kind":{"Normal":{}}},{"name":"StrWhiteSpace","ty":"Ast[StrWhiteSpace]","kind":{"Normal":{}}}]},"methodName":"StringNumericValue","isStatic":false,"withParams":[],"retTy":"Number"}},"body":"\n  1. Return StringNumericValue of |StrNumericLiteral|.","code":"\n            1. Return StringNumericValue of |StrNumericLiteral|.\n          "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StringNumericLiteral","idx":1,"subIdx":1,"rhsParams":[{"name":"StrWhiteSpace","ty":"Ast[StrWhiteSpace]","kind":{"Normal":{}}},{"name":"StrNumericLiteral","ty":"Ast[StrNumericLiteral]","kind":{"Normal":{}}},{"name":"StrWhiteSpace","ty":"Ast[StrWhiteSpace]","kind":{"Normal":{}}}]},"methodName":"StringNumericValue","isStatic":false,"withParams":[],"retTy":"Number"}},"body":"\n  1. Return StringNumericValue of |StrNumericLiteral|.","code":"\n            1. Return StringNumericValue of |StrNumericLiteral|.\n          "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StringNumericLiteral","idx":1,"subIdx":2,"rhsParams":[{"name":"StrWhiteSpace","ty":"Ast[StrWhiteSpace]","kind":{"Normal":{}}},{"name":"StrNumericLiteral","ty":"Ast[StrNumericLiteral]","kind":{"Normal":{}}},{"name":"StrWhiteSpace","ty":"Ast[StrWhiteSpace]","kind":{"Normal":{}}}]},"methodName":"StringNumericValue","isStatic":false,"withParams":[],"retTy":"Number"}},"body":"\n  1. Return StringNumericValue of |StrNumericLiteral|.","code":"\n            1. Return StringNumericValue of |StrNumericLiteral|.\n          "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StringNumericLiteral","idx":1,"subIdx":3,"rhsParams":[{"name":"StrWhiteSpace","ty":"Ast[StrWhiteSpace]","kind":{"Normal":{}}},{"name":"StrNumericLiteral","ty":"Ast[StrNumericLiteral]","kind":{"Normal":{}}},{"name":"StrWhiteSpace","ty":"Ast[StrWhiteSpace]","kind":{"Normal":{}}}]},"methodName":"StringNumericValue","isStatic":false,"withParams":[],"retTy":"Number"}},"body":"\n  1. Return StringNumericValue of |StrNumericLiteral|.","code":"\n            1. Return StringNumericValue of |StrNumericLiteral|.\n          "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StrNumericLiteral","idx":1,"subIdx":0,"rhsParams":[{"name":"NonDecimalIntegerLiteral","ty":"Ast[NonDecimalIntegerLiteral]","kind":{"Normal":{}}}]},"methodName":"StringNumericValue","isStatic":false,"withParams":[],"retTy":"Number"}},"body":"\n  1. Return 𝔽(MV of |NonDecimalIntegerLiteral|).","code":"\n            1. Return 𝔽(MV of |NonDecimalIntegerLiteral|).\n          "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StrDecimalLiteral","idx":2,"subIdx":0,"rhsParams":[{"name":"StrUnsignedDecimalLiteral","ty":"Ast[StrUnsignedDecimalLiteral]","kind":{"Normal":{}}}]},"methodName":"StringNumericValue","isStatic":false,"withParams":[],"retTy":"Number"}},"body":"\n  1. Let _a_ be StringNumericValue of |StrUnsignedDecimalLiteral|.\n  1. If _a_ is *+0*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.\n  1. Return -_a_.","code":"\n            1. Let _a_ be StringNumericValue of |StrUnsignedDecimalLiteral|.\n            1. If _a_ is *+0*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.\n            1. Return -_a_.\n          "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StrUnsignedDecimalLiteral","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"StringNumericValue","isStatic":false,"withParams":[],"retTy":"Number"}},"body":"\n  1. Return *+∞*<sub>𝔽</sub>.","code":"\n            1. Return *+∞*<sub>𝔽</sub>.\n          "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StrUnsignedDecimalLiteral","idx":1,"subIdx":0,"rhsParams":[{"name":"DecimalDigits","ty":"Ast[DecimalDigits]","kind":{"Normal":{}}},{"name":"DecimalDigits","ty":"Ast[DecimalDigits]","kind":{"Normal":{}}},{"name":"ExponentPart","ty":"Ast[ExponentPart]","kind":{"Normal":{}}}]},"methodName":"StringNumericValue","isStatic":false,"withParams":[],"retTy":"Number"}},"body":"\n  1. Let _a_ be MV of the first |DecimalDigits|.\n  1. If the second |DecimalDigits| is present, then\n    1. Let _b_ be MV of the second |DecimalDigits|.\n    1. Let _n_ be the number of code points in the second |DecimalDigits|.\n  1. Else,\n    1. Let _b_ be 0.\n    1. Let _n_ be 0.\n  1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|.\n  1. Else, let _e_ be 0.\n  1. Return RoundMVResult((_a_ + _b_ × 10<sup>(-_n_)</sup>) × 10<sup>_e_</sup>).","code":"\n            1. Let _a_ be MV of the first |DecimalDigits|.\n            1. If the second |DecimalDigits| is present, then\n              1. Let _b_ be MV of the second |DecimalDigits|.\n              1. Let _n_ be the number of code points in the second |DecimalDigits|.\n            1. Else,\n              1. Let _b_ be 0.\n              1. Let _n_ be 0.\n            1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.\n            1. Return RoundMVResult((_a_ + (_b_ × 10<sup>-_n_</sup>)) × 10<sup>_e_</sup>).\n          "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StrUnsignedDecimalLiteral","idx":1,"subIdx":1,"rhsParams":[{"name":"DecimalDigits","ty":"Ast[DecimalDigits]","kind":{"Normal":{}}},{"name":"DecimalDigits","ty":"Ast[DecimalDigits]","kind":{"Normal":{}}},{"name":"ExponentPart","ty":"Ast[ExponentPart]","kind":{"Normal":{}}}]},"methodName":"StringNumericValue","isStatic":false,"withParams":[],"retTy":"Number"}},"body":"\n  1. Let _a_ be MV of the first |DecimalDigits|.\n  1. If the second |DecimalDigits| is present, then\n    1. Let _b_ be MV of the second |DecimalDigits|.\n    1. Let _n_ be the number of code points in the second |DecimalDigits|.\n  1. Else,\n    1. Let _b_ be 0.\n    1. Let _n_ be 0.\n  1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|.\n  1. Else, let _e_ be 0.\n  1. Return RoundMVResult((_a_ + _b_ × 10<sup>(-_n_)</sup>) × 10<sup>_e_</sup>).","code":"\n            1. Let _a_ be MV of the first |DecimalDigits|.\n            1. If the second |DecimalDigits| is present, then\n              1. Let _b_ be MV of the second |DecimalDigits|.\n              1. Let _n_ be the number of code points in the second |DecimalDigits|.\n            1. Else,\n              1. Let _b_ be 0.\n              1. Let _n_ be 0.\n            1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.\n            1. Return RoundMVResult((_a_ + (_b_ × 10<sup>-_n_</sup>)) × 10<sup>_e_</sup>).\n          "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StrUnsignedDecimalLiteral","idx":1,"subIdx":2,"rhsParams":[{"name":"DecimalDigits","ty":"Ast[DecimalDigits]","kind":{"Normal":{}}},{"name":"DecimalDigits","ty":"Ast[DecimalDigits]","kind":{"Normal":{}}},{"name":"ExponentPart","ty":"Ast[ExponentPart]","kind":{"Normal":{}}}]},"methodName":"StringNumericValue","isStatic":false,"withParams":[],"retTy":"Number"}},"body":"\n  1. Let _a_ be MV of the first |DecimalDigits|.\n  1. If the second |DecimalDigits| is present, then\n    1. Let _b_ be MV of the second |DecimalDigits|.\n    1. Let _n_ be the number of code points in the second |DecimalDigits|.\n  1. Else,\n    1. Let _b_ be 0.\n    1. Let _n_ be 0.\n  1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|.\n  1. Else, let _e_ be 0.\n  1. Return RoundMVResult((_a_ + _b_ × 10<sup>(-_n_)</sup>) × 10<sup>_e_</sup>).","code":"\n            1. Let _a_ be MV of the first |DecimalDigits|.\n            1. If the second |DecimalDigits| is present, then\n              1. Let _b_ be MV of the second |DecimalDigits|.\n              1. Let _n_ be the number of code points in the second |DecimalDigits|.\n            1. Else,\n              1. Let _b_ be 0.\n              1. Let _n_ be 0.\n            1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.\n            1. Return RoundMVResult((_a_ + (_b_ × 10<sup>-_n_</sup>)) × 10<sup>_e_</sup>).\n          "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StrUnsignedDecimalLiteral","idx":1,"subIdx":3,"rhsParams":[{"name":"DecimalDigits","ty":"Ast[DecimalDigits]","kind":{"Normal":{}}},{"name":"DecimalDigits","ty":"Ast[DecimalDigits]","kind":{"Normal":{}}},{"name":"ExponentPart","ty":"Ast[ExponentPart]","kind":{"Normal":{}}}]},"methodName":"StringNumericValue","isStatic":false,"withParams":[],"retTy":"Number"}},"body":"\n  1. Let _a_ be MV of the first |DecimalDigits|.\n  1. If the second |DecimalDigits| is present, then\n    1. Let _b_ be MV of the second |DecimalDigits|.\n    1. Let _n_ be the number of code points in the second |DecimalDigits|.\n  1. Else,\n    1. Let _b_ be 0.\n    1. Let _n_ be 0.\n  1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|.\n  1. Else, let _e_ be 0.\n  1. Return RoundMVResult((_a_ + _b_ × 10<sup>(-_n_)</sup>) × 10<sup>_e_</sup>).","code":"\n            1. Let _a_ be MV of the first |DecimalDigits|.\n            1. If the second |DecimalDigits| is present, then\n              1. Let _b_ be MV of the second |DecimalDigits|.\n              1. Let _n_ be the number of code points in the second |DecimalDigits|.\n            1. Else,\n              1. Let _b_ be 0.\n              1. Let _n_ be 0.\n            1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.\n            1. Return RoundMVResult((_a_ + (_b_ × 10<sup>-_n_</sup>)) × 10<sup>_e_</sup>).\n          "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StrUnsignedDecimalLiteral","idx":2,"subIdx":0,"rhsParams":[{"name":"DecimalDigits","ty":"Ast[DecimalDigits]","kind":{"Normal":{}}},{"name":"ExponentPart","ty":"Ast[ExponentPart]","kind":{"Normal":{}}}]},"methodName":"StringNumericValue","isStatic":false,"withParams":[],"retTy":"Number"}},"body":"\n  1. Let _b_ be MV of |DecimalDigits|.\n  1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|.\n  1. Else, let _e_ be 0.\n  1. Let _n_ be the number of code points in |DecimalDigits|.\n  1. Return RoundMVResult(_b_ × 10<sup>(_e_ - _n_)</sup>).","code":"\n            1. Let _b_ be MV of |DecimalDigits|.\n            1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.\n            1. Let _n_ be the number of code points in |DecimalDigits|.\n            1. Return RoundMVResult(_b_ × 10<sup>_e_ - _n_</sup>).\n          "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StrUnsignedDecimalLiteral","idx":2,"subIdx":1,"rhsParams":[{"name":"DecimalDigits","ty":"Ast[DecimalDigits]","kind":{"Normal":{}}},{"name":"ExponentPart","ty":"Ast[ExponentPart]","kind":{"Normal":{}}}]},"methodName":"StringNumericValue","isStatic":false,"withParams":[],"retTy":"Number"}},"body":"\n  1. Let _b_ be MV of |DecimalDigits|.\n  1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|.\n  1. Else, let _e_ be 0.\n  1. Let _n_ be the number of code points in |DecimalDigits|.\n  1. Return RoundMVResult(_b_ × 10<sup>(_e_ - _n_)</sup>).","code":"\n            1. Let _b_ be MV of |DecimalDigits|.\n            1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.\n            1. Let _n_ be the number of code points in |DecimalDigits|.\n            1. Return RoundMVResult(_b_ × 10<sup>_e_ - _n_</sup>).\n          "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StrUnsignedDecimalLiteral","idx":3,"subIdx":0,"rhsParams":[{"name":"DecimalDigits","ty":"Ast[DecimalDigits]","kind":{"Normal":{}}},{"name":"ExponentPart","ty":"Ast[ExponentPart]","kind":{"Normal":{}}}]},"methodName":"StringNumericValue","isStatic":false,"withParams":[],"retTy":"Number"}},"body":"\n  1. Let _a_ be MV of |DecimalDigits|.\n  1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|.\n  1. Else, let _e_ be 0.\n  1. Return RoundMVResult(_a_ × 10<sup>_e_</sup>).","code":"\n            1. Let _a_ be MV of |DecimalDigits|.\n            1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.\n            1. Return RoundMVResult(_a_ × 10<sup>_e_</sup>).\n          "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StrUnsignedDecimalLiteral","idx":3,"subIdx":1,"rhsParams":[{"name":"DecimalDigits","ty":"Ast[DecimalDigits]","kind":{"Normal":{}}},{"name":"ExponentPart","ty":"Ast[ExponentPart]","kind":{"Normal":{}}}]},"methodName":"StringNumericValue","isStatic":false,"withParams":[],"retTy":"Number"}},"body":"\n  1. Let _a_ be MV of |DecimalDigits|.\n  1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|.\n  1. Else, let _e_ be 0.\n  1. Return RoundMVResult(_a_ × 10<sup>_e_</sup>).","code":"\n            1. Let _a_ be MV of |DecimalDigits|.\n            1. If |ExponentPart| is present, let _e_ be MV of |ExponentPart|. Otherwise, let _e_ be 0.\n            1. Return RoundMVResult(_a_ × 10<sup>_e_</sup>).\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"RoundMVResult","params":[{"name":"n","ty":"Unknown[\"a mathematical value\"]","kind":{"Normal":{}}}],"retTy":"Number"}},"body":"\n  1. If the decimal representation of _n_ has 20 or fewer significant digits, return 𝔽(_n_).\n  1. Let _option1_ be the mathematical value denoted by the result of replacing each significant digit in the decimal representation of _n_ after the 20th with a 0 digit.\n  1. Let _option2_ be the mathematical value denoted by the result of replacing each significant digit in the decimal representation of _n_ after the 20th with a 0 digit and then incrementing it at the 20th position (with carrying as necessary).\n  1. Let _chosen_ be an implementation-defined choice of either _option1_ or _option2_.\n  1. Return 𝔽(_chosen_).","code":"\n            1. If the decimal representation of _n_ has 20 or fewer significant digits, return 𝔽(_n_).\n            1. Let _option1_ be the mathematical value denoted by the result of replacing each significant digit in the decimal representation of _n_ after the 20th with a 0 digit.\n            1. Let _option2_ be the mathematical value denoted by the result of replacing each significant digit in the decimal representation of _n_ after the 20th with a 0 digit and then incrementing it at the 20th position (with carrying as necessary).\n            1. Let _chosen_ be an implementation-defined choice of either _option1_ or _option2_.\n            1. Return 𝔽(_chosen_).\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ToIntegerOrInfinity","params":[{"name":"argument","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Int | INF] | Throw"}},"body":"\n  1. Let _number_ be ? ToNumber(_argument_).\n  1. If _number_ is either *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return 0.\n  1. If _number_ is *+∞*<sub>𝔽</sub>, return +∞.\n  1. If _number_ is *-∞*<sub>𝔽</sub>, return -∞.\n  1. Return truncate(ℝ(_number_)).","code":"\n        1. Let _number_ be ? ToNumber(_argument_).\n        1. If _number_ is one of *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return 0.\n        1. If _number_ is *+∞*<sub>𝔽</sub>, return +∞.\n        1. If _number_ is *-∞*<sub>𝔽</sub>, return -∞.\n        1. Return truncate(ℝ(_number_)).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ToInt32","params":[{"name":"argument","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Number[Int]] | Throw"}},"body":"\n  1. Let _number_ be ? ToNumber(_argument_).\n  1. If _number_ is not finite or _number_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n  1. Let _int_ be truncate(ℝ(_number_)).\n  1. Let _int32bit_ be _int_ modulo 2<sup>32</sup>.\n  1. If _int32bit_ ≥ 2<sup>31</sup>, return 𝔽(_int32bit_ - 2<sup>32</sup>).\n  1. Else, return 𝔽(_int32bit_).","code":"\n        1. Let _number_ be ? ToNumber(_argument_).\n        1. If _number_ is not finite or _number_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n        1. Let _int_ be truncate(ℝ(_number_)).\n        1. Let _int32bit_ be _int_ modulo 2<sup>32</sup>.\n        1. If _int32bit_ ≥ 2<sup>31</sup>, return 𝔽(_int32bit_ - 2<sup>32</sup>); otherwise return 𝔽(_int32bit_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ToUint32","params":[{"name":"argument","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Number[Int]] | Throw"}},"body":"\n  1. Let _number_ be ? ToNumber(_argument_).\n  1. If _number_ is not finite or _number_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n  1. Let _int_ be truncate(ℝ(_number_)).\n  1. Let _int32bit_ be _int_ modulo 2<sup>32</sup>.\n  1. [id=\"step-touint32-return\"] Return 𝔽(_int32bit_).","code":"\n        1. Let _number_ be ? ToNumber(_argument_).\n        1. If _number_ is not finite or _number_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n        1. Let _int_ be truncate(ℝ(_number_)).\n        1. Let _int32bit_ be _int_ modulo 2<sup>32</sup>.\n        1. [id=\"step-touint32-return\"] Return 𝔽(_int32bit_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ToInt16","params":[{"name":"argument","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Number[Int]] | Throw"}},"body":"\n  1. Let _number_ be ? ToNumber(_argument_).\n  1. If _number_ is not finite or _number_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n  1. Let _int_ be truncate(ℝ(_number_)).\n  1. Let _int16bit_ be _int_ modulo 2<sup>16</sup>.\n  1. If _int16bit_ ≥ 2<sup>15</sup>, return 𝔽(_int16bit_ - 2<sup>16</sup>).\n  1. Else, return 𝔽(_int16bit_).","code":"\n        1. Let _number_ be ? ToNumber(_argument_).\n        1. If _number_ is not finite or _number_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n        1. Let _int_ be truncate(ℝ(_number_)).\n        1. Let _int16bit_ be _int_ modulo 2<sup>16</sup>.\n        1. If _int16bit_ ≥ 2<sup>15</sup>, return 𝔽(_int16bit_ - 2<sup>16</sup>); otherwise return 𝔽(_int16bit_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ToUint16","params":[{"name":"argument","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Number[Int]] | Throw"}},"body":"\n  1. Let _number_ be ? ToNumber(_argument_).\n  1. If _number_ is not finite or _number_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n  1. Let _int_ be truncate(ℝ(_number_)).\n  1. [id=\"step-touint16-mod\"] Let _int16bit_ be _int_ modulo 2<sup>16</sup>.\n  1. Return 𝔽(_int16bit_).","code":"\n        1. Let _number_ be ? ToNumber(_argument_).\n        1. If _number_ is not finite or _number_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n        1. Let _int_ be truncate(ℝ(_number_)).\n        1. [id=\"step-touint16-mod\"] Let _int16bit_ be _int_ modulo 2<sup>16</sup>.\n        1. Return 𝔽(_int16bit_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ToInt8","params":[{"name":"argument","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Number[Int]] | Throw"}},"body":"\n  1. Let _number_ be ? ToNumber(_argument_).\n  1. If _number_ is not finite or _number_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n  1. Let _int_ be truncate(ℝ(_number_)).\n  1. Let _int8bit_ be _int_ modulo 2<sup>8</sup>.\n  1. If _int8bit_ ≥ 2<sup>7</sup>, return 𝔽(_int8bit_ - 2<sup>8</sup>).\n  1. Else, return 𝔽(_int8bit_).","code":"\n        1. Let _number_ be ? ToNumber(_argument_).\n        1. If _number_ is not finite or _number_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n        1. Let _int_ be truncate(ℝ(_number_)).\n        1. Let _int8bit_ be _int_ modulo 2<sup>8</sup>.\n        1. If _int8bit_ ≥ 2<sup>7</sup>, return 𝔽(_int8bit_ - 2<sup>8</sup>); otherwise return 𝔽(_int8bit_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ToUint8","params":[{"name":"argument","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Number[Int]] | Throw"}},"body":"\n  1. Let _number_ be ? ToNumber(_argument_).\n  1. If _number_ is not finite or _number_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n  1. Let _int_ be truncate(ℝ(_number_)).\n  1. Let _int8bit_ be _int_ modulo 2<sup>8</sup>.\n  1. Return 𝔽(_int8bit_).","code":"\n        1. Let _number_ be ? ToNumber(_argument_).\n        1. If _number_ is not finite or _number_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n        1. Let _int_ be truncate(ℝ(_number_)).\n        1. Let _int8bit_ be _int_ modulo 2<sup>8</sup>.\n        1. Return 𝔽(_int8bit_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ToUint8Clamp","params":[{"name":"argument","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Number[Int]] | Throw"}},"body":"\n  1. Let _number_ be ? ToNumber(_argument_).\n  1. If _number_ is *NaN*, return *+0*<sub>𝔽</sub>.\n  1. Let _mv_ be the extended mathematical value of _number_.\n  1. Let _clamped_ be the result of clamping _mv_ between 0 and 255.\n  1. Let _f_ be floor(_clamped_).\n  1. If _clamped_ < _f_ + 0.5, return 𝔽(_f_).\n  1. If _clamped_ > _f_ + 0.5, return 𝔽(_f_ + 1).\n  1. If _f_ is even, return 𝔽(_f_). Otherwise, return 𝔽(_f_ + 1).","code":"\n        1. Let _number_ be ? ToNumber(_argument_).\n        1. If _number_ is *NaN*, return *+0*<sub>𝔽</sub>.\n        1. Let _mv_ be the extended mathematical value of _number_.\n        1. Let _clamped_ be the result of clamping _mv_ between 0 and 255.\n        1. Let _f_ be floor(_clamped_).\n        1. If _clamped_ < _f_ + 0.5, return 𝔽(_f_).\n        1. If _clamped_ > _f_ + 0.5, return 𝔽(_f_ + 1).\n        1. If _f_ is even, return 𝔽(_f_). Otherwise, return 𝔽(_f_ + 1).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ToBigInt","params":[{"name":"argument","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[BigInt] | Throw"}},"body":"\n  1. Let _prim_ be ? ToPrimitive(_argument_, ~number~).\n  1. Return the value that _prim_ corresponds to in <emu-xref href=\"#table-tobigint\"></emu-xref>.","code":"\n        1. Let _prim_ be ? ToPrimitive(_argument_, ~number~).\n        1. Return the value that _prim_ corresponds to in <emu-xref href=\"#table-tobigint\"></emu-xref>.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"StringToBigInt","params":[{"name":"str","ty":"String","kind":{"Normal":{}}}],"retTy":"BigInt | Undefined"}},"body":"\n  1. Let _text_ be StringToCodePoints(_str_).\n  1. Let _literal_ be ParseText(_text_, |StringIntegerLiteral|).\n  1. If _literal_ is a List[Record[Error]], return *undefined*.\n  1. Let _mv_ be MV of _literal_.\n  1. Assert: _mv_ is a Int.\n  1. Return ℤ(_mv_).","code":"\n        1. Let _text_ be StringToCodePoints(_str_).\n        1. Let _literal_ be ParseText(_text_, |StringIntegerLiteral|).\n        1. If _literal_ is a List of errors, return *undefined*.\n        1. Let _mv_ be the MV of _literal_.\n        1. Assert: _mv_ is an integer.\n        1. Return ℤ(_mv_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ToBigInt64","params":[{"name":"argument","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[BigInt] | Throw"}},"body":"\n  1. Let _n_ be ? ToBigInt(_argument_).\n  1. Let _int64bit_ be ℝ(_n_) modulo 2<sup>64</sup>.\n  1. If _int64bit_ ≥ 2<sup>63</sup>, return ℤ(_int64bit_ - 2<sup>64</sup>).\n  1. Else, return ℤ(_int64bit_).","code":"\n        1. Let _n_ be ? ToBigInt(_argument_).\n        1. Let _int64bit_ be ℝ(_n_) modulo 2<sup>64</sup>.\n        1. If _int64bit_ ≥ 2<sup>63</sup>, return ℤ(_int64bit_ - 2<sup>64</sup>); otherwise return ℤ(_int64bit_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ToBigUint64","params":[{"name":"argument","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[BigInt] | Throw"}},"body":"\n  1. Let _n_ be ? ToBigInt(_argument_).\n  1. Let _int64bit_ be ℝ(_n_) modulo 2<sup>64</sup>.\n  1. Return ℤ(_int64bit_).","code":"\n        1. Let _n_ be ? ToBigInt(_argument_).\n        1. Let _int64bit_ be ℝ(_n_) modulo 2<sup>64</sup>.\n        1. Return ℤ(_int64bit_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ToString","params":[{"name":"argument","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[String] | Throw"}},"body":"\n  1. If _argument_ is a String, return _argument_.\n  1. If _argument_ is a Record[Symbol], throw a *TypeError* exception.\n  1. If _argument_ is *undefined*, return *\"undefined\"*.\n  1. If _argument_ is *null*, return *\"null\"*.\n  1. If _argument_ is *true*, return *\"true\"*.\n  1. If _argument_ is *false*, return *\"false\"*.\n  1. If _argument_ is a Number, return Number::toString(_argument_, 10).\n  1. If _argument_ is a BigInt, return BigInt::toString(_argument_, 10).\n  1. Assert: _argument_ is a Record[Object].\n  1. Let _primValue_ be ? ToPrimitive(_argument_, ~string~).\n  1. Assert: _primValue_ is not a Record[Object].\n  1. Return ? ToString(_primValue_).","code":"\n        1. If _argument_ is a String, return _argument_.\n        1. If _argument_ is a Symbol, throw a *TypeError* exception.\n        1. If _argument_ is *undefined*, return *\"undefined\"*.\n        1. If _argument_ is *null*, return *\"null\"*.\n        1. If _argument_ is *true*, return *\"true\"*.\n        1. If _argument_ is *false*, return *\"false\"*.\n        1. If _argument_ is a Number, return Number::toString(_argument_, 10).\n        1. If _argument_ is a BigInt, return BigInt::toString(_argument_, 10).\n        1. Assert: _argument_ is an Object.\n        1. Let _primValue_ be ? ToPrimitive(_argument_, ~string~).\n        1. Assert: _primValue_ is not an Object.\n        1. Return ? ToString(_primValue_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ToPropertyKey","params":[{"name":"argument","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Record[Symbol] | String] | Throw"}},"body":"\n  1. Let _key_ be ? ToPrimitive(_argument_, ~string~).\n  1. If _key_ is a Record[Symbol], then\n    1. Return _key_.\n  1. Return ! ToString(_key_).","code":"\n        1. Let _key_ be ? ToPrimitive(_argument_, ~string~).\n        1. If _key_ is a Symbol, then\n          1. Return _key_.\n        1. Return ! ToString(_key_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ToLength","params":[{"name":"argument","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Number[Int]] | Throw"}},"body":"\n  1. Let _len_ be ? ToIntegerOrInfinity(_argument_).\n  1. If _len_ ≤ 0, return *+0*<sub>𝔽</sub>.\n  1. Return 𝔽(min(_len_, 2<sup>53</sup> - 1)).","code":"\n        1. Let _len_ be ? ToIntegerOrInfinity(_argument_).\n        1. If _len_ ≤ 0, return *+0*<sub>𝔽</sub>.\n        1. Return 𝔽(min(_len_, 2<sup>53</sup> - 1)).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CanonicalNumericIndexString","params":[{"name":"argument","ty":"String","kind":{"Normal":{}}}],"retTy":"Number | Undefined"}},"body":"\n  1. If _argument_ is *\"-0\"*, return *-0*<sub>𝔽</sub>.\n  1. Let _n_ be ! ToNumber(_argument_).\n  1. If ! ToString(_n_) is _argument_, return _n_.\n  1. Return *undefined*.","code":"\n        1. If _argument_ is *\"-0\"*, return *-0*<sub>𝔽</sub>.\n        1. Let _n_ be ! ToNumber(_argument_).\n        1. If ! ToString(_n_) is _argument_, return _n_.\n        1. Return *undefined*.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ToIndex","params":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[NonNegInt] | Throw"}},"body":"\n  1. Let _integer_ be ? ToIntegerOrInfinity(_value_).\n  1. If _integer_ is not in the inclusive interval from 0 to 2<sup>53</sup> - 1, throw a *RangeError* exception.\n  1. Return _integer_.","code":"\n        1. Let _integer_ be ? ToIntegerOrInfinity(_value_).\n        1. If _integer_ is not in the inclusive interval from 0 to 2<sup>53</sup> - 1, throw a *RangeError* exception.\n        1. Return _integer_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsArray","params":[{"name":"argument","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. If _argument_ is not a Record[Object], return *false*.\n  1. If _argument_ is a Record[Array], return *true*.\n  1. If _argument_ is a Record[ProxyExoticObject], then\n    1. Perform ? ValidateNonRevokedProxy(_argument_).\n    1. Let _proxyTarget_ be _argument_.[[ProxyTarget]].\n    1. Return ? IsArray(_proxyTarget_).\n  1. Return *false*.","code":"\n        1. If _argument_ is not an Object, return *false*.\n        1. If _argument_ is an Array exotic object, return *true*.\n        1. If _argument_ is a Proxy exotic object, then\n          1. Perform ? ValidateNonRevokedProxy(_argument_).\n          1. Let _proxyTarget_ be _argument_.[[ProxyTarget]].\n          1. Return ? IsArray(_proxyTarget_).\n        1. Return *false*.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsCallable","params":[{"name":"argument","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _argument_ is not a Record[Object], return *false*.\n  1. If _argument_ has a [[Call]] internal slot, return *true*.\n  1. Return *false*.","code":"\n        1. If _argument_ is not an Object, return *false*.\n        1. If _argument_ has a [[Call]] internal method, return *true*.\n        1. Return *false*.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsConstructor","params":[{"name":"argument","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _argument_ is not a Record[Object], return *false*.\n  1. If _argument_ has a [[Construct]] internal slot, return *true*.\n  1. Return *false*.","code":"\n        1. If _argument_ is not an Object, return *false*.\n        1. If _argument_ has a [[Construct]] internal method, return *true*.\n        1. Return *false*.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsExtensible","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Return ? _O_.[[IsExtensible]]().","code":"\n        1. Return ? <emu-meta effects=\"user-code\">_O_.[[IsExtensible]]</emu-meta>().\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsIntegralNumber","params":[{"name":"argument","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _argument_ is not a Number, return *false*.\n  1. If _argument_ is not finite, return *false*.\n  1. If truncate(ℝ(_argument_)) ≠ ℝ(_argument_), return *false*.\n  1. Return *true*.","code":"\n        1. If _argument_ is not a Number, return *false*.\n        1. If _argument_ is not finite, return *false*.\n        1. If truncate(ℝ(_argument_)) ≠ ℝ(_argument_), return *false*.\n        1. Return *true*.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsPropertyKey","params":[{"name":"argument","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _argument_ is a String, return *true*.\n  1. If _argument_ is a Record[Symbol], return *true*.\n  1. Return *false*.","code":"\n        1. If _argument_ is a String, return *true*.\n        1. If _argument_ is a Symbol, return *true*.\n        1. Return *false*.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsRegExp","params":[{"name":"argument","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. If _argument_ is not a Record[Object], return *false*.\n  1. Let _matcher_ be ? Get(_argument_, @@match).\n  1. If _matcher_ is not *undefined*, return ToBoolean(_matcher_).\n  1. If _argument_ has a [[RegExpMatcher]] internal slot, return *true*.\n  1. Return *false*.","code":"\n        1. If _argument_ is not an Object, return *false*.\n        1. Let _matcher_ be ? Get(_argument_, @@match).\n        1. If _matcher_ is not *undefined*, return ToBoolean(_matcher_).\n        1. If _argument_ has a [[RegExpMatcher]] internal slot, return *true*.\n        1. Return *false*.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsStringWellFormedUnicode","params":[{"name":"string","ty":"String","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _len_ be the length of _string_.\n  1. Let _k_ be 0.\n  1. Repeat, while _k_ < _len_,\n    1. Let _cp_ be CodePointAt(_string_, _k_).\n    1. If _cp_.[[IsUnpairedSurrogate]] is *true*, return *false*.\n    1. Set _k_ to _k_ + _cp_.[[CodeUnitCount]].\n  1. Return *true*.","code":"\n        1. Let _len_ be the length of _string_.\n        1. Let _k_ be 0.\n        1. Repeat, while _k_ < _len_,\n          1. Let _cp_ be CodePointAt(_string_, _k_).\n          1. If _cp_.[[IsUnpairedSurrogate]] is *true*, return *false*.\n          1. Set _k_ to _k_ + _cp_.[[CodeUnitCount]].\n        1. Return *true*.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"SameValue","params":[{"name":"x","ty":"ESValue","kind":{"Normal":{}}},{"name":"y","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If Type(_x_) is not Type(_y_), return *false*.\n  1. If _x_ is a Number, then\n    1. Return Number::sameValue(_x_, _y_).\n  1. Return SameValueNonNumber(_x_, _y_).","code":"\n        1. If Type(_x_) is not Type(_y_), return *false*.\n        1. If _x_ is a Number, then\n          1. Return Number::sameValue(_x_, _y_).\n        1. Return SameValueNonNumber(_x_, _y_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"SameValueZero","params":[{"name":"x","ty":"ESValue","kind":{"Normal":{}}},{"name":"y","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If Type(_x_) is not Type(_y_), return *false*.\n  1. If _x_ is a Number, then\n    1. Return Number::sameValueZero(_x_, _y_).\n  1. Return SameValueNonNumber(_x_, _y_).","code":"\n        1. If Type(_x_) is not Type(_y_), return *false*.\n        1. If _x_ is a Number, then\n          1. Return Number::sameValueZero(_x_, _y_).\n        1. Return SameValueNonNumber(_x_, _y_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"SameValueNonNumber","params":[{"name":"x","ty":"Unknown[\"an ECMAScript language value, but not a Number\"]","kind":{"Normal":{}}},{"name":"y","ty":"Unknown[\"an ECMAScript language value, but not a Number\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Assert: Type(_x_) is Type(_y_).\n  1. If _x_ is either *null* or *undefined*, return *true*.\n  1. If _x_ is a BigInt, then\n    1. Return BigInt::equal(_x_, _y_).\n  1. If _x_ is a String, then\n    1. If _x_ and _y_ have the same length and the same code units in the same positions, return *true*; otherwise, return *false*.\n  1. If _x_ is a Boolean, then\n    1. If _x_ and _y_ are both *true* or both *false*, return *true*; otherwise, return *false*.\n  1. NOTE: All other ECMAScript language values are compared by identity.\n  1. If _x_ is _y_, return *true*.\n  1. Else, return *false*.","code":"\n        1. Assert: Type(_x_) is Type(_y_).\n        1. If _x_ is either *null* or *undefined*, return *true*.\n        1. If _x_ is a BigInt, then\n          1. Return BigInt::equal(_x_, _y_).\n        1. If _x_ is a String, then\n          1. If _x_ and _y_ have the same length and the same code units in the same positions, return *true*; otherwise, return *false*.\n        1. If _x_ is a Boolean, then\n          1. If _x_ and _y_ are both *true* or both *false*, return *true*; otherwise, return *false*.\n        1. NOTE: All other ECMAScript language values are compared by identity.\n        1. If _x_ is _y_, return *true*; otherwise, return *false*.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsLessThan","params":[{"name":"x","ty":"ESValue","kind":{"Normal":{}}},{"name":"y","ty":"ESValue","kind":{"Normal":{}}},{"name":"LeftFirst","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[Boolean | Undefined] | Throw"}},"body":"\n  1. If _LeftFirst_ is *true*, then\n    1. Let _px_ be ? ToPrimitive(_x_, ~number~).\n    1. Let _py_ be ? ToPrimitive(_y_, ~number~).\n  1. Else,\n    1. NOTE: The order of evaluation needs to be reversed to preserve left to right evaluation.\n    1. Let _py_ be ? ToPrimitive(_y_, ~number~).\n    1. Let _px_ be ? ToPrimitive(_x_, ~number~).\n  1. [id=\"step-arc-string-check\"] If _px_ is a String and _py_ is a String, then\n    1. Let _lx_ be the length of _px_.\n    1. Let _ly_ be the length of _py_.\n    1. For each integer _i_ such that 0 ≤ _i_ ≤ the difference min(_lx_, _ly_) minus 1, in ascending order, do\n      1. Let _cx_ be the numeric value of the code unit at index _i_ within _px_.\n      1. Let _cy_ be the numeric value of the code unit at index _i_ within _py_.\n      1. If _cx_ < _cy_, return *true*.\n      1. If _cx_ > _cy_, return *false*.\n    1. If _lx_ < _ly_, return *true*.\n    1. Else, return *false*.\n  1. Else,\n    1. If _px_ is a BigInt and _py_ is a String, then\n      1. Let _ny_ be StringToBigInt(_py_).\n      1. If _ny_ is *undefined*, return *undefined*.\n      1. Return BigInt::lessThan(_px_, _ny_).\n    1. If _px_ is a String and _py_ is a BigInt, then\n      1. Let _nx_ be StringToBigInt(_px_).\n      1. If _nx_ is *undefined*, return *undefined*.\n      1. Return BigInt::lessThan(_nx_, _py_).\n    1. NOTE: Because _px_ and _py_ are primitive values, evaluation order is not important.\n    1. Let _nx_ be ? ToNumeric(_px_).\n    1. Let _ny_ be ? ToNumeric(_py_).\n    1. If Type(_nx_) is Type(_ny_), then\n      1. If _nx_ is a Number, then\n        1. Return Number::lessThan(_nx_, _ny_).\n      1. Else,\n        1. Assert: _nx_ is a BigInt.\n        1. Return BigInt::lessThan(_nx_, _ny_).\n    1. Assert: _nx_ is a BigInt and _ny_ is a Number or _nx_ is a Number and _ny_ is a BigInt.\n    1. If _nx_ is *NaN* or _ny_ is *NaN*, return *undefined*.\n    1. If _nx_ is *-∞*<sub>𝔽</sub> or _ny_ is *+∞*<sub>𝔽</sub>, return *true*.\n    1. If _nx_ is *+∞*<sub>𝔽</sub> or _ny_ is *-∞*<sub>𝔽</sub>, return *false*.\n    1. If ℝ(_nx_) < ℝ(_ny_), return *true*.\n    1. Else, return *false*.","code":"\n        1. If _LeftFirst_ is *true*, then\n          1. Let _px_ be ? ToPrimitive(_x_, ~number~).\n          1. Let _py_ be ? ToPrimitive(_y_, ~number~).\n        1. Else,\n          1. NOTE: The order of evaluation needs to be reversed to preserve left to right evaluation.\n          1. Let _py_ be ? ToPrimitive(_y_, ~number~).\n          1. Let _px_ be ? ToPrimitive(_x_, ~number~).\n        1. [id=\"step-arc-string-check\"] If _px_ is a String and _py_ is a String, then\n          1. Let _lx_ be the length of _px_.\n          1. Let _ly_ be the length of _py_.\n          1. For each integer _i_ such that 0 ≤ _i_ < min(_lx_, _ly_), in ascending order, do\n            1. Let _cx_ be the numeric value of the code unit at index _i_ within _px_.\n            1. Let _cy_ be the numeric value of the code unit at index _i_ within _py_.\n            1. If _cx_ < _cy_, return *true*.\n            1. If _cx_ > _cy_, return *false*.\n          1. If _lx_ < _ly_, return *true*. Otherwise, return *false*.\n        1. Else,\n          1. If _px_ is a BigInt and _py_ is a String, then\n            1. Let _ny_ be StringToBigInt(_py_).\n            1. If _ny_ is *undefined*, return *undefined*.\n            1. Return BigInt::lessThan(_px_, _ny_).\n          1. If _px_ is a String and _py_ is a BigInt, then\n            1. Let _nx_ be StringToBigInt(_px_).\n            1. If _nx_ is *undefined*, return *undefined*.\n            1. Return BigInt::lessThan(_nx_, _py_).\n          1. NOTE: Because _px_ and _py_ are primitive values, evaluation order is not important.\n          1. Let _nx_ be ? <emu-meta suppress-effects=\"user-code\">ToNumeric(_px_)</emu-meta>.\n          1. Let _ny_ be ? <emu-meta suppress-effects=\"user-code\">ToNumeric(_py_)</emu-meta>.\n          1. If Type(_nx_) is Type(_ny_), then\n            1. If _nx_ is a Number, then\n              1. Return Number::lessThan(_nx_, _ny_).\n            1. Else,\n              1. Assert: _nx_ is a BigInt.\n              1. Return BigInt::lessThan(_nx_, _ny_).\n          1. Assert: _nx_ is a BigInt and _ny_ is a Number, or _nx_ is a Number and _ny_ is a BigInt.\n          1. If _nx_ or _ny_ is *NaN*, return *undefined*.\n          1. If _nx_ is *-∞*<sub>𝔽</sub> or _ny_ is *+∞*<sub>𝔽</sub>, return *true*.\n          1. If _nx_ is *+∞*<sub>𝔽</sub> or _ny_ is *-∞*<sub>𝔽</sub>, return *false*.\n          1. If ℝ(_nx_) < ℝ(_ny_), return *true*; otherwise return *false*.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsLooselyEqual","params":[{"name":"x","ty":"ESValue","kind":{"Normal":{}}},{"name":"y","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. If Type(_x_) is Type(_y_), then\n    1. Return IsStrictlyEqual(_x_, _y_).\n  1. If _x_ is *null* and _y_ is *undefined*, return *true*.\n  1. If _x_ is *undefined* and _y_ is *null*, return *true*.\n  1. [id=\"step-abstract-equality-comparison-web-compat-insertion-point\"] NOTE: This step is replaced in section <emu-xref href=\"#sec-IsHTMLDDA-internal-slot-aec\"></emu-xref>.\n  1. If _x_ is a Number and _y_ is a String, return ! IsLooselyEqual(_x_, ! ToNumber(_y_)).\n  1. If _x_ is a String and _y_ is a Number, return ! IsLooselyEqual(! ToNumber(_x_), _y_).\n  1. If _x_ is a BigInt and _y_ is a String, then\n    1. Let _n_ be StringToBigInt(_y_).\n    1. If _n_ is *undefined*, return *false*.\n    1. Return ! IsLooselyEqual(_x_, _n_).\n  1. If _x_ is a String and _y_ is a BigInt, return ! IsLooselyEqual(_y_, _x_).\n  1. If _x_ is a Boolean, return ! IsLooselyEqual(! ToNumber(_x_), _y_).\n  1. If _y_ is a Boolean, return ! IsLooselyEqual(_x_, ! ToNumber(_y_)).\n  1. If _x_ is either a String, a Number, a BigInt, or a Record[Symbol] and _y_ is a Record[Object], return ! IsLooselyEqual(_x_, ? ToPrimitive(_y_)).\n  1. If _x_ is a Record[Object] and _y_ is either a String, a Number, a BigInt, or a Record[Symbol], return ! IsLooselyEqual(? ToPrimitive(_x_), _y_).\n  1. If _x_ is a BigInt and _y_ is a Number or _x_ is a Number and _y_ is a BigInt, then\n    1. If _x_ is not finite or _y_ is not finite, return *false*.\n    1. If ℝ(_x_) = ℝ(_y_), return *true*.\n    1. Else, return *false*.\n  1. Return *false*.","code":"\n        1. If Type(_x_) is Type(_y_), then\n          1. Return IsStrictlyEqual(_x_, _y_).\n        1. If _x_ is *null* and _y_ is *undefined*, return *true*.\n        1. If _x_ is *undefined* and _y_ is *null*, return *true*.\n        1. [id=\"step-abstract-equality-comparison-web-compat-insertion-point\"] NOTE: This step is replaced in section <emu-xref href=\"#sec-IsHTMLDDA-internal-slot-aec\"></emu-xref>.\n        1. If _x_ is a Number and _y_ is a String, return ! IsLooselyEqual(_x_, ! ToNumber(_y_)).\n        1. If _x_ is a String and _y_ is a Number, return ! IsLooselyEqual(! ToNumber(_x_), _y_).\n        1. If _x_ is a BigInt and _y_ is a String, then\n          1. Let _n_ be StringToBigInt(_y_).\n          1. If _n_ is *undefined*, return *false*.\n          1. Return ! IsLooselyEqual(_x_, _n_).\n        1. If _x_ is a String and _y_ is a BigInt, return ! IsLooselyEqual(_y_, _x_).\n        1. If _x_ is a Boolean, return ! IsLooselyEqual(! ToNumber(_x_), _y_).\n        1. If _y_ is a Boolean, return ! IsLooselyEqual(_x_, ! ToNumber(_y_)).\n        1. If _x_ is either a String, a Number, a BigInt, or a Symbol and _y_ is an Object, return ! IsLooselyEqual(_x_, ? ToPrimitive(_y_)).\n        1. If _x_ is an Object and _y_ is either a String, a Number, a BigInt, or a Symbol, return ! IsLooselyEqual(? ToPrimitive(_x_), _y_).\n        1. If _x_ is a BigInt and _y_ is a Number, or if _x_ is a Number and _y_ is a BigInt, then\n          1. If _x_ is not finite or _y_ is not finite, return *false*.\n          1. If ℝ(_x_) = ℝ(_y_), return *true*; otherwise return *false*.\n        1. Return *false*.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsStrictlyEqual","params":[{"name":"x","ty":"ESValue","kind":{"Normal":{}}},{"name":"y","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If Type(_x_) is not Type(_y_), return *false*.\n  1. If _x_ is a Number, then\n    1. Return Number::equal(_x_, _y_).\n  1. Return SameValueNonNumber(_x_, _y_).","code":"\n        1. If Type(_x_) is not Type(_y_), return *false*.\n        1. If _x_ is a Number, then\n          1. Return Number::equal(_x_, _y_).\n        1. Return SameValueNonNumber(_x_, _y_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"MakeBasicObject","params":[{"name":"internalSlotsList","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Record[Object]"}},"body":"\n  1. Let _obj_ be a newly created object with an internal slot for each name in _internalSlotsList_.\n  1. Set _obj_'s essential internal methods to the default ordinary object definitions specified in <emu-xref href=\"#sec-ordinary-object-internal-methods-and-internal-slots\"></emu-xref>.\n  1. Assert: If the caller will not be overriding both _obj_'s [[GetPrototypeOf]] and [[SetPrototypeOf]] essential internal methods, then _internalSlotsList_ contains [[Prototype]]..\n  1. Assert: If the caller will not be overriding all of _obj_'s [[SetPrototypeOf]], [[IsExtensible]], and [[PreventExtensions]] essential internal methods, then _internalSlotsList_ contains [[Extensible]]..\n  1. If _internalSlotsList_ contains [[Extensible]], set _obj_.[[Extensible]] to *true*.\n  1. Return _obj_.","code":"\n        1. Let _obj_ be a newly created object with an internal slot for each name in _internalSlotsList_.\n        1. Set _obj_'s essential internal methods to the default ordinary object definitions specified in <emu-xref href=\"#sec-ordinary-object-internal-methods-and-internal-slots\"></emu-xref>.\n        1. Assert: If the caller will not be overriding both _obj_'s [[GetPrototypeOf]] and [[SetPrototypeOf]] essential internal methods, then _internalSlotsList_ contains [[Prototype]].\n        1. Assert: If the caller will not be overriding all of _obj_'s [[SetPrototypeOf]], [[IsExtensible]], and [[PreventExtensions]] essential internal methods, then _internalSlotsList_ contains [[Extensible]].\n        1. If _internalSlotsList_ contains [[Extensible]], set _obj_.[[Extensible]] to *true*.\n        1. Return _obj_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"Get","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Return ? _O_.[[Get]](_P_, _O_).","code":"\n        1. Return ? <emu-meta effects=\"user-code\">_O_.[[Get]]</emu-meta>(_P_, _O_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetV","params":[{"name":"V","ty":"ESValue","kind":{"Normal":{}}},{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Let _O_ be ? ToObject(_V_).\n  1. Return ? _O_.[[Get]](_P_, _V_).","code":"\n        1. Let _O_ be ? ToObject(_V_).\n        1. Return ? <emu-meta effects=\"user-code\">_O_.[[Get]]</emu-meta>(_P_, _V_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"Set","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}},{"name":"V","ty":"ESValue","kind":{"Normal":{}}},{"name":"Throw","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Let _success_ be ? _O_.[[Set]](_P_, _V_, _O_).\n  1. If _success_ is *false* and _Throw_ is *true*, throw a *TypeError* exception.\n  1. Return ~unused~.","code":"\n        1. Let _success_ be ? <emu-meta effects=\"user-code\">_O_.[[Set]]</emu-meta>(_P_, _V_, _O_).\n        1. If _success_ is *false* and _Throw_ is *true*, throw a *TypeError* exception.\n        1. Return ~unused~.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CreateDataProperty","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}},{"name":"V","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Let _newDesc_ be PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* }.\n  1. Return ? _O_.[[DefineOwnProperty]](_P_, _newDesc_).","code":"\n        1. Let _newDesc_ be the PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* }.\n        1. Return ? <emu-meta effects=\"user-code\">_O_.[[DefineOwnProperty]]</emu-meta>(_P_, _newDesc_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CreateDataPropertyOrThrow","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}},{"name":"V","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Let _success_ be ? CreateDataProperty(_O_, _P_, _V_).\n  1. If _success_ is *false*, throw a *TypeError* exception.\n  1. Return ~unused~.","code":"\n        1. Let _success_ be ? CreateDataProperty(_O_, _P_, _V_).\n        1. If _success_ is *false*, throw a *TypeError* exception.\n        1. Return ~unused~.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CreateNonEnumerableDataPropertyOrThrow","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}},{"name":"V","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Assert: _O_ is an ordinary, extensible object with no non-configurable properties..\n  1. Let _newDesc_ be PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.\n  1. Perform ! DefinePropertyOrThrow(_O_, _P_, _newDesc_).\n  1. Return ~unused~.","code":"\n        1. Assert: _O_ is an ordinary, extensible object with no non-configurable properties.\n        1. Let _newDesc_ be the PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }.\n        1. Perform ! DefinePropertyOrThrow(_O_, _P_, _newDesc_).\n        1. Return ~unused~.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"DefinePropertyOrThrow","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}},{"name":"desc","ty":"Record[PropertyDescriptor]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Let _success_ be ? _O_.[[DefineOwnProperty]](_P_, _desc_).\n  1. If _success_ is *false*, throw a *TypeError* exception.\n  1. Return ~unused~.","code":"\n        1. Let _success_ be ? <emu-meta effects=\"user-code\">_O_.[[DefineOwnProperty]]</emu-meta>(_P_, _desc_).\n        1. If _success_ is *false*, throw a *TypeError* exception.\n        1. Return ~unused~.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"DeletePropertyOrThrow","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Let _success_ be ? _O_.[[Delete]](_P_).\n  1. If _success_ is *false*, throw a *TypeError* exception.\n  1. Return ~unused~.","code":"\n        1. Let _success_ be ? <emu-meta effects=\"user-code\">_O_.[[Delete]]</emu-meta>(_P_).\n        1. If _success_ is *false*, throw a *TypeError* exception.\n        1. Return ~unused~.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetMethod","params":[{"name":"V","ty":"ESValue","kind":{"Normal":{}}},{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Record[FunctionObject] | Undefined] | Throw"}},"body":"\n  1. Let _func_ be ? GetV(_V_, _P_).\n  1. If _func_ is either *undefined* or *null*, return *undefined*.\n  1. If IsCallable(_func_) is *false*, throw a *TypeError* exception.\n  1. Return _func_.","code":"\n        1. Let _func_ be ? GetV(_V_, _P_).\n        1. If _func_ is either *undefined* or *null*, return *undefined*.\n        1. If IsCallable(_func_) is *false*, throw a *TypeError* exception.\n        1. Return _func_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"HasProperty","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Return ? _O_.[[HasProperty]](_P_).","code":"\n        1. Return ? <emu-meta effects=\"user-code\">_O_.[[HasProperty]]</emu-meta>(_P_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"HasOwnProperty","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Let _desc_ be ? _O_.[[GetOwnProperty]](_P_).\n  1. If _desc_ is *undefined*, return *false*.\n  1. Return *true*.","code":"\n        1. Let _desc_ be ? <emu-meta effects=\"user-code\">_O_.[[GetOwnProperty]]</emu-meta>(_P_).\n        1. If _desc_ is *undefined*, return *false*.\n        1. Return *true*.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"Call","params":[{"name":"F","ty":"ESValue","kind":{"Normal":{}}},{"name":"V","ty":"ESValue","kind":{"Normal":{}}},{"name":"argumentsList","ty":"List[ESValue]","kind":{"Optional":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. If _argumentsList_ is not present, set _argumentsList_ to « ».\n  1. If IsCallable(_F_) is *false*, throw a *TypeError* exception.\n  1. Return ? _F_.[[Call]](_V_, _argumentsList_).","code":"\n        1. If _argumentsList_ is not present, set _argumentsList_ to a new empty List.\n        1. If IsCallable(_F_) is *false*, throw a *TypeError* exception.\n        1. Return ? <emu-meta effects=\"user-code\">_F_.[[Call]]</emu-meta>(_V_, _argumentsList_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"Construct","params":[{"name":"F","ty":"Record[Constructor]","kind":{"Normal":{}}},{"name":"argumentsList","ty":"List[ESValue]","kind":{"Optional":{}}},{"name":"newTarget","ty":"Record[Constructor]","kind":{"Optional":{}}}],"retTy":"Normal[Record[Object]] | Throw"}},"body":"\n  1. If _newTarget_ is not present, set _newTarget_ to _F_.\n  1. If _argumentsList_ is not present, set _argumentsList_ to « ».\n  1. Return ? _F_.[[Construct]](_argumentsList_, _newTarget_).","code":"\n        1. If _newTarget_ is not present, set _newTarget_ to _F_.\n        1. If _argumentsList_ is not present, set _argumentsList_ to a new empty List.\n        1. Return ? <emu-meta effects=\"user-code\">_F_.[[Construct]]</emu-meta>(_argumentsList_, _newTarget_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"SetIntegrityLevel","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"level","ty":"Enum[~frozen~, ~sealed~]","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Let _status_ be ? _O_.[[PreventExtensions]]().\n  1. If _status_ is *false*, return *false*.\n  1. Let _keys_ be ? _O_.[[OwnPropertyKeys]]().\n  1. If _level_ is ~sealed~, then\n    1. For each _k_ of _keys_, do\n      1. Perform ? DefinePropertyOrThrow(_O_, _k_, PropertyDescriptor { [[Configurable]]: *false* }).\n  1. Else,\n    1. Assert: _level_ is ~frozen~.\n    1. For each _k_ of _keys_, do\n      1. Let _currentDesc_ be ? _O_.[[GetOwnProperty]](_k_).\n      1. If _currentDesc_ is not *undefined*, then\n        1. If IsAccessorDescriptor(_currentDesc_) is *true*, then\n          1. Let _desc_ be PropertyDescriptor { [[Configurable]]: *false* }.\n        1. Else,\n          1. Let _desc_ be PropertyDescriptor { [[Configurable]]: *false*, [[Writable]]: *false* }.\n        1. Perform ? DefinePropertyOrThrow(_O_, _k_, _desc_).\n  1. Return *true*.","code":"\n        1. Let _status_ be ? _O_.[[PreventExtensions]]().\n        1. If _status_ is *false*, return *false*.\n        1. Let _keys_ be ? _O_.[[OwnPropertyKeys]]().\n        1. If _level_ is ~sealed~, then\n          1. For each element _k_ of _keys_, do\n            1. Perform ? DefinePropertyOrThrow(_O_, _k_, PropertyDescriptor { [[Configurable]]: *false* }).\n        1. Else,\n          1. Assert: _level_ is ~frozen~.\n          1. For each element _k_ of _keys_, do\n            1. Let _currentDesc_ be ? <emu-meta effects=\"user-code\">_O_.[[GetOwnProperty]]</emu-meta>(_k_).\n            1. If _currentDesc_ is not *undefined*, then\n              1. If IsAccessorDescriptor(_currentDesc_) is *true*, then\n                1. Let _desc_ be the PropertyDescriptor { [[Configurable]]: *false* }.\n              1. Else,\n                1. Let _desc_ be the PropertyDescriptor { [[Configurable]]: *false*, [[Writable]]: *false* }.\n              1. Perform ? DefinePropertyOrThrow(_O_, _k_, _desc_).\n        1. Return *true*.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"TestIntegrityLevel","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"level","ty":"Enum[~frozen~, ~sealed~]","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Let _extensible_ be ? IsExtensible(_O_).\n  1. If _extensible_ is *true*, return *false*.\n  1. NOTE: If the object is extensible, none of its properties are examined.\n  1. Let _keys_ be ? _O_.[[OwnPropertyKeys]]().\n  1. For each _k_ of _keys_, do\n    1. Let _currentDesc_ be ? _O_.[[GetOwnProperty]](_k_).\n    1. If _currentDesc_ is not *undefined*, then\n      1. If _currentDesc_.[[Configurable]] is *true*, return *false*.\n      1. If _level_ is ~frozen~ and IsDataDescriptor(_currentDesc_) is *true*, then\n        1. If _currentDesc_.[[Writable]] is *true*, return *false*.\n  1. Return *true*.","code":"\n        1. Let _extensible_ be ? IsExtensible(_O_).\n        1. If _extensible_ is *true*, return *false*.\n        1. NOTE: If the object is extensible, none of its properties are examined.\n        1. Let _keys_ be ? _O_.[[OwnPropertyKeys]]().\n        1. For each element _k_ of _keys_, do\n          1. Let _currentDesc_ be ? <emu-meta effects=\"user-code\">_O_.[[GetOwnProperty]]</emu-meta>(_k_).\n          1. If _currentDesc_ is not *undefined*, then\n            1. If _currentDesc_.[[Configurable]] is *true*, return *false*.\n            1. If _level_ is ~frozen~ and IsDataDescriptor(_currentDesc_) is *true*, then\n              1. If _currentDesc_.[[Writable]] is *true*, return *false*.\n        1. Return *true*.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CreateArrayFromList","params":[{"name":"elements","ty":"List[ESValue]","kind":{"Normal":{}}}],"retTy":"Record[Array]"}},"body":"\n  1. Let _array_ be ! ArrayCreate(0).\n  1. Let _n_ be 0.\n  1. For each _e_ of _elements_, do\n    1. Perform ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_n_)), _e_).\n    1. Set _n_ to _n_ + 1.\n  1. Return _array_.","code":"\n        1. Let _array_ be ! ArrayCreate(0).\n        1. Let _n_ be 0.\n        1. For each element _e_ of _elements_, do\n          1. Perform ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_n_)), _e_).\n          1. Set _n_ to _n_ + 1.\n        1. Return _array_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"LengthOfArrayLike","params":[{"name":"obj","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Normal[NonNegInt] | Throw"}},"body":"\n  1. Return ℝ(? ToLength(? Get(_obj_, *\"length\"*))).","code":"\n        1. Return ℝ(? ToLength(? Get(_obj_, *\"length\"*))).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CreateListFromArrayLike","params":[{"name":"obj","ty":"ESValue","kind":{"Normal":{}}},{"name":"elementTypes","ty":"Unknown[\"a List of names of ECMAScript Language Types\"]","kind":{"Optional":{}}}],"retTy":"Normal[List[ESValue]] | Throw"}},"body":"\n  1. If _elementTypes_ is not present, set _elementTypes_ to « Undefined, Null, Boolean, String, Symbol, Number, BigInt, Object ».\n  1. If _obj_ is not a Record[Object], throw a *TypeError* exception.\n  1. Let _len_ be ? LengthOfArrayLike(_obj_).\n  1. Let _list_ be « ».\n  1. Let _index_ be 0.\n  1. Repeat, while _index_ < _len_,\n    1. Let _indexName_ be ! ToString(𝔽(_index_)).\n    1. Let _next_ be ? Get(_obj_, _indexName_).\n    1. If _elementTypes_ does not contain Type(_next_), throw a *TypeError* exception.\n    1. Append _next_ to _list_.\n    1. Set _index_ to _index_ + 1.\n  1. Return _list_.","code":"\n        1. If _elementTypes_ is not present, set _elementTypes_ to « Undefined, Null, Boolean, String, Symbol, Number, BigInt, Object ».\n        1. If _obj_ is not an Object, throw a *TypeError* exception.\n        1. Let _len_ be ? LengthOfArrayLike(_obj_).\n        1. Let _list_ be a new empty List.\n        1. Let _index_ be 0.\n        1. Repeat, while _index_ < _len_,\n          1. Let _indexName_ be ! ToString(𝔽(_index_)).\n          1. Let _next_ be ? Get(_obj_, _indexName_).\n          1. If _elementTypes_ does not contain Type(_next_), throw a *TypeError* exception.\n          1. Append _next_ to _list_.\n          1. Set _index_ to _index_ + 1.\n        1. Return _list_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"Invoke","params":[{"name":"V","ty":"ESValue","kind":{"Normal":{}}},{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}},{"name":"argumentsList","ty":"List[ESValue]","kind":{"Optional":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. If _argumentsList_ is not present, set _argumentsList_ to « ».\n  1. Let _func_ be ? GetV(_V_, _P_).\n  1. Return ? Call(_func_, _V_, _argumentsList_).","code":"\n        1. If _argumentsList_ is not present, set _argumentsList_ to a new empty List.\n        1. Let _func_ be ? GetV(_V_, _P_).\n        1. Return ? Call(_func_, _V_, _argumentsList_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"OrdinaryHasInstance","params":[{"name":"C","ty":"ESValue","kind":{"Normal":{}}},{"name":"O","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. If IsCallable(_C_) is *false*, return *false*.\n  1. If _C_ has a [[BoundTargetFunction]] internal slot, then\n    1. Let _BC_ be _C_.[[BoundTargetFunction]].\n    1. Return ? InstanceofOperator(_O_, _BC_).\n  1. If _O_ is not a Record[Object], return *false*.\n  1. Let _P_ be ? Get(_C_, *\"prototype\"*).\n  1. If _P_ is not a Record[Object], throw a *TypeError* exception.\n  1. Repeat, \n    1. Set _O_ to ? _O_.[[GetPrototypeOf]]().\n    1. If _O_ is *null*, return *false*.\n    1. If SameValue(_P_, _O_) is *true*, return *true*.","code":"\n        1. If IsCallable(_C_) is *false*, return *false*.\n        1. If _C_ has a [[BoundTargetFunction]] internal slot, then\n          1. Let _BC_ be _C_.[[BoundTargetFunction]].\n          1. Return ? InstanceofOperator(_O_, _BC_).\n        1. If _O_ is not an Object, return *false*.\n        1. Let _P_ be ? Get(_C_, *\"prototype\"*).\n        1. If _P_ is not an Object, throw a *TypeError* exception.\n        1. Repeat,\n          1. Set _O_ to ? <emu-meta effects=\"user-code\">_O_.[[GetPrototypeOf]]</emu-meta>().\n          1. If _O_ is *null*, return *false*.\n          1. If SameValue(_P_, _O_) is *true*, return *true*.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"SpeciesConstructor","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"defaultConstructor","ty":"Record[Constructor]","kind":{"Normal":{}}}],"retTy":"Normal[Record[Constructor]] | Throw"}},"body":"\n  1. Let _C_ be ? Get(_O_, *\"constructor\"*).\n  1. If _C_ is *undefined*, return _defaultConstructor_.\n  1. If _C_ is not a Record[Object], throw a *TypeError* exception.\n  1. Let _S_ be ? Get(_C_, @@species).\n  1. If _S_ is either *undefined* or *null*, return _defaultConstructor_.\n  1. If IsConstructor(_S_) is *true*, return _S_.\n  1. Throw a *TypeError* exception.","code":"\n        1. Let _C_ be ? Get(_O_, *\"constructor\"*).\n        1. If _C_ is *undefined*, return _defaultConstructor_.\n        1. If _C_ is not an Object, throw a *TypeError* exception.\n        1. Let _S_ be ? Get(_C_, @@species).\n        1. If _S_ is either *undefined* or *null*, return _defaultConstructor_.\n        1. If IsConstructor(_S_) is *true*, return _S_.\n        1. Throw a *TypeError* exception.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"EnumerableOwnProperties","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"kind","ty":"Enum[~key+value~, ~key~, ~value~]","kind":{"Normal":{}}}],"retTy":"Normal[List[ESValue]] | Throw"}},"body":"\n  1. Let _ownKeys_ be ? _O_.[[OwnPropertyKeys]]().\n  1. Let _results_ be « ».\n  1. For each _key_ of _ownKeys_, do\n    1. If _key_ is a String, then\n      1. Let _desc_ be ? _O_.[[GetOwnProperty]](_key_).\n      1. If _desc_ is not *undefined* and _desc_.[[Enumerable]] is *true*, then\n        1. If _kind_ is ~key~, then\n          1. Append _key_ to _results_.\n        1. Else,\n          1. Let _value_ be ? Get(_O_, _key_).\n          1. If _kind_ is ~value~, then\n            1. Append _value_ to _results_.\n          1. Else,\n            1. Assert: _kind_ is ~key+value~.\n            1. Let _entry_ be CreateArrayFromList(« _key_, _value_ »).\n            1. Append _entry_ to _results_.\n  1. Return _results_.","code":"\n        1. Let _ownKeys_ be ? <emu-meta effects=\"user-code\">_O_.[[OwnPropertyKeys]]</emu-meta>().\n        1. Let _results_ be a new empty List.\n        1. For each element _key_ of _ownKeys_, do\n          1. If _key_ is a String, then\n            1. Let _desc_ be ? <emu-meta effects=\"user-code\">_O_.[[GetOwnProperty]]</emu-meta>(_key_).\n            1. If _desc_ is not *undefined* and _desc_.[[Enumerable]] is *true*, then\n              1. If _kind_ is ~key~, then\n                1. Append _key_ to _results_.\n              1. Else,\n                1. Let _value_ be ? Get(_O_, _key_).\n                1. If _kind_ is ~value~, then\n                  1. Append _value_ to _results_.\n                1. Else,\n                  1. Assert: _kind_ is ~key+value~.\n                  1. Let _entry_ be CreateArrayFromList(« _key_, _value_ »).\n                  1. Append _entry_ to _results_.\n        1. Return _results_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetFunctionRealm","params":[{"name":"obj","ty":"Record[FunctionObject]","kind":{"Normal":{}}}],"retTy":"Normal[Record[RealmRecord]] | Throw"}},"body":"\n  1. If _obj_ has a [[Realm]] internal slot, then\n    1. Return _obj_.[[Realm]].\n  1. If _obj_ is a Record[BoundFunctionExoticObject], then\n    1. Let _boundTargetFunction_ be _obj_.[[BoundTargetFunction]].\n    1. Return ? GetFunctionRealm(_boundTargetFunction_).\n  1. If _obj_ is a Record[ProxyExoticObject], then\n    1. Perform ? ValidateNonRevokedProxy(_obj_).\n    1. Let _proxyTarget_ be _obj_.[[ProxyTarget]].\n    1. Return ? GetFunctionRealm(_proxyTarget_).\n  1. [id=\"step-getfunctionrealm-default-return\"] Return the current Realm Record.","code":"\n        1. If _obj_ has a [[Realm]] internal slot, then\n          1. Return _obj_.[[Realm]].\n        1. If _obj_ is a bound function exotic object, then\n          1. Let _boundTargetFunction_ be _obj_.[[BoundTargetFunction]].\n          1. Return ? GetFunctionRealm(_boundTargetFunction_).\n        1. If _obj_ is a Proxy exotic object, then\n          1. Perform ? ValidateNonRevokedProxy(_obj_).\n          1. Let _proxyTarget_ be _obj_.[[ProxyTarget]].\n          1. Return ? GetFunctionRealm(_proxyTarget_).\n        1. [id=\"step-getfunctionrealm-default-return\"] Return the current Realm Record.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CopyDataProperties","params":[{"name":"target","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"source","ty":"ESValue","kind":{"Normal":{}}},{"name":"excludedItems","ty":"List[Record[Symbol] | String]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. If _source_ is either *undefined* or *null*, return ~unused~.\n  1. Let _from_ be ! ToObject(_source_).\n  1. Let _keys_ be ? _from_.[[OwnPropertyKeys]]().\n  1. For each _nextKey_ of _keys_, do\n    1. Let _excluded_ be *false*.\n    1. For each _e_ of _excludedItems_, do\n      1. If SameValue(_e_, _nextKey_) is *true*, then\n        1. Set _excluded_ to *true*.\n    1. If _excluded_ is *false*, then\n      1. Let _desc_ be ? _from_.[[GetOwnProperty]](_nextKey_).\n      1. If _desc_ is not *undefined* and _desc_.[[Enumerable]] is *true*, then\n        1. Let _propValue_ be ? Get(_from_, _nextKey_).\n        1. Perform ! CreateDataPropertyOrThrow(_target_, _nextKey_, _propValue_).\n  1. Return ~unused~.","code":"\n        1. If _source_ is either *undefined* or *null*, return ~unused~.\n        1. Let _from_ be ! ToObject(_source_).\n        1. Let _keys_ be ? <emu-meta effects=\"user-code\">_from_.[[OwnPropertyKeys]]</emu-meta>().\n        1. For each element _nextKey_ of _keys_, do\n          1. Let _excluded_ be *false*.\n          1. For each element _e_ of _excludedItems_, do\n            1. If SameValue(_e_, _nextKey_) is *true*, then\n              1. Set _excluded_ to *true*.\n          1. If _excluded_ is *false*, then\n            1. Let _desc_ be ? <emu-meta effects=\"user-code\">_from_.[[GetOwnProperty]]</emu-meta>(_nextKey_).\n            1. If _desc_ is not *undefined* and _desc_.[[Enumerable]] is *true*, then\n              1. Let _propValue_ be ? Get(_from_, _nextKey_).\n              1. Perform ! CreateDataPropertyOrThrow(_target_, _nextKey_, _propValue_).\n        1. Return ~unused~.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"PrivateElementFind","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"P","ty":"Record[PrivateName]","kind":{"Normal":{}}}],"retTy":"Record[PrivateElement] | Enum[~empty~]"}},"body":"\n  1. If _O_.[[PrivateElements]] contains a Record[PrivateElement] _pe_ such that _pe_.[[Key]] is _P_, then\n    1. Return _pe_.\n  1. Return ~empty~.","code":"\n        1. If _O_.[[PrivateElements]] contains a PrivateElement _pe_ such that _pe_.[[Key]] is _P_, then\n          1. Return _pe_.\n        1. Return ~empty~.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"PrivateFieldAdd","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"P","ty":"Record[PrivateName]","kind":{"Normal":{}}},{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. If the host is a web browser, then\n    1. Perform ? HostEnsureCanAddPrivateElement(_O_).\n  1. Let _entry_ be PrivateElementFind(_O_, _P_).\n  1. If _entry_ is not ~empty~, throw a *TypeError* exception.\n  1. Append PrivateElement { [[Key]]: _P_, [[Kind]]: ~field~, [[Value]]: _value_ } to _O_.[[PrivateElements]].\n  1. Return ~unused~.","code":"\n        1. If the host is a web browser, then\n          1. Perform ? HostEnsureCanAddPrivateElement(_O_).\n        1. Let _entry_ be PrivateElementFind(_O_, _P_).\n        1. If _entry_ is not ~empty~, throw a *TypeError* exception.\n        1. Append PrivateElement { [[Key]]: _P_, [[Kind]]: ~field~, [[Value]]: _value_ } to _O_.[[PrivateElements]].\n        1. Return ~unused~.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"PrivateMethodOrAccessorAdd","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"method","ty":"Record[PrivateElement]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Assert: _method_.[[Kind]] is either ~method~ or ~accessor~.\n  1. If the host is a web browser, then\n    1. Perform ? HostEnsureCanAddPrivateElement(_O_).\n  1. Let _entry_ be PrivateElementFind(_O_, _method_.[[Key]]).\n  1. If _entry_ is not ~empty~, throw a *TypeError* exception.\n  1. Append _method_ to _O_.[[PrivateElements]].\n  1. Return ~unused~.","code":"\n        1. Assert: _method_.[[Kind]] is either ~method~ or ~accessor~.\n        1. If the host is a web browser, then\n          1. Perform ? HostEnsureCanAddPrivateElement(_O_).\n        1. Let _entry_ be PrivateElementFind(_O_, _method_.[[Key]]).\n        1. If _entry_ is not ~empty~, throw a *TypeError* exception.\n        1. Append _method_ to _O_.[[PrivateElements]].\n        1. Return ~unused~.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"PrivateGet","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"P","ty":"Record[PrivateName]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Let _entry_ be PrivateElementFind(_O_, _P_).\n  1. If _entry_ is ~empty~, throw a *TypeError* exception.\n  1. If _entry_.[[Kind]] is either ~field~ or ~method~, then\n    1. Return _entry_.[[Value]].\n  1. Assert: _entry_.[[Kind]] is ~accessor~.\n  1. If _entry_.[[Get]] is *undefined*, throw a *TypeError* exception.\n  1. Let _getter_ be _entry_.[[Get]].\n  1. Return ? Call(_getter_, _O_).","code":"\n        1. Let _entry_ be PrivateElementFind(_O_, _P_).\n        1. If _entry_ is ~empty~, throw a *TypeError* exception.\n        1. If _entry_.[[Kind]] is either ~field~ or ~method~, then\n          1. Return _entry_.[[Value]].\n        1. Assert: _entry_.[[Kind]] is ~accessor~.\n        1. If _entry_.[[Get]] is *undefined*, throw a *TypeError* exception.\n        1. Let _getter_ be _entry_.[[Get]].\n        1. Return ? Call(_getter_, _O_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"PrivateSet","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"P","ty":"Record[PrivateName]","kind":{"Normal":{}}},{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Let _entry_ be PrivateElementFind(_O_, _P_).\n  1. If _entry_ is ~empty~, throw a *TypeError* exception.\n  1. If _entry_.[[Kind]] is ~field~, then\n    1. Set _entry_.[[Value]] to _value_.\n  1. Else if _entry_.[[Kind]] is ~method~, then\n    1. Throw a *TypeError* exception.\n  1. Else,\n    1. Assert: _entry_.[[Kind]] is ~accessor~.\n    1. If _entry_.[[Set]] is *undefined*, throw a *TypeError* exception.\n    1. Let _setter_ be _entry_.[[Set]].\n    1. Perform ? Call(_setter_, _O_, « _value_ »).\n  1. Return ~unused~.","code":"\n        1. Let _entry_ be PrivateElementFind(_O_, _P_).\n        1. If _entry_ is ~empty~, throw a *TypeError* exception.\n        1. If _entry_.[[Kind]] is ~field~, then\n          1. Set _entry_.[[Value]] to _value_.\n        1. Else if _entry_.[[Kind]] is ~method~, then\n          1. Throw a *TypeError* exception.\n        1. Else,\n          1. Assert: _entry_.[[Kind]] is ~accessor~.\n          1. If _entry_.[[Set]] is *undefined*, throw a *TypeError* exception.\n          1. Let _setter_ be _entry_.[[Set]].\n          1. Perform ? Call(_setter_, _O_, « _value_ »).\n        1. Return ~unused~.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"DefineField","params":[{"name":"receiver","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"fieldRecord","ty":"Record[ClassFieldDefinitionRecord]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Let _fieldName_ be _fieldRecord_.[[Name]].\n  1. Let _initializer_ be _fieldRecord_.[[Initializer]].\n  1. If _initializer_ is not ~empty~, then\n    1. Let _initValue_ be ? Call(_initializer_, _receiver_).\n  1. Else,\n    1. Let _initValue_ be *undefined*.\n  1. If _fieldName_ is a Record[PrivateName], then\n    1. Perform ? PrivateFieldAdd(_receiver_, _fieldName_, _initValue_).\n  1. Else,\n    1. Assert: IsPropertyKey(_fieldName_) is *true*.\n    1. Perform ? CreateDataPropertyOrThrow(_receiver_, _fieldName_, _initValue_).\n  1. Return ~unused~.","code":"\n        1. Let _fieldName_ be _fieldRecord_.[[Name]].\n        1. Let _initializer_ be _fieldRecord_.[[Initializer]].\n        1. If _initializer_ is not ~empty~, then\n          1. Let _initValue_ be ? Call(_initializer_, _receiver_).\n        1. Else,\n          1. Let _initValue_ be *undefined*.\n        1. If _fieldName_ is a Private Name, then\n          1. Perform ? PrivateFieldAdd(_receiver_, _fieldName_, _initValue_).\n        1. Else,\n          1. Assert: IsPropertyKey(_fieldName_) is *true*.\n          1. Perform ? CreateDataPropertyOrThrow(_receiver_, _fieldName_, _initValue_).\n        1. Return ~unused~.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"InitializeInstanceElements","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"constructor","ty":"Record[ECMAScriptFunctionObject]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Let _methods_ be _constructor_.[[PrivateMethods]].\n  1. For each Record[PrivateElement] _method_ of _methods_, do\n    1. Perform ? PrivateMethodOrAccessorAdd(_O_, _method_).\n  1. Let _fields_ be _constructor_.[[Fields]].\n  1. For each _fieldRecord_ of _fields_, do\n    1. Perform ? DefineField(_O_, _fieldRecord_).\n  1. Return ~unused~.","code":"\n        1. Let _methods_ be the value of _constructor_.[[PrivateMethods]].\n        1. For each PrivateElement _method_ of _methods_, do\n          1. Perform ? PrivateMethodOrAccessorAdd(_O_, _method_).\n        1. Let _fields_ be the value of _constructor_.[[Fields]].\n        1. For each element _fieldRecord_ of _fields_, do\n          1. Perform ? DefineField(_O_, _fieldRecord_).\n        1. Return ~unused~.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AddValueToKeyedGroup","params":[{"name":"groups","ty":"Unknown[\"a List of Records with fields [[Key]] (an ECMAScript language value) and [[Elements]] (a List of ECMAScript language values)\"]","kind":{"Normal":{}}},{"name":"key","ty":"ESValue","kind":{"Normal":{}}},{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. For each Record[{ Elements, Key }] _g_ of _groups_, do\n    1. If SameValue(_g_.[[Key]], _key_) is *true*, then\n      1. Assert: Exactly one element of _groups_ meets this criterion..\n      1. Append _value_ to _g_.[[Elements]].\n      1. Return ~unused~.\n  1. Let _group_ be Record { [[Key]]: _key_, [[Elements]]: « _value_ » }.\n  1. Append _group_ to _groups_.\n  1. Return ~unused~.","code":"\n        1. For each Record { [[Key]], [[Elements]] } _g_ of _groups_, do\n          1. If SameValue(_g_.[[Key]], _key_) is *true*, then\n            1. Assert: Exactly one element of _groups_ meets this criterion.\n            1. Append _value_ to _g_.[[Elements]].\n            1. Return ~unused~.\n        1. Let _group_ be the Record { [[Key]]: _key_, [[Elements]]: « _value_ » }.\n        1. Append _group_ to _groups_.\n        1. Return ~unused~.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GroupBy","params":[{"name":"items","ty":"ESValue","kind":{"Normal":{}}},{"name":"callbackfn","ty":"ESValue","kind":{"Normal":{}}},{"name":"keyCoercion","ty":"Enum[~property~, ~zero~]","kind":{"Normal":{}}}],"retTy":"Unknown[\"either a normal completion containing a List of Records with fields [[Key]] (an ECMAScript language value) and [[Elements]] (a List of ECMAScript language values), or a throw completion\"]"}},"body":"\n  1. Perform ? RequireObjectCoercible(_items_).\n  1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n  1. Let _groups_ be « ».\n  1. Let _iteratorRecord_ be ? GetIterator(_items_, ~sync~).\n  1. Let _k_ be 0.\n  1. Repeat, \n    1. If _k_ ≥ 2<sup>53</sup> - 1, then\n      1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).\n      1. Return ? IteratorClose(_iteratorRecord_, _error_).\n    1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n    1. If _next_ is ~done~, then\n      1. Return _groups_.\n    1. Let _value_ be _next_.\n    1. Let _key_ be Completion(Call(_callbackfn_, *undefined*, « _value_, 𝔽(_k_) »)).\n    1. Perform IfAbruptCloseIterator(_key_, _iteratorRecord_).\n    1. If _keyCoercion_ is ~property~, then\n      1. Set _key_ to Completion(ToPropertyKey(_key_)).\n      1. Perform IfAbruptCloseIterator(_key_, _iteratorRecord_).\n    1. Else,\n      1. Assert: _keyCoercion_ is ~zero~.\n      1. If _key_ is *-0*<sub>𝔽</sub>, set _key_ to *+0*<sub>𝔽</sub>.\n    1. Perform AddValueToKeyedGroup(_groups_, _key_, _value_).\n    1. Set _k_ to _k_ + 1.","code":"\n        1. Perform ? RequireObjectCoercible(_items_).\n        1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n        1. Let _groups_ be a new empty List.\n        1. Let _iteratorRecord_ be ? GetIterator(_items_, ~sync~).\n        1. Let _k_ be 0.\n        1. Repeat,\n          1. If _k_ ≥ 2<sup>53</sup> - 1, then\n            1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).\n            1. Return ? IteratorClose(_iteratorRecord_, _error_).\n          1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n          1. If _next_ is ~done~, then\n            1. Return _groups_.\n          1. Let _value_ be _next_.\n          1. Let _key_ be Completion(Call(_callbackfn_, *undefined*, « _value_, 𝔽(_k_) »)).\n          1. IfAbruptCloseIterator(_key_, _iteratorRecord_).\n          1. If _keyCoercion_ is ~property~, then\n            1. Set _key_ to Completion(ToPropertyKey(_key_)).\n            1. IfAbruptCloseIterator(_key_, _iteratorRecord_).\n          1. Else,\n            1. Assert: _keyCoercion_ is ~zero~.\n            1. If _key_ is *-0*<sub>𝔽</sub>, set _key_ to *+0*<sub>𝔽</sub>.\n          1. Perform AddValueToKeyedGroup(_groups_, _key_, _value_).\n          1. Set _k_ to _k_ + 1.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetIteratorFromMethod","params":[{"name":"obj","ty":"ESValue","kind":{"Normal":{}}},{"name":"method","ty":"Record[FunctionObject]","kind":{"Normal":{}}}],"retTy":"Normal[Record[IteratorRecord]] | Throw"}},"body":"\n  1. Let _iterator_ be ? Call(_method_, _obj_).\n  1. If _iterator_ is not a Record[Object], throw a *TypeError* exception.\n  1. Let _nextMethod_ be ? Get(_iterator_, *\"next\"*).\n  1. Let _iteratorRecord_ be Iterator Record { [[Iterator]]: _iterator_, [[NextMethod]]: _nextMethod_, [[Done]]: *false* }.\n  1. Return _iteratorRecord_.","code":"\n        1. Let _iterator_ be ? Call(_method_, _obj_).\n        1. If _iterator_ is not an Object, throw a *TypeError* exception.\n        1. Let _nextMethod_ be ? Get(_iterator_, *\"next\"*).\n        1. Let _iteratorRecord_ be the Iterator Record { [[Iterator]]: _iterator_, [[NextMethod]]: _nextMethod_, [[Done]]: *false* }.\n        1. Return _iteratorRecord_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetIterator","params":[{"name":"obj","ty":"ESValue","kind":{"Normal":{}}},{"name":"kind","ty":"Enum[~async~, ~sync~]","kind":{"Normal":{}}}],"retTy":"Normal[Record[IteratorRecord]] | Throw"}},"body":"\n  1. If _kind_ is ~async~, then\n    1. Let _method_ be ? GetMethod(_obj_, @@asyncIterator).\n    1. If _method_ is *undefined*, then\n      1. Let _syncMethod_ be ? GetMethod(_obj_, @@iterator).\n      1. If _syncMethod_ is *undefined*, throw a *TypeError* exception.\n      1. Let _syncIteratorRecord_ be ? GetIteratorFromMethod(_obj_, _syncMethod_).\n      1. Return CreateAsyncFromSyncIterator(_syncIteratorRecord_).\n  1. Else,\n    1. Let _method_ be ? GetMethod(_obj_, @@iterator).\n  1. If _method_ is *undefined*, throw a *TypeError* exception.\n  1. Return ? GetIteratorFromMethod(_obj_, _method_).","code":"\n        1. If _kind_ is ~async~, then\n          1. Let _method_ be ? GetMethod(_obj_, @@asyncIterator).\n          1. If _method_ is *undefined*, then\n            1. Let _syncMethod_ be ? GetMethod(_obj_, @@iterator).\n            1. If _syncMethod_ is *undefined*, throw a *TypeError* exception.\n            1. Let _syncIteratorRecord_ be ? GetIteratorFromMethod(_obj_, _syncMethod_).\n            1. Return CreateAsyncFromSyncIterator(_syncIteratorRecord_).\n        1. Else,\n          1. Let _method_ be ? GetMethod(_obj_, @@iterator).\n        1. If _method_ is *undefined*, throw a *TypeError* exception.\n        1. Return ? GetIteratorFromMethod(_obj_, _method_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IteratorNext","params":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}},{"name":"value","ty":"ESValue","kind":{"Optional":{}}}],"retTy":"Normal[Record[Object]] | Throw"}},"body":"\n  1. If _value_ is not present, then\n    1. Let _result_ be ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]]).\n  1. Else,\n    1. Let _result_ be ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]], « _value_ »).\n  1. If _result_ is not a Record[Object], throw a *TypeError* exception.\n  1. Return _result_.","code":"\n        1. If _value_ is not present, then\n          1. Let _result_ be ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]]).\n        1. Else,\n          1. Let _result_ be ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]], « _value_ »).\n        1. If _result_ is not an Object, throw a *TypeError* exception.\n        1. Return _result_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IteratorComplete","params":[{"name":"iterResult","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Return ToBoolean(? Get(_iterResult_, *\"done\"*)).","code":"\n        1. Return ToBoolean(? Get(_iterResult_, *\"done\"*)).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IteratorValue","params":[{"name":"iterResult","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Return ? Get(_iterResult_, *\"value\"*).","code":"\n        1. Return ? Get(_iterResult_, *\"value\"*).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IteratorStep","params":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}}],"retTy":"Normal[Record[Object] | False] | Throw"}},"body":"\n  1. Let _result_ be ? IteratorNext(_iteratorRecord_).\n  1. Let _done_ be ? IteratorComplete(_result_).\n  1. If _done_ is *true*, return *false*.\n  1. Return _result_.","code":"\n        1. Let _result_ be ? IteratorNext(_iteratorRecord_).\n        1. Let _done_ be ? IteratorComplete(_result_).\n        1. If _done_ is *true*, return *false*.\n        1. Return _result_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IteratorStepValue","params":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue | Enum[~done~]] | Throw"}},"body":"\n  1. Let _result_ be Completion(IteratorNext(_iteratorRecord_)).\n  1. If _result_ is a throw completion, then\n    1. Set _iteratorRecord_.[[Done]] to *true*.\n    1. Return ? _result_.\n  1. Set _result_ to ! _result_.\n  1. Let _done_ be Completion(IteratorComplete(_result_)).\n  1. If _done_ is a throw completion, then\n    1. Set _iteratorRecord_.[[Done]] to *true*.\n    1. Return ? _done_.\n  1. Set _done_ to ! _done_.\n  1. If _done_ is *true*, then\n    1. Set _iteratorRecord_.[[Done]] to *true*.\n    1. Return ~done~.\n  1. Let _value_ be Completion(Get(_result_, *\"value\"*)).\n  1. If _value_ is a throw completion, then\n    1. Set _iteratorRecord_.[[Done]] to *true*.\n  1. Return ? _value_.","code":"\n        1. Let _result_ be Completion(IteratorNext(_iteratorRecord_)).\n        1. If _result_ is a throw completion, then\n          1. Set _iteratorRecord_.[[Done]] to *true*.\n          1. Return ? _result_.\n        1. Set _result_ to ! _result_.\n        1. Let _done_ be Completion(IteratorComplete(_result_)).\n        1. If _done_ is a throw completion, then\n          1. Set _iteratorRecord_.[[Done]] to *true*.\n          1. Return ? _done_.\n        1. Set _done_ to ! _done_.\n        1. If _done_ is *true*, then\n          1. Set _iteratorRecord_.[[Done]] to *true*.\n          1. Return ~done~.\n        1. Let _value_ be Completion(Get(_result_, *\"value\"*)).\n        1. If _value_ is a throw completion, then\n          1. Set _iteratorRecord_.[[Done]] to *true*.\n        1. Return ? _value_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IteratorClose","params":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}},{"name":"completion","ty":"Completion","kind":{"Normal":{}}}],"retTy":"Completion"}},"body":"\n  1. Assert: _iteratorRecord_.[[Iterator]] is a Record[Object].\n  1. Let _iterator_ be _iteratorRecord_.[[Iterator]].\n  1. Let _innerResult_ be Completion(GetMethod(_iterator_, *\"return\"*)).\n  1. If _innerResult_ is a normal completion, then\n    1. Let _return_ be _innerResult_.[[Value]].\n    1. If _return_ is *undefined*, return ? _completion_.\n    1. Set _innerResult_ to Completion(Call(_return_, _iterator_)).\n  1. If _completion_ is a throw completion, return ? _completion_.\n  1. If _innerResult_ is a throw completion, return ? _innerResult_.\n  1. If _innerResult_.[[Value]] is not a Record[Object], throw a *TypeError* exception.\n  1. Return ? _completion_.","code":"\n        1. Assert: _iteratorRecord_.[[Iterator]] is an Object.\n        1. Let _iterator_ be _iteratorRecord_.[[Iterator]].\n        1. Let _innerResult_ be Completion(GetMethod(_iterator_, *\"return\"*)).\n        1. If _innerResult_ is a normal completion, then\n          1. Let _return_ be _innerResult_.[[Value]].\n          1. If _return_ is *undefined*, return ? _completion_.\n          1. Set _innerResult_ to Completion(Call(_return_, _iterator_)).\n        1. If _completion_ is a throw completion, return ? _completion_.\n        1. If _innerResult_ is a throw completion, return ? _innerResult_.\n        1. If _innerResult_.[[Value]] is not an Object, throw a *TypeError* exception.\n        1. Return ? _completion_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IfAbruptCloseIterator","params":[{"name":"value","ty":"Unknown","kind":{"Normal":{}}},{"name":"iteratorRecord","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Assert: _value_ is a Completion.\n  1. If _value_ is an abrupt completion, return ? IteratorClose(_iteratorRecord_, _value_).\n  1. Else, set _value_ to ! _value_.","code":"\n        1. Assert: _value_ is a Completion Record.\n        1. If _value_ is an abrupt completion, return ? IteratorClose(_iteratorRecord_, _value_).\n        1. Else, set _value_ to ! _value_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AsyncIteratorClose","params":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}},{"name":"completion","ty":"Completion","kind":{"Normal":{}}}],"retTy":"Completion"}},"body":"\n  1. Assert: _iteratorRecord_.[[Iterator]] is a Record[Object].\n  1. Let _iterator_ be _iteratorRecord_.[[Iterator]].\n  1. Let _innerResult_ be Completion(GetMethod(_iterator_, *\"return\"*)).\n  1. If _innerResult_ is a normal completion, then\n    1. Let _return_ be _innerResult_.[[Value]].\n    1. If _return_ is *undefined*, return ? _completion_.\n    1. Set _innerResult_ to Completion(Call(_return_, _iterator_)).\n    1. If _innerResult_ is a normal completion, set _innerResult_ to Completion(Await(_innerResult_.[[Value]])).\n  1. If _completion_ is a throw completion, return ? _completion_.\n  1. If _innerResult_ is a throw completion, return ? _innerResult_.\n  1. If _innerResult_.[[Value]] is not a Record[Object], throw a *TypeError* exception.\n  1. Return ? _completion_.","code":"\n        1. Assert: _iteratorRecord_.[[Iterator]] is an Object.\n        1. Let _iterator_ be _iteratorRecord_.[[Iterator]].\n        1. Let _innerResult_ be Completion(GetMethod(_iterator_, *\"return\"*)).\n        1. If _innerResult_ is a normal completion, then\n          1. Let _return_ be _innerResult_.[[Value]].\n          1. If _return_ is *undefined*, return ? _completion_.\n          1. Set _innerResult_ to Completion(Call(_return_, _iterator_)).\n          1. If _innerResult_ is a normal completion, set _innerResult_ to Completion(Await(_innerResult_.[[Value]])).\n        1. If _completion_ is a throw completion, return ? _completion_.\n        1. If _innerResult_ is a throw completion, return ? _innerResult_.\n        1. If _innerResult_.[[Value]] is not an Object, throw a *TypeError* exception.\n        1. Return ? _completion_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CreateIterResultObject","params":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}},{"name":"done","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Unknown[\"an Object that conforms to the <i>IteratorResult</i> interface\"]"}},"body":"\n  1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).\n  1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"value\"*, _value_).\n  1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"done\"*, _done_).\n  1. Return _obj_.","code":"\n        1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).\n        1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"value\"*, _value_).\n        1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"done\"*, _done_).\n        1. Return _obj_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CreateListIteratorRecord","params":[{"name":"list","ty":"List[ESValue]","kind":{"Normal":{}}}],"retTy":"Record[IteratorRecord]"}},"body":"\n  1. Let _closure_ be a new Abstract Closure with no parameters that captures _list_ and performs the following steps when called:\n    1. For each _E_ of _list_, do\n      1. Perform ? GeneratorYield(CreateIterResultObject(_E_, *false*)).\n    1. Return NormalCompletion(*undefined*).\n  1. Let _iterator_ be CreateIteratorFromClosure(_closure_, ~empty~, %IteratorPrototype%).\n  1. Return Iterator Record { [[Iterator]]: _iterator_, [[NextMethod]]: %GeneratorFunction.prototype.prototype.next%, [[Done]]: *false* }.","code":"\n        1. Let _closure_ be a new Abstract Closure with no parameters that captures _list_ and performs the following steps when called:\n          1. For each element _E_ of _list_, do\n            1. Perform ? GeneratorYield(CreateIterResultObject(_E_, *false*)).\n          1. Return NormalCompletion(*undefined*).\n        1. Let _iterator_ be CreateIteratorFromClosure(_closure_, ~empty~, %IteratorPrototype%).\n        1. Return the Iterator Record { [[Iterator]]: _iterator_, [[NextMethod]]: %GeneratorFunction.prototype.prototype.next%, [[Done]]: *false* }.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IteratorToList","params":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}}],"retTy":"Normal[List[ESValue]] | Throw"}},"body":"\n  1. Let _values_ be « ».\n  1. Repeat, \n    1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n    1. If _next_ is ~done~, then\n      1. Return _values_.\n    1. Append _next_ to _values_.","code":"\n        1. Let _values_ be a new empty List.\n        1. Repeat,\n          1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n          1. If _next_ is ~done~, then\n            1. Return _values_.\n          1. Append _next_ to _values_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingIdentifier","idx":0,"subIdx":0,"rhsParams":[{"name":"Identifier","ty":"Ast[Identifier]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « StringValue of |Identifier| ».","code":"\n        1. Return a List whose sole element is the StringValue of |Identifier|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingIdentifier","idx":1,"subIdx":0,"rhsParams":[]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « *\"yield\"* ».","code":"\n        1. Return « *\"yield\"* ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingIdentifier","idx":2,"subIdx":0,"rhsParams":[]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « *\"await\"* ».","code":"\n        1. Return « *\"await\"* ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LexicalDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"LetOrConst","ty":"Ast[LetOrConst]","kind":{"Normal":{}}},{"name":"BindingList","ty":"Ast[BindingList]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |BindingList|.","code":"\n        1. Return the BoundNames of |BindingList|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingList","idx":1,"subIdx":0,"rhsParams":[{"name":"BindingList","ty":"Ast[BindingList]","kind":{"Normal":{}}},{"name":"LexicalBinding","ty":"Ast[LexicalBinding]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be BoundNames of |BindingList|.\n  1. Let _names2_ be BoundNames of |LexicalBinding|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be the BoundNames of |BindingList|.\n        1. Let _names2_ be the BoundNames of |LexicalBinding|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LexicalBinding","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |BindingIdentifier|.","code":"\n        1. Return the BoundNames of |BindingIdentifier|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LexicalBinding","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |BindingIdentifier|.","code":"\n        1. Return the BoundNames of |BindingIdentifier|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LexicalBinding","idx":1,"subIdx":0,"rhsParams":[{"name":"BindingPattern","ty":"Ast[BindingPattern]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |BindingPattern|.","code":"\n        1. Return the BoundNames of |BindingPattern|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"VariableDeclarationList","idx":1,"subIdx":0,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"VariableDeclaration","ty":"Ast[VariableDeclaration]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be BoundNames of |VariableDeclarationList|.\n  1. Let _names2_ be BoundNames of |VariableDeclaration|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be BoundNames of |VariableDeclarationList|.\n        1. Let _names2_ be BoundNames of |VariableDeclaration|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"VariableDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |BindingIdentifier|.","code":"\n        1. Return the BoundNames of |BindingIdentifier|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"VariableDeclaration","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |BindingIdentifier|.","code":"\n        1. Return the BoundNames of |BindingIdentifier|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"VariableDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"BindingPattern","ty":"Ast[BindingPattern]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |BindingPattern|.","code":"\n        1. Return the BoundNames of |BindingPattern|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ObjectBindingPattern","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ObjectBindingPattern","idx":3,"subIdx":1,"rhsParams":[{"name":"BindingPropertyList","ty":"Ast[BindingPropertyList]","kind":{"Normal":{}}},{"name":"BindingRestProperty","ty":"Ast[BindingRestProperty]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be BoundNames of |BindingPropertyList|.\n  1. Let _names2_ be BoundNames of |BindingRestProperty|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be BoundNames of |BindingPropertyList|.\n        1. Let _names2_ be BoundNames of |BindingRestProperty|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayBindingPattern","idx":0,"subIdx":0,"rhsParams":[{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayBindingPattern","idx":0,"subIdx":2,"rhsParams":[{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayBindingPattern","idx":0,"subIdx":1,"rhsParams":[{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"BindingRestElement","ty":"Ast[BindingRestElement]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |BindingRestElement|.","code":"\n        1. Return the BoundNames of |BindingRestElement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayBindingPattern","idx":0,"subIdx":3,"rhsParams":[{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"BindingRestElement","ty":"Ast[BindingRestElement]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |BindingRestElement|.","code":"\n        1. Return the BoundNames of |BindingRestElement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayBindingPattern","idx":2,"subIdx":0,"rhsParams":[{"name":"BindingElementList","ty":"Ast[BindingElementList]","kind":{"Normal":{}}},{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |BindingElementList|.","code":"\n        1. Return the BoundNames of |BindingElementList|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayBindingPattern","idx":2,"subIdx":2,"rhsParams":[{"name":"BindingElementList","ty":"Ast[BindingElementList]","kind":{"Normal":{}}},{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |BindingElementList|.","code":"\n        1. Return the BoundNames of |BindingElementList|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayBindingPattern","idx":2,"subIdx":1,"rhsParams":[{"name":"BindingElementList","ty":"Ast[BindingElementList]","kind":{"Normal":{}}},{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"BindingRestElement","ty":"Ast[BindingRestElement]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be BoundNames of |BindingElementList|.\n  1. Let _names2_ be BoundNames of |BindingRestElement|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be BoundNames of |BindingElementList|.\n        1. Let _names2_ be BoundNames of |BindingRestElement|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayBindingPattern","idx":2,"subIdx":3,"rhsParams":[{"name":"BindingElementList","ty":"Ast[BindingElementList]","kind":{"Normal":{}}},{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"BindingRestElement","ty":"Ast[BindingRestElement]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be BoundNames of |BindingElementList|.\n  1. Let _names2_ be BoundNames of |BindingRestElement|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be BoundNames of |BindingElementList|.\n        1. Let _names2_ be BoundNames of |BindingRestElement|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingPropertyList","idx":1,"subIdx":0,"rhsParams":[{"name":"BindingPropertyList","ty":"Ast[BindingPropertyList]","kind":{"Normal":{}}},{"name":"BindingProperty","ty":"Ast[BindingProperty]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be BoundNames of |BindingPropertyList|.\n  1. Let _names2_ be BoundNames of |BindingProperty|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be BoundNames of |BindingPropertyList|.\n        1. Let _names2_ be BoundNames of |BindingProperty|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingElementList","idx":1,"subIdx":0,"rhsParams":[{"name":"BindingElementList","ty":"Ast[BindingElementList]","kind":{"Normal":{}}},{"name":"BindingElisionElement","ty":"Ast[BindingElisionElement]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be BoundNames of |BindingElementList|.\n  1. Let _names2_ be BoundNames of |BindingElisionElement|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be BoundNames of |BindingElementList|.\n        1. Let _names2_ be BoundNames of |BindingElisionElement|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingElisionElement","idx":0,"subIdx":0,"rhsParams":[{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"BindingElement","ty":"Ast[BindingElement]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |BindingElement|.","code":"\n        1. Return BoundNames of |BindingElement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingElisionElement","idx":0,"subIdx":1,"rhsParams":[{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"BindingElement","ty":"Ast[BindingElement]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |BindingElement|.","code":"\n        1. Return BoundNames of |BindingElement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingProperty","idx":1,"subIdx":0,"rhsParams":[{"name":"PropertyName","ty":"Ast[PropertyName]","kind":{"Normal":{}}},{"name":"BindingElement","ty":"Ast[BindingElement]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |BindingElement|.","code":"\n        1. Return the BoundNames of |BindingElement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"SingleNameBinding","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |BindingIdentifier|.","code":"\n        1. Return the BoundNames of |BindingIdentifier|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"SingleNameBinding","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |BindingIdentifier|.","code":"\n        1. Return the BoundNames of |BindingIdentifier|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingElement","idx":1,"subIdx":0,"rhsParams":[{"name":"BindingPattern","ty":"Ast[BindingPattern]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |BindingPattern|.","code":"\n        1. Return the BoundNames of |BindingPattern|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingElement","idx":1,"subIdx":1,"rhsParams":[{"name":"BindingPattern","ty":"Ast[BindingPattern]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |BindingPattern|.","code":"\n        1. Return the BoundNames of |BindingPattern|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"LetOrConst","ty":"Ast[LetOrConst]","kind":{"Normal":{}}},{"name":"ForBinding","ty":"Ast[ForBinding]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |ForBinding|.","code":"\n        1. Return the BoundNames of |ForBinding|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |BindingIdentifier|.","code":"\n        1. Return the BoundNames of |BindingIdentifier|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « *\"\\*default\\*\"* ».","code":"\n        1. Return « *\"\\*default\\*\"* ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FormalParameters","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FormalParameters","idx":4,"subIdx":0,"rhsParams":[{"name":"FormalParameterList","ty":"Ast[FormalParameterList]","kind":{"Normal":{}}},{"name":"FunctionRestParameter","ty":"Ast[FunctionRestParameter]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be BoundNames of |FormalParameterList|.\n  1. Let _names2_ be BoundNames of |FunctionRestParameter|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be BoundNames of |FormalParameterList|.\n        1. Let _names2_ be BoundNames of |FunctionRestParameter|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FormalParameterList","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameterList","ty":"Ast[FormalParameterList]","kind":{"Normal":{}}},{"name":"FormalParameter","ty":"Ast[FormalParameter]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be BoundNames of |FormalParameterList|.\n  1. Let _names2_ be BoundNames of |FormalParameter|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be BoundNames of |FormalParameterList|.\n        1. Let _names2_ be BoundNames of |FormalParameter|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrowParameters","idx":1,"subIdx":0,"rhsParams":[{"name":"CoverParenthesizedExpressionAndArrowParameterList","ty":"Ast[CoverParenthesizedExpressionAndArrowParameterList]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _formals_ be the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n  1. Return BoundNames of _formals_.","code":"\n        1. Let _formals_ be the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n        1. Return the BoundNames of _formals_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |BindingIdentifier|.","code":"\n        1. Return the BoundNames of |BindingIdentifier|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « *\"\\*default\\*\"* ».","code":"\n        1. Return « *\"\\*default\\*\"* ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |BindingIdentifier|.","code":"\n        1. Return the BoundNames of |BindingIdentifier|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « *\"\\*default\\*\"* ».","code":"\n        1. Return « *\"\\*default\\*\"* ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"ClassTail","ty":"Ast[ClassTail]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |BindingIdentifier|.","code":"\n        1. Return the BoundNames of |BindingIdentifier|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"ClassTail","ty":"Ast[ClassTail]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « *\"\\*default\\*\"* ».","code":"\n        1. Return « *\"\\*default\\*\"* ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncFunctionDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |BindingIdentifier|.","code":"\n        1. Return the BoundNames of |BindingIdentifier|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncFunctionDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « *\"\\*default\\*\"* ».","code":"\n        1. Return « *\"\\*default\\*\"* ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CoverCallExpressionAndAsyncArrowHead","idx":0,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"Arguments","ty":"Ast[Arguments]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _head_ be the |AsyncArrowHead| that is covered by |CoverCallExpressionAndAsyncArrowHead|.\n  1. Return BoundNames of _head_.","code":"\n        1. Let _head_ be the |AsyncArrowHead| that is covered by |CoverCallExpressionAndAsyncArrowHead|.\n        1. Return the BoundNames of _head_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ImportDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"ImportClause","ty":"Ast[ImportClause]","kind":{"Normal":{}}},{"name":"FromClause","ty":"Ast[FromClause]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |ImportClause|.","code":"\n        1. Return the BoundNames of |ImportClause|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ImportDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"ModuleSpecifier","ty":"Ast[ModuleSpecifier]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ImportClause","idx":3,"subIdx":0,"rhsParams":[{"name":"ImportedDefaultBinding","ty":"Ast[ImportedDefaultBinding]","kind":{"Normal":{}}},{"name":"NameSpaceImport","ty":"Ast[NameSpaceImport]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be BoundNames of |ImportedDefaultBinding|.\n  1. Let _names2_ be BoundNames of |NameSpaceImport|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be the BoundNames of |ImportedDefaultBinding|.\n        1. Let _names2_ be the BoundNames of |NameSpaceImport|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ImportClause","idx":4,"subIdx":0,"rhsParams":[{"name":"ImportedDefaultBinding","ty":"Ast[ImportedDefaultBinding]","kind":{"Normal":{}}},{"name":"NamedImports","ty":"Ast[NamedImports]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be BoundNames of |ImportedDefaultBinding|.\n  1. Let _names2_ be BoundNames of |NamedImports|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be the BoundNames of |ImportedDefaultBinding|.\n        1. Let _names2_ be the BoundNames of |NamedImports|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NamedImports","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ImportsList","idx":1,"subIdx":0,"rhsParams":[{"name":"ImportsList","ty":"Ast[ImportsList]","kind":{"Normal":{}}},{"name":"ImportSpecifier","ty":"Ast[ImportSpecifier]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be BoundNames of |ImportsList|.\n  1. Let _names2_ be BoundNames of |ImportSpecifier|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be the BoundNames of |ImportsList|.\n        1. Let _names2_ be the BoundNames of |ImportSpecifier|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ImportSpecifier","idx":1,"subIdx":0,"rhsParams":[{"name":"ModuleExportName","ty":"Ast[ModuleExportName]","kind":{"Normal":{}}},{"name":"ImportedBinding","ty":"Ast[ImportedBinding]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |ImportedBinding|.","code":"\n        1. Return the BoundNames of |ImportedBinding|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"ExportFromClause","ty":"Ast[ExportFromClause]","kind":{"Normal":{}}},{"name":"FromClause","ty":"Ast[FromClause]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"NamedExports","ty":"Ast[NamedExports]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":2,"subIdx":0,"rhsParams":[{"name":"VariableStatement","ty":"Ast[VariableStatement]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |VariableStatement|.","code":"\n        1. Return the BoundNames of |VariableStatement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":3,"subIdx":0,"rhsParams":[{"name":"Declaration","ty":"Ast[Declaration]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |Declaration|.","code":"\n        1. Return the BoundNames of |Declaration|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":4,"subIdx":0,"rhsParams":[{"name":"HoistableDeclaration","ty":"Ast[HoistableDeclaration]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _declarationNames_ be BoundNames of |HoistableDeclaration|.\n  1. If _declarationNames_ does not include the element *\"\\*default\\*\"*, append *\"\\*default\\*\"* to _declarationNames_.\n  1. Return _declarationNames_.","code":"\n        1. Let _declarationNames_ be the BoundNames of |HoistableDeclaration|.\n        1. If _declarationNames_ does not include the element *\"\\*default\\*\"*, append *\"\\*default\\*\"* to _declarationNames_.\n        1. Return _declarationNames_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":5,"subIdx":0,"rhsParams":[{"name":"ClassDeclaration","ty":"Ast[ClassDeclaration]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _declarationNames_ be BoundNames of |ClassDeclaration|.\n  1. If _declarationNames_ does not include the element *\"\\*default\\*\"*, append *\"\\*default\\*\"* to _declarationNames_.\n  1. Return _declarationNames_.","code":"\n        1. Let _declarationNames_ be the BoundNames of |ClassDeclaration|.\n        1. If _declarationNames_ does not include the element *\"\\*default\\*\"*, append *\"\\*default\\*\"* to _declarationNames_.\n        1. Return _declarationNames_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":6,"subIdx":0,"rhsParams":[{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"BoundNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « *\"\\*default\\*\"* ».","code":"\n        1. Return « *\"\\*default\\*\"* ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"HoistableDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"FunctionDeclaration","ty":"Ast[FunctionDeclaration]","kind":{"Normal":{}}}]},"methodName":"DeclarationPart","isStatic":true,"withParams":[],"retTy":"Ast"}},"body":"\n  1. Return |FunctionDeclaration|.","code":"\n        1. Return |FunctionDeclaration|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"HoistableDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"GeneratorDeclaration","ty":"Ast[GeneratorDeclaration]","kind":{"Normal":{}}}]},"methodName":"DeclarationPart","isStatic":true,"withParams":[],"retTy":"Ast"}},"body":"\n  1. Return |GeneratorDeclaration|.","code":"\n        1. Return |GeneratorDeclaration|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"HoistableDeclaration","idx":2,"subIdx":0,"rhsParams":[{"name":"AsyncFunctionDeclaration","ty":"Ast[AsyncFunctionDeclaration]","kind":{"Normal":{}}}]},"methodName":"DeclarationPart","isStatic":true,"withParams":[],"retTy":"Ast"}},"body":"\n  1. Return |AsyncFunctionDeclaration|.","code":"\n        1. Return |AsyncFunctionDeclaration|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"HoistableDeclaration","idx":3,"subIdx":0,"rhsParams":[{"name":"AsyncGeneratorDeclaration","ty":"Ast[AsyncGeneratorDeclaration]","kind":{"Normal":{}}}]},"methodName":"DeclarationPart","isStatic":true,"withParams":[],"retTy":"Ast"}},"body":"\n  1. Return |AsyncGeneratorDeclaration|.","code":"\n        1. Return |AsyncGeneratorDeclaration|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Declaration","idx":1,"subIdx":0,"rhsParams":[{"name":"ClassDeclaration","ty":"Ast[ClassDeclaration]","kind":{"Normal":{}}}]},"methodName":"DeclarationPart","isStatic":true,"withParams":[],"retTy":"Ast"}},"body":"\n  1. Return |ClassDeclaration|.","code":"\n        1. Return |ClassDeclaration|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Declaration","idx":2,"subIdx":0,"rhsParams":[{"name":"LexicalDeclaration","ty":"Ast[LexicalDeclaration]","kind":{"Normal":{}}}]},"methodName":"DeclarationPart","isStatic":true,"withParams":[],"retTy":"Ast"}},"body":"\n  1. Return |LexicalDeclaration|.","code":"\n        1. Return |LexicalDeclaration|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LexicalDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"LetOrConst","ty":"Ast[LetOrConst]","kind":{"Normal":{}}},{"name":"BindingList","ty":"Ast[BindingList]","kind":{"Normal":{}}}]},"methodName":"IsConstantDeclaration","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return IsConstantDeclaration of |LetOrConst|.","code":"\n        1. Return IsConstantDeclaration of |LetOrConst|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LetOrConst","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"IsConstantDeclaration","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LetOrConst","idx":1,"subIdx":0,"rhsParams":[]},"methodName":"IsConstantDeclaration","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"IsConstantDeclaration","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"IsConstantDeclaration","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"IsConstantDeclaration","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"IsConstantDeclaration","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"IsConstantDeclaration","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"IsConstantDeclaration","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncFunctionDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"IsConstantDeclaration","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncFunctionDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"IsConstantDeclaration","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"ClassTail","ty":"Ast[ClassTail]","kind":{"Normal":{}}}]},"methodName":"IsConstantDeclaration","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"ClassTail","ty":"Ast[ClassTail]","kind":{"Normal":{}}}]},"methodName":"IsConstantDeclaration","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"ExportFromClause","ty":"Ast[ExportFromClause]","kind":{"Normal":{}}},{"name":"FromClause","ty":"Ast[FromClause]","kind":{"Normal":{}}}]},"methodName":"IsConstantDeclaration","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"NamedExports","ty":"Ast[NamedExports]","kind":{"Normal":{}}}]},"methodName":"IsConstantDeclaration","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":6,"subIdx":0,"rhsParams":[{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"IsConstantDeclaration","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Block","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"LexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementList","idx":1,"subIdx":0,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}},{"name":"StatementListItem","ty":"Ast[StatementListItem]","kind":{"Normal":{}}}]},"methodName":"LexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be LexicallyDeclaredNames of |StatementList|.\n  1. Let _names2_ be LexicallyDeclaredNames of |StatementListItem|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be LexicallyDeclaredNames of |StatementList|.\n        1. Let _names2_ be LexicallyDeclaredNames of |StatementListItem|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementListItem","idx":0,"subIdx":0,"rhsParams":[{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"LexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar>, return LexicallyDeclaredNames of |LabelledStatement|.\n  1. Return « ».","code":"\n        1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar>, return LexicallyDeclaredNames of |LabelledStatement|.\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementListItem","idx":1,"subIdx":0,"rhsParams":[{"name":"Declaration","ty":"Ast[Declaration]","kind":{"Normal":{}}}]},"methodName":"LexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |Declaration|.","code":"\n        1. Return the BoundNames of |Declaration|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"LexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":0,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"LexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. If the first |CaseClauses| is present, let _names1_ be LexicallyDeclaredNames of the first |CaseClauses|.\n  1. Else, let _names1_ be « ».\n  1. Let _names2_ be LexicallyDeclaredNames of |DefaultClause|.\n  1. If the second |CaseClauses| is present, let _names3_ be LexicallyDeclaredNames of the second |CaseClauses|.\n  1. Else, let _names3_ be « ».\n  1. Return the list-concatenation of _names1_, _names2_, and _names3_.","code":"\n        1. If the first |CaseClauses| is present, let _names1_ be the LexicallyDeclaredNames of the first |CaseClauses|.\n        1. Else, let _names1_ be a new empty List.\n        1. Let _names2_ be LexicallyDeclaredNames of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _names3_ be the LexicallyDeclaredNames of the second |CaseClauses|.\n        1. Else, let _names3_ be a new empty List.\n        1. Return the list-concatenation of _names1_, _names2_, and _names3_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":1,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"LexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. If the first |CaseClauses| is present, let _names1_ be LexicallyDeclaredNames of the first |CaseClauses|.\n  1. Else, let _names1_ be « ».\n  1. Let _names2_ be LexicallyDeclaredNames of |DefaultClause|.\n  1. If the second |CaseClauses| is present, let _names3_ be LexicallyDeclaredNames of the second |CaseClauses|.\n  1. Else, let _names3_ be « ».\n  1. Return the list-concatenation of _names1_, _names2_, and _names3_.","code":"\n        1. If the first |CaseClauses| is present, let _names1_ be the LexicallyDeclaredNames of the first |CaseClauses|.\n        1. Else, let _names1_ be a new empty List.\n        1. Let _names2_ be LexicallyDeclaredNames of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _names3_ be the LexicallyDeclaredNames of the second |CaseClauses|.\n        1. Else, let _names3_ be a new empty List.\n        1. Return the list-concatenation of _names1_, _names2_, and _names3_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":2,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"LexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. If the first |CaseClauses| is present, let _names1_ be LexicallyDeclaredNames of the first |CaseClauses|.\n  1. Else, let _names1_ be « ».\n  1. Let _names2_ be LexicallyDeclaredNames of |DefaultClause|.\n  1. If the second |CaseClauses| is present, let _names3_ be LexicallyDeclaredNames of the second |CaseClauses|.\n  1. Else, let _names3_ be « ».\n  1. Return the list-concatenation of _names1_, _names2_, and _names3_.","code":"\n        1. If the first |CaseClauses| is present, let _names1_ be the LexicallyDeclaredNames of the first |CaseClauses|.\n        1. Else, let _names1_ be a new empty List.\n        1. Let _names2_ be LexicallyDeclaredNames of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _names3_ be the LexicallyDeclaredNames of the second |CaseClauses|.\n        1. Else, let _names3_ be a new empty List.\n        1. Return the list-concatenation of _names1_, _names2_, and _names3_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":3,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"LexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. If the first |CaseClauses| is present, let _names1_ be LexicallyDeclaredNames of the first |CaseClauses|.\n  1. Else, let _names1_ be « ».\n  1. Let _names2_ be LexicallyDeclaredNames of |DefaultClause|.\n  1. If the second |CaseClauses| is present, let _names3_ be LexicallyDeclaredNames of the second |CaseClauses|.\n  1. Else, let _names3_ be « ».\n  1. Return the list-concatenation of _names1_, _names2_, and _names3_.","code":"\n        1. If the first |CaseClauses| is present, let _names1_ be the LexicallyDeclaredNames of the first |CaseClauses|.\n        1. Else, let _names1_ be a new empty List.\n        1. Let _names2_ be LexicallyDeclaredNames of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _names3_ be the LexicallyDeclaredNames of the second |CaseClauses|.\n        1. Else, let _names3_ be a new empty List.\n        1. Return the list-concatenation of _names1_, _names2_, and _names3_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseClauses","idx":1,"subIdx":0,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"CaseClause","ty":"Ast[CaseClause]","kind":{"Normal":{}}}]},"methodName":"LexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be LexicallyDeclaredNames of |CaseClauses|.\n  1. Let _names2_ be LexicallyDeclaredNames of |CaseClause|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be LexicallyDeclaredNames of |CaseClauses|.\n        1. Let _names2_ be LexicallyDeclaredNames of |CaseClause|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseClause","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"LexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. If |StatementList| is present, return LexicallyDeclaredNames of |StatementList|.\n  1. Return « ».","code":"\n        1. If the |StatementList| is present, return the LexicallyDeclaredNames of |StatementList|.\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseClause","idx":0,"subIdx":1,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"LexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. If |StatementList| is present, return LexicallyDeclaredNames of |StatementList|.\n  1. Return « ».","code":"\n        1. If the |StatementList| is present, return the LexicallyDeclaredNames of |StatementList|.\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DefaultClause","idx":0,"subIdx":0,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"LexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. If |StatementList| is present, return LexicallyDeclaredNames of |StatementList|.\n  1. Return « ».","code":"\n        1. If the |StatementList| is present, return the LexicallyDeclaredNames of |StatementList|.\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DefaultClause","idx":0,"subIdx":1,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"LexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. If |StatementList| is present, return LexicallyDeclaredNames of |StatementList|.\n  1. Return « ».","code":"\n        1. If the |StatementList| is present, return the LexicallyDeclaredNames of |StatementList|.\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LabelledStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"LabelIdentifier","ty":"Ast[LabelIdentifier]","kind":{"Normal":{}}},{"name":"LabelledItem","ty":"Ast[LabelledItem]","kind":{"Normal":{}}}]},"methodName":"LexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return LexicallyDeclaredNames of |LabelledItem|.","code":"\n        1. Return the LexicallyDeclaredNames of |LabelledItem|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LabelledItem","idx":0,"subIdx":0,"rhsParams":[{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"LexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LabelledItem","idx":1,"subIdx":0,"rhsParams":[{"name":"FunctionDeclaration","ty":"Ast[FunctionDeclaration]","kind":{"Normal":{}}}]},"methodName":"LexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |FunctionDeclaration|.","code":"\n        1. Return BoundNames of |FunctionDeclaration|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionStatementList","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"LexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionStatementList","idx":0,"subIdx":1,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"LexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return TopLevelLexicallyDeclaredNames of |StatementList|.","code":"\n        1. Return TopLevelLexicallyDeclaredNames of |StatementList|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassStaticBlockStatementList","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"LexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassStaticBlockStatementList","idx":0,"subIdx":1,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"LexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return TopLevelLexicallyDeclaredNames of |StatementList|.","code":"\n        1. Return the TopLevelLexicallyDeclaredNames of |StatementList|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ConciseBody","idx":0,"subIdx":0,"rhsParams":[{"name":"ExpressionBody","ty":"Ast[ExpressionBody]","kind":{"Normal":{}}}]},"methodName":"LexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncConciseBody","idx":0,"subIdx":0,"rhsParams":[{"name":"ExpressionBody","ty":"Ast[ExpressionBody]","kind":{"Normal":{}}}]},"methodName":"LexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Script","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"LexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ScriptBody","idx":0,"subIdx":0,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"LexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return TopLevelLexicallyDeclaredNames of |StatementList|.","code":"\n        1. Return TopLevelLexicallyDeclaredNames of |StatementList|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItemList","idx":1,"subIdx":0,"rhsParams":[{"name":"ModuleItemList","ty":"Ast[ModuleItemList]","kind":{"Normal":{}}},{"name":"ModuleItem","ty":"Ast[ModuleItem]","kind":{"Normal":{}}}]},"methodName":"LexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be LexicallyDeclaredNames of |ModuleItemList|.\n  1. Let _names2_ be LexicallyDeclaredNames of |ModuleItem|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be LexicallyDeclaredNames of |ModuleItemList|.\n        1. Let _names2_ be LexicallyDeclaredNames of |ModuleItem|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItem","idx":0,"subIdx":0,"rhsParams":[{"name":"ImportDeclaration","ty":"Ast[ImportDeclaration]","kind":{"Normal":{}}}]},"methodName":"LexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |ImportDeclaration|.","code":"\n        1. Return the BoundNames of |ImportDeclaration|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItem","idx":1,"subIdx":0,"rhsParams":[{"name":"ExportDeclaration","ty":"Ast[ExportDeclaration]","kind":{"Normal":{}}}]},"methodName":"LexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. If |ExportDeclaration| is `export` |VariableStatement|, return a new empty List.\n  1. Return BoundNames of |ExportDeclaration|.","code":"\n        1. If |ExportDeclaration| is `export` |VariableStatement|, return a new empty List.\n        1. Return the BoundNames of |ExportDeclaration|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItem","idx":2,"subIdx":0,"rhsParams":[{"name":"StatementListItem","ty":"Ast[StatementListItem]","kind":{"Normal":{}}}]},"methodName":"LexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return LexicallyDeclaredNames of |StatementListItem|.","code":"\n        1. Return LexicallyDeclaredNames of |StatementListItem|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementList","idx":1,"subIdx":0,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}},{"name":"StatementListItem","ty":"Ast[StatementListItem]","kind":{"Normal":{}}}]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Let _declarations1_ be LexicallyScopedDeclarations of |StatementList|.\n  1. Let _declarations2_ be LexicallyScopedDeclarations of |StatementListItem|.\n  1. Return the list-concatenation of _declarations1_ and _declarations2_.","code":"\n        1. Let _declarations1_ be LexicallyScopedDeclarations of |StatementList|.\n        1. Let _declarations2_ be LexicallyScopedDeclarations of |StatementListItem|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementListItem","idx":0,"subIdx":0,"rhsParams":[{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar>, return LexicallyScopedDeclarations of |LabelledStatement|.\n  1. Return « ».","code":"\n        1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar>, return LexicallyScopedDeclarations of |LabelledStatement|.\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementListItem","idx":1,"subIdx":0,"rhsParams":[{"name":"Declaration","ty":"Ast[Declaration]","kind":{"Normal":{}}}]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « DeclarationPart of |Declaration| ».","code":"\n        1. Return a List whose sole element is DeclarationPart of |Declaration|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":0,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. If the first |CaseClauses| is present, let _declarations1_ be LexicallyScopedDeclarations of the first |CaseClauses|.\n  1. Else, let _declarations1_ be « ».\n  1. Let _declarations2_ be LexicallyScopedDeclarations of |DefaultClause|.\n  1. If the second |CaseClauses| is present, let _declarations3_ be LexicallyScopedDeclarations of the second |CaseClauses|.\n  1. Else, let _declarations3_ be « ».\n  1. Return the list-concatenation of _declarations1_, _declarations2_, and _declarations3_.","code":"\n        1. If the first |CaseClauses| is present, let _declarations1_ be the LexicallyScopedDeclarations of the first |CaseClauses|.\n        1. Else, let _declarations1_ be a new empty List.\n        1. Let _declarations2_ be LexicallyScopedDeclarations of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _declarations3_ be the LexicallyScopedDeclarations of the second |CaseClauses|.\n        1. Else, let _declarations3_ be a new empty List.\n        1. Return the list-concatenation of _declarations1_, _declarations2_, and _declarations3_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":1,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. If the first |CaseClauses| is present, let _declarations1_ be LexicallyScopedDeclarations of the first |CaseClauses|.\n  1. Else, let _declarations1_ be « ».\n  1. Let _declarations2_ be LexicallyScopedDeclarations of |DefaultClause|.\n  1. If the second |CaseClauses| is present, let _declarations3_ be LexicallyScopedDeclarations of the second |CaseClauses|.\n  1. Else, let _declarations3_ be « ».\n  1. Return the list-concatenation of _declarations1_, _declarations2_, and _declarations3_.","code":"\n        1. If the first |CaseClauses| is present, let _declarations1_ be the LexicallyScopedDeclarations of the first |CaseClauses|.\n        1. Else, let _declarations1_ be a new empty List.\n        1. Let _declarations2_ be LexicallyScopedDeclarations of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _declarations3_ be the LexicallyScopedDeclarations of the second |CaseClauses|.\n        1. Else, let _declarations3_ be a new empty List.\n        1. Return the list-concatenation of _declarations1_, _declarations2_, and _declarations3_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":2,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. If the first |CaseClauses| is present, let _declarations1_ be LexicallyScopedDeclarations of the first |CaseClauses|.\n  1. Else, let _declarations1_ be « ».\n  1. Let _declarations2_ be LexicallyScopedDeclarations of |DefaultClause|.\n  1. If the second |CaseClauses| is present, let _declarations3_ be LexicallyScopedDeclarations of the second |CaseClauses|.\n  1. Else, let _declarations3_ be « ».\n  1. Return the list-concatenation of _declarations1_, _declarations2_, and _declarations3_.","code":"\n        1. If the first |CaseClauses| is present, let _declarations1_ be the LexicallyScopedDeclarations of the first |CaseClauses|.\n        1. Else, let _declarations1_ be a new empty List.\n        1. Let _declarations2_ be LexicallyScopedDeclarations of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _declarations3_ be the LexicallyScopedDeclarations of the second |CaseClauses|.\n        1. Else, let _declarations3_ be a new empty List.\n        1. Return the list-concatenation of _declarations1_, _declarations2_, and _declarations3_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":3,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. If the first |CaseClauses| is present, let _declarations1_ be LexicallyScopedDeclarations of the first |CaseClauses|.\n  1. Else, let _declarations1_ be « ».\n  1. Let _declarations2_ be LexicallyScopedDeclarations of |DefaultClause|.\n  1. If the second |CaseClauses| is present, let _declarations3_ be LexicallyScopedDeclarations of the second |CaseClauses|.\n  1. Else, let _declarations3_ be « ».\n  1. Return the list-concatenation of _declarations1_, _declarations2_, and _declarations3_.","code":"\n        1. If the first |CaseClauses| is present, let _declarations1_ be the LexicallyScopedDeclarations of the first |CaseClauses|.\n        1. Else, let _declarations1_ be a new empty List.\n        1. Let _declarations2_ be LexicallyScopedDeclarations of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _declarations3_ be the LexicallyScopedDeclarations of the second |CaseClauses|.\n        1. Else, let _declarations3_ be a new empty List.\n        1. Return the list-concatenation of _declarations1_, _declarations2_, and _declarations3_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseClauses","idx":1,"subIdx":0,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"CaseClause","ty":"Ast[CaseClause]","kind":{"Normal":{}}}]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Let _declarations1_ be LexicallyScopedDeclarations of |CaseClauses|.\n  1. Let _declarations2_ be LexicallyScopedDeclarations of |CaseClause|.\n  1. Return the list-concatenation of _declarations1_ and _declarations2_.","code":"\n        1. Let _declarations1_ be LexicallyScopedDeclarations of |CaseClauses|.\n        1. Let _declarations2_ be LexicallyScopedDeclarations of |CaseClause|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseClause","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. If |StatementList| is present, return LexicallyScopedDeclarations of |StatementList|.\n  1. Return « ».","code":"\n        1. If the |StatementList| is present, return the LexicallyScopedDeclarations of |StatementList|.\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseClause","idx":0,"subIdx":1,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. If |StatementList| is present, return LexicallyScopedDeclarations of |StatementList|.\n  1. Return « ».","code":"\n        1. If the |StatementList| is present, return the LexicallyScopedDeclarations of |StatementList|.\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DefaultClause","idx":0,"subIdx":0,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. If |StatementList| is present, return LexicallyScopedDeclarations of |StatementList|.\n  1. Return « ».","code":"\n        1. If the |StatementList| is present, return the LexicallyScopedDeclarations of |StatementList|.\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DefaultClause","idx":0,"subIdx":1,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. If |StatementList| is present, return LexicallyScopedDeclarations of |StatementList|.\n  1. Return « ».","code":"\n        1. If the |StatementList| is present, return the LexicallyScopedDeclarations of |StatementList|.\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LabelledStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"LabelIdentifier","ty":"Ast[LabelIdentifier]","kind":{"Normal":{}}},{"name":"LabelledItem","ty":"Ast[LabelledItem]","kind":{"Normal":{}}}]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return LexicallyScopedDeclarations of |LabelledItem|.","code":"\n        1. Return the LexicallyScopedDeclarations of |LabelledItem|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LabelledItem","idx":0,"subIdx":0,"rhsParams":[{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LabelledItem","idx":1,"subIdx":0,"rhsParams":[{"name":"FunctionDeclaration","ty":"Ast[FunctionDeclaration]","kind":{"Normal":{}}}]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « |FunctionDeclaration| ».","code":"\n        1. Return « |FunctionDeclaration| ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionStatementList","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionStatementList","idx":0,"subIdx":1,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return TopLevelLexicallyScopedDeclarations of |StatementList|.","code":"\n        1. Return the TopLevelLexicallyScopedDeclarations of |StatementList|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassStaticBlockStatementList","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassStaticBlockStatementList","idx":0,"subIdx":1,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return TopLevelLexicallyScopedDeclarations of |StatementList|.","code":"\n        1. Return the TopLevelLexicallyScopedDeclarations of |StatementList|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ConciseBody","idx":0,"subIdx":0,"rhsParams":[{"name":"ExpressionBody","ty":"Ast[ExpressionBody]","kind":{"Normal":{}}}]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncConciseBody","idx":0,"subIdx":0,"rhsParams":[{"name":"ExpressionBody","ty":"Ast[ExpressionBody]","kind":{"Normal":{}}}]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Script","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ScriptBody","idx":0,"subIdx":0,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return TopLevelLexicallyScopedDeclarations of |StatementList|.","code":"\n        1. Return TopLevelLexicallyScopedDeclarations of |StatementList|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Module","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItemList","idx":1,"subIdx":0,"rhsParams":[{"name":"ModuleItemList","ty":"Ast[ModuleItemList]","kind":{"Normal":{}}},{"name":"ModuleItem","ty":"Ast[ModuleItem]","kind":{"Normal":{}}}]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Let _declarations1_ be LexicallyScopedDeclarations of |ModuleItemList|.\n  1. Let _declarations2_ be LexicallyScopedDeclarations of |ModuleItem|.\n  1. Return the list-concatenation of _declarations1_ and _declarations2_.","code":"\n        1. Let _declarations1_ be LexicallyScopedDeclarations of |ModuleItemList|.\n        1. Let _declarations2_ be LexicallyScopedDeclarations of |ModuleItem|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItem","idx":0,"subIdx":0,"rhsParams":[{"name":"ImportDeclaration","ty":"Ast[ImportDeclaration]","kind":{"Normal":{}}}]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"ExportFromClause","ty":"Ast[ExportFromClause]","kind":{"Normal":{}}},{"name":"FromClause","ty":"Ast[FromClause]","kind":{"Normal":{}}}]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"NamedExports","ty":"Ast[NamedExports]","kind":{"Normal":{}}}]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":2,"subIdx":0,"rhsParams":[{"name":"VariableStatement","ty":"Ast[VariableStatement]","kind":{"Normal":{}}}]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":3,"subIdx":0,"rhsParams":[{"name":"Declaration","ty":"Ast[Declaration]","kind":{"Normal":{}}}]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « DeclarationPart of |Declaration| ».","code":"\n        1. Return a List whose sole element is DeclarationPart of |Declaration|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":4,"subIdx":0,"rhsParams":[{"name":"HoistableDeclaration","ty":"Ast[HoistableDeclaration]","kind":{"Normal":{}}}]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « DeclarationPart of |HoistableDeclaration| ».","code":"\n        1. Return a List whose sole element is DeclarationPart of |HoistableDeclaration|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":5,"subIdx":0,"rhsParams":[{"name":"ClassDeclaration","ty":"Ast[ClassDeclaration]","kind":{"Normal":{}}}]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « |ClassDeclaration| ».","code":"\n        1. Return a List whose sole element is |ClassDeclaration|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":6,"subIdx":0,"rhsParams":[{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"LexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « *this* value ».","code":"\n        1. Return a List whose sole element is this |ExportDeclaration|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":2,"subIdx":0,"rhsParams":[{"name":"EmptyStatement","ty":"Ast[EmptyStatement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":3,"subIdx":0,"rhsParams":[{"name":"ExpressionStatement","ty":"Ast[ExpressionStatement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":6,"subIdx":0,"rhsParams":[{"name":"ContinueStatement","ty":"Ast[ContinueStatement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":7,"subIdx":0,"rhsParams":[{"name":"BreakStatement","ty":"Ast[BreakStatement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":8,"subIdx":0,"rhsParams":[{"name":"ReturnStatement","ty":"Ast[ReturnStatement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":11,"subIdx":0,"rhsParams":[{"name":"ThrowStatement","ty":"Ast[ThrowStatement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":13,"subIdx":0,"rhsParams":[{"name":"DebuggerStatement","ty":"Ast[DebuggerStatement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Block","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementList","idx":1,"subIdx":0,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}},{"name":"StatementListItem","ty":"Ast[StatementListItem]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be VarDeclaredNames of |StatementList|.\n  1. Let _names2_ be VarDeclaredNames of |StatementListItem|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be VarDeclaredNames of |StatementList|.\n        1. Let _names2_ be VarDeclaredNames of |StatementListItem|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementListItem","idx":1,"subIdx":0,"rhsParams":[{"name":"Declaration","ty":"Ast[Declaration]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"VariableStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |VariableDeclarationList|.","code":"\n        1. Return BoundNames of |VariableDeclarationList|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IfStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be VarDeclaredNames of the first |Statement|.\n  1. Let _names2_ be VarDeclaredNames of the second |Statement|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be VarDeclaredNames of the first |Statement|.\n        1. Let _names2_ be VarDeclaredNames of the second |Statement|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IfStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return VarDeclaredNames of |Statement|.","code":"\n        1. Return the VarDeclaredNames of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DoWhileStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return VarDeclaredNames of |Statement|.","code":"\n        1. Return the VarDeclaredNames of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"WhileStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return VarDeclaredNames of |Statement|.","code":"\n        1. Return the VarDeclaredNames of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return VarDeclaredNames of |Statement|.","code":"\n        1. Return the VarDeclaredNames of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":1,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return VarDeclaredNames of |Statement|.","code":"\n        1. Return the VarDeclaredNames of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":2,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return VarDeclaredNames of |Statement|.","code":"\n        1. Return the VarDeclaredNames of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":3,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return VarDeclaredNames of |Statement|.","code":"\n        1. Return the VarDeclaredNames of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":4,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return VarDeclaredNames of |Statement|.","code":"\n        1. Return the VarDeclaredNames of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":5,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return VarDeclaredNames of |Statement|.","code":"\n        1. Return the VarDeclaredNames of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":6,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return VarDeclaredNames of |Statement|.","code":"\n        1. Return the VarDeclaredNames of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":7,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return VarDeclaredNames of |Statement|.","code":"\n        1. Return the VarDeclaredNames of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be BoundNames of |VariableDeclarationList|.\n  1. Let _names2_ be VarDeclaredNames of |Statement|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be BoundNames of |VariableDeclarationList|.\n        1. Let _names2_ be VarDeclaredNames of |Statement|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":1,"subIdx":1,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be BoundNames of |VariableDeclarationList|.\n  1. Let _names2_ be VarDeclaredNames of |Statement|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be BoundNames of |VariableDeclarationList|.\n        1. Let _names2_ be VarDeclaredNames of |Statement|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":1,"subIdx":2,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be BoundNames of |VariableDeclarationList|.\n  1. Let _names2_ be VarDeclaredNames of |Statement|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be BoundNames of |VariableDeclarationList|.\n        1. Let _names2_ be VarDeclaredNames of |Statement|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":1,"subIdx":3,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be BoundNames of |VariableDeclarationList|.\n  1. Let _names2_ be VarDeclaredNames of |Statement|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be BoundNames of |VariableDeclarationList|.\n        1. Let _names2_ be VarDeclaredNames of |Statement|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":2,"subIdx":0,"rhsParams":[{"name":"LexicalDeclaration","ty":"Ast[LexicalDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return VarDeclaredNames of |Statement|.","code":"\n        1. Return the VarDeclaredNames of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":2,"subIdx":1,"rhsParams":[{"name":"LexicalDeclaration","ty":"Ast[LexicalDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return VarDeclaredNames of |Statement|.","code":"\n        1. Return the VarDeclaredNames of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":2,"subIdx":2,"rhsParams":[{"name":"LexicalDeclaration","ty":"Ast[LexicalDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return VarDeclaredNames of |Statement|.","code":"\n        1. Return the VarDeclaredNames of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":2,"subIdx":3,"rhsParams":[{"name":"LexicalDeclaration","ty":"Ast[LexicalDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return VarDeclaredNames of |Statement|.","code":"\n        1. Return the VarDeclaredNames of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return VarDeclaredNames of |Statement|.","code":"\n        1. Return the VarDeclaredNames of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":2,"subIdx":0,"rhsParams":[{"name":"ForDeclaration","ty":"Ast[ForDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return VarDeclaredNames of |Statement|.","code":"\n        1. Return the VarDeclaredNames of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":3,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return VarDeclaredNames of |Statement|.","code":"\n        1. Return the VarDeclaredNames of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":5,"subIdx":0,"rhsParams":[{"name":"ForDeclaration","ty":"Ast[ForDeclaration]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return VarDeclaredNames of |Statement|.","code":"\n        1. Return the VarDeclaredNames of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":6,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return VarDeclaredNames of |Statement|.","code":"\n        1. Return the VarDeclaredNames of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":8,"subIdx":0,"rhsParams":[{"name":"ForDeclaration","ty":"Ast[ForDeclaration]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return VarDeclaredNames of |Statement|.","code":"\n        1. Return the VarDeclaredNames of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"ForBinding","ty":"Ast[ForBinding]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be BoundNames of |ForBinding|.\n  1. Let _names2_ be VarDeclaredNames of |Statement|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be the BoundNames of |ForBinding|.\n        1. Let _names2_ be the VarDeclaredNames of |Statement|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":4,"subIdx":0,"rhsParams":[{"name":"ForBinding","ty":"Ast[ForBinding]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be BoundNames of |ForBinding|.\n  1. Let _names2_ be VarDeclaredNames of |Statement|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be the BoundNames of |ForBinding|.\n        1. Let _names2_ be the VarDeclaredNames of |Statement|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":7,"subIdx":0,"rhsParams":[{"name":"ForBinding","ty":"Ast[ForBinding]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be BoundNames of |ForBinding|.\n  1. Let _names2_ be VarDeclaredNames of |Statement|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be the BoundNames of |ForBinding|.\n        1. Let _names2_ be the VarDeclaredNames of |Statement|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"WithStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return VarDeclaredNames of |Statement|.","code":"\n        1. Return the VarDeclaredNames of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"SwitchStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"CaseBlock","ty":"Ast[CaseBlock]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return VarDeclaredNames of |CaseBlock|.","code":"\n        1. Return the VarDeclaredNames of |CaseBlock|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":0,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. If the first |CaseClauses| is present, let _names1_ be VarDeclaredNames of the first |CaseClauses|.\n  1. Else, let _names1_ be « ».\n  1. Let _names2_ be VarDeclaredNames of |DefaultClause|.\n  1. If the second |CaseClauses| is present, let _names3_ be VarDeclaredNames of the second |CaseClauses|.\n  1. Else, let _names3_ be « ».\n  1. Return the list-concatenation of _names1_, _names2_, and _names3_.","code":"\n        1. If the first |CaseClauses| is present, let _names1_ be the VarDeclaredNames of the first |CaseClauses|.\n        1. Else, let _names1_ be a new empty List.\n        1. Let _names2_ be VarDeclaredNames of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _names3_ be the VarDeclaredNames of the second |CaseClauses|.\n        1. Else, let _names3_ be a new empty List.\n        1. Return the list-concatenation of _names1_, _names2_, and _names3_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":1,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. If the first |CaseClauses| is present, let _names1_ be VarDeclaredNames of the first |CaseClauses|.\n  1. Else, let _names1_ be « ».\n  1. Let _names2_ be VarDeclaredNames of |DefaultClause|.\n  1. If the second |CaseClauses| is present, let _names3_ be VarDeclaredNames of the second |CaseClauses|.\n  1. Else, let _names3_ be « ».\n  1. Return the list-concatenation of _names1_, _names2_, and _names3_.","code":"\n        1. If the first |CaseClauses| is present, let _names1_ be the VarDeclaredNames of the first |CaseClauses|.\n        1. Else, let _names1_ be a new empty List.\n        1. Let _names2_ be VarDeclaredNames of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _names3_ be the VarDeclaredNames of the second |CaseClauses|.\n        1. Else, let _names3_ be a new empty List.\n        1. Return the list-concatenation of _names1_, _names2_, and _names3_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":2,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. If the first |CaseClauses| is present, let _names1_ be VarDeclaredNames of the first |CaseClauses|.\n  1. Else, let _names1_ be « ».\n  1. Let _names2_ be VarDeclaredNames of |DefaultClause|.\n  1. If the second |CaseClauses| is present, let _names3_ be VarDeclaredNames of the second |CaseClauses|.\n  1. Else, let _names3_ be « ».\n  1. Return the list-concatenation of _names1_, _names2_, and _names3_.","code":"\n        1. If the first |CaseClauses| is present, let _names1_ be the VarDeclaredNames of the first |CaseClauses|.\n        1. Else, let _names1_ be a new empty List.\n        1. Let _names2_ be VarDeclaredNames of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _names3_ be the VarDeclaredNames of the second |CaseClauses|.\n        1. Else, let _names3_ be a new empty List.\n        1. Return the list-concatenation of _names1_, _names2_, and _names3_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":3,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. If the first |CaseClauses| is present, let _names1_ be VarDeclaredNames of the first |CaseClauses|.\n  1. Else, let _names1_ be « ».\n  1. Let _names2_ be VarDeclaredNames of |DefaultClause|.\n  1. If the second |CaseClauses| is present, let _names3_ be VarDeclaredNames of the second |CaseClauses|.\n  1. Else, let _names3_ be « ».\n  1. Return the list-concatenation of _names1_, _names2_, and _names3_.","code":"\n        1. If the first |CaseClauses| is present, let _names1_ be the VarDeclaredNames of the first |CaseClauses|.\n        1. Else, let _names1_ be a new empty List.\n        1. Let _names2_ be VarDeclaredNames of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _names3_ be the VarDeclaredNames of the second |CaseClauses|.\n        1. Else, let _names3_ be a new empty List.\n        1. Return the list-concatenation of _names1_, _names2_, and _names3_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseClauses","idx":1,"subIdx":0,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"CaseClause","ty":"Ast[CaseClause]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be VarDeclaredNames of |CaseClauses|.\n  1. Let _names2_ be VarDeclaredNames of |CaseClause|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be VarDeclaredNames of |CaseClauses|.\n        1. Let _names2_ be VarDeclaredNames of |CaseClause|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseClause","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. If |StatementList| is present, return VarDeclaredNames of |StatementList|.\n  1. Return « ».","code":"\n        1. If the |StatementList| is present, return the VarDeclaredNames of |StatementList|.\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseClause","idx":0,"subIdx":1,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. If |StatementList| is present, return VarDeclaredNames of |StatementList|.\n  1. Return « ».","code":"\n        1. If the |StatementList| is present, return the VarDeclaredNames of |StatementList|.\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DefaultClause","idx":0,"subIdx":0,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. If |StatementList| is present, return VarDeclaredNames of |StatementList|.\n  1. Return « ».","code":"\n        1. If the |StatementList| is present, return the VarDeclaredNames of |StatementList|.\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DefaultClause","idx":0,"subIdx":1,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. If |StatementList| is present, return VarDeclaredNames of |StatementList|.\n  1. Return « ».","code":"\n        1. If the |StatementList| is present, return the VarDeclaredNames of |StatementList|.\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LabelledStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"LabelIdentifier","ty":"Ast[LabelIdentifier]","kind":{"Normal":{}}},{"name":"LabelledItem","ty":"Ast[LabelledItem]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return VarDeclaredNames of |LabelledItem|.","code":"\n        1. Return the VarDeclaredNames of |LabelledItem|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LabelledItem","idx":1,"subIdx":0,"rhsParams":[{"name":"FunctionDeclaration","ty":"Ast[FunctionDeclaration]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TryStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Block","ty":"Ast[Block]","kind":{"Normal":{}}},{"name":"Catch","ty":"Ast[Catch]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be VarDeclaredNames of |Block|.\n  1. Let _names2_ be VarDeclaredNames of |Catch|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be VarDeclaredNames of |Block|.\n        1. Let _names2_ be VarDeclaredNames of |Catch|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TryStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"Block","ty":"Ast[Block]","kind":{"Normal":{}}},{"name":"Finally","ty":"Ast[Finally]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be VarDeclaredNames of |Block|.\n  1. Let _names2_ be VarDeclaredNames of |Finally|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be VarDeclaredNames of |Block|.\n        1. Let _names2_ be VarDeclaredNames of |Finally|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TryStatement","idx":2,"subIdx":0,"rhsParams":[{"name":"Block","ty":"Ast[Block]","kind":{"Normal":{}}},{"name":"Catch","ty":"Ast[Catch]","kind":{"Normal":{}}},{"name":"Finally","ty":"Ast[Finally]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be VarDeclaredNames of |Block|.\n  1. Let _names2_ be VarDeclaredNames of |Catch|.\n  1. Let _names3_ be VarDeclaredNames of |Finally|.\n  1. Return the list-concatenation of _names1_, _names2_, and _names3_.","code":"\n        1. Let _names1_ be VarDeclaredNames of |Block|.\n        1. Let _names2_ be VarDeclaredNames of |Catch|.\n        1. Let _names3_ be VarDeclaredNames of |Finally|.\n        1. Return the list-concatenation of _names1_, _names2_, and _names3_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Catch","idx":0,"subIdx":0,"rhsParams":[{"name":"CatchParameter","ty":"Ast[CatchParameter]","kind":{"Normal":{}}},{"name":"Block","ty":"Ast[Block]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return VarDeclaredNames of |Block|.","code":"\n        1. Return the VarDeclaredNames of |Block|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionStatementList","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionStatementList","idx":0,"subIdx":1,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return TopLevelVarDeclaredNames of |StatementList|.","code":"\n        1. Return TopLevelVarDeclaredNames of |StatementList|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassStaticBlockStatementList","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassStaticBlockStatementList","idx":0,"subIdx":1,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return TopLevelVarDeclaredNames of |StatementList|.","code":"\n        1. Return the TopLevelVarDeclaredNames of |StatementList|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ConciseBody","idx":0,"subIdx":0,"rhsParams":[{"name":"ExpressionBody","ty":"Ast[ExpressionBody]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncConciseBody","idx":0,"subIdx":0,"rhsParams":[{"name":"ExpressionBody","ty":"Ast[ExpressionBody]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Script","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ScriptBody","idx":0,"subIdx":0,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return TopLevelVarDeclaredNames of |StatementList|.","code":"\n        1. Return TopLevelVarDeclaredNames of |StatementList|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItemList","idx":1,"subIdx":0,"rhsParams":[{"name":"ModuleItemList","ty":"Ast[ModuleItemList]","kind":{"Normal":{}}},{"name":"ModuleItem","ty":"Ast[ModuleItem]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be VarDeclaredNames of |ModuleItemList|.\n  1. Let _names2_ be VarDeclaredNames of |ModuleItem|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be VarDeclaredNames of |ModuleItemList|.\n        1. Let _names2_ be VarDeclaredNames of |ModuleItem|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItem","idx":0,"subIdx":0,"rhsParams":[{"name":"ImportDeclaration","ty":"Ast[ImportDeclaration]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItem","idx":1,"subIdx":0,"rhsParams":[{"name":"ExportDeclaration","ty":"Ast[ExportDeclaration]","kind":{"Normal":{}}}]},"methodName":"VarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. If |ExportDeclaration| is `export` |VariableStatement|, return BoundNames of |ExportDeclaration|.\n  1. Return « ».","code":"\n        1. If |ExportDeclaration| is `export` |VariableStatement|, return BoundNames of |ExportDeclaration|.\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":2,"subIdx":0,"rhsParams":[{"name":"EmptyStatement","ty":"Ast[EmptyStatement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":3,"subIdx":0,"rhsParams":[{"name":"ExpressionStatement","ty":"Ast[ExpressionStatement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":6,"subIdx":0,"rhsParams":[{"name":"ContinueStatement","ty":"Ast[ContinueStatement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":7,"subIdx":0,"rhsParams":[{"name":"BreakStatement","ty":"Ast[BreakStatement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":8,"subIdx":0,"rhsParams":[{"name":"ReturnStatement","ty":"Ast[ReturnStatement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":11,"subIdx":0,"rhsParams":[{"name":"ThrowStatement","ty":"Ast[ThrowStatement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":13,"subIdx":0,"rhsParams":[{"name":"DebuggerStatement","ty":"Ast[DebuggerStatement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Block","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementList","idx":1,"subIdx":0,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}},{"name":"StatementListItem","ty":"Ast[StatementListItem]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Let _declarations1_ be VarScopedDeclarations of |StatementList|.\n  1. Let _declarations2_ be VarScopedDeclarations of |StatementListItem|.\n  1. Return the list-concatenation of _declarations1_ and _declarations2_.","code":"\n        1. Let _declarations1_ be VarScopedDeclarations of |StatementList|.\n        1. Let _declarations2_ be VarScopedDeclarations of |StatementListItem|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementListItem","idx":1,"subIdx":0,"rhsParams":[{"name":"Declaration","ty":"Ast[Declaration]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"VariableDeclarationList","idx":0,"subIdx":0,"rhsParams":[{"name":"VariableDeclaration","ty":"Ast[VariableDeclaration]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « |VariableDeclaration| ».","code":"\n        1. Return « |VariableDeclaration| ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"VariableDeclarationList","idx":1,"subIdx":0,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"VariableDeclaration","ty":"Ast[VariableDeclaration]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Let _declarations1_ be VarScopedDeclarations of |VariableDeclarationList|.\n  1. Return the list-concatenation of _declarations1_ and « |VariableDeclaration| ».","code":"\n        1. Let _declarations1_ be VarScopedDeclarations of |VariableDeclarationList|.\n        1. Return the list-concatenation of _declarations1_ and « |VariableDeclaration| ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IfStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Let _declarations1_ be VarScopedDeclarations of the first |Statement|.\n  1. Let _declarations2_ be VarScopedDeclarations of the second |Statement|.\n  1. Return the list-concatenation of _declarations1_ and _declarations2_.","code":"\n        1. Let _declarations1_ be VarScopedDeclarations of the first |Statement|.\n        1. Let _declarations2_ be VarScopedDeclarations of the second |Statement|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IfStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return VarScopedDeclarations of |Statement|.","code":"\n        1. Return the VarScopedDeclarations of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DoWhileStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return VarScopedDeclarations of |Statement|.","code":"\n        1. Return the VarScopedDeclarations of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"WhileStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return VarScopedDeclarations of |Statement|.","code":"\n        1. Return the VarScopedDeclarations of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return VarScopedDeclarations of |Statement|.","code":"\n        1. Return the VarScopedDeclarations of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":1,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return VarScopedDeclarations of |Statement|.","code":"\n        1. Return the VarScopedDeclarations of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":2,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return VarScopedDeclarations of |Statement|.","code":"\n        1. Return the VarScopedDeclarations of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":3,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return VarScopedDeclarations of |Statement|.","code":"\n        1. Return the VarScopedDeclarations of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":4,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return VarScopedDeclarations of |Statement|.","code":"\n        1. Return the VarScopedDeclarations of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":5,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return VarScopedDeclarations of |Statement|.","code":"\n        1. Return the VarScopedDeclarations of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":6,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return VarScopedDeclarations of |Statement|.","code":"\n        1. Return the VarScopedDeclarations of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":7,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return VarScopedDeclarations of |Statement|.","code":"\n        1. Return the VarScopedDeclarations of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Let _declarations1_ be VarScopedDeclarations of |VariableDeclarationList|.\n  1. Let _declarations2_ be VarScopedDeclarations of |Statement|.\n  1. Return the list-concatenation of _declarations1_ and _declarations2_.","code":"\n        1. Let _declarations1_ be VarScopedDeclarations of |VariableDeclarationList|.\n        1. Let _declarations2_ be VarScopedDeclarations of |Statement|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":1,"subIdx":1,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Let _declarations1_ be VarScopedDeclarations of |VariableDeclarationList|.\n  1. Let _declarations2_ be VarScopedDeclarations of |Statement|.\n  1. Return the list-concatenation of _declarations1_ and _declarations2_.","code":"\n        1. Let _declarations1_ be VarScopedDeclarations of |VariableDeclarationList|.\n        1. Let _declarations2_ be VarScopedDeclarations of |Statement|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":1,"subIdx":2,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Let _declarations1_ be VarScopedDeclarations of |VariableDeclarationList|.\n  1. Let _declarations2_ be VarScopedDeclarations of |Statement|.\n  1. Return the list-concatenation of _declarations1_ and _declarations2_.","code":"\n        1. Let _declarations1_ be VarScopedDeclarations of |VariableDeclarationList|.\n        1. Let _declarations2_ be VarScopedDeclarations of |Statement|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":1,"subIdx":3,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Let _declarations1_ be VarScopedDeclarations of |VariableDeclarationList|.\n  1. Let _declarations2_ be VarScopedDeclarations of |Statement|.\n  1. Return the list-concatenation of _declarations1_ and _declarations2_.","code":"\n        1. Let _declarations1_ be VarScopedDeclarations of |VariableDeclarationList|.\n        1. Let _declarations2_ be VarScopedDeclarations of |Statement|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":2,"subIdx":0,"rhsParams":[{"name":"LexicalDeclaration","ty":"Ast[LexicalDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return VarScopedDeclarations of |Statement|.","code":"\n        1. Return the VarScopedDeclarations of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":2,"subIdx":1,"rhsParams":[{"name":"LexicalDeclaration","ty":"Ast[LexicalDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return VarScopedDeclarations of |Statement|.","code":"\n        1. Return the VarScopedDeclarations of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":2,"subIdx":2,"rhsParams":[{"name":"LexicalDeclaration","ty":"Ast[LexicalDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return VarScopedDeclarations of |Statement|.","code":"\n        1. Return the VarScopedDeclarations of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":2,"subIdx":3,"rhsParams":[{"name":"LexicalDeclaration","ty":"Ast[LexicalDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return VarScopedDeclarations of |Statement|.","code":"\n        1. Return the VarScopedDeclarations of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return VarScopedDeclarations of |Statement|.","code":"\n        1. Return the VarScopedDeclarations of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":2,"subIdx":0,"rhsParams":[{"name":"ForDeclaration","ty":"Ast[ForDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return VarScopedDeclarations of |Statement|.","code":"\n        1. Return the VarScopedDeclarations of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":3,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return VarScopedDeclarations of |Statement|.","code":"\n        1. Return the VarScopedDeclarations of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":5,"subIdx":0,"rhsParams":[{"name":"ForDeclaration","ty":"Ast[ForDeclaration]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return VarScopedDeclarations of |Statement|.","code":"\n        1. Return the VarScopedDeclarations of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":6,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return VarScopedDeclarations of |Statement|.","code":"\n        1. Return the VarScopedDeclarations of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":8,"subIdx":0,"rhsParams":[{"name":"ForDeclaration","ty":"Ast[ForDeclaration]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return VarScopedDeclarations of |Statement|.","code":"\n        1. Return the VarScopedDeclarations of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"ForBinding","ty":"Ast[ForBinding]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Let _declarations1_ be « |ForBinding| ».\n  1. Let _declarations2_ be VarScopedDeclarations of |Statement|.\n  1. Return the list-concatenation of _declarations1_ and _declarations2_.","code":"\n        1. Let _declarations1_ be « |ForBinding| ».\n        1. Let _declarations2_ be VarScopedDeclarations of |Statement|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":4,"subIdx":0,"rhsParams":[{"name":"ForBinding","ty":"Ast[ForBinding]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Let _declarations1_ be « |ForBinding| ».\n  1. Let _declarations2_ be VarScopedDeclarations of |Statement|.\n  1. Return the list-concatenation of _declarations1_ and _declarations2_.","code":"\n        1. Let _declarations1_ be « |ForBinding| ».\n        1. Let _declarations2_ be VarScopedDeclarations of |Statement|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":7,"subIdx":0,"rhsParams":[{"name":"ForBinding","ty":"Ast[ForBinding]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Let _declarations1_ be « |ForBinding| ».\n  1. Let _declarations2_ be VarScopedDeclarations of |Statement|.\n  1. Return the list-concatenation of _declarations1_ and _declarations2_.","code":"\n        1. Let _declarations1_ be « |ForBinding| ».\n        1. Let _declarations2_ be VarScopedDeclarations of |Statement|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"WithStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return VarScopedDeclarations of |Statement|.","code":"\n        1. Return the VarScopedDeclarations of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"SwitchStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"CaseBlock","ty":"Ast[CaseBlock]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return VarScopedDeclarations of |CaseBlock|.","code":"\n        1. Return the VarScopedDeclarations of |CaseBlock|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":0,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. If the first |CaseClauses| is present, let _declarations1_ be VarScopedDeclarations of the first |CaseClauses|.\n  1. Else, let _declarations1_ be « ».\n  1. Let _declarations2_ be VarScopedDeclarations of |DefaultClause|.\n  1. If the second |CaseClauses| is present, let _declarations3_ be VarScopedDeclarations of the second |CaseClauses|.\n  1. Else, let _declarations3_ be « ».\n  1. Return the list-concatenation of _declarations1_, _declarations2_, and _declarations3_.","code":"\n        1. If the first |CaseClauses| is present, let _declarations1_ be the VarScopedDeclarations of the first |CaseClauses|.\n        1. Else, let _declarations1_ be a new empty List.\n        1. Let _declarations2_ be VarScopedDeclarations of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _declarations3_ be the VarScopedDeclarations of the second |CaseClauses|.\n        1. Else, let _declarations3_ be a new empty List.\n        1. Return the list-concatenation of _declarations1_, _declarations2_, and _declarations3_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":1,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. If the first |CaseClauses| is present, let _declarations1_ be VarScopedDeclarations of the first |CaseClauses|.\n  1. Else, let _declarations1_ be « ».\n  1. Let _declarations2_ be VarScopedDeclarations of |DefaultClause|.\n  1. If the second |CaseClauses| is present, let _declarations3_ be VarScopedDeclarations of the second |CaseClauses|.\n  1. Else, let _declarations3_ be « ».\n  1. Return the list-concatenation of _declarations1_, _declarations2_, and _declarations3_.","code":"\n        1. If the first |CaseClauses| is present, let _declarations1_ be the VarScopedDeclarations of the first |CaseClauses|.\n        1. Else, let _declarations1_ be a new empty List.\n        1. Let _declarations2_ be VarScopedDeclarations of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _declarations3_ be the VarScopedDeclarations of the second |CaseClauses|.\n        1. Else, let _declarations3_ be a new empty List.\n        1. Return the list-concatenation of _declarations1_, _declarations2_, and _declarations3_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":2,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. If the first |CaseClauses| is present, let _declarations1_ be VarScopedDeclarations of the first |CaseClauses|.\n  1. Else, let _declarations1_ be « ».\n  1. Let _declarations2_ be VarScopedDeclarations of |DefaultClause|.\n  1. If the second |CaseClauses| is present, let _declarations3_ be VarScopedDeclarations of the second |CaseClauses|.\n  1. Else, let _declarations3_ be « ».\n  1. Return the list-concatenation of _declarations1_, _declarations2_, and _declarations3_.","code":"\n        1. If the first |CaseClauses| is present, let _declarations1_ be the VarScopedDeclarations of the first |CaseClauses|.\n        1. Else, let _declarations1_ be a new empty List.\n        1. Let _declarations2_ be VarScopedDeclarations of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _declarations3_ be the VarScopedDeclarations of the second |CaseClauses|.\n        1. Else, let _declarations3_ be a new empty List.\n        1. Return the list-concatenation of _declarations1_, _declarations2_, and _declarations3_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":3,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. If the first |CaseClauses| is present, let _declarations1_ be VarScopedDeclarations of the first |CaseClauses|.\n  1. Else, let _declarations1_ be « ».\n  1. Let _declarations2_ be VarScopedDeclarations of |DefaultClause|.\n  1. If the second |CaseClauses| is present, let _declarations3_ be VarScopedDeclarations of the second |CaseClauses|.\n  1. Else, let _declarations3_ be « ».\n  1. Return the list-concatenation of _declarations1_, _declarations2_, and _declarations3_.","code":"\n        1. If the first |CaseClauses| is present, let _declarations1_ be the VarScopedDeclarations of the first |CaseClauses|.\n        1. Else, let _declarations1_ be a new empty List.\n        1. Let _declarations2_ be VarScopedDeclarations of |DefaultClause|.\n        1. If the second |CaseClauses| is present, let _declarations3_ be the VarScopedDeclarations of the second |CaseClauses|.\n        1. Else, let _declarations3_ be a new empty List.\n        1. Return the list-concatenation of _declarations1_, _declarations2_, and _declarations3_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseClauses","idx":1,"subIdx":0,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"CaseClause","ty":"Ast[CaseClause]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Let _declarations1_ be VarScopedDeclarations of |CaseClauses|.\n  1. Let _declarations2_ be VarScopedDeclarations of |CaseClause|.\n  1. Return the list-concatenation of _declarations1_ and _declarations2_.","code":"\n        1. Let _declarations1_ be VarScopedDeclarations of |CaseClauses|.\n        1. Let _declarations2_ be VarScopedDeclarations of |CaseClause|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseClause","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. If |StatementList| is present, return VarScopedDeclarations of |StatementList|.\n  1. Return « ».","code":"\n        1. If the |StatementList| is present, return the VarScopedDeclarations of |StatementList|.\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseClause","idx":0,"subIdx":1,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. If |StatementList| is present, return VarScopedDeclarations of |StatementList|.\n  1. Return « ».","code":"\n        1. If the |StatementList| is present, return the VarScopedDeclarations of |StatementList|.\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DefaultClause","idx":0,"subIdx":0,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. If |StatementList| is present, return VarScopedDeclarations of |StatementList|.\n  1. Return « ».","code":"\n        1. If the |StatementList| is present, return the VarScopedDeclarations of |StatementList|.\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DefaultClause","idx":0,"subIdx":1,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. If |StatementList| is present, return VarScopedDeclarations of |StatementList|.\n  1. Return « ».","code":"\n        1. If the |StatementList| is present, return the VarScopedDeclarations of |StatementList|.\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LabelledStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"LabelIdentifier","ty":"Ast[LabelIdentifier]","kind":{"Normal":{}}},{"name":"LabelledItem","ty":"Ast[LabelledItem]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return VarScopedDeclarations of |LabelledItem|.","code":"\n        1. Return the VarScopedDeclarations of |LabelledItem|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LabelledItem","idx":1,"subIdx":0,"rhsParams":[{"name":"FunctionDeclaration","ty":"Ast[FunctionDeclaration]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TryStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Block","ty":"Ast[Block]","kind":{"Normal":{}}},{"name":"Catch","ty":"Ast[Catch]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Let _declarations1_ be VarScopedDeclarations of |Block|.\n  1. Let _declarations2_ be VarScopedDeclarations of |Catch|.\n  1. Return the list-concatenation of _declarations1_ and _declarations2_.","code":"\n        1. Let _declarations1_ be VarScopedDeclarations of |Block|.\n        1. Let _declarations2_ be VarScopedDeclarations of |Catch|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TryStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"Block","ty":"Ast[Block]","kind":{"Normal":{}}},{"name":"Finally","ty":"Ast[Finally]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Let _declarations1_ be VarScopedDeclarations of |Block|.\n  1. Let _declarations2_ be VarScopedDeclarations of |Finally|.\n  1. Return the list-concatenation of _declarations1_ and _declarations2_.","code":"\n        1. Let _declarations1_ be VarScopedDeclarations of |Block|.\n        1. Let _declarations2_ be VarScopedDeclarations of |Finally|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TryStatement","idx":2,"subIdx":0,"rhsParams":[{"name":"Block","ty":"Ast[Block]","kind":{"Normal":{}}},{"name":"Catch","ty":"Ast[Catch]","kind":{"Normal":{}}},{"name":"Finally","ty":"Ast[Finally]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Let _declarations1_ be VarScopedDeclarations of |Block|.\n  1. Let _declarations2_ be VarScopedDeclarations of |Catch|.\n  1. Let _declarations3_ be VarScopedDeclarations of |Finally|.\n  1. Return the list-concatenation of _declarations1_, _declarations2_, and _declarations3_.","code":"\n        1. Let _declarations1_ be VarScopedDeclarations of |Block|.\n        1. Let _declarations2_ be VarScopedDeclarations of |Catch|.\n        1. Let _declarations3_ be VarScopedDeclarations of |Finally|.\n        1. Return the list-concatenation of _declarations1_, _declarations2_, and _declarations3_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Catch","idx":0,"subIdx":0,"rhsParams":[{"name":"CatchParameter","ty":"Ast[CatchParameter]","kind":{"Normal":{}}},{"name":"Block","ty":"Ast[Block]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return VarScopedDeclarations of |Block|.","code":"\n        1. Return the VarScopedDeclarations of |Block|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionStatementList","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionStatementList","idx":0,"subIdx":1,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return TopLevelVarScopedDeclarations of |StatementList|.","code":"\n        1. Return the TopLevelVarScopedDeclarations of |StatementList|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassStaticBlockStatementList","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassStaticBlockStatementList","idx":0,"subIdx":1,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return TopLevelVarScopedDeclarations of |StatementList|.","code":"\n        1. Return the TopLevelVarScopedDeclarations of |StatementList|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ConciseBody","idx":0,"subIdx":0,"rhsParams":[{"name":"ExpressionBody","ty":"Ast[ExpressionBody]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncConciseBody","idx":0,"subIdx":0,"rhsParams":[{"name":"ExpressionBody","ty":"Ast[ExpressionBody]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Script","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ScriptBody","idx":0,"subIdx":0,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return TopLevelVarScopedDeclarations of |StatementList|.","code":"\n        1. Return TopLevelVarScopedDeclarations of |StatementList|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Module","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItemList","idx":1,"subIdx":0,"rhsParams":[{"name":"ModuleItemList","ty":"Ast[ModuleItemList]","kind":{"Normal":{}}},{"name":"ModuleItem","ty":"Ast[ModuleItem]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Let _declarations1_ be VarScopedDeclarations of |ModuleItemList|.\n  1. Let _declarations2_ be VarScopedDeclarations of |ModuleItem|.\n  1. Return the list-concatenation of _declarations1_ and _declarations2_.","code":"\n        1. Let _declarations1_ be VarScopedDeclarations of |ModuleItemList|.\n        1. Let _declarations2_ be VarScopedDeclarations of |ModuleItem|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItem","idx":0,"subIdx":0,"rhsParams":[{"name":"ImportDeclaration","ty":"Ast[ImportDeclaration]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItem","idx":1,"subIdx":0,"rhsParams":[{"name":"ExportDeclaration","ty":"Ast[ExportDeclaration]","kind":{"Normal":{}}}]},"methodName":"VarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. If |ExportDeclaration| is `export` |VariableStatement|, return VarScopedDeclarations of |VariableStatement|.\n  1. Return « ».","code":"\n        1. If |ExportDeclaration| is `export` |VariableStatement|, return VarScopedDeclarations of |VariableStatement|.\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementList","idx":1,"subIdx":0,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}},{"name":"StatementListItem","ty":"Ast[StatementListItem]","kind":{"Normal":{}}}]},"methodName":"TopLevelLexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be TopLevelLexicallyDeclaredNames of |StatementList|.\n  1. Let _names2_ be TopLevelLexicallyDeclaredNames of |StatementListItem|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be TopLevelLexicallyDeclaredNames of |StatementList|.\n        1. Let _names2_ be TopLevelLexicallyDeclaredNames of |StatementListItem|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementListItem","idx":0,"subIdx":0,"rhsParams":[{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"TopLevelLexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementListItem","idx":1,"subIdx":0,"rhsParams":[{"name":"Declaration","ty":"Ast[Declaration]","kind":{"Normal":{}}}]},"methodName":"TopLevelLexicallyDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. If |Declaration| is <emu-grammar>Declaration : HoistableDeclaration</emu-grammar>, then\n    1. Return « ».\n  1. Return BoundNames of |Declaration|.","code":"\n        1. If |Declaration| is <emu-grammar>Declaration : HoistableDeclaration</emu-grammar>, then\n          1. Return a new empty List.\n        1. Return the BoundNames of |Declaration|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementList","idx":1,"subIdx":0,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}},{"name":"StatementListItem","ty":"Ast[StatementListItem]","kind":{"Normal":{}}}]},"methodName":"TopLevelLexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Let _declarations1_ be TopLevelLexicallyScopedDeclarations of |StatementList|.\n  1. Let _declarations2_ be TopLevelLexicallyScopedDeclarations of |StatementListItem|.\n  1. Return the list-concatenation of _declarations1_ and _declarations2_.","code":"\n        1. Let _declarations1_ be TopLevelLexicallyScopedDeclarations of |StatementList|.\n        1. Let _declarations2_ be TopLevelLexicallyScopedDeclarations of |StatementListItem|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementListItem","idx":0,"subIdx":0,"rhsParams":[{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"TopLevelLexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementListItem","idx":1,"subIdx":0,"rhsParams":[{"name":"Declaration","ty":"Ast[Declaration]","kind":{"Normal":{}}}]},"methodName":"TopLevelLexicallyScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. If |Declaration| is <emu-grammar>Declaration : HoistableDeclaration</emu-grammar>, then\n    1. Return « ».\n  1. Return « |Declaration| ».","code":"\n        1. If |Declaration| is <emu-grammar>Declaration : HoistableDeclaration</emu-grammar>, then\n          1. Return a new empty List.\n        1. Return « |Declaration| ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementList","idx":1,"subIdx":0,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}},{"name":"StatementListItem","ty":"Ast[StatementListItem]","kind":{"Normal":{}}}]},"methodName":"TopLevelVarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be TopLevelVarDeclaredNames of |StatementList|.\n  1. Let _names2_ be TopLevelVarDeclaredNames of |StatementListItem|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be TopLevelVarDeclaredNames of |StatementList|.\n        1. Let _names2_ be TopLevelVarDeclaredNames of |StatementListItem|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementListItem","idx":1,"subIdx":0,"rhsParams":[{"name":"Declaration","ty":"Ast[Declaration]","kind":{"Normal":{}}}]},"methodName":"TopLevelVarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. If |Declaration| is <emu-grammar>Declaration : HoistableDeclaration</emu-grammar>, then\n    1. Return BoundNames of |HoistableDeclaration|.\n  1. Return « ».","code":"\n        1. If |Declaration| is <emu-grammar>Declaration : HoistableDeclaration</emu-grammar>, then\n          1. Return the BoundNames of |HoistableDeclaration|.\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementListItem","idx":0,"subIdx":0,"rhsParams":[{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"TopLevelVarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar>, return TopLevelVarDeclaredNames of |Statement|.\n  1. Return VarDeclaredNames of |Statement|.","code":"\n        1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar>, return TopLevelVarDeclaredNames of |Statement|.\n        1. Return VarDeclaredNames of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LabelledStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"LabelIdentifier","ty":"Ast[LabelIdentifier]","kind":{"Normal":{}}},{"name":"LabelledItem","ty":"Ast[LabelledItem]","kind":{"Normal":{}}}]},"methodName":"TopLevelVarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return TopLevelVarDeclaredNames of |LabelledItem|.","code":"\n        1. Return the TopLevelVarDeclaredNames of |LabelledItem|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LabelledItem","idx":0,"subIdx":0,"rhsParams":[{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"TopLevelVarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar>, return TopLevelVarDeclaredNames of |Statement|.\n  1. Return VarDeclaredNames of |Statement|.","code":"\n        1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar>, return TopLevelVarDeclaredNames of |Statement|.\n        1. Return VarDeclaredNames of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LabelledItem","idx":1,"subIdx":0,"rhsParams":[{"name":"FunctionDeclaration","ty":"Ast[FunctionDeclaration]","kind":{"Normal":{}}}]},"methodName":"TopLevelVarDeclaredNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |FunctionDeclaration|.","code":"\n        1. Return BoundNames of |FunctionDeclaration|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementList","idx":1,"subIdx":0,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}},{"name":"StatementListItem","ty":"Ast[StatementListItem]","kind":{"Normal":{}}}]},"methodName":"TopLevelVarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Let _declarations1_ be TopLevelVarScopedDeclarations of |StatementList|.\n  1. Let _declarations2_ be TopLevelVarScopedDeclarations of |StatementListItem|.\n  1. Return the list-concatenation of _declarations1_ and _declarations2_.","code":"\n        1. Let _declarations1_ be TopLevelVarScopedDeclarations of |StatementList|.\n        1. Let _declarations2_ be TopLevelVarScopedDeclarations of |StatementListItem|.\n        1. Return the list-concatenation of _declarations1_ and _declarations2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementListItem","idx":0,"subIdx":0,"rhsParams":[{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"TopLevelVarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar>, return TopLevelVarScopedDeclarations of |Statement|.\n  1. Return VarScopedDeclarations of |Statement|.","code":"\n        1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar>, return TopLevelVarScopedDeclarations of |Statement|.\n        1. Return VarScopedDeclarations of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementListItem","idx":1,"subIdx":0,"rhsParams":[{"name":"Declaration","ty":"Ast[Declaration]","kind":{"Normal":{}}}]},"methodName":"TopLevelVarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. If |Declaration| is <emu-grammar>Declaration : HoistableDeclaration</emu-grammar>, then\n    1. Let _declaration_ be DeclarationPart of |HoistableDeclaration|.\n    1. Return « _declaration_ ».\n  1. Return « ».","code":"\n        1. If |Declaration| is <emu-grammar>Declaration : HoistableDeclaration</emu-grammar>, then\n          1. Let _declaration_ be DeclarationPart of |HoistableDeclaration|.\n          1. Return « _declaration_ ».\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LabelledStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"LabelIdentifier","ty":"Ast[LabelIdentifier]","kind":{"Normal":{}}},{"name":"LabelledItem","ty":"Ast[LabelledItem]","kind":{"Normal":{}}}]},"methodName":"TopLevelVarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return TopLevelVarScopedDeclarations of |LabelledItem|.","code":"\n        1. Return the TopLevelVarScopedDeclarations of |LabelledItem|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LabelledItem","idx":0,"subIdx":0,"rhsParams":[{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"TopLevelVarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar>, return TopLevelVarScopedDeclarations of |Statement|.\n  1. Return VarScopedDeclarations of |Statement|.","code":"\n        1. If |Statement| is <emu-grammar>Statement : LabelledStatement</emu-grammar>, return TopLevelVarScopedDeclarations of |Statement|.\n        1. Return VarScopedDeclarations of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LabelledItem","idx":1,"subIdx":0,"rhsParams":[{"name":"FunctionDeclaration","ty":"Ast[FunctionDeclaration]","kind":{"Normal":{}}}]},"methodName":"TopLevelVarScopedDeclarations","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « |FunctionDeclaration| ».","code":"\n        1. Return « |FunctionDeclaration| ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":1,"subIdx":0,"rhsParams":[{"name":"VariableStatement","ty":"Ast[VariableStatement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":2,"subIdx":0,"rhsParams":[{"name":"EmptyStatement","ty":"Ast[EmptyStatement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":3,"subIdx":0,"rhsParams":[{"name":"ExpressionStatement","ty":"Ast[ExpressionStatement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":6,"subIdx":0,"rhsParams":[{"name":"ContinueStatement","ty":"Ast[ContinueStatement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":7,"subIdx":0,"rhsParams":[{"name":"BreakStatement","ty":"Ast[BreakStatement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":8,"subIdx":0,"rhsParams":[{"name":"ReturnStatement","ty":"Ast[ReturnStatement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":11,"subIdx":0,"rhsParams":[{"name":"ThrowStatement","ty":"Ast[ThrowStatement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":13,"subIdx":0,"rhsParams":[{"name":"DebuggerStatement","ty":"Ast[DebuggerStatement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Block","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementListItem","idx":1,"subIdx":0,"rhsParams":[{"name":"Declaration","ty":"Ast[Declaration]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementList","idx":1,"subIdx":0,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}},{"name":"StatementListItem","ty":"Ast[StatementListItem]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _hasDuplicates_ be ContainsDuplicateLabels of |StatementList| with argument _labelSet_.\n  1. If _hasDuplicates_ is *true*, return *true*.\n  1. Return ContainsDuplicateLabels of |StatementListItem| with argument _labelSet_.","code":"\n        1. Let _hasDuplicates_ be ContainsDuplicateLabels of |StatementList| with argument _labelSet_.\n        1. If _hasDuplicates_ is *true*, return *true*.\n        1. Return ContainsDuplicateLabels of |StatementListItem| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IfStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _hasDuplicate_ be ContainsDuplicateLabels of the first |Statement| with argument _labelSet_.\n  1. If _hasDuplicate_ is *true*, return *true*.\n  1. Return ContainsDuplicateLabels of the second |Statement| with argument _labelSet_.","code":"\n        1. Let _hasDuplicate_ be ContainsDuplicateLabels of the first |Statement| with argument _labelSet_.\n        1. If _hasDuplicate_ is *true*, return *true*.\n        1. Return ContainsDuplicateLabels of the second |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IfStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DoWhileStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"WhileStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":1,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":2,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":3,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":4,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":5,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":6,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":7,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":1,"subIdx":1,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":1,"subIdx":2,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":1,"subIdx":3,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":2,"subIdx":0,"rhsParams":[{"name":"LexicalDeclaration","ty":"Ast[LexicalDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":2,"subIdx":1,"rhsParams":[{"name":"LexicalDeclaration","ty":"Ast[LexicalDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":2,"subIdx":2,"rhsParams":[{"name":"LexicalDeclaration","ty":"Ast[LexicalDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":2,"subIdx":3,"rhsParams":[{"name":"LexicalDeclaration","ty":"Ast[LexicalDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"ForBinding","ty":"Ast[ForBinding]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":2,"subIdx":0,"rhsParams":[{"name":"ForDeclaration","ty":"Ast[ForDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":3,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":4,"subIdx":0,"rhsParams":[{"name":"ForBinding","ty":"Ast[ForBinding]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":5,"subIdx":0,"rhsParams":[{"name":"ForDeclaration","ty":"Ast[ForDeclaration]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":6,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":7,"subIdx":0,"rhsParams":[{"name":"ForBinding","ty":"Ast[ForBinding]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":8,"subIdx":0,"rhsParams":[{"name":"ForDeclaration","ty":"Ast[ForDeclaration]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"WithStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"SwitchStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"CaseBlock","ty":"Ast[CaseBlock]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |CaseBlock| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |CaseBlock| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":0,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If the first |CaseClauses| is present, then\n    1. If ContainsDuplicateLabels of the first |CaseClauses| with argument _labelSet_ is *true*, return *true*.\n  1. If ContainsDuplicateLabels of |DefaultClause| with argument _labelSet_ is *true*, return *true*.\n  1. If the second |CaseClauses| is not present, return *false*.\n  1. Return ContainsDuplicateLabels of the second |CaseClauses| with argument _labelSet_.","code":"\n        1. If the first |CaseClauses| is present, then\n          1. If ContainsDuplicateLabels of the first |CaseClauses| with argument _labelSet_ is *true*, return *true*.\n        1. If ContainsDuplicateLabels of |DefaultClause| with argument _labelSet_ is *true*, return *true*.\n        1. If the second |CaseClauses| is not present, return *false*.\n        1. Return ContainsDuplicateLabels of the second |CaseClauses| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":1,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If the first |CaseClauses| is present, then\n    1. If ContainsDuplicateLabels of the first |CaseClauses| with argument _labelSet_ is *true*, return *true*.\n  1. If ContainsDuplicateLabels of |DefaultClause| with argument _labelSet_ is *true*, return *true*.\n  1. If the second |CaseClauses| is not present, return *false*.\n  1. Return ContainsDuplicateLabels of the second |CaseClauses| with argument _labelSet_.","code":"\n        1. If the first |CaseClauses| is present, then\n          1. If ContainsDuplicateLabels of the first |CaseClauses| with argument _labelSet_ is *true*, return *true*.\n        1. If ContainsDuplicateLabels of |DefaultClause| with argument _labelSet_ is *true*, return *true*.\n        1. If the second |CaseClauses| is not present, return *false*.\n        1. Return ContainsDuplicateLabels of the second |CaseClauses| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":2,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If the first |CaseClauses| is present, then\n    1. If ContainsDuplicateLabels of the first |CaseClauses| with argument _labelSet_ is *true*, return *true*.\n  1. If ContainsDuplicateLabels of |DefaultClause| with argument _labelSet_ is *true*, return *true*.\n  1. If the second |CaseClauses| is not present, return *false*.\n  1. Return ContainsDuplicateLabels of the second |CaseClauses| with argument _labelSet_.","code":"\n        1. If the first |CaseClauses| is present, then\n          1. If ContainsDuplicateLabels of the first |CaseClauses| with argument _labelSet_ is *true*, return *true*.\n        1. If ContainsDuplicateLabels of |DefaultClause| with argument _labelSet_ is *true*, return *true*.\n        1. If the second |CaseClauses| is not present, return *false*.\n        1. Return ContainsDuplicateLabels of the second |CaseClauses| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":3,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If the first |CaseClauses| is present, then\n    1. If ContainsDuplicateLabels of the first |CaseClauses| with argument _labelSet_ is *true*, return *true*.\n  1. If ContainsDuplicateLabels of |DefaultClause| with argument _labelSet_ is *true*, return *true*.\n  1. If the second |CaseClauses| is not present, return *false*.\n  1. Return ContainsDuplicateLabels of the second |CaseClauses| with argument _labelSet_.","code":"\n        1. If the first |CaseClauses| is present, then\n          1. If ContainsDuplicateLabels of the first |CaseClauses| with argument _labelSet_ is *true*, return *true*.\n        1. If ContainsDuplicateLabels of |DefaultClause| with argument _labelSet_ is *true*, return *true*.\n        1. If the second |CaseClauses| is not present, return *false*.\n        1. Return ContainsDuplicateLabels of the second |CaseClauses| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseClauses","idx":1,"subIdx":0,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"CaseClause","ty":"Ast[CaseClause]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _hasDuplicates_ be ContainsDuplicateLabels of |CaseClauses| with argument _labelSet_.\n  1. If _hasDuplicates_ is *true*, return *true*.\n  1. Return ContainsDuplicateLabels of |CaseClause| with argument _labelSet_.","code":"\n        1. Let _hasDuplicates_ be ContainsDuplicateLabels of |CaseClauses| with argument _labelSet_.\n        1. If _hasDuplicates_ is *true*, return *true*.\n        1. Return ContainsDuplicateLabels of |CaseClause| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseClause","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If |StatementList| is present, return ContainsDuplicateLabels of |StatementList| with argument _labelSet_.\n  1. Return *false*.","code":"\n        1. If the |StatementList| is present, return ContainsDuplicateLabels of |StatementList| with argument _labelSet_.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseClause","idx":0,"subIdx":1,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If |StatementList| is present, return ContainsDuplicateLabels of |StatementList| with argument _labelSet_.\n  1. Return *false*.","code":"\n        1. If the |StatementList| is present, return ContainsDuplicateLabels of |StatementList| with argument _labelSet_.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DefaultClause","idx":0,"subIdx":0,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If |StatementList| is present, return ContainsDuplicateLabels of |StatementList| with argument _labelSet_.\n  1. Return *false*.","code":"\n        1. If the |StatementList| is present, return ContainsDuplicateLabels of |StatementList| with argument _labelSet_.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DefaultClause","idx":0,"subIdx":1,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If |StatementList| is present, return ContainsDuplicateLabels of |StatementList| with argument _labelSet_.\n  1. Return *false*.","code":"\n        1. If the |StatementList| is present, return ContainsDuplicateLabels of |StatementList| with argument _labelSet_.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LabelledStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"LabelIdentifier","ty":"Ast[LabelIdentifier]","kind":{"Normal":{}}},{"name":"LabelledItem","ty":"Ast[LabelledItem]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _label_ be StringValue of |LabelIdentifier|.\n  1. If _labelSet_ contains _label_, return *true*.\n  1. Let _newLabelSet_ be the list-concatenation of _labelSet_ and « _label_ ».\n  1. Return ContainsDuplicateLabels of |LabelledItem| with argument _newLabelSet_.","code":"\n        1. Let _label_ be the StringValue of |LabelIdentifier|.\n        1. If _labelSet_ contains _label_, return *true*.\n        1. Let _newLabelSet_ be the list-concatenation of _labelSet_ and « _label_ ».\n        1. Return ContainsDuplicateLabels of |LabelledItem| with argument _newLabelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LabelledItem","idx":1,"subIdx":0,"rhsParams":[{"name":"FunctionDeclaration","ty":"Ast[FunctionDeclaration]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TryStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Block","ty":"Ast[Block]","kind":{"Normal":{}}},{"name":"Catch","ty":"Ast[Catch]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _hasDuplicates_ be ContainsDuplicateLabels of |Block| with argument _labelSet_.\n  1. If _hasDuplicates_ is *true*, return *true*.\n  1. Return ContainsDuplicateLabels of |Catch| with argument _labelSet_.","code":"\n        1. Let _hasDuplicates_ be ContainsDuplicateLabels of |Block| with argument _labelSet_.\n        1. If _hasDuplicates_ is *true*, return *true*.\n        1. Return ContainsDuplicateLabels of |Catch| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TryStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"Block","ty":"Ast[Block]","kind":{"Normal":{}}},{"name":"Finally","ty":"Ast[Finally]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _hasDuplicates_ be ContainsDuplicateLabels of |Block| with argument _labelSet_.\n  1. If _hasDuplicates_ is *true*, return *true*.\n  1. Return ContainsDuplicateLabels of |Finally| with argument _labelSet_.","code":"\n        1. Let _hasDuplicates_ be ContainsDuplicateLabels of |Block| with argument _labelSet_.\n        1. If _hasDuplicates_ is *true*, return *true*.\n        1. Return ContainsDuplicateLabels of |Finally| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TryStatement","idx":2,"subIdx":0,"rhsParams":[{"name":"Block","ty":"Ast[Block]","kind":{"Normal":{}}},{"name":"Catch","ty":"Ast[Catch]","kind":{"Normal":{}}},{"name":"Finally","ty":"Ast[Finally]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If ContainsDuplicateLabels of |Block| with argument _labelSet_ is *true*, return *true*.\n  1. If ContainsDuplicateLabels of |Catch| with argument _labelSet_ is *true*, return *true*.\n  1. Return ContainsDuplicateLabels of |Finally| with argument _labelSet_.","code":"\n        1. If ContainsDuplicateLabels of |Block| with argument _labelSet_ is *true*, return *true*.\n        1. If ContainsDuplicateLabels of |Catch| with argument _labelSet_ is *true*, return *true*.\n        1. Return ContainsDuplicateLabels of |Finally| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Catch","idx":0,"subIdx":0,"rhsParams":[{"name":"CatchParameter","ty":"Ast[CatchParameter]","kind":{"Normal":{}}},{"name":"Block","ty":"Ast[Block]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsDuplicateLabels of |Block| with argument _labelSet_.","code":"\n        1. Return ContainsDuplicateLabels of |Block| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionStatementList","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassStaticBlockStatementList","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItemList","idx":1,"subIdx":0,"rhsParams":[{"name":"ModuleItemList","ty":"Ast[ModuleItemList]","kind":{"Normal":{}}},{"name":"ModuleItem","ty":"Ast[ModuleItem]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _hasDuplicates_ be ContainsDuplicateLabels of |ModuleItemList| with argument _labelSet_.\n  1. If _hasDuplicates_ is *true*, return *true*.\n  1. Return ContainsDuplicateLabels of |ModuleItem| with argument _labelSet_.","code":"\n        1. Let _hasDuplicates_ be ContainsDuplicateLabels of |ModuleItemList| with argument _labelSet_.\n        1. If _hasDuplicates_ is *true*, return *true*.\n        1. Return ContainsDuplicateLabels of |ModuleItem| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItem","idx":0,"subIdx":0,"rhsParams":[{"name":"ImportDeclaration","ty":"Ast[ImportDeclaration]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItem","idx":1,"subIdx":0,"rhsParams":[{"name":"ExportDeclaration","ty":"Ast[ExportDeclaration]","kind":{"Normal":{}}}]},"methodName":"ContainsDuplicateLabels","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":1,"subIdx":0,"rhsParams":[{"name":"VariableStatement","ty":"Ast[VariableStatement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":2,"subIdx":0,"rhsParams":[{"name":"EmptyStatement","ty":"Ast[EmptyStatement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":3,"subIdx":0,"rhsParams":[{"name":"ExpressionStatement","ty":"Ast[ExpressionStatement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":6,"subIdx":0,"rhsParams":[{"name":"ContinueStatement","ty":"Ast[ContinueStatement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":8,"subIdx":0,"rhsParams":[{"name":"ReturnStatement","ty":"Ast[ReturnStatement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":11,"subIdx":0,"rhsParams":[{"name":"ThrowStatement","ty":"Ast[ThrowStatement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":13,"subIdx":0,"rhsParams":[{"name":"DebuggerStatement","ty":"Ast[DebuggerStatement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Block","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementListItem","idx":1,"subIdx":0,"rhsParams":[{"name":"Declaration","ty":"Ast[Declaration]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementList","idx":1,"subIdx":0,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}},{"name":"StatementListItem","ty":"Ast[StatementListItem]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |StatementList| with argument _labelSet_.\n  1. If _hasUndefinedLabels_ is *true*, return *true*.\n  1. Return ContainsUndefinedBreakTarget of |StatementListItem| with argument _labelSet_.","code":"\n        1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |StatementList| with argument _labelSet_.\n        1. If _hasUndefinedLabels_ is *true*, return *true*.\n        1. Return ContainsUndefinedBreakTarget of |StatementListItem| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IfStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of the first |Statement| with argument _labelSet_.\n  1. If _hasUndefinedLabels_ is *true*, return *true*.\n  1. Return ContainsUndefinedBreakTarget of the second |Statement| with argument _labelSet_.","code":"\n        1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of the first |Statement| with argument _labelSet_.\n        1. If _hasUndefinedLabels_ is *true*, return *true*.\n        1. Return ContainsUndefinedBreakTarget of the second |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IfStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DoWhileStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"WhileStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":1,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":2,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":3,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":4,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":5,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":6,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":7,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":1,"subIdx":1,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":1,"subIdx":2,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":1,"subIdx":3,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":2,"subIdx":0,"rhsParams":[{"name":"LexicalDeclaration","ty":"Ast[LexicalDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":2,"subIdx":1,"rhsParams":[{"name":"LexicalDeclaration","ty":"Ast[LexicalDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":2,"subIdx":2,"rhsParams":[{"name":"LexicalDeclaration","ty":"Ast[LexicalDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":2,"subIdx":3,"rhsParams":[{"name":"LexicalDeclaration","ty":"Ast[LexicalDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"ForBinding","ty":"Ast[ForBinding]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":2,"subIdx":0,"rhsParams":[{"name":"ForDeclaration","ty":"Ast[ForDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":3,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":4,"subIdx":0,"rhsParams":[{"name":"ForBinding","ty":"Ast[ForBinding]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":5,"subIdx":0,"rhsParams":[{"name":"ForDeclaration","ty":"Ast[ForDeclaration]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":6,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":7,"subIdx":0,"rhsParams":[{"name":"ForBinding","ty":"Ast[ForBinding]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":8,"subIdx":0,"rhsParams":[{"name":"ForDeclaration","ty":"Ast[ForDeclaration]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BreakStatement","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BreakStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"LabelIdentifier","ty":"Ast[LabelIdentifier]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _labelSet_ does not contain StringValue of |LabelIdentifier|, return *true*.\n  1. Return *false*.","code":"\n        1. If _labelSet_ does not contain the StringValue of |LabelIdentifier|, return *true*.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"WithStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Statement| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"SwitchStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"CaseBlock","ty":"Ast[CaseBlock]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |CaseBlock| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |CaseBlock| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":0,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If the first |CaseClauses| is present, then\n    1. If ContainsUndefinedBreakTarget of the first |CaseClauses| with argument _labelSet_ is *true*, return *true*.\n  1. If ContainsUndefinedBreakTarget of |DefaultClause| with argument _labelSet_ is *true*, return *true*.\n  1. If the second |CaseClauses| is not present, return *false*.\n  1. Return ContainsUndefinedBreakTarget of the second |CaseClauses| with argument _labelSet_.","code":"\n        1. If the first |CaseClauses| is present, then\n          1. If ContainsUndefinedBreakTarget of the first |CaseClauses| with argument _labelSet_ is *true*, return *true*.\n        1. If ContainsUndefinedBreakTarget of |DefaultClause| with argument _labelSet_ is *true*, return *true*.\n        1. If the second |CaseClauses| is not present, return *false*.\n        1. Return ContainsUndefinedBreakTarget of the second |CaseClauses| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":1,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If the first |CaseClauses| is present, then\n    1. If ContainsUndefinedBreakTarget of the first |CaseClauses| with argument _labelSet_ is *true*, return *true*.\n  1. If ContainsUndefinedBreakTarget of |DefaultClause| with argument _labelSet_ is *true*, return *true*.\n  1. If the second |CaseClauses| is not present, return *false*.\n  1. Return ContainsUndefinedBreakTarget of the second |CaseClauses| with argument _labelSet_.","code":"\n        1. If the first |CaseClauses| is present, then\n          1. If ContainsUndefinedBreakTarget of the first |CaseClauses| with argument _labelSet_ is *true*, return *true*.\n        1. If ContainsUndefinedBreakTarget of |DefaultClause| with argument _labelSet_ is *true*, return *true*.\n        1. If the second |CaseClauses| is not present, return *false*.\n        1. Return ContainsUndefinedBreakTarget of the second |CaseClauses| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":2,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If the first |CaseClauses| is present, then\n    1. If ContainsUndefinedBreakTarget of the first |CaseClauses| with argument _labelSet_ is *true*, return *true*.\n  1. If ContainsUndefinedBreakTarget of |DefaultClause| with argument _labelSet_ is *true*, return *true*.\n  1. If the second |CaseClauses| is not present, return *false*.\n  1. Return ContainsUndefinedBreakTarget of the second |CaseClauses| with argument _labelSet_.","code":"\n        1. If the first |CaseClauses| is present, then\n          1. If ContainsUndefinedBreakTarget of the first |CaseClauses| with argument _labelSet_ is *true*, return *true*.\n        1. If ContainsUndefinedBreakTarget of |DefaultClause| with argument _labelSet_ is *true*, return *true*.\n        1. If the second |CaseClauses| is not present, return *false*.\n        1. Return ContainsUndefinedBreakTarget of the second |CaseClauses| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":3,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If the first |CaseClauses| is present, then\n    1. If ContainsUndefinedBreakTarget of the first |CaseClauses| with argument _labelSet_ is *true*, return *true*.\n  1. If ContainsUndefinedBreakTarget of |DefaultClause| with argument _labelSet_ is *true*, return *true*.\n  1. If the second |CaseClauses| is not present, return *false*.\n  1. Return ContainsUndefinedBreakTarget of the second |CaseClauses| with argument _labelSet_.","code":"\n        1. If the first |CaseClauses| is present, then\n          1. If ContainsUndefinedBreakTarget of the first |CaseClauses| with argument _labelSet_ is *true*, return *true*.\n        1. If ContainsUndefinedBreakTarget of |DefaultClause| with argument _labelSet_ is *true*, return *true*.\n        1. If the second |CaseClauses| is not present, return *false*.\n        1. Return ContainsUndefinedBreakTarget of the second |CaseClauses| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseClauses","idx":1,"subIdx":0,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"CaseClause","ty":"Ast[CaseClause]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |CaseClauses| with argument _labelSet_.\n  1. If _hasUndefinedLabels_ is *true*, return *true*.\n  1. Return ContainsUndefinedBreakTarget of |CaseClause| with argument _labelSet_.","code":"\n        1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |CaseClauses| with argument _labelSet_.\n        1. If _hasUndefinedLabels_ is *true*, return *true*.\n        1. Return ContainsUndefinedBreakTarget of |CaseClause| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseClause","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If |StatementList| is present, return ContainsUndefinedBreakTarget of |StatementList| with argument _labelSet_.\n  1. Return *false*.","code":"\n        1. If the |StatementList| is present, return ContainsUndefinedBreakTarget of |StatementList| with argument _labelSet_.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseClause","idx":0,"subIdx":1,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If |StatementList| is present, return ContainsUndefinedBreakTarget of |StatementList| with argument _labelSet_.\n  1. Return *false*.","code":"\n        1. If the |StatementList| is present, return ContainsUndefinedBreakTarget of |StatementList| with argument _labelSet_.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DefaultClause","idx":0,"subIdx":0,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If |StatementList| is present, return ContainsUndefinedBreakTarget of |StatementList| with argument _labelSet_.\n  1. Return *false*.","code":"\n        1. If the |StatementList| is present, return ContainsUndefinedBreakTarget of |StatementList| with argument _labelSet_.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DefaultClause","idx":0,"subIdx":1,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If |StatementList| is present, return ContainsUndefinedBreakTarget of |StatementList| with argument _labelSet_.\n  1. Return *false*.","code":"\n        1. If the |StatementList| is present, return ContainsUndefinedBreakTarget of |StatementList| with argument _labelSet_.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LabelledStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"LabelIdentifier","ty":"Ast[LabelIdentifier]","kind":{"Normal":{}}},{"name":"LabelledItem","ty":"Ast[LabelledItem]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _label_ be StringValue of |LabelIdentifier|.\n  1. Let _newLabelSet_ be the list-concatenation of _labelSet_ and « _label_ ».\n  1. Return ContainsUndefinedBreakTarget of |LabelledItem| with argument _newLabelSet_.","code":"\n        1. Let _label_ be the StringValue of |LabelIdentifier|.\n        1. Let _newLabelSet_ be the list-concatenation of _labelSet_ and « _label_ ».\n        1. Return ContainsUndefinedBreakTarget of |LabelledItem| with argument _newLabelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LabelledItem","idx":1,"subIdx":0,"rhsParams":[{"name":"FunctionDeclaration","ty":"Ast[FunctionDeclaration]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TryStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Block","ty":"Ast[Block]","kind":{"Normal":{}}},{"name":"Catch","ty":"Ast[Catch]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |Block| with argument _labelSet_.\n  1. If _hasUndefinedLabels_ is *true*, return *true*.\n  1. Return ContainsUndefinedBreakTarget of |Catch| with argument _labelSet_.","code":"\n        1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |Block| with argument _labelSet_.\n        1. If _hasUndefinedLabels_ is *true*, return *true*.\n        1. Return ContainsUndefinedBreakTarget of |Catch| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TryStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"Block","ty":"Ast[Block]","kind":{"Normal":{}}},{"name":"Finally","ty":"Ast[Finally]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |Block| with argument _labelSet_.\n  1. If _hasUndefinedLabels_ is *true*, return *true*.\n  1. Return ContainsUndefinedBreakTarget of |Finally| with argument _labelSet_.","code":"\n        1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |Block| with argument _labelSet_.\n        1. If _hasUndefinedLabels_ is *true*, return *true*.\n        1. Return ContainsUndefinedBreakTarget of |Finally| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TryStatement","idx":2,"subIdx":0,"rhsParams":[{"name":"Block","ty":"Ast[Block]","kind":{"Normal":{}}},{"name":"Catch","ty":"Ast[Catch]","kind":{"Normal":{}}},{"name":"Finally","ty":"Ast[Finally]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If ContainsUndefinedBreakTarget of |Block| with argument _labelSet_ is *true*, return *true*.\n  1. If ContainsUndefinedBreakTarget of |Catch| with argument _labelSet_ is *true*, return *true*.\n  1. Return ContainsUndefinedBreakTarget of |Finally| with argument _labelSet_.","code":"\n        1. If ContainsUndefinedBreakTarget of |Block| with argument _labelSet_ is *true*, return *true*.\n        1. If ContainsUndefinedBreakTarget of |Catch| with argument _labelSet_ is *true*, return *true*.\n        1. Return ContainsUndefinedBreakTarget of |Finally| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Catch","idx":0,"subIdx":0,"rhsParams":[{"name":"CatchParameter","ty":"Ast[CatchParameter]","kind":{"Normal":{}}},{"name":"Block","ty":"Ast[Block]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedBreakTarget of |Block| with argument _labelSet_.","code":"\n        1. Return ContainsUndefinedBreakTarget of |Block| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionStatementList","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassStaticBlockStatementList","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItemList","idx":1,"subIdx":0,"rhsParams":[{"name":"ModuleItemList","ty":"Ast[ModuleItemList]","kind":{"Normal":{}}},{"name":"ModuleItem","ty":"Ast[ModuleItem]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |ModuleItemList| with argument _labelSet_.\n  1. If _hasUndefinedLabels_ is *true*, return *true*.\n  1. Return ContainsUndefinedBreakTarget of |ModuleItem| with argument _labelSet_.","code":"\n        1. Let _hasUndefinedLabels_ be ContainsUndefinedBreakTarget of |ModuleItemList| with argument _labelSet_.\n        1. If _hasUndefinedLabels_ is *true*, return *true*.\n        1. Return ContainsUndefinedBreakTarget of |ModuleItem| with argument _labelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItem","idx":0,"subIdx":0,"rhsParams":[{"name":"ImportDeclaration","ty":"Ast[ImportDeclaration]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItem","idx":1,"subIdx":0,"rhsParams":[{"name":"ExportDeclaration","ty":"Ast[ExportDeclaration]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedBreakTarget","isStatic":true,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":1,"subIdx":0,"rhsParams":[{"name":"VariableStatement","ty":"Ast[VariableStatement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":2,"subIdx":0,"rhsParams":[{"name":"EmptyStatement","ty":"Ast[EmptyStatement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":3,"subIdx":0,"rhsParams":[{"name":"ExpressionStatement","ty":"Ast[ExpressionStatement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":7,"subIdx":0,"rhsParams":[{"name":"BreakStatement","ty":"Ast[BreakStatement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":8,"subIdx":0,"rhsParams":[{"name":"ReturnStatement","ty":"Ast[ReturnStatement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":11,"subIdx":0,"rhsParams":[{"name":"ThrowStatement","ty":"Ast[ThrowStatement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":13,"subIdx":0,"rhsParams":[{"name":"DebuggerStatement","ty":"Ast[DebuggerStatement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Block","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementListItem","idx":1,"subIdx":0,"rhsParams":[{"name":"Declaration","ty":"Ast[Declaration]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":0,"subIdx":0,"rhsParams":[{"name":"BlockStatement","ty":"Ast[BlockStatement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |BlockStatement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |BlockStatement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BreakableStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"IterationStatement","ty":"Ast[IterationStatement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _newIterationSet_ be the list-concatenation of _iterationSet_ and _labelSet_.\n  1. Return ContainsUndefinedContinueTarget of |IterationStatement| with arguments _newIterationSet_ and « ».","code":"\n        1. Let _newIterationSet_ be the list-concatenation of _iterationSet_ and _labelSet_.\n        1. Return ContainsUndefinedContinueTarget of |IterationStatement| with arguments _newIterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementList","idx":1,"subIdx":0,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}},{"name":"StatementListItem","ty":"Ast[StatementListItem]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |StatementList| with arguments _iterationSet_ and « ».\n  1. If _hasUndefinedLabels_ is *true*, return *true*.\n  1. Return ContainsUndefinedContinueTarget of |StatementListItem| with arguments _iterationSet_ and « ».","code":"\n        1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |StatementList| with arguments _iterationSet_ and « ».\n        1. If _hasUndefinedLabels_ is *true*, return *true*.\n        1. Return ContainsUndefinedContinueTarget of |StatementListItem| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IfStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of the first |Statement| with arguments _iterationSet_ and « ».\n  1. If _hasUndefinedLabels_ is *true*, return *true*.\n  1. Return ContainsUndefinedContinueTarget of the second |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of the first |Statement| with arguments _iterationSet_ and « ».\n        1. If _hasUndefinedLabels_ is *true*, return *true*.\n        1. Return ContainsUndefinedContinueTarget of the second |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IfStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DoWhileStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"WhileStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":1,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":2,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":3,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":4,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":5,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":6,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":7,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":1,"subIdx":1,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":1,"subIdx":2,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":1,"subIdx":3,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":2,"subIdx":0,"rhsParams":[{"name":"LexicalDeclaration","ty":"Ast[LexicalDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":2,"subIdx":1,"rhsParams":[{"name":"LexicalDeclaration","ty":"Ast[LexicalDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":2,"subIdx":2,"rhsParams":[{"name":"LexicalDeclaration","ty":"Ast[LexicalDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":2,"subIdx":3,"rhsParams":[{"name":"LexicalDeclaration","ty":"Ast[LexicalDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"ForBinding","ty":"Ast[ForBinding]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":2,"subIdx":0,"rhsParams":[{"name":"ForDeclaration","ty":"Ast[ForDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":3,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":4,"subIdx":0,"rhsParams":[{"name":"ForBinding","ty":"Ast[ForBinding]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":5,"subIdx":0,"rhsParams":[{"name":"ForDeclaration","ty":"Ast[ForDeclaration]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":6,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":7,"subIdx":0,"rhsParams":[{"name":"ForBinding","ty":"Ast[ForBinding]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":8,"subIdx":0,"rhsParams":[{"name":"ForDeclaration","ty":"Ast[ForDeclaration]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ContinueStatement","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ContinueStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"LabelIdentifier","ty":"Ast[LabelIdentifier]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _iterationSet_ does not contain StringValue of |LabelIdentifier|, return *true*.\n  1. Return *false*.","code":"\n        1. If _iterationSet_ does not contain the StringValue of |LabelIdentifier|, return *true*.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"WithStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Statement| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"SwitchStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"CaseBlock","ty":"Ast[CaseBlock]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |CaseBlock| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |CaseBlock| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":0,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If the first |CaseClauses| is present, then\n    1. If ContainsUndefinedContinueTarget of the first |CaseClauses| with arguments _iterationSet_ and « » is *true*, return *true*.\n  1. If ContainsUndefinedContinueTarget of |DefaultClause| with arguments _iterationSet_ and « » is *true*, return *true*.\n  1. If the second |CaseClauses| is not present, return *false*.\n  1. Return ContainsUndefinedContinueTarget of the second |CaseClauses| with arguments _iterationSet_ and « ».","code":"\n        1. If the first |CaseClauses| is present, then\n          1. If ContainsUndefinedContinueTarget of the first |CaseClauses| with arguments _iterationSet_ and « » is *true*, return *true*.\n        1. If ContainsUndefinedContinueTarget of |DefaultClause| with arguments _iterationSet_ and « » is *true*, return *true*.\n        1. If the second |CaseClauses| is not present, return *false*.\n        1. Return ContainsUndefinedContinueTarget of the second |CaseClauses| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":1,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If the first |CaseClauses| is present, then\n    1. If ContainsUndefinedContinueTarget of the first |CaseClauses| with arguments _iterationSet_ and « » is *true*, return *true*.\n  1. If ContainsUndefinedContinueTarget of |DefaultClause| with arguments _iterationSet_ and « » is *true*, return *true*.\n  1. If the second |CaseClauses| is not present, return *false*.\n  1. Return ContainsUndefinedContinueTarget of the second |CaseClauses| with arguments _iterationSet_ and « ».","code":"\n        1. If the first |CaseClauses| is present, then\n          1. If ContainsUndefinedContinueTarget of the first |CaseClauses| with arguments _iterationSet_ and « » is *true*, return *true*.\n        1. If ContainsUndefinedContinueTarget of |DefaultClause| with arguments _iterationSet_ and « » is *true*, return *true*.\n        1. If the second |CaseClauses| is not present, return *false*.\n        1. Return ContainsUndefinedContinueTarget of the second |CaseClauses| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":2,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If the first |CaseClauses| is present, then\n    1. If ContainsUndefinedContinueTarget of the first |CaseClauses| with arguments _iterationSet_ and « » is *true*, return *true*.\n  1. If ContainsUndefinedContinueTarget of |DefaultClause| with arguments _iterationSet_ and « » is *true*, return *true*.\n  1. If the second |CaseClauses| is not present, return *false*.\n  1. Return ContainsUndefinedContinueTarget of the second |CaseClauses| with arguments _iterationSet_ and « ».","code":"\n        1. If the first |CaseClauses| is present, then\n          1. If ContainsUndefinedContinueTarget of the first |CaseClauses| with arguments _iterationSet_ and « » is *true*, return *true*.\n        1. If ContainsUndefinedContinueTarget of |DefaultClause| with arguments _iterationSet_ and « » is *true*, return *true*.\n        1. If the second |CaseClauses| is not present, return *false*.\n        1. Return ContainsUndefinedContinueTarget of the second |CaseClauses| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":3,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If the first |CaseClauses| is present, then\n    1. If ContainsUndefinedContinueTarget of the first |CaseClauses| with arguments _iterationSet_ and « » is *true*, return *true*.\n  1. If ContainsUndefinedContinueTarget of |DefaultClause| with arguments _iterationSet_ and « » is *true*, return *true*.\n  1. If the second |CaseClauses| is not present, return *false*.\n  1. Return ContainsUndefinedContinueTarget of the second |CaseClauses| with arguments _iterationSet_ and « ».","code":"\n        1. If the first |CaseClauses| is present, then\n          1. If ContainsUndefinedContinueTarget of the first |CaseClauses| with arguments _iterationSet_ and « » is *true*, return *true*.\n        1. If ContainsUndefinedContinueTarget of |DefaultClause| with arguments _iterationSet_ and « » is *true*, return *true*.\n        1. If the second |CaseClauses| is not present, return *false*.\n        1. Return ContainsUndefinedContinueTarget of the second |CaseClauses| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseClauses","idx":1,"subIdx":0,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"CaseClause","ty":"Ast[CaseClause]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |CaseClauses| with arguments _iterationSet_ and « ».\n  1. If _hasUndefinedLabels_ is *true*, return *true*.\n  1. Return ContainsUndefinedContinueTarget of |CaseClause| with arguments _iterationSet_ and « ».","code":"\n        1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |CaseClauses| with arguments _iterationSet_ and « ».\n        1. If _hasUndefinedLabels_ is *true*, return *true*.\n        1. Return ContainsUndefinedContinueTarget of |CaseClause| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseClause","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If |StatementList| is present, return ContainsUndefinedContinueTarget of |StatementList| with arguments _iterationSet_ and « ».\n  1. Return *false*.","code":"\n        1. If the |StatementList| is present, return ContainsUndefinedContinueTarget of |StatementList| with arguments _iterationSet_ and « ».\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseClause","idx":0,"subIdx":1,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If |StatementList| is present, return ContainsUndefinedContinueTarget of |StatementList| with arguments _iterationSet_ and « ».\n  1. Return *false*.","code":"\n        1. If the |StatementList| is present, return ContainsUndefinedContinueTarget of |StatementList| with arguments _iterationSet_ and « ».\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DefaultClause","idx":0,"subIdx":0,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If |StatementList| is present, return ContainsUndefinedContinueTarget of |StatementList| with arguments _iterationSet_ and « ».\n  1. Return *false*.","code":"\n        1. If the |StatementList| is present, return ContainsUndefinedContinueTarget of |StatementList| with arguments _iterationSet_ and « ».\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DefaultClause","idx":0,"subIdx":1,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If |StatementList| is present, return ContainsUndefinedContinueTarget of |StatementList| with arguments _iterationSet_ and « ».\n  1. Return *false*.","code":"\n        1. If the |StatementList| is present, return ContainsUndefinedContinueTarget of |StatementList| with arguments _iterationSet_ and « ».\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LabelledStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"LabelIdentifier","ty":"Ast[LabelIdentifier]","kind":{"Normal":{}}},{"name":"LabelledItem","ty":"Ast[LabelledItem]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _label_ be StringValue of |LabelIdentifier|.\n  1. Let _newLabelSet_ be the list-concatenation of _labelSet_ and « _label_ ».\n  1. Return ContainsUndefinedContinueTarget of |LabelledItem| with arguments _iterationSet_ and _newLabelSet_.","code":"\n        1. Let _label_ be the StringValue of |LabelIdentifier|.\n        1. Let _newLabelSet_ be the list-concatenation of _labelSet_ and « _label_ ».\n        1. Return ContainsUndefinedContinueTarget of |LabelledItem| with arguments _iterationSet_ and _newLabelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LabelledItem","idx":1,"subIdx":0,"rhsParams":[{"name":"FunctionDeclaration","ty":"Ast[FunctionDeclaration]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TryStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Block","ty":"Ast[Block]","kind":{"Normal":{}}},{"name":"Catch","ty":"Ast[Catch]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |Block| with arguments _iterationSet_ and « ».\n  1. If _hasUndefinedLabels_ is *true*, return *true*.\n  1. Return ContainsUndefinedContinueTarget of |Catch| with arguments _iterationSet_ and « ».","code":"\n        1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |Block| with arguments _iterationSet_ and « ».\n        1. If _hasUndefinedLabels_ is *true*, return *true*.\n        1. Return ContainsUndefinedContinueTarget of |Catch| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TryStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"Block","ty":"Ast[Block]","kind":{"Normal":{}}},{"name":"Finally","ty":"Ast[Finally]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |Block| with arguments _iterationSet_ and « ».\n  1. If _hasUndefinedLabels_ is *true*, return *true*.\n  1. Return ContainsUndefinedContinueTarget of |Finally| with arguments _iterationSet_ and « ».","code":"\n        1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |Block| with arguments _iterationSet_ and « ».\n        1. If _hasUndefinedLabels_ is *true*, return *true*.\n        1. Return ContainsUndefinedContinueTarget of |Finally| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TryStatement","idx":2,"subIdx":0,"rhsParams":[{"name":"Block","ty":"Ast[Block]","kind":{"Normal":{}}},{"name":"Catch","ty":"Ast[Catch]","kind":{"Normal":{}}},{"name":"Finally","ty":"Ast[Finally]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If ContainsUndefinedContinueTarget of |Block| with arguments _iterationSet_ and « » is *true*, return *true*.\n  1. If ContainsUndefinedContinueTarget of |Catch| with arguments _iterationSet_ and « » is *true*, return *true*.\n  1. Return ContainsUndefinedContinueTarget of |Finally| with arguments _iterationSet_ and « ».","code":"\n        1. If ContainsUndefinedContinueTarget of |Block| with arguments _iterationSet_ and « » is *true*, return *true*.\n        1. If ContainsUndefinedContinueTarget of |Catch| with arguments _iterationSet_ and « » is *true*, return *true*.\n        1. Return ContainsUndefinedContinueTarget of |Finally| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Catch","idx":0,"subIdx":0,"rhsParams":[{"name":"CatchParameter","ty":"Ast[CatchParameter]","kind":{"Normal":{}}},{"name":"Block","ty":"Ast[Block]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ContainsUndefinedContinueTarget of |Block| with arguments _iterationSet_ and « ».","code":"\n        1. Return ContainsUndefinedContinueTarget of |Block| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionStatementList","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassStaticBlockStatementList","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItemList","idx":1,"subIdx":0,"rhsParams":[{"name":"ModuleItemList","ty":"Ast[ModuleItemList]","kind":{"Normal":{}}},{"name":"ModuleItem","ty":"Ast[ModuleItem]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |ModuleItemList| with arguments _iterationSet_ and « ».\n  1. If _hasUndefinedLabels_ is *true*, return *true*.\n  1. Return ContainsUndefinedContinueTarget of |ModuleItem| with arguments _iterationSet_ and « ».","code":"\n        1. Let _hasUndefinedLabels_ be ContainsUndefinedContinueTarget of |ModuleItemList| with arguments _iterationSet_ and « ».\n        1. If _hasUndefinedLabels_ is *true*, return *true*.\n        1. Return ContainsUndefinedContinueTarget of |ModuleItem| with arguments _iterationSet_ and « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItem","idx":0,"subIdx":0,"rhsParams":[{"name":"ImportDeclaration","ty":"Ast[ImportDeclaration]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItem","idx":1,"subIdx":0,"rhsParams":[{"name":"ExportDeclaration","ty":"Ast[ExportDeclaration]","kind":{"Normal":{}}}]},"methodName":"ContainsUndefinedContinueTarget","isStatic":true,"withParams":[{"name":"iterationSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":12,"subIdx":0,"rhsParams":[{"name":"CoverParenthesizedExpressionAndArrowParameterList","ty":"Ast[CoverParenthesizedExpressionAndArrowParameterList]","kind":{"Normal":{}}}]},"methodName":"HasName","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Let _expr_ be the |ParenthesizedExpression| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n  1. If IsFunctionDefinition of _expr_ is *false*, return *false*.\n  1. Return HasName of _expr_.","code":"\n        1. Let _expr_ be the |ParenthesizedExpression| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n        1. If IsFunctionDefinition of _expr_ is *false*, return *false*.\n        1. Return HasName of _expr_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"HasName","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"HasName","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"HasName","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncFunctionExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"HasName","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrowFunction","idx":0,"subIdx":0,"rhsParams":[{"name":"ArrowParameters","ty":"Ast[ArrowParameters]","kind":{"Normal":{}}},{"name":"ConciseBody","ty":"Ast[ConciseBody]","kind":{"Normal":{}}}]},"methodName":"HasName","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncArrowFunction","idx":0,"subIdx":0,"rhsParams":[{"name":"AsyncArrowBindingIdentifier","ty":"Ast[AsyncArrowBindingIdentifier]","kind":{"Normal":{}}},{"name":"AsyncConciseBody","ty":"Ast[AsyncConciseBody]","kind":{"Normal":{}}}]},"methodName":"HasName","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncArrowFunction","idx":1,"subIdx":0,"rhsParams":[{"name":"CoverCallExpressionAndAsyncArrowHead","ty":"Ast[CoverCallExpressionAndAsyncArrowHead]","kind":{"Normal":{}}},{"name":"AsyncConciseBody","ty":"Ast[AsyncConciseBody]","kind":{"Normal":{}}}]},"methodName":"HasName","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassTail","ty":"Ast[ClassTail]","kind":{"Normal":{}}}]},"methodName":"HasName","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionExpression","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"HasName","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorExpression","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"HasName","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorExpression","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"HasName","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncFunctionExpression","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"HasName","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassExpression","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"ClassTail","ty":"Ast[ClassTail]","kind":{"Normal":{}}}]},"methodName":"HasName","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":12,"subIdx":0,"rhsParams":[{"name":"CoverParenthesizedExpressionAndArrowParameterList","ty":"Ast[CoverParenthesizedExpressionAndArrowParameterList]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Let _expr_ be the |ParenthesizedExpression| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n  1. Return IsFunctionDefinition of _expr_.","code":"\n        1. Let _expr_ be the |ParenthesizedExpression| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n        1. Return IsFunctionDefinition of _expr_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"IdentifierReference","ty":"Ast[IdentifierReference]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"Literal","ty":"Ast[Literal]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"ArrayLiteral","ty":"Ast[ArrayLiteral]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"ObjectLiteral","ty":"Ast[ObjectLiteral]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":10,"subIdx":0,"rhsParams":[{"name":"RegularExpressionLiteral","ty":"Ast[RegularExpressionLiteral]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":11,"subIdx":0,"rhsParams":[{"name":"TemplateLiteral","ty":"Ast[TemplateLiteral]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"IdentifierName","ty":"Ast[IdentifierName]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"TemplateLiteral","ty":"Ast[TemplateLiteral]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"SuperProperty","ty":"Ast[SuperProperty]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":5,"subIdx":0,"rhsParams":[{"name":"MetaProperty","ty":"Ast[MetaProperty]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":6,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"Arguments","ty":"Ast[Arguments]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":7,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"PrivateIdentifier","ty":"Ast[PrivateIdentifier]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NewExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"NewExpression","ty":"Ast[NewExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LeftHandSideExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"CallExpression","ty":"Ast[CallExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LeftHandSideExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"OptionalExpression","ty":"Ast[OptionalExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UpdateExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UpdateExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UpdateExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UpdateExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":5,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":6,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":7,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":8,"subIdx":0,"rhsParams":[{"name":"AwaitExpression","ty":"Ast[AwaitExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExponentiationExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"UpdateExpression","ty":"Ast[UpdateExpression]","kind":{"Normal":{}}},{"name":"ExponentiationExpression","ty":"Ast[ExponentiationExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MultiplicativeExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"MultiplicativeExpression","ty":"Ast[MultiplicativeExpression]","kind":{"Normal":{}}},{"name":"MultiplicativeOperator","ty":"Ast[MultiplicativeOperator]","kind":{"Normal":{}}},{"name":"ExponentiationExpression","ty":"Ast[ExponentiationExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AdditiveExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"AdditiveExpression","ty":"Ast[AdditiveExpression]","kind":{"Normal":{}}},{"name":"MultiplicativeExpression","ty":"Ast[MultiplicativeExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AdditiveExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"AdditiveExpression","ty":"Ast[AdditiveExpression]","kind":{"Normal":{}}},{"name":"MultiplicativeExpression","ty":"Ast[MultiplicativeExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ShiftExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}},{"name":"AdditiveExpression","ty":"Ast[AdditiveExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ShiftExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}},{"name":"AdditiveExpression","ty":"Ast[AdditiveExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ShiftExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}},{"name":"AdditiveExpression","ty":"Ast[AdditiveExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RelationalExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}},{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RelationalExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}},{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RelationalExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}},{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RelationalExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}},{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RelationalExpression","idx":5,"subIdx":0,"rhsParams":[{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}},{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RelationalExpression","idx":6,"subIdx":0,"rhsParams":[{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}},{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RelationalExpression","idx":7,"subIdx":0,"rhsParams":[{"name":"PrivateIdentifier","ty":"Ast[PrivateIdentifier]","kind":{"Normal":{}}},{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"EqualityExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"EqualityExpression","ty":"Ast[EqualityExpression]","kind":{"Normal":{}}},{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"EqualityExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"EqualityExpression","ty":"Ast[EqualityExpression]","kind":{"Normal":{}}},{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"EqualityExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"EqualityExpression","ty":"Ast[EqualityExpression]","kind":{"Normal":{}}},{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"EqualityExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"EqualityExpression","ty":"Ast[EqualityExpression]","kind":{"Normal":{}}},{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BitwiseANDExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"BitwiseANDExpression","ty":"Ast[BitwiseANDExpression]","kind":{"Normal":{}}},{"name":"EqualityExpression","ty":"Ast[EqualityExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BitwiseXORExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"BitwiseXORExpression","ty":"Ast[BitwiseXORExpression]","kind":{"Normal":{}}},{"name":"BitwiseANDExpression","ty":"Ast[BitwiseANDExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BitwiseORExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"BitwiseORExpression","ty":"Ast[BitwiseORExpression]","kind":{"Normal":{}}},{"name":"BitwiseXORExpression","ty":"Ast[BitwiseXORExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LogicalANDExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"LogicalANDExpression","ty":"Ast[LogicalANDExpression]","kind":{"Normal":{}}},{"name":"BitwiseORExpression","ty":"Ast[BitwiseORExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LogicalORExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"LogicalORExpression","ty":"Ast[LogicalORExpression]","kind":{"Normal":{}}},{"name":"LogicalANDExpression","ty":"Ast[LogicalANDExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CoalesceExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"CoalesceExpressionHead","ty":"Ast[CoalesceExpressionHead]","kind":{"Normal":{}}},{"name":"BitwiseORExpression","ty":"Ast[BitwiseORExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ConditionalExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"ShortCircuitExpression","ty":"Ast[ShortCircuitExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"YieldExpression","ty":"Ast[YieldExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentExpression","idx":5,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentOperator","ty":"Ast[AssignmentOperator]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentExpression","idx":6,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentExpression","idx":7,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentExpression","idx":8,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Expression","idx":1,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"ArrowFunction","ty":"Ast[ArrowFunction]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"AsyncArrowFunction","ty":"Ast[AsyncArrowFunction]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionExpression","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorExpression","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorExpression","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncFunctionExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncFunctionExpression","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"ClassTail","ty":"Ast[ClassTail]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassExpression","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"ClassTail","ty":"Ast[ClassTail]","kind":{"Normal":{}}}]},"methodName":"IsFunctionDefinition","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsAnonymousFunctionDefinition","params":[{"name":"expr","ty":"Unknown[\"an |AssignmentExpression| Parse Node, an |Initializer| Parse Node, or an |Expression| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If IsFunctionDefinition of _expr_ is *false*, return *false*.\n  1. Let _hasName_ be HasName of _expr_.\n  1. If _hasName_ is *true*, return *false*.\n  1. Return *true*.","code":"\n        1. If IsFunctionDefinition of _expr_ is *false*, return *false*.\n        1. Let _hasName_ be HasName of _expr_.\n        1. If _hasName_ is *true*, return *false*.\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"IdentifierReference","ty":"Ast[IdentifierReference]","kind":{"Normal":{}}}]},"methodName":"IsIdentifierRef","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"IsIdentifierRef","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"Literal","ty":"Ast[Literal]","kind":{"Normal":{}}}]},"methodName":"IsIdentifierRef","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"ArrayLiteral","ty":"Ast[ArrayLiteral]","kind":{"Normal":{}}}]},"methodName":"IsIdentifierRef","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"ObjectLiteral","ty":"Ast[ObjectLiteral]","kind":{"Normal":{}}}]},"methodName":"IsIdentifierRef","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":5,"subIdx":0,"rhsParams":[{"name":"FunctionExpression","ty":"Ast[FunctionExpression]","kind":{"Normal":{}}}]},"methodName":"IsIdentifierRef","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":6,"subIdx":0,"rhsParams":[{"name":"ClassExpression","ty":"Ast[ClassExpression]","kind":{"Normal":{}}}]},"methodName":"IsIdentifierRef","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":7,"subIdx":0,"rhsParams":[{"name":"GeneratorExpression","ty":"Ast[GeneratorExpression]","kind":{"Normal":{}}}]},"methodName":"IsIdentifierRef","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":8,"subIdx":0,"rhsParams":[{"name":"AsyncFunctionExpression","ty":"Ast[AsyncFunctionExpression]","kind":{"Normal":{}}}]},"methodName":"IsIdentifierRef","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":9,"subIdx":0,"rhsParams":[{"name":"AsyncGeneratorExpression","ty":"Ast[AsyncGeneratorExpression]","kind":{"Normal":{}}}]},"methodName":"IsIdentifierRef","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":10,"subIdx":0,"rhsParams":[{"name":"RegularExpressionLiteral","ty":"Ast[RegularExpressionLiteral]","kind":{"Normal":{}}}]},"methodName":"IsIdentifierRef","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":11,"subIdx":0,"rhsParams":[{"name":"TemplateLiteral","ty":"Ast[TemplateLiteral]","kind":{"Normal":{}}}]},"methodName":"IsIdentifierRef","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":12,"subIdx":0,"rhsParams":[{"name":"CoverParenthesizedExpressionAndArrowParameterList","ty":"Ast[CoverParenthesizedExpressionAndArrowParameterList]","kind":{"Normal":{}}}]},"methodName":"IsIdentifierRef","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"IsIdentifierRef","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"IdentifierName","ty":"Ast[IdentifierName]","kind":{"Normal":{}}}]},"methodName":"IsIdentifierRef","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"TemplateLiteral","ty":"Ast[TemplateLiteral]","kind":{"Normal":{}}}]},"methodName":"IsIdentifierRef","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"SuperProperty","ty":"Ast[SuperProperty]","kind":{"Normal":{}}}]},"methodName":"IsIdentifierRef","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":5,"subIdx":0,"rhsParams":[{"name":"MetaProperty","ty":"Ast[MetaProperty]","kind":{"Normal":{}}}]},"methodName":"IsIdentifierRef","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":6,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"Arguments","ty":"Ast[Arguments]","kind":{"Normal":{}}}]},"methodName":"IsIdentifierRef","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":7,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"PrivateIdentifier","ty":"Ast[PrivateIdentifier]","kind":{"Normal":{}}}]},"methodName":"IsIdentifierRef","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NewExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"NewExpression","ty":"Ast[NewExpression]","kind":{"Normal":{}}}]},"methodName":"IsIdentifierRef","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LeftHandSideExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"CallExpression","ty":"Ast[CallExpression]","kind":{"Normal":{}}}]},"methodName":"IsIdentifierRef","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LeftHandSideExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"OptionalExpression","ty":"Ast[OptionalExpression]","kind":{"Normal":{}}}]},"methodName":"IsIdentifierRef","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":12,"subIdx":0,"rhsParams":[{"name":"CoverParenthesizedExpressionAndArrowParameterList","ty":"Ast[CoverParenthesizedExpressionAndArrowParameterList]","kind":{"Normal":{}}}]},"methodName":"NamedEvaluation","isStatic":false,"withParams":[{"name":"name","ty":"Record[PrivateName | Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Record[FunctionObject]] | Abrupt"}},"body":"\n  1. Let _expr_ be the |ParenthesizedExpression| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n  1. Return ? NamedEvaluation of _expr_ with argument _name_.","code":"\n        1. Let _expr_ be the |ParenthesizedExpression| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n        1. Return ? NamedEvaluation of _expr_ with argument _name_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ParenthesizedExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"NamedEvaluation","isStatic":false,"withParams":[{"name":"name","ty":"Record[PrivateName | Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Record[FunctionObject]] | Abrupt"}},"body":"\n  1. Assert: IsAnonymousFunctionDefinition(|Expression|) is *true*.\n  1. Return ? NamedEvaluation of |Expression| with argument _name_.","code":"\n        1. Assert: IsAnonymousFunctionDefinition(|Expression|) is *true*.\n        1. Return ? NamedEvaluation of |Expression| with argument _name_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"NamedEvaluation","isStatic":false,"withParams":[{"name":"name","ty":"Record[PrivateName | Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Record[FunctionObject]] | Abrupt"}},"body":"\n  1. Return InstantiateOrdinaryFunctionExpression of |FunctionExpression| with argument _name_.","code":"\n        1. Return InstantiateOrdinaryFunctionExpression of |FunctionExpression| with argument _name_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"NamedEvaluation","isStatic":false,"withParams":[{"name":"name","ty":"Record[PrivateName | Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Record[FunctionObject]] | Abrupt"}},"body":"\n  1. Return InstantiateGeneratorFunctionExpression of |GeneratorExpression| with argument _name_.","code":"\n        1. Return InstantiateGeneratorFunctionExpression of |GeneratorExpression| with argument _name_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"NamedEvaluation","isStatic":false,"withParams":[{"name":"name","ty":"Record[PrivateName | Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Record[FunctionObject]] | Abrupt"}},"body":"\n  1. Return InstantiateAsyncGeneratorFunctionExpression of |AsyncGeneratorExpression| with argument _name_.","code":"\n        1. Return InstantiateAsyncGeneratorFunctionExpression of |AsyncGeneratorExpression| with argument _name_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncFunctionExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"NamedEvaluation","isStatic":false,"withParams":[{"name":"name","ty":"Record[PrivateName | Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Record[FunctionObject]] | Abrupt"}},"body":"\n  1. Return InstantiateAsyncFunctionExpression of |AsyncFunctionExpression| with argument _name_.","code":"\n        1. Return InstantiateAsyncFunctionExpression of |AsyncFunctionExpression| with argument _name_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrowFunction","idx":0,"subIdx":0,"rhsParams":[{"name":"ArrowParameters","ty":"Ast[ArrowParameters]","kind":{"Normal":{}}},{"name":"ConciseBody","ty":"Ast[ConciseBody]","kind":{"Normal":{}}}]},"methodName":"NamedEvaluation","isStatic":false,"withParams":[{"name":"name","ty":"Record[PrivateName | Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Record[FunctionObject]] | Abrupt"}},"body":"\n  1. Return InstantiateArrowFunctionExpression of |ArrowFunction| with argument _name_.","code":"\n        1. Return InstantiateArrowFunctionExpression of |ArrowFunction| with argument _name_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncArrowFunction","idx":0,"subIdx":0,"rhsParams":[{"name":"AsyncArrowBindingIdentifier","ty":"Ast[AsyncArrowBindingIdentifier]","kind":{"Normal":{}}},{"name":"AsyncConciseBody","ty":"Ast[AsyncConciseBody]","kind":{"Normal":{}}}]},"methodName":"NamedEvaluation","isStatic":false,"withParams":[{"name":"name","ty":"Record[PrivateName | Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Record[FunctionObject]] | Abrupt"}},"body":"\n  1. Return InstantiateAsyncArrowFunctionExpression of |AsyncArrowFunction| with argument _name_.","code":"\n        1. Return InstantiateAsyncArrowFunctionExpression of |AsyncArrowFunction| with argument _name_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncArrowFunction","idx":1,"subIdx":0,"rhsParams":[{"name":"CoverCallExpressionAndAsyncArrowHead","ty":"Ast[CoverCallExpressionAndAsyncArrowHead]","kind":{"Normal":{}}},{"name":"AsyncConciseBody","ty":"Ast[AsyncConciseBody]","kind":{"Normal":{}}}]},"methodName":"NamedEvaluation","isStatic":false,"withParams":[{"name":"name","ty":"Record[PrivateName | Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Record[FunctionObject]] | Abrupt"}},"body":"\n  1. Return InstantiateAsyncArrowFunctionExpression of |AsyncArrowFunction| with argument _name_.","code":"\n        1. Return InstantiateAsyncArrowFunctionExpression of |AsyncArrowFunction| with argument _name_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassTail","ty":"Ast[ClassTail]","kind":{"Normal":{}}}]},"methodName":"NamedEvaluation","isStatic":false,"withParams":[{"name":"name","ty":"Record[PrivateName | Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Record[FunctionObject]] | Abrupt"}},"body":"\n  1. Let _value_ be ? ClassDefinitionEvaluation of |ClassTail| with arguments *undefined* and _name_.\n  1. Set _value_.[[SourceText]] to the source text matched by |ClassExpression|.\n  1. Return _value_.","code":"\n        1. Let _value_ be ? ClassDefinitionEvaluation of |ClassTail| with arguments *undefined* and _name_.\n        1. Set _value_.[[SourceText]] to the source text matched by |ClassExpression|.\n        1. Return _value_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":null,"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. For each child node _child_ of *this* value, do\n    1. If _child_ is an instance of _symbol_, return *true*.\n    1. If _child_ is an instance of a nonterminal, then\n      1. Let _contained_ be the result of _child_ Contains _symbol_.\n      1. If _contained_ is *true*, return *true*.\n  1. Return *false*.","code":"\n        1. For each child node _child_ of this Parse Node, do\n          1. If _child_ is an instance of _symbol_, return *true*.\n          1. If _child_ is an instance of a nonterminal, then\n            1. Let _contained_ be the result of _child_ Contains _symbol_.\n            1. If _contained_ is *true*, return *true*.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionExpression","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorExpression","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorExpression","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncFunctionDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncFunctionDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncFunctionExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncFunctionExpression","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassTail","idx":0,"subIdx":1,"rhsParams":[{"name":"ClassHeritage","ty":"Ast[ClassHeritage]","kind":{"Normal":{}}},{"name":"ClassBody","ty":"Ast[ClassBody]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _symbol_ is |ClassBody|, return *true*.\n  1. If _symbol_ is |ClassHeritage|, then\n    1. If |ClassHeritage| is present, return *true*.\n    1. Else, return *false*.\n  1. If |ClassHeritage| is present, then\n    1. If |ClassHeritage| Contains _symbol_ is *true*, return *true*.\n  1. Return ComputedPropertyContains of |ClassBody| with argument _symbol_.","code":"\n        1. If _symbol_ is |ClassBody|, return *true*.\n        1. If _symbol_ is |ClassHeritage|, then\n          1. If |ClassHeritage| is present, return *true*; otherwise return *false*.\n        1. If |ClassHeritage| is present, then\n          1. If |ClassHeritage| Contains _symbol_ is *true*, return *true*.\n        1. Return the result of ComputedPropertyContains of |ClassBody| with argument _symbol_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassTail","idx":0,"subIdx":3,"rhsParams":[{"name":"ClassHeritage","ty":"Ast[ClassHeritage]","kind":{"Normal":{}}},{"name":"ClassBody","ty":"Ast[ClassBody]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _symbol_ is |ClassBody|, return *true*.\n  1. If _symbol_ is |ClassHeritage|, then\n    1. If |ClassHeritage| is present, return *true*.\n    1. Else, return *false*.\n  1. If |ClassHeritage| is present, then\n    1. If |ClassHeritage| Contains _symbol_ is *true*, return *true*.\n  1. Return ComputedPropertyContains of |ClassBody| with argument _symbol_.","code":"\n        1. If _symbol_ is |ClassBody|, return *true*.\n        1. If _symbol_ is |ClassHeritage|, then\n          1. If |ClassHeritage| is present, return *true*; otherwise return *false*.\n        1. If |ClassHeritage| is present, then\n          1. If |ClassHeritage| Contains _symbol_ is *true*, return *true*.\n        1. Return the result of ComputedPropertyContains of |ClassBody| with argument _symbol_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassStaticBlock","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassStaticBlockBody","ty":"Ast[ClassStaticBlockBody]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrowFunction","idx":0,"subIdx":0,"rhsParams":[{"name":"ArrowParameters","ty":"Ast[ArrowParameters]","kind":{"Normal":{}}},{"name":"ConciseBody","ty":"Ast[ConciseBody]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _symbol_ is neither |NewTarget|, |SuperProperty|, |SuperCall|, `super`, nor `this`, return *false*.\n  1. If |ArrowParameters| Contains _symbol_ is *true*, return *true*.\n  1. Return |ConciseBody| Contains _symbol_.","code":"\n        1. If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, `super`, or `this`, return *false*.\n        1. If |ArrowParameters| Contains _symbol_ is *true*, return *true*.\n        1. Return |ConciseBody| Contains _symbol_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrowParameters","idx":1,"subIdx":0,"rhsParams":[{"name":"CoverParenthesizedExpressionAndArrowParameterList","ty":"Ast[CoverParenthesizedExpressionAndArrowParameterList]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _formals_ be the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n  1. Return _formals_ Contains _symbol_.","code":"\n        1. Let _formals_ be the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n        1. Return _formals_ Contains _symbol_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncArrowFunction","idx":0,"subIdx":0,"rhsParams":[{"name":"AsyncArrowBindingIdentifier","ty":"Ast[AsyncArrowBindingIdentifier]","kind":{"Normal":{}}},{"name":"AsyncConciseBody","ty":"Ast[AsyncConciseBody]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _symbol_ is neither |NewTarget|, |SuperProperty|, |SuperCall|, `super`, nor `this`, return *false*.\n  1. Return |AsyncConciseBody| Contains _symbol_.","code":"\n        1. If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, `super`, or `this`, return *false*.\n        1. Return |AsyncConciseBody| Contains _symbol_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncArrowFunction","idx":1,"subIdx":0,"rhsParams":[{"name":"CoverCallExpressionAndAsyncArrowHead","ty":"Ast[CoverCallExpressionAndAsyncArrowHead]","kind":{"Normal":{}}},{"name":"AsyncConciseBody","ty":"Ast[AsyncConciseBody]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _symbol_ is neither |NewTarget|, |SuperProperty|, |SuperCall|, `super`, nor `this`, return *false*.\n  1. Let _head_ be the |AsyncArrowHead| that is covered by |CoverCallExpressionAndAsyncArrowHead|.\n  1. If _head_ Contains _symbol_ is *true*, return *true*.\n  1. Return |AsyncConciseBody| Contains _symbol_.","code":"\n        1. If _symbol_ is not one of |NewTarget|, |SuperProperty|, |SuperCall|, `super`, or `this`, return *false*.\n        1. Let _head_ be the |AsyncArrowHead| that is covered by |CoverCallExpressionAndAsyncArrowHead|.\n        1. If _head_ Contains _symbol_ is *true*, return *true*.\n        1. Return |AsyncConciseBody| Contains _symbol_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PropertyDefinition","idx":3,"subIdx":0,"rhsParams":[{"name":"MethodDefinition","ty":"Ast[MethodDefinition]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _symbol_ is |MethodDefinition|, return *true*.\n  1. Return ComputedPropertyContains of |MethodDefinition| with argument _symbol_.","code":"\n        1. If _symbol_ is |MethodDefinition|, return *true*.\n        1. Return the result of ComputedPropertyContains of |MethodDefinition| with argument _symbol_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LiteralPropertyName","idx":0,"subIdx":0,"rhsParams":[{"name":"IdentifierName","ty":"Ast[IdentifierName]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"IdentifierName","ty":"Ast[IdentifierName]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If |MemberExpression| Contains _symbol_ is *true*, return *true*.\n  1. Return *false*.","code":"\n        1. If |MemberExpression| Contains _symbol_ is *true*, return *true*.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"SuperProperty","idx":1,"subIdx":0,"rhsParams":[{"name":"IdentifierName","ty":"Ast[IdentifierName]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _symbol_ is the |ReservedWord| `super`, return *true*.\n  1. Return *false*.","code":"\n        1. If _symbol_ is the |ReservedWord| `super`, return *true*.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CallExpression","idx":5,"subIdx":0,"rhsParams":[{"name":"CallExpression","ty":"Ast[CallExpression]","kind":{"Normal":{}}},{"name":"IdentifierName","ty":"Ast[IdentifierName]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If |CallExpression| Contains _symbol_ is *true*, return *true*.\n  1. Return *false*.","code":"\n        1. If |CallExpression| Contains _symbol_ is *true*, return *true*.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"OptionalChain","idx":2,"subIdx":0,"rhsParams":[{"name":"IdentifierName","ty":"Ast[IdentifierName]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"OptionalChain","idx":7,"subIdx":0,"rhsParams":[{"name":"OptionalChain","ty":"Ast[OptionalChain]","kind":{"Normal":{}}},{"name":"IdentifierName","ty":"Ast[IdentifierName]","kind":{"Normal":{}}}]},"methodName":"Contains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If |OptionalChain| Contains _symbol_ is *true*, return *true*.\n  1. Return *false*.","code":"\n        1. If |OptionalChain| Contains _symbol_ is *true*, return *true*.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElementName","idx":1,"subIdx":0,"rhsParams":[{"name":"PrivateIdentifier","ty":"Ast[PrivateIdentifier]","kind":{"Normal":{}}}]},"methodName":"ComputedPropertyContains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PropertyName","idx":0,"subIdx":0,"rhsParams":[{"name":"LiteralPropertyName","ty":"Ast[LiteralPropertyName]","kind":{"Normal":{}}}]},"methodName":"ComputedPropertyContains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PropertyName","idx":1,"subIdx":0,"rhsParams":[{"name":"ComputedPropertyName","ty":"Ast[ComputedPropertyName]","kind":{"Normal":{}}}]},"methodName":"ComputedPropertyContains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return the result of |ComputedPropertyName| Contains _symbol_.","code":"\n        1. Return the result of |ComputedPropertyName| Contains _symbol_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MethodDefinition","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"UniqueFormalParameters","ty":"Ast[UniqueFormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"ComputedPropertyContains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ComputedPropertyContains of |ClassElementName| with argument _symbol_.","code":"\n        1. Return the result of ComputedPropertyContains of |ClassElementName| with argument _symbol_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MethodDefinition","idx":4,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"ComputedPropertyContains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ComputedPropertyContains of |ClassElementName| with argument _symbol_.","code":"\n        1. Return the result of ComputedPropertyContains of |ClassElementName| with argument _symbol_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MethodDefinition","idx":5,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"PropertySetParameterList","ty":"Ast[PropertySetParameterList]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"ComputedPropertyContains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ComputedPropertyContains of |ClassElementName| with argument _symbol_.","code":"\n        1. Return the result of ComputedPropertyContains of |ClassElementName| with argument _symbol_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorMethod","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"UniqueFormalParameters","ty":"Ast[UniqueFormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"ComputedPropertyContains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ComputedPropertyContains of |ClassElementName| with argument _symbol_.","code":"\n        1. Return the result of ComputedPropertyContains of |ClassElementName| with argument _symbol_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorMethod","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"UniqueFormalParameters","ty":"Ast[UniqueFormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"ComputedPropertyContains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ComputedPropertyContains of |ClassElementName| with argument _symbol_.","code":"\n        1. Return the result of ComputedPropertyContains of |ClassElementName| with argument _symbol_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElementList","idx":1,"subIdx":0,"rhsParams":[{"name":"ClassElementList","ty":"Ast[ClassElementList]","kind":{"Normal":{}}},{"name":"ClassElement","ty":"Ast[ClassElement]","kind":{"Normal":{}}}]},"methodName":"ComputedPropertyContains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _inList_ be ComputedPropertyContains of |ClassElementList| with argument _symbol_.\n  1. If _inList_ is *true*, return *true*.\n  1. Return ComputedPropertyContains of |ClassElement| with argument _symbol_.","code":"\n        1. Let _inList_ be ComputedPropertyContains of |ClassElementList| with argument _symbol_.\n        1. If _inList_ is *true*, return *true*.\n        1. Return the result of ComputedPropertyContains of |ClassElement| with argument _symbol_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElement","idx":4,"subIdx":0,"rhsParams":[{"name":"ClassStaticBlock","ty":"Ast[ClassStaticBlock]","kind":{"Normal":{}}}]},"methodName":"ComputedPropertyContains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElement","idx":5,"subIdx":0,"rhsParams":[]},"methodName":"ComputedPropertyContains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncMethod","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"UniqueFormalParameters","ty":"Ast[UniqueFormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"ComputedPropertyContains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ComputedPropertyContains of |ClassElementName| with argument _symbol_.","code":"\n        1. Return the result of ComputedPropertyContains of |ClassElementName| with argument _symbol_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FieldDefinition","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"ComputedPropertyContains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ComputedPropertyContains of |ClassElementName| with argument _symbol_.","code":"\n        1. Return the result of ComputedPropertyContains of |ClassElementName| with argument _symbol_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FieldDefinition","idx":0,"subIdx":1,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"ComputedPropertyContains","isStatic":true,"withParams":[{"name":"symbol","ty":"GrammarSymbol","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ComputedPropertyContains of |ClassElementName| with argument _symbol_.","code":"\n        1. Return the result of ComputedPropertyContains of |ClassElementName| with argument _symbol_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"InstantiateFunctionObject","isStatic":false,"withParams":[{"name":"env","ty":"Record[EnvironmentRecord]","kind":{"Normal":{}}},{"name":"privateEnv","ty":"Record[PrivateEnvironmentRecord] | Null","kind":{"Normal":{}}}],"retTy":"Record[ECMAScriptFunctionObject]"}},"body":"\n  1. Return InstantiateOrdinaryFunctionObject of |FunctionDeclaration| with arguments _env_ and _privateEnv_.","code":"\n        1. Return InstantiateOrdinaryFunctionObject of |FunctionDeclaration| with arguments _env_ and _privateEnv_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"InstantiateFunctionObject","isStatic":false,"withParams":[{"name":"env","ty":"Record[EnvironmentRecord]","kind":{"Normal":{}}},{"name":"privateEnv","ty":"Record[PrivateEnvironmentRecord] | Null","kind":{"Normal":{}}}],"retTy":"Record[ECMAScriptFunctionObject]"}},"body":"\n  1. Return InstantiateOrdinaryFunctionObject of |FunctionDeclaration| with arguments _env_ and _privateEnv_.","code":"\n        1. Return InstantiateOrdinaryFunctionObject of |FunctionDeclaration| with arguments _env_ and _privateEnv_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"InstantiateFunctionObject","isStatic":false,"withParams":[{"name":"env","ty":"Record[EnvironmentRecord]","kind":{"Normal":{}}},{"name":"privateEnv","ty":"Record[PrivateEnvironmentRecord] | Null","kind":{"Normal":{}}}],"retTy":"Record[ECMAScriptFunctionObject]"}},"body":"\n  1. Return InstantiateGeneratorFunctionObject of |GeneratorDeclaration| with arguments _env_ and _privateEnv_.","code":"\n        1. Return InstantiateGeneratorFunctionObject of |GeneratorDeclaration| with arguments _env_ and _privateEnv_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"InstantiateFunctionObject","isStatic":false,"withParams":[{"name":"env","ty":"Record[EnvironmentRecord]","kind":{"Normal":{}}},{"name":"privateEnv","ty":"Record[PrivateEnvironmentRecord] | Null","kind":{"Normal":{}}}],"retTy":"Record[ECMAScriptFunctionObject]"}},"body":"\n  1. Return InstantiateGeneratorFunctionObject of |GeneratorDeclaration| with arguments _env_ and _privateEnv_.","code":"\n        1. Return InstantiateGeneratorFunctionObject of |GeneratorDeclaration| with arguments _env_ and _privateEnv_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"InstantiateFunctionObject","isStatic":false,"withParams":[{"name":"env","ty":"Record[EnvironmentRecord]","kind":{"Normal":{}}},{"name":"privateEnv","ty":"Record[PrivateEnvironmentRecord] | Null","kind":{"Normal":{}}}],"retTy":"Record[ECMAScriptFunctionObject]"}},"body":"\n  1. Return InstantiateAsyncGeneratorFunctionObject of |AsyncGeneratorDeclaration| with arguments _env_ and _privateEnv_.","code":"\n        1. Return InstantiateAsyncGeneratorFunctionObject of |AsyncGeneratorDeclaration| with arguments _env_ and _privateEnv_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"InstantiateFunctionObject","isStatic":false,"withParams":[{"name":"env","ty":"Record[EnvironmentRecord]","kind":{"Normal":{}}},{"name":"privateEnv","ty":"Record[PrivateEnvironmentRecord] | Null","kind":{"Normal":{}}}],"retTy":"Record[ECMAScriptFunctionObject]"}},"body":"\n  1. Return InstantiateAsyncGeneratorFunctionObject of |AsyncGeneratorDeclaration| with arguments _env_ and _privateEnv_.","code":"\n        1. Return InstantiateAsyncGeneratorFunctionObject of |AsyncGeneratorDeclaration| with arguments _env_ and _privateEnv_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncFunctionDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"InstantiateFunctionObject","isStatic":false,"withParams":[{"name":"env","ty":"Record[EnvironmentRecord]","kind":{"Normal":{}}},{"name":"privateEnv","ty":"Record[PrivateEnvironmentRecord] | Null","kind":{"Normal":{}}}],"retTy":"Record[ECMAScriptFunctionObject]"}},"body":"\n  1. Return InstantiateAsyncFunctionObject of |AsyncFunctionDeclaration| with arguments _env_ and _privateEnv_.","code":"\n        1. Return InstantiateAsyncFunctionObject of |AsyncFunctionDeclaration| with arguments _env_ and _privateEnv_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncFunctionDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"InstantiateFunctionObject","isStatic":false,"withParams":[{"name":"env","ty":"Record[EnvironmentRecord]","kind":{"Normal":{}}},{"name":"privateEnv","ty":"Record[PrivateEnvironmentRecord] | Null","kind":{"Normal":{}}}],"retTy":"Record[ECMAScriptFunctionObject]"}},"body":"\n  1. Return InstantiateAsyncFunctionObject of |AsyncFunctionDeclaration| with arguments _env_ and _privateEnv_.","code":"\n        1. Return InstantiateAsyncFunctionObject of |AsyncFunctionDeclaration| with arguments _env_ and _privateEnv_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingIdentifier","idx":0,"subIdx":0,"rhsParams":[{"name":"Identifier","ty":"Ast[Identifier]","kind":{"Normal":{}}}]},"methodName":"BindingInitialization","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _name_ be StringValue of |Identifier|.\n  1. Return ? InitializeBoundName(_name_, _value_, _environment_).","code":"\n        1. Let _name_ be StringValue of |Identifier|.\n        1. Return ? InitializeBoundName(_name_, _value_, _environment_).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingIdentifier","idx":1,"subIdx":0,"rhsParams":[]},"methodName":"BindingInitialization","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Return ? InitializeBoundName(*\"yield\"*, _value_, _environment_).","code":"\n        1. Return ? InitializeBoundName(*\"yield\"*, _value_, _environment_).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingIdentifier","idx":2,"subIdx":0,"rhsParams":[]},"methodName":"BindingInitialization","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Return ? InitializeBoundName(*\"await\"*, _value_, _environment_).","code":"\n        1. Return ? InitializeBoundName(*\"await\"*, _value_, _environment_).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingPattern","idx":0,"subIdx":0,"rhsParams":[{"name":"ObjectBindingPattern","ty":"Ast[ObjectBindingPattern]","kind":{"Normal":{}}}]},"methodName":"BindingInitialization","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Perform ? RequireObjectCoercible(_value_).\n  1. Return ? BindingInitialization of |ObjectBindingPattern| with arguments _value_ and _environment_.","code":"\n        1. Perform ? RequireObjectCoercible(_value_).\n        1. Return ? BindingInitialization of |ObjectBindingPattern| with arguments _value_ and _environment_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingPattern","idx":1,"subIdx":0,"rhsParams":[{"name":"ArrayBindingPattern","ty":"Ast[ArrayBindingPattern]","kind":{"Normal":{}}}]},"methodName":"BindingInitialization","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n  1. Let _result_ be Completion(IteratorBindingInitialization of |ArrayBindingPattern| with arguments _iteratorRecord_ and _environment_).\n  1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _result_).\n  1. Return ? _result_.","code":"\n        1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n        1. Let _result_ be Completion(IteratorBindingInitialization of |ArrayBindingPattern| with arguments _iteratorRecord_ and _environment_).\n        1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _result_).\n        1. Return ? _result_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ObjectBindingPattern","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"BindingInitialization","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Return ~unused~.","code":"\n        1. Return ~unused~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ObjectBindingPattern","idx":2,"subIdx":0,"rhsParams":[{"name":"BindingPropertyList","ty":"Ast[BindingPropertyList]","kind":{"Normal":{}}}]},"methodName":"BindingInitialization","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Perform ? PropertyBindingInitialization of |BindingPropertyList| with arguments _value_ and _environment_.\n  1. Return ~unused~.","code":"\n        1. Perform ? PropertyBindingInitialization of |BindingPropertyList| with arguments _value_ and _environment_.\n        1. Return ~unused~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ObjectBindingPattern","idx":3,"subIdx":0,"rhsParams":[{"name":"BindingPropertyList","ty":"Ast[BindingPropertyList]","kind":{"Normal":{}}}]},"methodName":"BindingInitialization","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Perform ? PropertyBindingInitialization of |BindingPropertyList| with arguments _value_ and _environment_.\n  1. Return ~unused~.","code":"\n        1. Perform ? PropertyBindingInitialization of |BindingPropertyList| with arguments _value_ and _environment_.\n        1. Return ~unused~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ObjectBindingPattern","idx":1,"subIdx":0,"rhsParams":[{"name":"BindingRestProperty","ty":"Ast[BindingRestProperty]","kind":{"Normal":{}}}]},"methodName":"BindingInitialization","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _excludedNames_ be « ».\n  1. Return ? RestBindingInitialization of |BindingRestProperty| with arguments _value_, _environment_, and _excludedNames_.","code":"\n        1. Let _excludedNames_ be a new empty List.\n        1. Return ? RestBindingInitialization of |BindingRestProperty| with arguments _value_, _environment_, and _excludedNames_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ObjectBindingPattern","idx":3,"subIdx":1,"rhsParams":[{"name":"BindingPropertyList","ty":"Ast[BindingPropertyList]","kind":{"Normal":{}}},{"name":"BindingRestProperty","ty":"Ast[BindingRestProperty]","kind":{"Normal":{}}}]},"methodName":"BindingInitialization","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _excludedNames_ be ? PropertyBindingInitialization of |BindingPropertyList| with arguments _value_ and _environment_.\n  1. Return ? RestBindingInitialization of |BindingRestProperty| with arguments _value_, _environment_, and _excludedNames_.","code":"\n        1. Let _excludedNames_ be ? PropertyBindingInitialization of |BindingPropertyList| with arguments _value_ and _environment_.\n        1. Return ? RestBindingInitialization of |BindingRestProperty| with arguments _value_, _environment_, and _excludedNames_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"InitializeBoundName","params":[{"name":"name","ty":"String","kind":{"Normal":{}}},{"name":"value","ty":"ESValue","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. If _environment_ is not *undefined*, then\n    1. Perform ! _environment_.InitializeBinding(_name_, _value_).\n    1. Return ~unused~.\n  1. Else,\n    1. Let _lhs_ be ? ResolveBinding(_name_).\n    1. Return ? PutValue(_lhs_, _value_).","code":"\n          1. If _environment_ is not *undefined*, then\n            1. Perform ! _environment_.InitializeBinding(_name_, _value_).\n            1. Return ~unused~.\n          1. Else,\n            1. Let _lhs_ be ? ResolveBinding(_name_).\n            1. Return ? PutValue(_lhs_, _value_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayBindingPattern","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"IteratorBindingInitialization","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Return ~unused~.","code":"\n        1. Return ~unused~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayBindingPattern","idx":0,"subIdx":2,"rhsParams":[{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}}]},"methodName":"IteratorBindingInitialization","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Return ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.","code":"\n        1. Return ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayBindingPattern","idx":0,"subIdx":1,"rhsParams":[{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"BindingRestElement","ty":"Ast[BindingRestElement]","kind":{"Normal":{}}}]},"methodName":"IteratorBindingInitialization","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. If |Elision| is present, then\n    1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.\n  1. Return ? IteratorBindingInitialization of |BindingRestElement| with arguments _iteratorRecord_ and _environment_.","code":"\n        1. If |Elision| is present, then\n          1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.\n        1. Return ? IteratorBindingInitialization of |BindingRestElement| with arguments _iteratorRecord_ and _environment_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayBindingPattern","idx":0,"subIdx":3,"rhsParams":[{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"BindingRestElement","ty":"Ast[BindingRestElement]","kind":{"Normal":{}}}]},"methodName":"IteratorBindingInitialization","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. If |Elision| is present, then\n    1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.\n  1. Return ? IteratorBindingInitialization of |BindingRestElement| with arguments _iteratorRecord_ and _environment_.","code":"\n        1. If |Elision| is present, then\n          1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.\n        1. Return ? IteratorBindingInitialization of |BindingRestElement| with arguments _iteratorRecord_ and _environment_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayBindingPattern","idx":2,"subIdx":2,"rhsParams":[{"name":"BindingElementList","ty":"Ast[BindingElementList]","kind":{"Normal":{}}},{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}}]},"methodName":"IteratorBindingInitialization","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Perform ? IteratorBindingInitialization of |BindingElementList| with arguments _iteratorRecord_ and _environment_.\n  1. Return ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.","code":"\n        1. Perform ? IteratorBindingInitialization of |BindingElementList| with arguments _iteratorRecord_ and _environment_.\n        1. Return ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayBindingPattern","idx":2,"subIdx":1,"rhsParams":[{"name":"BindingElementList","ty":"Ast[BindingElementList]","kind":{"Normal":{}}},{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"BindingRestElement","ty":"Ast[BindingRestElement]","kind":{"Normal":{}}}]},"methodName":"IteratorBindingInitialization","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Perform ? IteratorBindingInitialization of |BindingElementList| with arguments _iteratorRecord_ and _environment_.\n  1. If |Elision| is present, then\n    1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.\n  1. Return ? IteratorBindingInitialization of |BindingRestElement| with arguments _iteratorRecord_ and _environment_.","code":"\n        1. Perform ? IteratorBindingInitialization of |BindingElementList| with arguments _iteratorRecord_ and _environment_.\n        1. If |Elision| is present, then\n          1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.\n        1. Return ? IteratorBindingInitialization of |BindingRestElement| with arguments _iteratorRecord_ and _environment_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayBindingPattern","idx":2,"subIdx":3,"rhsParams":[{"name":"BindingElementList","ty":"Ast[BindingElementList]","kind":{"Normal":{}}},{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"BindingRestElement","ty":"Ast[BindingRestElement]","kind":{"Normal":{}}}]},"methodName":"IteratorBindingInitialization","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Perform ? IteratorBindingInitialization of |BindingElementList| with arguments _iteratorRecord_ and _environment_.\n  1. If |Elision| is present, then\n    1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.\n  1. Return ? IteratorBindingInitialization of |BindingRestElement| with arguments _iteratorRecord_ and _environment_.","code":"\n        1. Perform ? IteratorBindingInitialization of |BindingElementList| with arguments _iteratorRecord_ and _environment_.\n        1. If |Elision| is present, then\n          1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.\n        1. Return ? IteratorBindingInitialization of |BindingRestElement| with arguments _iteratorRecord_ and _environment_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingElementList","idx":1,"subIdx":0,"rhsParams":[{"name":"BindingElementList","ty":"Ast[BindingElementList]","kind":{"Normal":{}}},{"name":"BindingElisionElement","ty":"Ast[BindingElisionElement]","kind":{"Normal":{}}}]},"methodName":"IteratorBindingInitialization","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Perform ? IteratorBindingInitialization of |BindingElementList| with arguments _iteratorRecord_ and _environment_.\n  1. Return ? IteratorBindingInitialization of |BindingElisionElement| with arguments _iteratorRecord_ and _environment_.","code":"\n        1. Perform ? IteratorBindingInitialization of |BindingElementList| with arguments _iteratorRecord_ and _environment_.\n        1. Return ? IteratorBindingInitialization of |BindingElisionElement| with arguments _iteratorRecord_ and _environment_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingElisionElement","idx":0,"subIdx":1,"rhsParams":[{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"BindingElement","ty":"Ast[BindingElement]","kind":{"Normal":{}}}]},"methodName":"IteratorBindingInitialization","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.\n  1. Return ? IteratorBindingInitialization of |BindingElement| with arguments _iteratorRecord_ and _environment_.","code":"\n        1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.\n        1. Return ? IteratorBindingInitialization of |BindingElement| with arguments _iteratorRecord_ and _environment_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"SingleNameBinding","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"IteratorBindingInitialization","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _bindingId_ be StringValue of |BindingIdentifier|.\n  1. Let _lhs_ be ? ResolveBinding(_bindingId_, _environment_).\n  1. Let _v_ be *undefined*.\n  1. If _iteratorRecord_.[[Done]] is *false*, then\n    1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n    1. If _next_ is not ~done~, then\n      1. Set _v_ to _next_.\n  1. If |Initializer| is present and _v_ is *undefined*, then\n    1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then\n      1. Set _v_ to ? NamedEvaluation of |Initializer| with argument _bindingId_.\n    1. Else,\n      1. Let _defaultValue_ be ? the result of evaluating |Initializer|.\n      1. Set _v_ to ? GetValue(_defaultValue_).\n  1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _v_).\n  1. Return ? InitializeReferencedBinding(_lhs_, _v_).","code":"\n        1. Let _bindingId_ be StringValue of |BindingIdentifier|.\n        1. Let _lhs_ be ? ResolveBinding(_bindingId_, _environment_).\n        1. Let _v_ be *undefined*.\n        1. If _iteratorRecord_.[[Done]] is *false*, then\n          1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n          1. If _next_ is not ~done~, then\n            1. Set _v_ to _next_.\n        1. If |Initializer| is present and _v_ is *undefined*, then\n          1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then\n            1. Set _v_ to ? NamedEvaluation of |Initializer| with argument _bindingId_.\n          1. Else,\n            1. Let _defaultValue_ be ? Evaluation of |Initializer|.\n            1. Set _v_ to ? GetValue(_defaultValue_).\n        1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _v_).\n        1. Return ? InitializeReferencedBinding(_lhs_, _v_).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"SingleNameBinding","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"IteratorBindingInitialization","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _bindingId_ be StringValue of |BindingIdentifier|.\n  1. Let _lhs_ be ? ResolveBinding(_bindingId_, _environment_).\n  1. Let _v_ be *undefined*.\n  1. If _iteratorRecord_.[[Done]] is *false*, then\n    1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n    1. If _next_ is not ~done~, then\n      1. Set _v_ to _next_.\n  1. If |Initializer| is present and _v_ is *undefined*, then\n    1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then\n      1. Set _v_ to ? NamedEvaluation of |Initializer| with argument _bindingId_.\n    1. Else,\n      1. Let _defaultValue_ be ? the result of evaluating |Initializer|.\n      1. Set _v_ to ? GetValue(_defaultValue_).\n  1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _v_).\n  1. Return ? InitializeReferencedBinding(_lhs_, _v_).","code":"\n        1. Let _bindingId_ be StringValue of |BindingIdentifier|.\n        1. Let _lhs_ be ? ResolveBinding(_bindingId_, _environment_).\n        1. Let _v_ be *undefined*.\n        1. If _iteratorRecord_.[[Done]] is *false*, then\n          1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n          1. If _next_ is not ~done~, then\n            1. Set _v_ to _next_.\n        1. If |Initializer| is present and _v_ is *undefined*, then\n          1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then\n            1. Set _v_ to ? NamedEvaluation of |Initializer| with argument _bindingId_.\n          1. Else,\n            1. Let _defaultValue_ be ? Evaluation of |Initializer|.\n            1. Set _v_ to ? GetValue(_defaultValue_).\n        1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _v_).\n        1. Return ? InitializeReferencedBinding(_lhs_, _v_).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingElement","idx":1,"subIdx":0,"rhsParams":[{"name":"BindingPattern","ty":"Ast[BindingPattern]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"IteratorBindingInitialization","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _v_ be *undefined*.\n  1. If _iteratorRecord_.[[Done]] is *false*, then\n    1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n    1. If _next_ is not ~done~, then\n      1. Set _v_ to _next_.\n  1. If |Initializer| is present and _v_ is *undefined*, then\n    1. Let _defaultValue_ be ? the result of evaluating |Initializer|.\n    1. Set _v_ to ? GetValue(_defaultValue_).\n  1. Return ? BindingInitialization of |BindingPattern| with arguments _v_ and _environment_.","code":"\n        1. Let _v_ be *undefined*.\n        1. If _iteratorRecord_.[[Done]] is *false*, then\n          1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n          1. If _next_ is not ~done~, then\n            1. Set _v_ to _next_.\n        1. If |Initializer| is present and _v_ is *undefined*, then\n          1. Let _defaultValue_ be ? Evaluation of |Initializer|.\n          1. Set _v_ to ? GetValue(_defaultValue_).\n        1. Return ? BindingInitialization of |BindingPattern| with arguments _v_ and _environment_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingElement","idx":1,"subIdx":1,"rhsParams":[{"name":"BindingPattern","ty":"Ast[BindingPattern]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"IteratorBindingInitialization","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _v_ be *undefined*.\n  1. If _iteratorRecord_.[[Done]] is *false*, then\n    1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n    1. If _next_ is not ~done~, then\n      1. Set _v_ to _next_.\n  1. If |Initializer| is present and _v_ is *undefined*, then\n    1. Let _defaultValue_ be ? the result of evaluating |Initializer|.\n    1. Set _v_ to ? GetValue(_defaultValue_).\n  1. Return ? BindingInitialization of |BindingPattern| with arguments _v_ and _environment_.","code":"\n        1. Let _v_ be *undefined*.\n        1. If _iteratorRecord_.[[Done]] is *false*, then\n          1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n          1. If _next_ is not ~done~, then\n            1. Set _v_ to _next_.\n        1. If |Initializer| is present and _v_ is *undefined*, then\n          1. Let _defaultValue_ be ? Evaluation of |Initializer|.\n          1. Set _v_ to ? GetValue(_defaultValue_).\n        1. Return ? BindingInitialization of |BindingPattern| with arguments _v_ and _environment_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingRestElement","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}}]},"methodName":"IteratorBindingInitialization","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _lhs_ be ? ResolveBinding(StringValue of |BindingIdentifier|, _environment_).\n  1. Let _A_ be ! ArrayCreate(0).\n  1. Let _n_ be 0.\n  1. Repeat, \n    1. Let _next_ be ~done~.\n    1. If _iteratorRecord_.[[Done]] is *false*, then\n      1. Set _next_ to ? IteratorStepValue(_iteratorRecord_).\n    1. If _next_ is ~done~, then\n      1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _A_).\n      1. Return ? InitializeReferencedBinding(_lhs_, _A_).\n    1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _next_).\n    1. Set _n_ to _n_ + 1.","code":"\n        1. Let _lhs_ be ? ResolveBinding(StringValue of |BindingIdentifier|, _environment_).\n        1. Let _A_ be ! ArrayCreate(0).\n        1. Let _n_ be 0.\n        1. Repeat,\n          1. Let _next_ be ~done~.\n          1. If _iteratorRecord_.[[Done]] is *false*, then\n            1. Set _next_ to ? IteratorStepValue(_iteratorRecord_).\n          1. If _next_ is ~done~, then\n            1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _A_).\n            1. Return ? InitializeReferencedBinding(_lhs_, _A_).\n          1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _next_).\n          1. Set _n_ to _n_ + 1.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingRestElement","idx":1,"subIdx":0,"rhsParams":[{"name":"BindingPattern","ty":"Ast[BindingPattern]","kind":{"Normal":{}}}]},"methodName":"IteratorBindingInitialization","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _A_ be ! ArrayCreate(0).\n  1. Let _n_ be 0.\n  1. Repeat, \n    1. Let _next_ be ~done~.\n    1. If _iteratorRecord_.[[Done]] is *false*, then\n      1. Set _next_ to ? IteratorStepValue(_iteratorRecord_).\n    1. If _next_ is ~done~, then\n      1. Return ? BindingInitialization of |BindingPattern| with arguments _A_ and _environment_.\n    1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _next_).\n    1. Set _n_ to _n_ + 1.","code":"\n        1. Let _A_ be ! ArrayCreate(0).\n        1. Let _n_ be 0.\n        1. Repeat,\n          1. Let _next_ be ~done~.\n          1. If _iteratorRecord_.[[Done]] is *false*, then\n            1. Set _next_ to ? IteratorStepValue(_iteratorRecord_).\n          1. If _next_ is ~done~, then\n            1. Return ? BindingInitialization of |BindingPattern| with arguments _A_ and _environment_.\n          1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _next_).\n          1. Set _n_ to _n_ + 1.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FormalParameters","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"IteratorBindingInitialization","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Return ~unused~.","code":"\n        1. Return ~unused~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FormalParameters","idx":4,"subIdx":0,"rhsParams":[{"name":"FormalParameterList","ty":"Ast[FormalParameterList]","kind":{"Normal":{}}},{"name":"FunctionRestParameter","ty":"Ast[FunctionRestParameter]","kind":{"Normal":{}}}]},"methodName":"IteratorBindingInitialization","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Perform ? IteratorBindingInitialization of |FormalParameterList| with arguments _iteratorRecord_ and _environment_.\n  1. Return ? IteratorBindingInitialization of |FunctionRestParameter| with arguments _iteratorRecord_ and _environment_.","code":"\n        1. Perform ? IteratorBindingInitialization of |FormalParameterList| with arguments _iteratorRecord_ and _environment_.\n        1. Return ? IteratorBindingInitialization of |FunctionRestParameter| with arguments _iteratorRecord_ and _environment_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FormalParameterList","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameterList","ty":"Ast[FormalParameterList]","kind":{"Normal":{}}},{"name":"FormalParameter","ty":"Ast[FormalParameter]","kind":{"Normal":{}}}]},"methodName":"IteratorBindingInitialization","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Perform ? IteratorBindingInitialization of |FormalParameterList| with arguments _iteratorRecord_ and _environment_.\n  1. Return ? IteratorBindingInitialization of |FormalParameter| with arguments _iteratorRecord_ and _environment_.","code":"\n        1. Perform ? IteratorBindingInitialization of |FormalParameterList| with arguments _iteratorRecord_ and _environment_.\n        1. Return ? IteratorBindingInitialization of |FormalParameter| with arguments _iteratorRecord_ and _environment_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrowParameters","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}}]},"methodName":"IteratorBindingInitialization","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _v_ be *undefined*.\n  1. Assert: _iteratorRecord_.[[Done]] is *false*.\n  1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n  1. If _next_ is not ~done~, then\n    1. Set _v_ to _next_.\n  1. Return ? BindingInitialization of |BindingIdentifier| with arguments _v_ and _environment_.","code":"\n        1. Let _v_ be *undefined*.\n        1. Assert: _iteratorRecord_.[[Done]] is *false*.\n        1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n        1. If _next_ is not ~done~, then\n          1. Set _v_ to _next_.\n        1. Return ? BindingInitialization of |BindingIdentifier| with arguments _v_ and _environment_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrowParameters","idx":1,"subIdx":0,"rhsParams":[{"name":"CoverParenthesizedExpressionAndArrowParameterList","ty":"Ast[CoverParenthesizedExpressionAndArrowParameterList]","kind":{"Normal":{}}}]},"methodName":"IteratorBindingInitialization","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _formals_ be the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n  1. Return ? IteratorBindingInitialization of _formals_ with arguments _iteratorRecord_ and _environment_.","code":"\n        1. Let _formals_ be the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n        1. Return ? IteratorBindingInitialization of _formals_ with arguments _iteratorRecord_ and _environment_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncArrowBindingIdentifier","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}}]},"methodName":"IteratorBindingInitialization","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _v_ be *undefined*.\n  1. Assert: _iteratorRecord_.[[Done]] is *false*.\n  1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n  1. If _next_ is not ~done~, then\n    1. Set _v_ to _next_.\n  1. Return ? BindingInitialization of |BindingIdentifier| with arguments _v_ and _environment_.","code":"\n        1. Let _v_ be *undefined*.\n        1. Assert: _iteratorRecord_.[[Done]] is *false*.\n        1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n        1. If _next_ is not ~done~, then\n          1. Set _v_ to _next_.\n        1. Return ? BindingInitialization of |BindingIdentifier| with arguments _v_ and _environment_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IdentifierReference","idx":0,"subIdx":0,"rhsParams":[{"name":"Identifier","ty":"Ast[Identifier]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. If this |IdentifierReference| is contained in strict mode code and StringValue of |Identifier| is either *\"eval\"* or *\"arguments\"*, return ~invalid~.\n  1. Return ~simple~.","code":"\n        1. If this |IdentifierReference| is contained in strict mode code and StringValue of |Identifier| is either *\"eval\"* or *\"arguments\"*, return ~invalid~.\n        1. Return ~simple~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IdentifierReference","idx":1,"subIdx":0,"rhsParams":[]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~simple~.","code":"\n        1. Return ~simple~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IdentifierReference","idx":2,"subIdx":0,"rhsParams":[]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~simple~.","code":"\n        1. Return ~simple~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CallExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"CallExpression","ty":"Ast[CallExpression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~simple~.","code":"\n        1. Return ~simple~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CallExpression","idx":5,"subIdx":0,"rhsParams":[{"name":"CallExpression","ty":"Ast[CallExpression]","kind":{"Normal":{}}},{"name":"IdentifierName","ty":"Ast[IdentifierName]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~simple~.","code":"\n        1. Return ~simple~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CallExpression","idx":7,"subIdx":0,"rhsParams":[{"name":"CallExpression","ty":"Ast[CallExpression]","kind":{"Normal":{}}},{"name":"PrivateIdentifier","ty":"Ast[PrivateIdentifier]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~simple~.","code":"\n        1. Return ~simple~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~simple~.","code":"\n        1. Return ~simple~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"IdentifierName","ty":"Ast[IdentifierName]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~simple~.","code":"\n        1. Return ~simple~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"SuperProperty","ty":"Ast[SuperProperty]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~simple~.","code":"\n        1. Return ~simple~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":7,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"PrivateIdentifier","ty":"Ast[PrivateIdentifier]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~simple~.","code":"\n        1. Return ~simple~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":12,"subIdx":0,"rhsParams":[{"name":"CoverParenthesizedExpressionAndArrowParameterList","ty":"Ast[CoverParenthesizedExpressionAndArrowParameterList]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Let _expr_ be the |ParenthesizedExpression| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n  1. Return AssignmentTargetType of _expr_.","code":"\n        1. Let _expr_ be the |ParenthesizedExpression| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n        1. Return AssignmentTargetType of _expr_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"Literal","ty":"Ast[Literal]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"ArrayLiteral","ty":"Ast[ArrayLiteral]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"ObjectLiteral","ty":"Ast[ObjectLiteral]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":5,"subIdx":0,"rhsParams":[{"name":"FunctionExpression","ty":"Ast[FunctionExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":6,"subIdx":0,"rhsParams":[{"name":"ClassExpression","ty":"Ast[ClassExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":7,"subIdx":0,"rhsParams":[{"name":"GeneratorExpression","ty":"Ast[GeneratorExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":8,"subIdx":0,"rhsParams":[{"name":"AsyncFunctionExpression","ty":"Ast[AsyncFunctionExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":9,"subIdx":0,"rhsParams":[{"name":"AsyncGeneratorExpression","ty":"Ast[AsyncGeneratorExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":10,"subIdx":0,"rhsParams":[{"name":"RegularExpressionLiteral","ty":"Ast[RegularExpressionLiteral]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":11,"subIdx":0,"rhsParams":[{"name":"TemplateLiteral","ty":"Ast[TemplateLiteral]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CallExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"CoverCallExpressionAndAsyncArrowHead","ty":"Ast[CoverCallExpressionAndAsyncArrowHead]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CallExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"SuperCall","ty":"Ast[SuperCall]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CallExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"ImportCall","ty":"Ast[ImportCall]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CallExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"CallExpression","ty":"Ast[CallExpression]","kind":{"Normal":{}}},{"name":"Arguments","ty":"Ast[Arguments]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CallExpression","idx":6,"subIdx":0,"rhsParams":[{"name":"CallExpression","ty":"Ast[CallExpression]","kind":{"Normal":{}}},{"name":"TemplateLiteral","ty":"Ast[TemplateLiteral]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NewExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"NewExpression","ty":"Ast[NewExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"TemplateLiteral","ty":"Ast[TemplateLiteral]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":6,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"Arguments","ty":"Ast[Arguments]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NewTarget","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ImportMeta","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LeftHandSideExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"OptionalExpression","ty":"Ast[OptionalExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UpdateExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UpdateExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UpdateExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UpdateExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":5,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":6,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":7,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":8,"subIdx":0,"rhsParams":[{"name":"AwaitExpression","ty":"Ast[AwaitExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExponentiationExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"UpdateExpression","ty":"Ast[UpdateExpression]","kind":{"Normal":{}}},{"name":"ExponentiationExpression","ty":"Ast[ExponentiationExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MultiplicativeExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"MultiplicativeExpression","ty":"Ast[MultiplicativeExpression]","kind":{"Normal":{}}},{"name":"MultiplicativeOperator","ty":"Ast[MultiplicativeOperator]","kind":{"Normal":{}}},{"name":"ExponentiationExpression","ty":"Ast[ExponentiationExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AdditiveExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"AdditiveExpression","ty":"Ast[AdditiveExpression]","kind":{"Normal":{}}},{"name":"MultiplicativeExpression","ty":"Ast[MultiplicativeExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AdditiveExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"AdditiveExpression","ty":"Ast[AdditiveExpression]","kind":{"Normal":{}}},{"name":"MultiplicativeExpression","ty":"Ast[MultiplicativeExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ShiftExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}},{"name":"AdditiveExpression","ty":"Ast[AdditiveExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ShiftExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}},{"name":"AdditiveExpression","ty":"Ast[AdditiveExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ShiftExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}},{"name":"AdditiveExpression","ty":"Ast[AdditiveExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RelationalExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}},{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RelationalExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}},{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RelationalExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}},{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RelationalExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}},{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RelationalExpression","idx":5,"subIdx":0,"rhsParams":[{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}},{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RelationalExpression","idx":6,"subIdx":0,"rhsParams":[{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}},{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RelationalExpression","idx":7,"subIdx":0,"rhsParams":[{"name":"PrivateIdentifier","ty":"Ast[PrivateIdentifier]","kind":{"Normal":{}}},{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"EqualityExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"EqualityExpression","ty":"Ast[EqualityExpression]","kind":{"Normal":{}}},{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"EqualityExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"EqualityExpression","ty":"Ast[EqualityExpression]","kind":{"Normal":{}}},{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"EqualityExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"EqualityExpression","ty":"Ast[EqualityExpression]","kind":{"Normal":{}}},{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"EqualityExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"EqualityExpression","ty":"Ast[EqualityExpression]","kind":{"Normal":{}}},{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BitwiseANDExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"BitwiseANDExpression","ty":"Ast[BitwiseANDExpression]","kind":{"Normal":{}}},{"name":"EqualityExpression","ty":"Ast[EqualityExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BitwiseXORExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"BitwiseXORExpression","ty":"Ast[BitwiseXORExpression]","kind":{"Normal":{}}},{"name":"BitwiseANDExpression","ty":"Ast[BitwiseANDExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BitwiseORExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"BitwiseORExpression","ty":"Ast[BitwiseORExpression]","kind":{"Normal":{}}},{"name":"BitwiseXORExpression","ty":"Ast[BitwiseXORExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LogicalANDExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"LogicalANDExpression","ty":"Ast[LogicalANDExpression]","kind":{"Normal":{}}},{"name":"BitwiseORExpression","ty":"Ast[BitwiseORExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LogicalORExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"LogicalORExpression","ty":"Ast[LogicalORExpression]","kind":{"Normal":{}}},{"name":"LogicalANDExpression","ty":"Ast[LogicalANDExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CoalesceExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"CoalesceExpressionHead","ty":"Ast[CoalesceExpressionHead]","kind":{"Normal":{}}},{"name":"BitwiseORExpression","ty":"Ast[BitwiseORExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ConditionalExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"ShortCircuitExpression","ty":"Ast[ShortCircuitExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"YieldExpression","ty":"Ast[YieldExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"ArrowFunction","ty":"Ast[ArrowFunction]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"AsyncArrowFunction","ty":"Ast[AsyncArrowFunction]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentExpression","idx":5,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentOperator","ty":"Ast[AssignmentOperator]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentExpression","idx":6,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentExpression","idx":7,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentExpression","idx":8,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Expression","idx":1,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"AssignmentTargetType","isStatic":true,"withParams":[],"retTy":"Enum[~invalid~, ~simple~]"}},"body":"\n  1. Return ~invalid~.","code":"\n        1. Return ~invalid~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PropertyDefinition","idx":0,"subIdx":0,"rhsParams":[{"name":"IdentifierReference","ty":"Ast[IdentifierReference]","kind":{"Normal":{}}}]},"methodName":"PropName","isStatic":true,"withParams":[],"retTy":"Enum[~empty~] | String"}},"body":"\n  1. Return StringValue of |IdentifierReference|.","code":"\n        1. Return StringValue of |IdentifierReference|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PropertyDefinition","idx":4,"subIdx":0,"rhsParams":[{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"PropName","isStatic":true,"withParams":[],"retTy":"Enum[~empty~] | String"}},"body":"\n  1. Return ~empty~.","code":"\n        1. Return ~empty~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PropertyDefinition","idx":2,"subIdx":0,"rhsParams":[{"name":"PropertyName","ty":"Ast[PropertyName]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"PropName","isStatic":true,"withParams":[],"retTy":"Enum[~empty~] | String"}},"body":"\n  1. Return PropName of |PropertyName|.","code":"\n        1. Return PropName of |PropertyName|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LiteralPropertyName","idx":0,"subIdx":0,"rhsParams":[{"name":"IdentifierName","ty":"Ast[IdentifierName]","kind":{"Normal":{}}}]},"methodName":"PropName","isStatic":true,"withParams":[],"retTy":"Enum[~empty~] | String"}},"body":"\n  1. Return StringValue of |IdentifierName|.","code":"\n        1. Return StringValue of |IdentifierName|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LiteralPropertyName","idx":1,"subIdx":0,"rhsParams":[{"name":"StringLiteral","ty":"Ast[StringLiteral]","kind":{"Normal":{}}}]},"methodName":"PropName","isStatic":true,"withParams":[],"retTy":"Enum[~empty~] | String"}},"body":"\n  1. Return SV of |StringLiteral|.","code":"\n        1. Return the SV of |StringLiteral|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LiteralPropertyName","idx":2,"subIdx":0,"rhsParams":[{"name":"NumericLiteral","ty":"Ast[NumericLiteral]","kind":{"Normal":{}}}]},"methodName":"PropName","isStatic":true,"withParams":[],"retTy":"Enum[~empty~] | String"}},"body":"\n  1. Let _nbr_ be NumericValue of |NumericLiteral|.\n  1. Return ! ToString(_nbr_).","code":"\n        1. Let _nbr_ be the NumericValue of |NumericLiteral|.\n        1. Return ! ToString(_nbr_).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ComputedPropertyName","idx":0,"subIdx":0,"rhsParams":[{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"PropName","isStatic":true,"withParams":[],"retTy":"Enum[~empty~] | String"}},"body":"\n  1. Return ~empty~.","code":"\n        1. Return ~empty~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MethodDefinition","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"UniqueFormalParameters","ty":"Ast[UniqueFormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"PropName","isStatic":true,"withParams":[],"retTy":"Enum[~empty~] | String"}},"body":"\n  1. Return PropName of |ClassElementName|.","code":"\n        1. Return PropName of |ClassElementName|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MethodDefinition","idx":4,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"PropName","isStatic":true,"withParams":[],"retTy":"Enum[~empty~] | String"}},"body":"\n  1. Return PropName of |ClassElementName|.","code":"\n        1. Return PropName of |ClassElementName|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MethodDefinition","idx":5,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"PropertySetParameterList","ty":"Ast[PropertySetParameterList]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"PropName","isStatic":true,"withParams":[],"retTy":"Enum[~empty~] | String"}},"body":"\n  1. Return PropName of |ClassElementName|.","code":"\n        1. Return PropName of |ClassElementName|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorMethod","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"UniqueFormalParameters","ty":"Ast[UniqueFormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"PropName","isStatic":true,"withParams":[],"retTy":"Enum[~empty~] | String"}},"body":"\n  1. Return PropName of |ClassElementName|.","code":"\n        1. Return PropName of |ClassElementName|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorMethod","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"UniqueFormalParameters","ty":"Ast[UniqueFormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"PropName","isStatic":true,"withParams":[],"retTy":"Enum[~empty~] | String"}},"body":"\n  1. Return PropName of |ClassElementName|.","code":"\n        1. Return PropName of |ClassElementName|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElement","idx":4,"subIdx":0,"rhsParams":[{"name":"ClassStaticBlock","ty":"Ast[ClassStaticBlock]","kind":{"Normal":{}}}]},"methodName":"PropName","isStatic":true,"withParams":[],"retTy":"Enum[~empty~] | String"}},"body":"\n  1. Return ~empty~.","code":"\n        1. Return ~empty~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElement","idx":5,"subIdx":0,"rhsParams":[]},"methodName":"PropName","isStatic":true,"withParams":[],"retTy":"Enum[~empty~] | String"}},"body":"\n  1. Return ~empty~.","code":"\n        1. Return ~empty~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncMethod","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"UniqueFormalParameters","ty":"Ast[UniqueFormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"PropName","isStatic":true,"withParams":[],"retTy":"Enum[~empty~] | String"}},"body":"\n  1. Return PropName of |ClassElementName|.","code":"\n        1. Return PropName of |ClassElementName|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FieldDefinition","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"PropName","isStatic":true,"withParams":[],"retTy":"Enum[~empty~] | String"}},"body":"\n  1. Return PropName of |ClassElementName|.","code":"\n        1. Return PropName of |ClassElementName|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FieldDefinition","idx":0,"subIdx":1,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"PropName","isStatic":true,"withParams":[],"retTy":"Enum[~empty~] | String"}},"body":"\n  1. Return PropName of |ClassElementName|.","code":"\n        1. Return PropName of |ClassElementName|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElementName","idx":1,"subIdx":0,"rhsParams":[{"name":"PrivateIdentifier","ty":"Ast[PrivateIdentifier]","kind":{"Normal":{}}}]},"methodName":"PropName","isStatic":true,"withParams":[],"retTy":"Enum[~empty~] | String"}},"body":"\n  1. Return ~empty~.","code":"\n        1. Return ~empty~.\n      "},{"head":{"ConcreteMethodHead":{"concMethodName":"HasBinding","receiver":{"name":"envRec","ty":"Record[DeclarativeEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"N","ty":"String","kind":{"Normal":{}}}],"retTy":"Normal[Boolean]"}},"body":"\n  1. If _envRec_ has a binding for _N_, return *true*.\n  1. Return *false*.","code":"\n            1. If _envRec_ has a binding for _N_, return *true*.\n            1. Return *false*.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"CreateMutableBinding","receiver":{"name":"envRec","ty":"Record[DeclarativeEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"N","ty":"String","kind":{"Normal":{}}},{"name":"D","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]]"}},"body":"\n  1. Assert: _envRec_ does not already have a binding for _N_..\n  1. Create a mutable binding in _envRec_ for _N_ and record that it is uninitialized. If _D_ is *true*, record that the newly created binding may be deleted by a subsequent DeleteBinding call.\n  1. Return ~unused~.","code":"\n            1. Assert: _envRec_ does not already have a binding for _N_.\n            1. Create a mutable binding in _envRec_ for _N_ and record that it is uninitialized. If _D_ is *true*, record that the newly created binding may be deleted by a subsequent DeleteBinding call.\n            1. Return ~unused~.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"CreateImmutableBinding","receiver":{"name":"envRec","ty":"Record[DeclarativeEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"N","ty":"String","kind":{"Normal":{}}},{"name":"S","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]]"}},"body":"\n  1. Assert: _envRec_ does not already have a binding for _N_..\n  1. Create an immutable binding in _envRec_ for _N_ and record that it is uninitialized. If _S_ is *true*, record that the newly created binding is a strict binding.\n  1. Return ~unused~.","code":"\n            1. Assert: _envRec_ does not already have a binding for _N_.\n            1. Create an immutable binding in _envRec_ for _N_ and record that it is uninitialized. If _S_ is *true*, record that the newly created binding is a strict binding.\n            1. Return ~unused~.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"InitializeBinding","receiver":{"name":"envRec","ty":"Record[DeclarativeEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"N","ty":"String","kind":{"Normal":{}}},{"name":"V","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]]"}},"body":"\n  1. Assert: _envRec_ must have an uninitialized binding for _N_..\n  1. Set the bound value for _N_ in _envRec_ to _V_.\n  1. <emu-not-ref>Record</emu-not-ref> that the binding for _N_ in _envRec_ has been initialized.\n  1. Return ~unused~.","code":"\n            1. Assert: _envRec_ must have an uninitialized binding for _N_.\n            1. Set the bound value for _N_ in _envRec_ to _V_.\n            1. <emu-not-ref>Record</emu-not-ref> that the binding for _N_ in _envRec_ has been initialized.\n            1. Return ~unused~.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"SetMutableBinding","receiver":{"name":"envRec","ty":"Record[DeclarativeEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"N","ty":"String","kind":{"Normal":{}}},{"name":"V","ty":"ESValue","kind":{"Normal":{}}},{"name":"S","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. [id=\"step-setmutablebinding-missing-binding\"] If _envRec_ does not have a binding for _N_, then\n    1. If _S_ is *true*, throw a *ReferenceError* exception.\n    1. Perform ! _envRec_.CreateMutableBinding(_N_, *true*).\n    1. Perform ! _envRec_.InitializeBinding(_N_, _V_).\n    1. Return ~unused~.\n  1. If _envRec_the binding for _N_ in.[[strict]] is *true*, set _S_ to *true*.\n  1. If _envRec_the binding for _N_ in.[[initialized]] is not *true*, then\n    1. Throw a *ReferenceError* exception.\n  1. Else if _envRec_the binding for _N_ in is a Record[MutableBinding], then\n    1. Change its bound value to _V_.\n  1. Else,\n    1. Assert: This is an attempt to change the value of an immutable binding..\n    1. If _S_ is *true*, throw a *TypeError* exception.\n  1. Return ~unused~.","code":"\n            1. [id=\"step-setmutablebinding-missing-binding\"] If _envRec_ does not have a binding for _N_, then\n              1. If _S_ is *true*, throw a *ReferenceError* exception.\n              1. Perform ! _envRec_.CreateMutableBinding(_N_, *true*).\n              1. Perform ! _envRec_.InitializeBinding(_N_, _V_).\n              1. Return ~unused~.\n            1. If the binding for _N_ in _envRec_ is a strict binding, set _S_ to *true*.\n            1. If the binding for _N_ in _envRec_ has not yet been initialized, then\n              1. Throw a *ReferenceError* exception.\n            1. Else if the binding for _N_ in _envRec_ is a mutable binding, then\n              1. Change its bound value to _V_.\n            1. Else,\n              1. Assert: This is an attempt to change the value of an immutable binding.\n              1. If _S_ is *true*, throw a *TypeError* exception.\n            1. Return ~unused~.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"GetBindingValue","receiver":{"name":"envRec","ty":"Record[DeclarativeEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"N","ty":"String","kind":{"Normal":{}}},{"name":"S","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Assert: _envRec_ has a binding for _N_.\n  1. If the binding for _N_ in _envRec_ is an uninitialized binding, throw a *ReferenceError* exception.\n  1. Return the value currently bound to _N_ in _envRec_.","code":"\n            1. Assert: _envRec_ has a binding for _N_.\n            1. If the binding for _N_ in _envRec_ is an uninitialized binding, throw a *ReferenceError* exception.\n            1. Return the value currently bound to _N_ in _envRec_.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"DeleteBinding","receiver":{"name":"envRec","ty":"Record[DeclarativeEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"N","ty":"String","kind":{"Normal":{}}}],"retTy":"Normal[Boolean]"}},"body":"\n  1. Assert: _envRec_ has a binding for _N_.\n  1. If the binding for _N_ in _envRec_ cannot be deleted, return *false*.\n  1. Remove the binding for _N_ from _envRec_.\n  1. Return *true*.","code":"\n            1. Assert: _envRec_ has a binding for _N_.\n            1. If the binding for _N_ in _envRec_ cannot be deleted, return *false*.\n            1. Remove the binding for _N_ from _envRec_.\n            1. Return *true*.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"HasThisBinding","receiver":{"name":"envRec","ty":"Record[DeclarativeEnvironmentRecord]","kind":{"Normal":{}}},"params":[],"retTy":"False"}},"body":"\n  1. Return *false*.","code":"\n            1. Return *false*.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"HasSuperBinding","receiver":{"name":"envRec","ty":"Record[DeclarativeEnvironmentRecord]","kind":{"Normal":{}}},"params":[],"retTy":"False"}},"body":"\n  1. Return *false*.","code":"\n            1. Return *false*.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"WithBaseObject","receiver":{"name":"envRec","ty":"Record[DeclarativeEnvironmentRecord]","kind":{"Normal":{}}},"params":[],"retTy":"Undefined"}},"body":"\n  1. Return *undefined*.","code":"\n            1. Return *undefined*.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"HasBinding","receiver":{"name":"envRec","ty":"Record[ObjectEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"N","ty":"String","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Let _bindingObject_ be _envRec_.[[BindingObject]].\n  1. Let _foundBinding_ be ? HasProperty(_bindingObject_, _N_).\n  1. If _foundBinding_ is *false*, return *false*.\n  1. If _envRec_.[[IsWithEnvironment]] is *false*, return *true*.\n  1. Let _unscopables_ be ? Get(_bindingObject_, @@unscopables).\n  1. If _unscopables_ is a Record[Object], then\n    1. Let _blocked_ be ToBoolean(? Get(_unscopables_, _N_)).\n    1. If _blocked_ is *true*, return *false*.\n  1. Return *true*.","code":"\n            1. Let _bindingObject_ be _envRec_.[[BindingObject]].\n            1. Let _foundBinding_ be ? HasProperty(_bindingObject_, _N_).\n            1. If _foundBinding_ is *false*, return *false*.\n            1. If _envRec_.[[IsWithEnvironment]] is *false*, return *true*.\n            1. Let _unscopables_ be ? Get(_bindingObject_, @@unscopables).\n            1. If _unscopables_ is an Object, then\n              1. Let _blocked_ be ToBoolean(? Get(_unscopables_, _N_)).\n              1. If _blocked_ is *true*, return *false*.\n            1. Return *true*.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"CreateMutableBinding","receiver":{"name":"envRec","ty":"Record[ObjectEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"N","ty":"String","kind":{"Normal":{}}},{"name":"D","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Let _bindingObject_ be _envRec_.[[BindingObject]].\n  1. Perform ? DefinePropertyOrThrow(_bindingObject_, _N_, PropertyDescriptor { [[Value]]: *undefined*, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: _D_ }).\n  1. Return ~unused~.","code":"\n            1. Let _bindingObject_ be _envRec_.[[BindingObject]].\n            1. Perform ? DefinePropertyOrThrow(_bindingObject_, _N_, PropertyDescriptor { [[Value]]: *undefined*, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: _D_ }).\n            1. Return ~unused~.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"InitializeBinding","receiver":{"name":"envRec","ty":"Record[ObjectEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"N","ty":"String","kind":{"Normal":{}}},{"name":"V","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Perform ? _envRec_.SetMutableBinding(_N_, _V_, *false*).\n  1. Return ~unused~.","code":"\n            1. Perform ? <emu-meta effects=\"user-code\">_envRec_.SetMutableBinding</emu-meta>(_N_, _V_, *false*).\n            1. Return ~unused~.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"SetMutableBinding","receiver":{"name":"envRec","ty":"Record[ObjectEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"N","ty":"String","kind":{"Normal":{}}},{"name":"V","ty":"ESValue","kind":{"Normal":{}}},{"name":"S","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Let _bindingObject_ be _envRec_.[[BindingObject]].\n  1. Let _stillExists_ be ? HasProperty(_bindingObject_, _N_).\n  1. If _stillExists_ is *false* and _S_ is *true*, throw a *ReferenceError* exception.\n  1. Perform ? Set(_bindingObject_, _N_, _V_, _S_).\n  1. Return ~unused~.","code":"\n            1. Let _bindingObject_ be _envRec_.[[BindingObject]].\n            1. Let _stillExists_ be ? HasProperty(_bindingObject_, _N_).\n            1. If _stillExists_ is *false* and _S_ is *true*, throw a *ReferenceError* exception.\n            1. Perform ? Set(_bindingObject_, _N_, _V_, _S_).\n            1. Return ~unused~.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"GetBindingValue","receiver":{"name":"envRec","ty":"Record[ObjectEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"N","ty":"String","kind":{"Normal":{}}},{"name":"S","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Let _bindingObject_ be _envRec_.[[BindingObject]].\n  1. Let _value_ be ? HasProperty(_bindingObject_, _N_).\n  1. If _value_ is *false*, then\n    1. If _S_ is *false*, return *undefined*.\n    1. Else, throw a *ReferenceError* exception.\n  1. Return ? Get(_bindingObject_, _N_).","code":"\n            1. Let _bindingObject_ be _envRec_.[[BindingObject]].\n            1. Let _value_ be ? HasProperty(_bindingObject_, _N_).\n            1. If _value_ is *false*, then\n              1. If _S_ is *false*, return *undefined*; otherwise throw a *ReferenceError* exception.\n            1. Return ? Get(_bindingObject_, _N_).\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"DeleteBinding","receiver":{"name":"envRec","ty":"Record[ObjectEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"N","ty":"String","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Let _bindingObject_ be _envRec_.[[BindingObject]].\n  1. Return ? _bindingObject_.[[Delete]](_N_).","code":"\n            1. Let _bindingObject_ be _envRec_.[[BindingObject]].\n            1. Return ? <emu-meta effects=\"user-code\">_bindingObject_.[[Delete]]</emu-meta>(_N_).\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"HasThisBinding","receiver":{"name":"envRec","ty":"Record[ObjectEnvironmentRecord]","kind":{"Normal":{}}},"params":[],"retTy":"False"}},"body":"\n  1. Return *false*.","code":"\n            1. Return *false*.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"HasSuperBinding","receiver":{"name":"envRec","ty":"Record[ObjectEnvironmentRecord]","kind":{"Normal":{}}},"params":[],"retTy":"False"}},"body":"\n  1. Return *false*.","code":"\n            1. Return *false*.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"WithBaseObject","receiver":{"name":"envRec","ty":"Record[ObjectEnvironmentRecord]","kind":{"Normal":{}}},"params":[],"retTy":"Record[Object] | Undefined"}},"body":"\n  1. If _envRec_.[[IsWithEnvironment]] is *true*, return _envRec_.[[BindingObject]].\n  1. Else, return *undefined*.","code":"\n            1. If _envRec_.[[IsWithEnvironment]] is *true*, return _envRec_.[[BindingObject]].\n            1. Otherwise, return *undefined*.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"BindThisValue","receiver":{"name":"envRec","ty":"Record[FunctionEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"V","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Assert: _envRec_.[[ThisBindingStatus]] is not ~lexical~.\n  1. If _envRec_.[[ThisBindingStatus]] is ~initialized~, throw a *ReferenceError* exception.\n  1. Set _envRec_.[[ThisValue]] to _V_.\n  1. Set _envRec_.[[ThisBindingStatus]] to ~initialized~.\n  1. Return _V_.","code":"\n            1. Assert: _envRec_.[[ThisBindingStatus]] is not ~lexical~.\n            1. If _envRec_.[[ThisBindingStatus]] is ~initialized~, throw a *ReferenceError* exception.\n            1. Set _envRec_.[[ThisValue]] to _V_.\n            1. Set _envRec_.[[ThisBindingStatus]] to ~initialized~.\n            1. Return _V_.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"HasThisBinding","receiver":{"name":"envRec","ty":"Record[FunctionEnvironmentRecord]","kind":{"Normal":{}}},"params":[],"retTy":"Boolean"}},"body":"\n  1. If _envRec_.[[ThisBindingStatus]] is ~lexical~, return *false*.\n  1. Else, return *true*.","code":"\n            1. If _envRec_.[[ThisBindingStatus]] is ~lexical~, return *false*; otherwise, return *true*.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"HasSuperBinding","receiver":{"name":"envRec","ty":"Record[FunctionEnvironmentRecord]","kind":{"Normal":{}}},"params":[],"retTy":"Boolean"}},"body":"\n  1. If _envRec_.[[ThisBindingStatus]] is ~lexical~, return *false*.\n  1. If _envRec_.[[FunctionObject]].[[HomeObject]] is *undefined*, return *false*.\n  1. Else, return *true*.","code":"\n            1. If _envRec_.[[ThisBindingStatus]] is ~lexical~, return *false*.\n            1. If _envRec_.[[FunctionObject]].[[HomeObject]] is *undefined*, return *false*; otherwise, return *true*.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"GetThisBinding","receiver":{"name":"envRec","ty":"Record[FunctionEnvironmentRecord]","kind":{"Normal":{}}},"params":[],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Assert: _envRec_.[[ThisBindingStatus]] is not ~lexical~.\n  1. If _envRec_.[[ThisBindingStatus]] is ~uninitialized~, throw a *ReferenceError* exception.\n  1. Return _envRec_.[[ThisValue]].","code":"\n            1. Assert: _envRec_.[[ThisBindingStatus]] is not ~lexical~.\n            1. If _envRec_.[[ThisBindingStatus]] is ~uninitialized~, throw a *ReferenceError* exception.\n            1. Return _envRec_.[[ThisValue]].\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"GetSuperBase","receiver":{"name":"envRec","ty":"Record[FunctionEnvironmentRecord]","kind":{"Normal":{}}},"params":[],"retTy":"Normal[Record[Object] | Undefined | Null] | Throw"}},"body":"\n  1. Let _home_ be _envRec_.[[FunctionObject]].[[HomeObject]].\n  1. If _home_ is *undefined*, return *undefined*.\n  1. Assert: _home_ is a Record[Object].\n  1. Return ? _home_.[[GetPrototypeOf]]().","code":"\n            1. Let _home_ be _envRec_.[[FunctionObject]].[[HomeObject]].\n            1. If _home_ is *undefined*, return *undefined*.\n            1. Assert: _home_ is an Object.\n            1. Return ? <emu-meta effects=\"user-code\">_home_.[[GetPrototypeOf]]</emu-meta>().\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"HasBinding","receiver":{"name":"envRec","ty":"Record[GlobalEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"N","ty":"String","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].\n  1. If ! _DclRec_.HasBinding(_N_) is *true*, return *true*.\n  1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n  1. Return ? _ObjRec_.HasBinding(_N_).","code":"\n            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].\n            1. If ! _DclRec_.HasBinding(_N_) is *true*, return *true*.\n            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n            1. Return ? <emu-meta effects=\"user-code\">_ObjRec_.HasBinding</emu-meta>(_N_).\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"CreateMutableBinding","receiver":{"name":"envRec","ty":"Record[GlobalEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"N","ty":"String","kind":{"Normal":{}}},{"name":"D","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].\n  1. If ! _DclRec_.HasBinding(_N_) is *true*, throw a *TypeError* exception.\n  1. Return ! _DclRec_.CreateMutableBinding(_N_, _D_).","code":"\n            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].\n            1. If ! _DclRec_.HasBinding(_N_) is *true*, throw a *TypeError* exception.\n            1. Return ! _DclRec_.CreateMutableBinding(_N_, _D_).\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"CreateImmutableBinding","receiver":{"name":"envRec","ty":"Record[GlobalEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"N","ty":"String","kind":{"Normal":{}}},{"name":"S","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].\n  1. If ! _DclRec_.HasBinding(_N_) is *true*, throw a *TypeError* exception.\n  1. Return ! _DclRec_.CreateImmutableBinding(_N_, _S_).","code":"\n            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].\n            1. If ! _DclRec_.HasBinding(_N_) is *true*, throw a *TypeError* exception.\n            1. Return ! _DclRec_.CreateImmutableBinding(_N_, _S_).\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"InitializeBinding","receiver":{"name":"envRec","ty":"Record[GlobalEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"N","ty":"String","kind":{"Normal":{}}},{"name":"V","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].\n  1. If ! _DclRec_.HasBinding(_N_) is *true*, then\n    1. Return ! _DclRec_.InitializeBinding(_N_, _V_).\n  1. Assert: If the binding exists, it must be in the Object Environment Record..\n  1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n  1. Return ? _ObjRec_.InitializeBinding(_N_, _V_).","code":"\n            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].\n            1. If ! _DclRec_.HasBinding(_N_) is *true*, then\n              1. Return ! _DclRec_.InitializeBinding(_N_, _V_).\n            1. Assert: If the binding exists, it must be in the Object Environment Record.\n            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n            1. Return ? <emu-meta effects=\"user-code\">_ObjRec_.InitializeBinding</emu-meta>(_N_, _V_).\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"SetMutableBinding","receiver":{"name":"envRec","ty":"Record[GlobalEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"N","ty":"String","kind":{"Normal":{}}},{"name":"V","ty":"ESValue","kind":{"Normal":{}}},{"name":"S","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].\n  1. If ! _DclRec_.HasBinding(_N_) is *true*, then\n    1. Return ? _DclRec_.SetMutableBinding(_N_, _V_, _S_).\n  1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n  1. Return ? _ObjRec_.SetMutableBinding(_N_, _V_, _S_).","code":"\n            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].\n            1. If ! _DclRec_.HasBinding(_N_) is *true*, then\n              1. Return ? _DclRec_.SetMutableBinding(_N_, _V_, _S_).\n            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n            1. Return ? <emu-meta effects=\"user-code\">_ObjRec_.SetMutableBinding</emu-meta>(_N_, _V_, _S_).\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"GetBindingValue","receiver":{"name":"envRec","ty":"Record[GlobalEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"N","ty":"String","kind":{"Normal":{}}},{"name":"S","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].\n  1. If ! _DclRec_.HasBinding(_N_) is *true*, then\n    1. Return ? _DclRec_.GetBindingValue(_N_, _S_).\n  1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n  1. Return ? _ObjRec_.GetBindingValue(_N_, _S_).","code":"\n            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].\n            1. If ! _DclRec_.HasBinding(_N_) is *true*, then\n              1. Return ? _DclRec_.GetBindingValue(_N_, _S_).\n            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n            1. Return ? <emu-meta effects=\"user-code\">_ObjRec_.GetBindingValue</emu-meta>(_N_, _S_).\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"DeleteBinding","receiver":{"name":"envRec","ty":"Record[GlobalEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"N","ty":"String","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].\n  1. If ! _DclRec_.HasBinding(_N_) is *true*, then\n    1. Return ! _DclRec_.DeleteBinding(_N_).\n  1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n  1. Let _globalObject_ be _ObjRec_.[[BindingObject]].\n  1. Let _existingProp_ be ? HasOwnProperty(_globalObject_, _N_).\n  1. If _existingProp_ is *true*, then\n    1. Let _status_ be ? _ObjRec_.DeleteBinding(_N_).\n    1. If _status_ is *true* and _envRec_.[[VarNames]] contains _N_, then\n      1. Remove _N_ from _envRec_.[[VarNames]].\n    1. Return _status_.\n  1. Return *true*.","code":"\n            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].\n            1. If ! _DclRec_.HasBinding(_N_) is *true*, then\n              1. Return ! _DclRec_.DeleteBinding(_N_).\n            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n            1. Let _globalObject_ be _ObjRec_.[[BindingObject]].\n            1. Let _existingProp_ be ? HasOwnProperty(_globalObject_, _N_).\n            1. If _existingProp_ is *true*, then\n              1. Let _status_ be ? <emu-meta effects=\"user-code\">_ObjRec_.DeleteBinding</emu-meta>(_N_).\n              1. If _status_ is *true* and _envRec_.[[VarNames]] contains _N_, then\n                1. Remove _N_ from _envRec_.[[VarNames]].\n              1. Return _status_.\n            1. Return *true*.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"HasThisBinding","receiver":{"name":"envRec","ty":"Record[GlobalEnvironmentRecord]","kind":{"Normal":{}}},"params":[],"retTy":"True"}},"body":"\n  1. Return *true*.","code":"\n            1. Return *true*.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"HasSuperBinding","receiver":{"name":"envRec","ty":"Record[GlobalEnvironmentRecord]","kind":{"Normal":{}}},"params":[],"retTy":"False"}},"body":"\n  1. Return *false*.","code":"\n            1. Return *false*.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"WithBaseObject","receiver":{"name":"envRec","ty":"Record[GlobalEnvironmentRecord]","kind":{"Normal":{}}},"params":[],"retTy":"Undefined"}},"body":"\n  1. Return *undefined*.","code":"\n            1. Return *undefined*.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"GetThisBinding","receiver":{"name":"envRec","ty":"Record[GlobalEnvironmentRecord]","kind":{"Normal":{}}},"params":[],"retTy":"Normal[Record[Object]]"}},"body":"\n  1. Return _envRec_.[[GlobalThisValue]].","code":"\n            1. Return _envRec_.[[GlobalThisValue]].\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"HasVarDeclaration","receiver":{"name":"envRec","ty":"Record[GlobalEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"N","ty":"String","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _varDeclaredNames_ be _envRec_.[[VarNames]].\n  1. If _varDeclaredNames_ contains _N_, return *true*.\n  1. Return *false*.","code":"\n            1. Let _varDeclaredNames_ be _envRec_.[[VarNames]].\n            1. If _varDeclaredNames_ contains _N_, return *true*.\n            1. Return *false*.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"HasLexicalDeclaration","receiver":{"name":"envRec","ty":"Record[GlobalEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"N","ty":"String","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].\n  1. Return ! _DclRec_.HasBinding(_N_).","code":"\n            1. Let _DclRec_ be _envRec_.[[DeclarativeRecord]].\n            1. Return ! _DclRec_.HasBinding(_N_).\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"HasRestrictedGlobalProperty","receiver":{"name":"envRec","ty":"Record[GlobalEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"N","ty":"String","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n  1. Let _globalObject_ be _ObjRec_.[[BindingObject]].\n  1. Let _existingProp_ be ? _globalObject_.[[GetOwnProperty]](_N_).\n  1. If _existingProp_ is *undefined*, return *false*.\n  1. If _existingProp_.[[Configurable]] is *true*, return *false*.\n  1. Return *true*.","code":"\n            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n            1. Let _globalObject_ be _ObjRec_.[[BindingObject]].\n            1. Let _existingProp_ be ? <emu-meta effects=\"user-code\">_globalObject_.[[GetOwnProperty]]</emu-meta>(_N_).\n            1. If _existingProp_ is *undefined*, return *false*.\n            1. If _existingProp_.[[Configurable]] is *true*, return *false*.\n            1. Return *true*.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"CanDeclareGlobalVar","receiver":{"name":"envRec","ty":"Record[GlobalEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"N","ty":"String","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n  1. Let _globalObject_ be _ObjRec_.[[BindingObject]].\n  1. Let _hasProperty_ be ? HasOwnProperty(_globalObject_, _N_).\n  1. If _hasProperty_ is *true*, return *true*.\n  1. Return ? IsExtensible(_globalObject_).","code":"\n            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n            1. Let _globalObject_ be _ObjRec_.[[BindingObject]].\n            1. Let _hasProperty_ be ? HasOwnProperty(_globalObject_, _N_).\n            1. If _hasProperty_ is *true*, return *true*.\n            1. Return ? IsExtensible(_globalObject_).\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"CanDeclareGlobalFunction","receiver":{"name":"envRec","ty":"Record[GlobalEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"N","ty":"String","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n  1. Let _globalObject_ be _ObjRec_.[[BindingObject]].\n  1. Let _existingProp_ be ? _globalObject_.[[GetOwnProperty]](_N_).\n  1. If _existingProp_ is *undefined*, return ? IsExtensible(_globalObject_).\n  1. If _existingProp_.[[Configurable]] is *true*, return *true*.\n  1. If IsDataDescriptor(_existingProp_) is *true* and _existingProp_ has attribute values { [[Writable]]: *true*, [[Enumerable]]: *true* }, return *true*.\n  1. Return *false*.","code":"\n            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n            1. Let _globalObject_ be _ObjRec_.[[BindingObject]].\n            1. Let _existingProp_ be ? <emu-meta effects=\"user-code\">_globalObject_.[[GetOwnProperty]]</emu-meta>(_N_).\n            1. If _existingProp_ is *undefined*, return ? IsExtensible(_globalObject_).\n            1. If _existingProp_.[[Configurable]] is *true*, return *true*.\n            1. If IsDataDescriptor(_existingProp_) is *true* and _existingProp_ has attribute values { [[Writable]]: *true*, [[Enumerable]]: *true* }, return *true*.\n            1. Return *false*.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"CreateGlobalVarBinding","receiver":{"name":"envRec","ty":"Record[GlobalEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"N","ty":"String","kind":{"Normal":{}}},{"name":"D","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n  1. Let _globalObject_ be _ObjRec_.[[BindingObject]].\n  1. Let _hasProperty_ be ? HasOwnProperty(_globalObject_, _N_).\n  1. Let _extensible_ be ? IsExtensible(_globalObject_).\n  1. If _hasProperty_ is *false* and _extensible_ is *true*, then\n    1. Perform ? _ObjRec_.CreateMutableBinding(_N_, _D_).\n    1. Perform ? _ObjRec_.InitializeBinding(_N_, *undefined*).\n  1. If _envRec_.[[VarNames]] does not contain _N_, then\n    1. Append _N_ to _envRec_.[[VarNames]].\n  1. Return ~unused~.","code":"\n            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n            1. Let _globalObject_ be _ObjRec_.[[BindingObject]].\n            1. Let _hasProperty_ be ? HasOwnProperty(_globalObject_, _N_).\n            1. Let _extensible_ be ? IsExtensible(_globalObject_).\n            1. If _hasProperty_ is *false* and _extensible_ is *true*, then\n              1. Perform ? <emu-meta effects=\"user-code\">_ObjRec_.CreateMutableBinding</emu-meta>(_N_, _D_).\n              1. Perform ? <emu-meta effects=\"user-code\">_ObjRec_.InitializeBinding</emu-meta>(_N_, *undefined*).\n            1. If _envRec_.[[VarNames]] does not contain _N_, then\n              1. Append _N_ to _envRec_.[[VarNames]].\n            1. Return ~unused~.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"CreateGlobalFunctionBinding","receiver":{"name":"envRec","ty":"Record[GlobalEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"N","ty":"String","kind":{"Normal":{}}},{"name":"V","ty":"ESValue","kind":{"Normal":{}}},{"name":"D","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n  1. Let _globalObject_ be _ObjRec_.[[BindingObject]].\n  1. Let _existingProp_ be ? _globalObject_.[[GetOwnProperty]](_N_).\n  1. If _existingProp_ is *undefined* or _existingProp_.[[Configurable]] is *true*, then\n    1. Let _desc_ be PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: _D_ }.\n  1. Else,\n    1. Let _desc_ be PropertyDescriptor { [[Value]]: _V_ }.\n  1. Perform ? DefinePropertyOrThrow(_globalObject_, _N_, _desc_).\n  1. [id=\"step-createglobalfunctionbinding-set\"] Perform ? Set(_globalObject_, _N_, _V_, *false*).\n  1. If _envRec_.[[VarNames]] does not contain _N_, then\n    1. Append _N_ to _envRec_.[[VarNames]].\n  1. Return ~unused~.","code":"\n            1. Let _ObjRec_ be _envRec_.[[ObjectRecord]].\n            1. Let _globalObject_ be _ObjRec_.[[BindingObject]].\n            1. Let _existingProp_ be ? <emu-meta effects=\"user-code\">_globalObject_.[[GetOwnProperty]]</emu-meta>(_N_).\n            1. If _existingProp_ is *undefined* or _existingProp_.[[Configurable]] is *true*, then\n              1. Let _desc_ be the PropertyDescriptor { [[Value]]: _V_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: _D_ }.\n            1. Else,\n              1. Let _desc_ be the PropertyDescriptor { [[Value]]: _V_ }.\n            1. Perform ? DefinePropertyOrThrow(_globalObject_, _N_, _desc_).\n            1. [id=\"step-createglobalfunctionbinding-set\"] Perform ? Set(_globalObject_, _N_, _V_, *false*).\n            1. If _envRec_.[[VarNames]] does not contain _N_, then\n              1. Append _N_ to _envRec_.[[VarNames]].\n            1. Return ~unused~.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"GetBindingValue","receiver":{"name":"envRec","ty":"Record[ModuleEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"N","ty":"String","kind":{"Normal":{}}},{"name":"S","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Assert: _S_ is *true*.\n  1. Assert: _envRec_ has a binding for _N_.\n  1. If the binding for _N_ is an indirect binding, then\n    1. Let _M_ and _N2_ be the indirection values provided when this binding for _N_ was created.\n    1. Let _targetEnv_ be _M_.[[Environment]].\n    1. If _targetEnv_ is ~empty~, throw a *ReferenceError* exception.\n    1. Return ? _targetEnv_.GetBindingValue(_N2_, *true*).\n  1. If the binding for _N_ in _envRec_ is an uninitialized binding, throw a *ReferenceError* exception.\n  1. Return the value currently bound to _N_ in _envRec_.","code":"\n            1. Assert: _S_ is *true*.\n            1. Assert: _envRec_ has a binding for _N_.\n            1. If the binding for _N_ is an indirect binding, then\n              1. Let _M_ and _N2_ be the indirection values provided when this binding for _N_ was created.\n              1. Let _targetEnv_ be _M_.[[Environment]].\n              1. If _targetEnv_ is ~empty~, throw a *ReferenceError* exception.\n              1. Return ? <emu-meta effects=\"user-code\">_targetEnv_.GetBindingValue</emu-meta>(_N2_, *true*).\n            1. If the binding for _N_ in _envRec_ is an uninitialized binding, throw a *ReferenceError* exception.\n            1. Return the value currently bound to _N_ in _envRec_.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"HasThisBinding","receiver":{"name":"envRec","ty":"Record[ModuleEnvironmentRecord]","kind":{"Normal":{}}},"params":[],"retTy":"True"}},"body":"\n  1. Return *true*.","code":"\n            1. Return *true*.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"GetThisBinding","receiver":{"name":"envRec","ty":"Record[ModuleEnvironmentRecord]","kind":{"Normal":{}}},"params":[],"retTy":"Normal[Undefined]"}},"body":"\n  1. Return *undefined*.","code":"\n            1. Return *undefined*.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"CreateImportBinding","receiver":{"name":"envRec","ty":"Record[ModuleEnvironmentRecord]","kind":{"Normal":{}}},"params":[{"name":"N","ty":"String","kind":{"Normal":{}}},{"name":"M","ty":"Record[ModuleRecord]","kind":{"Normal":{}}},{"name":"N2","ty":"String","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Assert: _envRec_ does not already have a binding for _N_..\n  1. Assert: When _M_.[[Environment]] is instantiated, it will have a direct binding for _N2_..\n  1. Create an immutable indirect binding in _envRec_ for _N_ that references _M_ and _N2_ as its target binding and record that the binding is initialized.\n  1. Return ~unused~.","code":"\n            1. Assert: _envRec_ does not already have a binding for _N_.\n            1. Assert: When _M_.[[Environment]] is instantiated, it will have a direct binding for _N2_.\n            1. Create an immutable indirect binding in _envRec_ for _N_ that references _M_ and _N2_ as its target binding and record that the binding is initialized.\n            1. Return ~unused~.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetIdentifierReference","params":[{"name":"env","ty":"Record[EnvironmentRecord] | Null","kind":{"Normal":{}}},{"name":"name","ty":"String","kind":{"Normal":{}}},{"name":"strict","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[Record[ReferenceRecord]] | Throw"}},"body":"\n  1. If _env_ is *null*, then\n    1. Return Reference Record { [[Base]]: ~unresolvable~, [[ReferencedName]]: _name_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ }.\n  1. Let _exists_ be ? _env_.HasBinding(_name_).\n  1. If _exists_ is *true*, then\n    1. Return Reference Record { [[Base]]: _env_, [[ReferencedName]]: _name_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ }.\n  1. Else,\n    1. Let _outer_ be _env_.[[OuterEnv]].\n    1. Return ? GetIdentifierReference(_outer_, _name_, _strict_).","code":"\n          1. If _env_ is *null*, then\n            1. Return the Reference Record { [[Base]]: ~unresolvable~, [[ReferencedName]]: _name_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ }.\n          1. Let _exists_ be ? <emu-meta effects=\"user-code\">_env_.HasBinding</emu-meta>(_name_).\n          1. If _exists_ is *true*, then\n            1. Return the Reference Record { [[Base]]: _env_, [[ReferencedName]]: _name_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ }.\n          1. Else,\n            1. Let _outer_ be _env_.[[OuterEnv]].\n            1. Return ? GetIdentifierReference(_outer_, _name_, _strict_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"NewDeclarativeEnvironment","params":[{"name":"E","ty":"Record[EnvironmentRecord] | Null","kind":{"Normal":{}}}],"retTy":"Record[DeclarativeEnvironmentRecord]"}},"body":"\n  1. Let _env_ be Declarative Environment Record { }.\n  1. Set _env_.[[OuterEnv]] to _E_.\n  1. Return _env_.","code":"\n          1. Let _env_ be a new Declarative Environment Record containing no bindings.\n          1. Set _env_.[[OuterEnv]] to _E_.\n          1. Return _env_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"NewObjectEnvironment","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"W","ty":"Boolean","kind":{"Normal":{}}},{"name":"E","ty":"Record[EnvironmentRecord] | Null","kind":{"Normal":{}}}],"retTy":"Record[ObjectEnvironmentRecord]"}},"body":"\n  1. Let _env_ be Object Environment Record { }.\n  1. Set _env_.[[BindingObject]] to _O_.\n  1. Set _env_.[[IsWithEnvironment]] to _W_.\n  1. Set _env_.[[OuterEnv]] to _E_.\n  1. Return _env_.","code":"\n          1. Let _env_ be a new Object Environment Record.\n          1. Set _env_.[[BindingObject]] to _O_.\n          1. Set _env_.[[IsWithEnvironment]] to _W_.\n          1. Set _env_.[[OuterEnv]] to _E_.\n          1. Return _env_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"NewFunctionEnvironment","params":[{"name":"F","ty":"Record[ECMAScriptFunctionObject]","kind":{"Normal":{}}},{"name":"newTarget","ty":"Record[Object] | Undefined","kind":{"Normal":{}}}],"retTy":"Record[FunctionEnvironmentRecord]"}},"body":"\n  1. Let _env_ be Function Environment Record { }.\n  1. Set _env_.[[FunctionObject]] to _F_.\n  1. If _F_.[[ThisMode]] is ~lexical~, set _env_.[[ThisBindingStatus]] to ~lexical~.\n  1. Else, set _env_.[[ThisBindingStatus]] to ~uninitialized~.\n  1. Set _env_.[[NewTarget]] to _newTarget_.\n  1. Set _env_.[[OuterEnv]] to _F_.[[Environment]].\n  1. Return _env_.","code":"\n          1. Let _env_ be a new Function Environment Record containing no bindings.\n          1. Set _env_.[[FunctionObject]] to _F_.\n          1. If _F_.[[ThisMode]] is ~lexical~, set _env_.[[ThisBindingStatus]] to ~lexical~.\n          1. Else, set _env_.[[ThisBindingStatus]] to ~uninitialized~.\n          1. Set _env_.[[NewTarget]] to _newTarget_.\n          1. Set _env_.[[OuterEnv]] to _F_.[[Environment]].\n          1. Return _env_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"NewGlobalEnvironment","params":[{"name":"G","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"thisValue","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Record[GlobalEnvironmentRecord]"}},"body":"\n  1. Let _objRec_ be NewObjectEnvironment(_G_, *false*, *null*).\n  1. Let _dclRec_ be NewDeclarativeEnvironment(*null*).\n  1. Let _env_ be Global Environment Record { }.\n  1. Set _env_.[[ObjectRecord]] to _objRec_.\n  1. Set _env_.[[GlobalThisValue]] to _thisValue_.\n  1. Set _env_.[[DeclarativeRecord]] to _dclRec_.\n  1. Set _env_.[[VarNames]] to « ».\n  1. Set _env_.[[OuterEnv]] to *null*.\n  1. Return _env_.","code":"\n          1. Let _objRec_ be NewObjectEnvironment(_G_, *false*, *null*).\n          1. Let _dclRec_ be NewDeclarativeEnvironment(*null*).\n          1. Let _env_ be a new Global Environment Record.\n          1. Set _env_.[[ObjectRecord]] to _objRec_.\n          1. Set _env_.[[GlobalThisValue]] to _thisValue_.\n          1. Set _env_.[[DeclarativeRecord]] to _dclRec_.\n          1. Set _env_.[[VarNames]] to a new empty List.\n          1. Set _env_.[[OuterEnv]] to *null*.\n          1. Return _env_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"NewModuleEnvironment","params":[{"name":"E","ty":"Record[EnvironmentRecord]","kind":{"Normal":{}}}],"retTy":"Record[ModuleEnvironmentRecord]"}},"body":"\n  1. Let _env_ be Module Environment Record { }.\n  1. Set _env_.[[OuterEnv]] to _E_.\n  1. Return _env_.","code":"\n          1. Let _env_ be a new Module Environment Record containing no bindings.\n          1. Set _env_.[[OuterEnv]] to _E_.\n          1. Return _env_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"NewPrivateEnvironment","params":[{"name":"outerPrivEnv","ty":"Record[PrivateEnvironmentRecord] | Null","kind":{"Normal":{}}}],"retTy":"Record[PrivateEnvironmentRecord]"}},"body":"\n  1. Let _names_ be « ».\n  1. Return PrivateEnvironment Record { [[OuterPrivateEnvironment]]: _outerPrivEnv_, [[Names]]: _names_ }.","code":"\n          1. Let _names_ be a new empty List.\n          1. Return the PrivateEnvironment Record { [[OuterPrivateEnvironment]]: _outerPrivEnv_, [[Names]]: _names_ }.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ResolvePrivateIdentifier","params":[{"name":"privEnv","ty":"Record[PrivateEnvironmentRecord]","kind":{"Normal":{}}},{"name":"identifier","ty":"String","kind":{"Normal":{}}}],"retTy":"Record[PrivateName]"}},"body":"\n  1. Let _names_ be _privEnv_.[[Names]].\n  1. For each Record[PrivateName] _pn_ of _names_, do\n    1. If _pn_.[[Description]] is _identifier_, then\n      1. Return _pn_.\n  1. Let _outerPrivEnv_ be _privEnv_.[[OuterPrivateEnvironment]].\n  1. Assert: _outerPrivEnv_ is not *null*.\n  1. Return ResolvePrivateIdentifier(_outerPrivEnv_, _identifier_).","code":"\n          1. Let _names_ be _privEnv_.[[Names]].\n          1. For each Private Name _pn_ of _names_, do\n            1. If _pn_.[[Description]] is _identifier_, then\n              1. Return _pn_.\n          1. Let _outerPrivEnv_ be _privEnv_.[[OuterPrivateEnvironment]].\n          1. Assert: _outerPrivEnv_ is not *null*.\n          1. Return ResolvePrivateIdentifier(_outerPrivEnv_, _identifier_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CreateRealm","params":[],"retTy":"Record[RealmRecord]"}},"body":"\n  1. Let _realmRec_ be a new Realm Record.\n  1. Perform CreateIntrinsics(_realmRec_).\n  1. Set _realmRec_.[[AgentSignifier]] to AgentSignifier().\n  1. Set _realmRec_.[[GlobalObject]] to *undefined*.\n  1. Set _realmRec_.[[GlobalEnv]] to *undefined*.\n  1. Set _realmRec_.[[TemplateMap]] to « ».\n  1. Return _realmRec_.","code":"\n        1. Let _realmRec_ be a new Realm Record.\n        1. Perform CreateIntrinsics(_realmRec_).\n        1. Set _realmRec_.[[AgentSignifier]] to AgentSignifier().\n        1. Set _realmRec_.[[GlobalObject]] to *undefined*.\n        1. Set _realmRec_.[[GlobalEnv]] to *undefined*.\n        1. Set _realmRec_.[[TemplateMap]] to a new empty List.\n        1. Return _realmRec_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CreateIntrinsics","params":[{"name":"realmRec","ty":"Record[RealmRecord]","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Set _realmRec_.[[Intrinsics]] to Record { }.\n  1. [declared=\"steps,name,length,slots,prototype\"] Set fields of _realmRec_.[[Intrinsics]] with the values listed in <emu-xref href=\"#table-well-known-intrinsic-objects\"></emu-xref>.\n  1. Perform AddRestrictedFunctionProperties(_realmRec_.[[Intrinsics]].[[%Function.prototype%]], _realmRec_).\n  1. Return ~unused~.","code":"\n        1. Set _realmRec_.[[Intrinsics]] to a new Record.\n        1. [declared=\"steps,name,length,slots,prototype\"] Set fields of _realmRec_.[[Intrinsics]] with the values listed in <emu-xref href=\"#table-well-known-intrinsic-objects\"></emu-xref>. The field names are the names listed in column one of the table. The value of each field is a new object value fully and recursively populated with property values as defined by the specification of each object in clauses <emu-xref href=\"#sec-global-object\"></emu-xref> through <emu-xref href=\"#sec-reflection\"></emu-xref>. All object property values are newly created object values. All values that are built-in function objects are created by performing CreateBuiltinFunction(_steps_, _length_, _name_, _slots_, _realmRec_, _prototype_) where _steps_ is the definition of that function provided by this specification, _name_ is the initial value of the function's *\"name\"* property, _length_ is the initial value of the function's *\"length\"* property, _slots_ is a list of the names, if any, of the function's specified internal slots, and _prototype_ is the specified value of the function's [[Prototype]] internal slot. The creation of the intrinsics and their properties must be ordered to avoid any dependencies upon objects that have not yet been created.\n        1. Perform AddRestrictedFunctionProperties(_realmRec_.[[Intrinsics]].[[%Function.prototype%]], _realmRec_).\n        1. Return ~unused~.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"SetRealmGlobalObject","params":[{"name":"realmRec","ty":"Record[RealmRecord]","kind":{"Normal":{}}},{"name":"globalObj","ty":"Record[Object] | Undefined","kind":{"Normal":{}}},{"name":"thisValue","ty":"Record[Object] | Undefined","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. If _globalObj_ is *undefined*, then\n    1. Let _intrinsics_ be _realmRec_.[[Intrinsics]].\n    1. Set _globalObj_ to OrdinaryObjectCreate(_intrinsics_.[[%Object.prototype%]]).\n  1. Assert: _globalObj_ is a Record[Object].\n  1. If _thisValue_ is *undefined*, set _thisValue_ to _globalObj_.\n  1. Set _realmRec_.[[GlobalObject]] to _globalObj_.\n  1. Let _newGlobalEnv_ be NewGlobalEnvironment(_globalObj_, _thisValue_).\n  1. Set _realmRec_.[[GlobalEnv]] to _newGlobalEnv_.\n  1. Return ~unused~.","code":"\n        1. If _globalObj_ is *undefined*, then\n          1. Let _intrinsics_ be _realmRec_.[[Intrinsics]].\n          1. Set _globalObj_ to OrdinaryObjectCreate(_intrinsics_.[[%Object.prototype%]]).\n        1. Assert: _globalObj_ is an Object.\n        1. If _thisValue_ is *undefined*, set _thisValue_ to _globalObj_.\n        1. Set _realmRec_.[[GlobalObject]] to _globalObj_.\n        1. Let _newGlobalEnv_ be NewGlobalEnvironment(_globalObj_, _thisValue_).\n        1. Set _realmRec_.[[GlobalEnv]] to _newGlobalEnv_.\n        1. Return ~unused~.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"SetDefaultGlobalBindings","params":[{"name":"realmRec","ty":"Record[RealmRecord]","kind":{"Normal":{}}}],"retTy":"Normal[Record[Object]] | Throw"}},"body":"\n  1. Let _global_ be _realmRec_.[[GlobalObject]].\n  1. For each property of the Global Object specified in clause <emu-xref href=\"#sec-global-object\"></emu-xref>, do\n    1. Let _name_ be the String value of the property name.\n    1. Let _desc_ be the fully populated data Property Descriptor for the property, containing the specified attributes for the property. For properties listed in <emu-xref href=\"#sec-function-properties-of-the-global-object\"></emu-xref>, <emu-xref href=\"#sec-constructor-properties-of-the-global-object\"></emu-xref>, or <emu-xref href=\"#sec-other-properties-of-the-global-object\"></emu-xref> the value of the [[Value]] attribute is the corresponding intrinsic object from _realmRec_.\n    1. Perform ? DefinePropertyOrThrow(_global_, _name_, _desc_).\n  1. Return _global_.","code":"\n        1. Let _global_ be _realmRec_.[[GlobalObject]].\n        1. For each property of the Global Object specified in clause <emu-xref href=\"#sec-global-object\"></emu-xref>, do\n          1. Let _name_ be the String value of the property name.\n          1. Let _desc_ be the fully populated data Property Descriptor for the property, containing the specified attributes for the property. For properties listed in <emu-xref href=\"#sec-function-properties-of-the-global-object\"></emu-xref>, <emu-xref href=\"#sec-constructor-properties-of-the-global-object\"></emu-xref>, or <emu-xref href=\"#sec-other-properties-of-the-global-object\"></emu-xref> the value of the [[Value]] attribute is the corresponding intrinsic object from _realmRec_.\n          1. Perform ? DefinePropertyOrThrow(_global_, _name_, _desc_).\n        1. Return _global_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetActiveScriptOrModule","params":[],"retTy":"Record[ModuleRecord | ScriptRecord] | Null"}},"body":"\n  1. If the execution context stack is empty, return *null*.\n  1. Let _ec_ be the topmost execution context on the execution context stack whose ScriptOrModule component is not *null*.\n  1. If no such execution context exists, return *null*. Otherwise, return _ec_'s ScriptOrModule.","code":"\n        1. If the execution context stack is empty, return *null*.\n        1. Let _ec_ be the topmost execution context on the execution context stack whose ScriptOrModule component is not *null*.\n        1. If no such execution context exists, return *null*. Otherwise, return _ec_'s ScriptOrModule.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ResolveBinding","params":[{"name":"name","ty":"String","kind":{"Normal":{}}},{"name":"env","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Optional":{}}}],"retTy":"Normal[Record[ReferenceRecord]] | Throw"}},"body":"\n  1. If _env_ is not present or _env_ is *undefined*, then\n    1. Set _env_ to the running execution context.LexicalEnvironment.\n  1. Assert: _env_ is a Record[EnvironmentRecord].\n  1. If *true*, let _strict_ be *true*.\n  1. Else, let _strict_ be *false*.\n  1. Return ? GetIdentifierReference(_env_, _name_, _strict_).","code":"\n        1. If _env_ is not present or _env_ is *undefined*, then\n          1. Set _env_ to the running execution context's LexicalEnvironment.\n        1. Assert: _env_ is an Environment Record.\n        1. If the source text matched by the syntactic production that is being evaluated is contained in strict mode code, let _strict_ be *true*; else let _strict_ be *false*.\n        1. Return ? GetIdentifierReference(_env_, _name_, _strict_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetThisEnvironment","params":[],"retTy":"Record[EnvironmentRecord]"}},"body":"\n  1. Let _env_ be the running execution context.LexicalEnvironment.\n  1. [id=\"step-getthisenvironment-loop\"] Repeat, \n    1. Let _exists_ be _env_.HasThisBinding().\n    1. If _exists_ is *true*, return _env_.\n    1. Let _outer_ be _env_.[[OuterEnv]].\n    1. Assert: _outer_ is not *null*.\n    1. Set _env_ to _outer_.","code":"\n        1. Let _env_ be the running execution context's LexicalEnvironment.\n        1. [id=\"step-getthisenvironment-loop\"] Repeat,\n          1. Let _exists_ be _env_.HasThisBinding().\n          1. If _exists_ is *true*, return _env_.\n          1. Let _outer_ be _env_.[[OuterEnv]].\n          1. Assert: _outer_ is not *null*.\n          1. Set _env_ to _outer_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ResolveThisBinding","params":[],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Let _envRec_ be GetThisEnvironment().\n  1. Return ? _envRec_.GetThisBinding().","code":"\n        1. Let _envRec_ be GetThisEnvironment().\n        1. Return ? _envRec_.GetThisBinding().\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetNewTarget","params":[],"retTy":"Record[Object] | Undefined"}},"body":"\n  1. Let _envRec_ be GetThisEnvironment().\n  1. Assert: _envRec_ has a [[NewTarget]] internal slot.\n  1. Return _envRec_.[[NewTarget]].","code":"\n        1. Let _envRec_ be GetThisEnvironment().\n        1. Assert: _envRec_ has a [[NewTarget]] field.\n        1. Return _envRec_.[[NewTarget]].\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetGlobalObject","params":[],"retTy":"Record[Object]"}},"body":"\n  1. Let _currentRealm_ be the current Realm Record.\n  1. Return _currentRealm_.[[GlobalObject]].","code":"\n        1. Let _currentRealm_ be the current Realm Record.\n        1. Return _currentRealm_.[[GlobalObject]].\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":true,"name":"HostMakeJobCallback","params":[{"name":"callback","ty":"Record[FunctionObject]","kind":{"Normal":{}}}],"retTy":"Record[JobCallbackRecord]"}},"body":"\n  1. Return JobCallback Record { [[Callback]]: _callback_, [[HostDefined]]: ~empty~ }.","code":"\n        1. Return the JobCallback Record { [[Callback]]: _callback_, [[HostDefined]]: ~empty~ }.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":true,"name":"HostCallJobCallback","params":[{"name":"jobCallback","ty":"Record[JobCallbackRecord]","kind":{"Normal":{}}},{"name":"V","ty":"ESValue","kind":{"Normal":{}}},{"name":"argumentsList","ty":"List[ESValue]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Assert: IsCallable(_jobCallback_.[[Callback]]) is *true*.\n  1. Return ? Call(_jobCallback_.[[Callback]], _V_, _argumentsList_).","code":"\n        1. Assert: IsCallable(_jobCallback_.[[Callback]]) is *true*.\n        1. Return ? Call(_jobCallback_.[[Callback]], _V_, _argumentsList_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"InitializeHostDefinedRealm","params":[],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Let _realm_ be CreateRealm().\n  1. Let _newContext_ be ExecutionContext { }.\n  1. Set _newContext_.Function to *null*.\n  1. Set _newContext_.Realm to _realm_.\n  1. Set _newContext_.ScriptOrModule to *null*.\n  1. Push _newContext_ onto the execution context stack; _newContext_ is now the running execution context.\n  1. If the host requires use of an exotic object to serve as _realm_'s global object, let _global_ be such an object created in a host-defined manner. Otherwise, let _global_ be *undefined*, indicating that an ordinary object should be created as the global object.\n  1. If the host requires that the `this` binding in _realm_'s global scope return an object other than the global object, let _thisValue_ be such an object created in a host-defined manner. Otherwise, let _thisValue_ be *undefined*, indicating that _realm_'s global `this` binding should be the global object.\n  1. Perform SetRealmGlobalObject(_realm_, _global_, _thisValue_).\n  1. Let _globalObj_ be ? SetDefaultGlobalBindings(_realm_).\n  1. Create any host-defined global object properties on _globalObj_.\n  1. Return ~unused~.","code":"\n      1. Let _realm_ be CreateRealm().\n      1. Let _newContext_ be a new execution context.\n      1. Set the Function of _newContext_ to *null*.\n      1. Set the Realm of _newContext_ to _realm_.\n      1. Set the ScriptOrModule of _newContext_ to *null*.\n      1. Push _newContext_ onto the execution context stack; _newContext_ is now the running execution context.\n      1. If the host requires use of an exotic object to serve as _realm_'s global object, let _global_ be such an object created in a host-defined manner. Otherwise, let _global_ be *undefined*, indicating that an ordinary object should be created as the global object.\n      1. If the host requires that the `this` binding in _realm_'s global scope return an object other than the global object, let _thisValue_ be such an object created in a host-defined manner. Otherwise, let _thisValue_ be *undefined*, indicating that _realm_'s global `this` binding should be the global object.\n      1. Perform SetRealmGlobalObject(_realm_, _global_, _thisValue_).\n      1. Let _globalObj_ be ? SetDefaultGlobalBindings(_realm_).\n      1. Create any host-defined global object properties on _globalObj_.\n      1. Return ~unused~.\n    "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AgentSignifier","params":[],"retTy":"Unknown[\"an agent signifier\"]"}},"body":"\n  1. Let _AR_ be the Agent Record of the surrounding agent.\n  1. Return _AR_.[[Signifier]].","code":"\n        1. Let _AR_ be the Agent Record of the surrounding agent.\n        1. Return _AR_.[[Signifier]].\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AgentCanSuspend","params":[],"retTy":"Boolean"}},"body":"\n  1. Let _AR_ be the Agent Record of the surrounding agent.\n  1. Return _AR_.[[CanBlock]].","code":"\n        1. Let _AR_ be the Agent Record of the surrounding agent.\n        1. Return _AR_.[[CanBlock]].\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":true,"name":"HostEnqueueFinalizationRegistryCleanupJob","params":[{"name":"finalizationRegistry","ty":"Record[FinalizationRegistry]","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Let _cleanupResult_ be Completion(CleanupFinalizationRegistry(_finalizationRegistry_)).\n  1. If _cleanupResult_ is an abrupt completion, perform any host-defined steps for reporting the error.\n  1. Return ~unused~.","code":"\n          1. Let _cleanupResult_ be Completion(CleanupFinalizationRegistry(_finalizationRegistry_)).\n          1. If _cleanupResult_ is an abrupt completion, perform any host-defined steps for reporting the error.\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ClearKeptObjects","params":[],"retTy":"Enum[~unused~]"}},"body":"\n  1. Let _agentRecord_ be the surrounding agent's Agent Record.\n  1. Set _agentRecord_.[[KeptAlive]] to « ».\n  1. Return ~unused~.","code":"\n      1. Let _agentRecord_ be the surrounding agent's Agent Record.\n      1. Set _agentRecord_.[[KeptAlive]] to a new empty List.\n      1. Return ~unused~.\n    "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AddToKeptObjects","params":[{"name":"value","ty":"Record[Object | Symbol]","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Let _agentRecord_ be the surrounding agent's Agent Record.\n  1. Append _value_ to _agentRecord_.[[KeptAlive]].\n  1. Return ~unused~.","code":"\n      1. Let _agentRecord_ be the surrounding agent's Agent Record.\n      1. Append _value_ to _agentRecord_.[[KeptAlive]].\n      1. Return ~unused~.\n    "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CleanupFinalizationRegistry","params":[{"name":"finalizationRegistry","ty":"Record[FinalizationRegistry]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Assert: _finalizationRegistry_ has [[Cells]] and [[CleanupCallback]] internal slots..\n  1. Let _callback_ be _finalizationRegistry_.[[CleanupCallback]].\n  1. While _finalizationRegistry_.[[Cells]] contains a Record _cell_ such that _cell_.[[WeakRefTarget]] is ~empty~, an implementation may perform the following steps:\n    1. Choose any such _cell_.\n    1. Remove _cell_ from _finalizationRegistry_.[[Cells]].\n    1. Perform ? HostCallJobCallback(_callback_, *undefined*, « _cell_.[[HeldValue]] »).\n  1. Return ~unused~.","code":"\n      1. Assert: _finalizationRegistry_ has [[Cells]] and [[CleanupCallback]] internal slots.\n      1. Let _callback_ be _finalizationRegistry_.[[CleanupCallback]].\n      1. While _finalizationRegistry_.[[Cells]] contains a Record _cell_ such that _cell_.[[WeakRefTarget]] is ~empty~, an implementation may perform the following steps:\n        1. Choose any such _cell_.\n        1. Remove _cell_ from _finalizationRegistry_.[[Cells]].\n        1. Perform ? HostCallJobCallback(_callback_, *undefined*, « _cell_.[[HeldValue]] »).\n      1. Return ~unused~.\n    "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CanBeHeldWeakly","params":[{"name":"v","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _v_ is a Record[Object], return *true*.\n  1. If _v_ is a Record[Symbol] and KeyForSymbol(_v_) is *undefined*, return *true*.\n  1. Return *false*.","code":"\n      1. If _v_ is an Object, return *true*.\n      1. If _v_ is a Symbol and KeyForSymbol(_v_) is *undefined*, return *true*.\n      1. Return *false*.\n    "},{"head":{"InternalMethodHead":{"methodName":"GetPrototypeOf","receiver":{"name":"O","ty":"Record[OrdinaryObject]","kind":{"Normal":{}}},"params":[],"retTy":"Normal[Record[Object] | Null]"}},"body":"\n  1. Return OrdinaryGetPrototypeOf(_O_).","code":"\n        1. Return OrdinaryGetPrototypeOf(_O_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"OrdinaryGetPrototypeOf","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Record[Object] | Null"}},"body":"\n  1. Return _O_.[[Prototype]].","code":"\n          1. Return _O_.[[Prototype]].\n        "},{"head":{"InternalMethodHead":{"methodName":"SetPrototypeOf","receiver":{"name":"O","ty":"Record[OrdinaryObject]","kind":{"Normal":{}}},"params":[{"name":"V","ty":"Record[Object] | Null","kind":{"Normal":{}}}],"retTy":"Normal[Boolean]"}},"body":"\n  1. Return OrdinarySetPrototypeOf(_O_, _V_).","code":"\n        1. Return OrdinarySetPrototypeOf(_O_, _V_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"OrdinarySetPrototypeOf","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"V","ty":"Record[Object] | Null","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _current_ be _O_.[[Prototype]].\n  1. If SameValue(_V_, _current_) is *true*, return *true*.\n  1. Let _extensible_ be _O_.[[Extensible]].\n  1. If _extensible_ is *false*, return *false*.\n  1. Let _p_ be _V_.\n  1. Let _done_ be *false*.\n  1. [id=\"step-ordinarysetprototypeof-loop\"] Repeat, while _done_ is *false*,\n    1. If _p_ is *null*, then\n      1. Set _done_ to *true*.\n    1. Else if SameValue(_p_, _O_) is *true*, then\n      1. Return *false*.\n    1. Else,\n      1. If _p_.[[GetPrototypeOf]] is not the definition specified in <emu-xref href=\"#sec-ordinary-object-internal-methods-and-internal-slots-getprototypeof\"></emu-xref>, set _done_ to *true*.\n      1. Else, set _p_ to _p_.[[Prototype]].\n  1. Set _O_.[[Prototype]] to _V_.\n  1. Return *true*.","code":"\n          1. Let _current_ be _O_.[[Prototype]].\n          1. If SameValue(_V_, _current_) is *true*, return *true*.\n          1. Let _extensible_ be _O_.[[Extensible]].\n          1. If _extensible_ is *false*, return *false*.\n          1. Let _p_ be _V_.\n          1. Let _done_ be *false*.\n          1. [id=\"step-ordinarysetprototypeof-loop\"] Repeat, while _done_ is *false*,\n            1. If _p_ is *null*, then\n              1. Set _done_ to *true*.\n            1. Else if SameValue(_p_, _O_) is *true*, then\n              1. Return *false*.\n            1. Else,\n              1. If _p_.[[GetPrototypeOf]] is not the ordinary object internal method defined in <emu-xref href=\"#sec-ordinary-object-internal-methods-and-internal-slots-getprototypeof\"></emu-xref>, set _done_ to *true*.\n              1. Else, set _p_ to _p_.[[Prototype]].\n          1. Set _O_.[[Prototype]] to _V_.\n          1. Return *true*.\n        "},{"head":{"InternalMethodHead":{"methodName":"IsExtensible","receiver":{"name":"O","ty":"Record[OrdinaryObject]","kind":{"Normal":{}}},"params":[],"retTy":"Normal[Boolean]"}},"body":"\n  1. Return OrdinaryIsExtensible(_O_).","code":"\n        1. Return OrdinaryIsExtensible(_O_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"OrdinaryIsExtensible","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return _O_.[[Extensible]].","code":"\n          1. Return _O_.[[Extensible]].\n        "},{"head":{"InternalMethodHead":{"methodName":"PreventExtensions","receiver":{"name":"O","ty":"Record[OrdinaryObject]","kind":{"Normal":{}}},"params":[],"retTy":"Normal[True]"}},"body":"\n  1. Return OrdinaryPreventExtensions(_O_).","code":"\n        1. Return OrdinaryPreventExtensions(_O_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"OrdinaryPreventExtensions","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"True"}},"body":"\n  1. Set _O_.[[Extensible]] to *false*.\n  1. Return *true*.","code":"\n          1. Set _O_.[[Extensible]] to *false*.\n          1. Return *true*.\n        "},{"head":{"InternalMethodHead":{"methodName":"GetOwnProperty","receiver":{"name":"O","ty":"Record[OrdinaryObject]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Record[PropertyDescriptor] | Undefined]"}},"body":"\n  1. Return OrdinaryGetOwnProperty(_O_, _P_).","code":"\n        1. Return OrdinaryGetOwnProperty(_O_, _P_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"OrdinaryGetOwnProperty","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Record[PropertyDescriptor] | Undefined"}},"body":"\n  1. If _O_ does not have an own property with key _P_, return *undefined*.\n  1. Let _D_ be Property Descriptor { }.\n  1. Let _X_ be _O_'s own property whose key is _P_.\n  1. If _X_ is a data property, then\n    1. Set _D_.[[Value]] to _X_.[[Value]].\n    1. Set _D_.[[Writable]] to _X_.[[Writable]].\n  1. Else,\n    1. Assert: _X_ is an accessor property.\n    1. Set _D_.[[Get]] to _X_.[[Get]].\n    1. Set _D_.[[Set]] to _X_.[[Set]].\n  1. Set _D_.[[Enumerable]] to _X_.[[Enumerable]].\n  1. Set _D_.[[Configurable]] to _X_.[[Configurable]].\n  1. Return _D_.","code":"\n          1. If _O_ does not have an own property with key _P_, return *undefined*.\n          1. Let _D_ be a newly created Property Descriptor with no fields.\n          1. Let _X_ be _O_'s own property whose key is _P_.\n          1. If _X_ is a data property, then\n            1. Set _D_.[[Value]] to the value of _X_'s [[Value]] attribute.\n            1. Set _D_.[[Writable]] to the value of _X_'s [[Writable]] attribute.\n          1. Else,\n            1. Assert: _X_ is an accessor property.\n            1. Set _D_.[[Get]] to the value of _X_'s [[Get]] attribute.\n            1. Set _D_.[[Set]] to the value of _X_'s [[Set]] attribute.\n          1. Set _D_.[[Enumerable]] to the value of _X_'s [[Enumerable]] attribute.\n          1. Set _D_.[[Configurable]] to the value of _X_'s [[Configurable]] attribute.\n          1. Return _D_.\n        "},{"head":{"InternalMethodHead":{"methodName":"DefineOwnProperty","receiver":{"name":"O","ty":"Record[OrdinaryObject]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}},{"name":"Desc","ty":"Record[PropertyDescriptor]","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Return ? OrdinaryDefineOwnProperty(_O_, _P_, _Desc_).","code":"\n        1. Return ? OrdinaryDefineOwnProperty(_O_, _P_, _Desc_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"OrdinaryDefineOwnProperty","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}},{"name":"Desc","ty":"Record[PropertyDescriptor]","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Let _current_ be ? _O_.[[GetOwnProperty]](_P_).\n  1. Let _extensible_ be ? IsExtensible(_O_).\n  1. Return ValidateAndApplyPropertyDescriptor(_O_, _P_, _extensible_, _Desc_, _current_).","code":"\n          1. Let _current_ be ? <emu-meta effects=\"user-code\">_O_.[[GetOwnProperty]]</emu-meta>(_P_).\n          1. Let _extensible_ be ? IsExtensible(_O_).\n          1. Return ValidateAndApplyPropertyDescriptor(_O_, _P_, _extensible_, _Desc_, _current_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsCompatiblePropertyDescriptor","params":[{"name":"Extensible","ty":"Boolean","kind":{"Normal":{}}},{"name":"Desc","ty":"Record[PropertyDescriptor]","kind":{"Normal":{}}},{"name":"Current","ty":"Record[PropertyDescriptor] | Undefined","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return ValidateAndApplyPropertyDescriptor(*undefined*, *\"\"*, _Extensible_, _Desc_, _Current_).","code":"\n          1. Return ValidateAndApplyPropertyDescriptor(*undefined*, *\"\"*, _Extensible_, _Desc_, _Current_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ValidateAndApplyPropertyDescriptor","params":[{"name":"O","ty":"Record[Object] | Undefined","kind":{"Normal":{}}},{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}},{"name":"extensible","ty":"Boolean","kind":{"Normal":{}}},{"name":"Desc","ty":"Record[PropertyDescriptor]","kind":{"Normal":{}}},{"name":"current","ty":"Record[PropertyDescriptor] | Undefined","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Assert: IsPropertyKey(_P_) is *true*.\n  1. If _current_ is *undefined*, then\n    1. If _extensible_ is *false*, return *false*.\n    1. If _O_ is *undefined*, return *true*.\n    1. If IsAccessorDescriptor(_Desc_) is *true*, then\n      1. Create an own accessor property named _P_ of object _O_ whose [[Get]], [[Set]], [[Enumerable]], and [[Configurable]] attributes are set to the value of the corresponding field in _Desc_ if _Desc_ has that field, or to the attribute's <emu-xref href=\"#table-object-property-attributes\">default value</emu-xref> otherwise.\n    1. Else,\n      1. Create an own data property named _P_ of object _O_ whose [[Value]], [[Writable]], [[Enumerable]], and [[Configurable]] attributes are set to the value of the corresponding field in _Desc_ if _Desc_ has that field, or to the attribute's <emu-xref href=\"#table-object-property-attributes\">default value</emu-xref> otherwise.\n    1. Return *true*.\n  1. Assert: _current_ is a fully populated Property Descriptor.\n  1. If _Desc_ does not have any fields, return *true*.\n  1. If _current_.[[Configurable]] is *false*, then\n    1. If _Desc_ has a [[Configurable]] internal slot and _Desc_.[[Configurable]] is *true*, return *false*.\n    1. If _Desc_ has a [[Enumerable]] internal slot and _Desc_.[[Enumerable]] is not _current_.[[Enumerable]], return *false*.\n    1. If IsGenericDescriptor(_Desc_) is *false* and IsAccessorDescriptor(_Desc_) is not IsAccessorDescriptor(_current_), return *false*.\n    1. If IsAccessorDescriptor(_current_) is *true*, then\n      1. If _Desc_ has a [[Get]] internal slot and SameValue(_Desc_.[[Get]], _current_.[[Get]]) is *false*, return *false*.\n      1. If _Desc_ has a [[Set]] internal slot and SameValue(_Desc_.[[Set]], _current_.[[Set]]) is *false*, return *false*.\n    1. Else if _current_.[[Writable]] is *false*, then\n      1. If _Desc_ has a [[Writable]] internal slot and _Desc_.[[Writable]] is *true*, return *false*.\n      1. If _Desc_ has a [[Value]] internal slot and SameValue(_Desc_.[[Value]], _current_.[[Value]]) is *false*, return *false*.\n  1. If _O_ is not *undefined*, then\n    1. If IsDataDescriptor(_current_) is *true* and IsAccessorDescriptor(_Desc_) is *true*, then\n      1. If _Desc_ has a [[Configurable]] internal slot, let _configurable_ be _Desc_.[[Configurable]].\n      1. Else, let _configurable_ be _current_.[[Configurable]].\n      1. If _Desc_ has a [[Enumerable]] internal slot, let _enumerable_ be _Desc_.[[Enumerable]].\n      1. Else, let _enumerable_ be _current_.[[Enumerable]].\n      1. Replace the property named _P_ of object _O_ with an accessor property whose [[Configurable]] and [[Enumerable]] attributes are set to _configurable_ and _enumerable_, respectively, and whose [[Get]] and [[Set]] attributes are set to the value of the corresponding field in _Desc_ if _Desc_ has that field, or to the attribute's <emu-xref href=\"#table-object-property-attributes\">default value</emu-xref> otherwise.\n    1. Else if IsAccessorDescriptor(_current_) is *true* and IsDataDescriptor(_Desc_) is *true*, then\n      1. If _Desc_ has a [[Configurable]] internal slot, let _configurable_ be _Desc_.[[Configurable]].\n      1. Else, let _configurable_ be _current_.[[Configurable]].\n      1. If _Desc_ has a [[Enumerable]] internal slot, let _enumerable_ be _Desc_.[[Enumerable]].\n      1. Else, let _enumerable_ be _current_.[[Enumerable]].\n      1. Replace the property named _P_ of object _O_ with a data property whose [[Configurable]] and [[Enumerable]] attributes are set to _configurable_ and _enumerable_, respectively, and whose [[Value]] and [[Writable]] attributes are set to the value of the corresponding field in _Desc_ if _Desc_ has that field, or to the attribute's <emu-xref href=\"#table-object-property-attributes\">default value</emu-xref> otherwise.\n    1. Else,\n      1. For each field of _Desc_, set the corresponding attribute of the property named _P_ of object _O_ to the value of the field.\n  1. Return *true*.","code":"\n          1. Assert: IsPropertyKey(_P_) is *true*.\n          1. If _current_ is *undefined*, then\n            1. If _extensible_ is *false*, return *false*.\n            1. If _O_ is *undefined*, return *true*.\n            1. If IsAccessorDescriptor(_Desc_) is *true*, then\n              1. Create an own accessor property named _P_ of object _O_ whose [[Get]], [[Set]], [[Enumerable]], and [[Configurable]] attributes are set to the value of the corresponding field in _Desc_ if _Desc_ has that field, or to the attribute's <emu-xref href=\"#table-object-property-attributes\">default value</emu-xref> otherwise.\n            1. Else,\n              1. Create an own data property named _P_ of object _O_ whose [[Value]], [[Writable]], [[Enumerable]], and [[Configurable]] attributes are set to the value of the corresponding field in _Desc_ if _Desc_ has that field, or to the attribute's <emu-xref href=\"#table-object-property-attributes\">default value</emu-xref> otherwise.\n            1. Return *true*.\n          1. Assert: _current_ is a fully populated Property Descriptor.\n          1. If _Desc_ does not have any fields, return *true*.\n          1. If _current_.[[Configurable]] is *false*, then\n            1. If _Desc_ has a [[Configurable]] field and _Desc_.[[Configurable]] is *true*, return *false*.\n            1. If _Desc_ has an [[Enumerable]] field and _Desc_.[[Enumerable]] is not _current_.[[Enumerable]], return *false*.\n            1. If IsGenericDescriptor(_Desc_) is *false* and IsAccessorDescriptor(_Desc_) is not IsAccessorDescriptor(_current_), return *false*.\n            1. If IsAccessorDescriptor(_current_) is *true*, then\n              1. If _Desc_ has a [[Get]] field and SameValue(_Desc_.[[Get]], _current_.[[Get]]) is *false*, return *false*.\n              1. If _Desc_ has a [[Set]] field and SameValue(_Desc_.[[Set]], _current_.[[Set]]) is *false*, return *false*.\n            1. Else if _current_.[[Writable]] is *false*, then\n              1. If _Desc_ has a [[Writable]] field and _Desc_.[[Writable]] is *true*, return *false*.\n              1. If _Desc_ has a [[Value]] field and SameValue(_Desc_.[[Value]], _current_.[[Value]]) is *false*, return *false*.\n          1. If _O_ is not *undefined*, then\n            1. If IsDataDescriptor(_current_) is *true* and IsAccessorDescriptor(_Desc_) is *true*, then\n              1. If _Desc_ has a [[Configurable]] field, let _configurable_ be _Desc_.[[Configurable]]; else let _configurable_ be _current_.[[Configurable]].\n              1. If _Desc_ has a [[Enumerable]] field, let _enumerable_ be _Desc_.[[Enumerable]]; else let _enumerable_ be _current_.[[Enumerable]].\n              1. Replace the property named _P_ of object _O_ with an accessor property whose [[Configurable]] and [[Enumerable]] attributes are set to _configurable_ and _enumerable_, respectively, and whose [[Get]] and [[Set]] attributes are set to the value of the corresponding field in _Desc_ if _Desc_ has that field, or to the attribute's <emu-xref href=\"#table-object-property-attributes\">default value</emu-xref> otherwise.\n            1. Else if IsAccessorDescriptor(_current_) is *true* and IsDataDescriptor(_Desc_) is *true*, then\n              1. If _Desc_ has a [[Configurable]] field, let _configurable_ be _Desc_.[[Configurable]]; else let _configurable_ be _current_.[[Configurable]].\n              1. If _Desc_ has a [[Enumerable]] field, let _enumerable_ be _Desc_.[[Enumerable]]; else let _enumerable_ be _current_.[[Enumerable]].\n              1. Replace the property named _P_ of object _O_ with a data property whose [[Configurable]] and [[Enumerable]] attributes are set to _configurable_ and _enumerable_, respectively, and whose [[Value]] and [[Writable]] attributes are set to the value of the corresponding field in _Desc_ if _Desc_ has that field, or to the attribute's <emu-xref href=\"#table-object-property-attributes\">default value</emu-xref> otherwise.\n            1. Else,\n              1. For each field of _Desc_, set the corresponding attribute of the property named _P_ of object _O_ to the value of the field.\n          1. Return *true*.\n        "},{"head":{"InternalMethodHead":{"methodName":"HasProperty","receiver":{"name":"O","ty":"Record[OrdinaryObject]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Return ? OrdinaryHasProperty(_O_, _P_).","code":"\n        1. Return ? OrdinaryHasProperty(_O_, _P_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"OrdinaryHasProperty","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Let _hasOwn_ be ? _O_.[[GetOwnProperty]](_P_).\n  1. If _hasOwn_ is not *undefined*, return *true*.\n  1. Let _parent_ be ? _O_.[[GetPrototypeOf]]().\n  1. If _parent_ is not *null*, then\n    1. Return ? _parent_.[[HasProperty]](_P_).\n  1. Return *false*.","code":"\n          1. Let _hasOwn_ be ? <emu-meta effects=\"user-code\">_O_.[[GetOwnProperty]]</emu-meta>(_P_).\n          1. If _hasOwn_ is not *undefined*, return *true*.\n          1. Let _parent_ be ? <emu-meta effects=\"user-code\">_O_.[[GetPrototypeOf]]</emu-meta>().\n          1. If _parent_ is not *null*, then\n            1. Return ? <emu-meta effects=\"user-code\">_parent_.[[HasProperty]]</emu-meta>(_P_).\n          1. Return *false*.\n        "},{"head":{"InternalMethodHead":{"methodName":"Get","receiver":{"name":"O","ty":"Record[OrdinaryObject]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}},{"name":"Receiver","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Return ? OrdinaryGet(_O_, _P_, _Receiver_).","code":"\n        1. Return ? OrdinaryGet(_O_, _P_, _Receiver_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"OrdinaryGet","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}},{"name":"Receiver","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Let _desc_ be ? _O_.[[GetOwnProperty]](_P_).\n  1. If _desc_ is *undefined*, then\n    1. Let _parent_ be ? _O_.[[GetPrototypeOf]]().\n    1. If _parent_ is *null*, return *undefined*.\n    1. Return ? _parent_.[[Get]](_P_, _Receiver_).\n  1. If IsDataDescriptor(_desc_) is *true*, return _desc_.[[Value]].\n  1. Assert: IsAccessorDescriptor(_desc_) is *true*.\n  1. Let _getter_ be _desc_.[[Get]].\n  1. If _getter_ is *undefined*, return *undefined*.\n  1. Return ? Call(_getter_, _Receiver_).","code":"\n          1. Let _desc_ be ? <emu-meta effects=\"user-code\">_O_.[[GetOwnProperty]]</emu-meta>(_P_).\n          1. If _desc_ is *undefined*, then\n            1. Let _parent_ be ? <emu-meta effects=\"user-code\">_O_.[[GetPrototypeOf]]</emu-meta>().\n            1. If _parent_ is *null*, return *undefined*.\n            1. Return ? <emu-meta effects=\"user-code\">_parent_.[[Get]]</emu-meta>(_P_, _Receiver_).\n          1. If IsDataDescriptor(_desc_) is *true*, return _desc_.[[Value]].\n          1. Assert: IsAccessorDescriptor(_desc_) is *true*.\n          1. Let _getter_ be _desc_.[[Get]].\n          1. If _getter_ is *undefined*, return *undefined*.\n          1. Return ? Call(_getter_, _Receiver_).\n        "},{"head":{"InternalMethodHead":{"methodName":"Set","receiver":{"name":"O","ty":"Record[OrdinaryObject]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}},{"name":"V","ty":"ESValue","kind":{"Normal":{}}},{"name":"Receiver","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Return ? OrdinarySet(_O_, _P_, _V_, _Receiver_).","code":"\n        1. Return ? OrdinarySet(_O_, _P_, _V_, _Receiver_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"OrdinarySet","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}},{"name":"V","ty":"ESValue","kind":{"Normal":{}}},{"name":"Receiver","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Let _ownDesc_ be ? _O_.[[GetOwnProperty]](_P_).\n  1. Return ? OrdinarySetWithOwnDescriptor(_O_, _P_, _V_, _Receiver_, _ownDesc_).","code":"\n          1. Let _ownDesc_ be ? <emu-meta effects=\"user-code\">_O_.[[GetOwnProperty]]</emu-meta>(_P_).\n          1. Return ? OrdinarySetWithOwnDescriptor(_O_, _P_, _V_, _Receiver_, _ownDesc_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"OrdinarySetWithOwnDescriptor","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}},{"name":"V","ty":"ESValue","kind":{"Normal":{}}},{"name":"Receiver","ty":"ESValue","kind":{"Normal":{}}},{"name":"ownDesc","ty":"Record[PropertyDescriptor] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. If _ownDesc_ is *undefined*, then\n    1. Let _parent_ be ? _O_.[[GetPrototypeOf]]().\n    1. If _parent_ is not *null*, then\n      1. Return ? _parent_.[[Set]](_P_, _V_, _Receiver_).\n    1. Else,\n      1. Set _ownDesc_ to PropertyDescriptor { [[Value]]: *undefined*, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* }.\n  1. If IsDataDescriptor(_ownDesc_) is *true*, then\n    1. If _ownDesc_.[[Writable]] is *false*, return *false*.\n    1. If _Receiver_ is not a Record[Object], return *false*.\n    1. Let _existingDescriptor_ be ? _Receiver_.[[GetOwnProperty]](_P_).\n    1. If _existingDescriptor_ is not *undefined*, then\n      1. If IsAccessorDescriptor(_existingDescriptor_) is *true*, return *false*.\n      1. If _existingDescriptor_.[[Writable]] is *false*, return *false*.\n      1. Let _valueDesc_ be PropertyDescriptor { [[Value]]: _V_ }.\n      1. Return ? _Receiver_.[[DefineOwnProperty]](_P_, _valueDesc_).\n    1. Else,\n      1. Assert: _Receiver_ does not currently have a property _P_..\n      1. Return ? CreateDataProperty(_Receiver_, _P_, _V_).\n  1. Assert: IsAccessorDescriptor(_ownDesc_) is *true*.\n  1. Let _setter_ be _ownDesc_.[[Set]].\n  1. If _setter_ is *undefined*, return *false*.\n  1. Perform ? Call(_setter_, _Receiver_, « _V_ »).\n  1. Return *true*.","code":"\n          1. If _ownDesc_ is *undefined*, then\n            1. Let _parent_ be ? <emu-meta effects=\"user-code\">_O_.[[GetPrototypeOf]]</emu-meta>().\n            1. If _parent_ is not *null*, then\n              1. Return ? <emu-meta effects=\"user-code\">_parent_.[[Set]]</emu-meta>(_P_, _V_, _Receiver_).\n            1. Else,\n              1. Set _ownDesc_ to the PropertyDescriptor { [[Value]]: *undefined*, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* }.\n          1. If IsDataDescriptor(_ownDesc_) is *true*, then\n            1. If _ownDesc_.[[Writable]] is *false*, return *false*.\n            1. If _Receiver_ is not an Object, return *false*.\n            1. Let _existingDescriptor_ be ? <emu-meta effects=\"user-code\">_Receiver_.[[GetOwnProperty]]</emu-meta>(_P_).\n            1. If _existingDescriptor_ is not *undefined*, then\n              1. If IsAccessorDescriptor(_existingDescriptor_) is *true*, return *false*.\n              1. If _existingDescriptor_.[[Writable]] is *false*, return *false*.\n              1. Let _valueDesc_ be the PropertyDescriptor { [[Value]]: _V_ }.\n              1. Return ? <emu-meta effects=\"user-code\">_Receiver_.[[DefineOwnProperty]]</emu-meta>(_P_, _valueDesc_).\n            1. Else,\n              1. Assert: _Receiver_ does not currently have a property _P_.\n              1. Return ? CreateDataProperty(_Receiver_, _P_, _V_).\n          1. Assert: IsAccessorDescriptor(_ownDesc_) is *true*.\n          1. Let _setter_ be _ownDesc_.[[Set]].\n          1. If _setter_ is *undefined*, return *false*.\n          1. Perform ? Call(_setter_, _Receiver_, « _V_ »).\n          1. Return *true*.\n        "},{"head":{"InternalMethodHead":{"methodName":"Delete","receiver":{"name":"O","ty":"Record[OrdinaryObject]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Return ? OrdinaryDelete(_O_, _P_).","code":"\n        1. Return ? OrdinaryDelete(_O_, _P_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"OrdinaryDelete","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Let _desc_ be ? _O_.[[GetOwnProperty]](_P_).\n  1. If _desc_ is *undefined*, return *true*.\n  1. If _desc_.[[Configurable]] is *true*, then\n    1. Remove the own property with name _P_ from _O_.\n    1. Return *true*.\n  1. Return *false*.","code":"\n          1. Let _desc_ be ? <emu-meta effects=\"user-code\">_O_.[[GetOwnProperty]]</emu-meta>(_P_).\n          1. If _desc_ is *undefined*, return *true*.\n          1. If _desc_.[[Configurable]] is *true*, then\n            1. Remove the own property with name _P_ from _O_.\n            1. Return *true*.\n          1. Return *false*.\n        "},{"head":{"InternalMethodHead":{"methodName":"OwnPropertyKeys","receiver":{"name":"O","ty":"Record[OrdinaryObject]","kind":{"Normal":{}}},"params":[],"retTy":"Normal[List[Record[Symbol] | String]]"}},"body":"\n  1. Return OrdinaryOwnPropertyKeys(_O_).","code":"\n        1. Return OrdinaryOwnPropertyKeys(_O_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"OrdinaryOwnPropertyKeys","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"List[Record[Symbol] | String]"}},"body":"\n  1. Let _keys_ be « ».\n  1. For each own property key _P_ of _O_ such that _P_ is an array index, in ascending numeric index order, do\n    1. Append _P_ to _keys_.\n  1. For each own property key _P_ of _O_ such that _P_ is a String and _P_ is not an array index, in ascending chronological order of property creation, do\n    1. Append _P_ to _keys_.\n  1. For each own property key _P_ of _O_ such that _P_ is a Record[Symbol], in ascending chronological order of property creation, do\n    1. Append _P_ to _keys_.\n  1. Return _keys_.","code":"\n          1. Let _keys_ be a new empty List.\n          1. For each own property key _P_ of _O_ such that _P_ is an array index, in ascending numeric index order, do\n            1. Append _P_ to _keys_.\n          1. For each own property key _P_ of _O_ such that _P_ is a String and _P_ is not an array index, in ascending chronological order of property creation, do\n            1. Append _P_ to _keys_.\n          1. For each own property key _P_ of _O_ such that _P_ is a Symbol, in ascending chronological order of property creation, do\n            1. Append _P_ to _keys_.\n          1. Return _keys_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"OrdinaryObjectCreate","params":[{"name":"proto","ty":"Record[Object] | Null","kind":{"Normal":{}}},{"name":"additionalInternalSlotsList","ty":"Unknown[\"a List of names of internal slots\"]","kind":{"Optional":{}}}],"retTy":"Record[Object]"}},"body":"\n  1. Let _internalSlotsList_ be « [[Prototype]], [[Extensible]] ».\n  1. If _additionalInternalSlotsList_ is present, set _internalSlotsList_ to the list-concatenation of _internalSlotsList_ and _additionalInternalSlotsList_.\n  1. Let _O_ be MakeBasicObject(_internalSlotsList_).\n  1. Set _O_.[[Prototype]] to _proto_.\n  1. Return _O_.","code":"\n        1. Let _internalSlotsList_ be « [[Prototype]], [[Extensible]] ».\n        1. If _additionalInternalSlotsList_ is present, set _internalSlotsList_ to the list-concatenation of _internalSlotsList_ and _additionalInternalSlotsList_.\n        1. Let _O_ be MakeBasicObject(_internalSlotsList_).\n        1. Set _O_.[[Prototype]] to _proto_.\n        1. Return _O_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"OrdinaryCreateFromConstructor","params":[{"name":"constructor","ty":"Record[Constructor]","kind":{"Normal":{}}},{"name":"intrinsicDefaultProto","ty":"String","kind":{"Normal":{}}},{"name":"internalSlotsList","ty":"Unknown[\"a List of names of internal slots\"]","kind":{"Optional":{}}}],"retTy":"Normal[Record[Object]] | Throw"}},"body":"\n  1. Assert: _intrinsicDefaultProto_ is this specification's name of an intrinsic object. The corresponding object must be an intrinsic that is intended to be used as the [[Prototype]] value of an object..\n  1. Let _proto_ be ? GetPrototypeFromConstructor(_constructor_, _intrinsicDefaultProto_).\n  1. If _internalSlotsList_ is present, let _slotsList_ be _internalSlotsList_.\n  1. Else, let _slotsList_ be « ».\n  1. Return OrdinaryObjectCreate(_proto_, _slotsList_).","code":"\n        1. Assert: _intrinsicDefaultProto_ is this specification's name of an intrinsic object. The corresponding object must be an intrinsic that is intended to be used as the [[Prototype]] value of an object.\n        1. Let _proto_ be ? GetPrototypeFromConstructor(_constructor_, _intrinsicDefaultProto_).\n        1. If _internalSlotsList_ is present, let _slotsList_ be _internalSlotsList_.\n        1. Else, let _slotsList_ be a new empty List.\n        1. Return OrdinaryObjectCreate(_proto_, _slotsList_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetPrototypeFromConstructor","params":[{"name":"constructor","ty":"Record[FunctionObject]","kind":{"Normal":{}}},{"name":"intrinsicDefaultProto","ty":"String","kind":{"Normal":{}}}],"retTy":"Normal[Record[Object]] | Throw"}},"body":"\n  1. Assert: _intrinsicDefaultProto_ is this specification's name of an intrinsic object. The corresponding object must be an intrinsic that is intended to be used as the [[Prototype]] value of an object..\n  1. Let _proto_ be ? Get(_constructor_, *\"prototype\"*).\n  1. If _proto_ is not a Record[Object], then\n    1. Let _realm_ be ? GetFunctionRealm(_constructor_).\n    1. Set _proto_ to _realm_.[[Intrinsics]][_intrinsicDefaultProto_].\n  1. Return _proto_.","code":"\n        1. Assert: _intrinsicDefaultProto_ is this specification's name of an intrinsic object. The corresponding object must be an intrinsic that is intended to be used as the [[Prototype]] value of an object.\n        1. Let _proto_ be ? Get(_constructor_, *\"prototype\"*).\n        1. If _proto_ is not an Object, then\n          1. Let _realm_ be ? GetFunctionRealm(_constructor_).\n          1. Set _proto_ to _realm_'s intrinsic object named _intrinsicDefaultProto_.\n        1. Return _proto_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"RequireInternalSlot","params":[{"name":"O","ty":"ESValue","kind":{"Normal":{}}},{"name":"internalSlot","ty":"String","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. If _O_ is not a Record[Object], throw a *TypeError* exception.\n  1. If _O_ does not have a _internalSlot_ internal slot, throw a *TypeError* exception.\n  1. Return ~unused~.","code":"\n        1. If _O_ is not an Object, throw a *TypeError* exception.\n        1. If _O_ does not have an _internalSlot_ internal slot, throw a *TypeError* exception.\n        1. Return ~unused~.\n      "},{"head":{"InternalMethodHead":{"methodName":"Call","receiver":{"name":"F","ty":"Record[ECMAScriptFunctionObject]","kind":{"Normal":{}}},"params":[{"name":"thisArgument","ty":"ESValue","kind":{"Normal":{}}},{"name":"argumentsList","ty":"List[ESValue]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Let _callerContext_ be the running execution context.\n  1. Let _calleeContext_ be PrepareForOrdinaryCall(_F_, *undefined*).\n  1. Assert: _calleeContext_ is now the running execution context..\n  1. If _F_.[[IsClassConstructor]] is *true*, then\n    1. Let _error_ be a newly created *TypeError* object.\n    1. NOTE: _error_ is created in _calleeContext_ with _F_'s associated Realm Record.\n    1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.\n    1. Return ThrowCompletion(_error_).\n  1. Perform OrdinaryCallBindThis(_F_, _calleeContext_, _thisArgument_).\n  1. Let _result_ be Completion(OrdinaryCallEvaluateBody(_F_, _argumentsList_)).\n  1. [id=\"step-call-pop-context-stack\"] Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.\n  1. If _result_ is a return completion, return _result_.[[Value]].\n  1. Perform ReturnIfAbrupt(_result_).\n  1. Return *undefined*.","code":"\n        1. Let _callerContext_ be the running execution context.\n        1. Let _calleeContext_ be PrepareForOrdinaryCall(_F_, *undefined*).\n        1. Assert: _calleeContext_ is now the running execution context.\n        1. If _F_.[[IsClassConstructor]] is *true*, then\n          1. Let _error_ be a newly created *TypeError* object.\n          1. NOTE: _error_ is created in _calleeContext_ with _F_'s associated Realm Record.\n          1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.\n          1. Return ThrowCompletion(_error_).\n        1. Perform OrdinaryCallBindThis(_F_, _calleeContext_, _thisArgument_).\n        1. Let _result_ be Completion(OrdinaryCallEvaluateBody(_F_, _argumentsList_)).\n        1. [id=\"step-call-pop-context-stack\"] Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.\n        1. If _result_ is a return completion, return _result_.[[Value]].\n        1. ReturnIfAbrupt(_result_).\n        1. Return *undefined*.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"PrepareForOrdinaryCall","params":[{"name":"F","ty":"Record[ECMAScriptFunctionObject]","kind":{"Normal":{}}},{"name":"newTarget","ty":"Record[Object] | Undefined","kind":{"Normal":{}}}],"retTy":"Record[ExecutionContext]"}},"body":"\n  1. Let _callerContext_ be the running execution context.\n  1. Let _calleeContext_ be ExecutionContext { }.\n  1. Set _calleeContext_.Function to _F_.\n  1. Let _calleeRealm_ be _F_.[[Realm]].\n  1. Set _calleeContext_.Realm to _calleeRealm_.\n  1. Set _calleeContext_.ScriptOrModule to _F_.[[ScriptOrModule]].\n  1. Let _localEnv_ be NewFunctionEnvironment(_F_, _newTarget_).\n  1. Set _calleeContext_.LexicalEnvironment to _localEnv_.\n  1. Set _calleeContext_.VariableEnvironment to _localEnv_.\n  1. Set _calleeContext_.PrivateEnvironment to _F_.[[PrivateEnvironment]].\n  1. If _callerContext_ is not already suspended, suspend _callerContext_.\n  1. Push _calleeContext_ onto the execution context stack; _calleeContext_ is now the running execution context.\n  1. NOTE: Any exception objects produced after this point are associated with _calleeRealm_.\n  1. Return _calleeContext_.","code":"\n          1. Let _callerContext_ be the running execution context.\n          1. Let _calleeContext_ be a new ECMAScript code execution context.\n          1. Set the Function of _calleeContext_ to _F_.\n          1. Let _calleeRealm_ be _F_.[[Realm]].\n          1. Set the Realm of _calleeContext_ to _calleeRealm_.\n          1. Set the ScriptOrModule of _calleeContext_ to _F_.[[ScriptOrModule]].\n          1. Let _localEnv_ be NewFunctionEnvironment(_F_, _newTarget_).\n          1. Set the LexicalEnvironment of _calleeContext_ to _localEnv_.\n          1. Set the VariableEnvironment of _calleeContext_ to _localEnv_.\n          1. Set the PrivateEnvironment of _calleeContext_ to _F_.[[PrivateEnvironment]].\n          1. If _callerContext_ is not already suspended, suspend _callerContext_.\n          1. Push _calleeContext_ onto the execution context stack; _calleeContext_ is now the running execution context.\n          1. NOTE: Any exception objects produced after this point are associated with _calleeRealm_.\n          1. Return _calleeContext_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"OrdinaryCallBindThis","params":[{"name":"F","ty":"Record[ECMAScriptFunctionObject]","kind":{"Normal":{}}},{"name":"calleeContext","ty":"Record[ExecutionContext]","kind":{"Normal":{}}},{"name":"thisArgument","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Let _thisMode_ be _F_.[[ThisMode]].\n  1. If _thisMode_ is ~lexical~, return ~unused~.\n  1. Let _calleeRealm_ be _F_.[[Realm]].\n  1. Let _localEnv_ be _calleeContext_.LexicalEnvironment.\n  1. If _thisMode_ is ~strict~, then\n    1. Let _thisValue_ be _thisArgument_.\n  1. Else,\n    1. If _thisArgument_ is either *undefined* or *null*, then\n      1. Let _globalEnv_ be _calleeRealm_.[[GlobalEnv]].\n      1. Assert: _globalEnv_ is a Record[GlobalEnvironmentRecord].\n      1. Let _thisValue_ be _globalEnv_.[[GlobalThisValue]].\n    1. Else,\n      1. Let _thisValue_ be ! ToObject(_thisArgument_).\n      1. NOTE: ToObject produces wrapper objects using _calleeRealm_.\n  1. Assert: _localEnv_ is a Record[FunctionEnvironmentRecord].\n  1. Assert: The next step never returns an abrupt completion because _localEnv_.[[ThisBindingStatus]] is not ~initialized~..\n  1. Perform ! _localEnv_.BindThisValue(_thisValue_).\n  1. Return ~unused~.","code":"\n          1. Let _thisMode_ be _F_.[[ThisMode]].\n          1. If _thisMode_ is ~lexical~, return ~unused~.\n          1. Let _calleeRealm_ be _F_.[[Realm]].\n          1. Let _localEnv_ be the LexicalEnvironment of _calleeContext_.\n          1. If _thisMode_ is ~strict~, then\n            1. Let _thisValue_ be _thisArgument_.\n          1. Else,\n            1. If _thisArgument_ is either *undefined* or *null*, then\n              1. Let _globalEnv_ be _calleeRealm_.[[GlobalEnv]].\n              1. Assert: _globalEnv_ is a Global Environment Record.\n              1. Let _thisValue_ be _globalEnv_.[[GlobalThisValue]].\n            1. Else,\n              1. Let _thisValue_ be ! ToObject(_thisArgument_).\n              1. NOTE: ToObject produces wrapper objects using _calleeRealm_.\n          1. Assert: _localEnv_ is a Function Environment Record.\n          1. Assert: The next step never returns an abrupt completion because _localEnv_.[[ThisBindingStatus]] is not ~initialized~.\n          1. Perform ! _localEnv_.BindThisValue(_thisValue_).\n          1. Return ~unused~.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionBody","idx":0,"subIdx":0,"rhsParams":[{"name":"FunctionStatementList","ty":"Ast[FunctionStatementList]","kind":{"Normal":{}}}]},"methodName":"EvaluateBody","isStatic":false,"withParams":[{"name":"functionObject","ty":"Record[ECMAScriptFunctionObject]","kind":{"Normal":{}}},{"name":"argumentsList","ty":"List[ESValue]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Return ? EvaluateFunctionBody of |FunctionBody| with arguments _functionObject_ and _argumentsList_.","code":"\n          1. Return ? EvaluateFunctionBody of |FunctionBody| with arguments _functionObject_ and _argumentsList_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ConciseBody","idx":0,"subIdx":0,"rhsParams":[{"name":"ExpressionBody","ty":"Ast[ExpressionBody]","kind":{"Normal":{}}}]},"methodName":"EvaluateBody","isStatic":false,"withParams":[{"name":"functionObject","ty":"Record[ECMAScriptFunctionObject]","kind":{"Normal":{}}},{"name":"argumentsList","ty":"List[ESValue]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Return ? EvaluateConciseBody of |ConciseBody| with arguments _functionObject_ and _argumentsList_.","code":"\n          1. Return ? EvaluateConciseBody of |ConciseBody| with arguments _functionObject_ and _argumentsList_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorBody","idx":0,"subIdx":0,"rhsParams":[{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"EvaluateBody","isStatic":false,"withParams":[{"name":"functionObject","ty":"Record[ECMAScriptFunctionObject]","kind":{"Normal":{}}},{"name":"argumentsList","ty":"List[ESValue]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Return ? EvaluateGeneratorBody of |GeneratorBody| with arguments _functionObject_ and _argumentsList_.","code":"\n          1. Return ? EvaluateGeneratorBody of |GeneratorBody| with arguments _functionObject_ and _argumentsList_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorBody","idx":0,"subIdx":0,"rhsParams":[{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"EvaluateBody","isStatic":false,"withParams":[{"name":"functionObject","ty":"Record[ECMAScriptFunctionObject]","kind":{"Normal":{}}},{"name":"argumentsList","ty":"List[ESValue]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Return ? EvaluateAsyncGeneratorBody of |AsyncGeneratorBody| with arguments _functionObject_ and _argumentsList_.","code":"\n          1. Return ? EvaluateAsyncGeneratorBody of |AsyncGeneratorBody| with arguments _functionObject_ and _argumentsList_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncFunctionBody","idx":0,"subIdx":0,"rhsParams":[{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"EvaluateBody","isStatic":false,"withParams":[{"name":"functionObject","ty":"Record[ECMAScriptFunctionObject]","kind":{"Normal":{}}},{"name":"argumentsList","ty":"List[ESValue]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Return ? EvaluateAsyncFunctionBody of |AsyncFunctionBody| with arguments _functionObject_ and _argumentsList_.","code":"\n          1. Return ? EvaluateAsyncFunctionBody of |AsyncFunctionBody| with arguments _functionObject_ and _argumentsList_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncConciseBody","idx":0,"subIdx":0,"rhsParams":[{"name":"ExpressionBody","ty":"Ast[ExpressionBody]","kind":{"Normal":{}}}]},"methodName":"EvaluateBody","isStatic":false,"withParams":[{"name":"functionObject","ty":"Record[ECMAScriptFunctionObject]","kind":{"Normal":{}}},{"name":"argumentsList","ty":"List[ESValue]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Return ? EvaluateAsyncConciseBody of |AsyncConciseBody| with arguments _functionObject_ and _argumentsList_.","code":"\n          1. Return ? EvaluateAsyncConciseBody of |AsyncConciseBody| with arguments _functionObject_ and _argumentsList_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Initializer","idx":0,"subIdx":0,"rhsParams":[{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"EvaluateBody","isStatic":false,"withParams":[{"name":"functionObject","ty":"Record[ECMAScriptFunctionObject]","kind":{"Normal":{}}},{"name":"argumentsList","ty":"List[ESValue]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Assert: _argumentsList_ is empty.\n  1. Assert: _functionObject_.[[ClassFieldInitializerName]] is not ~empty~.\n  1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true*, then\n    1. Let _value_ be ? NamedEvaluation of |Initializer| with argument _functionObject_.[[ClassFieldInitializerName]].\n  1. Else,\n    1. Let _rhs_ be ? the result of evaluating |AssignmentExpression|.\n    1. Let _value_ be ? GetValue(_rhs_).\n  1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _value_, [[Target]]: ~empty~ }.","code":"\n          1. Assert: _argumentsList_ is empty.\n          1. Assert: _functionObject_.[[ClassFieldInitializerName]] is not ~empty~.\n          1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true*, then\n            1. Let _value_ be ? NamedEvaluation of |Initializer| with argument _functionObject_.[[ClassFieldInitializerName]].\n          1. Else,\n            1. Let _rhs_ be ? Evaluation of |AssignmentExpression|.\n            1. Let _value_ be ? GetValue(_rhs_).\n          1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _value_, [[Target]]: ~empty~ }.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassStaticBlockBody","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassStaticBlockStatementList","ty":"Ast[ClassStaticBlockStatementList]","kind":{"Normal":{}}}]},"methodName":"EvaluateBody","isStatic":false,"withParams":[{"name":"functionObject","ty":"Record[ECMAScriptFunctionObject]","kind":{"Normal":{}}},{"name":"argumentsList","ty":"List[ESValue]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Assert: _argumentsList_ is empty.\n  1. Return ? EvaluateClassStaticBlockBody of |ClassStaticBlockBody| with argument _functionObject_.","code":"\n          1. Assert: _argumentsList_ is empty.\n          1. Return ? EvaluateClassStaticBlockBody of |ClassStaticBlockBody| with argument _functionObject_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"OrdinaryCallEvaluateBody","params":[{"name":"F","ty":"Record[ECMAScriptFunctionObject]","kind":{"Normal":{}}},{"name":"argumentsList","ty":"List[ESValue]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Return ? EvaluateBody of _F_.[[ECMAScriptCode]] with arguments _F_ and _argumentsList_.","code":"\n          1. Return ? EvaluateBody of _F_.[[ECMAScriptCode]] with arguments _F_ and _argumentsList_.\n        "},{"head":{"InternalMethodHead":{"methodName":"Construct","receiver":{"name":"F","ty":"Record[ECMAScriptFunctionObject]","kind":{"Normal":{}}},"params":[{"name":"argumentsList","ty":"List[ESValue]","kind":{"Normal":{}}},{"name":"newTarget","ty":"Record[Constructor]","kind":{"Normal":{}}}],"retTy":"Normal[Record[Object]] | Throw"}},"body":"\n  1. Let _callerContext_ be the running execution context.\n  1. Let _kind_ be _F_.[[ConstructorKind]].\n  1. If _kind_ is ~base~, then\n    1. Let _thisArgument_ be ? OrdinaryCreateFromConstructor(_newTarget_, *\"%Object.prototype%\"*).\n  1. Let _calleeContext_ be PrepareForOrdinaryCall(_F_, _newTarget_).\n  1. Assert: _calleeContext_ is now the running execution context..\n  1. If _kind_ is ~base~, then\n    1. Perform OrdinaryCallBindThis(_F_, _calleeContext_, _thisArgument_).\n    1. Let _initializeResult_ be Completion(InitializeInstanceElements(_thisArgument_, _F_)).\n    1. If _initializeResult_ is an abrupt completion, then\n      1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.\n      1. Return ? _initializeResult_.\n  1. Let _constructorEnv_ be _calleeContext_.LexicalEnvironment.\n  1. Let _result_ be Completion(OrdinaryCallEvaluateBody(_F_, _argumentsList_)).\n  1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.\n  1. If _result_ is a return completion, then\n    1. If _result_.[[Value]] is a Record[Object], return _result_.[[Value]].\n    1. If _kind_ is ~base~, return _thisArgument_.\n    1. If _result_.[[Value]] is not *undefined*, throw a *TypeError* exception.\n  1. Else,\n    1. Perform ReturnIfAbrupt(_result_).\n  1. Let _thisBinding_ be ? _constructorEnv_.GetThisBinding().\n  1. Assert: _thisBinding_ is a Record[Object].\n  1. Return _thisBinding_.","code":"\n        1. Let _callerContext_ be the running execution context.\n        1. Let _kind_ be _F_.[[ConstructorKind]].\n        1. If _kind_ is ~base~, then\n          1. Let _thisArgument_ be ? OrdinaryCreateFromConstructor(_newTarget_, *\"%Object.prototype%\"*).\n        1. Let _calleeContext_ be PrepareForOrdinaryCall(_F_, _newTarget_).\n        1. Assert: _calleeContext_ is now the running execution context.\n        1. If _kind_ is ~base~, then\n          1. Perform OrdinaryCallBindThis(_F_, _calleeContext_, _thisArgument_).\n          1. Let _initializeResult_ be Completion(InitializeInstanceElements(_thisArgument_, _F_)).\n          1. If _initializeResult_ is an abrupt completion, then\n            1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.\n            1. Return ? _initializeResult_.\n        1. Let _constructorEnv_ be the LexicalEnvironment of _calleeContext_.\n        1. Let _result_ be Completion(OrdinaryCallEvaluateBody(_F_, _argumentsList_)).\n        1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.\n        1. If _result_ is a return completion, then\n          1. If _result_.[[Value]] is an Object, return _result_.[[Value]].\n          1. If _kind_ is ~base~, return _thisArgument_.\n          1. If _result_.[[Value]] is not *undefined*, throw a *TypeError* exception.\n        1. Else,\n          1. ReturnIfAbrupt(_result_).\n        1. Let _thisBinding_ be ? _constructorEnv_.GetThisBinding().\n        1. Assert: _thisBinding_ is an Object.\n        1. Return _thisBinding_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"OrdinaryFunctionCreate","params":[{"name":"functionPrototype","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"sourceText","ty":"Unknown[\"a sequence of Unicode code points\"]","kind":{"Normal":{}}},{"name":"ParameterList","ty":"Ast","kind":{"Normal":{}}},{"name":"Body","ty":"Ast","kind":{"Normal":{}}},{"name":"thisMode","ty":"Enum[~lexical-this~, ~non-lexical-this~]","kind":{"Normal":{}}},{"name":"env","ty":"Record[EnvironmentRecord]","kind":{"Normal":{}}},{"name":"privateEnv","ty":"Record[PrivateEnvironmentRecord] | Null","kind":{"Normal":{}}}],"retTy":"Record[ECMAScriptFunctionObject]"}},"body":"\n  1. Let _internalSlotsList_ be the internal slots listed in <emu-xref href=\"#table-internal-slots-of-ecmascript-function-objects\"></emu-xref>.\n  1. Let _F_ be OrdinaryObjectCreate(_functionPrototype_, _internalSlotsList_).\n  1. Set _F_.[[Call]] to the definition specified in <emu-xref href=\"#sec-ecmascript-function-objects-call-thisargument-argumentslist\"></emu-xref>.\n  1. Set _F_.[[SourceText]] to _sourceText_.\n  1. Set _F_.[[FormalParameters]] to _ParameterList_.\n  1. Set _F_.[[ECMAScriptCode]] to _Body_.\n  1. If the source text matched by _Body_ is strict mode code, let _Strict_ be *true*.\n  1. Else, let _Strict_ be *false*.\n  1. Set _F_.[[Strict]] to _Strict_.\n  1. If _thisMode_ is ~lexical-this~, set _F_.[[ThisMode]] to ~lexical~.\n  1. Else if _Strict_ is *true*, set _F_.[[ThisMode]] to ~strict~.\n  1. Else, set _F_.[[ThisMode]] to ~global~.\n  1. Set _F_.[[IsClassConstructor]] to *false*.\n  1. Set _F_.[[Environment]] to _env_.\n  1. Set _F_.[[PrivateEnvironment]] to _privateEnv_.\n  1. Set _F_.[[ScriptOrModule]] to GetActiveScriptOrModule().\n  1. Set _F_.[[Realm]] to the current Realm Record.\n  1. Set _F_.[[HomeObject]] to *undefined*.\n  1. Set _F_.[[Fields]] to « ».\n  1. Set _F_.[[PrivateMethods]] to « ».\n  1. Set _F_.[[ClassFieldInitializerName]] to ~empty~.\n  1. Let _len_ be ExpectedArgumentCount of _ParameterList_.\n  1. Perform SetFunctionLength(_F_, _len_).\n  1. Return _F_.","code":"\n        1. Let _internalSlotsList_ be the internal slots listed in <emu-xref href=\"#table-internal-slots-of-ecmascript-function-objects\"></emu-xref>.\n        1. Let _F_ be OrdinaryObjectCreate(_functionPrototype_, _internalSlotsList_).\n        1. Set _F_.[[Call]] to the definition specified in <emu-xref href=\"#sec-ecmascript-function-objects-call-thisargument-argumentslist\"></emu-xref>.\n        1. Set _F_.[[SourceText]] to _sourceText_.\n        1. Set _F_.[[FormalParameters]] to _ParameterList_.\n        1. Set _F_.[[ECMAScriptCode]] to _Body_.\n        1. If the source text matched by _Body_ is strict mode code, let _Strict_ be *true*; else let _Strict_ be *false*.\n        1. Set _F_.[[Strict]] to _Strict_.\n        1. If _thisMode_ is ~lexical-this~, set _F_.[[ThisMode]] to ~lexical~.\n        1. Else if _Strict_ is *true*, set _F_.[[ThisMode]] to ~strict~.\n        1. Else, set _F_.[[ThisMode]] to ~global~.\n        1. Set _F_.[[IsClassConstructor]] to *false*.\n        1. Set _F_.[[Environment]] to _env_.\n        1. Set _F_.[[PrivateEnvironment]] to _privateEnv_.\n        1. Set _F_.[[ScriptOrModule]] to GetActiveScriptOrModule().\n        1. Set _F_.[[Realm]] to the current Realm Record.\n        1. Set _F_.[[HomeObject]] to *undefined*.\n        1. Set _F_.[[Fields]] to a new empty List.\n        1. Set _F_.[[PrivateMethods]] to a new empty List.\n        1. Set _F_.[[ClassFieldInitializerName]] to ~empty~.\n        1. Let _len_ be the ExpectedArgumentCount of _ParameterList_.\n        1. Perform SetFunctionLength(_F_, _len_).\n        1. Return _F_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AddRestrictedFunctionProperties","params":[{"name":"F","ty":"Record[FunctionObject]","kind":{"Normal":{}}},{"name":"realm","ty":"Record[RealmRecord]","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Assert: _realm_.[[Intrinsics]].[[%ThrowTypeError%]] exists and has been initialized..\n  1. Let _thrower_ be _realm_.[[Intrinsics]].[[%ThrowTypeError%]].\n  1. Perform ! DefinePropertyOrThrow(_F_, *\"caller\"*, PropertyDescriptor { [[Get]]: _thrower_, [[Set]]: _thrower_, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n  1. Perform ! DefinePropertyOrThrow(_F_, *\"arguments\"*, PropertyDescriptor { [[Get]]: _thrower_, [[Set]]: _thrower_, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n  1. Return ~unused~.","code":"\n        1. Assert: _realm_.[[Intrinsics]].[[%ThrowTypeError%]] exists and has been initialized.\n        1. Let _thrower_ be _realm_.[[Intrinsics]].[[%ThrowTypeError%]].\n        1. Perform ! DefinePropertyOrThrow(_F_, *\"caller\"*, PropertyDescriptor { [[Get]]: _thrower_, [[Set]]: _thrower_, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n        1. Perform ! DefinePropertyOrThrow(_F_, *\"arguments\"*, PropertyDescriptor { [[Get]]: _thrower_, [[Set]]: _thrower_, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n        1. Return ~unused~.\n      "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"ThrowTypeError"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Throw a *TypeError* exception.","code":"\n          1. Throw a *TypeError* exception.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"MakeConstructor","params":[{"name":"F","ty":"Record[BuiltinFunctionObject | ECMAScriptFunctionObject]","kind":{"Normal":{}}},{"name":"writablePrototype","ty":"Boolean","kind":{"Optional":{}}},{"name":"prototype","ty":"Record[Object]","kind":{"Optional":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. If _F_ is a Record[ECMAScriptFunctionObject], then\n    1. Assert: IsConstructor(_F_) is *false*.\n    1. Assert: _F_ is an extensible object that does not have a *\"prototype\"* own property..\n    1. Set _F_.[[Construct]] to the definition specified in <emu-xref href=\"#sec-ecmascript-function-objects-construct-argumentslist-newtarget\"></emu-xref>.\n  1. Else,\n    1. Set _F_.[[Construct]] to the definition specified in <emu-xref href=\"#sec-built-in-function-objects-construct-argumentslist-newtarget\"></emu-xref>.\n  1. Set _F_.[[ConstructorKind]] to ~base~.\n  1. If _writablePrototype_ is not present, set _writablePrototype_ to *true*.\n  1. If _prototype_ is not present, then\n    1. Set _prototype_ to OrdinaryObjectCreate(%Object.prototype%).\n    1. Perform ! DefinePropertyOrThrow(_prototype_, *\"constructor\"*, PropertyDescriptor { [[Value]]: _F_, [[Writable]]: _writablePrototype_, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n  1. Perform ! DefinePropertyOrThrow(_F_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: _writablePrototype_, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n  1. Return ~unused~.","code":"\n        1. If _F_ is an ECMAScript function object, then\n          1. Assert: IsConstructor(_F_) is *false*.\n          1. Assert: _F_ is an extensible object that does not have a *\"prototype\"* own property.\n          1. Set _F_.[[Construct]] to the definition specified in <emu-xref href=\"#sec-ecmascript-function-objects-construct-argumentslist-newtarget\"></emu-xref>.\n        1. Else,\n          1. Set _F_.[[Construct]] to the definition specified in <emu-xref href=\"#sec-built-in-function-objects-construct-argumentslist-newtarget\"></emu-xref>.\n        1. Set _F_.[[ConstructorKind]] to ~base~.\n        1. If _writablePrototype_ is not present, set _writablePrototype_ to *true*.\n        1. If _prototype_ is not present, then\n          1. Set _prototype_ to OrdinaryObjectCreate(%Object.prototype%).\n          1. Perform ! DefinePropertyOrThrow(_prototype_, *\"constructor\"*, PropertyDescriptor { [[Value]]: _F_, [[Writable]]: _writablePrototype_, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n        1. Perform ! DefinePropertyOrThrow(_F_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: _writablePrototype_, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n        1. Return ~unused~.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"MakeClassConstructor","params":[{"name":"F","ty":"Record[ECMAScriptFunctionObject]","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Assert: _F_.[[IsClassConstructor]] is *false*.\n  1. Set _F_.[[IsClassConstructor]] to *true*.\n  1. Return ~unused~.","code":"\n        1. Assert: _F_.[[IsClassConstructor]] is *false*.\n        1. Set _F_.[[IsClassConstructor]] to *true*.\n        1. Return ~unused~.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"MakeMethod","params":[{"name":"F","ty":"Record[ECMAScriptFunctionObject]","kind":{"Normal":{}}},{"name":"homeObject","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Set _F_.[[HomeObject]] to _homeObject_.\n  1. Return ~unused~.","code":"\n        1. Set _F_.[[HomeObject]] to _homeObject_.\n        1. Return ~unused~.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"DefineMethodProperty","params":[{"name":"homeObject","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"key","ty":"Record[PrivateName | Symbol] | String","kind":{"Normal":{}}},{"name":"closure","ty":"Record[FunctionObject]","kind":{"Normal":{}}},{"name":"enumerable","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[Record[PrivateElement] | Enum[~unused~]] | Abrupt"}},"body":"\n  1. Assert: _homeObject_ is an ordinary, extensible object..\n  1. If _key_ is a Record[PrivateName], then\n    1. Return PrivateElement { [[Key]]: _key_, [[Kind]]: ~method~, [[Value]]: _closure_ }.\n  1. Else,\n    1. Let _desc_ be PropertyDescriptor { [[Value]]: _closure_, [[Writable]]: *true*, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.\n    1. Perform ? DefinePropertyOrThrow(_homeObject_, _key_, _desc_).\n    1. NOTE: DefinePropertyOrThrow only returns an abrupt completion when attempting to define a class static method whose _key_ is *\"prototype\"*.\n    1. Return ~unused~.","code":"\n        1. Assert: _homeObject_ is an ordinary, extensible object.\n        1. If _key_ is a Private Name, then\n          1. Return PrivateElement { [[Key]]: _key_, [[Kind]]: ~method~, [[Value]]: _closure_ }.\n        1. Else,\n          1. Let _desc_ be the PropertyDescriptor { [[Value]]: _closure_, [[Writable]]: *true*, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.\n          1. Perform ? DefinePropertyOrThrow(_homeObject_, _key_, _desc_).\n          1. NOTE: DefinePropertyOrThrow only returns an abrupt completion when attempting to define a class static method whose _key_ is *\"prototype\"*.\n          1. Return ~unused~.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"SetFunctionName","params":[{"name":"F","ty":"Record[FunctionObject]","kind":{"Normal":{}}},{"name":"name","ty":"Record[PrivateName | Symbol] | String","kind":{"Normal":{}}},{"name":"prefix","ty":"String","kind":{"Optional":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Assert: _F_ is an extensible object that does not have a *\"name\"* own property..\n  1. If _name_ is a Record[Symbol], then\n    1. Let _description_ be _name_.[[Description]].\n    1. If _description_ is *undefined*, set _name_ to *\"\"*.\n    1. Else, set _name_ to the string-concatenation of *\"[\"*, _description_, and *\"]\"*.\n  1. Else if _name_ is a Record[PrivateName], then\n    1. Set _name_ to _name_.[[Description]].\n  1. If _F_ has a [[InitialName]] internal slot, then\n    1. Set _F_.[[InitialName]] to _name_.\n  1. If _prefix_ is present, then\n    1. Set _name_ to the string-concatenation of _prefix_, 0x0020 (SPACE), and _name_.\n    1. If _F_ has a [[InitialName]] internal slot, then\n      1. Optionally, set _F_.[[InitialName]] to _name_.\n  1. Perform ! DefinePropertyOrThrow(_F_, *\"name\"*, PropertyDescriptor { [[Value]]: _name_, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n  1. Return ~unused~.","code":"\n        1. Assert: _F_ is an extensible object that does not have a *\"name\"* own property.\n        1. If _name_ is a Symbol, then\n          1. Let _description_ be _name_'s [[Description]] value.\n          1. If _description_ is *undefined*, set _name_ to the empty String.\n          1. Else, set _name_ to the string-concatenation of *\"[\"*, _description_, and *\"]\"*.\n        1. Else if _name_ is a Private Name, then\n          1. Set _name_ to _name_.[[Description]].\n        1. If _F_ has an [[InitialName]] internal slot, then\n          1. Set _F_.[[InitialName]] to _name_.\n        1. If _prefix_ is present, then\n          1. Set _name_ to the string-concatenation of _prefix_, the code unit 0x0020 (SPACE), and _name_.\n          1. If _F_ has an [[InitialName]] internal slot, then\n            1. Optionally, set _F_.[[InitialName]] to _name_.\n        1. Perform ! DefinePropertyOrThrow(_F_, *\"name\"*, PropertyDescriptor { [[Value]]: _name_, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n        1. Return ~unused~.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"SetFunctionLength","params":[{"name":"F","ty":"Record[FunctionObject]","kind":{"Normal":{}}},{"name":"length","ty":"NonNegInt | +INF","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Assert: _F_ is an extensible object that does not have a *\"length\"* own property..\n  1. Perform ! DefinePropertyOrThrow(_F_, *\"length\"*, PropertyDescriptor { [[Value]]: 𝔽(_length_), [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n  1. Return ~unused~.","code":"\n        1. Assert: _F_ is an extensible object that does not have a *\"length\"* own property.\n        1. Perform ! DefinePropertyOrThrow(_F_, *\"length\"*, PropertyDescriptor { [[Value]]: 𝔽(_length_), [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n        1. Return ~unused~.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"FunctionDeclarationInstantiation","params":[{"name":"func","ty":"Record[ECMAScriptFunctionObject]","kind":{"Normal":{}}},{"name":"argumentsList","ty":"List[ESValue]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _calleeContext_ be the running execution context.\n  1. Let _code_ be _func_.[[ECMAScriptCode]].\n  1. Let _strict_ be _func_.[[Strict]].\n  1. Let _formals_ be _func_.[[FormalParameters]].\n  1. Let _parameterNames_ be BoundNames of _formals_.\n  1. If _parameterNames_ is duplicate entries, let _hasDuplicates_ be *true*.\n  1. Else, let _hasDuplicates_ be *false*.\n  1. Let _simpleParameterList_ be IsSimpleParameterList of _formals_.\n  1. Let _hasParameterExpressions_ be ContainsExpression of _formals_.\n  1. Let _varNames_ be VarDeclaredNames of _code_.\n  1. Let _varDeclarations_ be VarScopedDeclarations of _code_.\n  1. Let _lexicalNames_ be LexicallyDeclaredNames of _code_.\n  1. Let _functionNames_ be « ».\n  1. Let _functionsToInitialize_ be « ».\n  1. For each _d_ of _varDeclarations_, in reverse List order, do\n    1. If _d_ is neither a Ast[VariableDeclaration], a Ast[ForBinding], nor a Ast[BindingIdentifier], then\n      1. Assert: _d_ is a Ast[AsyncFunctionDeclaration | AsyncGeneratorDeclaration | FunctionDeclaration | GeneratorDeclaration].\n      1. Let _fn_ be the sole element of BoundNames of _d_.\n      1. If _functionNames_ does not contain _fn_, then\n        1. Insert _fn_ as the first element of _functionNames_.\n        1. NOTE: If there are multiple function declarations for the same name, the last declaration is used.\n        1. Insert _d_ as the first element of _functionsToInitialize_.\n  1. Let _argumentsObjectNeeded_ be *true*.\n  1. If _func_.[[ThisMode]] is ~lexical~, then\n    1. NOTE: Arrow functions never have an arguments object.\n    1. Set _argumentsObjectNeeded_ to *false*.\n  1. Else if _parameterNames_ contains *\"arguments\"*, then\n    1. Set _argumentsObjectNeeded_ to *false*.\n  1. Else if _hasParameterExpressions_ is *false*, then\n    1. If _functionNames_ contains *\"arguments\"* or _lexicalNames_ contains *\"arguments\"*, then\n      1. Set _argumentsObjectNeeded_ to *false*.\n  1. If _strict_ is *true* or _hasParameterExpressions_ is *false*, then\n    1. NOTE: Only a single Environment Record is needed for the parameters, since calls to `eval` in strict mode code cannot create new bindings which are visible outside of the `eval`.\n    1. Let _env_ be _calleeContext_.LexicalEnvironment.\n  1. Else,\n    1. NOTE: A separate Environment Record is needed to ensure that bindings created by direct eval calls in the formal parameter list are outside the environment where parameters are declared.\n    1. Let _calleeEnv_ be _calleeContext_.LexicalEnvironment.\n    1. Let _env_ be NewDeclarativeEnvironment(_calleeEnv_).\n    1. Assert: _calleeContext_.VariableEnvironment is _calleeEnv_.\n    1. Set _calleeContext_.LexicalEnvironment to _env_.\n  1. For each String _paramName_ of _parameterNames_, do\n    1. Let _alreadyDeclared_ be ! _env_.HasBinding(_paramName_).\n    1. NOTE: Early errors ensure that duplicate parameter names can only occur in non-strict functions that do not have parameter default values or rest parameters.\n    1. If _alreadyDeclared_ is *false*, then\n      1. Perform ! _env_.CreateMutableBinding(_paramName_, *false*).\n      1. If _hasDuplicates_ is *true*, then\n        1. Perform ! _env_.InitializeBinding(_paramName_, *undefined*).\n  1. If _argumentsObjectNeeded_ is *true*, then\n    1. If _strict_ is *true* or _simpleParameterList_ is *false*, then\n      1. Let _ao_ be CreateUnmappedArgumentsObject(_argumentsList_).\n    1. Else,\n      1. NOTE: A mapped argument object is only provided for non-strict functions that don't have a rest parameter, any parameter default value initializers, or any destructured parameters.\n      1. Let _ao_ be CreateMappedArgumentsObject(_func_, _formals_, _argumentsList_, _env_).\n    1. If _strict_ is *true*, then\n      1. Perform ! _env_.CreateImmutableBinding(*\"arguments\"*, *false*).\n      1. NOTE: In strict mode code early errors prevent attempting to assign to this binding, so its mutability is not observable.\n    1. Else,\n      1. Perform ! _env_.CreateMutableBinding(*\"arguments\"*, *false*).\n    1. Perform ! _env_.InitializeBinding(*\"arguments\"*, _ao_).\n    1. Let _parameterBindings_ be the list-concatenation of _parameterNames_ and « *\"arguments\"* ».\n  1. Else,\n    1. Let _parameterBindings_ be _parameterNames_.\n  1. Let _iteratorRecord_ be CreateListIteratorRecord(_argumentsList_).\n  1. If _hasDuplicates_ is *true*, then\n    1. Perform ? IteratorBindingInitialization of _formals_ with arguments _iteratorRecord_ and *undefined*.\n  1. Else,\n    1. Perform ? IteratorBindingInitialization of _formals_ with arguments _iteratorRecord_ and _env_.\n  1. If _hasParameterExpressions_ is *false*, then\n    1. NOTE: Only a single Environment Record is needed for the parameters and top-level vars.\n    1. Let _instantiatedVarNames_ be a copy of the List _parameterBindings_.\n    1. For each _n_ of _varNames_, do\n      1. If _instantiatedVarNames_ does not contain _n_, then\n        1. Append _n_ to _instantiatedVarNames_.\n        1. Perform ! _env_.CreateMutableBinding(_n_, *false*).\n        1. Perform ! _env_.InitializeBinding(_n_, *undefined*).\n    1. Let _varEnv_ be _env_.\n  1. Else,\n    1. NOTE: A separate Environment Record is needed to ensure that closures created by expressions in the formal parameter list do not have visibility of declarations in the function body.\n    1. Let _varEnv_ be NewDeclarativeEnvironment(_env_).\n    1. Set _calleeContext_.VariableEnvironment to _varEnv_.\n    1. Let _instantiatedVarNames_ be « ».\n    1. For each _n_ of _varNames_, do\n      1. If _instantiatedVarNames_ does not contain _n_, then\n        1. Append _n_ to _instantiatedVarNames_.\n        1. Perform ! _varEnv_.CreateMutableBinding(_n_, *false*).\n        1. If _parameterBindings_ does not contain _n_ or _functionNames_ contains _n_, then\n          1. Let _initialValue_ be *undefined*.\n        1. Else,\n          1. Let _initialValue_ be ! _env_.GetBindingValue(_n_, *false*).\n        1. Perform ! _varEnv_.InitializeBinding(_n_, _initialValue_).\n        1. NOTE: A var with the same name as a formal parameter initially has the same value as the corresponding initialized parameter.\n  1. [id=\"step-functiondeclarationinstantiation-web-compat-insertion-point\"] NOTE: Annex <emu-xref href=\"#sec-web-compat-functiondeclarationinstantiation\"></emu-xref> adds additional steps at this point.\n  1. If _strict_ is *false*, then\n    1. Let _lexEnv_ be NewDeclarativeEnvironment(_varEnv_).\n    1. NOTE: Non-strict functions use a separate Environment Record for top-level lexical declarations so that a direct eval can determine whether any var scoped declarations introduced by the eval code conflict with pre-existing top-level lexically scoped declarations. This is not needed for strict functions because a strict direct eval always places all declarations into a new Environment Record.\n  1. Else,\n    1. Let _lexEnv_ be _varEnv_.\n  1. Set _calleeContext_.LexicalEnvironment to _lexEnv_.\n  1. Let _lexDeclarations_ be LexicallyScopedDeclarations of _code_.\n  1. For each _d_ of _lexDeclarations_, do\n    1. NOTE: A lexically declared name cannot be the same as a function/generator declaration, formal parameter, or a var name. Lexically declared names are only instantiated here but not initialized.\n    1. For each _dn_ of BoundNames of _d_, do\n      1. If IsConstantDeclaration of _d_ is *true*, then\n        1. Perform ! _lexEnv_.CreateImmutableBinding(_dn_, *true*).\n      1. Else,\n        1. Perform ! _lexEnv_.CreateMutableBinding(_dn_, *false*).\n  1. Let _privateEnv_ be _calleeContext_.PrivateEnvironment.\n  1. For each Ast _f_ of _functionsToInitialize_, do\n    1. Let _fn_ be the sole element of BoundNames of _f_.\n    1. Let _fo_ be InstantiateFunctionObject of _f_ with arguments _lexEnv_ and _privateEnv_.\n    1. Perform ! _varEnv_.SetMutableBinding(_fn_, _fo_, *false*).\n  1. Return ~unused~.","code":"\n        1. Let _calleeContext_ be the running execution context.\n        1. Let _code_ be _func_.[[ECMAScriptCode]].\n        1. Let _strict_ be _func_.[[Strict]].\n        1. Let _formals_ be _func_.[[FormalParameters]].\n        1. Let _parameterNames_ be the BoundNames of _formals_.\n        1. If _parameterNames_ has any duplicate entries, let _hasDuplicates_ be *true*. Otherwise, let _hasDuplicates_ be *false*.\n        1. Let _simpleParameterList_ be IsSimpleParameterList of _formals_.\n        1. Let _hasParameterExpressions_ be ContainsExpression of _formals_.\n        1. Let _varNames_ be the VarDeclaredNames of _code_.\n        1. Let _varDeclarations_ be the VarScopedDeclarations of _code_.\n        1. Let _lexicalNames_ be the LexicallyDeclaredNames of _code_.\n        1. Let _functionNames_ be a new empty List.\n        1. Let _functionsToInitialize_ be a new empty List.\n        1. For each element _d_ of _varDeclarations_, in reverse List order, do\n          1. If _d_ is neither a |VariableDeclaration| nor a |ForBinding| nor a |BindingIdentifier|, then\n            1. Assert: _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|.\n            1. Let _fn_ be the sole element of the BoundNames of _d_.\n            1. If _functionNames_ does not contain _fn_, then\n              1. Insert _fn_ as the first element of _functionNames_.\n              1. NOTE: If there are multiple function declarations for the same name, the last declaration is used.\n              1. Insert _d_ as the first element of _functionsToInitialize_.\n        1. Let _argumentsObjectNeeded_ be *true*.\n        1. If _func_.[[ThisMode]] is ~lexical~, then\n          1. NOTE: Arrow functions never have an arguments object.\n          1. Set _argumentsObjectNeeded_ to *false*.\n        1. Else if _parameterNames_ contains *\"arguments\"*, then\n          1. Set _argumentsObjectNeeded_ to *false*.\n        1. Else if _hasParameterExpressions_ is *false*, then\n          1. If _functionNames_ contains *\"arguments\"* or _lexicalNames_ contains *\"arguments\"*, then\n            1. Set _argumentsObjectNeeded_ to *false*.\n        1. If _strict_ is *true* or _hasParameterExpressions_ is *false*, then\n          1. NOTE: Only a single Environment Record is needed for the parameters, since calls to `eval` in strict mode code cannot create new bindings which are visible outside of the `eval`.\n          1. Let _env_ be the LexicalEnvironment of _calleeContext_.\n        1. Else,\n          1. NOTE: A separate Environment Record is needed to ensure that bindings created by direct eval calls in the formal parameter list are outside the environment where parameters are declared.\n          1. Let _calleeEnv_ be the LexicalEnvironment of _calleeContext_.\n          1. Let _env_ be NewDeclarativeEnvironment(_calleeEnv_).\n          1. Assert: The VariableEnvironment of _calleeContext_ is _calleeEnv_.\n          1. Set the LexicalEnvironment of _calleeContext_ to _env_.\n        1. For each String _paramName_ of _parameterNames_, do\n          1. Let _alreadyDeclared_ be ! _env_.HasBinding(_paramName_).\n          1. NOTE: Early errors ensure that duplicate parameter names can only occur in non-strict functions that do not have parameter default values or rest parameters.\n          1. If _alreadyDeclared_ is *false*, then\n            1. Perform ! _env_.CreateMutableBinding(_paramName_, *false*).\n            1. If _hasDuplicates_ is *true*, then\n              1. Perform ! _env_.InitializeBinding(_paramName_, *undefined*).\n        1. If _argumentsObjectNeeded_ is *true*, then\n          1. If _strict_ is *true* or _simpleParameterList_ is *false*, then\n            1. Let _ao_ be CreateUnmappedArgumentsObject(_argumentsList_).\n          1. Else,\n            1. NOTE: A mapped argument object is only provided for non-strict functions that don't have a rest parameter, any parameter default value initializers, or any destructured parameters.\n            1. Let _ao_ be CreateMappedArgumentsObject(_func_, _formals_, _argumentsList_, _env_).\n          1. If _strict_ is *true*, then\n            1. Perform ! _env_.CreateImmutableBinding(*\"arguments\"*, *false*).\n            1. NOTE: In strict mode code early errors prevent attempting to assign to this binding, so its mutability is not observable.\n          1. Else,\n            1. Perform ! _env_.CreateMutableBinding(*\"arguments\"*, *false*).\n          1. Perform ! _env_.InitializeBinding(*\"arguments\"*, _ao_).\n          1. Let _parameterBindings_ be the list-concatenation of _parameterNames_ and « *\"arguments\"* ».\n        1. Else,\n          1. Let _parameterBindings_ be _parameterNames_.\n        1. Let _iteratorRecord_ be CreateListIteratorRecord(_argumentsList_).\n        1. If _hasDuplicates_ is *true*, then\n          1. Perform ? IteratorBindingInitialization of _formals_ with arguments _iteratorRecord_ and *undefined*.\n        1. Else,\n          1. Perform ? IteratorBindingInitialization of _formals_ with arguments _iteratorRecord_ and _env_.\n        1. If _hasParameterExpressions_ is *false*, then\n          1. NOTE: Only a single Environment Record is needed for the parameters and top-level vars.\n          1. Let _instantiatedVarNames_ be a copy of the List _parameterBindings_.\n          1. For each element _n_ of _varNames_, do\n            1. If _instantiatedVarNames_ does not contain _n_, then\n              1. Append _n_ to _instantiatedVarNames_.\n              1. Perform ! _env_.CreateMutableBinding(_n_, *false*).\n              1. Perform ! _env_.InitializeBinding(_n_, *undefined*).\n          1. Let _varEnv_ be _env_.\n        1. Else,\n          1. NOTE: A separate Environment Record is needed to ensure that closures created by expressions in the formal parameter list do not have visibility of declarations in the function body.\n          1. Let _varEnv_ be NewDeclarativeEnvironment(_env_).\n          1. Set the VariableEnvironment of _calleeContext_ to _varEnv_.\n          1. Let _instantiatedVarNames_ be a new empty List.\n          1. For each element _n_ of _varNames_, do\n            1. If _instantiatedVarNames_ does not contain _n_, then\n              1. Append _n_ to _instantiatedVarNames_.\n              1. Perform ! _varEnv_.CreateMutableBinding(_n_, *false*).\n              1. If _parameterBindings_ does not contain _n_, or if _functionNames_ contains _n_, then\n                1. Let _initialValue_ be *undefined*.\n              1. Else,\n                1. Let _initialValue_ be ! _env_.GetBindingValue(_n_, *false*).\n              1. Perform ! _varEnv_.InitializeBinding(_n_, _initialValue_).\n              1. NOTE: A var with the same name as a formal parameter initially has the same value as the corresponding initialized parameter.\n        1. [id=\"step-functiondeclarationinstantiation-web-compat-insertion-point\"] NOTE: Annex <emu-xref href=\"#sec-web-compat-functiondeclarationinstantiation\"></emu-xref> adds additional steps at this point.\n        1. If _strict_ is *false*, then\n          1. Let _lexEnv_ be NewDeclarativeEnvironment(_varEnv_).\n          1. NOTE: Non-strict functions use a separate Environment Record for top-level lexical declarations so that a direct eval can determine whether any var scoped declarations introduced by the eval code conflict with pre-existing top-level lexically scoped declarations. This is not needed for strict functions because a strict direct eval always places all declarations into a new Environment Record.\n        1. Else,\n          1. Let _lexEnv_ be _varEnv_.\n        1. Set the LexicalEnvironment of _calleeContext_ to _lexEnv_.\n        1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _code_.\n        1. For each element _d_ of _lexDeclarations_, do\n          1. NOTE: A lexically declared name cannot be the same as a function/generator declaration, formal parameter, or a var name. Lexically declared names are only instantiated here but not initialized.\n          1. For each element _dn_ of the BoundNames of _d_, do\n            1. If IsConstantDeclaration of _d_ is *true*, then\n              1. Perform ! _lexEnv_.CreateImmutableBinding(_dn_, *true*).\n            1. Else,\n              1. Perform ! _lexEnv_.CreateMutableBinding(_dn_, *false*).\n        1. Let _privateEnv_ be the PrivateEnvironment of _calleeContext_.\n        1. For each Parse Node _f_ of _functionsToInitialize_, do\n          1. Let _fn_ be the sole element of the BoundNames of _f_.\n          1. Let _fo_ be InstantiateFunctionObject of _f_ with arguments _lexEnv_ and _privateEnv_.\n          1. Perform ! _varEnv_.SetMutableBinding(_fn_, _fo_, *false*).\n        1. Return ~unused~.\n      "},{"head":{"InternalMethodHead":{"methodName":"Call","receiver":{"name":"F","ty":"Record[BuiltinFunctionObject]","kind":{"Normal":{}}},"params":[{"name":"thisArgument","ty":"ESValue","kind":{"Normal":{}}},{"name":"argumentsList","ty":"List[ESValue]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Return ? BuiltinCallOrConstruct(_F_, _thisArgument_, _argumentsList_, *undefined*).","code":"\n        1. Return ? BuiltinCallOrConstruct(_F_, _thisArgument_, _argumentsList_, *undefined*).\n      "},{"head":{"InternalMethodHead":{"methodName":"Construct","receiver":{"name":"F","ty":"Record[BuiltinFunctionObject]","kind":{"Normal":{}}},"params":[{"name":"argumentsList","ty":"List[ESValue]","kind":{"Normal":{}}},{"name":"newTarget","ty":"Record[Constructor]","kind":{"Normal":{}}}],"retTy":"Normal[Record[Object]] | Throw"}},"body":"\n  1. Return ? BuiltinCallOrConstruct(_F_, ~uninitialized~, _argumentsList_, _newTarget_).","code":"\n        1. Return ? BuiltinCallOrConstruct(_F_, ~uninitialized~, _argumentsList_, _newTarget_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"BuiltinCallOrConstruct","params":[{"name":"F","ty":"Record[BuiltinFunctionObject]","kind":{"Normal":{}}},{"name":"thisArgument","ty":"ESValue | Enum[~uninitialized~]","kind":{"Normal":{}}},{"name":"argumentsList","ty":"List[ESValue]","kind":{"Normal":{}}},{"name":"newTarget","ty":"Record[Constructor] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Let _callerContext_ be the running execution context.\n  1. If _callerContext_ is not already suspended, suspend _callerContext_.\n  1. Let _calleeContext_ be ExecutionContext { }.\n  1. Set _calleeContext_.Function to _F_.\n  1. Let _calleeRealm_ be _F_.[[Realm]].\n  1. Set _calleeContext_.Realm to _calleeRealm_.\n  1. Set _calleeContext_.ScriptOrModule to *null*.\n  1. Perform any necessary implementation-defined initialization of _calleeContext_.\n  1. Push _calleeContext_ onto the execution context stack; _calleeContext_ is now the running execution context.\n  1. [id=\"step-call-builtin-function-result\"] Let _result_ be the Completion Record that is <emu-meta effects=\"user-code\">the result of evaluating</emu-meta> _F_ in a manner that conforms to the specification of _F_. If _thisArgument_ is ~uninitialized~, the *this* value is uninitialized; otherwise, _thisArgument_ provides the *this* value. _argumentsList_ provides the named parameters. _newTarget_ provides the NewTarget value.\n  1. NOTE: If _F_ is defined in this document, “the specification of _F_” is the behaviour specified for it via algorithm steps or other means.\n  1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.\n  1. Return ? _result_.","code":"\n        1. Let _callerContext_ be the running execution context.\n        1. If _callerContext_ is not already suspended, suspend _callerContext_.\n        1. Let _calleeContext_ be a new execution context.\n        1. Set the Function of _calleeContext_ to _F_.\n        1. Let _calleeRealm_ be _F_.[[Realm]].\n        1. Set the Realm of _calleeContext_ to _calleeRealm_.\n        1. Set the ScriptOrModule of _calleeContext_ to *null*.\n        1. Perform any necessary implementation-defined initialization of _calleeContext_.\n        1. Push _calleeContext_ onto the execution context stack; _calleeContext_ is now the running execution context.\n        1. [id=\"step-call-builtin-function-result\"] Let _result_ be the Completion Record that is <emu-meta effects=\"user-code\">the result of evaluating</emu-meta> _F_ in a manner that conforms to the specification of _F_. If _thisArgument_ is ~uninitialized~, the *this* value is uninitialized; otherwise, _thisArgument_ provides the *this* value. _argumentsList_ provides the named parameters. _newTarget_ provides the NewTarget value.\n        1. NOTE: If _F_ is defined in this document, “the specification of _F_” is the behaviour specified for it via algorithm steps or other means.\n        1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.\n        1. Return ? _result_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CreateBuiltinFunction","params":[{"name":"behaviour","ty":"Unknown[\"an Abstract Closure, a set of algorithm steps, or some other definition of a function's behaviour provided in this specification\"]","kind":{"Normal":{}}},{"name":"length","ty":"NonNegInt | +INF","kind":{"Normal":{}}},{"name":"name","ty":"Record[PrivateName | Symbol] | String","kind":{"Normal":{}}},{"name":"additionalInternalSlotsList","ty":"Unknown[\"a List of names of internal slots\"]","kind":{"Normal":{}}},{"name":"realm","ty":"Record[RealmRecord]","kind":{"Optional":{}}},{"name":"prototype","ty":"Record[Object] | Null","kind":{"Optional":{}}},{"name":"prefix","ty":"String","kind":{"Optional":{}}}],"retTy":"Record[FunctionObject]"}},"body":"\n  1. If _realm_ is not present, set _realm_ to the current Realm Record.\n  1. If _prototype_ is not present, set _prototype_ to _realm_.[[Intrinsics]].[[%Function.prototype%]].\n  1. Let _internalSlotsList_ be a List containing the names of all the internal slots that <emu-xref href=\"#sec-built-in-function-objects\"></emu-xref> requires for the built-in function object that is about to be created.\n  1. Append to _internalSlotsList_ the elements of _additionalInternalSlotsList_.\n  1. Let _func_ be a new built-in function object that, when called, performs the action described by _behaviour_ using the provided arguments as the values of the corresponding parameters specified by _behaviour_. The new function object has internal slots whose names are the elements of _internalSlotsList_, and an [[InitialName]] internal slot.\n  1. Set _func_.[[Prototype]] to _prototype_.\n  1. Set _func_.[[Extensible]] to *true*.\n  1. Set _func_.[[Realm]] to _realm_.\n  1. Set _func_.[[InitialName]] to *null*.\n  1. Perform SetFunctionLength(_func_, _length_).\n  1. If _prefix_ is not present, then\n    1. Perform SetFunctionName(_func_, _name_).\n  1. Else,\n    1. Perform SetFunctionName(_func_, _name_, _prefix_).\n  1. Return _func_.","code":"\n        1. If _realm_ is not present, set _realm_ to the current Realm Record.\n        1. If _prototype_ is not present, set _prototype_ to _realm_.[[Intrinsics]].[[%Function.prototype%]].\n        1. Let _internalSlotsList_ be a List containing the names of all the internal slots that <emu-xref href=\"#sec-built-in-function-objects\"></emu-xref> requires for the built-in function object that is about to be created.\n        1. Append to _internalSlotsList_ the elements of _additionalInternalSlotsList_.\n        1. Let _func_ be a new built-in function object that, when called, performs the action described by _behaviour_ using the provided arguments as the values of the corresponding parameters specified by _behaviour_. The new function object has internal slots whose names are the elements of _internalSlotsList_, and an [[InitialName]] internal slot.\n        1. Set _func_.[[Prototype]] to _prototype_.\n        1. Set _func_.[[Extensible]] to *true*.\n        1. Set _func_.[[Realm]] to _realm_.\n        1. Set _func_.[[InitialName]] to *null*.\n        1. Perform SetFunctionLength(_func_, _length_).\n        1. If _prefix_ is not present, then\n          1. Perform SetFunctionName(_func_, _name_).\n        1. Else,\n          1. Perform SetFunctionName(_func_, _name_, _prefix_).\n        1. Return _func_.\n      "},{"head":{"InternalMethodHead":{"methodName":"Call","receiver":{"name":"F","ty":"Record[BoundFunctionExoticObject]","kind":{"Normal":{}}},"params":[{"name":"thisArgument","ty":"ESValue","kind":{"Normal":{}}},{"name":"argumentsList","ty":"List[ESValue]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Let _target_ be _F_.[[BoundTargetFunction]].\n  1. Let _boundThis_ be _F_.[[BoundThis]].\n  1. Let _boundArgs_ be _F_.[[BoundArguments]].\n  1. Let _args_ be the list-concatenation of _boundArgs_ and _argumentsList_.\n  1. Return ? Call(_target_, _boundThis_, _args_).","code":"\n          1. Let _target_ be _F_.[[BoundTargetFunction]].\n          1. Let _boundThis_ be _F_.[[BoundThis]].\n          1. Let _boundArgs_ be _F_.[[BoundArguments]].\n          1. Let _args_ be the list-concatenation of _boundArgs_ and _argumentsList_.\n          1. Return ? Call(_target_, _boundThis_, _args_).\n        "},{"head":{"InternalMethodHead":{"methodName":"Construct","receiver":{"name":"F","ty":"Record[BoundFunctionExoticObject]","kind":{"Normal":{}}},"params":[{"name":"argumentsList","ty":"List[ESValue]","kind":{"Normal":{}}},{"name":"newTarget","ty":"Record[Constructor]","kind":{"Normal":{}}}],"retTy":"Normal[Record[Object]] | Throw"}},"body":"\n  1. Let _target_ be _F_.[[BoundTargetFunction]].\n  1. Assert: IsConstructor(_target_) is *true*.\n  1. Let _boundArgs_ be _F_.[[BoundArguments]].\n  1. Let _args_ be the list-concatenation of _boundArgs_ and _argumentsList_.\n  1. If SameValue(_F_, _newTarget_) is *true*, set _newTarget_ to _target_.\n  1. Return ? Construct(_target_, _args_, _newTarget_).","code":"\n          1. Let _target_ be _F_.[[BoundTargetFunction]].\n          1. Assert: IsConstructor(_target_) is *true*.\n          1. Let _boundArgs_ be _F_.[[BoundArguments]].\n          1. Let _args_ be the list-concatenation of _boundArgs_ and _argumentsList_.\n          1. If SameValue(_F_, _newTarget_) is *true*, set _newTarget_ to _target_.\n          1. Return ? Construct(_target_, _args_, _newTarget_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"BoundFunctionCreate","params":[{"name":"targetFunction","ty":"Record[FunctionObject]","kind":{"Normal":{}}},{"name":"boundThis","ty":"ESValue","kind":{"Normal":{}}},{"name":"boundArgs","ty":"List[ESValue]","kind":{"Normal":{}}}],"retTy":"Normal[Record[FunctionObject]] | Throw"}},"body":"\n  1. Let _proto_ be ? _targetFunction_.[[GetPrototypeOf]]().\n  1. Let _internalSlotsList_ be the list-concatenation of « [[Prototype]], [[Extensible]] » and the internal slots listed in <emu-xref href=\"#table-internal-slots-of-bound-function-exotic-objects\"></emu-xref>.\n  1. Let _obj_ be MakeBasicObject(_internalSlotsList_).\n  1. Set _obj_.[[Prototype]] to _proto_.\n  1. Set _obj_.[[Call]] to the definition specified in <emu-xref href=\"#sec-bound-function-exotic-objects-call-thisargument-argumentslist\"></emu-xref>.\n  1. If IsConstructor(_targetFunction_) is *true*, then\n    1. Set _obj_.[[Construct]] to the definition specified in <emu-xref href=\"#sec-bound-function-exotic-objects-construct-argumentslist-newtarget\"></emu-xref>.\n  1. Set _obj_.[[BoundTargetFunction]] to _targetFunction_.\n  1. Set _obj_.[[BoundThis]] to _boundThis_.\n  1. Set _obj_.[[BoundArguments]] to _boundArgs_.\n  1. Return _obj_.","code":"\n          1. Let _proto_ be ? <emu-meta effects=\"user-code\">_targetFunction_.[[GetPrototypeOf]]</emu-meta>().\n          1. Let _internalSlotsList_ be the list-concatenation of « [[Prototype]], [[Extensible]] » and the internal slots listed in <emu-xref href=\"#table-internal-slots-of-bound-function-exotic-objects\"></emu-xref>.\n          1. Let _obj_ be MakeBasicObject(_internalSlotsList_).\n          1. Set _obj_.[[Prototype]] to _proto_.\n          1. Set _obj_.[[Call]] as described in <emu-xref href=\"#sec-bound-function-exotic-objects-call-thisargument-argumentslist\"></emu-xref>.\n          1. If IsConstructor(_targetFunction_) is *true*, then\n            1. Set _obj_.[[Construct]] as described in <emu-xref href=\"#sec-bound-function-exotic-objects-construct-argumentslist-newtarget\"></emu-xref>.\n          1. Set _obj_.[[BoundTargetFunction]] to _targetFunction_.\n          1. Set _obj_.[[BoundThis]] to _boundThis_.\n          1. Set _obj_.[[BoundArguments]] to _boundArgs_.\n          1. Return _obj_.\n        "},{"head":{"InternalMethodHead":{"methodName":"DefineOwnProperty","receiver":{"name":"A","ty":"Record[Array]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}},{"name":"Desc","ty":"Record[PropertyDescriptor]","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. If _P_ is *\"length\"*, then\n    1. Return ? ArraySetLength(_A_, _Desc_).\n  1. Else if _P_ is an array index, then\n    1. Let _lengthDesc_ be OrdinaryGetOwnProperty(_A_, *\"length\"*).\n    1. Assert: IsDataDescriptor(_lengthDesc_) is *true*.\n    1. Assert: _lengthDesc_.[[Configurable]] is *false*.\n    1. Let _length_ be _lengthDesc_.[[Value]].\n    1. Assert: _length_ is a Number[NonNegInt].\n    1. Let _index_ be ! ToUint32(_P_).\n    1. If _index_ ≥ _length_ and _lengthDesc_.[[Writable]] is *false*, return *false*.\n    1. Let _succeeded_ be ! OrdinaryDefineOwnProperty(_A_, _P_, _Desc_).\n    1. If _succeeded_ is *false*, return *false*.\n    1. If _index_ ≥ _length_, then\n      1. Set _lengthDesc_.[[Value]] to _index_ + *1*<sub>𝔽</sub>.\n      1. Set _succeeded_ to ! OrdinaryDefineOwnProperty(_A_, *\"length\"*, _lengthDesc_).\n      1. Assert: _succeeded_ is *true*.\n    1. Return *true*.\n  1. Return ? OrdinaryDefineOwnProperty(_A_, _P_, _Desc_).","code":"\n          1. If _P_ is *\"length\"*, then\n            1. Return ? ArraySetLength(_A_, _Desc_).\n          1. Else if _P_ is an array index, then\n            1. Let _lengthDesc_ be OrdinaryGetOwnProperty(_A_, *\"length\"*).\n            1. Assert: IsDataDescriptor(_lengthDesc_) is *true*.\n            1. Assert: _lengthDesc_.[[Configurable]] is *false*.\n            1. Let _length_ be _lengthDesc_.[[Value]].\n            1. Assert: _length_ is a non-negative integral Number.\n            1. Let _index_ be ! ToUint32(_P_).\n            1. If _index_ ≥ _length_ and _lengthDesc_.[[Writable]] is *false*, return *false*.\n            1. Let _succeeded_ be ! OrdinaryDefineOwnProperty(_A_, _P_, _Desc_).\n            1. If _succeeded_ is *false*, return *false*.\n            1. If _index_ ≥ _length_, then\n              1. Set _lengthDesc_.[[Value]] to _index_ + *1*<sub>𝔽</sub>.\n              1. Set _succeeded_ to ! OrdinaryDefineOwnProperty(_A_, *\"length\"*, _lengthDesc_).\n              1. Assert: _succeeded_ is *true*.\n            1. Return *true*.\n          1. Return ? OrdinaryDefineOwnProperty(_A_, _P_, _Desc_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ArrayCreate","params":[{"name":"length","ty":"NonNegInt","kind":{"Normal":{}}},{"name":"proto","ty":"Record[Object]","kind":{"Optional":{}}}],"retTy":"Normal[Record[Array]] | Throw"}},"body":"\n  1. If _length_ > 2<sup>32</sup> - 1, throw a *RangeError* exception.\n  1. If _proto_ is not present, set _proto_ to %Array.prototype%.\n  1. Let _A_ be MakeBasicObject(« [[Prototype]], [[Extensible]] »).\n  1. Set _A_.[[Prototype]] to _proto_.\n  1. Set _A_.[[DefineOwnProperty]] to the definition specified in <emu-xref href=\"#sec-array-exotic-objects-defineownproperty-p-desc\"></emu-xref>.\n  1. Perform ! OrdinaryDefineOwnProperty(_A_, *\"length\"*, PropertyDescriptor { [[Value]]: 𝔽(_length_), [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n  1. Return _A_.","code":"\n          1. If _length_ > 2<sup>32</sup> - 1, throw a *RangeError* exception.\n          1. If _proto_ is not present, set _proto_ to %Array.prototype%.\n          1. Let _A_ be MakeBasicObject(« [[Prototype]], [[Extensible]] »).\n          1. Set _A_.[[Prototype]] to _proto_.\n          1. Set _A_.[[DefineOwnProperty]] as specified in <emu-xref href=\"#sec-array-exotic-objects-defineownproperty-p-desc\"></emu-xref>.\n          1. Perform ! OrdinaryDefineOwnProperty(_A_, *\"length\"*, PropertyDescriptor { [[Value]]: 𝔽(_length_), [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n          1. Return _A_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ArraySpeciesCreate","params":[{"name":"originalArray","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"length","ty":"NonNegInt","kind":{"Normal":{}}}],"retTy":"Normal[Record[Object]] | Throw"}},"body":"\n  1. Let _isArray_ be ? IsArray(_originalArray_).\n  1. If _isArray_ is *false*, return ? ArrayCreate(_length_).\n  1. Let _C_ be ? Get(_originalArray_, *\"constructor\"*).\n  1. If IsConstructor(_C_) is *true*, then\n    1. Let _thisRealm_ be the current Realm Record.\n    1. Let _realmC_ be ? GetFunctionRealm(_C_).\n    1. If _thisRealm_ is not _realmC_, then\n      1. If SameValue(_C_, _realmC_.[[Intrinsics]].[[%Array%]]) is *true*, set _C_ to *undefined*.\n  1. If _C_ is a Record[Object], then\n    1. Set _C_ to ? Get(_C_, @@species).\n    1. If _C_ is *null*, set _C_ to *undefined*.\n  1. If _C_ is *undefined*, return ? ArrayCreate(_length_).\n  1. If IsConstructor(_C_) is *false*, throw a *TypeError* exception.\n  1. Return ? Construct(_C_, « 𝔽(_length_) »).","code":"\n          1. Let _isArray_ be ? IsArray(_originalArray_).\n          1. If _isArray_ is *false*, return ? ArrayCreate(_length_).\n          1. Let _C_ be ? Get(_originalArray_, *\"constructor\"*).\n          1. If IsConstructor(_C_) is *true*, then\n            1. Let _thisRealm_ be the current Realm Record.\n            1. Let _realmC_ be ? GetFunctionRealm(_C_).\n            1. If _thisRealm_ and _realmC_ are not the same Realm Record, then\n              1. If SameValue(_C_, _realmC_.[[Intrinsics]].[[%Array%]]) is *true*, set _C_ to *undefined*.\n          1. If _C_ is an Object, then\n            1. Set _C_ to ? Get(_C_, @@species).\n            1. If _C_ is *null*, set _C_ to *undefined*.\n          1. If _C_ is *undefined*, return ? ArrayCreate(_length_).\n          1. If IsConstructor(_C_) is *false*, throw a *TypeError* exception.\n          1. Return ? Construct(_C_, « 𝔽(_length_) »).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ArraySetLength","params":[{"name":"A","ty":"Record[Array]","kind":{"Normal":{}}},{"name":"Desc","ty":"Record[PropertyDescriptor]","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. If _Desc_ does not have a [[Value]] internal slot, then\n    1. Return ! OrdinaryDefineOwnProperty(_A_, *\"length\"*, _Desc_).\n  1. Let _newLenDesc_ be a copy of _Desc_.\n  1. [id=\"step-arraysetlength-newlen\"] Let _newLen_ be ? ToUint32(_Desc_.[[Value]]).\n  1. [id=\"step-arraysetlength-numberlen\"] Let _numberLen_ be ? ToNumber(_Desc_.[[Value]]).\n  1. If SameValueZero(_newLen_, _numberLen_) is *false*, throw a *RangeError* exception.\n  1. Set _newLenDesc_.[[Value]] to _newLen_.\n  1. Let _oldLenDesc_ be OrdinaryGetOwnProperty(_A_, *\"length\"*).\n  1. Assert: IsDataDescriptor(_oldLenDesc_) is *true*.\n  1. Assert: _oldLenDesc_.[[Configurable]] is *false*.\n  1. Let _oldLen_ be _oldLenDesc_.[[Value]].\n  1. If _newLen_ ≥ _oldLen_, then\n    1. Return ! OrdinaryDefineOwnProperty(_A_, *\"length\"*, _newLenDesc_).\n  1. If _oldLenDesc_.[[Writable]] is *false*, return *false*.\n  1. If _newLenDesc_ does not have a [[Writable]] internal slot or _newLenDesc_.[[Writable]] is *true*, then\n    1. Let _newWritable_ be *true*.\n  1. Else,\n    1. NOTE: Setting the [[Writable]] attribute to *false* is deferred in case any elements cannot be deleted.\n    1. Let _newWritable_ be *false*.\n    1. Set _newLenDesc_.[[Writable]] to *true*.\n  1. Let _succeeded_ be ! OrdinaryDefineOwnProperty(_A_, *\"length\"*, _newLenDesc_).\n  1. If _succeeded_ is *false*, return *false*.\n  1. For each own property key _P_ of _A_ such that _P_ is an array index and ! ToUint32(_P_) ≥ _newLen_, in descending numeric index order, do\n    1. Let _deleteSucceeded_ be ! _A_.[[Delete]](_P_).\n    1. If _deleteSucceeded_ is *false*, then\n      1. Set _newLenDesc_.[[Value]] to ! ToUint32(_P_) + *1*<sub>𝔽</sub>.\n      1. If _newWritable_ is *false*, set _newLenDesc_.[[Writable]] to *false*.\n      1. Perform ! OrdinaryDefineOwnProperty(_A_, *\"length\"*, _newLenDesc_).\n      1. Return *false*.\n  1. If _newWritable_ is *false*, then\n    1. Set _succeeded_ to ! OrdinaryDefineOwnProperty(_A_, *\"length\"*, PropertyDescriptor { [[Writable]]: *false* }).\n    1. Assert: _succeeded_ is *true*.\n  1. Return *true*.","code":"\n          1. If _Desc_ does not have a [[Value]] field, then\n            1. Return ! OrdinaryDefineOwnProperty(_A_, *\"length\"*, _Desc_).\n          1. Let _newLenDesc_ be a copy of _Desc_.\n          1. [id=\"step-arraysetlength-newlen\"] Let _newLen_ be ? ToUint32(_Desc_.[[Value]]).\n          1. [id=\"step-arraysetlength-numberlen\"] Let _numberLen_ be ? ToNumber(_Desc_.[[Value]]).\n          1. If SameValueZero(_newLen_, _numberLen_) is *false*, throw a *RangeError* exception.\n          1. Set _newLenDesc_.[[Value]] to _newLen_.\n          1. Let _oldLenDesc_ be OrdinaryGetOwnProperty(_A_, *\"length\"*).\n          1. Assert: IsDataDescriptor(_oldLenDesc_) is *true*.\n          1. Assert: _oldLenDesc_.[[Configurable]] is *false*.\n          1. Let _oldLen_ be _oldLenDesc_.[[Value]].\n          1. If _newLen_ ≥ _oldLen_, then\n            1. Return ! OrdinaryDefineOwnProperty(_A_, *\"length\"*, _newLenDesc_).\n          1. If _oldLenDesc_.[[Writable]] is *false*, return *false*.\n          1. If _newLenDesc_ does not have a [[Writable]] field or _newLenDesc_.[[Writable]] is *true*, then\n            1. Let _newWritable_ be *true*.\n          1. Else,\n            1. NOTE: Setting the [[Writable]] attribute to *false* is deferred in case any elements cannot be deleted.\n            1. Let _newWritable_ be *false*.\n            1. Set _newLenDesc_.[[Writable]] to *true*.\n          1. Let _succeeded_ be ! OrdinaryDefineOwnProperty(_A_, *\"length\"*, _newLenDesc_).\n          1. If _succeeded_ is *false*, return *false*.\n          1. For each own property key _P_ of _A_ such that _P_ is an array index and ! ToUint32(_P_) ≥ _newLen_, in descending numeric index order, do\n            1. Let _deleteSucceeded_ be ! _A_.[[Delete]](_P_).\n            1. If _deleteSucceeded_ is *false*, then\n              1. Set _newLenDesc_.[[Value]] to ! ToUint32(_P_) + *1*<sub>𝔽</sub>.\n              1. If _newWritable_ is *false*, set _newLenDesc_.[[Writable]] to *false*.\n              1. Perform ! OrdinaryDefineOwnProperty(_A_, *\"length\"*, _newLenDesc_).\n              1. Return *false*.\n          1. If _newWritable_ is *false*, then\n            1. Set _succeeded_ to ! OrdinaryDefineOwnProperty(_A_, *\"length\"*, PropertyDescriptor { [[Writable]]: *false* }).\n            1. Assert: _succeeded_ is *true*.\n          1. Return *true*.\n        "},{"head":{"InternalMethodHead":{"methodName":"GetOwnProperty","receiver":{"name":"S","ty":"Record[StringExoticObject]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Record[PropertyDescriptor] | Undefined]"}},"body":"\n  1. Let _desc_ be OrdinaryGetOwnProperty(_S_, _P_).\n  1. If _desc_ is not *undefined*, return _desc_.\n  1. Return StringGetOwnProperty(_S_, _P_).","code":"\n          1. Let _desc_ be OrdinaryGetOwnProperty(_S_, _P_).\n          1. If _desc_ is not *undefined*, return _desc_.\n          1. Return StringGetOwnProperty(_S_, _P_).\n        "},{"head":{"InternalMethodHead":{"methodName":"DefineOwnProperty","receiver":{"name":"S","ty":"Record[StringExoticObject]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}},{"name":"Desc","ty":"Record[PropertyDescriptor]","kind":{"Normal":{}}}],"retTy":"Normal[Boolean]"}},"body":"\n  1. Let _stringDesc_ be StringGetOwnProperty(_S_, _P_).\n  1. If _stringDesc_ is not *undefined*, then\n    1. Let _extensible_ be _S_.[[Extensible]].\n    1. Return IsCompatiblePropertyDescriptor(_extensible_, _Desc_, _stringDesc_).\n  1. Return ! OrdinaryDefineOwnProperty(_S_, _P_, _Desc_).","code":"\n          1. Let _stringDesc_ be StringGetOwnProperty(_S_, _P_).\n          1. If _stringDesc_ is not *undefined*, then\n            1. Let _extensible_ be _S_.[[Extensible]].\n            1. Return IsCompatiblePropertyDescriptor(_extensible_, _Desc_, _stringDesc_).\n          1. Return ! OrdinaryDefineOwnProperty(_S_, _P_, _Desc_).\n        "},{"head":{"InternalMethodHead":{"methodName":"OwnPropertyKeys","receiver":{"name":"O","ty":"Record[StringExoticObject]","kind":{"Normal":{}}},"params":[],"retTy":"Normal[List[Record[Symbol] | String]]"}},"body":"\n  1. Let _keys_ be « ».\n  1. Let _str_ be _O_.[[StringData]].\n  1. Assert: _str_ is a String.\n  1. Let _len_ be the length of _str_.\n  1. For each integer _i_ such that 0 ≤ _i_ ≤ the difference _len_ minus 1, in ascending order, do\n    1. Append ! ToString(𝔽(_i_)) to _keys_.\n  1. For each own property key _P_ of _O_ such that _P_ is an array index and ! ToIntegerOrInfinity(_P_) ≥ _len_, in ascending numeric index order, do\n    1. Append _P_ to _keys_.\n  1. For each own property key _P_ of _O_ such that _P_ is a String and _P_ is not an array index, in ascending chronological order of property creation, do\n    1. Append _P_ to _keys_.\n  1. For each own property key _P_ of _O_ such that _P_ is a Record[Symbol], in ascending chronological order of property creation, do\n    1. Append _P_ to _keys_.\n  1. Return _keys_.","code":"\n          1. Let _keys_ be a new empty List.\n          1. Let _str_ be _O_.[[StringData]].\n          1. Assert: _str_ is a String.\n          1. Let _len_ be the length of _str_.\n          1. For each integer _i_ such that 0 ≤ _i_ < _len_, in ascending order, do\n            1. Append ! ToString(𝔽(_i_)) to _keys_.\n          1. For each own property key _P_ of _O_ such that _P_ is an array index and ! ToIntegerOrInfinity(_P_) ≥ _len_, in ascending numeric index order, do\n            1. Append _P_ to _keys_.\n          1. For each own property key _P_ of _O_ such that _P_ is a String and _P_ is not an array index, in ascending chronological order of property creation, do\n            1. Append _P_ to _keys_.\n          1. For each own property key _P_ of _O_ such that _P_ is a Symbol, in ascending chronological order of property creation, do\n            1. Append _P_ to _keys_.\n          1. Return _keys_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"StringCreate","params":[{"name":"value","ty":"String","kind":{"Normal":{}}},{"name":"prototype","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Record[StringExoticObject]"}},"body":"\n  1. Let _S_ be MakeBasicObject(« [[Prototype]], [[Extensible]], [[StringData]] »).\n  1. Set _S_.[[Prototype]] to _prototype_.\n  1. Set _S_.[[StringData]] to _value_.\n  1. Set _S_.[[GetOwnProperty]] to the definition specified in <emu-xref href=\"#sec-string-exotic-objects-getownproperty-p\"></emu-xref>.\n  1. Set _S_.[[DefineOwnProperty]] to the definition specified in <emu-xref href=\"#sec-string-exotic-objects-defineownproperty-p-desc\"></emu-xref>.\n  1. Set _S_.[[OwnPropertyKeys]] to the definition specified in <emu-xref href=\"#sec-string-exotic-objects-ownpropertykeys\"></emu-xref>.\n  1. Let _length_ be the length of _value_.\n  1. Perform ! DefinePropertyOrThrow(_S_, *\"length\"*, PropertyDescriptor { [[Value]]: 𝔽(_length_), [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n  1. Return _S_.","code":"\n          1. Let _S_ be MakeBasicObject(« [[Prototype]], [[Extensible]], [[StringData]] »).\n          1. Set _S_.[[Prototype]] to _prototype_.\n          1. Set _S_.[[StringData]] to _value_.\n          1. Set _S_.[[GetOwnProperty]] as specified in <emu-xref href=\"#sec-string-exotic-objects-getownproperty-p\"></emu-xref>.\n          1. Set _S_.[[DefineOwnProperty]] as specified in <emu-xref href=\"#sec-string-exotic-objects-defineownproperty-p-desc\"></emu-xref>.\n          1. Set _S_.[[OwnPropertyKeys]] as specified in <emu-xref href=\"#sec-string-exotic-objects-ownpropertykeys\"></emu-xref>.\n          1. Let _length_ be the length of _value_.\n          1. Perform ! DefinePropertyOrThrow(_S_, *\"length\"*, PropertyDescriptor { [[Value]]: 𝔽(_length_), [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n          1. Return _S_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"StringGetOwnProperty","params":[{"name":"S","ty":"Unknown[\"an Object that has a [[StringData]] internal slot\"]","kind":{"Normal":{}}},{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Record[PropertyDescriptor] | Undefined"}},"body":"\n  1. If _P_ is not a String, return *undefined*.\n  1. Let _index_ be CanonicalNumericIndexString(_P_).\n  1. If _index_ is *undefined*, return *undefined*.\n  1. If IsIntegralNumber(_index_) is *false*, return *undefined*.\n  1. If _index_ is *-0*<sub>𝔽</sub>, return *undefined*.\n  1. Let _str_ be _S_.[[StringData]].\n  1. Assert: _str_ is a String.\n  1. Let _len_ be the length of _str_.\n  1. If ℝ(_index_) < 0 or _len_ ≤ ℝ(_index_), return *undefined*.\n  1. Let _resultStr_ be the substring of _str_ from ℝ(_index_) to ℝ(_index_) + 1.\n  1. Return PropertyDescriptor { [[Value]]: _resultStr_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* }.","code":"\n          1. If _P_ is not a String, return *undefined*.\n          1. Let _index_ be CanonicalNumericIndexString(_P_).\n          1. If _index_ is *undefined*, return *undefined*.\n          1. If IsIntegralNumber(_index_) is *false*, return *undefined*.\n          1. If _index_ is *-0*<sub>𝔽</sub>, return *undefined*.\n          1. Let _str_ be _S_.[[StringData]].\n          1. Assert: _str_ is a String.\n          1. Let _len_ be the length of _str_.\n          1. If ℝ(_index_) < 0 or _len_ ≤ ℝ(_index_), return *undefined*.\n          1. Let _resultStr_ be the substring of _str_ from ℝ(_index_) to ℝ(_index_) + 1.\n          1. Return the PropertyDescriptor { [[Value]]: _resultStr_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* }.\n        "},{"head":{"InternalMethodHead":{"methodName":"GetOwnProperty","receiver":{"name":"args","ty":"Record[ArgumentsExoticObject]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Record[PropertyDescriptor] | Undefined]"}},"body":"\n  1. Let _desc_ be OrdinaryGetOwnProperty(_args_, _P_).\n  1. If _desc_ is *undefined*, return *undefined*.\n  1. Let _map_ be _args_.[[ParameterMap]].\n  1. Let _isMapped_ be ! HasOwnProperty(_map_, _P_).\n  1. If _isMapped_ is *true*, then\n    1. Set _desc_.[[Value]] to ! Get(_map_, _P_).\n  1. Return _desc_.","code":"\n          1. Let _desc_ be OrdinaryGetOwnProperty(_args_, _P_).\n          1. If _desc_ is *undefined*, return *undefined*.\n          1. Let _map_ be _args_.[[ParameterMap]].\n          1. Let _isMapped_ be ! HasOwnProperty(_map_, _P_).\n          1. If _isMapped_ is *true*, then\n            1. Set _desc_.[[Value]] to ! Get(_map_, _P_).\n          1. Return _desc_.\n        "},{"head":{"InternalMethodHead":{"methodName":"DefineOwnProperty","receiver":{"name":"args","ty":"Record[ArgumentsExoticObject]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}},{"name":"Desc","ty":"Record[PropertyDescriptor]","kind":{"Normal":{}}}],"retTy":"Normal[Boolean]"}},"body":"\n  1. Let _map_ be _args_.[[ParameterMap]].\n  1. Let _isMapped_ be ! HasOwnProperty(_map_, _P_).\n  1. Let _newArgDesc_ be _Desc_.\n  1. If _isMapped_ is *true* and IsDataDescriptor(_Desc_) is *true*, then\n    1. If _Desc_ does not have a [[Value]] internal slot and _Desc_ has a [[Writable]] internal slot and _Desc_.[[Writable]] is *false*, then\n      1. Set _newArgDesc_ to a copy of _Desc_.\n      1. Set _newArgDesc_.[[Value]] to ! Get(_map_, _P_).\n  1. Let _allowed_ be ! OrdinaryDefineOwnProperty(_args_, _P_, _newArgDesc_).\n  1. If _allowed_ is *false*, return *false*.\n  1. If _isMapped_ is *true*, then\n    1. If IsAccessorDescriptor(_Desc_) is *true*, then\n      1. Perform ! _map_.[[Delete]](_P_).\n    1. Else,\n      1. If _Desc_ has a [[Value]] internal slot, then\n        1. Assert: The following Set will succeed, since formal parameters mapped by arguments objects are always writable..\n        1. Perform ! Set(_map_, _P_, _Desc_.[[Value]], *false*).\n      1. If _Desc_ has a [[Writable]] internal slot and _Desc_.[[Writable]] is *false*, then\n        1. Perform ! _map_.[[Delete]](_P_).\n  1. Return *true*.","code":"\n          1. Let _map_ be _args_.[[ParameterMap]].\n          1. Let _isMapped_ be ! HasOwnProperty(_map_, _P_).\n          1. Let _newArgDesc_ be _Desc_.\n          1. If _isMapped_ is *true* and IsDataDescriptor(_Desc_) is *true*, then\n            1. If _Desc_ does not have a [[Value]] field, _Desc_ has a [[Writable]] field, and _Desc_.[[Writable]] is *false*, then\n              1. Set _newArgDesc_ to a copy of _Desc_.\n              1. Set _newArgDesc_.[[Value]] to ! Get(_map_, _P_).\n          1. Let _allowed_ be ! OrdinaryDefineOwnProperty(_args_, _P_, _newArgDesc_).\n          1. If _allowed_ is *false*, return *false*.\n          1. If _isMapped_ is *true*, then\n            1. If IsAccessorDescriptor(_Desc_) is *true*, then\n              1. Perform ! _map_.[[Delete]](_P_).\n            1. Else,\n              1. If _Desc_ has a [[Value]] field, then\n                1. Assert: The following Set will succeed, since formal parameters mapped by arguments objects are always writable.\n                1. Perform ! Set(_map_, _P_, _Desc_.[[Value]], *false*).\n              1. If _Desc_ has a [[Writable]] field and _Desc_.[[Writable]] is *false*, then\n                1. Perform ! _map_.[[Delete]](_P_).\n          1. Return *true*.\n        "},{"head":{"InternalMethodHead":{"methodName":"Get","receiver":{"name":"args","ty":"Record[ArgumentsExoticObject]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}},{"name":"Receiver","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Let _map_ be _args_.[[ParameterMap]].\n  1. Let _isMapped_ be ! HasOwnProperty(_map_, _P_).\n  1. If _isMapped_ is *false*, then\n    1. Return ? OrdinaryGet(_args_, _P_, _Receiver_).\n  1. Else,\n    1. Assert: _map_ contains a formal parameter mapping for _P_..\n    1. Return ! Get(_map_, _P_).","code":"\n          1. Let _map_ be _args_.[[ParameterMap]].\n          1. Let _isMapped_ be ! HasOwnProperty(_map_, _P_).\n          1. If _isMapped_ is *false*, then\n            1. Return ? OrdinaryGet(_args_, _P_, _Receiver_).\n          1. Else,\n            1. Assert: _map_ contains a formal parameter mapping for _P_.\n            1. Return ! Get(_map_, _P_).\n        "},{"head":{"InternalMethodHead":{"methodName":"Set","receiver":{"name":"args","ty":"Record[ArgumentsExoticObject]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}},{"name":"V","ty":"ESValue","kind":{"Normal":{}}},{"name":"Receiver","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. If SameValue(_args_, _Receiver_) is *false*, then\n    1. Let _isMapped_ be *false*.\n  1. Else,\n    1. Let _map_ be _args_.[[ParameterMap]].\n    1. Let _isMapped_ be ! HasOwnProperty(_map_, _P_).\n  1. If _isMapped_ is *true*, then\n    1. Assert: The following Set will succeed, since formal parameters mapped by arguments objects are always writable..\n    1. Perform ! Set(_map_, _P_, _V_, *false*).\n  1. Return ? OrdinarySet(_args_, _P_, _V_, _Receiver_).","code":"\n          1. If SameValue(_args_, _Receiver_) is *false*, then\n            1. Let _isMapped_ be *false*.\n          1. Else,\n            1. Let _map_ be _args_.[[ParameterMap]].\n            1. Let _isMapped_ be ! HasOwnProperty(_map_, _P_).\n          1. If _isMapped_ is *true*, then\n            1. Assert: The following Set will succeed, since formal parameters mapped by arguments objects are always writable.\n            1. Perform ! Set(_map_, _P_, _V_, *false*).\n          1. Return ? OrdinarySet(_args_, _P_, _V_, _Receiver_).\n        "},{"head":{"InternalMethodHead":{"methodName":"Delete","receiver":{"name":"args","ty":"Record[ArgumentsExoticObject]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Let _map_ be _args_.[[ParameterMap]].\n  1. Let _isMapped_ be ! HasOwnProperty(_map_, _P_).\n  1. Let _result_ be ? OrdinaryDelete(_args_, _P_).\n  1. If _result_ is *true* and _isMapped_ is *true*, then\n    1. Perform ! _map_.[[Delete]](_P_).\n  1. Return _result_.","code":"\n          1. Let _map_ be _args_.[[ParameterMap]].\n          1. Let _isMapped_ be ! HasOwnProperty(_map_, _P_).\n          1. Let _result_ be ? OrdinaryDelete(_args_, _P_).\n          1. If _result_ is *true* and _isMapped_ is *true*, then\n            1. Perform ! _map_.[[Delete]](_P_).\n          1. Return _result_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CreateUnmappedArgumentsObject","params":[{"name":"argumentsList","ty":"List[ESValue]","kind":{"Normal":{}}}],"retTy":"Record[OrdinaryObject]"}},"body":"\n  1. Let _len_ be the number of elements in _argumentsList_.\n  1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%, « [[ParameterMap]] »).\n  1. Set _obj_.[[ParameterMap]] to *undefined*.\n  1. Perform ! DefinePropertyOrThrow(_obj_, *\"length\"*, PropertyDescriptor { [[Value]]: 𝔽(_len_), [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n  1. Let _index_ be 0.\n  1. Repeat, while _index_ < _len_,\n    1. Let _val_ be _argumentsList_[_index_].\n    1. Perform ! CreateDataPropertyOrThrow(_obj_, ! ToString(𝔽(_index_)), _val_).\n    1. Set _index_ to _index_ + 1.\n  1. Perform ! DefinePropertyOrThrow(_obj_, @@iterator, PropertyDescriptor { [[Value]]: %Array.prototype.values%, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n  1. Perform ! DefinePropertyOrThrow(_obj_, *\"callee\"*, PropertyDescriptor { [[Get]]: %ThrowTypeError%, [[Set]]: %ThrowTypeError%, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n  1. Return _obj_.","code":"\n          1. Let _len_ be the number of elements in _argumentsList_.\n          1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%, « [[ParameterMap]] »).\n          1. Set _obj_.[[ParameterMap]] to *undefined*.\n          1. Perform ! DefinePropertyOrThrow(_obj_, *\"length\"*, PropertyDescriptor { [[Value]]: 𝔽(_len_), [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n          1. Let _index_ be 0.\n          1. Repeat, while _index_ < _len_,\n            1. Let _val_ be _argumentsList_[_index_].\n            1. Perform ! CreateDataPropertyOrThrow(_obj_, ! ToString(𝔽(_index_)), _val_).\n            1. Set _index_ to _index_ + 1.\n          1. Perform ! DefinePropertyOrThrow(_obj_, @@iterator, PropertyDescriptor { [[Value]]: %Array.prototype.values%, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n          1. Perform ! DefinePropertyOrThrow(_obj_, *\"callee\"*, PropertyDescriptor { [[Get]]: %ThrowTypeError%, [[Set]]: %ThrowTypeError%, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n          1. Return _obj_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CreateMappedArgumentsObject","params":[{"name":"func","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"formals","ty":"Ast","kind":{"Normal":{}}},{"name":"argumentsList","ty":"List[ESValue]","kind":{"Normal":{}}},{"name":"env","ty":"Record[EnvironmentRecord]","kind":{"Normal":{}}}],"retTy":"Record[ArgumentsExoticObject]"}},"body":"\n  1. Assert: _formals_ does not contain a rest parameter, any binding patterns, or any initializers. It may contain duplicate identifiers..\n  1. Let _len_ be the number of elements in _argumentsList_.\n  1. Let _obj_ be MakeBasicObject(« [[Prototype]], [[Extensible]], [[ParameterMap]] »).\n  1. Set _obj_.[[GetOwnProperty]] to the definition specified in <emu-xref href=\"#sec-arguments-exotic-objects-getownproperty-p\"></emu-xref>.\n  1. Set _obj_.[[DefineOwnProperty]] to the definition specified in <emu-xref href=\"#sec-arguments-exotic-objects-defineownproperty-p-desc\"></emu-xref>.\n  1. Set _obj_.[[Get]] to the definition specified in <emu-xref href=\"#sec-arguments-exotic-objects-get-p-receiver\"></emu-xref>.\n  1. Set _obj_.[[Set]] to the definition specified in <emu-xref href=\"#sec-arguments-exotic-objects-set-p-v-receiver\"></emu-xref>.\n  1. Set _obj_.[[Delete]] to the definition specified in <emu-xref href=\"#sec-arguments-exotic-objects-delete-p\"></emu-xref>.\n  1. Set _obj_.[[Prototype]] to %Object.prototype%.\n  1. Let _map_ be OrdinaryObjectCreate(*null*).\n  1. Set _obj_.[[ParameterMap]] to _map_.\n  1. Let _parameterNames_ be BoundNames of _formals_.\n  1. Let _numberOfParameters_ be the number of elements in _parameterNames_.\n  1. Let _index_ be 0.\n  1. Repeat, while _index_ < _len_,\n    1. Let _val_ be _argumentsList_[_index_].\n    1. Perform ! CreateDataPropertyOrThrow(_obj_, ! ToString(𝔽(_index_)), _val_).\n    1. Set _index_ to _index_ + 1.\n  1. Perform ! DefinePropertyOrThrow(_obj_, *\"length\"*, PropertyDescriptor { [[Value]]: 𝔽(_len_), [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n  1. Let _mappedNames_ be « ».\n  1. Set _index_ to _numberOfParameters_ - 1.\n  1. Repeat, while _index_ ≥ 0,\n    1. Let _name_ be _parameterNames_[_index_].\n    1. If _mappedNames_ does not contain _name_, then\n      1. Append _name_ to _mappedNames_.\n      1. If _index_ < _len_, then\n        1. Let _g_ be MakeArgGetter(_name_, _env_).\n        1. Let _p_ be MakeArgSetter(_name_, _env_).\n        1. Perform ! _map_.[[DefineOwnProperty]](! ToString(𝔽(_index_)), PropertyDescriptor { [[Set]]: _p_, [[Get]]: _g_, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n    1. Set _index_ to _index_ - 1.\n  1. Perform ! DefinePropertyOrThrow(_obj_, @@iterator, PropertyDescriptor { [[Value]]: %Array.prototype.values%, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n  1. Perform ! DefinePropertyOrThrow(_obj_, *\"callee\"*, PropertyDescriptor { [[Value]]: _func_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n  1. Return _obj_.","code":"\n          1. Assert: _formals_ does not contain a rest parameter, any binding patterns, or any initializers. It may contain duplicate identifiers.\n          1. Let _len_ be the number of elements in _argumentsList_.\n          1. Let _obj_ be MakeBasicObject(« [[Prototype]], [[Extensible]], [[ParameterMap]] »).\n          1. Set _obj_.[[GetOwnProperty]] as specified in <emu-xref href=\"#sec-arguments-exotic-objects-getownproperty-p\"></emu-xref>.\n          1. Set _obj_.[[DefineOwnProperty]] as specified in <emu-xref href=\"#sec-arguments-exotic-objects-defineownproperty-p-desc\"></emu-xref>.\n          1. Set _obj_.[[Get]] as specified in <emu-xref href=\"#sec-arguments-exotic-objects-get-p-receiver\"></emu-xref>.\n          1. Set _obj_.[[Set]] as specified in <emu-xref href=\"#sec-arguments-exotic-objects-set-p-v-receiver\"></emu-xref>.\n          1. Set _obj_.[[Delete]] as specified in <emu-xref href=\"#sec-arguments-exotic-objects-delete-p\"></emu-xref>.\n          1. Set _obj_.[[Prototype]] to %Object.prototype%.\n          1. Let _map_ be OrdinaryObjectCreate(*null*).\n          1. Set _obj_.[[ParameterMap]] to _map_.\n          1. Let _parameterNames_ be the BoundNames of _formals_.\n          1. Let _numberOfParameters_ be the number of elements in _parameterNames_.\n          1. Let _index_ be 0.\n          1. Repeat, while _index_ < _len_,\n            1. Let _val_ be _argumentsList_[_index_].\n            1. Perform ! CreateDataPropertyOrThrow(_obj_, ! ToString(𝔽(_index_)), _val_).\n            1. Set _index_ to _index_ + 1.\n          1. Perform ! DefinePropertyOrThrow(_obj_, *\"length\"*, PropertyDescriptor { [[Value]]: 𝔽(_len_), [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n          1. Let _mappedNames_ be a new empty List.\n          1. Set _index_ to _numberOfParameters_ - 1.\n          1. Repeat, while _index_ ≥ 0,\n            1. Let _name_ be _parameterNames_[_index_].\n            1. If _mappedNames_ does not contain _name_, then\n              1. Append _name_ to _mappedNames_.\n              1. If _index_ < _len_, then\n                1. Let _g_ be MakeArgGetter(_name_, _env_).\n                1. Let _p_ be MakeArgSetter(_name_, _env_).\n                1. Perform ! _map_.[[DefineOwnProperty]](! ToString(𝔽(_index_)), PropertyDescriptor { [[Set]]: _p_, [[Get]]: _g_, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n            1. Set _index_ to _index_ - 1.\n          1. Perform ! DefinePropertyOrThrow(_obj_, @@iterator, PropertyDescriptor { [[Value]]: %Array.prototype.values%, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n          1. Perform ! DefinePropertyOrThrow(_obj_, *\"callee\"*, PropertyDescriptor { [[Value]]: _func_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *true* }).\n          1. Return _obj_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"MakeArgGetter","params":[{"name":"name","ty":"String","kind":{"Normal":{}}},{"name":"env","ty":"Record[EnvironmentRecord]","kind":{"Normal":{}}}],"retTy":"Record[FunctionObject]"}},"body":"\n  1. Let _getterClosure_ be a new Abstract Closure with no parameters that captures _name_ and _env_ and performs the following steps when called:\n    1. Return _env_.GetBindingValue(_name_, *false*).\n  1. Let _getter_ be CreateBuiltinFunction(_getterClosure_, 0, *\"\"*, « »).\n  1. NOTE: _getter_ is never directly accessible to ECMAScript code.\n  1. Return _getter_.","code":"\n            1. Let _getterClosure_ be a new Abstract Closure with no parameters that captures _name_ and _env_ and performs the following steps when called:\n              1. Return _env_.GetBindingValue(_name_, *false*).\n            1. Let _getter_ be CreateBuiltinFunction(_getterClosure_, 0, *\"\"*, « »).\n            1. NOTE: _getter_ is never directly accessible to ECMAScript code.\n            1. Return _getter_.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"MakeArgSetter","params":[{"name":"name","ty":"String","kind":{"Normal":{}}},{"name":"env","ty":"Record[EnvironmentRecord]","kind":{"Normal":{}}}],"retTy":"Record[FunctionObject]"}},"body":"\n  1. Let _setterClosure_ be a new Abstract Closure with parameters (_value_) that captures _name_ and _env_ and performs the following steps when called:\n    1. Return ! _env_.SetMutableBinding(_name_, _value_, *false*).\n  1. Let _setter_ be CreateBuiltinFunction(_setterClosure_, 1, *\"\"*, « »).\n  1. NOTE: _setter_ is never directly accessible to ECMAScript code.\n  1. Return _setter_.","code":"\n            1. Let _setterClosure_ be a new Abstract Closure with parameters (_value_) that captures _name_ and _env_ and performs the following steps when called:\n              1. Return ! _env_.SetMutableBinding(_name_, _value_, *false*).\n            1. Let _setter_ be CreateBuiltinFunction(_setterClosure_, 1, *\"\"*, « »).\n            1. NOTE: _setter_ is never directly accessible to ECMAScript code.\n            1. Return _setter_.\n          "},{"head":{"InternalMethodHead":{"methodName":"GetOwnProperty","receiver":{"name":"O","ty":"Record[TypedArray]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Record[PropertyDescriptor] | Undefined]"}},"body":"\n  1. If _P_ is a String, then\n    1. Let _numericIndex_ be CanonicalNumericIndexString(_P_).\n    1. If _numericIndex_ is not *undefined*, then\n      1. Let _value_ be TypedArrayGetElement(_O_, _numericIndex_).\n      1. If _value_ is *undefined*, return *undefined*.\n      1. Return PropertyDescriptor { [[Value]]: _value_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* }.\n  1. Return OrdinaryGetOwnProperty(_O_, _P_).","code":"\n          1. If _P_ is a String, then\n            1. Let _numericIndex_ be CanonicalNumericIndexString(_P_).\n            1. If _numericIndex_ is not *undefined*, then\n              1. Let _value_ be TypedArrayGetElement(_O_, _numericIndex_).\n              1. If _value_ is *undefined*, return *undefined*.\n              1. Return the PropertyDescriptor { [[Value]]: _value_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *true* }.\n          1. Return OrdinaryGetOwnProperty(_O_, _P_).\n        "},{"head":{"InternalMethodHead":{"methodName":"HasProperty","receiver":{"name":"O","ty":"Record[TypedArray]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. If _P_ is a String, then\n    1. Let _numericIndex_ be CanonicalNumericIndexString(_P_).\n    1. If _numericIndex_ is not *undefined*, return IsValidIntegerIndex(_O_, _numericIndex_).\n  1. Return ? OrdinaryHasProperty(_O_, _P_).","code":"\n          1. If _P_ is a String, then\n            1. Let _numericIndex_ be CanonicalNumericIndexString(_P_).\n            1. If _numericIndex_ is not *undefined*, return IsValidIntegerIndex(_O_, _numericIndex_).\n          1. Return ? OrdinaryHasProperty(_O_, _P_).\n        "},{"head":{"InternalMethodHead":{"methodName":"DefineOwnProperty","receiver":{"name":"O","ty":"Record[TypedArray]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}},{"name":"Desc","ty":"Record[PropertyDescriptor]","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. If _P_ is a String, then\n    1. Let _numericIndex_ be CanonicalNumericIndexString(_P_).\n    1. If _numericIndex_ is not *undefined*, then\n      1. If IsValidIntegerIndex(_O_, _numericIndex_) is *false*, return *false*.\n      1. If _Desc_ has a [[Configurable]] internal slot and _Desc_.[[Configurable]] is *false*, return *false*.\n      1. If _Desc_ has a [[Enumerable]] internal slot and _Desc_.[[Enumerable]] is *false*, return *false*.\n      1. If IsAccessorDescriptor(_Desc_) is *true*, return *false*.\n      1. If _Desc_ has a [[Writable]] internal slot and _Desc_.[[Writable]] is *false*, return *false*.\n      1. If _Desc_ has a [[Value]] internal slot, perform ? TypedArraySetElement(_O_, _numericIndex_, _Desc_.[[Value]]).\n      1. Return *true*.\n  1. Return ! OrdinaryDefineOwnProperty(_O_, _P_, _Desc_).","code":"\n          1. If _P_ is a String, then\n            1. Let _numericIndex_ be CanonicalNumericIndexString(_P_).\n            1. If _numericIndex_ is not *undefined*, then\n              1. If IsValidIntegerIndex(_O_, _numericIndex_) is *false*, return *false*.\n              1. If _Desc_ has a [[Configurable]] field and _Desc_.[[Configurable]] is *false*, return *false*.\n              1. If _Desc_ has an [[Enumerable]] field and _Desc_.[[Enumerable]] is *false*, return *false*.\n              1. If IsAccessorDescriptor(_Desc_) is *true*, return *false*.\n              1. If _Desc_ has a [[Writable]] field and _Desc_.[[Writable]] is *false*, return *false*.\n              1. If _Desc_ has a [[Value]] field, perform ? TypedArraySetElement(_O_, _numericIndex_, _Desc_.[[Value]]).\n              1. Return *true*.\n          1. Return ! OrdinaryDefineOwnProperty(_O_, _P_, _Desc_).\n        "},{"head":{"InternalMethodHead":{"methodName":"Get","receiver":{"name":"O","ty":"Record[TypedArray]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}},{"name":"Receiver","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. If _P_ is a String, then\n    1. Let _numericIndex_ be CanonicalNumericIndexString(_P_).\n    1. If _numericIndex_ is not *undefined*, then\n      1. Return TypedArrayGetElement(_O_, _numericIndex_).\n  1. Return ? OrdinaryGet(_O_, _P_, _Receiver_).","code":"\n          1. If _P_ is a String, then\n            1. Let _numericIndex_ be CanonicalNumericIndexString(_P_).\n            1. If _numericIndex_ is not *undefined*, then\n              1. Return TypedArrayGetElement(_O_, _numericIndex_).\n          1. Return ? OrdinaryGet(_O_, _P_, _Receiver_).\n        "},{"head":{"InternalMethodHead":{"methodName":"Set","receiver":{"name":"O","ty":"Record[TypedArray]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}},{"name":"V","ty":"ESValue","kind":{"Normal":{}}},{"name":"Receiver","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. If _P_ is a String, then\n    1. Let _numericIndex_ be CanonicalNumericIndexString(_P_).\n    1. If _numericIndex_ is not *undefined*, then\n      1. If SameValue(_O_, _Receiver_) is *true*, then\n        1. Perform ? TypedArraySetElement(_O_, _numericIndex_, _V_).\n        1. Return *true*.\n      1. If IsValidIntegerIndex(_O_, _numericIndex_) is *false*, return *true*.\n  1. Return ? OrdinarySet(_O_, _P_, _V_, _Receiver_).","code":"\n          1. If _P_ is a String, then\n            1. Let _numericIndex_ be CanonicalNumericIndexString(_P_).\n            1. If _numericIndex_ is not *undefined*, then\n              1. If SameValue(_O_, _Receiver_) is *true*, then\n                1. Perform ? TypedArraySetElement(_O_, _numericIndex_, _V_).\n                1. Return *true*.\n              1. If IsValidIntegerIndex(_O_, _numericIndex_) is *false*, return *true*.\n          1. Return ? OrdinarySet(_O_, _P_, _V_, _Receiver_).\n        "},{"head":{"InternalMethodHead":{"methodName":"Delete","receiver":{"name":"O","ty":"Record[TypedArray]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Boolean]"}},"body":"\n  1. If _P_ is a String, then\n    1. Let _numericIndex_ be CanonicalNumericIndexString(_P_).\n    1. If _numericIndex_ is not *undefined*, then\n      1. If IsValidIntegerIndex(_O_, _numericIndex_) is *false*, return *true*.\n      1. Else, return *false*.\n  1. Return ! OrdinaryDelete(_O_, _P_).","code":"\n          1. If _P_ is a String, then\n            1. Let _numericIndex_ be CanonicalNumericIndexString(_P_).\n            1. If _numericIndex_ is not *undefined*, then\n              1. If IsValidIntegerIndex(_O_, _numericIndex_) is *false*, return *true*; else return *false*.\n          1. Return ! OrdinaryDelete(_O_, _P_).\n        "},{"head":{"InternalMethodHead":{"methodName":"OwnPropertyKeys","receiver":{"name":"O","ty":"Record[TypedArray]","kind":{"Normal":{}}},"params":[],"retTy":"Normal[List[Record[Symbol] | String]]"}},"body":"\n  1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).\n  1. Let _keys_ be « ».\n  1. If IsTypedArrayOutOfBounds(_taRecord_) is *false*, then\n    1. Let _length_ be TypedArrayLength(_taRecord_).\n    1. For each integer _i_ such that 0 ≤ _i_ ≤ the difference _length_ minus 1, in ascending order, do\n      1. Append ! ToString(𝔽(_i_)) to _keys_.\n  1. For each own property key _P_ of _O_ such that _P_ is a String and _P_ is not an integer index, in ascending chronological order of property creation, do\n    1. Append _P_ to _keys_.\n  1. For each own property key _P_ of _O_ such that _P_ is a Record[Symbol], in ascending chronological order of property creation, do\n    1. Append _P_ to _keys_.\n  1. Return _keys_.","code":"\n          1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).\n          1. Let _keys_ be a new empty List.\n          1. If IsTypedArrayOutOfBounds(_taRecord_) is *false*, then\n            1. Let _length_ be TypedArrayLength(_taRecord_).\n            1. For each integer _i_ such that 0 ≤ _i_ < _length_, in ascending order, do\n              1. Append ! ToString(𝔽(_i_)) to _keys_.\n          1. For each own property key _P_ of _O_ such that _P_ is a String and _P_ is not an integer index, in ascending chronological order of property creation, do\n            1. Append _P_ to _keys_.\n          1. For each own property key _P_ of _O_ such that _P_ is a Symbol, in ascending chronological order of property creation, do\n            1. Append _P_ to _keys_.\n          1. Return _keys_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"MakeTypedArrayWithBufferWitnessRecord","params":[{"name":"obj","ty":"Record[TypedArray]","kind":{"Normal":{}}},{"name":"order","ty":"Enum[~seq-cst~, ~unordered~]","kind":{"Normal":{}}}],"retTy":"Record[TypedArrayWithBufferWitnessRecord]"}},"body":"\n  1. Let _buffer_ be _obj_.[[ViewedArrayBuffer]].\n  1. If IsDetachedBuffer(_buffer_) is *true*, then\n    1. Let _byteLength_ be ~detached~.\n  1. Else,\n    1. Let _byteLength_ be ArrayBufferByteLength(_buffer_, _order_).\n  1. Return TypedArray With Buffer Witness Record { [[Object]]: _obj_, [[CachedBufferByteLength]]: _byteLength_ }.","code":"\n          1. Let _buffer_ be _obj_.[[ViewedArrayBuffer]].\n          1. If IsDetachedBuffer(_buffer_) is *true*, then\n            1. Let _byteLength_ be ~detached~.\n          1. Else,\n            1. Let _byteLength_ be ArrayBufferByteLength(_buffer_, _order_).\n          1. Return the TypedArray With Buffer Witness Record { [[Object]]: _obj_, [[CachedBufferByteLength]]: _byteLength_ }.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"TypedArrayCreate","params":[{"name":"prototype","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Record[TypedArray]"}},"body":"\n  1. Let _internalSlotsList_ be « [[Prototype]], [[Extensible]], [[ViewedArrayBuffer]], [[TypedArrayName]], [[ContentType]], [[ByteLength]], [[ByteOffset]], [[ArrayLength]] ».\n  1. Let _A_ be MakeBasicObject(_internalSlotsList_).\n  1. Set _A_.[[GetOwnProperty]] to the definition specified in <emu-xref href=\"#sec-typedarray-getownproperty\"></emu-xref>.\n  1. Set _A_.[[HasProperty]] to the definition specified in <emu-xref href=\"#sec-typedarray-hasproperty\"></emu-xref>.\n  1. Set _A_.[[DefineOwnProperty]] to the definition specified in <emu-xref href=\"#sec-typedarray-defineownproperty\"></emu-xref>.\n  1. Set _A_.[[Get]] to the definition specified in <emu-xref href=\"#sec-typedarray-get\"></emu-xref>.\n  1. Set _A_.[[Set]] to the definition specified in <emu-xref href=\"#sec-typedarray-set\"></emu-xref>.\n  1. Set _A_.[[Delete]] to the definition specified in <emu-xref href=\"#sec-typedarray-delete\"></emu-xref>.\n  1. Set _A_.[[OwnPropertyKeys]] to the definition specified in <emu-xref href=\"#sec-typedarray-ownpropertykeys\"></emu-xref>.\n  1. Set _A_.[[Prototype]] to _prototype_.\n  1. Return _A_.","code":"\n          1. Let _internalSlotsList_ be « [[Prototype]], [[Extensible]], [[ViewedArrayBuffer]], [[TypedArrayName]], [[ContentType]], [[ByteLength]], [[ByteOffset]], [[ArrayLength]] ».\n          1. Let _A_ be MakeBasicObject(_internalSlotsList_).\n          1. Set _A_.[[GetOwnProperty]] as specified in <emu-xref href=\"#sec-typedarray-getownproperty\"></emu-xref>.\n          1. Set _A_.[[HasProperty]] as specified in <emu-xref href=\"#sec-typedarray-hasproperty\"></emu-xref>.\n          1. Set _A_.[[DefineOwnProperty]] as specified in <emu-xref href=\"#sec-typedarray-defineownproperty\"></emu-xref>.\n          1. Set _A_.[[Get]] as specified in <emu-xref href=\"#sec-typedarray-get\"></emu-xref>.\n          1. Set _A_.[[Set]] as specified in <emu-xref href=\"#sec-typedarray-set\"></emu-xref>.\n          1. Set _A_.[[Delete]] as specified in <emu-xref href=\"#sec-typedarray-delete\"></emu-xref>.\n          1. Set _A_.[[OwnPropertyKeys]] as specified in <emu-xref href=\"#sec-typedarray-ownpropertykeys\"></emu-xref>.\n          1. Set _A_.[[Prototype]] to _prototype_.\n          1. Return _A_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"TypedArrayByteLength","params":[{"name":"taRecord","ty":"Record[TypedArrayWithBufferWitnessRecord]","kind":{"Normal":{}}}],"retTy":"NonNegInt"}},"body":"\n  1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, return 0.\n  1. Let _length_ be TypedArrayLength(_taRecord_).\n  1. If _length_ = 0, return 0.\n  1. Let _O_ be _taRecord_.[[Object]].\n  1. If _O_.[[ByteLength]] is not ~auto~, return _O_.[[ByteLength]].\n  1. Let _elementSize_ be TypedArrayElementSize(_O_).\n  1. Return _length_ × _elementSize_.","code":"\n          1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, return 0.\n          1. Let _length_ be TypedArrayLength(_taRecord_).\n          1. If _length_ = 0, return 0.\n          1. Let _O_ be _taRecord_.[[Object]].\n          1. If _O_.[[ByteLength]] is not ~auto~, return _O_.[[ByteLength]].\n          1. Let _elementSize_ be TypedArrayElementSize(_O_).\n          1. Return _length_ × _elementSize_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"TypedArrayLength","params":[{"name":"taRecord","ty":"Record[TypedArrayWithBufferWitnessRecord]","kind":{"Normal":{}}}],"retTy":"NonNegInt"}},"body":"\n  1. Assert: IsTypedArrayOutOfBounds(_taRecord_) is *false*.\n  1. Let _O_ be _taRecord_.[[Object]].\n  1. If _O_.[[ArrayLength]] is not ~auto~, return _O_.[[ArrayLength]].\n  1. Assert: IsFixedLengthArrayBuffer(_O_.[[ViewedArrayBuffer]]) is *false*.\n  1. Let _byteOffset_ be _O_.[[ByteOffset]].\n  1. Let _elementSize_ be TypedArrayElementSize(_O_).\n  1. Let _byteLength_ be _taRecord_.[[CachedBufferByteLength]].\n  1. Assert: _byteLength_ is not ~detached~.\n  1. Return floor((_byteLength_ - _byteOffset_) / _elementSize_).","code":"\n          1. Assert: IsTypedArrayOutOfBounds(_taRecord_) is *false*.\n          1. Let _O_ be _taRecord_.[[Object]].\n          1. If _O_.[[ArrayLength]] is not ~auto~, return _O_.[[ArrayLength]].\n          1. Assert: IsFixedLengthArrayBuffer(_O_.[[ViewedArrayBuffer]]) is *false*.\n          1. Let _byteOffset_ be _O_.[[ByteOffset]].\n          1. Let _elementSize_ be TypedArrayElementSize(_O_).\n          1. Let _byteLength_ be _taRecord_.[[CachedBufferByteLength]].\n          1. Assert: _byteLength_ is not ~detached~.\n          1. Return floor((_byteLength_ - _byteOffset_) / _elementSize_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsTypedArrayOutOfBounds","params":[{"name":"taRecord","ty":"Record[TypedArrayWithBufferWitnessRecord]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _O_ be _taRecord_.[[Object]].\n  1. Let _bufferByteLength_ be _taRecord_.[[CachedBufferByteLength]].\n  1. Assert: IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) is *true* if and only if _bufferByteLength_ is ~detached~..\n  1. If _bufferByteLength_ is ~detached~, return *true*.\n  1. Let _byteOffsetStart_ be _O_.[[ByteOffset]].\n  1. If _O_.[[ArrayLength]] is ~auto~, then\n    1. Let _byteOffsetEnd_ be _bufferByteLength_.\n  1. Else,\n    1. Let _elementSize_ be TypedArrayElementSize(_O_).\n    1. Let _byteOffsetEnd_ be _byteOffsetStart_ + _O_.[[ArrayLength]] × _elementSize_.\n  1. If _byteOffsetStart_ > _bufferByteLength_ or _byteOffsetEnd_ > _bufferByteLength_, return *true*.\n  1. NOTE: 0-length TypedArrays are not considered out-of-bounds.\n  1. Return *false*.","code":"\n          1. Let _O_ be _taRecord_.[[Object]].\n          1. Let _bufferByteLength_ be _taRecord_.[[CachedBufferByteLength]].\n          1. Assert: IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) is *true* if and only if _bufferByteLength_ is ~detached~.\n          1. If _bufferByteLength_ is ~detached~, return *true*.\n          1. Let _byteOffsetStart_ be _O_.[[ByteOffset]].\n          1. If _O_.[[ArrayLength]] is ~auto~, then\n            1. Let _byteOffsetEnd_ be _bufferByteLength_.\n          1. Else,\n            1. Let _elementSize_ be TypedArrayElementSize(_O_).\n            1. Let _byteOffsetEnd_ be _byteOffsetStart_ + _O_.[[ArrayLength]] × _elementSize_.\n          1. If _byteOffsetStart_ > _bufferByteLength_ or _byteOffsetEnd_ > _bufferByteLength_, return *true*.\n          1. NOTE: 0-length TypedArrays are not considered out-of-bounds.\n          1. Return *false*.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsValidIntegerIndex","params":[{"name":"O","ty":"Record[TypedArray]","kind":{"Normal":{}}},{"name":"index","ty":"Number","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) is *true*, return *false*.\n  1. If IsIntegralNumber(_index_) is *false*, return *false*.\n  1. If _index_ is *-0*<sub>𝔽</sub>, return *false*.\n  1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, ~unordered~).\n  1. NOTE: Bounds checking is not a synchronizing operation when _O_'s backing buffer is a growable SharedArrayBuffer.\n  1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, return *false*.\n  1. Let _length_ be TypedArrayLength(_taRecord_).\n  1. If ℝ(_index_) < 0 or ℝ(_index_) ≥ _length_, return *false*.\n  1. Return *true*.","code":"\n          1. If IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) is *true*, return *false*.\n          1. If IsIntegralNumber(_index_) is *false*, return *false*.\n          1. If _index_ is *-0*<sub>𝔽</sub>, return *false*.\n          1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, ~unordered~).\n          1. NOTE: Bounds checking is not a synchronizing operation when _O_'s backing buffer is a growable SharedArrayBuffer.\n          1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, return *false*.\n          1. Let _length_ be TypedArrayLength(_taRecord_).\n          1. If ℝ(_index_) < 0 or ℝ(_index_) ≥ _length_, return *false*.\n          1. Return *true*.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"TypedArrayGetElement","params":[{"name":"O","ty":"Record[TypedArray]","kind":{"Normal":{}}},{"name":"index","ty":"Number","kind":{"Normal":{}}}],"retTy":"Number | BigInt | Undefined"}},"body":"\n  1. If IsValidIntegerIndex(_O_, _index_) is *false*, return *undefined*.\n  1. Let _offset_ be _O_.[[ByteOffset]].\n  1. Let _elementSize_ be TypedArrayElementSize(_O_).\n  1. Let _byteIndexInBuffer_ be ℝ(_index_) × _elementSize_ + _offset_.\n  1. Let _elementType_ be TypedArrayElementType(_O_).\n  1. Return GetValueFromBuffer(_O_.[[ViewedArrayBuffer]], _byteIndexInBuffer_, _elementType_, *true*, ~unordered~).","code":"\n          1. If IsValidIntegerIndex(_O_, _index_) is *false*, return *undefined*.\n          1. Let _offset_ be _O_.[[ByteOffset]].\n          1. Let _elementSize_ be TypedArrayElementSize(_O_).\n          1. Let _byteIndexInBuffer_ be (ℝ(_index_) × _elementSize_) + _offset_.\n          1. Let _elementType_ be TypedArrayElementType(_O_).\n          1. Return GetValueFromBuffer(_O_.[[ViewedArrayBuffer]], _byteIndexInBuffer_, _elementType_, *true*, ~unordered~).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"TypedArraySetElement","params":[{"name":"O","ty":"Record[TypedArray]","kind":{"Normal":{}}},{"name":"index","ty":"Number","kind":{"Normal":{}}},{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. If _O_.[[ContentType]] is ~bigint~, let _numValue_ be ? ToBigInt(_value_).\n  1. Else, let _numValue_ be ? ToNumber(_value_).\n  1. If IsValidIntegerIndex(_O_, _index_) is *true*, then\n    1. Let _offset_ be _O_.[[ByteOffset]].\n    1. Let _elementSize_ be TypedArrayElementSize(_O_).\n    1. Let _byteIndexInBuffer_ be ℝ(_index_) × _elementSize_ + _offset_.\n    1. Let _elementType_ be TypedArrayElementType(_O_).\n    1. Perform SetValueInBuffer(_O_.[[ViewedArrayBuffer]], _byteIndexInBuffer_, _elementType_, _numValue_, *true*, ~unordered~).\n  1. Return ~unused~.","code":"\n          1. If _O_.[[ContentType]] is ~bigint~, let _numValue_ be ? ToBigInt(_value_).\n          1. Otherwise, let _numValue_ be ? ToNumber(_value_).\n          1. If IsValidIntegerIndex(_O_, _index_) is *true*, then\n            1. Let _offset_ be _O_.[[ByteOffset]].\n            1. Let _elementSize_ be TypedArrayElementSize(_O_).\n            1. Let _byteIndexInBuffer_ be (ℝ(_index_) × _elementSize_) + _offset_.\n            1. Let _elementType_ be TypedArrayElementType(_O_).\n            1. Perform SetValueInBuffer(_O_.[[ViewedArrayBuffer]], _byteIndexInBuffer_, _elementType_, _numValue_, *true*, ~unordered~).\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsArrayBufferViewOutOfBounds","params":[{"name":"O","ty":"Record[DataView | TypedArray]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _O_ has a [[DataView]] internal slot, then\n    1. Let _viewRecord_ be MakeDataViewWithBufferWitnessRecord(_O_, ~seq-cst~).\n    1. Return IsViewOutOfBounds(_viewRecord_).\n  1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).\n  1. Return IsTypedArrayOutOfBounds(_taRecord_).","code":"\n          1. If _O_ has a [[DataView]] internal slot, then\n            1. Let _viewRecord_ be MakeDataViewWithBufferWitnessRecord(_O_, ~seq-cst~).\n            1. Return IsViewOutOfBounds(_viewRecord_).\n          1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).\n          1. Return IsTypedArrayOutOfBounds(_taRecord_).\n        "},{"head":{"InternalMethodHead":{"methodName":"GetPrototypeOf","receiver":{"name":"this","ty":"Record[ModuleNamespaceExoticObject]","kind":{"Normal":{}}},"params":[],"retTy":"Normal[Null]"}},"body":"\n  1. Return *null*.","code":"\n          1. Return *null*.\n        "},{"head":{"InternalMethodHead":{"methodName":"SetPrototypeOf","receiver":{"name":"O","ty":"Record[ModuleNamespaceExoticObject]","kind":{"Normal":{}}},"params":[{"name":"V","ty":"Record[Object] | Null","kind":{"Normal":{}}}],"retTy":"Normal[Boolean]"}},"body":"\n  1. Return ! SetImmutablePrototype(_O_, _V_).","code":"\n          1. Return ! SetImmutablePrototype(_O_, _V_).\n        "},{"head":{"InternalMethodHead":{"methodName":"IsExtensible","receiver":{"name":"this","ty":"Record[ModuleNamespaceExoticObject]","kind":{"Normal":{}}},"params":[],"retTy":"Normal[False]"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"InternalMethodHead":{"methodName":"PreventExtensions","receiver":{"name":"this","ty":"Record[ModuleNamespaceExoticObject]","kind":{"Normal":{}}},"params":[],"retTy":"Normal[True]"}},"body":"\n  1. Return *true*.","code":"\n          1. Return *true*.\n        "},{"head":{"InternalMethodHead":{"methodName":"GetOwnProperty","receiver":{"name":"O","ty":"Record[ModuleNamespaceExoticObject]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Record[PropertyDescriptor] | Undefined] | Throw"}},"body":"\n  1. If _P_ is a Record[Symbol], return OrdinaryGetOwnProperty(_O_, _P_).\n  1. Let _exports_ be _O_.[[Exports]].\n  1. If _exports_ does not contain _P_, return *undefined*.\n  1. Let _value_ be ? _O_.[[Get]](_P_, _O_).\n  1. Return PropertyDescriptor { [[Value]]: _value_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *false* }.","code":"\n          1. If _P_ is a Symbol, return OrdinaryGetOwnProperty(_O_, _P_).\n          1. Let _exports_ be _O_.[[Exports]].\n          1. If _exports_ does not contain _P_, return *undefined*.\n          1. Let _value_ be ? _O_.[[Get]](_P_, _O_).\n          1. Return PropertyDescriptor { [[Value]]: _value_, [[Writable]]: *true*, [[Enumerable]]: *true*, [[Configurable]]: *false* }.\n        "},{"head":{"InternalMethodHead":{"methodName":"DefineOwnProperty","receiver":{"name":"O","ty":"Record[ModuleNamespaceExoticObject]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}},{"name":"Desc","ty":"Record[PropertyDescriptor]","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. If _P_ is a Record[Symbol], return ! OrdinaryDefineOwnProperty(_O_, _P_, _Desc_).\n  1. Let _current_ be ? _O_.[[GetOwnProperty]](_P_).\n  1. If _current_ is *undefined*, return *false*.\n  1. If _Desc_ has a [[Configurable]] internal slot and _Desc_.[[Configurable]] is *true*, return *false*.\n  1. If _Desc_ has a [[Enumerable]] internal slot and _Desc_.[[Enumerable]] is *false*, return *false*.\n  1. If IsAccessorDescriptor(_Desc_) is *true*, return *false*.\n  1. If _Desc_ has a [[Writable]] internal slot and _Desc_.[[Writable]] is *false*, return *false*.\n  1. If _Desc_ has a [[Value]] internal slot, return SameValue(_Desc_.[[Value]], _current_.[[Value]]).\n  1. Return *true*.","code":"\n          1. If _P_ is a Symbol, return ! OrdinaryDefineOwnProperty(_O_, _P_, _Desc_).\n          1. Let _current_ be ? _O_.[[GetOwnProperty]](_P_).\n          1. If _current_ is *undefined*, return *false*.\n          1. If _Desc_ has a [[Configurable]] field and _Desc_.[[Configurable]] is *true*, return *false*.\n          1. If _Desc_ has an [[Enumerable]] field and _Desc_.[[Enumerable]] is *false*, return *false*.\n          1. If IsAccessorDescriptor(_Desc_) is *true*, return *false*.\n          1. If _Desc_ has a [[Writable]] field and _Desc_.[[Writable]] is *false*, return *false*.\n          1. If _Desc_ has a [[Value]] field, return SameValue(_Desc_.[[Value]], _current_.[[Value]]).\n          1. Return *true*.\n        "},{"head":{"InternalMethodHead":{"methodName":"HasProperty","receiver":{"name":"O","ty":"Record[ModuleNamespaceExoticObject]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Boolean]"}},"body":"\n  1. If _P_ is a Record[Symbol], return ! OrdinaryHasProperty(_O_, _P_).\n  1. Let _exports_ be _O_.[[Exports]].\n  1. If _exports_ contains _P_, return *true*.\n  1. Return *false*.","code":"\n          1. If _P_ is a Symbol, return ! OrdinaryHasProperty(_O_, _P_).\n          1. Let _exports_ be _O_.[[Exports]].\n          1. If _exports_ contains _P_, return *true*.\n          1. Return *false*.\n        "},{"head":{"InternalMethodHead":{"methodName":"Get","receiver":{"name":"O","ty":"Record[ModuleNamespaceExoticObject]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}},{"name":"Receiver","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. If _P_ is a Record[Symbol], then\n    1. Return ! OrdinaryGet(_O_, _P_, _Receiver_).\n  1. Let _exports_ be _O_.[[Exports]].\n  1. If _exports_ does not contain _P_, return *undefined*.\n  1. Let _m_ be _O_.[[Module]].\n  1. Let _binding_ be _m_.ResolveExport(_P_).\n  1. Assert: _binding_ is a Record[ResolvedBindingRecord].\n  1. Let _targetModule_ be _binding_.[[Module]].\n  1. Assert: _targetModule_ is not *undefined*.\n  1. If _binding_.[[BindingName]] is ~namespace~, then\n    1. Return GetModuleNamespace(_targetModule_).\n  1. Let _targetEnv_ be _targetModule_.[[Environment]].\n  1. If _targetEnv_ is ~empty~, throw a *ReferenceError* exception.\n  1. Return ? _targetEnv_.GetBindingValue(_binding_.[[BindingName]], *true*).","code":"\n          1. If _P_ is a Symbol, then\n            1. Return ! OrdinaryGet(_O_, _P_, _Receiver_).\n          1. Let _exports_ be _O_.[[Exports]].\n          1. If _exports_ does not contain _P_, return *undefined*.\n          1. Let _m_ be _O_.[[Module]].\n          1. Let _binding_ be _m_.ResolveExport(_P_).\n          1. Assert: _binding_ is a ResolvedBinding Record.\n          1. Let _targetModule_ be _binding_.[[Module]].\n          1. Assert: _targetModule_ is not *undefined*.\n          1. If _binding_.[[BindingName]] is ~namespace~, then\n            1. Return GetModuleNamespace(_targetModule_).\n          1. Let _targetEnv_ be _targetModule_.[[Environment]].\n          1. If _targetEnv_ is ~empty~, throw a *ReferenceError* exception.\n          1. Return ? _targetEnv_.GetBindingValue(_binding_.[[BindingName]], *true*).\n        "},{"head":{"InternalMethodHead":{"methodName":"Set","receiver":{"name":"this","ty":"Record[ModuleNamespaceExoticObject]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}},{"name":"V","ty":"ESValue","kind":{"Normal":{}}},{"name":"Receiver","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[False]"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"InternalMethodHead":{"methodName":"Delete","receiver":{"name":"O","ty":"Record[ModuleNamespaceExoticObject]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Boolean]"}},"body":"\n  1. If _P_ is a Record[Symbol], then\n    1. Return ! OrdinaryDelete(_O_, _P_).\n  1. Let _exports_ be _O_.[[Exports]].\n  1. If _exports_ contains _P_, return *false*.\n  1. Return *true*.","code":"\n          1. If _P_ is a Symbol, then\n            1. Return ! OrdinaryDelete(_O_, _P_).\n          1. Let _exports_ be _O_.[[Exports]].\n          1. If _exports_ contains _P_, return *false*.\n          1. Return *true*.\n        "},{"head":{"InternalMethodHead":{"methodName":"OwnPropertyKeys","receiver":{"name":"O","ty":"Record[ModuleNamespaceExoticObject]","kind":{"Normal":{}}},"params":[],"retTy":"Normal[List[Record[Symbol] | String]]"}},"body":"\n  1. Let _exports_ be _O_.[[Exports]].\n  1. Let _symbolKeys_ be OrdinaryOwnPropertyKeys(_O_).\n  1. Return the list-concatenation of _exports_ and _symbolKeys_.","code":"\n          1. Let _exports_ be _O_.[[Exports]].\n          1. Let _symbolKeys_ be OrdinaryOwnPropertyKeys(_O_).\n          1. Return the list-concatenation of _exports_ and _symbolKeys_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ModuleNamespaceCreate","params":[{"name":"module","ty":"Record[ModuleRecord]","kind":{"Normal":{}}},{"name":"exports","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Record[ModuleNamespaceExoticObject]"}},"body":"\n  1. Assert: _module_.[[Namespace]] is ~empty~.\n  1. Let _internalSlotsList_ be the internal slots listed in <emu-xref href=\"#table-internal-slots-of-module-namespace-exotic-objects\"></emu-xref>.\n  1. Let _M_ be MakeBasicObject(_internalSlotsList_).\n  1. Set _M_'s essential internal methods to the definitions specified in <emu-xref href=\"#sec-module-namespace-exotic-objects\"></emu-xref>.\n  1. Set _M_.[[Module]] to _module_.\n  1. [declared=\"comparefn\"] Let _sortedExports_ be a List whose elements are the elements of _exports_ ordered as if an Array of the same values had been sorted using %Array.prototype.sort% using *undefined* as _comparefn_.\n  1. Set _M_.[[Exports]] to _sortedExports_.\n  1. Create own properties of _M_ corresponding to the definitions in <emu-xref href=\"#sec-module-namespace-objects\"></emu-xref>.\n  1. Set _module_.[[Namespace]] to _M_.\n  1. Return _M_.","code":"\n          1. Assert: _module_.[[Namespace]] is ~empty~.\n          1. Let _internalSlotsList_ be the internal slots listed in <emu-xref href=\"#table-internal-slots-of-module-namespace-exotic-objects\"></emu-xref>.\n          1. Let _M_ be MakeBasicObject(_internalSlotsList_).\n          1. Set _M_'s essential internal methods to the definitions specified in <emu-xref href=\"#sec-module-namespace-exotic-objects\"></emu-xref>.\n          1. Set _M_.[[Module]] to _module_.\n          1. [declared=\"comparefn\"] Let _sortedExports_ be a List whose elements are the elements of _exports_ ordered as if an Array of the same values had been sorted using %Array.prototype.sort% using *undefined* as _comparefn_.\n          1. Set _M_.[[Exports]] to _sortedExports_.\n          1. Create own properties of _M_ corresponding to the definitions in <emu-xref href=\"#sec-module-namespace-objects\"></emu-xref>.\n          1. Set _module_.[[Namespace]] to _M_.\n          1. Return _M_.\n        "},{"head":{"InternalMethodHead":{"methodName":"SetPrototypeOf","receiver":{"name":"O","ty":"Record[ImmutablePrototypeExoticObject]","kind":{"Normal":{}}},"params":[{"name":"V","ty":"Record[Object] | Null","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Return ? SetImmutablePrototype(_O_, _V_).","code":"\n          1. Return ? SetImmutablePrototype(_O_, _V_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"SetImmutablePrototype","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"V","ty":"Record[Object] | Null","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Let _current_ be ? _O_.[[GetPrototypeOf]]().\n  1. If SameValue(_V_, _current_) is *true*, return *true*.\n  1. Return *false*.","code":"\n          1. Let _current_ be ? <emu-meta effects=\"user-code\">_O_.[[GetPrototypeOf]]</emu-meta>().\n          1. If SameValue(_V_, _current_) is *true*, return *true*.\n          1. Return *false*.\n        "},{"head":{"InternalMethodHead":{"methodName":"GetPrototypeOf","receiver":{"name":"O","ty":"Record[ProxyExoticObject]","kind":{"Normal":{}}},"params":[],"retTy":"Normal[Record[Object] | Null] | Throw"}},"body":"\n  1. Perform ? ValidateNonRevokedProxy(_O_).\n  1. Let _target_ be _O_.[[ProxyTarget]].\n  1. Let _handler_ be _O_.[[ProxyHandler]].\n  1. Assert: _handler_ is a Record[Object].\n  1. Let _trap_ be ? GetMethod(_handler_, *\"getPrototypeOf\"*).\n  1. If _trap_ is *undefined*, then\n    1. Return ? _target_.[[GetPrototypeOf]]().\n  1. Let _handlerProto_ be ? Call(_trap_, _handler_, « _target_ »).\n  1. If _handlerProto_ is not a Record[Object] and _handlerProto_ is not *null*, throw a *TypeError* exception.\n  1. Let _extensibleTarget_ be ? IsExtensible(_target_).\n  1. If _extensibleTarget_ is *true*, return _handlerProto_.\n  1. Let _targetProto_ be ? _target_.[[GetPrototypeOf]]().\n  1. If SameValue(_handlerProto_, _targetProto_) is *false*, throw a *TypeError* exception.\n  1. Return _handlerProto_.","code":"\n        1. Perform ? ValidateNonRevokedProxy(_O_).\n        1. Let _target_ be _O_.[[ProxyTarget]].\n        1. Let _handler_ be _O_.[[ProxyHandler]].\n        1. Assert: _handler_ is an Object.\n        1. Let _trap_ be ? GetMethod(_handler_, *\"getPrototypeOf\"*).\n        1. If _trap_ is *undefined*, then\n          1. Return ? <emu-meta effects=\"user-code\">_target_.[[GetPrototypeOf]]</emu-meta>().\n        1. Let _handlerProto_ be ? Call(_trap_, _handler_, « _target_ »).\n        1. If _handlerProto_ is not an Object and _handlerProto_ is not *null*, throw a *TypeError* exception.\n        1. Let _extensibleTarget_ be ? IsExtensible(_target_).\n        1. If _extensibleTarget_ is *true*, return _handlerProto_.\n        1. Let _targetProto_ be ? <emu-meta effects=\"user-code\">_target_.[[GetPrototypeOf]]</emu-meta>().\n        1. If SameValue(_handlerProto_, _targetProto_) is *false*, throw a *TypeError* exception.\n        1. Return _handlerProto_.\n      "},{"head":{"InternalMethodHead":{"methodName":"SetPrototypeOf","receiver":{"name":"O","ty":"Record[ProxyExoticObject]","kind":{"Normal":{}}},"params":[{"name":"V","ty":"Record[Object] | Null","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Perform ? ValidateNonRevokedProxy(_O_).\n  1. Let _target_ be _O_.[[ProxyTarget]].\n  1. Let _handler_ be _O_.[[ProxyHandler]].\n  1. Assert: _handler_ is a Record[Object].\n  1. Let _trap_ be ? GetMethod(_handler_, *\"setPrototypeOf\"*).\n  1. If _trap_ is *undefined*, then\n    1. Return ? _target_.[[SetPrototypeOf]](_V_).\n  1. Let _booleanTrapResult_ be ToBoolean(? Call(_trap_, _handler_, « _target_, _V_ »)).\n  1. If _booleanTrapResult_ is *false*, return *false*.\n  1. Let _extensibleTarget_ be ? IsExtensible(_target_).\n  1. If _extensibleTarget_ is *true*, return *true*.\n  1. Let _targetProto_ be ? _target_.[[GetPrototypeOf]]().\n  1. If SameValue(_V_, _targetProto_) is *false*, throw a *TypeError* exception.\n  1. Return *true*.","code":"\n        1. Perform ? ValidateNonRevokedProxy(_O_).\n        1. Let _target_ be _O_.[[ProxyTarget]].\n        1. Let _handler_ be _O_.[[ProxyHandler]].\n        1. Assert: _handler_ is an Object.\n        1. Let _trap_ be ? GetMethod(_handler_, *\"setPrototypeOf\"*).\n        1. If _trap_ is *undefined*, then\n          1. Return ? <emu-meta effects=\"user-code\">_target_.[[SetPrototypeOf]]</emu-meta>(_V_).\n        1. Let _booleanTrapResult_ be ToBoolean(? Call(_trap_, _handler_, « _target_, _V_ »)).\n        1. If _booleanTrapResult_ is *false*, return *false*.\n        1. Let _extensibleTarget_ be ? IsExtensible(_target_).\n        1. If _extensibleTarget_ is *true*, return *true*.\n        1. Let _targetProto_ be ? <emu-meta effects=\"user-code\">_target_.[[GetPrototypeOf]]</emu-meta>().\n        1. If SameValue(_V_, _targetProto_) is *false*, throw a *TypeError* exception.\n        1. Return *true*.\n      "},{"head":{"InternalMethodHead":{"methodName":"IsExtensible","receiver":{"name":"O","ty":"Record[ProxyExoticObject]","kind":{"Normal":{}}},"params":[],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Perform ? ValidateNonRevokedProxy(_O_).\n  1. Let _target_ be _O_.[[ProxyTarget]].\n  1. Let _handler_ be _O_.[[ProxyHandler]].\n  1. Assert: _handler_ is a Record[Object].\n  1. Let _trap_ be ? GetMethod(_handler_, *\"isExtensible\"*).\n  1. If _trap_ is *undefined*, then\n    1. Return ? IsExtensible(_target_).\n  1. Let _booleanTrapResult_ be ToBoolean(? Call(_trap_, _handler_, « _target_ »)).\n  1. Let _targetResult_ be ? IsExtensible(_target_).\n  1. If _booleanTrapResult_ is not _targetResult_, throw a *TypeError* exception.\n  1. Return _booleanTrapResult_.","code":"\n        1. Perform ? ValidateNonRevokedProxy(_O_).\n        1. Let _target_ be _O_.[[ProxyTarget]].\n        1. Let _handler_ be _O_.[[ProxyHandler]].\n        1. Assert: _handler_ is an Object.\n        1. Let _trap_ be ? GetMethod(_handler_, *\"isExtensible\"*).\n        1. If _trap_ is *undefined*, then\n          1. Return ? IsExtensible(_target_).\n        1. Let _booleanTrapResult_ be ToBoolean(? Call(_trap_, _handler_, « _target_ »)).\n        1. Let _targetResult_ be ? IsExtensible(_target_).\n        1. If _booleanTrapResult_ is not _targetResult_, throw a *TypeError* exception.\n        1. Return _booleanTrapResult_.\n      "},{"head":{"InternalMethodHead":{"methodName":"PreventExtensions","receiver":{"name":"O","ty":"Record[ProxyExoticObject]","kind":{"Normal":{}}},"params":[],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Perform ? ValidateNonRevokedProxy(_O_).\n  1. Let _target_ be _O_.[[ProxyTarget]].\n  1. Let _handler_ be _O_.[[ProxyHandler]].\n  1. Assert: _handler_ is a Record[Object].\n  1. Let _trap_ be ? GetMethod(_handler_, *\"preventExtensions\"*).\n  1. If _trap_ is *undefined*, then\n    1. Return ? _target_.[[PreventExtensions]]().\n  1. Let _booleanTrapResult_ be ToBoolean(? Call(_trap_, _handler_, « _target_ »)).\n  1. If _booleanTrapResult_ is *true*, then\n    1. Let _extensibleTarget_ be ? IsExtensible(_target_).\n    1. If _extensibleTarget_ is *true*, throw a *TypeError* exception.\n  1. Return _booleanTrapResult_.","code":"\n        1. Perform ? ValidateNonRevokedProxy(_O_).\n        1. Let _target_ be _O_.[[ProxyTarget]].\n        1. Let _handler_ be _O_.[[ProxyHandler]].\n        1. Assert: _handler_ is an Object.\n        1. Let _trap_ be ? GetMethod(_handler_, *\"preventExtensions\"*).\n        1. If _trap_ is *undefined*, then\n          1. Return ? <emu-meta effects=\"user-code\">_target_.[[PreventExtensions]]()</emu-meta>.\n        1. Let _booleanTrapResult_ be ToBoolean(? Call(_trap_, _handler_, « _target_ »)).\n        1. If _booleanTrapResult_ is *true*, then\n          1. Let _extensibleTarget_ be ? IsExtensible(_target_).\n          1. If _extensibleTarget_ is *true*, throw a *TypeError* exception.\n        1. Return _booleanTrapResult_.\n      "},{"head":{"InternalMethodHead":{"methodName":"GetOwnProperty","receiver":{"name":"O","ty":"Record[ProxyExoticObject]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Record[PropertyDescriptor] | Undefined] | Throw"}},"body":"\n  1. Perform ? ValidateNonRevokedProxy(_O_).\n  1. Let _target_ be _O_.[[ProxyTarget]].\n  1. Let _handler_ be _O_.[[ProxyHandler]].\n  1. Assert: _handler_ is a Record[Object].\n  1. Let _trap_ be ? GetMethod(_handler_, *\"getOwnPropertyDescriptor\"*).\n  1. If _trap_ is *undefined*, then\n    1. Return ? _target_.[[GetOwnProperty]](_P_).\n  1. Let _trapResultObj_ be ? Call(_trap_, _handler_, « _target_, _P_ »).\n  1. If _trapResultObj_ is not a Record[Object] and _trapResultObj_ is not *undefined*, throw a *TypeError* exception.\n  1. Let _targetDesc_ be ? _target_.[[GetOwnProperty]](_P_).\n  1. If _trapResultObj_ is *undefined*, then\n    1. If _targetDesc_ is *undefined*, return *undefined*.\n    1. If _targetDesc_.[[Configurable]] is *false*, throw a *TypeError* exception.\n    1. Let _extensibleTarget_ be ? IsExtensible(_target_).\n    1. If _extensibleTarget_ is *false*, throw a *TypeError* exception.\n    1. Return *undefined*.\n  1. Let _extensibleTarget_ be ? IsExtensible(_target_).\n  1. Let _resultDesc_ be ? ToPropertyDescriptor(_trapResultObj_).\n  1. Perform CompletePropertyDescriptor(_resultDesc_).\n  1. Let _valid_ be IsCompatiblePropertyDescriptor(_extensibleTarget_, _resultDesc_, _targetDesc_).\n  1. If _valid_ is *false*, throw a *TypeError* exception.\n  1. If _resultDesc_.[[Configurable]] is *false*, then\n    1. If _targetDesc_ is *undefined* or _targetDesc_.[[Configurable]] is *true*, then\n      1. Throw a *TypeError* exception.\n    1. If _resultDesc_ has a [[Writable]] internal slot and _resultDesc_.[[Writable]] is *false*, then\n      1. Assert: _targetDesc_ has a [[Writable]] internal slot.\n      1. If _targetDesc_.[[Writable]] is *true*, throw a *TypeError* exception.\n  1. Return _resultDesc_.","code":"\n        1. Perform ? ValidateNonRevokedProxy(_O_).\n        1. Let _target_ be _O_.[[ProxyTarget]].\n        1. Let _handler_ be _O_.[[ProxyHandler]].\n        1. Assert: _handler_ is an Object.\n        1. Let _trap_ be ? GetMethod(_handler_, *\"getOwnPropertyDescriptor\"*).\n        1. If _trap_ is *undefined*, then\n          1. Return ? <emu-meta effects=\"user-code\">_target_.[[GetOwnProperty]]</emu-meta>(_P_).\n        1. Let _trapResultObj_ be ? Call(_trap_, _handler_, « _target_, _P_ »).\n        1. If _trapResultObj_ is not an Object and _trapResultObj_ is not *undefined*, throw a *TypeError* exception.\n        1. Let _targetDesc_ be ? <emu-meta effects=\"user-code\">_target_.[[GetOwnProperty]]</emu-meta>(_P_).\n        1. If _trapResultObj_ is *undefined*, then\n          1. If _targetDesc_ is *undefined*, return *undefined*.\n          1. If _targetDesc_.[[Configurable]] is *false*, throw a *TypeError* exception.\n          1. Let _extensibleTarget_ be ? IsExtensible(_target_).\n          1. If _extensibleTarget_ is *false*, throw a *TypeError* exception.\n          1. Return *undefined*.\n        1. Let _extensibleTarget_ be ? IsExtensible(_target_).\n        1. Let _resultDesc_ be ? ToPropertyDescriptor(_trapResultObj_).\n        1. Perform CompletePropertyDescriptor(_resultDesc_).\n        1. Let _valid_ be IsCompatiblePropertyDescriptor(_extensibleTarget_, _resultDesc_, _targetDesc_).\n        1. If _valid_ is *false*, throw a *TypeError* exception.\n        1. If _resultDesc_.[[Configurable]] is *false*, then\n          1. If _targetDesc_ is *undefined* or _targetDesc_.[[Configurable]] is *true*, then\n            1. Throw a *TypeError* exception.\n          1. If _resultDesc_ has a [[Writable]] field and _resultDesc_.[[Writable]] is *false*, then\n            1. Assert: _targetDesc_ has a [[Writable]] field.\n            1. If _targetDesc_.[[Writable]] is *true*, throw a *TypeError* exception.\n        1. Return _resultDesc_.\n      "},{"head":{"InternalMethodHead":{"methodName":"DefineOwnProperty","receiver":{"name":"O","ty":"Record[ProxyExoticObject]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}},{"name":"Desc","ty":"Record[PropertyDescriptor]","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Perform ? ValidateNonRevokedProxy(_O_).\n  1. Let _target_ be _O_.[[ProxyTarget]].\n  1. Let _handler_ be _O_.[[ProxyHandler]].\n  1. Assert: _handler_ is a Record[Object].\n  1. Let _trap_ be ? GetMethod(_handler_, *\"defineProperty\"*).\n  1. If _trap_ is *undefined*, then\n    1. Return ? _target_.[[DefineOwnProperty]](_P_, _Desc_).\n  1. Let _descObj_ be FromPropertyDescriptor(_Desc_).\n  1. Let _booleanTrapResult_ be ToBoolean(? Call(_trap_, _handler_, « _target_, _P_, _descObj_ »)).\n  1. If _booleanTrapResult_ is *false*, return *false*.\n  1. Let _targetDesc_ be ? _target_.[[GetOwnProperty]](_P_).\n  1. Let _extensibleTarget_ be ? IsExtensible(_target_).\n  1. If _Desc_ has a [[Configurable]] internal slot and _Desc_.[[Configurable]] is *false*, then\n    1. Let _settingConfigFalse_ be *true*.\n  1. Else,\n    1. Let _settingConfigFalse_ be *false*.\n  1. If _targetDesc_ is *undefined*, then\n    1. If _extensibleTarget_ is *false*, throw a *TypeError* exception.\n    1. If _settingConfigFalse_ is *true*, throw a *TypeError* exception.\n  1. Else,\n    1. If IsCompatiblePropertyDescriptor(_extensibleTarget_, _Desc_, _targetDesc_) is *false*, throw a *TypeError* exception.\n    1. If _settingConfigFalse_ is *true* and _targetDesc_.[[Configurable]] is *true*, throw a *TypeError* exception.\n    1. If IsDataDescriptor(_targetDesc_) is *true* and _targetDesc_.[[Configurable]] is *false* and _targetDesc_.[[Writable]] is *true*, then\n      1. If _Desc_ has a [[Writable]] internal slot and _Desc_.[[Writable]] is *false*, throw a *TypeError* exception.\n  1. Return *true*.","code":"\n        1. Perform ? ValidateNonRevokedProxy(_O_).\n        1. Let _target_ be _O_.[[ProxyTarget]].\n        1. Let _handler_ be _O_.[[ProxyHandler]].\n        1. Assert: _handler_ is an Object.\n        1. Let _trap_ be ? GetMethod(_handler_, *\"defineProperty\"*).\n        1. If _trap_ is *undefined*, then\n          1. Return ? <emu-meta effects=\"user-code\">_target_.[[DefineOwnProperty]]</emu-meta>(_P_, _Desc_).\n        1. Let _descObj_ be FromPropertyDescriptor(_Desc_).\n        1. Let _booleanTrapResult_ be ToBoolean(? Call(_trap_, _handler_, « _target_, _P_, _descObj_ »)).\n        1. If _booleanTrapResult_ is *false*, return *false*.\n        1. Let _targetDesc_ be ? <emu-meta effects=\"user-code\">_target_.[[GetOwnProperty]]</emu-meta>(_P_).\n        1. Let _extensibleTarget_ be ? IsExtensible(_target_).\n        1. If _Desc_ has a [[Configurable]] field and _Desc_.[[Configurable]] is *false*, then\n          1. Let _settingConfigFalse_ be *true*.\n        1. Else,\n          1. Let _settingConfigFalse_ be *false*.\n        1. If _targetDesc_ is *undefined*, then\n          1. If _extensibleTarget_ is *false*, throw a *TypeError* exception.\n          1. If _settingConfigFalse_ is *true*, throw a *TypeError* exception.\n        1. Else,\n          1. If IsCompatiblePropertyDescriptor(_extensibleTarget_, _Desc_, _targetDesc_) is *false*, throw a *TypeError* exception.\n          1. If _settingConfigFalse_ is *true* and _targetDesc_.[[Configurable]] is *true*, throw a *TypeError* exception.\n          1. If IsDataDescriptor(_targetDesc_) is *true*, _targetDesc_.[[Configurable]] is *false*, and _targetDesc_.[[Writable]] is *true*, then\n            1. If _Desc_ has a [[Writable]] field and _Desc_.[[Writable]] is *false*, throw a *TypeError* exception.\n        1. Return *true*.\n      "},{"head":{"InternalMethodHead":{"methodName":"HasProperty","receiver":{"name":"O","ty":"Record[ProxyExoticObject]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Perform ? ValidateNonRevokedProxy(_O_).\n  1. Let _target_ be _O_.[[ProxyTarget]].\n  1. Let _handler_ be _O_.[[ProxyHandler]].\n  1. Assert: _handler_ is a Record[Object].\n  1. Let _trap_ be ? GetMethod(_handler_, *\"has\"*).\n  1. If _trap_ is *undefined*, then\n    1. Return ? _target_.[[HasProperty]](_P_).\n  1. Let _booleanTrapResult_ be ToBoolean(? Call(_trap_, _handler_, « _target_, _P_ »)).\n  1. If _booleanTrapResult_ is *false*, then\n    1. Let _targetDesc_ be ? _target_.[[GetOwnProperty]](_P_).\n    1. If _targetDesc_ is not *undefined*, then\n      1. If _targetDesc_.[[Configurable]] is *false*, throw a *TypeError* exception.\n      1. Let _extensibleTarget_ be ? IsExtensible(_target_).\n      1. If _extensibleTarget_ is *false*, throw a *TypeError* exception.\n  1. Return _booleanTrapResult_.","code":"\n        1. Perform ? ValidateNonRevokedProxy(_O_).\n        1. Let _target_ be _O_.[[ProxyTarget]].\n        1. Let _handler_ be _O_.[[ProxyHandler]].\n        1. Assert: _handler_ is an Object.\n        1. Let _trap_ be ? GetMethod(_handler_, *\"has\"*).\n        1. If _trap_ is *undefined*, then\n          1. Return ? <emu-meta effects=\"user-code\">_target_.[[HasProperty]]</emu-meta>(_P_).\n        1. Let _booleanTrapResult_ be ToBoolean(? Call(_trap_, _handler_, « _target_, _P_ »)).\n        1. If _booleanTrapResult_ is *false*, then\n          1. Let _targetDesc_ be ? <emu-meta effects=\"user-code\">_target_.[[GetOwnProperty]]</emu-meta>(_P_).\n          1. If _targetDesc_ is not *undefined*, then\n            1. If _targetDesc_.[[Configurable]] is *false*, throw a *TypeError* exception.\n            1. Let _extensibleTarget_ be ? IsExtensible(_target_).\n            1. If _extensibleTarget_ is *false*, throw a *TypeError* exception.\n        1. Return _booleanTrapResult_.\n      "},{"head":{"InternalMethodHead":{"methodName":"Get","receiver":{"name":"O","ty":"Record[ProxyExoticObject]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}},{"name":"Receiver","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Perform ? ValidateNonRevokedProxy(_O_).\n  1. Let _target_ be _O_.[[ProxyTarget]].\n  1. Let _handler_ be _O_.[[ProxyHandler]].\n  1. Assert: _handler_ is a Record[Object].\n  1. Let _trap_ be ? GetMethod(_handler_, *\"get\"*).\n  1. If _trap_ is *undefined*, then\n    1. Return ? _target_.[[Get]](_P_, _Receiver_).\n  1. Let _trapResult_ be ? Call(_trap_, _handler_, « _target_, _P_, _Receiver_ »).\n  1. Let _targetDesc_ be ? _target_.[[GetOwnProperty]](_P_).\n  1. If _targetDesc_ is not *undefined* and _targetDesc_.[[Configurable]] is *false*, then\n    1. If IsDataDescriptor(_targetDesc_) is *true* and _targetDesc_.[[Writable]] is *false*, then\n      1. If SameValue(_trapResult_, _targetDesc_.[[Value]]) is *false*, throw a *TypeError* exception.\n    1. If IsAccessorDescriptor(_targetDesc_) is *true* and _targetDesc_.[[Get]] is *undefined*, then\n      1. If _trapResult_ is not *undefined*, throw a *TypeError* exception.\n  1. Return _trapResult_.","code":"\n        1. Perform ? ValidateNonRevokedProxy(_O_).\n        1. Let _target_ be _O_.[[ProxyTarget]].\n        1. Let _handler_ be _O_.[[ProxyHandler]].\n        1. Assert: _handler_ is an Object.\n        1. Let _trap_ be ? GetMethod(_handler_, *\"get\"*).\n        1. If _trap_ is *undefined*, then\n          1. Return ? <emu-meta effects=\"user-code\">_target_.[[Get]]</emu-meta>(_P_, _Receiver_).\n        1. Let _trapResult_ be ? Call(_trap_, _handler_, « _target_, _P_, _Receiver_ »).\n        1. Let _targetDesc_ be ? <emu-meta effects=\"user-code\">_target_.[[GetOwnProperty]]</emu-meta>(_P_).\n        1. If _targetDesc_ is not *undefined* and _targetDesc_.[[Configurable]] is *false*, then\n          1. If IsDataDescriptor(_targetDesc_) is *true* and _targetDesc_.[[Writable]] is *false*, then\n            1. If SameValue(_trapResult_, _targetDesc_.[[Value]]) is *false*, throw a *TypeError* exception.\n          1. If IsAccessorDescriptor(_targetDesc_) is *true* and _targetDesc_.[[Get]] is *undefined*, then\n            1. If _trapResult_ is not *undefined*, throw a *TypeError* exception.\n        1. Return _trapResult_.\n      "},{"head":{"InternalMethodHead":{"methodName":"Set","receiver":{"name":"O","ty":"Record[ProxyExoticObject]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}},{"name":"V","ty":"ESValue","kind":{"Normal":{}}},{"name":"Receiver","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Perform ? ValidateNonRevokedProxy(_O_).\n  1. Let _target_ be _O_.[[ProxyTarget]].\n  1. Let _handler_ be _O_.[[ProxyHandler]].\n  1. Assert: _handler_ is a Record[Object].\n  1. Let _trap_ be ? GetMethod(_handler_, *\"set\"*).\n  1. If _trap_ is *undefined*, then\n    1. Return ? _target_.[[Set]](_P_, _V_, _Receiver_).\n  1. Let _booleanTrapResult_ be ToBoolean(? Call(_trap_, _handler_, « _target_, _P_, _V_, _Receiver_ »)).\n  1. If _booleanTrapResult_ is *false*, return *false*.\n  1. Let _targetDesc_ be ? _target_.[[GetOwnProperty]](_P_).\n  1. If _targetDesc_ is not *undefined* and _targetDesc_.[[Configurable]] is *false*, then\n    1. If IsDataDescriptor(_targetDesc_) is *true* and _targetDesc_.[[Writable]] is *false*, then\n      1. If SameValue(_V_, _targetDesc_.[[Value]]) is *false*, throw a *TypeError* exception.\n    1. If IsAccessorDescriptor(_targetDesc_) is *true*, then\n      1. If _targetDesc_.[[Set]] is *undefined*, throw a *TypeError* exception.\n  1. Return *true*.","code":"\n        1. Perform ? ValidateNonRevokedProxy(_O_).\n        1. Let _target_ be _O_.[[ProxyTarget]].\n        1. Let _handler_ be _O_.[[ProxyHandler]].\n        1. Assert: _handler_ is an Object.\n        1. Let _trap_ be ? GetMethod(_handler_, *\"set\"*).\n        1. If _trap_ is *undefined*, then\n          1. Return ? <emu-meta effects=\"user-code\">_target_.[[Set]]</emu-meta>(_P_, _V_, _Receiver_).\n        1. Let _booleanTrapResult_ be ToBoolean(? Call(_trap_, _handler_, « _target_, _P_, _V_, _Receiver_ »)).\n        1. If _booleanTrapResult_ is *false*, return *false*.\n        1. Let _targetDesc_ be ? <emu-meta effects=\"user-code\">_target_.[[GetOwnProperty]]</emu-meta>(_P_).\n        1. If _targetDesc_ is not *undefined* and _targetDesc_.[[Configurable]] is *false*, then\n          1. If IsDataDescriptor(_targetDesc_) is *true* and _targetDesc_.[[Writable]] is *false*, then\n            1. If SameValue(_V_, _targetDesc_.[[Value]]) is *false*, throw a *TypeError* exception.\n          1. If IsAccessorDescriptor(_targetDesc_) is *true*, then\n            1. If _targetDesc_.[[Set]] is *undefined*, throw a *TypeError* exception.\n        1. Return *true*.\n      "},{"head":{"InternalMethodHead":{"methodName":"Delete","receiver":{"name":"O","ty":"Record[ProxyExoticObject]","kind":{"Normal":{}}},"params":[{"name":"P","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. Perform ? ValidateNonRevokedProxy(_O_).\n  1. Let _target_ be _O_.[[ProxyTarget]].\n  1. Let _handler_ be _O_.[[ProxyHandler]].\n  1. Assert: _handler_ is a Record[Object].\n  1. Let _trap_ be ? GetMethod(_handler_, *\"deleteProperty\"*).\n  1. If _trap_ is *undefined*, then\n    1. Return ? _target_.[[Delete]](_P_).\n  1. Let _booleanTrapResult_ be ToBoolean(? Call(_trap_, _handler_, « _target_, _P_ »)).\n  1. If _booleanTrapResult_ is *false*, return *false*.\n  1. Let _targetDesc_ be ? _target_.[[GetOwnProperty]](_P_).\n  1. If _targetDesc_ is *undefined*, return *true*.\n  1. If _targetDesc_.[[Configurable]] is *false*, throw a *TypeError* exception.\n  1. Let _extensibleTarget_ be ? IsExtensible(_target_).\n  1. If _extensibleTarget_ is *false*, throw a *TypeError* exception.\n  1. Return *true*.","code":"\n        1. Perform ? ValidateNonRevokedProxy(_O_).\n        1. Let _target_ be _O_.[[ProxyTarget]].\n        1. Let _handler_ be _O_.[[ProxyHandler]].\n        1. Assert: _handler_ is an Object.\n        1. Let _trap_ be ? GetMethod(_handler_, *\"deleteProperty\"*).\n        1. If _trap_ is *undefined*, then\n          1. Return ? <emu-meta effects=\"user-code\">_target_.[[Delete]]</emu-meta>(_P_).\n        1. Let _booleanTrapResult_ be ToBoolean(? Call(_trap_, _handler_, « _target_, _P_ »)).\n        1. If _booleanTrapResult_ is *false*, return *false*.\n        1. Let _targetDesc_ be ? <emu-meta effects=\"user-code\">_target_.[[GetOwnProperty]]</emu-meta>(_P_).\n        1. If _targetDesc_ is *undefined*, return *true*.\n        1. If _targetDesc_.[[Configurable]] is *false*, throw a *TypeError* exception.\n        1. Let _extensibleTarget_ be ? IsExtensible(_target_).\n        1. If _extensibleTarget_ is *false*, throw a *TypeError* exception.\n        1. Return *true*.\n      "},{"head":{"InternalMethodHead":{"methodName":"OwnPropertyKeys","receiver":{"name":"O","ty":"Record[ProxyExoticObject]","kind":{"Normal":{}}},"params":[],"retTy":"Normal[List[Record[Symbol] | String]] | Throw"}},"body":"\n  1. Perform ? ValidateNonRevokedProxy(_O_).\n  1. Let _target_ be _O_.[[ProxyTarget]].\n  1. Let _handler_ be _O_.[[ProxyHandler]].\n  1. Assert: _handler_ is a Record[Object].\n  1. Let _trap_ be ? GetMethod(_handler_, *\"ownKeys\"*).\n  1. If _trap_ is *undefined*, then\n    1. Return ? _target_.[[OwnPropertyKeys]]().\n  1. Let _trapResultArray_ be ? Call(_trap_, _handler_, « _target_ »).\n  1. Let _trapResult_ be ? CreateListFromArrayLike(_trapResultArray_, « String, Symbol »).\n  1. If _trapResult_ is duplicate entries, throw a *TypeError* exception.\n  1. Let _extensibleTarget_ be ? IsExtensible(_target_).\n  1. Let _targetKeys_ be ? _target_.[[OwnPropertyKeys]]().\n  1. Assert: _targetKeys_ is a List[Record[Symbol] | String].\n  1. Assert: _targetKeys_ is not duplicate entries.\n  1. Let _targetConfigurableKeys_ be « ».\n  1. Let _targetNonconfigurableKeys_ be « ».\n  1. For each _key_ of _targetKeys_, do\n    1. Let _desc_ be ? _target_.[[GetOwnProperty]](_key_).\n    1. If _desc_ is not *undefined* and _desc_.[[Configurable]] is *false*, then\n      1. Append _key_ to _targetNonconfigurableKeys_.\n    1. Else,\n      1. Append _key_ to _targetConfigurableKeys_.\n  1. If _extensibleTarget_ is *true* and _targetNonconfigurableKeys_ is empty, then\n    1. Return _trapResult_.\n  1. Let _uncheckedResultKeys_ be a List whose elements are the elements of _trapResult_.\n  1. For each _key_ of _targetNonconfigurableKeys_, do\n    1. If _uncheckedResultKeys_ does not contain _key_, throw a *TypeError* exception.\n    1. Remove _key_ from _uncheckedResultKeys_.\n  1. If _extensibleTarget_ is *true*, return _trapResult_.\n  1. For each _key_ of _targetConfigurableKeys_, do\n    1. If _uncheckedResultKeys_ does not contain _key_, throw a *TypeError* exception.\n    1. Remove _key_ from _uncheckedResultKeys_.\n  1. If _uncheckedResultKeys_ is not empty, throw a *TypeError* exception.\n  1. Return _trapResult_.","code":"\n        1. Perform ? ValidateNonRevokedProxy(_O_).\n        1. Let _target_ be _O_.[[ProxyTarget]].\n        1. Let _handler_ be _O_.[[ProxyHandler]].\n        1. Assert: _handler_ is an Object.\n        1. Let _trap_ be ? GetMethod(_handler_, *\"ownKeys\"*).\n        1. If _trap_ is *undefined*, then\n          1. Return ? <emu-meta effects=\"user-code\">_target_.[[OwnPropertyKeys]]()</emu-meta>.\n        1. Let _trapResultArray_ be ? Call(_trap_, _handler_, « _target_ »).\n        1. Let _trapResult_ be ? CreateListFromArrayLike(_trapResultArray_, « String, Symbol »).\n        1. If _trapResult_ contains any duplicate entries, throw a *TypeError* exception.\n        1. Let _extensibleTarget_ be ? IsExtensible(_target_).\n        1. Let _targetKeys_ be ? <emu-meta effects=\"user-code\">_target_.[[OwnPropertyKeys]]()</emu-meta>.\n        1. Assert: _targetKeys_ is a List of property keys.\n        1. Assert: _targetKeys_ contains no duplicate entries.\n        1. Let _targetConfigurableKeys_ be a new empty List.\n        1. Let _targetNonconfigurableKeys_ be a new empty List.\n        1. For each element _key_ of _targetKeys_, do\n          1. Let _desc_ be ? <emu-meta effects=\"user-code\">_target_.[[GetOwnProperty]]</emu-meta>(_key_).\n          1. If _desc_ is not *undefined* and _desc_.[[Configurable]] is *false*, then\n            1. Append _key_ to _targetNonconfigurableKeys_.\n          1. Else,\n            1. Append _key_ to _targetConfigurableKeys_.\n        1. If _extensibleTarget_ is *true* and _targetNonconfigurableKeys_ is empty, then\n          1. Return _trapResult_.\n        1. Let _uncheckedResultKeys_ be a List whose elements are the elements of _trapResult_.\n        1. For each element _key_ of _targetNonconfigurableKeys_, do\n          1. If _uncheckedResultKeys_ does not contain _key_, throw a *TypeError* exception.\n          1. Remove _key_ from _uncheckedResultKeys_.\n        1. If _extensibleTarget_ is *true*, return _trapResult_.\n        1. For each element _key_ of _targetConfigurableKeys_, do\n          1. If _uncheckedResultKeys_ does not contain _key_, throw a *TypeError* exception.\n          1. Remove _key_ from _uncheckedResultKeys_.\n        1. If _uncheckedResultKeys_ is not empty, throw a *TypeError* exception.\n        1. Return _trapResult_.\n      "},{"head":{"InternalMethodHead":{"methodName":"Call","receiver":{"name":"O","ty":"Record[ProxyExoticObject]","kind":{"Normal":{}}},"params":[{"name":"thisArgument","ty":"ESValue","kind":{"Normal":{}}},{"name":"argumentsList","ty":"List[ESValue]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Perform ? ValidateNonRevokedProxy(_O_).\n  1. Let _target_ be _O_.[[ProxyTarget]].\n  1. Let _handler_ be _O_.[[ProxyHandler]].\n  1. Assert: _handler_ is a Record[Object].\n  1. Let _trap_ be ? GetMethod(_handler_, *\"apply\"*).\n  1. If _trap_ is *undefined*, then\n    1. Return ? Call(_target_, _thisArgument_, _argumentsList_).\n  1. Let _argArray_ be CreateArrayFromList(_argumentsList_).\n  1. Return ? Call(_trap_, _handler_, « _target_, _thisArgument_, _argArray_ »).","code":"\n        1. Perform ? ValidateNonRevokedProxy(_O_).\n        1. Let _target_ be _O_.[[ProxyTarget]].\n        1. Let _handler_ be _O_.[[ProxyHandler]].\n        1. Assert: _handler_ is an Object.\n        1. Let _trap_ be ? GetMethod(_handler_, *\"apply\"*).\n        1. If _trap_ is *undefined*, then\n          1. Return ? Call(_target_, _thisArgument_, _argumentsList_).\n        1. Let _argArray_ be CreateArrayFromList(_argumentsList_).\n        1. Return ? Call(_trap_, _handler_, « _target_, _thisArgument_, _argArray_ »).\n      "},{"head":{"InternalMethodHead":{"methodName":"Construct","receiver":{"name":"O","ty":"Record[ProxyExoticObject]","kind":{"Normal":{}}},"params":[{"name":"argumentsList","ty":"List[ESValue]","kind":{"Normal":{}}},{"name":"newTarget","ty":"Record[Constructor]","kind":{"Normal":{}}}],"retTy":"Normal[Record[Object]] | Throw"}},"body":"\n  1. Perform ? ValidateNonRevokedProxy(_O_).\n  1. Let _target_ be _O_.[[ProxyTarget]].\n  1. Assert: IsConstructor(_target_) is *true*.\n  1. Let _handler_ be _O_.[[ProxyHandler]].\n  1. Assert: _handler_ is a Record[Object].\n  1. Let _trap_ be ? GetMethod(_handler_, *\"construct\"*).\n  1. If _trap_ is *undefined*, then\n    1. Return ? Construct(_target_, _argumentsList_, _newTarget_).\n  1. Let _argArray_ be CreateArrayFromList(_argumentsList_).\n  1. Let _newObj_ be ? Call(_trap_, _handler_, « _target_, _argArray_, _newTarget_ »).\n  1. If _newObj_ is not a Record[Object], throw a *TypeError* exception.\n  1. Return _newObj_.","code":"\n        1. Perform ? ValidateNonRevokedProxy(_O_).\n        1. Let _target_ be _O_.[[ProxyTarget]].\n        1. Assert: IsConstructor(_target_) is *true*.\n        1. Let _handler_ be _O_.[[ProxyHandler]].\n        1. Assert: _handler_ is an Object.\n        1. Let _trap_ be ? GetMethod(_handler_, *\"construct\"*).\n        1. If _trap_ is *undefined*, then\n          1. Return ? Construct(_target_, _argumentsList_, _newTarget_).\n        1. Let _argArray_ be CreateArrayFromList(_argumentsList_).\n        1. Let _newObj_ be ? Call(_trap_, _handler_, « _target_, _argArray_, _newTarget_ »).\n        1. If _newObj_ is not an Object, throw a *TypeError* exception.\n        1. Return _newObj_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ValidateNonRevokedProxy","params":[{"name":"proxy","ty":"Record[ProxyExoticObject]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. If _proxy_.[[ProxyTarget]] is *null*, throw a *TypeError* exception.\n  1. Assert: _proxy_.[[ProxyHandler]] is not *null*.\n  1. Return ~unused~.","code":"\n        1. If _proxy_.[[ProxyTarget]] is *null*, throw a *TypeError* exception.\n        1. Assert: _proxy_.[[ProxyHandler]] is not *null*.\n        1. Return ~unused~.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ProxyCreate","params":[{"name":"target","ty":"ESValue","kind":{"Normal":{}}},{"name":"handler","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Record[ProxyExoticObject]] | Throw"}},"body":"\n  1. If _target_ is not a Record[Object], throw a *TypeError* exception.\n  1. If _handler_ is not a Record[Object], throw a *TypeError* exception.\n  1. Let _P_ be MakeBasicObject(« [[ProxyHandler]], [[ProxyTarget]] »).\n  1. Set _P_'s essential internal methods, except for [[Call]] and [[Construct]], to the definitions specified in <emu-xref href=\"#sec-proxy-object-internal-methods-and-internal-slots\"></emu-xref>.\n  1. If IsCallable(_target_) is *true*, then\n    1. Set _P_.[[Call]] to the definition specified in <emu-xref href=\"#sec-proxy-object-internal-methods-and-internal-slots-call-thisargument-argumentslist\"></emu-xref>.\n    1. If IsConstructor(_target_) is *true*, then\n      1. Set _P_.[[Construct]] to the definition specified in <emu-xref href=\"#sec-proxy-object-internal-methods-and-internal-slots-construct-argumentslist-newtarget\"></emu-xref>.\n  1. Set _P_.[[ProxyTarget]] to _target_.\n  1. Set _P_.[[ProxyHandler]] to _handler_.\n  1. Return _P_.","code":"\n        1. If _target_ is not an Object, throw a *TypeError* exception.\n        1. If _handler_ is not an Object, throw a *TypeError* exception.\n        1. Let _P_ be MakeBasicObject(« [[ProxyHandler]], [[ProxyTarget]] »).\n        1. Set _P_'s essential internal methods, except for [[Call]] and [[Construct]], to the definitions specified in <emu-xref href=\"#sec-proxy-object-internal-methods-and-internal-slots\"></emu-xref>.\n        1. If IsCallable(_target_) is *true*, then\n          1. Set _P_.[[Call]] as specified in <emu-xref href=\"#sec-proxy-object-internal-methods-and-internal-slots-call-thisargument-argumentslist\"></emu-xref>.\n          1. If IsConstructor(_target_) is *true*, then\n            1. Set _P_.[[Construct]] as specified in <emu-xref href=\"#sec-proxy-object-internal-methods-and-internal-slots-construct-argumentslist-newtarget\"></emu-xref>.\n        1. Set _P_.[[ProxyTarget]] to _target_.\n        1. Set _P_.[[ProxyHandler]] to _handler_.\n        1. Return _P_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"UTF16EncodeCodePoint","params":[{"name":"cp","ty":"Unknown[\"a Unicode code point\"]","kind":{"Normal":{}}}],"retTy":"String"}},"body":"\n  1. Assert: 0 ≤ _cp_ ≤ 0x10FFFF..\n  1. If _cp_ ≤ 0xffff, return the String value consisting of the code unit whose numeric value is _cp_.\n  1. Let _cu1_ be the code unit whose numeric value is floor((_cp_ - 0x10000) / 0x400) + 0xD800.\n  1. Let _cu2_ be the code unit whose numeric value is ((_cp_ - 0x10000) modulo 0x400) + 0xDC00.\n  1. Return the string-concatenation of _cu1_ and _cu2_.","code":"\n        1. Assert: 0 ≤ _cp_ ≤ 0x10FFFF.\n        1. If _cp_ ≤ 0xFFFF, return the String value consisting of the code unit whose numeric value is _cp_.\n        1. Let _cu1_ be the code unit whose numeric value is floor((_cp_ - 0x10000) / 0x400) + 0xD800.\n        1. Let _cu2_ be the code unit whose numeric value is ((_cp_ - 0x10000) modulo 0x400) + 0xDC00.\n        1. Return the string-concatenation of _cu1_ and _cu2_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CodePointsToString","params":[{"name":"text","ty":"Unknown[\"a sequence of Unicode code points\"]","kind":{"Normal":{}}}],"retTy":"String"}},"body":"\n  1. Let _result_ be *\"\"*.\n  1. For each code point _cp_ of _text_, do\n    1. Set _result_ to the string-concatenation of _result_ and UTF16EncodeCodePoint(_cp_).\n  1. Return _result_.","code":"\n        1. Let _result_ be the empty String.\n        1. For each code point _cp_ of _text_, do\n          1. Set _result_ to the string-concatenation of _result_ and UTF16EncodeCodePoint(_cp_).\n        1. Return _result_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"UTF16SurrogatePairToCodePoint","params":[{"name":"lead","ty":"Unknown[\"a code unit\"]","kind":{"Normal":{}}},{"name":"trail","ty":"Unknown[\"a code unit\"]","kind":{"Normal":{}}}],"retTy":"Unknown[\"a code point\"]"}},"body":"\n  1. Assert: _lead_ is a leading surrogate and _trail_ is a trailing surrogate..\n  1. Let _cp_ be (_lead_ - 0xd800) × 0x0400 + _trail_ - 0xdc00 + 0x10000.\n  1. Return the code point _cp_.","code":"\n        1. Assert: _lead_ is a leading surrogate and _trail_ is a trailing surrogate.\n        1. Let _cp_ be (_lead_ - 0xD800) × 0x400 + (_trail_ - 0xDC00) + 0x10000.\n        1. Return the code point _cp_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CodePointAt","params":[{"name":"string","ty":"String","kind":{"Normal":{}}},{"name":"position","ty":"NonNegInt","kind":{"Normal":{}}}],"retTy":"Unknown[\"a Record with fields [[CodePoint]] (a code point), [[CodeUnitCount]] (a positive integer), and [[IsUnpairedSurrogate]] (a Boolean)\"]"}},"body":"\n  1. Let _size_ be the length of _string_.\n  1. Assert: _position_ ≥ 0 and _position_ < _size_.\n  1. Let _first_ be the code unit at index _position_ within _string_.\n  1. Let _cp_ be the code point whose numeric value is the numeric value of _first_.\n  1. If _first_ is neither a leading surrogate nor a trailing surrogate, then\n    1. Return Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *false* }.\n  1. If _first_ is a trailing surrogate or _position_ + 1 = _size_, then\n    1. Return Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *true* }.\n  1. Let _second_ be the code unit at index _position_ + 1 within _string_.\n  1. If _second_ is not a trailing surrogate, then\n    1. Return Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *true* }.\n  1. Set _cp_ to UTF16SurrogatePairToCodePoint(_first_, _second_).\n  1. Return Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 2, [[IsUnpairedSurrogate]]: *false* }.","code":"\n        1. Let _size_ be the length of _string_.\n        1. Assert: _position_ ≥ 0 and _position_ < _size_.\n        1. Let _first_ be the code unit at index _position_ within _string_.\n        1. Let _cp_ be the code point whose numeric value is the numeric value of _first_.\n        1. If _first_ is neither a leading surrogate nor a trailing surrogate, then\n          1. Return the Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *false* }.\n        1. If _first_ is a trailing surrogate or _position_ + 1 = _size_, then\n          1. Return the Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *true* }.\n        1. Let _second_ be the code unit at index _position_ + 1 within _string_.\n        1. If _second_ is not a trailing surrogate, then\n          1. Return the Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *true* }.\n        1. Set _cp_ to UTF16SurrogatePairToCodePoint(_first_, _second_).\n        1. Return the Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 2, [[IsUnpairedSurrogate]]: *false* }.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"StringToCodePoints","params":[{"name":"string","ty":"String","kind":{"Normal":{}}}],"retTy":"Unknown[\"a List of code points\"]"}},"body":"\n  1. Let _codePoints_ be « ».\n  1. Let _size_ be the length of _string_.\n  1. Let _position_ be 0.\n  1. Repeat, while _position_ < _size_,\n    1. Let _cp_ be CodePointAt(_string_, _position_).\n    1. Append _cp_.[[CodePoint]] to _codePoints_.\n    1. Set _position_ to _position_ + _cp_.[[CodeUnitCount]].\n  1. Return _codePoints_.","code":"\n        1. Let _codePoints_ be a new empty List.\n        1. Let _size_ be the length of _string_.\n        1. Let _position_ be 0.\n        1. Repeat, while _position_ < _size_,\n          1. Let _cp_ be CodePointAt(_string_, _position_).\n          1. Append _cp_.[[CodePoint]] to _codePoints_.\n          1. Set _position_ to _position_ + _cp_.[[CodeUnitCount]].\n        1. Return _codePoints_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ParseText","params":[{"name":"sourceText","ty":"Unknown[\"a sequence of Unicode code points\"]","kind":{"Normal":{}}},{"name":"goalSymbol","ty":"Unknown[\"a nonterminal in one of the ECMAScript grammars\"]","kind":{"Normal":{}}}],"retTy":"Unknown[\"a Parse Node or a non-empty List of *SyntaxError* objects\"]"}},"body":"\n  1. Attempt to parse _sourceText_ using _goalSymbol_ as the goal symbol, and analyse the parse result for any early error conditions. Parsing and early error detection may be interleaved in an implementation-defined manner.\n  1. If the parse succeeded and no early errors were found, return the Parse Node (an instance of _goalSymbol_) at the root of the parse tree resulting from the parse.\n  1. Otherwise, return a List of one or more *SyntaxError* objects representing the parsing errors and/or early errors. If more than one parsing error or early error is present, the number and ordering of error objects in the list is implementation-defined, but at least one must be present.","code":"\n        1. Attempt to parse _sourceText_ using _goalSymbol_ as the goal symbol, and analyse the parse result for any early error conditions. Parsing and early error detection may be interleaved in an implementation-defined manner.\n        1. If the parse succeeded and no early errors were found, return the Parse Node (an instance of _goalSymbol_) at the root of the parse tree resulting from the parse.\n        1. Otherwise, return a List of one or more *SyntaxError* objects representing the parsing errors and/or early errors. If more than one parsing error or early error is present, the number and ordering of error objects in the list is implementation-defined, but at least one must be present.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IdentifierName","idx":0,"subIdx":0,"rhsParams":[{"name":"IdentifierStart","ty":"Ast[IdentifierStart]","kind":{"Normal":{}}}]},"methodName":"IdentifierCodePoints","isStatic":true,"withParams":[],"retTy":"Unknown[\"a List of code points\"]"}},"body":"\n  1. Let _cp_ be IdentifierCodePoint of |IdentifierStart|.\n  1. Return « _cp_ ».","code":"\n          1. Let _cp_ be IdentifierCodePoint of |IdentifierStart|.\n          1. Return « _cp_ ».\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IdentifierName","idx":1,"subIdx":0,"rhsParams":[{"name":"IdentifierName","ty":"Ast[IdentifierName]","kind":{"Normal":{}}},{"name":"IdentifierPart","ty":"Ast[IdentifierPart]","kind":{"Normal":{}}}]},"methodName":"IdentifierCodePoints","isStatic":true,"withParams":[],"retTy":"Unknown[\"a List of code points\"]"}},"body":"\n  1. Let _cps_ be IdentifierCodePoints of the derived |IdentifierName|.\n  1. Let _cp_ be IdentifierCodePoint of |IdentifierPart|.\n  1. Return the list-concatenation of _cps_ and « _cp_ ».","code":"\n          1. Let _cps_ be IdentifierCodePoints of the derived |IdentifierName|.\n          1. Let _cp_ be IdentifierCodePoint of |IdentifierPart|.\n          1. Return the list-concatenation of _cps_ and « _cp_ ».\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IdentifierStart","idx":0,"subIdx":0,"rhsParams":[{"name":"IdentifierStartChar","ty":"Ast[IdentifierStartChar]","kind":{"Normal":{}}}]},"methodName":"IdentifierCodePoint","isStatic":true,"withParams":[],"retTy":"Unknown[\"a code point\"]"}},"body":"\n  1. Return the code point matched by |IdentifierStartChar|.","code":"\n          1. Return the code point matched by |IdentifierStartChar|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IdentifierPart","idx":0,"subIdx":0,"rhsParams":[{"name":"IdentifierPartChar","ty":"Ast[IdentifierPartChar]","kind":{"Normal":{}}}]},"methodName":"IdentifierCodePoint","isStatic":true,"withParams":[],"retTy":"Unknown[\"a code point\"]"}},"body":"\n  1. Return the code point matched by |IdentifierPartChar|.","code":"\n          1. Return the code point matched by |IdentifierPartChar|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnicodeEscapeSequence","idx":0,"subIdx":0,"rhsParams":[{"name":"Hex4Digits","ty":"Ast[Hex4Digits]","kind":{"Normal":{}}}]},"methodName":"IdentifierCodePoint","isStatic":true,"withParams":[],"retTy":"Unknown[\"a code point\"]"}},"body":"\n  1. Return the code point whose numeric value is the MV of |Hex4Digits|.","code":"\n          1. Return the code point whose numeric value is the MV of |Hex4Digits|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnicodeEscapeSequence","idx":1,"subIdx":0,"rhsParams":[{"name":"CodePoint","ty":"Ast[CodePoint]","kind":{"Normal":{}}}]},"methodName":"IdentifierCodePoint","isStatic":true,"withParams":[],"retTy":"Unknown[\"a code point\"]"}},"body":"\n  1. Return the code point whose numeric value is the MV of |CodePoint|.","code":"\n          1. Return the code point whose numeric value is the MV of |CodePoint|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NumericLiteral","idx":0,"subIdx":0,"rhsParams":[{"name":"DecimalLiteral","ty":"Ast[DecimalLiteral]","kind":{"Normal":{}}}]},"methodName":"NumericValue","isStatic":true,"withParams":[],"retTy":"Number | BigInt"}},"body":"\n  1. Return RoundMVResult(MV of |DecimalLiteral|).","code":"\n          1. Return RoundMVResult(MV of |DecimalLiteral|).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NumericLiteral","idx":2,"subIdx":0,"rhsParams":[{"name":"NonDecimalIntegerLiteral","ty":"Ast[NonDecimalIntegerLiteral]","kind":{"Normal":{}}}]},"methodName":"NumericValue","isStatic":true,"withParams":[],"retTy":"Number | BigInt"}},"body":"\n  1. Return 𝔽(MV of |NonDecimalIntegerLiteral|).","code":"\n          1. Return 𝔽(MV of |NonDecimalIntegerLiteral|).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NumericLiteral","idx":4,"subIdx":0,"rhsParams":[{"name":"LegacyOctalIntegerLiteral","ty":"Ast[LegacyOctalIntegerLiteral]","kind":{"Normal":{}}}]},"methodName":"NumericValue","isStatic":true,"withParams":[],"retTy":"Number | BigInt"}},"body":"\n  1. Return 𝔽(MV of |LegacyOctalIntegerLiteral|).","code":"\n          1. Return 𝔽(MV of |LegacyOctalIntegerLiteral|).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NumericLiteral","idx":3,"subIdx":0,"rhsParams":[{"name":"NonDecimalIntegerLiteral","ty":"Ast[NonDecimalIntegerLiteral]","kind":{"Normal":{}}},{"name":"BigIntLiteralSuffix","ty":"Ast[BigIntLiteralSuffix]","kind":{"Normal":{}}}]},"methodName":"NumericValue","isStatic":true,"withParams":[],"retTy":"Number | BigInt"}},"body":"\n  1. Return ℤ(MV of |NonDecimalIntegerLiteral|).","code":"\n          1. Return the BigInt value for the MV of |NonDecimalIntegerLiteral|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DecimalBigIntegerLiteral","idx":0,"subIdx":0,"rhsParams":[{"name":"BigIntLiteralSuffix","ty":"Ast[BigIntLiteralSuffix]","kind":{"Normal":{}}}]},"methodName":"NumericValue","isStatic":true,"withParams":[],"retTy":"Number | BigInt"}},"body":"\n  1. Return *0*<sub>ℤ</sub>.","code":"\n          1. Return *0*<sub>ℤ</sub>.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DecimalBigIntegerLiteral","idx":1,"subIdx":0,"rhsParams":[{"name":"NonZeroDigit","ty":"Ast[NonZeroDigit]","kind":{"Normal":{}}},{"name":"BigIntLiteralSuffix","ty":"Ast[BigIntLiteralSuffix]","kind":{"Normal":{}}}]},"methodName":"NumericValue","isStatic":true,"withParams":[],"retTy":"Number | BigInt"}},"body":"\n  1. Return ℤ(MV of |NonZeroDigit|).","code":"\n          1. Return the BigInt value for the MV of |NonZeroDigit|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DecimalBigIntegerLiteral","idx":1,"subIdx":1,"rhsParams":[{"name":"NonZeroDigit","ty":"Ast[NonZeroDigit]","kind":{"Normal":{}}},{"name":"DecimalDigits","ty":"Ast[DecimalDigits]","kind":{"Normal":{}}},{"name":"BigIntLiteralSuffix","ty":"Ast[BigIntLiteralSuffix]","kind":{"Normal":{}}}]},"methodName":"NumericValue","isStatic":true,"withParams":[],"retTy":"Number | BigInt"}},"body":"\n  1. Let _n_ be the number of code points in |DecimalDigits|, excluding all occurrences of |NumericLiteralSeparator|.\n  1. Let _mv_ be (the MV of |NonZeroDigit| × 10<sup>_n_</sup>) plus the MV of |DecimalDigits|.\n  1. Return ℤ(_mv_).","code":"\n          1. Let _n_ be the number of code points in |DecimalDigits|, excluding all occurrences of |NumericLiteralSeparator|.\n          1. Let _mv_ be (the MV of |NonZeroDigit| × 10<sup>_n_</sup>) plus the MV of |DecimalDigits|.\n          1. Return ℤ(_mv_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DecimalBigIntegerLiteral","idx":2,"subIdx":0,"rhsParams":[{"name":"NonZeroDigit","ty":"Ast[NonZeroDigit]","kind":{"Normal":{}}},{"name":"NumericLiteralSeparator","ty":"Ast[NumericLiteralSeparator]","kind":{"Normal":{}}},{"name":"DecimalDigits","ty":"Ast[DecimalDigits]","kind":{"Normal":{}}},{"name":"BigIntLiteralSuffix","ty":"Ast[BigIntLiteralSuffix]","kind":{"Normal":{}}}]},"methodName":"NumericValue","isStatic":true,"withParams":[],"retTy":"Number | BigInt"}},"body":"\n  1. Let _n_ be the number of code points in |DecimalDigits|, excluding all occurrences of |NumericLiteralSeparator|.\n  1. Let _mv_ be (the MV of |NonZeroDigit| × 10<sup>_n_</sup>) plus the MV of |DecimalDigits|.\n  1. Return ℤ(_mv_).","code":"\n          1. Let _n_ be the number of code points in |DecimalDigits|, excluding all occurrences of |NumericLiteralSeparator|.\n          1. Let _mv_ be (the MV of |NonZeroDigit| × 10<sup>_n_</sup>) plus the MV of |DecimalDigits|.\n          1. Return ℤ(_mv_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RegularExpressionLiteral","idx":0,"subIdx":0,"rhsParams":[{"name":"RegularExpressionBody","ty":"Ast[RegularExpressionBody]","kind":{"Normal":{}}},{"name":"RegularExpressionFlags","ty":"Ast[RegularExpressionFlags]","kind":{"Normal":{}}}]},"methodName":"BodyText","isStatic":true,"withParams":[],"retTy":"Unknown[\"source text\"]"}},"body":"\n  1. Return the source text that was recognized as |RegularExpressionBody|.","code":"\n          1. Return the source text that was recognized as |RegularExpressionBody|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RegularExpressionLiteral","idx":0,"subIdx":0,"rhsParams":[{"name":"RegularExpressionBody","ty":"Ast[RegularExpressionBody]","kind":{"Normal":{}}},{"name":"RegularExpressionFlags","ty":"Ast[RegularExpressionFlags]","kind":{"Normal":{}}}]},"methodName":"FlagText","isStatic":true,"withParams":[],"retTy":"Unknown[\"source text\"]"}},"body":"\n  1. Return the source text that was recognized as |RegularExpressionFlags|.","code":"\n          1. Return the source text that was recognized as |RegularExpressionFlags|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IdentifierName","idx":0,"subIdx":0,"rhsParams":[{"name":"IdentifierStart","ty":"Ast[IdentifierStart]","kind":{"Normal":{}}}]},"methodName":"StringValue","isStatic":true,"withParams":[],"retTy":"String"}},"body":"\n  1. Let _idTextUnescaped_ be IdentifierCodePoints of |IdentifierName|.\n  1. Return CodePointsToString(_idTextUnescaped_).","code":"\n        1. Let _idTextUnescaped_ be IdentifierCodePoints of |IdentifierName|.\n        1. Return CodePointsToString(_idTextUnescaped_).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IdentifierName","idx":1,"subIdx":0,"rhsParams":[{"name":"IdentifierName","ty":"Ast[IdentifierName]","kind":{"Normal":{}}},{"name":"IdentifierPart","ty":"Ast[IdentifierPart]","kind":{"Normal":{}}}]},"methodName":"StringValue","isStatic":true,"withParams":[],"retTy":"String"}},"body":"\n  1. Let _idTextUnescaped_ be IdentifierCodePoints of |IdentifierName|.\n  1. Return CodePointsToString(_idTextUnescaped_).","code":"\n        1. Let _idTextUnescaped_ be IdentifierCodePoints of |IdentifierName|.\n        1. Return CodePointsToString(_idTextUnescaped_).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IdentifierReference","idx":1,"subIdx":0,"rhsParams":[]},"methodName":"StringValue","isStatic":true,"withParams":[],"retTy":"String"}},"body":"\n  1. Return *\"yield\"*.","code":"\n        1. Return *\"yield\"*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingIdentifier","idx":1,"subIdx":0,"rhsParams":[]},"methodName":"StringValue","isStatic":true,"withParams":[],"retTy":"String"}},"body":"\n  1. Return *\"yield\"*.","code":"\n        1. Return *\"yield\"*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LabelIdentifier","idx":1,"subIdx":0,"rhsParams":[]},"methodName":"StringValue","isStatic":true,"withParams":[],"retTy":"String"}},"body":"\n  1. Return *\"yield\"*.","code":"\n        1. Return *\"yield\"*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IdentifierReference","idx":2,"subIdx":0,"rhsParams":[]},"methodName":"StringValue","isStatic":true,"withParams":[],"retTy":"String"}},"body":"\n  1. Return *\"await\"*.","code":"\n        1. Return *\"await\"*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingIdentifier","idx":2,"subIdx":0,"rhsParams":[]},"methodName":"StringValue","isStatic":true,"withParams":[],"retTy":"String"}},"body":"\n  1. Return *\"await\"*.","code":"\n        1. Return *\"await\"*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LabelIdentifier","idx":2,"subIdx":0,"rhsParams":[]},"methodName":"StringValue","isStatic":true,"withParams":[],"retTy":"String"}},"body":"\n  1. Return *\"await\"*.","code":"\n        1. Return *\"await\"*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Identifier","idx":0,"subIdx":0,"rhsParams":[{"name":"IdentifierName","ty":"Ast[IdentifierName]","kind":{"Normal":{}}}]},"methodName":"StringValue","isStatic":true,"withParams":[],"retTy":"String"}},"body":"\n  1. Return StringValue of |IdentifierName|.","code":"\n        1. Return the StringValue of |IdentifierName|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrivateIdentifier","idx":0,"subIdx":0,"rhsParams":[{"name":"IdentifierName","ty":"Ast[IdentifierName]","kind":{"Normal":{}}}]},"methodName":"StringValue","isStatic":true,"withParams":[],"retTy":"String"}},"body":"\n  1. Return the string-concatenation of 0x0023 (NUMBER SIGN) and StringValue of |IdentifierName|.","code":"\n        1. Return the string-concatenation of 0x0023 (NUMBER SIGN) and the StringValue of |IdentifierName|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleExportName","idx":1,"subIdx":0,"rhsParams":[{"name":"StringLiteral","ty":"Ast[StringLiteral]","kind":{"Normal":{}}}]},"methodName":"StringValue","isStatic":true,"withParams":[],"retTy":"String"}},"body":"\n  1. Return SV of |StringLiteral|.","code":"\n        1. Return the SV of |StringLiteral|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IdentifierReference","idx":0,"subIdx":0,"rhsParams":[{"name":"Identifier","ty":"Ast[Identifier]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ? ResolveBinding(StringValue of |Identifier|).","code":"\n        1. Return ? ResolveBinding(StringValue of |Identifier|).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IdentifierReference","idx":1,"subIdx":0,"rhsParams":[]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ? ResolveBinding(*\"yield\"*).","code":"\n        1. Return ? ResolveBinding(*\"yield\"*).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IdentifierReference","idx":2,"subIdx":0,"rhsParams":[]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ? ResolveBinding(*\"await\"*).","code":"\n        1. Return ? ResolveBinding(*\"await\"*).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ? ResolveThisBinding().","code":"\n          1. Return ? ResolveThisBinding().\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Literal","idx":0,"subIdx":0,"rhsParams":[{"name":"NullLiteral","ty":"Ast[NullLiteral]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return *null*.","code":"\n          1. Return *null*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Literal","idx":1,"subIdx":0,"rhsParams":[{"name":"BooleanLiteral","ty":"Ast[BooleanLiteral]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. If |BooleanLiteral| is the token `false`, return *false*.\n  1. If |BooleanLiteral| is the token `true`, return *true*.","code":"\n          1. If |BooleanLiteral| is the token `false`, return *false*.\n          1. If |BooleanLiteral| is the token `true`, return *true*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Literal","idx":2,"subIdx":0,"rhsParams":[{"name":"NumericLiteral","ty":"Ast[NumericLiteral]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return NumericValue of |NumericLiteral|.","code":"\n          1. Return the NumericValue of |NumericLiteral| as defined in <emu-xref href=\"#sec-literals-numeric-literals\"></emu-xref>.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Literal","idx":3,"subIdx":0,"rhsParams":[{"name":"StringLiteral","ty":"Ast[StringLiteral]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return SV of |StringLiteral|.","code":"\n          1. Return the SV of |StringLiteral| as defined in <emu-xref href=\"#sec-static-semantics-sv\"></emu-xref>.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Elision","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"ArrayAccumulation","isStatic":false,"withParams":[{"name":"array","ty":"Record[Array]","kind":{"Normal":{}}},{"name":"nextIndex","ty":"Int","kind":{"Normal":{}}}],"retTy":"Normal[Int] | Abrupt"}},"body":"\n  1. Let _len_ be _nextIndex_ + 1.\n  1. Perform ? Set(_array_, *\"length\"*, 𝔽(_len_), *true*).\n  1. NOTE: The above step throws if _len_ exceeds 2<sup>32</sup> - 1.\n  1. Return _len_.","code":"\n          1. Let _len_ be _nextIndex_ + 1.\n          1. Perform ? Set(_array_, *\"length\"*, 𝔽(_len_), *true*).\n          1. NOTE: The above step throws if _len_ exceeds 2<sup>32</sup> - 1.\n          1. Return _len_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Elision","idx":1,"subIdx":0,"rhsParams":[{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}}]},"methodName":"ArrayAccumulation","isStatic":false,"withParams":[{"name":"array","ty":"Record[Array]","kind":{"Normal":{}}},{"name":"nextIndex","ty":"Int","kind":{"Normal":{}}}],"retTy":"Normal[Int] | Abrupt"}},"body":"\n  1. Return ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_ + 1.","code":"\n          1. Return ? ArrayAccumulation of |Elision| with arguments _array_ and (_nextIndex_ + 1).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ElementList","idx":0,"subIdx":0,"rhsParams":[{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"ArrayAccumulation","isStatic":false,"withParams":[{"name":"array","ty":"Record[Array]","kind":{"Normal":{}}},{"name":"nextIndex","ty":"Int","kind":{"Normal":{}}}],"retTy":"Normal[Int] | Abrupt"}},"body":"\n  1. If |Elision| is present, then\n    1. Set _nextIndex_ to ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n  1. Let _initResult_ be ? the result of evaluating |AssignmentExpression|.\n  1. Let _initValue_ be ? GetValue(_initResult_).\n  1. Perform ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _initValue_).\n  1. Return _nextIndex_ + 1.","code":"\n          1. If |Elision| is present, then\n            1. Set _nextIndex_ to ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n          1. Let _initResult_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _initValue_ be ? GetValue(_initResult_).\n          1. Perform ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _initValue_).\n          1. Return _nextIndex_ + 1.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ElementList","idx":0,"subIdx":1,"rhsParams":[{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"ArrayAccumulation","isStatic":false,"withParams":[{"name":"array","ty":"Record[Array]","kind":{"Normal":{}}},{"name":"nextIndex","ty":"Int","kind":{"Normal":{}}}],"retTy":"Normal[Int] | Abrupt"}},"body":"\n  1. If |Elision| is present, then\n    1. Set _nextIndex_ to ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n  1. Let _initResult_ be ? the result of evaluating |AssignmentExpression|.\n  1. Let _initValue_ be ? GetValue(_initResult_).\n  1. Perform ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _initValue_).\n  1. Return _nextIndex_ + 1.","code":"\n          1. If |Elision| is present, then\n            1. Set _nextIndex_ to ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n          1. Let _initResult_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _initValue_ be ? GetValue(_initResult_).\n          1. Perform ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _initValue_).\n          1. Return _nextIndex_ + 1.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ElementList","idx":1,"subIdx":0,"rhsParams":[{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"SpreadElement","ty":"Ast[SpreadElement]","kind":{"Normal":{}}}]},"methodName":"ArrayAccumulation","isStatic":false,"withParams":[{"name":"array","ty":"Record[Array]","kind":{"Normal":{}}},{"name":"nextIndex","ty":"Int","kind":{"Normal":{}}}],"retTy":"Normal[Int] | Abrupt"}},"body":"\n  1. If |Elision| is present, then\n    1. Set _nextIndex_ to ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n  1. Return ? ArrayAccumulation of |SpreadElement| with arguments _array_ and _nextIndex_.","code":"\n          1. If |Elision| is present, then\n            1. Set _nextIndex_ to ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n          1. Return ? ArrayAccumulation of |SpreadElement| with arguments _array_ and _nextIndex_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ElementList","idx":1,"subIdx":1,"rhsParams":[{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"SpreadElement","ty":"Ast[SpreadElement]","kind":{"Normal":{}}}]},"methodName":"ArrayAccumulation","isStatic":false,"withParams":[{"name":"array","ty":"Record[Array]","kind":{"Normal":{}}},{"name":"nextIndex","ty":"Int","kind":{"Normal":{}}}],"retTy":"Normal[Int] | Abrupt"}},"body":"\n  1. If |Elision| is present, then\n    1. Set _nextIndex_ to ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n  1. Return ? ArrayAccumulation of |SpreadElement| with arguments _array_ and _nextIndex_.","code":"\n          1. If |Elision| is present, then\n            1. Set _nextIndex_ to ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n          1. Return ? ArrayAccumulation of |SpreadElement| with arguments _array_ and _nextIndex_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ElementList","idx":2,"subIdx":0,"rhsParams":[{"name":"ElementList","ty":"Ast[ElementList]","kind":{"Normal":{}}},{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"ArrayAccumulation","isStatic":false,"withParams":[{"name":"array","ty":"Record[Array]","kind":{"Normal":{}}},{"name":"nextIndex","ty":"Int","kind":{"Normal":{}}}],"retTy":"Normal[Int] | Abrupt"}},"body":"\n  1. Set _nextIndex_ to ? ArrayAccumulation of |ElementList| with arguments _array_ and _nextIndex_.\n  1. If |Elision| is present, then\n    1. Set _nextIndex_ to ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n  1. Let _initResult_ be ? the result of evaluating |AssignmentExpression|.\n  1. Let _initValue_ be ? GetValue(_initResult_).\n  1. Perform ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _initValue_).\n  1. Return _nextIndex_ + 1.","code":"\n          1. Set _nextIndex_ to ? ArrayAccumulation of |ElementList| with arguments _array_ and _nextIndex_.\n          1. If |Elision| is present, then\n            1. Set _nextIndex_ to ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n          1. Let _initResult_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _initValue_ be ? GetValue(_initResult_).\n          1. Perform ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _initValue_).\n          1. Return _nextIndex_ + 1.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ElementList","idx":2,"subIdx":1,"rhsParams":[{"name":"ElementList","ty":"Ast[ElementList]","kind":{"Normal":{}}},{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"ArrayAccumulation","isStatic":false,"withParams":[{"name":"array","ty":"Record[Array]","kind":{"Normal":{}}},{"name":"nextIndex","ty":"Int","kind":{"Normal":{}}}],"retTy":"Normal[Int] | Abrupt"}},"body":"\n  1. Set _nextIndex_ to ? ArrayAccumulation of |ElementList| with arguments _array_ and _nextIndex_.\n  1. If |Elision| is present, then\n    1. Set _nextIndex_ to ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n  1. Let _initResult_ be ? the result of evaluating |AssignmentExpression|.\n  1. Let _initValue_ be ? GetValue(_initResult_).\n  1. Perform ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _initValue_).\n  1. Return _nextIndex_ + 1.","code":"\n          1. Set _nextIndex_ to ? ArrayAccumulation of |ElementList| with arguments _array_ and _nextIndex_.\n          1. If |Elision| is present, then\n            1. Set _nextIndex_ to ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n          1. Let _initResult_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _initValue_ be ? GetValue(_initResult_).\n          1. Perform ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _initValue_).\n          1. Return _nextIndex_ + 1.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ElementList","idx":3,"subIdx":0,"rhsParams":[{"name":"ElementList","ty":"Ast[ElementList]","kind":{"Normal":{}}},{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"SpreadElement","ty":"Ast[SpreadElement]","kind":{"Normal":{}}}]},"methodName":"ArrayAccumulation","isStatic":false,"withParams":[{"name":"array","ty":"Record[Array]","kind":{"Normal":{}}},{"name":"nextIndex","ty":"Int","kind":{"Normal":{}}}],"retTy":"Normal[Int] | Abrupt"}},"body":"\n  1. Set _nextIndex_ to ? ArrayAccumulation of |ElementList| with arguments _array_ and _nextIndex_.\n  1. If |Elision| is present, then\n    1. Set _nextIndex_ to ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n  1. Return ? ArrayAccumulation of |SpreadElement| with arguments _array_ and _nextIndex_.","code":"\n          1. Set _nextIndex_ to ? ArrayAccumulation of |ElementList| with arguments _array_ and _nextIndex_.\n          1. If |Elision| is present, then\n            1. Set _nextIndex_ to ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n          1. Return ? ArrayAccumulation of |SpreadElement| with arguments _array_ and _nextIndex_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ElementList","idx":3,"subIdx":1,"rhsParams":[{"name":"ElementList","ty":"Ast[ElementList]","kind":{"Normal":{}}},{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"SpreadElement","ty":"Ast[SpreadElement]","kind":{"Normal":{}}}]},"methodName":"ArrayAccumulation","isStatic":false,"withParams":[{"name":"array","ty":"Record[Array]","kind":{"Normal":{}}},{"name":"nextIndex","ty":"Int","kind":{"Normal":{}}}],"retTy":"Normal[Int] | Abrupt"}},"body":"\n  1. Set _nextIndex_ to ? ArrayAccumulation of |ElementList| with arguments _array_ and _nextIndex_.\n  1. If |Elision| is present, then\n    1. Set _nextIndex_ to ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n  1. Return ? ArrayAccumulation of |SpreadElement| with arguments _array_ and _nextIndex_.","code":"\n          1. Set _nextIndex_ to ? ArrayAccumulation of |ElementList| with arguments _array_ and _nextIndex_.\n          1. If |Elision| is present, then\n            1. Set _nextIndex_ to ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n          1. Return ? ArrayAccumulation of |SpreadElement| with arguments _array_ and _nextIndex_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"SpreadElement","idx":0,"subIdx":0,"rhsParams":[{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"ArrayAccumulation","isStatic":false,"withParams":[{"name":"array","ty":"Record[Array]","kind":{"Normal":{}}},{"name":"nextIndex","ty":"Int","kind":{"Normal":{}}}],"retTy":"Normal[Int] | Abrupt"}},"body":"\n  1. Let _spreadRef_ be ? the result of evaluating |AssignmentExpression|.\n  1. Let _spreadObj_ be ? GetValue(_spreadRef_).\n  1. Let _iteratorRecord_ be ? GetIterator(_spreadObj_, ~sync~).\n  1. Repeat, \n    1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n    1. If _next_ is ~done~, return _nextIndex_.\n    1. Perform ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _next_).\n    1. Set _nextIndex_ to _nextIndex_ + 1.","code":"\n          1. Let _spreadRef_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _spreadObj_ be ? GetValue(_spreadRef_).\n          1. Let _iteratorRecord_ be ? GetIterator(_spreadObj_, ~sync~).\n          1. Repeat,\n            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n            1. If _next_ is ~done~, return _nextIndex_.\n            1. Perform ! CreateDataPropertyOrThrow(_array_, ! ToString(𝔽(_nextIndex_)), _next_).\n            1. Set _nextIndex_ to _nextIndex_ + 1.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayLiteral","idx":0,"subIdx":0,"rhsParams":[{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _array_ be ! ArrayCreate(0).\n  1. If |Elision| is present, then\n    1. Perform ? ArrayAccumulation of |Elision| with arguments _array_ and 0.\n  1. Return _array_.","code":"\n          1. Let _array_ be ! ArrayCreate(0).\n          1. If |Elision| is present, then\n            1. Perform ? ArrayAccumulation of |Elision| with arguments _array_ and 0.\n          1. Return _array_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayLiteral","idx":0,"subIdx":1,"rhsParams":[{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _array_ be ! ArrayCreate(0).\n  1. If |Elision| is present, then\n    1. Perform ? ArrayAccumulation of |Elision| with arguments _array_ and 0.\n  1. Return _array_.","code":"\n          1. Let _array_ be ! ArrayCreate(0).\n          1. If |Elision| is present, then\n            1. Perform ? ArrayAccumulation of |Elision| with arguments _array_ and 0.\n          1. Return _array_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayLiteral","idx":1,"subIdx":0,"rhsParams":[{"name":"ElementList","ty":"Ast[ElementList]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _array_ be ! ArrayCreate(0).\n  1. Perform ? ArrayAccumulation of |ElementList| with arguments _array_ and 0.\n  1. Return _array_.","code":"\n          1. Let _array_ be ! ArrayCreate(0).\n          1. Perform ? ArrayAccumulation of |ElementList| with arguments _array_ and 0.\n          1. Return _array_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayLiteral","idx":2,"subIdx":0,"rhsParams":[{"name":"ElementList","ty":"Ast[ElementList]","kind":{"Normal":{}}},{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _array_ be ! ArrayCreate(0).\n  1. Let _nextIndex_ be ? ArrayAccumulation of |ElementList| with arguments _array_ and 0.\n  1. If |Elision| is present, then\n    1. Perform ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n  1. Return _array_.","code":"\n          1. Let _array_ be ! ArrayCreate(0).\n          1. Let _nextIndex_ be ? ArrayAccumulation of |ElementList| with arguments _array_ and 0.\n          1. If |Elision| is present, then\n            1. Perform ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n          1. Return _array_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayLiteral","idx":2,"subIdx":1,"rhsParams":[{"name":"ElementList","ty":"Ast[ElementList]","kind":{"Normal":{}}},{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _array_ be ! ArrayCreate(0).\n  1. Let _nextIndex_ be ? ArrayAccumulation of |ElementList| with arguments _array_ and 0.\n  1. If |Elision| is present, then\n    1. Perform ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n  1. Return _array_.","code":"\n          1. Let _array_ be ! ArrayCreate(0).\n          1. Let _nextIndex_ be ? ArrayAccumulation of |ElementList| with arguments _array_ and 0.\n          1. If |Elision| is present, then\n            1. Perform ? ArrayAccumulation of |Elision| with arguments _array_ and _nextIndex_.\n          1. Return _array_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PropertyName","idx":0,"subIdx":0,"rhsParams":[{"name":"LiteralPropertyName","ty":"Ast[LiteralPropertyName]","kind":{"Normal":{}}}]},"methodName":"IsComputedPropertyKey","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PropertyName","idx":1,"subIdx":0,"rhsParams":[{"name":"ComputedPropertyName","ty":"Ast[ComputedPropertyName]","kind":{"Normal":{}}}]},"methodName":"IsComputedPropertyKey","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n          1. Return *true*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PropertyDefinitionList","idx":0,"subIdx":0,"rhsParams":[{"name":"PropertyDefinition","ty":"Ast[PropertyDefinition]","kind":{"Normal":{}}}]},"methodName":"PropertyNameList","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _propName_ be PropName of |PropertyDefinition|.\n  1. If _propName_ is ~empty~, return « ».\n  1. Return « _propName_ ».","code":"\n          1. Let _propName_ be PropName of |PropertyDefinition|.\n          1. If _propName_ is ~empty~, return a new empty List.\n          1. Return « _propName_ ».\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PropertyDefinitionList","idx":1,"subIdx":0,"rhsParams":[{"name":"PropertyDefinitionList","ty":"Ast[PropertyDefinitionList]","kind":{"Normal":{}}},{"name":"PropertyDefinition","ty":"Ast[PropertyDefinition]","kind":{"Normal":{}}}]},"methodName":"PropertyNameList","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _list_ be PropertyNameList of |PropertyDefinitionList|.\n  1. Let _propName_ be PropName of |PropertyDefinition|.\n  1. If _propName_ is ~empty~, return _list_.\n  1. Return the list-concatenation of _list_ and « _propName_ ».","code":"\n          1. Let _list_ be PropertyNameList of |PropertyDefinitionList|.\n          1. Let _propName_ be PropName of |PropertyDefinition|.\n          1. If _propName_ is ~empty~, return _list_.\n          1. Return the list-concatenation of _list_ and « _propName_ ».\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ObjectLiteral","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return OrdinaryObjectCreate(%Object.prototype%).","code":"\n          1. Return OrdinaryObjectCreate(%Object.prototype%).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ObjectLiteral","idx":1,"subIdx":0,"rhsParams":[{"name":"PropertyDefinitionList","ty":"Ast[PropertyDefinitionList]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).\n  1. Perform ? PropertyDefinitionEvaluation of |PropertyDefinitionList| with argument _obj_.\n  1. Return _obj_.","code":"\n          1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).\n          1. Perform ? PropertyDefinitionEvaluation of |PropertyDefinitionList| with argument _obj_.\n          1. Return _obj_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ObjectLiteral","idx":2,"subIdx":0,"rhsParams":[{"name":"PropertyDefinitionList","ty":"Ast[PropertyDefinitionList]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).\n  1. Perform ? PropertyDefinitionEvaluation of |PropertyDefinitionList| with argument _obj_.\n  1. Return _obj_.","code":"\n          1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).\n          1. Perform ? PropertyDefinitionEvaluation of |PropertyDefinitionList| with argument _obj_.\n          1. Return _obj_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LiteralPropertyName","idx":0,"subIdx":0,"rhsParams":[{"name":"IdentifierName","ty":"Ast[IdentifierName]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return StringValue of |IdentifierName|.","code":"\n          1. Return StringValue of |IdentifierName|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LiteralPropertyName","idx":1,"subIdx":0,"rhsParams":[{"name":"StringLiteral","ty":"Ast[StringLiteral]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return SV of |StringLiteral|.","code":"\n          1. Return the SV of |StringLiteral|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LiteralPropertyName","idx":2,"subIdx":0,"rhsParams":[{"name":"NumericLiteral","ty":"Ast[NumericLiteral]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _nbr_ be NumericValue of |NumericLiteral|.\n  1. Return ! ToString(_nbr_).","code":"\n          1. Let _nbr_ be the NumericValue of |NumericLiteral|.\n          1. Return ! ToString(_nbr_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ComputedPropertyName","idx":0,"subIdx":0,"rhsParams":[{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _exprValue_ be ? the result of evaluating |AssignmentExpression|.\n  1. Let _propName_ be ? GetValue(_exprValue_).\n  1. Return ? ToPropertyKey(_propName_).","code":"\n          1. Let _exprValue_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _propName_ be ? GetValue(_exprValue_).\n          1. Return ? ToPropertyKey(_propName_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PropertyDefinitionList","idx":1,"subIdx":0,"rhsParams":[{"name":"PropertyDefinitionList","ty":"Ast[PropertyDefinitionList]","kind":{"Normal":{}}},{"name":"PropertyDefinition","ty":"Ast[PropertyDefinition]","kind":{"Normal":{}}}]},"methodName":"PropertyDefinitionEvaluation","isStatic":false,"withParams":[{"name":"object","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Perform ? PropertyDefinitionEvaluation of |PropertyDefinitionList| with argument _object_.\n  1. Perform ? PropertyDefinitionEvaluation of |PropertyDefinition| with argument _object_.\n  1. Return ~unused~.","code":"\n          1. Perform ? PropertyDefinitionEvaluation of |PropertyDefinitionList| with argument _object_.\n          1. Perform ? PropertyDefinitionEvaluation of |PropertyDefinition| with argument _object_.\n          1. Return ~unused~.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PropertyDefinition","idx":4,"subIdx":0,"rhsParams":[{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"PropertyDefinitionEvaluation","isStatic":false,"withParams":[{"name":"object","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _exprValue_ be ? the result of evaluating |AssignmentExpression|.\n  1. Let _fromValue_ be ? GetValue(_exprValue_).\n  1. Let _excludedNames_ be « ».\n  1. Perform ? CopyDataProperties(_object_, _fromValue_, _excludedNames_).\n  1. Return ~unused~.","code":"\n          1. Let _exprValue_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _fromValue_ be ? GetValue(_exprValue_).\n          1. Let _excludedNames_ be a new empty List.\n          1. Perform ? CopyDataProperties(_object_, _fromValue_, _excludedNames_).\n          1. Return ~unused~.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PropertyDefinition","idx":0,"subIdx":0,"rhsParams":[{"name":"IdentifierReference","ty":"Ast[IdentifierReference]","kind":{"Normal":{}}}]},"methodName":"PropertyDefinitionEvaluation","isStatic":false,"withParams":[{"name":"object","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _propName_ be StringValue of |IdentifierReference|.\n  1. Let _exprValue_ be ? the result of evaluating |IdentifierReference|.\n  1. Let _propValue_ be ? GetValue(_exprValue_).\n  1. Assert: _object_ is an ordinary, extensible object with no non-configurable properties..\n  1. Perform ! CreateDataPropertyOrThrow(_object_, _propName_, _propValue_).\n  1. Return ~unused~.","code":"\n          1. Let _propName_ be StringValue of |IdentifierReference|.\n          1. Let _exprValue_ be ? Evaluation of |IdentifierReference|.\n          1. Let _propValue_ be ? GetValue(_exprValue_).\n          1. Assert: _object_ is an ordinary, extensible object with no non-configurable properties.\n          1. Perform ! CreateDataPropertyOrThrow(_object_, _propName_, _propValue_).\n          1. Return ~unused~.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PropertyDefinition","idx":2,"subIdx":0,"rhsParams":[{"name":"PropertyName","ty":"Ast[PropertyName]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"PropertyDefinitionEvaluation","isStatic":false,"withParams":[{"name":"object","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _propKey_ be ? the result of evaluating |PropertyName|.\n  1. If *false*, then\n    1. Let _isProtoSetter_ be *false*.\n  1. Else if _propKey_ is *\"__proto__\"* and IsComputedPropertyKey of |PropertyName| is *false*, then\n    1. Let _isProtoSetter_ be *true*.\n  1. Else,\n    1. Let _isProtoSetter_ be *false*.\n  1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true* and _isProtoSetter_ is *false*, then\n    1. Let _propValue_ be ? NamedEvaluation of |AssignmentExpression| with argument _propKey_.\n  1. Else,\n    1. Let _exprValueRef_ be ? the result of evaluating |AssignmentExpression|.\n    1. Let _propValue_ be ? GetValue(_exprValueRef_).\n  1. If _isProtoSetter_ is *true*, then\n    1. If _propValue_ is a Record[Object] or _propValue_ is *null*, then\n      1. Perform ! _object_.[[SetPrototypeOf]](_propValue_).\n    1. Return ~unused~.\n  1. Assert: _object_ is an ordinary, extensible object with no non-configurable properties..\n  1. Perform ! CreateDataPropertyOrThrow(_object_, _propKey_, _propValue_).\n  1. Return ~unused~.","code":"\n          1. Let _propKey_ be ? Evaluation of |PropertyName|.\n          1. If this |PropertyDefinition| is contained within a |Script| that is being evaluated for JSON.parse (see step <emu-xref href=\"#step-json-parse-eval\"></emu-xref> of <emu-xref href=\"#sec-json.parse\">JSON.parse</emu-xref>), then\n            1. Let _isProtoSetter_ be *false*.\n          1. Else if _propKey_ is *\"__proto__\"* and IsComputedPropertyKey of |PropertyName| is *false*, then\n            1. Let _isProtoSetter_ be *true*.\n          1. Else,\n            1. Let _isProtoSetter_ be *false*.\n          1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true* and _isProtoSetter_ is *false*, then\n            1. Let _propValue_ be ? NamedEvaluation of |AssignmentExpression| with argument _propKey_.\n          1. Else,\n            1. Let _exprValueRef_ be ? Evaluation of |AssignmentExpression|.\n            1. Let _propValue_ be ? GetValue(_exprValueRef_).\n          1. If _isProtoSetter_ is *true*, then\n            1. If _propValue_ is an Object or _propValue_ is *null*, then\n              1. Perform ! <emu-meta effects=\"user-code\">_object_.[[SetPrototypeOf]]</emu-meta>(_propValue_).\n            1. Return ~unused~.\n          1. Assert: _object_ is an ordinary, extensible object with no non-configurable properties.\n          1. Perform ! CreateDataPropertyOrThrow(_object_, _propKey_, _propValue_).\n          1. Return ~unused~.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PropertyDefinition","idx":3,"subIdx":0,"rhsParams":[{"name":"MethodDefinition","ty":"Ast[MethodDefinition]","kind":{"Normal":{}}}]},"methodName":"PropertyDefinitionEvaluation","isStatic":false,"withParams":[{"name":"object","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Perform ? MethodDefinitionEvaluation of |MethodDefinition| with arguments _object_ and *true*.\n  1. Return ~unused~.","code":"\n          1. Perform ? MethodDefinitionEvaluation of |MethodDefinition| with arguments _object_ and *true*.\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsValidRegularExpressionLiteral","params":[{"name":"literal","ty":"Unknown[\"a |RegularExpressionLiteral| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _flags_ be FlagText of _literal_.\n  1. If _flags_ contains any code points other than `d`, `g`, `i`, `m`, `s`, `u`, `v`, or `y`, or if _flags_ contains any code point more than once, return *false*.\n  1. If _flags_ contains `u`, let _u_ be *true*.\n  1. Else, let _u_ be *false*.\n  1. If _flags_ contains `v`, let _v_ be *true*.\n  1. Else, let _v_ be *false*.\n  1. Let _patternText_ be BodyText of _literal_.\n  1. If _u_ is *false* and _v_ is *false*, then\n    1. Let _stringValue_ be CodePointsToString(_patternText_).\n    1. Set _patternText_ to the sequence of code points resulting from interpreting each of the 16-bit elements of _stringValue_ as a Unicode BMP code point. UTF-16 decoding is not applied to the elements.\n  1. Let _parseResult_ be ParsePattern(_patternText_, _u_, _v_).\n  1. If _parseResult_ is a Ast, return *true*.\n  1. Else, return *false*.","code":"\n          1. Let _flags_ be FlagText of _literal_.\n          1. If _flags_ contains any code points other than `d`, `g`, `i`, `m`, `s`, `u`, `v`, or `y`, or if _flags_ contains any code point more than once, return *false*.\n          1. If _flags_ contains `u`, let _u_ be *true*; else let _u_ be *false*.\n          1. If _flags_ contains `v`, let _v_ be *true*; else let _v_ be *false*.\n          1. Let _patternText_ be BodyText of _literal_.\n          1. If _u_ is *false* and _v_ is *false*, then\n            1. Let _stringValue_ be CodePointsToString(_patternText_).\n            1. Set _patternText_ to the sequence of code points resulting from interpreting each of the 16-bit elements of _stringValue_ as a Unicode BMP code point. UTF-16 decoding is not applied to the elements.\n          1. Let _parseResult_ be ParsePattern(_patternText_, _u_, _v_).\n          1. If _parseResult_ is a Parse Node, return *true*; else return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":10,"subIdx":0,"rhsParams":[{"name":"RegularExpressionLiteral","ty":"Ast[RegularExpressionLiteral]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _pattern_ be CodePointsToString(BodyText of |RegularExpressionLiteral|).\n  1. Let _flags_ be CodePointsToString(FlagText of |RegularExpressionLiteral|).\n  1. Return ! RegExpCreate(_pattern_, _flags_).","code":"\n          1. Let _pattern_ be CodePointsToString(BodyText of |RegularExpressionLiteral|).\n          1. Let _flags_ be CodePointsToString(FlagText of |RegularExpressionLiteral|).\n          1. Return ! RegExpCreate(_pattern_, _flags_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TemplateLiteral","idx":0,"subIdx":0,"rhsParams":[{"name":"NoSubstitutionTemplate","ty":"Ast[NoSubstitutionTemplate]","kind":{"Normal":{}}}]},"methodName":"TemplateStrings","isStatic":true,"withParams":[{"name":"raw","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"List[String | Undefined]"}},"body":"\n  1. Return « TemplateString(|NoSubstitutionTemplate|, _raw_) ».","code":"\n          1. Return « TemplateString(|NoSubstitutionTemplate|, _raw_) ».\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"SubstitutionTemplate","idx":0,"subIdx":0,"rhsParams":[{"name":"TemplateHead","ty":"Ast[TemplateHead]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"TemplateSpans","ty":"Ast[TemplateSpans]","kind":{"Normal":{}}}]},"methodName":"TemplateStrings","isStatic":true,"withParams":[{"name":"raw","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"List[String | Undefined]"}},"body":"\n  1. Let _head_ be « TemplateString(|TemplateHead|, _raw_) ».\n  1. Let _tail_ be TemplateStrings of |TemplateSpans| with argument _raw_.\n  1. Return the list-concatenation of _head_ and _tail_.","code":"\n          1. Let _head_ be « TemplateString(|TemplateHead|, _raw_) ».\n          1. Let _tail_ be TemplateStrings of |TemplateSpans| with argument _raw_.\n          1. Return the list-concatenation of _head_ and _tail_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TemplateSpans","idx":0,"subIdx":0,"rhsParams":[{"name":"TemplateTail","ty":"Ast[TemplateTail]","kind":{"Normal":{}}}]},"methodName":"TemplateStrings","isStatic":true,"withParams":[{"name":"raw","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"List[String | Undefined]"}},"body":"\n  1. Return « TemplateString(|TemplateTail|, _raw_) ».","code":"\n          1. Return « TemplateString(|TemplateTail|, _raw_) ».\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TemplateSpans","idx":1,"subIdx":0,"rhsParams":[{"name":"TemplateMiddleList","ty":"Ast[TemplateMiddleList]","kind":{"Normal":{}}},{"name":"TemplateTail","ty":"Ast[TemplateTail]","kind":{"Normal":{}}}]},"methodName":"TemplateStrings","isStatic":true,"withParams":[{"name":"raw","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"List[String | Undefined]"}},"body":"\n  1. Let _middle_ be TemplateStrings of |TemplateMiddleList| with argument _raw_.\n  1. Let _tail_ be « TemplateString(|TemplateTail|, _raw_) ».\n  1. Return the list-concatenation of _middle_ and _tail_.","code":"\n          1. Let _middle_ be TemplateStrings of |TemplateMiddleList| with argument _raw_.\n          1. Let _tail_ be « TemplateString(|TemplateTail|, _raw_) ».\n          1. Return the list-concatenation of _middle_ and _tail_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TemplateMiddleList","idx":0,"subIdx":0,"rhsParams":[{"name":"TemplateMiddle","ty":"Ast[TemplateMiddle]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"TemplateStrings","isStatic":true,"withParams":[{"name":"raw","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"List[String | Undefined]"}},"body":"\n  1. Return « TemplateString(|TemplateMiddle|, _raw_) ».","code":"\n          1. Return « TemplateString(|TemplateMiddle|, _raw_) ».\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TemplateMiddleList","idx":1,"subIdx":0,"rhsParams":[{"name":"TemplateMiddleList","ty":"Ast[TemplateMiddleList]","kind":{"Normal":{}}},{"name":"TemplateMiddle","ty":"Ast[TemplateMiddle]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"TemplateStrings","isStatic":true,"withParams":[{"name":"raw","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"List[String | Undefined]"}},"body":"\n  1. Let _front_ be TemplateStrings of |TemplateMiddleList| with argument _raw_.\n  1. Let _last_ be « TemplateString(|TemplateMiddle|, _raw_) ».\n  1. Return the list-concatenation of _front_ and _last_.","code":"\n          1. Let _front_ be TemplateStrings of |TemplateMiddleList| with argument _raw_.\n          1. Let _last_ be « TemplateString(|TemplateMiddle|, _raw_) ».\n          1. Return the list-concatenation of _front_ and _last_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"TemplateString","params":[{"name":"templateToken","ty":"Unknown[\"a |NoSubstitutionTemplate| Parse Node, a |TemplateHead| Parse Node, a |TemplateMiddle| Parse Node, or a |TemplateTail| Parse Node\"]","kind":{"Normal":{}}},{"name":"raw","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"String | Undefined"}},"body":"\n  1. If _raw_ is *true*, then\n    1. Let _string_ be TRV of _templateToken_.\n  1. Else,\n    1. Let _string_ be TV of _templateToken_.\n  1. Return _string_.","code":"\n          1. If _raw_ is *true*, then\n            1. Let _string_ be the TRV of _templateToken_.\n          1. Else,\n            1. Let _string_ be the TV of _templateToken_.\n          1. Return _string_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetTemplateObject","params":[{"name":"templateLiteral","ty":"Ast","kind":{"Normal":{}}}],"retTy":"Record[Array]"}},"body":"\n  1. Let _realm_ be the current Realm Record.\n  1. Let _templateRegistry_ be _realm_.[[TemplateMap]].\n  1. For each _e_ of _templateRegistry_, do\n    1. If _e_.[[Site]] is _templateLiteral_, then\n      1. Return _e_.[[Array]].\n  1. Let _rawStrings_ be TemplateStrings of _templateLiteral_ with argument *true*.\n  1. Assert: _rawStrings_ is a List[String].\n  1. Let _cookedStrings_ be TemplateStrings of _templateLiteral_ with argument *false*.\n  1. Let _count_ be the number of elements in _cookedStrings_.\n  1. Assert: _count_ ≤ 2<sup>32</sup> - 1.\n  1. Let _template_ be ! ArrayCreate(_count_).\n  1. Let _rawObj_ be ! ArrayCreate(_count_).\n  1. Let _index_ be 0.\n  1. Repeat, while _index_ < _count_,\n    1. Let _prop_ be ! ToString(𝔽(_index_)).\n    1. Let _cookedValue_ be _cookedStrings_[_index_].\n    1. Perform ! DefinePropertyOrThrow(_template_, _prop_, PropertyDescriptor { [[Value]]: _cookedValue_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* }).\n    1. Let _rawValue_ be _rawStrings_[_index_].\n    1. Perform ! DefinePropertyOrThrow(_rawObj_, _prop_, PropertyDescriptor { [[Value]]: _rawValue_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* }).\n    1. Set _index_ to _index_ + 1.\n  1. Perform ! SetIntegrityLevel(_rawObj_, ~frozen~).\n  1. Perform ! DefinePropertyOrThrow(_template_, *\"raw\"*, PropertyDescriptor { [[Value]]: _rawObj_, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n  1. Perform ! SetIntegrityLevel(_template_, ~frozen~).\n  1. Append Record { [[Site]]: _templateLiteral_, [[Array]]: _template_ } to _realm_.[[TemplateMap]].\n  1. Return _template_.","code":"\n          1. Let _realm_ be the current Realm Record.\n          1. Let _templateRegistry_ be _realm_.[[TemplateMap]].\n          1. For each element _e_ of _templateRegistry_, do\n            1. If _e_.[[Site]] is the same Parse Node as _templateLiteral_, then\n              1. Return _e_.[[Array]].\n          1. Let _rawStrings_ be TemplateStrings of _templateLiteral_ with argument *true*.\n          1. Assert: _rawStrings_ is a List of Strings.\n          1. Let _cookedStrings_ be TemplateStrings of _templateLiteral_ with argument *false*.\n          1. Let _count_ be the number of elements in the List _cookedStrings_.\n          1. Assert: _count_ ≤ 2<sup>32</sup> - 1.\n          1. Let _template_ be ! ArrayCreate(_count_).\n          1. Let _rawObj_ be ! ArrayCreate(_count_).\n          1. Let _index_ be 0.\n          1. Repeat, while _index_ < _count_,\n            1. Let _prop_ be ! ToString(𝔽(_index_)).\n            1. Let _cookedValue_ be _cookedStrings_[_index_].\n            1. Perform ! DefinePropertyOrThrow(_template_, _prop_, PropertyDescriptor { [[Value]]: _cookedValue_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* }).\n            1. Let _rawValue_ be the String value _rawStrings_[_index_].\n            1. Perform ! DefinePropertyOrThrow(_rawObj_, _prop_, PropertyDescriptor { [[Value]]: _rawValue_, [[Writable]]: *false*, [[Enumerable]]: *true*, [[Configurable]]: *false* }).\n            1. Set _index_ to _index_ + 1.\n          1. Perform ! SetIntegrityLevel(_rawObj_, ~frozen~).\n          1. Perform ! DefinePropertyOrThrow(_template_, *\"raw\"*, PropertyDescriptor { [[Value]]: _rawObj_, [[Writable]]: *false*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n          1. Perform ! SetIntegrityLevel(_template_, ~frozen~).\n          1. Append the Record { [[Site]]: _templateLiteral_, [[Array]]: _template_ } to _realm_.[[TemplateMap]].\n          1. Return _template_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TemplateSpans","idx":0,"subIdx":0,"rhsParams":[{"name":"TemplateTail","ty":"Ast[TemplateTail]","kind":{"Normal":{}}}]},"methodName":"SubstitutionEvaluation","isStatic":false,"withParams":[],"retTy":"Normal[List[ESValue]] | Abrupt"}},"body":"\n  1. Return « ».","code":"\n          1. Return a new empty List.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TemplateSpans","idx":1,"subIdx":0,"rhsParams":[{"name":"TemplateMiddleList","ty":"Ast[TemplateMiddleList]","kind":{"Normal":{}}},{"name":"TemplateTail","ty":"Ast[TemplateTail]","kind":{"Normal":{}}}]},"methodName":"SubstitutionEvaluation","isStatic":false,"withParams":[],"retTy":"Normal[List[ESValue]] | Abrupt"}},"body":"\n  1. Return ? SubstitutionEvaluation of |TemplateMiddleList|.","code":"\n          1. Return ? SubstitutionEvaluation of |TemplateMiddleList|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TemplateMiddleList","idx":0,"subIdx":0,"rhsParams":[{"name":"TemplateMiddle","ty":"Ast[TemplateMiddle]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"SubstitutionEvaluation","isStatic":false,"withParams":[],"retTy":"Normal[List[ESValue]] | Abrupt"}},"body":"\n  1. Let _subRef_ be ? the result of evaluating |Expression|.\n  1. Let _sub_ be ? GetValue(_subRef_).\n  1. Return « _sub_ ».","code":"\n          1. Let _subRef_ be ? Evaluation of |Expression|.\n          1. Let _sub_ be ? GetValue(_subRef_).\n          1. Return « _sub_ ».\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TemplateMiddleList","idx":1,"subIdx":0,"rhsParams":[{"name":"TemplateMiddleList","ty":"Ast[TemplateMiddleList]","kind":{"Normal":{}}},{"name":"TemplateMiddle","ty":"Ast[TemplateMiddle]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"SubstitutionEvaluation","isStatic":false,"withParams":[],"retTy":"Normal[List[ESValue]] | Abrupt"}},"body":"\n  1. Let _preceding_ be ? SubstitutionEvaluation of |TemplateMiddleList|.\n  1. Let _nextRef_ be ? the result of evaluating |Expression|.\n  1. Let _next_ be ? GetValue(_nextRef_).\n  1. Return the list-concatenation of _preceding_ and « _next_ ».","code":"\n          1. Let _preceding_ be ? SubstitutionEvaluation of |TemplateMiddleList|.\n          1. Let _nextRef_ be ? Evaluation of |Expression|.\n          1. Let _next_ be ? GetValue(_nextRef_).\n          1. Return the list-concatenation of _preceding_ and « _next_ ».\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TemplateLiteral","idx":0,"subIdx":0,"rhsParams":[{"name":"NoSubstitutionTemplate","ty":"Ast[NoSubstitutionTemplate]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return TV of |NoSubstitutionTemplate|.","code":"\n          1. Return the TV of |NoSubstitutionTemplate| as defined in <emu-xref href=\"#sec-template-literal-lexical-components\"></emu-xref>.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"SubstitutionTemplate","idx":0,"subIdx":0,"rhsParams":[{"name":"TemplateHead","ty":"Ast[TemplateHead]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"TemplateSpans","ty":"Ast[TemplateSpans]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _head_ be TV of |TemplateHead|.\n  1. Let _subRef_ be ? the result of evaluating |Expression|.\n  1. Let _sub_ be ? GetValue(_subRef_).\n  1. Let _middle_ be ? ToString(_sub_).\n  1. Let _tail_ be ? the result of evaluating |TemplateSpans|.\n  1. Return the string-concatenation of _head_, _middle_, and _tail_.","code":"\n          1. Let _head_ be the TV of |TemplateHead| as defined in <emu-xref href=\"#sec-template-literal-lexical-components\"></emu-xref>.\n          1. Let _subRef_ be ? Evaluation of |Expression|.\n          1. Let _sub_ be ? GetValue(_subRef_).\n          1. Let _middle_ be ? ToString(_sub_).\n          1. Let _tail_ be ? Evaluation of |TemplateSpans|.\n          1. Return the string-concatenation of _head_, _middle_, and _tail_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TemplateSpans","idx":0,"subIdx":0,"rhsParams":[{"name":"TemplateTail","ty":"Ast[TemplateTail]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return TV of |TemplateTail|.","code":"\n          1. Return the TV of |TemplateTail| as defined in <emu-xref href=\"#sec-template-literal-lexical-components\"></emu-xref>.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TemplateSpans","idx":1,"subIdx":0,"rhsParams":[{"name":"TemplateMiddleList","ty":"Ast[TemplateMiddleList]","kind":{"Normal":{}}},{"name":"TemplateTail","ty":"Ast[TemplateTail]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _head_ be ? the result of evaluating |TemplateMiddleList|.\n  1. Let _tail_ be TV of |TemplateTail|.\n  1. Return the string-concatenation of _head_ and _tail_.","code":"\n          1. Let _head_ be ? Evaluation of |TemplateMiddleList|.\n          1. Let _tail_ be the TV of |TemplateTail| as defined in <emu-xref href=\"#sec-template-literal-lexical-components\"></emu-xref>.\n          1. Return the string-concatenation of _head_ and _tail_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TemplateMiddleList","idx":0,"subIdx":0,"rhsParams":[{"name":"TemplateMiddle","ty":"Ast[TemplateMiddle]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _head_ be TV of |TemplateMiddle|.\n  1. Let _subRef_ be ? the result of evaluating |Expression|.\n  1. Let _sub_ be ? GetValue(_subRef_).\n  1. Let _middle_ be ? ToString(_sub_).\n  1. Return the string-concatenation of _head_ and _middle_.","code":"\n          1. Let _head_ be the TV of |TemplateMiddle| as defined in <emu-xref href=\"#sec-template-literal-lexical-components\"></emu-xref>.\n          1. Let _subRef_ be ? Evaluation of |Expression|.\n          1. Let _sub_ be ? GetValue(_subRef_).\n          1. Let _middle_ be ? ToString(_sub_).\n          1. Return the string-concatenation of _head_ and _middle_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TemplateMiddleList","idx":1,"subIdx":0,"rhsParams":[{"name":"TemplateMiddleList","ty":"Ast[TemplateMiddleList]","kind":{"Normal":{}}},{"name":"TemplateMiddle","ty":"Ast[TemplateMiddle]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _rest_ be ? the result of evaluating |TemplateMiddleList|.\n  1. Let _middle_ be TV of |TemplateMiddle|.\n  1. Let _subRef_ be ? the result of evaluating |Expression|.\n  1. Let _sub_ be ? GetValue(_subRef_).\n  1. Let _last_ be ? ToString(_sub_).\n  1. Return the string-concatenation of _rest_, _middle_, and _last_.","code":"\n          1. Let _rest_ be ? Evaluation of |TemplateMiddleList|.\n          1. Let _middle_ be the TV of |TemplateMiddle| as defined in <emu-xref href=\"#sec-template-literal-lexical-components\"></emu-xref>.\n          1. Let _subRef_ be ? Evaluation of |Expression|.\n          1. Let _sub_ be ? GetValue(_subRef_).\n          1. Let _last_ be ? ToString(_sub_).\n          1. Return the string-concatenation of _rest_, _middle_, and _last_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":12,"subIdx":0,"rhsParams":[{"name":"CoverParenthesizedExpressionAndArrowParameterList","ty":"Ast[CoverParenthesizedExpressionAndArrowParameterList]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _expr_ be the |ParenthesizedExpression| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n  1. Return ? the result of evaluating _expr_.","code":"\n          1. Let _expr_ be the |ParenthesizedExpression| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n          1. Return ? Evaluation of _expr_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ParenthesizedExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ? the result of evaluating |Expression|.","code":"\n          1. Return ? Evaluation of |Expression|. This may be of type Reference.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _baseReference_ be ? the result of evaluating |MemberExpression|.\n  1. Let _baseValue_ be ? GetValue(_baseReference_).\n  1. If the source text matched by *this* value is strict mode code, let _strict_ be *true*.\n  1. Else, let _strict_ be *false*.\n  1. Return ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_).","code":"\n          1. Let _baseReference_ be ? Evaluation of |MemberExpression|.\n          1. Let _baseValue_ be ? GetValue(_baseReference_).\n          1. If the source text matched by this |MemberExpression| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.\n          1. Return ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"IdentifierName","ty":"Ast[IdentifierName]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _baseReference_ be ? the result of evaluating |MemberExpression|.\n  1. Let _baseValue_ be ? GetValue(_baseReference_).\n  1. If the source text matched by *this* value is strict mode code, let _strict_ be *true*.\n  1. Else, let _strict_ be *false*.\n  1. Return EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_).","code":"\n          1. Let _baseReference_ be ? Evaluation of |MemberExpression|.\n          1. Let _baseValue_ be ? GetValue(_baseReference_).\n          1. If the source text matched by this |MemberExpression| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.\n          1. Return EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":7,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"PrivateIdentifier","ty":"Ast[PrivateIdentifier]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _baseReference_ be ? the result of evaluating |MemberExpression|.\n  1. Let _baseValue_ be ? GetValue(_baseReference_).\n  1. Let _fieldNameString_ be StringValue of |PrivateIdentifier|.\n  1. Return MakePrivateReference(_baseValue_, _fieldNameString_).","code":"\n          1. Let _baseReference_ be ? Evaluation of |MemberExpression|.\n          1. Let _baseValue_ be ? GetValue(_baseReference_).\n          1. Let _fieldNameString_ be the StringValue of |PrivateIdentifier|.\n          1. Return MakePrivateReference(_baseValue_, _fieldNameString_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CallExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"CallExpression","ty":"Ast[CallExpression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _baseReference_ be ? the result of evaluating |CallExpression|.\n  1. Let _baseValue_ be ? GetValue(_baseReference_).\n  1. If the source text matched by *this* value is strict mode code, let _strict_ be *true*.\n  1. Else, let _strict_ be *false*.\n  1. Return ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_).","code":"\n          1. Let _baseReference_ be ? Evaluation of |CallExpression|.\n          1. Let _baseValue_ be ? GetValue(_baseReference_).\n          1. If the source text matched by this |CallExpression| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.\n          1. Return ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CallExpression","idx":5,"subIdx":0,"rhsParams":[{"name":"CallExpression","ty":"Ast[CallExpression]","kind":{"Normal":{}}},{"name":"IdentifierName","ty":"Ast[IdentifierName]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _baseReference_ be ? the result of evaluating |CallExpression|.\n  1. Let _baseValue_ be ? GetValue(_baseReference_).\n  1. If the source text matched by *this* value is strict mode code, let _strict_ be *true*.\n  1. Else, let _strict_ be *false*.\n  1. Return EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_).","code":"\n          1. Let _baseReference_ be ? Evaluation of |CallExpression|.\n          1. Let _baseValue_ be ? GetValue(_baseReference_).\n          1. If the source text matched by this |CallExpression| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.\n          1. Return EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CallExpression","idx":7,"subIdx":0,"rhsParams":[{"name":"CallExpression","ty":"Ast[CallExpression]","kind":{"Normal":{}}},{"name":"PrivateIdentifier","ty":"Ast[PrivateIdentifier]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _baseReference_ be ? the result of evaluating |CallExpression|.\n  1. Let _baseValue_ be ? GetValue(_baseReference_).\n  1. Let _fieldNameString_ be StringValue of |PrivateIdentifier|.\n  1. Return MakePrivateReference(_baseValue_, _fieldNameString_).","code":"\n          1. Let _baseReference_ be ? Evaluation of |CallExpression|.\n          1. Let _baseValue_ be ? GetValue(_baseReference_).\n          1. Let _fieldNameString_ be the StringValue of |PrivateIdentifier|.\n          1. Return MakePrivateReference(_baseValue_, _fieldNameString_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"EvaluatePropertyAccessWithExpressionKey","params":[{"name":"baseValue","ty":"ESValue","kind":{"Normal":{}}},{"name":"expression","ty":"Unknown[\"an |Expression| Parse Node\"]","kind":{"Normal":{}}},{"name":"strict","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[Record[ReferenceRecord]] | Abrupt"}},"body":"\n  1. Let _propertyNameReference_ be ? the result of evaluating _expression_.\n  1. Let _propertyNameValue_ be ? GetValue(_propertyNameReference_).\n  1. Let _propertyKey_ be ? ToPropertyKey(_propertyNameValue_).\n  1. Return Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _propertyKey_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ }.","code":"\n        1. Let _propertyNameReference_ be ? Evaluation of _expression_.\n        1. Let _propertyNameValue_ be ? GetValue(_propertyNameReference_).\n        1. Let _propertyKey_ be ? ToPropertyKey(_propertyNameValue_).\n        1. Return the Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _propertyKey_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ }.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"EvaluatePropertyAccessWithIdentifierKey","params":[{"name":"baseValue","ty":"ESValue","kind":{"Normal":{}}},{"name":"identifierName","ty":"Unknown[\"an |IdentifierName| Parse Node\"]","kind":{"Normal":{}}},{"name":"strict","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Record[ReferenceRecord]"}},"body":"\n  1. Let _propertyNameString_ be StringValue of _identifierName_.\n  1. Return Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _propertyNameString_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ }.","code":"\n        1. Let _propertyNameString_ be StringValue of _identifierName_.\n        1. Return the Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _propertyNameString_, [[Strict]]: _strict_, [[ThisValue]]: ~empty~ }.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NewExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"NewExpression","ty":"Ast[NewExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ? EvaluateNew(|NewExpression|, ~empty~).","code":"\n          1. Return ? EvaluateNew(|NewExpression|, ~empty~).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":6,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"Arguments","ty":"Ast[Arguments]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ? EvaluateNew(|MemberExpression|, |Arguments|).","code":"\n          1. Return ? EvaluateNew(|MemberExpression|, |Arguments|).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"EvaluateNew","params":[{"name":"constructExpr","ty":"Unknown[\"a |NewExpression| Parse Node or a |MemberExpression| Parse Node\"]","kind":{"Normal":{}}},{"name":"arguments","ty":"Unknown[\"~empty~ or an |Arguments| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _ref_ be ? the result of evaluating _constructExpr_.\n  1. Let _constructor_ be ? GetValue(_ref_).\n  1. If _arguments_ is ~empty~, then\n    1. Let _argList_ be « ».\n  1. Else,\n    1. Let _argList_ be ? ArgumentListEvaluation of _arguments_.\n  1. If IsConstructor(_constructor_) is *false*, throw a *TypeError* exception.\n  1. Return ? Construct(_constructor_, _argList_).","code":"\n            1. Let _ref_ be ? Evaluation of _constructExpr_.\n            1. Let _constructor_ be ? GetValue(_ref_).\n            1. If _arguments_ is ~empty~, then\n              1. Let _argList_ be a new empty List.\n            1. Else,\n              1. Let _argList_ be ? ArgumentListEvaluation of _arguments_.\n            1. If IsConstructor(_constructor_) is *false*, throw a *TypeError* exception.\n            1. Return ? Construct(_constructor_, _argList_).\n          "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CallExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"CoverCallExpressionAndAsyncArrowHead","ty":"Ast[CoverCallExpressionAndAsyncArrowHead]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _expr_ be the |CallMemberExpression| that is covered by |CoverCallExpressionAndAsyncArrowHead|.\n  1. Let _memberExpr_ be the |MemberExpression| of _expr_.\n  1. Let _arguments_ be the |Arguments| of _expr_.\n  1. Let _ref_ be ? the result of evaluating _memberExpr_.\n  1. Let _func_ be ? GetValue(_ref_).\n  1. If _ref_ is a Record[ReferenceRecord] and IsPropertyReference(_ref_) is *false* and _ref_.[[ReferencedName]] is *\"eval\"*, then\n    1. If SameValue(_func_, %eval%) is *true*, then\n      1. Let _argList_ be ? ArgumentListEvaluation of _arguments_.\n      1. If _argList_ is empty, return *undefined*.\n      1. Let _evalArg_ be _argList_[0].\n      1. If the source text matched by *this* value is strict mode code, let _strictCaller_ be *true*.\n      1. Else, let _strictCaller_ be *false*.\n      1. [id=\"step-callexpression-evaluation-direct-eval\"] Return ? PerformEval(_evalArg_, _strictCaller_, *true*).\n  1. Let _thisCall_ be *this* value.\n  1. Let _tailCall_ be IsInTailPosition(_thisCall_).\n  1. Return ? EvaluateCall(_func_, _ref_, _arguments_, _tailCall_).","code":"\n          1. Let _expr_ be the |CallMemberExpression| that is covered by |CoverCallExpressionAndAsyncArrowHead|.\n          1. Let _memberExpr_ be the |MemberExpression| of _expr_.\n          1. Let _arguments_ be the |Arguments| of _expr_.\n          1. Let _ref_ be ? Evaluation of _memberExpr_.\n          1. Let _func_ be ? GetValue(_ref_).\n          1. If _ref_ is a Reference Record, IsPropertyReference(_ref_) is *false*, and _ref_.[[ReferencedName]] is *\"eval\"*, then\n            1. If SameValue(_func_, %eval%) is *true*, then\n              1. Let _argList_ be ? ArgumentListEvaluation of _arguments_.\n              1. If _argList_ has no elements, return *undefined*.\n              1. Let _evalArg_ be the first element of _argList_.\n              1. If the source text matched by this |CallExpression| is strict mode code, let _strictCaller_ be *true*. Otherwise let _strictCaller_ be *false*.\n              1. [id=\"step-callexpression-evaluation-direct-eval\"] Return ? PerformEval(_evalArg_, _strictCaller_, *true*).\n          1. Let _thisCall_ be this |CallExpression|.\n          1. Let _tailCall_ be IsInTailPosition(_thisCall_).\n          1. Return ? EvaluateCall(_func_, _ref_, _arguments_, _tailCall_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CallExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"CallExpression","ty":"Ast[CallExpression]","kind":{"Normal":{}}},{"name":"Arguments","ty":"Ast[Arguments]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _ref_ be ? the result of evaluating |CallExpression|.\n  1. Let _func_ be ? GetValue(_ref_).\n  1. Let _thisCall_ be *this* value.\n  1. Let _tailCall_ be IsInTailPosition(_thisCall_).\n  1. Return ? EvaluateCall(_func_, _ref_, |Arguments|, _tailCall_).","code":"\n          1. Let _ref_ be ? Evaluation of |CallExpression|.\n          1. Let _func_ be ? GetValue(_ref_).\n          1. Let _thisCall_ be this |CallExpression|.\n          1. Let _tailCall_ be IsInTailPosition(_thisCall_).\n          1. Return ? EvaluateCall(_func_, _ref_, |Arguments|, _tailCall_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"EvaluateCall","params":[{"name":"func","ty":"ESValue","kind":{"Normal":{}}},{"name":"ref","ty":"ESValue | Record[ReferenceRecord]","kind":{"Normal":{}}},{"name":"arguments","ty":"Ast","kind":{"Normal":{}}},{"name":"tailPosition","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. If _ref_ is a Record[ReferenceRecord], then\n    1. If IsPropertyReference(_ref_) is *true*, then\n      1. Let _thisValue_ be GetThisValue(_ref_).\n    1. Else,\n      1. Let _refEnv_ be _ref_.[[Base]].\n      1. Assert: _refEnv_ is a Record[EnvironmentRecord].\n      1. Let _thisValue_ be _refEnv_.WithBaseObject().\n  1. Else,\n    1. Let _thisValue_ be *undefined*.\n  1. Let _argList_ be ? ArgumentListEvaluation of _arguments_.\n  1. If _func_ is not a Record[Object], throw a *TypeError* exception.\n  1. If IsCallable(_func_) is *false*, throw a *TypeError* exception.\n  1. If _tailPosition_ is *true*, perform PrepareForTailCall().\n  1. Return ? Call(_func_, _thisValue_, _argList_).","code":"\n          1. If _ref_ is a Reference Record, then\n            1. If IsPropertyReference(_ref_) is *true*, then\n              1. Let _thisValue_ be GetThisValue(_ref_).\n            1. Else,\n              1. Let _refEnv_ be _ref_.[[Base]].\n              1. Assert: _refEnv_ is an Environment Record.\n              1. Let _thisValue_ be _refEnv_.WithBaseObject().\n          1. Else,\n            1. Let _thisValue_ be *undefined*.\n          1. Let _argList_ be ? ArgumentListEvaluation of _arguments_.\n          1. If _func_ is not an Object, throw a *TypeError* exception.\n          1. If IsCallable(_func_) is *false*, throw a *TypeError* exception.\n          1. If _tailPosition_ is *true*, perform PrepareForTailCall().\n          1. Return ? Call(_func_, _thisValue_, _argList_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"SuperProperty","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _env_ be GetThisEnvironment().\n  1. Let _actualThis_ be ? _env_.GetThisBinding().\n  1. Let _propertyNameReference_ be ? the result of evaluating |Expression|.\n  1. Let _propertyNameValue_ be ? GetValue(_propertyNameReference_).\n  1. Let _propertyKey_ be ? ToPropertyKey(_propertyNameValue_).\n  1. If the source text matched by *this* value is strict mode code, let _strict_ be *true*.\n  1. Else, let _strict_ be *false*.\n  1. Return ? MakeSuperPropertyReference(_actualThis_, _propertyKey_, _strict_).","code":"\n          1. Let _env_ be GetThisEnvironment().\n          1. Let _actualThis_ be ? _env_.GetThisBinding().\n          1. Let _propertyNameReference_ be ? Evaluation of |Expression|.\n          1. Let _propertyNameValue_ be ? GetValue(_propertyNameReference_).\n          1. Let _propertyKey_ be ? ToPropertyKey(_propertyNameValue_).\n          1. If the source text matched by this |SuperProperty| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.\n          1. Return ? MakeSuperPropertyReference(_actualThis_, _propertyKey_, _strict_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"SuperProperty","idx":1,"subIdx":0,"rhsParams":[{"name":"IdentifierName","ty":"Ast[IdentifierName]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _env_ be GetThisEnvironment().\n  1. Let _actualThis_ be ? _env_.GetThisBinding().\n  1. Let _propertyKey_ be StringValue of |IdentifierName|.\n  1. If the source text matched by *this* value is strict mode code, let _strict_ be *true*.\n  1. Else, let _strict_ be *false*.\n  1. Return ? MakeSuperPropertyReference(_actualThis_, _propertyKey_, _strict_).","code":"\n          1. Let _env_ be GetThisEnvironment().\n          1. Let _actualThis_ be ? _env_.GetThisBinding().\n          1. Let _propertyKey_ be StringValue of |IdentifierName|.\n          1. If the source text matched by this |SuperProperty| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.\n          1. Return ? MakeSuperPropertyReference(_actualThis_, _propertyKey_, _strict_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"SuperCall","idx":0,"subIdx":0,"rhsParams":[{"name":"Arguments","ty":"Ast[Arguments]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _newTarget_ be GetNewTarget().\n  1. Assert: _newTarget_ is a Record[Object].\n  1. Let _func_ be GetSuperConstructor().\n  1. Let _argList_ be ? ArgumentListEvaluation of |Arguments|.\n  1. If IsConstructor(_func_) is *false*, throw a *TypeError* exception.\n  1. Let _result_ be ? Construct(_func_, _argList_, _newTarget_).\n  1. Let _thisER_ be GetThisEnvironment().\n  1. Perform ? _thisER_.BindThisValue(_result_).\n  1. Let _F_ be _thisER_.[[FunctionObject]].\n  1. Assert: _F_ is a Record[ECMAScriptFunctionObject].\n  1. Perform ? InitializeInstanceElements(_result_, _F_).\n  1. Return _result_.","code":"\n          1. Let _newTarget_ be GetNewTarget().\n          1. Assert: _newTarget_ is an Object.\n          1. Let _func_ be GetSuperConstructor().\n          1. Let _argList_ be ? ArgumentListEvaluation of |Arguments|.\n          1. If IsConstructor(_func_) is *false*, throw a *TypeError* exception.\n          1. Let _result_ be ? Construct(_func_, _argList_, _newTarget_).\n          1. Let _thisER_ be GetThisEnvironment().\n          1. Perform ? _thisER_.BindThisValue(_result_).\n          1. Let _F_ be _thisER_.[[FunctionObject]].\n          1. Assert: _F_ is an ECMAScript function object.\n          1. Perform ? InitializeInstanceElements(_result_, _F_).\n          1. Return _result_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetSuperConstructor","params":[],"retTy":"ESValue"}},"body":"\n  1. Let _envRec_ be GetThisEnvironment().\n  1. Assert: _envRec_ is a Record[FunctionEnvironmentRecord].\n  1. Let _activeFunction_ be _envRec_.[[FunctionObject]].\n  1. Assert: _activeFunction_ is a Record[ECMAScriptFunctionObject].\n  1. Let _superConstructor_ be ! _activeFunction_.[[GetPrototypeOf]]().\n  1. Return _superConstructor_.","code":"\n          1. Let _envRec_ be GetThisEnvironment().\n          1. Assert: _envRec_ is a Function Environment Record.\n          1. Let _activeFunction_ be _envRec_.[[FunctionObject]].\n          1. Assert: _activeFunction_ is an ECMAScript function object.\n          1. Let _superConstructor_ be ! _activeFunction_.[[GetPrototypeOf]]().\n          1. Return _superConstructor_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"MakeSuperPropertyReference","params":[{"name":"actualThis","ty":"ESValue","kind":{"Normal":{}}},{"name":"propertyKey","ty":"Record[Symbol] | String","kind":{"Normal":{}}},{"name":"strict","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[Record[SuperReferenceRecord]] | Throw"}},"body":"\n  1. Let _env_ be GetThisEnvironment().\n  1. Assert: _env_.HasSuperBinding() is *true*.\n  1. Let _baseValue_ be ? _env_.GetSuperBase().\n  1. Return Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _propertyKey_, [[Strict]]: _strict_, [[ThisValue]]: _actualThis_ }.","code":"\n          1. Let _env_ be GetThisEnvironment().\n          1. Assert: _env_.HasSuperBinding() is *true*.\n          1. Let _baseValue_ be ? _env_.GetSuperBase().\n          1. Return the Reference Record { [[Base]]: _baseValue_, [[ReferencedName]]: _propertyKey_, [[Strict]]: _strict_, [[ThisValue]]: _actualThis_ }.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Arguments","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"ArgumentListEvaluation","isStatic":false,"withParams":[],"retTy":"Normal[List[ESValue]] | Abrupt"}},"body":"\n  1. Return « ».","code":"\n          1. Return a new empty List.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArgumentList","idx":0,"subIdx":0,"rhsParams":[{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"ArgumentListEvaluation","isStatic":false,"withParams":[],"retTy":"Normal[List[ESValue]] | Abrupt"}},"body":"\n  1. Let _ref_ be ? the result of evaluating |AssignmentExpression|.\n  1. Let _arg_ be ? GetValue(_ref_).\n  1. Return « _arg_ ».","code":"\n          1. Let _ref_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _arg_ be ? GetValue(_ref_).\n          1. Return « _arg_ ».\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArgumentList","idx":1,"subIdx":0,"rhsParams":[{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"ArgumentListEvaluation","isStatic":false,"withParams":[],"retTy":"Normal[List[ESValue]] | Abrupt"}},"body":"\n  1. Let _list_ be « ».\n  1. Let _spreadRef_ be ? the result of evaluating |AssignmentExpression|.\n  1. Let _spreadObj_ be ? GetValue(_spreadRef_).\n  1. Let _iteratorRecord_ be ? GetIterator(_spreadObj_, ~sync~).\n  1. Repeat, \n    1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n    1. If _next_ is ~done~, return _list_.\n    1. Append _next_ to _list_.","code":"\n          1. Let _list_ be a new empty List.\n          1. Let _spreadRef_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _spreadObj_ be ? GetValue(_spreadRef_).\n          1. Let _iteratorRecord_ be ? GetIterator(_spreadObj_, ~sync~).\n          1. Repeat,\n            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n            1. If _next_ is ~done~, return _list_.\n            1. Append _next_ to _list_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArgumentList","idx":2,"subIdx":0,"rhsParams":[{"name":"ArgumentList","ty":"Ast[ArgumentList]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"ArgumentListEvaluation","isStatic":false,"withParams":[],"retTy":"Normal[List[ESValue]] | Abrupt"}},"body":"\n  1. Let _precedingArgs_ be ? ArgumentListEvaluation of |ArgumentList|.\n  1. Let _ref_ be ? the result of evaluating |AssignmentExpression|.\n  1. Let _arg_ be ? GetValue(_ref_).\n  1. Return the list-concatenation of _precedingArgs_ and « _arg_ ».","code":"\n          1. Let _precedingArgs_ be ? ArgumentListEvaluation of |ArgumentList|.\n          1. Let _ref_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _arg_ be ? GetValue(_ref_).\n          1. Return the list-concatenation of _precedingArgs_ and « _arg_ ».\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArgumentList","idx":3,"subIdx":0,"rhsParams":[{"name":"ArgumentList","ty":"Ast[ArgumentList]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"ArgumentListEvaluation","isStatic":false,"withParams":[],"retTy":"Normal[List[ESValue]] | Abrupt"}},"body":"\n  1. Let _precedingArgs_ be ? ArgumentListEvaluation of |ArgumentList|.\n  1. Let _spreadRef_ be ? the result of evaluating |AssignmentExpression|.\n  1. Let _iteratorRecord_ be ? GetIterator(? GetValue(_spreadRef_), ~sync~).\n  1. Repeat, \n    1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n    1. If _next_ is ~done~, return _precedingArgs_.\n    1. Append _next_ to _precedingArgs_.","code":"\n          1. Let _precedingArgs_ be ? ArgumentListEvaluation of |ArgumentList|.\n          1. Let _spreadRef_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _iteratorRecord_ be ? GetIterator(? GetValue(_spreadRef_), ~sync~).\n          1. Repeat,\n            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n            1. If _next_ is ~done~, return _precedingArgs_.\n            1. Append _next_ to _precedingArgs_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TemplateLiteral","idx":0,"subIdx":0,"rhsParams":[{"name":"NoSubstitutionTemplate","ty":"Ast[NoSubstitutionTemplate]","kind":{"Normal":{}}}]},"methodName":"ArgumentListEvaluation","isStatic":false,"withParams":[],"retTy":"Normal[List[ESValue]] | Abrupt"}},"body":"\n  1. Let _templateLiteral_ be *this* value.\n  1. Let _siteObj_ be GetTemplateObject(_templateLiteral_).\n  1. Return « _siteObj_ ».","code":"\n          1. Let _templateLiteral_ be this |TemplateLiteral|.\n          1. Let _siteObj_ be GetTemplateObject(_templateLiteral_).\n          1. Return « _siteObj_ ».\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TemplateLiteral","idx":1,"subIdx":0,"rhsParams":[{"name":"SubstitutionTemplate","ty":"Ast[SubstitutionTemplate]","kind":{"Normal":{}}}]},"methodName":"ArgumentListEvaluation","isStatic":false,"withParams":[],"retTy":"Normal[List[ESValue]] | Abrupt"}},"body":"\n  1. Let _templateLiteral_ be *this* value.\n  1. Let _siteObj_ be GetTemplateObject(_templateLiteral_).\n  1. Let _remaining_ be ? ArgumentListEvaluation of |SubstitutionTemplate|.\n  1. Return the list-concatenation of « _siteObj_ » and _remaining_.","code":"\n          1. Let _templateLiteral_ be this |TemplateLiteral|.\n          1. Let _siteObj_ be GetTemplateObject(_templateLiteral_).\n          1. Let _remaining_ be ? ArgumentListEvaluation of |SubstitutionTemplate|.\n          1. Return the list-concatenation of « _siteObj_ » and _remaining_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"SubstitutionTemplate","idx":0,"subIdx":0,"rhsParams":[{"name":"TemplateHead","ty":"Ast[TemplateHead]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"TemplateSpans","ty":"Ast[TemplateSpans]","kind":{"Normal":{}}}]},"methodName":"ArgumentListEvaluation","isStatic":false,"withParams":[],"retTy":"Normal[List[ESValue]] | Abrupt"}},"body":"\n  1. Let _firstSubRef_ be ? the result of evaluating |Expression|.\n  1. Let _firstSub_ be ? GetValue(_firstSubRef_).\n  1. Let _restSub_ be ? SubstitutionEvaluation of |TemplateSpans|.\n  1. Assert: _restSub_ is a possibly empty List..\n  1. Return the list-concatenation of « _firstSub_ » and _restSub_.","code":"\n          1. Let _firstSubRef_ be ? Evaluation of |Expression|.\n          1. Let _firstSub_ be ? GetValue(_firstSubRef_).\n          1. Let _restSub_ be ? SubstitutionEvaluation of |TemplateSpans|.\n          1. Assert: _restSub_ is a possibly empty List.\n          1. Return the list-concatenation of « _firstSub_ » and _restSub_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"OptionalExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"OptionalChain","ty":"Ast[OptionalChain]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _baseReference_ be ? the result of evaluating |MemberExpression|.\n  1. Let _baseValue_ be ? GetValue(_baseReference_).\n  1. If _baseValue_ is either *undefined* or *null*, then\n    1. Return *undefined*.\n  1. Return ? ChainEvaluation of |OptionalChain| with arguments _baseValue_ and _baseReference_.","code":"\n          1. Let _baseReference_ be ? Evaluation of |MemberExpression|.\n          1. Let _baseValue_ be ? GetValue(_baseReference_).\n          1. If _baseValue_ is either *undefined* or *null*, then\n            1. Return *undefined*.\n          1. Return ? ChainEvaluation of |OptionalChain| with arguments _baseValue_ and _baseReference_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"OptionalExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"CallExpression","ty":"Ast[CallExpression]","kind":{"Normal":{}}},{"name":"OptionalChain","ty":"Ast[OptionalChain]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _baseReference_ be ? the result of evaluating |CallExpression|.\n  1. Let _baseValue_ be ? GetValue(_baseReference_).\n  1. If _baseValue_ is either *undefined* or *null*, then\n    1. Return *undefined*.\n  1. Return ? ChainEvaluation of |OptionalChain| with arguments _baseValue_ and _baseReference_.","code":"\n          1. Let _baseReference_ be ? Evaluation of |CallExpression|.\n          1. Let _baseValue_ be ? GetValue(_baseReference_).\n          1. If _baseValue_ is either *undefined* or *null*, then\n            1. Return *undefined*.\n          1. Return ? ChainEvaluation of |OptionalChain| with arguments _baseValue_ and _baseReference_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"OptionalExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"OptionalExpression","ty":"Ast[OptionalExpression]","kind":{"Normal":{}}},{"name":"OptionalChain","ty":"Ast[OptionalChain]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _baseReference_ be ? the result of evaluating |OptionalExpression|.\n  1. Let _baseValue_ be ? GetValue(_baseReference_).\n  1. If _baseValue_ is either *undefined* or *null*, then\n    1. Return *undefined*.\n  1. Return ? ChainEvaluation of |OptionalChain| with arguments _baseValue_ and _baseReference_.","code":"\n          1. Let _baseReference_ be ? Evaluation of |OptionalExpression|.\n          1. Let _baseValue_ be ? GetValue(_baseReference_).\n          1. If _baseValue_ is either *undefined* or *null*, then\n            1. Return *undefined*.\n          1. Return ? ChainEvaluation of |OptionalChain| with arguments _baseValue_ and _baseReference_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"OptionalChain","idx":0,"subIdx":0,"rhsParams":[{"name":"Arguments","ty":"Ast[Arguments]","kind":{"Normal":{}}}]},"methodName":"ChainEvaluation","isStatic":false,"withParams":[{"name":"baseValue","ty":"ESValue","kind":{"Normal":{}}},{"name":"baseReference","ty":"ESValue | Record[ReferenceRecord]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue | Record[ReferenceRecord]] | Abrupt"}},"body":"\n  1. Let _thisChain_ be *this* value.\n  1. Let _tailCall_ be IsInTailPosition(_thisChain_).\n  1. Return ? EvaluateCall(_baseValue_, _baseReference_, |Arguments|, _tailCall_).","code":"\n          1. Let _thisChain_ be this |OptionalChain|.\n          1. Let _tailCall_ be IsInTailPosition(_thisChain_).\n          1. Return ? EvaluateCall(_baseValue_, _baseReference_, |Arguments|, _tailCall_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"OptionalChain","idx":1,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"ChainEvaluation","isStatic":false,"withParams":[{"name":"baseValue","ty":"ESValue","kind":{"Normal":{}}},{"name":"baseReference","ty":"ESValue | Record[ReferenceRecord]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue | Record[ReferenceRecord]] | Abrupt"}},"body":"\n  1. If the source text matched by *this* value is strict mode code, let _strict_ be *true*.\n  1. Else, let _strict_ be *false*.\n  1. Return ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_).","code":"\n          1. If the source text matched by this |OptionalChain| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.\n          1. Return ? EvaluatePropertyAccessWithExpressionKey(_baseValue_, |Expression|, _strict_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"OptionalChain","idx":2,"subIdx":0,"rhsParams":[{"name":"IdentifierName","ty":"Ast[IdentifierName]","kind":{"Normal":{}}}]},"methodName":"ChainEvaluation","isStatic":false,"withParams":[{"name":"baseValue","ty":"ESValue","kind":{"Normal":{}}},{"name":"baseReference","ty":"ESValue | Record[ReferenceRecord]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue | Record[ReferenceRecord]] | Abrupt"}},"body":"\n  1. If the source text matched by *this* value is strict mode code, let _strict_ be *true*.\n  1. Else, let _strict_ be *false*.\n  1. Return EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_).","code":"\n          1. If the source text matched by this |OptionalChain| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.\n          1. Return EvaluatePropertyAccessWithIdentifierKey(_baseValue_, |IdentifierName|, _strict_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"OptionalChain","idx":4,"subIdx":0,"rhsParams":[{"name":"PrivateIdentifier","ty":"Ast[PrivateIdentifier]","kind":{"Normal":{}}}]},"methodName":"ChainEvaluation","isStatic":false,"withParams":[{"name":"baseValue","ty":"ESValue","kind":{"Normal":{}}},{"name":"baseReference","ty":"ESValue | Record[ReferenceRecord]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue | Record[ReferenceRecord]] | Abrupt"}},"body":"\n  1. Let _fieldNameString_ be StringValue of |PrivateIdentifier|.\n  1. Return MakePrivateReference(_baseValue_, _fieldNameString_).","code":"\n          1. Let _fieldNameString_ be the StringValue of |PrivateIdentifier|.\n          1. Return MakePrivateReference(_baseValue_, _fieldNameString_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"OptionalChain","idx":5,"subIdx":0,"rhsParams":[{"name":"OptionalChain","ty":"Ast[OptionalChain]","kind":{"Normal":{}}},{"name":"Arguments","ty":"Ast[Arguments]","kind":{"Normal":{}}}]},"methodName":"ChainEvaluation","isStatic":false,"withParams":[{"name":"baseValue","ty":"ESValue","kind":{"Normal":{}}},{"name":"baseReference","ty":"ESValue | Record[ReferenceRecord]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue | Record[ReferenceRecord]] | Abrupt"}},"body":"\n  1. Let _optionalChain_ be |OptionalChain|.\n  1. Let _newReference_ be ? ChainEvaluation of _optionalChain_ with arguments _baseValue_ and _baseReference_.\n  1. Let _newValue_ be ? GetValue(_newReference_).\n  1. Let _thisChain_ be *this* value.\n  1. Let _tailCall_ be IsInTailPosition(_thisChain_).\n  1. Return ? EvaluateCall(_newValue_, _newReference_, |Arguments|, _tailCall_).","code":"\n          1. Let _optionalChain_ be |OptionalChain|.\n          1. Let _newReference_ be ? ChainEvaluation of _optionalChain_ with arguments _baseValue_ and _baseReference_.\n          1. Let _newValue_ be ? GetValue(_newReference_).\n          1. Let _thisChain_ be this |OptionalChain|.\n          1. Let _tailCall_ be IsInTailPosition(_thisChain_).\n          1. Return ? EvaluateCall(_newValue_, _newReference_, |Arguments|, _tailCall_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"OptionalChain","idx":6,"subIdx":0,"rhsParams":[{"name":"OptionalChain","ty":"Ast[OptionalChain]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"ChainEvaluation","isStatic":false,"withParams":[{"name":"baseValue","ty":"ESValue","kind":{"Normal":{}}},{"name":"baseReference","ty":"ESValue | Record[ReferenceRecord]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue | Record[ReferenceRecord]] | Abrupt"}},"body":"\n  1. Let _optionalChain_ be |OptionalChain|.\n  1. Let _newReference_ be ? ChainEvaluation of _optionalChain_ with arguments _baseValue_ and _baseReference_.\n  1. Let _newValue_ be ? GetValue(_newReference_).\n  1. If the source text matched by *this* value is strict mode code, let _strict_ be *true*.\n  1. Else, let _strict_ be *false*.\n  1. Return ? EvaluatePropertyAccessWithExpressionKey(_newValue_, |Expression|, _strict_).","code":"\n          1. Let _optionalChain_ be |OptionalChain|.\n          1. Let _newReference_ be ? ChainEvaluation of _optionalChain_ with arguments _baseValue_ and _baseReference_.\n          1. Let _newValue_ be ? GetValue(_newReference_).\n          1. If the source text matched by this |OptionalChain| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.\n          1. Return ? EvaluatePropertyAccessWithExpressionKey(_newValue_, |Expression|, _strict_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"OptionalChain","idx":7,"subIdx":0,"rhsParams":[{"name":"OptionalChain","ty":"Ast[OptionalChain]","kind":{"Normal":{}}},{"name":"IdentifierName","ty":"Ast[IdentifierName]","kind":{"Normal":{}}}]},"methodName":"ChainEvaluation","isStatic":false,"withParams":[{"name":"baseValue","ty":"ESValue","kind":{"Normal":{}}},{"name":"baseReference","ty":"ESValue | Record[ReferenceRecord]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue | Record[ReferenceRecord]] | Abrupt"}},"body":"\n  1. Let _optionalChain_ be |OptionalChain|.\n  1. Let _newReference_ be ? ChainEvaluation of _optionalChain_ with arguments _baseValue_ and _baseReference_.\n  1. Let _newValue_ be ? GetValue(_newReference_).\n  1. If the source text matched by *this* value is strict mode code, let _strict_ be *true*.\n  1. Else, let _strict_ be *false*.\n  1. Return EvaluatePropertyAccessWithIdentifierKey(_newValue_, |IdentifierName|, _strict_).","code":"\n          1. Let _optionalChain_ be |OptionalChain|.\n          1. Let _newReference_ be ? ChainEvaluation of _optionalChain_ with arguments _baseValue_ and _baseReference_.\n          1. Let _newValue_ be ? GetValue(_newReference_).\n          1. If the source text matched by this |OptionalChain| is strict mode code, let _strict_ be *true*; else let _strict_ be *false*.\n          1. Return EvaluatePropertyAccessWithIdentifierKey(_newValue_, |IdentifierName|, _strict_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"OptionalChain","idx":9,"subIdx":0,"rhsParams":[{"name":"OptionalChain","ty":"Ast[OptionalChain]","kind":{"Normal":{}}},{"name":"PrivateIdentifier","ty":"Ast[PrivateIdentifier]","kind":{"Normal":{}}}]},"methodName":"ChainEvaluation","isStatic":false,"withParams":[{"name":"baseValue","ty":"ESValue","kind":{"Normal":{}}},{"name":"baseReference","ty":"ESValue | Record[ReferenceRecord]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue | Record[ReferenceRecord]] | Abrupt"}},"body":"\n  1. Let _optionalChain_ be |OptionalChain|.\n  1. Let _newReference_ be ? ChainEvaluation of _optionalChain_ with arguments _baseValue_ and _baseReference_.\n  1. Let _newValue_ be ? GetValue(_newReference_).\n  1. Let _fieldNameString_ be StringValue of |PrivateIdentifier|.\n  1. Return MakePrivateReference(_newValue_, _fieldNameString_).","code":"\n          1. Let _optionalChain_ be |OptionalChain|.\n          1. Let _newReference_ be ? ChainEvaluation of _optionalChain_ with arguments _baseValue_ and _baseReference_.\n          1. Let _newValue_ be ? GetValue(_newReference_).\n          1. Let _fieldNameString_ be the StringValue of |PrivateIdentifier|.\n          1. Return MakePrivateReference(_newValue_, _fieldNameString_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ImportCall","idx":0,"subIdx":0,"rhsParams":[{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _referrer_ be GetActiveScriptOrModule().\n  1. If _referrer_ is *null*, set _referrer_ to the current Realm Record.\n  1. Let _argRef_ be ? the result of evaluating |AssignmentExpression|.\n  1. Let _specifier_ be ? GetValue(_argRef_).\n  1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n  1. Let _specifierString_ be Completion(ToString(_specifier_)).\n  1. Perform IfAbruptRejectPromise(_specifierString_, _promiseCapability_).\n  1. Perform HostLoadImportedModule(_referrer_, _specifierString_, ~empty~, _promiseCapability_).\n  1. Return _promiseCapability_.[[Promise]].","code":"\n          1. Let _referrer_ be GetActiveScriptOrModule().\n          1. If _referrer_ is *null*, set _referrer_ to the current Realm Record.\n          1. Let _argRef_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _specifier_ be ? GetValue(_argRef_).\n          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n          1. Let _specifierString_ be Completion(ToString(_specifier_)).\n          1. IfAbruptRejectPromise(_specifierString_, _promiseCapability_).\n          1. Perform HostLoadImportedModule(_referrer_, _specifierString_, ~empty~, _promiseCapability_).\n          1. Return _promiseCapability_.[[Promise]].\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ContinueDynamicImport","params":[{"name":"promiseCapability","ty":"Record[PromiseCapabilityRecord]","kind":{"Normal":{}}},{"name":"moduleCompletion","ty":"Normal[Record[ModuleRecord]] | Throw","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. If _moduleCompletion_ is an abrupt completion, then\n    1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _moduleCompletion_.[[Value]] »).\n    1. Return ~unused~.\n  1. Let _module_ be _moduleCompletion_.[[Value]].\n  1. Let _loadPromise_ be _module_.LoadRequestedModules().\n  1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _promiseCapability_ and performs the following steps when called:\n    1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _reason_ »).\n    1. Return ~unused~.\n  1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *\"\"*, « »).\n  1. Let _linkAndEvaluateClosure_ be a new Abstract Closure with no parameters that captures _module_, _promiseCapability_, and _onRejected_ and performs the following steps when called:\n    1. Let _link_ be Completion(_module_.Link()).\n    1. If _link_ is an abrupt completion, then\n      1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _link_.[[Value]] »).\n      1. Return ~unused~.\n    1. Let _evaluatePromise_ be _module_.Evaluate().\n    1. Let _fulfilledClosure_ be a new Abstract Closure with no parameters that captures _module_ and _promiseCapability_ and performs the following steps when called:\n      1. Let _namespace_ be GetModuleNamespace(_module_).\n      1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _namespace_ »).\n      1. Return ~unused~.\n    1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 0, *\"\"*, « »).\n    1. Perform PerformPromiseThen(_evaluatePromise_, _onFulfilled_, _onRejected_).\n    1. Return ~unused~.\n  1. Let _linkAndEvaluate_ be CreateBuiltinFunction(_linkAndEvaluateClosure_, 0, *\"\"*, « »).\n  1. Perform PerformPromiseThen(_loadPromise_, _linkAndEvaluate_, _onRejected_).\n  1. Return ~unused~.","code":"\n            1. If _moduleCompletion_ is an abrupt completion, then\n              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _moduleCompletion_.[[Value]] »).\n              1. Return ~unused~.\n            1. Let _module_ be _moduleCompletion_.[[Value]].\n            1. Let _loadPromise_ be _module_.LoadRequestedModules().\n            1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _promiseCapability_ and performs the following steps when called:\n              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _reason_ »).\n              1. Return ~unused~.\n            1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *\"\"*, « »).\n            1. Let _linkAndEvaluateClosure_ be a new Abstract Closure with no parameters that captures _module_, _promiseCapability_, and _onRejected_ and performs the following steps when called:\n              1. Let _link_ be Completion(_module_.Link()).\n              1. If _link_ is an abrupt completion, then\n                1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _link_.[[Value]] »).\n                1. Return ~unused~.\n              1. Let _evaluatePromise_ be _module_.Evaluate().\n              1. Let _fulfilledClosure_ be a new Abstract Closure with no parameters that captures _module_ and _promiseCapability_ and performs the following steps when called:\n                1. Let _namespace_ be GetModuleNamespace(_module_).\n                1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _namespace_ »).\n                1. Return ~unused~.\n              1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 0, *\"\"*, « »).\n              1. Perform PerformPromiseThen(_evaluatePromise_, _onFulfilled_, _onRejected_).\n              1. Return ~unused~.\n            1. Let _linkAndEvaluate_ be CreateBuiltinFunction(_linkAndEvaluateClosure_, 0, *\"\"*, « »).\n            1. Perform PerformPromiseThen(_loadPromise_, _linkAndEvaluate_, _onRejected_).\n            1. Return ~unused~.\n          "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"TemplateLiteral","ty":"Ast[TemplateLiteral]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _tagRef_ be ? the result of evaluating |MemberExpression|.\n  1. Let _tagFunc_ be ? GetValue(_tagRef_).\n  1. Let _thisCall_ be *this* value.\n  1. Let _tailCall_ be IsInTailPosition(_thisCall_).\n  1. Return ? EvaluateCall(_tagFunc_, _tagRef_, |TemplateLiteral|, _tailCall_).","code":"\n          1. Let _tagRef_ be ? Evaluation of |MemberExpression|.\n          1. Let _tagFunc_ be ? GetValue(_tagRef_).\n          1. Let _thisCall_ be this |MemberExpression|.\n          1. Let _tailCall_ be IsInTailPosition(_thisCall_).\n          1. Return ? EvaluateCall(_tagFunc_, _tagRef_, |TemplateLiteral|, _tailCall_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CallExpression","idx":6,"subIdx":0,"rhsParams":[{"name":"CallExpression","ty":"Ast[CallExpression]","kind":{"Normal":{}}},{"name":"TemplateLiteral","ty":"Ast[TemplateLiteral]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _tagRef_ be ? the result of evaluating |CallExpression|.\n  1. Let _tagFunc_ be ? GetValue(_tagRef_).\n  1. Let _thisCall_ be *this* value.\n  1. Let _tailCall_ be IsInTailPosition(_thisCall_).\n  1. Return ? EvaluateCall(_tagFunc_, _tagRef_, |TemplateLiteral|, _tailCall_).","code":"\n          1. Let _tagRef_ be ? Evaluation of |CallExpression|.\n          1. Let _tagFunc_ be ? GetValue(_tagRef_).\n          1. Let _thisCall_ be this |CallExpression|.\n          1. Let _tailCall_ be IsInTailPosition(_thisCall_).\n          1. Return ? EvaluateCall(_tagFunc_, _tagRef_, |TemplateLiteral|, _tailCall_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NewTarget","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return GetNewTarget().","code":"\n          1. Return GetNewTarget().\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ImportMeta","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _module_ be GetActiveScriptOrModule().\n  1. Assert: _module_ is a Record[SourceTextModuleRecord].\n  1. Let _importMeta_ be _module_.[[ImportMeta]].\n  1. If _importMeta_ is ~empty~, then\n    1. Set _importMeta_ to OrdinaryObjectCreate(*null*).\n    1. Let _importMetaValues_ be HostGetImportMetaProperties(_module_).\n    1. For each Record[{ Key, Value }] _p_ of _importMetaValues_, do\n      1. Perform ! CreateDataPropertyOrThrow(_importMeta_, _p_.[[Key]], _p_.[[Value]]).\n    1. Perform HostFinalizeImportMeta(_importMeta_, _module_).\n    1. Set _module_.[[ImportMeta]] to _importMeta_.\n    1. Return _importMeta_.\n  1. Else,\n    1. Assert: _importMeta_ is a Record[Object].\n    1. Return _importMeta_.","code":"\n          1. Let _module_ be GetActiveScriptOrModule().\n          1. Assert: _module_ is a Source Text Module Record.\n          1. Let _importMeta_ be _module_.[[ImportMeta]].\n          1. If _importMeta_ is ~empty~, then\n            1. Set _importMeta_ to OrdinaryObjectCreate(*null*).\n            1. Let _importMetaValues_ be HostGetImportMetaProperties(_module_).\n            1. For each Record { [[Key]], [[Value]] } _p_ of _importMetaValues_, do\n              1. Perform ! CreateDataPropertyOrThrow(_importMeta_, _p_.[[Key]], _p_.[[Value]]).\n            1. Perform HostFinalizeImportMeta(_importMeta_, _module_).\n            1. Set _module_.[[ImportMeta]] to _importMeta_.\n            1. Return _importMeta_.\n          1. Else,\n            1. Assert: _importMeta_ is an Object.\n            1. Return _importMeta_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UpdateExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _lhs_ be ? the result of evaluating |LeftHandSideExpression|.\n  1. Let _oldValue_ be ? ToNumeric(? GetValue(_lhs_)).\n  1. If _oldValue_ is a Number, then\n    1. Let _newValue_ be Number::add(_oldValue_, *1*<sub>𝔽</sub>).\n  1. Else,\n    1. Assert: _oldValue_ is a BigInt.\n    1. Let _newValue_ be BigInt::add(_oldValue_, *1*<sub>ℤ</sub>).\n  1. Perform ? PutValue(_lhs_, _newValue_).\n  1. Return _oldValue_.","code":"\n          1. Let _lhs_ be ? Evaluation of |LeftHandSideExpression|.\n          1. Let _oldValue_ be ? ToNumeric(? GetValue(_lhs_)).\n          1. If _oldValue_ is a Number, then\n            1. Let _newValue_ be Number::add(_oldValue_, *1*<sub>𝔽</sub>).\n          1. Else,\n            1. Assert: _oldValue_ is a BigInt.\n            1. Let _newValue_ be BigInt::add(_oldValue_, *1*<sub>ℤ</sub>).\n          1. Perform ? PutValue(_lhs_, _newValue_).\n          1. Return _oldValue_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UpdateExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _lhs_ be ? the result of evaluating |LeftHandSideExpression|.\n  1. Let _oldValue_ be ? ToNumeric(? GetValue(_lhs_)).\n  1. If _oldValue_ is a Number, then\n    1. Let _newValue_ be Number::subtract(_oldValue_, *1*<sub>𝔽</sub>).\n  1. Else,\n    1. Assert: _oldValue_ is a BigInt.\n    1. Let _newValue_ be BigInt::subtract(_oldValue_, *1*<sub>ℤ</sub>).\n  1. Perform ? PutValue(_lhs_, _newValue_).\n  1. Return _oldValue_.","code":"\n          1. Let _lhs_ be ? Evaluation of |LeftHandSideExpression|.\n          1. Let _oldValue_ be ? ToNumeric(? GetValue(_lhs_)).\n          1. If _oldValue_ is a Number, then\n            1. Let _newValue_ be Number::subtract(_oldValue_, *1*<sub>𝔽</sub>).\n          1. Else,\n            1. Assert: _oldValue_ is a BigInt.\n            1. Let _newValue_ be BigInt::subtract(_oldValue_, *1*<sub>ℤ</sub>).\n          1. Perform ? PutValue(_lhs_, _newValue_).\n          1. Return _oldValue_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UpdateExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _expr_ be ? the result of evaluating |UnaryExpression|.\n  1. Let _oldValue_ be ? ToNumeric(? GetValue(_expr_)).\n  1. If _oldValue_ is a Number, then\n    1. Let _newValue_ be Number::add(_oldValue_, *1*<sub>𝔽</sub>).\n  1. Else,\n    1. Assert: _oldValue_ is a BigInt.\n    1. Let _newValue_ be BigInt::add(_oldValue_, *1*<sub>ℤ</sub>).\n  1. Perform ? PutValue(_expr_, _newValue_).\n  1. Return _newValue_.","code":"\n          1. Let _expr_ be ? Evaluation of |UnaryExpression|.\n          1. Let _oldValue_ be ? ToNumeric(? GetValue(_expr_)).\n          1. If _oldValue_ is a Number, then\n            1. Let _newValue_ be Number::add(_oldValue_, *1*<sub>𝔽</sub>).\n          1. Else,\n            1. Assert: _oldValue_ is a BigInt.\n            1. Let _newValue_ be BigInt::add(_oldValue_, *1*<sub>ℤ</sub>).\n          1. Perform ? PutValue(_expr_, _newValue_).\n          1. Return _newValue_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UpdateExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _expr_ be ? the result of evaluating |UnaryExpression|.\n  1. Let _oldValue_ be ? ToNumeric(? GetValue(_expr_)).\n  1. If _oldValue_ is a Number, then\n    1. Let _newValue_ be Number::subtract(_oldValue_, *1*<sub>𝔽</sub>).\n  1. Else,\n    1. Assert: _oldValue_ is a BigInt.\n    1. Let _newValue_ be BigInt::subtract(_oldValue_, *1*<sub>ℤ</sub>).\n  1. Perform ? PutValue(_expr_, _newValue_).\n  1. Return _newValue_.","code":"\n          1. Let _expr_ be ? Evaluation of |UnaryExpression|.\n          1. Let _oldValue_ be ? ToNumeric(? GetValue(_expr_)).\n          1. If _oldValue_ is a Number, then\n            1. Let _newValue_ be Number::subtract(_oldValue_, *1*<sub>𝔽</sub>).\n          1. Else,\n            1. Assert: _oldValue_ is a BigInt.\n            1. Let _newValue_ be BigInt::subtract(_oldValue_, *1*<sub>ℤ</sub>).\n          1. Perform ? PutValue(_expr_, _newValue_).\n          1. Return _newValue_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _ref_ be ? the result of evaluating |UnaryExpression|.\n  1. If _ref_ is not a Record[ReferenceRecord], return *true*.\n  1. If IsUnresolvableReference(_ref_) is *true*, then\n    1. Assert: _ref_.[[Strict]] is *false*.\n    1. Return *true*.\n  1. If IsPropertyReference(_ref_) is *true*, then\n    1. Assert: IsPrivateReference(_ref_) is *false*.\n    1. If IsSuperReference(_ref_) is *true*, throw a *ReferenceError* exception.\n    1. [id=\"step-delete-operator-toobject\"] Let _baseObj_ be ? ToObject(_ref_.[[Base]]).\n    1. Let _deleteStatus_ be ? _baseObj_.[[Delete]](_ref_.[[ReferencedName]]).\n    1. If _deleteStatus_ is *false* and _ref_.[[Strict]] is *true*, throw a *TypeError* exception.\n    1. Return _deleteStatus_.\n  1. Else,\n    1. Let _base_ be _ref_.[[Base]].\n    1. Assert: _base_ is a Record[EnvironmentRecord].\n    1. Return ? _base_.DeleteBinding(_ref_.[[ReferencedName]]).","code":"\n          1. Let _ref_ be ? Evaluation of |UnaryExpression|.\n          1. If _ref_ is not a Reference Record, return *true*.\n          1. If IsUnresolvableReference(_ref_) is *true*, then\n            1. Assert: _ref_.[[Strict]] is *false*.\n            1. Return *true*.\n          1. If IsPropertyReference(_ref_) is *true*, then\n            1. Assert: IsPrivateReference(_ref_) is *false*.\n            1. If IsSuperReference(_ref_) is *true*, throw a *ReferenceError* exception.\n            1. [id=\"step-delete-operator-toobject\"] Let _baseObj_ be ? ToObject(_ref_.[[Base]]).\n            1. Let _deleteStatus_ be ? <emu-meta effects=\"user-code\">_baseObj_.[[Delete]]</emu-meta>(_ref_.[[ReferencedName]]).\n            1. If _deleteStatus_ is *false* and _ref_.[[Strict]] is *true*, throw a *TypeError* exception.\n            1. Return _deleteStatus_.\n          1. Else,\n            1. Let _base_ be _ref_.[[Base]].\n            1. Assert: _base_ is an Environment Record.\n            1. Return ? <emu-meta effects=\"user-code\">_base_.DeleteBinding</emu-meta>(_ref_.[[ReferencedName]]).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _expr_ be ? the result of evaluating |UnaryExpression|.\n  1. Perform ? GetValue(_expr_).\n  1. Return *undefined*.","code":"\n          1. Let _expr_ be ? Evaluation of |UnaryExpression|.\n          1. Perform ? GetValue(_expr_).\n          1. Return *undefined*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _val_ be ? the result of evaluating |UnaryExpression|.\n  1. If _val_ is a Record[ReferenceRecord], then\n    1. If IsUnresolvableReference(_val_) is *true*, return *\"undefined\"*.\n  1. Set _val_ to ? GetValue(_val_).\n  1. If _val_ is *undefined*, return *\"undefined\"*.\n  1. If _val_ is *null*, return *\"object\"*.\n  1. If _val_ is a String, return *\"string\"*.\n  1. If _val_ is a Record[Symbol], return *\"symbol\"*.\n  1. If _val_ is a Boolean, return *\"boolean\"*.\n  1. If _val_ is a Number, return *\"number\"*.\n  1. If _val_ is a BigInt, return *\"bigint\"*.\n  1. Assert: _val_ is a Record[Object].\n  1. [id=\"step-typeof-web-compat-insertion-point\"] NOTE: This step is replaced in section <emu-xref href=\"#sec-IsHTMLDDA-internal-slot-typeof\"></emu-xref>.\n  1. If _val_ has a [[Call]] internal slot, return *\"function\"*.\n  1. Return *\"object\"*.","code":"\n          1. Let _val_ be ? Evaluation of |UnaryExpression|.\n          1. If _val_ is a Reference Record, then\n            1. If IsUnresolvableReference(_val_) is *true*, return *\"undefined\"*.\n          1. Set _val_ to ? GetValue(_val_).\n          1. If _val_ is *undefined*, return *\"undefined\"*.\n          1. If _val_ is *null*, return *\"object\"*.\n          1. If _val_ is a String, return *\"string\"*.\n          1. If _val_ is a Symbol, return *\"symbol\"*.\n          1. If _val_ is a Boolean, return *\"boolean\"*.\n          1. If _val_ is a Number, return *\"number\"*.\n          1. If _val_ is a BigInt, return *\"bigint\"*.\n          1. Assert: _val_ is an Object.\n          1. [id=\"step-typeof-web-compat-insertion-point\"] NOTE: This step is replaced in section <emu-xref href=\"#sec-IsHTMLDDA-internal-slot-typeof\"></emu-xref>.\n          1. If _val_ has a [[Call]] internal slot, return *\"function\"*.\n          1. Return *\"object\"*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _expr_ be ? the result of evaluating |UnaryExpression|.\n  1. Return ? ToNumber(? GetValue(_expr_)).","code":"\n          1. Let _expr_ be ? Evaluation of |UnaryExpression|.\n          1. Return ? ToNumber(? GetValue(_expr_)).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":5,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _expr_ be ? the result of evaluating |UnaryExpression|.\n  1. Let _oldValue_ be ? ToNumeric(? GetValue(_expr_)).\n  1. If _oldValue_ is a Number, then\n    1. Return Number::unaryMinus(_oldValue_).\n  1. Else,\n    1. Assert: _oldValue_ is a BigInt.\n    1. Return BigInt::unaryMinus(_oldValue_).","code":"\n          1. Let _expr_ be ? Evaluation of |UnaryExpression|.\n          1. Let _oldValue_ be ? ToNumeric(? GetValue(_expr_)).\n          1. If _oldValue_ is a Number, then\n            1. Return Number::unaryMinus(_oldValue_).\n          1. Else,\n            1. Assert: _oldValue_ is a BigInt.\n            1. Return BigInt::unaryMinus(_oldValue_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":6,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _expr_ be ? the result of evaluating |UnaryExpression|.\n  1. Let _oldValue_ be ? ToNumeric(? GetValue(_expr_)).\n  1. If _oldValue_ is a Number, then\n    1. Return Number::bitwiseNOT(_oldValue_).\n  1. Else,\n    1. Assert: _oldValue_ is a BigInt.\n    1. Return BigInt::bitwiseNOT(_oldValue_).","code":"\n          1. Let _expr_ be ? Evaluation of |UnaryExpression|.\n          1. Let _oldValue_ be ? ToNumeric(? GetValue(_expr_)).\n          1. If _oldValue_ is a Number, then\n            1. Return Number::bitwiseNOT(_oldValue_).\n          1. Else,\n            1. Assert: _oldValue_ is a BigInt.\n            1. Return BigInt::bitwiseNOT(_oldValue_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":7,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _expr_ be ? the result of evaluating |UnaryExpression|.\n  1. Let _oldValue_ be ToBoolean(? GetValue(_expr_)).\n  1. If _oldValue_ is *true*, return *false*.\n  1. Return *true*.","code":"\n          1. Let _expr_ be ? Evaluation of |UnaryExpression|.\n          1. Let _oldValue_ be ToBoolean(? GetValue(_expr_)).\n          1. If _oldValue_ is *true*, return *false*.\n          1. Return *true*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExponentiationExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"UpdateExpression","ty":"Ast[UpdateExpression]","kind":{"Normal":{}}},{"name":"ExponentiationExpression","ty":"Ast[ExponentiationExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ? EvaluateStringOrNumericBinaryExpression(|UpdateExpression|, `**`, |ExponentiationExpression|).","code":"\n        1. Return ? EvaluateStringOrNumericBinaryExpression(|UpdateExpression|, `**`, |ExponentiationExpression|).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MultiplicativeExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"MultiplicativeExpression","ty":"Ast[MultiplicativeExpression]","kind":{"Normal":{}}},{"name":"MultiplicativeOperator","ty":"Ast[MultiplicativeOperator]","kind":{"Normal":{}}},{"name":"ExponentiationExpression","ty":"Ast[ExponentiationExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _opText_ be the source text matched by |MultiplicativeOperator|.\n  1. Return ? EvaluateStringOrNumericBinaryExpression(|MultiplicativeExpression|, _opText_, |ExponentiationExpression|).","code":"\n        1. Let _opText_ be the source text matched by |MultiplicativeOperator|.\n        1. Return ? EvaluateStringOrNumericBinaryExpression(|MultiplicativeExpression|, _opText_, |ExponentiationExpression|).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AdditiveExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"AdditiveExpression","ty":"Ast[AdditiveExpression]","kind":{"Normal":{}}},{"name":"MultiplicativeExpression","ty":"Ast[MultiplicativeExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ? EvaluateStringOrNumericBinaryExpression(|AdditiveExpression|, `+`, |MultiplicativeExpression|).","code":"\n          1. Return ? EvaluateStringOrNumericBinaryExpression(|AdditiveExpression|, `+`, |MultiplicativeExpression|).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AdditiveExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"AdditiveExpression","ty":"Ast[AdditiveExpression]","kind":{"Normal":{}}},{"name":"MultiplicativeExpression","ty":"Ast[MultiplicativeExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ? EvaluateStringOrNumericBinaryExpression(|AdditiveExpression|, `-`, |MultiplicativeExpression|).","code":"\n          1. Return ? EvaluateStringOrNumericBinaryExpression(|AdditiveExpression|, `-`, |MultiplicativeExpression|).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ShiftExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}},{"name":"AdditiveExpression","ty":"Ast[AdditiveExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ? EvaluateStringOrNumericBinaryExpression(|ShiftExpression|, `<<`, |AdditiveExpression|).","code":"\n          1. Return ? EvaluateStringOrNumericBinaryExpression(|ShiftExpression|, `<<`, |AdditiveExpression|).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ShiftExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}},{"name":"AdditiveExpression","ty":"Ast[AdditiveExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ? EvaluateStringOrNumericBinaryExpression(|ShiftExpression|, `>>`, |AdditiveExpression|).","code":"\n          1. Return ? EvaluateStringOrNumericBinaryExpression(|ShiftExpression|, `>>`, |AdditiveExpression|).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ShiftExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}},{"name":"AdditiveExpression","ty":"Ast[AdditiveExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ? EvaluateStringOrNumericBinaryExpression(|ShiftExpression|, `>>>`, |AdditiveExpression|).","code":"\n          1. Return ? EvaluateStringOrNumericBinaryExpression(|ShiftExpression|, `>>>`, |AdditiveExpression|).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RelationalExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}},{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _lref_ be ? the result of evaluating |RelationalExpression|.\n  1. Let _lval_ be ? GetValue(_lref_).\n  1. Let _rref_ be ? the result of evaluating |ShiftExpression|.\n  1. Let _rval_ be ? GetValue(_rref_).\n  1. Let _r_ be ? IsLessThan(_lval_, _rval_, *true*).\n  1. If _r_ is *undefined*, return *false*.\n  1. Else, return _r_.","code":"\n        1. Let _lref_ be ? Evaluation of |RelationalExpression|.\n        1. Let _lval_ be ? GetValue(_lref_).\n        1. Let _rref_ be ? Evaluation of |ShiftExpression|.\n        1. Let _rval_ be ? GetValue(_rref_).\n        1. Let _r_ be ? IsLessThan(_lval_, _rval_, *true*).\n        1. If _r_ is *undefined*, return *false*. Otherwise, return _r_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RelationalExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}},{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _lref_ be ? the result of evaluating |RelationalExpression|.\n  1. Let _lval_ be ? GetValue(_lref_).\n  1. Let _rref_ be ? the result of evaluating |ShiftExpression|.\n  1. Let _rval_ be ? GetValue(_rref_).\n  1. Let _r_ be ? IsLessThan(_rval_, _lval_, *false*).\n  1. If _r_ is *undefined*, return *false*.\n  1. Else, return _r_.","code":"\n        1. Let _lref_ be ? Evaluation of |RelationalExpression|.\n        1. Let _lval_ be ? GetValue(_lref_).\n        1. Let _rref_ be ? Evaluation of |ShiftExpression|.\n        1. Let _rval_ be ? GetValue(_rref_).\n        1. Let _r_ be ? IsLessThan(_rval_, _lval_, *false*).\n        1. If _r_ is *undefined*, return *false*. Otherwise, return _r_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RelationalExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}},{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _lref_ be ? the result of evaluating |RelationalExpression|.\n  1. Let _lval_ be ? GetValue(_lref_).\n  1. Let _rref_ be ? the result of evaluating |ShiftExpression|.\n  1. Let _rval_ be ? GetValue(_rref_).\n  1. Let _r_ be ? IsLessThan(_rval_, _lval_, *false*).\n  1. If _r_ is either *true* or *undefined*, return *false*.\n  1. Else, return *true*.","code":"\n        1. Let _lref_ be ? Evaluation of |RelationalExpression|.\n        1. Let _lval_ be ? GetValue(_lref_).\n        1. Let _rref_ be ? Evaluation of |ShiftExpression|.\n        1. Let _rval_ be ? GetValue(_rref_).\n        1. Let _r_ be ? IsLessThan(_rval_, _lval_, *false*).\n        1. If _r_ is either *true* or *undefined*, return *false*. Otherwise, return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RelationalExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}},{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _lref_ be ? the result of evaluating |RelationalExpression|.\n  1. Let _lval_ be ? GetValue(_lref_).\n  1. Let _rref_ be ? the result of evaluating |ShiftExpression|.\n  1. Let _rval_ be ? GetValue(_rref_).\n  1. Let _r_ be ? IsLessThan(_lval_, _rval_, *true*).\n  1. If _r_ is either *true* or *undefined*, return *false*.\n  1. Else, return *true*.","code":"\n        1. Let _lref_ be ? Evaluation of |RelationalExpression|.\n        1. Let _lval_ be ? GetValue(_lref_).\n        1. Let _rref_ be ? Evaluation of |ShiftExpression|.\n        1. Let _rval_ be ? GetValue(_rref_).\n        1. Let _r_ be ? IsLessThan(_lval_, _rval_, *true*).\n        1. If _r_ is either *true* or *undefined*, return *false*. Otherwise, return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RelationalExpression","idx":5,"subIdx":0,"rhsParams":[{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}},{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _lref_ be ? the result of evaluating |RelationalExpression|.\n  1. Let _lval_ be ? GetValue(_lref_).\n  1. Let _rref_ be ? the result of evaluating |ShiftExpression|.\n  1. Let _rval_ be ? GetValue(_rref_).\n  1. Return ? InstanceofOperator(_lval_, _rval_).","code":"\n        1. Let _lref_ be ? Evaluation of |RelationalExpression|.\n        1. Let _lval_ be ? GetValue(_lref_).\n        1. Let _rref_ be ? Evaluation of |ShiftExpression|.\n        1. Let _rval_ be ? GetValue(_rref_).\n        1. Return ? InstanceofOperator(_lval_, _rval_).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RelationalExpression","idx":6,"subIdx":0,"rhsParams":[{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}},{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _lref_ be ? the result of evaluating |RelationalExpression|.\n  1. Let _lval_ be ? GetValue(_lref_).\n  1. Let _rref_ be ? the result of evaluating |ShiftExpression|.\n  1. Let _rval_ be ? GetValue(_rref_).\n  1. If _rval_ is not a Record[Object], throw a *TypeError* exception.\n  1. Return ? HasProperty(_rval_, ? ToPropertyKey(_lval_)).","code":"\n        1. Let _lref_ be ? Evaluation of |RelationalExpression|.\n        1. Let _lval_ be ? GetValue(_lref_).\n        1. Let _rref_ be ? Evaluation of |ShiftExpression|.\n        1. Let _rval_ be ? GetValue(_rref_).\n        1. If _rval_ is not an Object, throw a *TypeError* exception.\n        1. Return ? HasProperty(_rval_, ? ToPropertyKey(_lval_)).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RelationalExpression","idx":7,"subIdx":0,"rhsParams":[{"name":"PrivateIdentifier","ty":"Ast[PrivateIdentifier]","kind":{"Normal":{}}},{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _privateIdentifier_ be StringValue of |PrivateIdentifier|.\n  1. Let _rref_ be ? the result of evaluating |ShiftExpression|.\n  1. Let _rval_ be ? GetValue(_rref_).\n  1. If _rval_ is not a Record[Object], throw a *TypeError* exception.\n  1. Let _privateEnv_ be the running execution context.PrivateEnvironment.\n  1. Let _privateName_ be ResolvePrivateIdentifier(_privateEnv_, _privateIdentifier_).\n  1. If PrivateElementFind(_rval_, _privateName_) is not ~empty~, return *true*.\n  1. Return *false*.","code":"\n        1. Let _privateIdentifier_ be the StringValue of |PrivateIdentifier|.\n        1. Let _rref_ be ? Evaluation of |ShiftExpression|.\n        1. Let _rval_ be ? GetValue(_rref_).\n        1. If _rval_ is not an Object, throw a *TypeError* exception.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _privateName_ be ResolvePrivateIdentifier(_privateEnv_, _privateIdentifier_).\n        1. If PrivateElementFind(_rval_, _privateName_) is not ~empty~, return *true*.\n        1. Return *false*.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"InstanceofOperator","params":[{"name":"V","ty":"ESValue","kind":{"Normal":{}}},{"name":"target","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. If _target_ is not a Record[Object], throw a *TypeError* exception.\n  1. Let _instOfHandler_ be ? GetMethod(_target_, @@hasInstance).\n  1. If _instOfHandler_ is not *undefined*, then\n    1. Return ToBoolean(? Call(_instOfHandler_, _target_, « _V_ »)).\n  1. [id=\"step-instanceof-check-function\"] If IsCallable(_target_) is *false*, throw a *TypeError* exception.\n  1. [id=\"step-instanceof-fallback\"] Return ? OrdinaryHasInstance(_target_, _V_).","code":"\n        1. If _target_ is not an Object, throw a *TypeError* exception.\n        1. Let _instOfHandler_ be ? GetMethod(_target_, @@hasInstance).\n        1. If _instOfHandler_ is not *undefined*, then\n          1. Return ToBoolean(? Call(_instOfHandler_, _target_, « _V_ »)).\n        1. [id=\"step-instanceof-check-function\"] If IsCallable(_target_) is *false*, throw a *TypeError* exception.\n        1. [id=\"step-instanceof-fallback\"] Return ? OrdinaryHasInstance(_target_, _V_).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"EqualityExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"EqualityExpression","ty":"Ast[EqualityExpression]","kind":{"Normal":{}}},{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _lref_ be ? the result of evaluating |EqualityExpression|.\n  1. Let _lval_ be ? GetValue(_lref_).\n  1. Let _rref_ be ? the result of evaluating |RelationalExpression|.\n  1. Let _rval_ be ? GetValue(_rref_).\n  1. Return ? IsLooselyEqual(_rval_, _lval_).","code":"\n        1. Let _lref_ be ? Evaluation of |EqualityExpression|.\n        1. Let _lval_ be ? GetValue(_lref_).\n        1. Let _rref_ be ? Evaluation of |RelationalExpression|.\n        1. Let _rval_ be ? GetValue(_rref_).\n        1. Return ? IsLooselyEqual(_rval_, _lval_).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"EqualityExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"EqualityExpression","ty":"Ast[EqualityExpression]","kind":{"Normal":{}}},{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _lref_ be ? the result of evaluating |EqualityExpression|.\n  1. Let _lval_ be ? GetValue(_lref_).\n  1. Let _rref_ be ? the result of evaluating |RelationalExpression|.\n  1. Let _rval_ be ? GetValue(_rref_).\n  1. Let _r_ be ? IsLooselyEqual(_rval_, _lval_).\n  1. If _r_ is *true*, return *false*.\n  1. Else, return *true*.","code":"\n        1. Let _lref_ be ? Evaluation of |EqualityExpression|.\n        1. Let _lval_ be ? GetValue(_lref_).\n        1. Let _rref_ be ? Evaluation of |RelationalExpression|.\n        1. Let _rval_ be ? GetValue(_rref_).\n        1. Let _r_ be ? IsLooselyEqual(_rval_, _lval_).\n        1. If _r_ is *true*, return *false*. Otherwise, return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"EqualityExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"EqualityExpression","ty":"Ast[EqualityExpression]","kind":{"Normal":{}}},{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _lref_ be ? the result of evaluating |EqualityExpression|.\n  1. Let _lval_ be ? GetValue(_lref_).\n  1. Let _rref_ be ? the result of evaluating |RelationalExpression|.\n  1. Let _rval_ be ? GetValue(_rref_).\n  1. Return IsStrictlyEqual(_rval_, _lval_).","code":"\n        1. Let _lref_ be ? Evaluation of |EqualityExpression|.\n        1. Let _lval_ be ? GetValue(_lref_).\n        1. Let _rref_ be ? Evaluation of |RelationalExpression|.\n        1. Let _rval_ be ? GetValue(_rref_).\n        1. Return IsStrictlyEqual(_rval_, _lval_).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"EqualityExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"EqualityExpression","ty":"Ast[EqualityExpression]","kind":{"Normal":{}}},{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _lref_ be ? the result of evaluating |EqualityExpression|.\n  1. Let _lval_ be ? GetValue(_lref_).\n  1. Let _rref_ be ? the result of evaluating |RelationalExpression|.\n  1. Let _rval_ be ? GetValue(_rref_).\n  1. Let _r_ be IsStrictlyEqual(_rval_, _lval_).\n  1. If _r_ is *true*, return *false*.\n  1. Else, return *true*.","code":"\n        1. Let _lref_ be ? Evaluation of |EqualityExpression|.\n        1. Let _lval_ be ? GetValue(_lref_).\n        1. Let _rref_ be ? Evaluation of |RelationalExpression|.\n        1. Let _rval_ be ? GetValue(_rref_).\n        1. Let _r_ be IsStrictlyEqual(_rval_, _lval_).\n        1. If _r_ is *true*, return *false*. Otherwise, return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BitwiseANDExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"BitwiseANDExpression","ty":"Ast[BitwiseANDExpression]","kind":{"Normal":{}}},{"name":"EqualityExpression","ty":"Ast[EqualityExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ? EvaluateStringOrNumericBinaryExpression(|BitwiseANDExpression|, `&`, |EqualityExpression|).","code":"\n        1. Return ? EvaluateStringOrNumericBinaryExpression(|BitwiseANDExpression|, `&`, |EqualityExpression|).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BitwiseXORExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"BitwiseXORExpression","ty":"Ast[BitwiseXORExpression]","kind":{"Normal":{}}},{"name":"BitwiseANDExpression","ty":"Ast[BitwiseANDExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ? EvaluateStringOrNumericBinaryExpression(|BitwiseXORExpression|, `^`, |BitwiseANDExpression|).","code":"\n        1. Return ? EvaluateStringOrNumericBinaryExpression(|BitwiseXORExpression|, `^`, |BitwiseANDExpression|).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BitwiseORExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"BitwiseORExpression","ty":"Ast[BitwiseORExpression]","kind":{"Normal":{}}},{"name":"BitwiseXORExpression","ty":"Ast[BitwiseXORExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ? EvaluateStringOrNumericBinaryExpression(|BitwiseORExpression|, `|`, |BitwiseXORExpression|).","code":"\n        1. Return ? EvaluateStringOrNumericBinaryExpression(|BitwiseORExpression|, `|`, |BitwiseXORExpression|).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LogicalANDExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"LogicalANDExpression","ty":"Ast[LogicalANDExpression]","kind":{"Normal":{}}},{"name":"BitwiseORExpression","ty":"Ast[BitwiseORExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _lref_ be ? the result of evaluating |LogicalANDExpression|.\n  1. Let _lval_ be ? GetValue(_lref_).\n  1. Let _lbool_ be ToBoolean(_lval_).\n  1. If _lbool_ is *false*, return _lval_.\n  1. Let _rref_ be ? the result of evaluating |BitwiseORExpression|.\n  1. Return ? GetValue(_rref_).","code":"\n        1. Let _lref_ be ? Evaluation of |LogicalANDExpression|.\n        1. Let _lval_ be ? GetValue(_lref_).\n        1. Let _lbool_ be ToBoolean(_lval_).\n        1. If _lbool_ is *false*, return _lval_.\n        1. Let _rref_ be ? Evaluation of |BitwiseORExpression|.\n        1. Return ? GetValue(_rref_).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LogicalORExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"LogicalORExpression","ty":"Ast[LogicalORExpression]","kind":{"Normal":{}}},{"name":"LogicalANDExpression","ty":"Ast[LogicalANDExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _lref_ be ? the result of evaluating |LogicalORExpression|.\n  1. Let _lval_ be ? GetValue(_lref_).\n  1. Let _lbool_ be ToBoolean(_lval_).\n  1. If _lbool_ is *true*, return _lval_.\n  1. Let _rref_ be ? the result of evaluating |LogicalANDExpression|.\n  1. Return ? GetValue(_rref_).","code":"\n        1. Let _lref_ be ? Evaluation of |LogicalORExpression|.\n        1. Let _lval_ be ? GetValue(_lref_).\n        1. Let _lbool_ be ToBoolean(_lval_).\n        1. If _lbool_ is *true*, return _lval_.\n        1. Let _rref_ be ? Evaluation of |LogicalANDExpression|.\n        1. Return ? GetValue(_rref_).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CoalesceExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"CoalesceExpressionHead","ty":"Ast[CoalesceExpressionHead]","kind":{"Normal":{}}},{"name":"BitwiseORExpression","ty":"Ast[BitwiseORExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _lref_ be ? the result of evaluating |CoalesceExpressionHead|.\n  1. Let _lval_ be ? GetValue(_lref_).\n  1. If _lval_ is either *undefined* or *null*, then\n    1. Let _rref_ be ? the result of evaluating |BitwiseORExpression|.\n    1. Return ? GetValue(_rref_).\n  1. Else,\n    1. Return _lval_.","code":"\n        1. Let _lref_ be ? Evaluation of |CoalesceExpressionHead|.\n        1. Let _lval_ be ? GetValue(_lref_).\n        1. If _lval_ is either *undefined* or *null*, then\n          1. Let _rref_ be ? Evaluation of |BitwiseORExpression|.\n          1. Return ? GetValue(_rref_).\n        1. Else,\n          1. Return _lval_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ConditionalExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"ShortCircuitExpression","ty":"Ast[ShortCircuitExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _lref_ be ? the result of evaluating |ShortCircuitExpression|.\n  1. Let _lval_ be ToBoolean(? GetValue(_lref_)).\n  1. If _lval_ is *true*, then\n    1. Let _trueRef_ be ? the result of evaluating the first |AssignmentExpression|.\n    1. Return ? GetValue(_trueRef_).\n  1. Else,\n    1. Let _falseRef_ be ? the result of evaluating the second |AssignmentExpression|.\n    1. Return ? GetValue(_falseRef_).","code":"\n        1. Let _lref_ be ? Evaluation of |ShortCircuitExpression|.\n        1. Let _lval_ be ToBoolean(? GetValue(_lref_)).\n        1. If _lval_ is *true*, then\n          1. Let _trueRef_ be ? Evaluation of the first |AssignmentExpression|.\n          1. Return ? GetValue(_trueRef_).\n        1. Else,\n          1. Let _falseRef_ be ? Evaluation of the second |AssignmentExpression|.\n          1. Return ? GetValue(_falseRef_).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. If |LeftHandSideExpression| is neither a Ast[ObjectLiteral] nor a Ast[ArrayLiteral], then\n    1. Let _lref_ be ? the result of evaluating |LeftHandSideExpression|.\n    1. If both IsAnonymousFunctionDefinition(|AssignmentExpression|) and IsIdentifierRef of |LeftHandSideExpression| are *true*, then\n      1. Let _rval_ be ? NamedEvaluation of |AssignmentExpression| with argument _lref_.[[ReferencedName]].\n    1. Else,\n      1. Let _rref_ be ? the result of evaluating |AssignmentExpression|.\n      1. Let _rval_ be ? GetValue(_rref_).\n    1. [id=\"step-assignmentexpression-evaluation-simple-putvalue\"] Perform ? PutValue(_lref_, _rval_).\n    1. Return _rval_.\n  1. Let _assignmentPattern_ be the |AssignmentPattern| that is covered by |LeftHandSideExpression|.\n  1. Let _rref_ be ? the result of evaluating |AssignmentExpression|.\n  1. Let _rval_ be ? GetValue(_rref_).\n  1. Perform ? DestructuringAssignmentEvaluation of _assignmentPattern_ with argument _rval_.\n  1. Return _rval_.","code":"\n        1. If |LeftHandSideExpression| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then\n          1. Let _lref_ be ? Evaluation of |LeftHandSideExpression|.\n          1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) and IsIdentifierRef of |LeftHandSideExpression| are both *true*, then\n            1. Let _rval_ be ? NamedEvaluation of |AssignmentExpression| with argument _lref_.[[ReferencedName]].\n          1. Else,\n            1. Let _rref_ be ? Evaluation of |AssignmentExpression|.\n            1. Let _rval_ be ? GetValue(_rref_).\n          1. [id=\"step-assignmentexpression-evaluation-simple-putvalue\"] Perform ? PutValue(_lref_, _rval_).\n          1. Return _rval_.\n        1. Let _assignmentPattern_ be the |AssignmentPattern| that is covered by |LeftHandSideExpression|.\n        1. Let _rref_ be ? Evaluation of |AssignmentExpression|.\n        1. Let _rval_ be ? GetValue(_rref_).\n        1. Perform ? DestructuringAssignmentEvaluation of _assignmentPattern_ with argument _rval_.\n        1. Return _rval_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentExpression","idx":5,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentOperator","ty":"Ast[AssignmentOperator]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _lref_ be ? the result of evaluating |LeftHandSideExpression|.\n  1. [id=\"step-assignmentexpression-evaluation-compound-getvalue\"] Let _lval_ be ? GetValue(_lref_).\n  1. Let _rref_ be ? the result of evaluating |AssignmentExpression|.\n  1. Let _rval_ be ? GetValue(_rref_).\n  1. Let _assignmentOpText_ be the source text matched by |AssignmentOperator|.\n  1. Let _opText_ be the sequence of Unicode code points associated with _assignmentOpText_ in the following table:\n    <figure>\n      <!-- emu-format ignore -->\n      <table class=\"lightweight-table\">\n      <tbody><tr><th> _assignmentOpText_ </th><th> _opText_       </th></tr>\n      <tr><td> `**=`              </td><td> `**`           </td></tr>\n      <tr><td> `*=`               </td><td> `*`            </td></tr>\n      <tr><td> `/=`               </td><td> `/`            </td></tr>\n      <tr><td> `%=`               </td><td> `%`            </td></tr>\n      <tr><td> `+=`               </td><td> `+`            </td></tr>\n      <tr><td> `-=`               </td><td> `-`            </td></tr>\n      <tr><td> `<<=`        </td><td> `<<`     </td></tr>\n      <tr><td> `>>=`        </td><td> `>>`     </td></tr>\n      <tr><td> `>>>=`    </td><td> `>>>` </td></tr>\n      <tr><td> `&=`           </td><td> `&`        </td></tr>\n      <tr><td> `^=`               </td><td> `^`            </td></tr>\n      <tr><td> `|=`               </td><td> `|`            </td></tr>\n      </tbody></table>\n    </figure>\n  1. Let _r_ be ? ApplyStringOrNumericBinaryOperator(_lval_, _opText_, _rval_).\n  1. [id=\"step-assignmentexpression-evaluation-compound-putvalue\"] Perform ? PutValue(_lref_, _r_).\n  1. Return _r_.","code":"\n        1. Let _lref_ be ? Evaluation of |LeftHandSideExpression|.\n        1. [id=\"step-assignmentexpression-evaluation-compound-getvalue\"] Let _lval_ be ? GetValue(_lref_).\n        1. Let _rref_ be ? Evaluation of |AssignmentExpression|.\n        1. Let _rval_ be ? GetValue(_rref_).\n        1. Let _assignmentOpText_ be the source text matched by |AssignmentOperator|.\n        1. Let _opText_ be the sequence of Unicode code points associated with _assignmentOpText_ in the following table:\n          <figure>\n            <!-- emu-format ignore -->\n            <table class=\"lightweight-table\">\n              <tbody><tr><th> _assignmentOpText_ </th><th> _opText_       </th></tr>\n              <tr><td> `**=`              </td><td> `**`           </td></tr>\n              <tr><td> `*=`               </td><td> `*`            </td></tr>\n              <tr><td> `/=`               </td><td> `/`            </td></tr>\n              <tr><td> `%=`               </td><td> `%`            </td></tr>\n              <tr><td> `+=`               </td><td> `+`            </td></tr>\n              <tr><td> `-=`               </td><td> `-`            </td></tr>\n              <tr><td> `<<=`        </td><td> `<<`     </td></tr>\n              <tr><td> `>>=`        </td><td> `>>`     </td></tr>\n              <tr><td> `>>>=`    </td><td> `>>>` </td></tr>\n              <tr><td> `&=`           </td><td> `&`        </td></tr>\n              <tr><td> `^=`               </td><td> `^`            </td></tr>\n              <tr><td> `|=`               </td><td> `|`            </td></tr>\n            </tbody></table>\n          </figure>\n        1. Let _r_ be ? ApplyStringOrNumericBinaryOperator(_lval_, _opText_, _rval_).\n        1. [id=\"step-assignmentexpression-evaluation-compound-putvalue\"] Perform ? PutValue(_lref_, _r_).\n        1. Return _r_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentExpression","idx":6,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _lref_ be ? the result of evaluating |LeftHandSideExpression|.\n  1. [id=\"step-assignmentexpression-evaluation-lgcl-and-getvalue\"] Let _lval_ be ? GetValue(_lref_).\n  1. Let _lbool_ be ToBoolean(_lval_).\n  1. If _lbool_ is *false*, return _lval_.\n  1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true* and IsIdentifierRef of |LeftHandSideExpression| is *true*, then\n    1. Let _rval_ be ? NamedEvaluation of |AssignmentExpression| with argument _lref_.[[ReferencedName]].\n  1. Else,\n    1. Let _rref_ be ? the result of evaluating |AssignmentExpression|.\n    1. Let _rval_ be ? GetValue(_rref_).\n  1. [id=\"step-assignmentexpression-evaluation-lgcl-and-putvalue\"] Perform ? PutValue(_lref_, _rval_).\n  1. Return _rval_.","code":"\n        1. Let _lref_ be ? Evaluation of |LeftHandSideExpression|.\n        1. [id=\"step-assignmentexpression-evaluation-lgcl-and-getvalue\"] Let _lval_ be ? GetValue(_lref_).\n        1. Let _lbool_ be ToBoolean(_lval_).\n        1. If _lbool_ is *false*, return _lval_.\n        1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true* and IsIdentifierRef of |LeftHandSideExpression| is *true*, then\n          1. Let _rval_ be ? NamedEvaluation of |AssignmentExpression| with argument _lref_.[[ReferencedName]].\n        1. Else,\n          1. Let _rref_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _rval_ be ? GetValue(_rref_).\n        1. [id=\"step-assignmentexpression-evaluation-lgcl-and-putvalue\"] Perform ? PutValue(_lref_, _rval_).\n        1. Return _rval_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentExpression","idx":7,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _lref_ be ? the result of evaluating |LeftHandSideExpression|.\n  1. [id=\"step-assignmentexpression-evaluation-lgcl-or-getvalue\"] Let _lval_ be ? GetValue(_lref_).\n  1. Let _lbool_ be ToBoolean(_lval_).\n  1. If _lbool_ is *true*, return _lval_.\n  1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true* and IsIdentifierRef of |LeftHandSideExpression| is *true*, then\n    1. Let _rval_ be ? NamedEvaluation of |AssignmentExpression| with argument _lref_.[[ReferencedName]].\n  1. Else,\n    1. Let _rref_ be ? the result of evaluating |AssignmentExpression|.\n    1. Let _rval_ be ? GetValue(_rref_).\n  1. [id=\"step-assignmentexpression-evaluation-lgcl-or-putvalue\"] Perform ? PutValue(_lref_, _rval_).\n  1. Return _rval_.","code":"\n        1. Let _lref_ be ? Evaluation of |LeftHandSideExpression|.\n        1. [id=\"step-assignmentexpression-evaluation-lgcl-or-getvalue\"] Let _lval_ be ? GetValue(_lref_).\n        1. Let _lbool_ be ToBoolean(_lval_).\n        1. If _lbool_ is *true*, return _lval_.\n        1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true* and IsIdentifierRef of |LeftHandSideExpression| is *true*, then\n          1. Let _rval_ be ? NamedEvaluation of |AssignmentExpression| with argument _lref_.[[ReferencedName]].\n        1. Else,\n          1. Let _rref_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _rval_ be ? GetValue(_rref_).\n        1. [id=\"step-assignmentexpression-evaluation-lgcl-or-putvalue\"] Perform ? PutValue(_lref_, _rval_).\n        1. Return _rval_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentExpression","idx":8,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _lref_ be ? the result of evaluating |LeftHandSideExpression|.\n  1. [id=\"step-assignmentexpression-evaluation-lgcl-nullish-getvalue\"] Let _lval_ be ? GetValue(_lref_).\n  1. If _lval_ is neither *undefined* nor *null*, return _lval_.\n  1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true* and IsIdentifierRef of |LeftHandSideExpression| is *true*, then\n    1. Let _rval_ be ? NamedEvaluation of |AssignmentExpression| with argument _lref_.[[ReferencedName]].\n  1. Else,\n    1. Let _rref_ be ? the result of evaluating |AssignmentExpression|.\n    1. Let _rval_ be ? GetValue(_rref_).\n  1. [id=\"step-assignmentexpression-evaluation-lgcl-nullish-putvalue\"] Perform ? PutValue(_lref_, _rval_).\n  1. Return _rval_.","code":"\n        1. Let _lref_ be ? Evaluation of |LeftHandSideExpression|.\n        1. [id=\"step-assignmentexpression-evaluation-lgcl-nullish-getvalue\"] Let _lval_ be ? GetValue(_lref_).\n        1. If _lval_ is neither *undefined* nor *null*, return _lval_.\n        1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true* and IsIdentifierRef of |LeftHandSideExpression| is *true*, then\n          1. Let _rval_ be ? NamedEvaluation of |AssignmentExpression| with argument _lref_.[[ReferencedName]].\n        1. Else,\n          1. Let _rref_ be ? Evaluation of |AssignmentExpression|.\n          1. Let _rval_ be ? GetValue(_rref_).\n        1. [id=\"step-assignmentexpression-evaluation-lgcl-nullish-putvalue\"] Perform ? PutValue(_lref_, _rval_).\n        1. Return _rval_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ApplyStringOrNumericBinaryOperator","params":[{"name":"lval","ty":"ESValue","kind":{"Normal":{}}},{"name":"opText","ty":"Unknown[\"`**`, `*`, `/`, `%`, `+`, `-`, `<<`, `>>`, `>>>`, `&`, `^`, or `|`\"]","kind":{"Normal":{}}},{"name":"rval","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Number | BigInt | String] | Throw"}},"body":"\n  1. If _opText_ is `+`, then\n    1. [id=\"step-binary-op-toprimitive-lval\"] Let _lprim_ be ? ToPrimitive(_lval_).\n    1. [id=\"step-binary-op-toprimitive-rval\"] Let _rprim_ be ? ToPrimitive(_rval_).\n    1. [id=\"step-binary-op-string-check\"] If _lprim_ is a String or _rprim_ is a String, then\n      1. Let _lstr_ be ? ToString(_lprim_).\n      1. Let _rstr_ be ? ToString(_rprim_).\n      1. Return the string-concatenation of _lstr_ and _rstr_.\n    1. Set _lval_ to _lprim_.\n    1. Set _rval_ to _rprim_.\n  1. NOTE: At this point, it must be a numeric operation.\n  1. Let _lnum_ be ? ToNumeric(_lval_).\n  1. Let _rnum_ be ? ToNumeric(_rval_).\n  1. If Type(_lnum_) is not Type(_rnum_), throw a *TypeError* exception.\n  1. If _lnum_ is a BigInt, then\n    1. If _opText_ is `**`, return ? BigInt::exponentiate(_lnum_, _rnum_).\n    1. If _opText_ is `/`, return ? BigInt::divide(_lnum_, _rnum_).\n    1. If _opText_ is `%`, return ? BigInt::remainder(_lnum_, _rnum_).\n    1. If _opText_ is `>>>`, return ? BigInt::unsignedRightShift(_lnum_, _rnum_).\n  1. Let _operation_ be the abstract operation associated with _opText_ and Type(_lnum_) in the following table:\n    <figure>\n      <!-- emu-format ignore -->\n      <table class=\"lightweight-table\">\n      <tbody><tr><th> _opText_       </th><th> Type(_lnum_) </th><th> _operation_                </th></tr>\n      <tr><td> `**`           </td><td> Number       </td><td> Number::exponentiate       </td></tr>\n      <tr><td> `*`            </td><td> Number       </td><td> Number::multiply           </td></tr>\n      <tr><td> `*`            </td><td> BigInt       </td><td> BigInt::multiply           </td></tr>\n      <tr><td> `/`            </td><td> Number       </td><td> Number::divide             </td></tr>\n      <tr><td> `%`            </td><td> Number       </td><td> Number::remainder          </td></tr>\n      <tr><td> `+`            </td><td> Number       </td><td> Number::add                </td></tr>\n      <tr><td> `+`            </td><td> BigInt       </td><td> BigInt::add                </td></tr>\n      <tr><td> `-`            </td><td> Number       </td><td> Number::subtract           </td></tr>\n      <tr><td> `-`            </td><td> BigInt       </td><td> BigInt::subtract           </td></tr>\n      <tr><td> `<<`     </td><td> Number       </td><td> Number::leftShift          </td></tr>\n      <tr><td> `<<`     </td><td> BigInt       </td><td> BigInt::leftShift          </td></tr>\n      <tr><td> `>>`     </td><td> Number       </td><td> Number::signedRightShift   </td></tr>\n      <tr><td> `>>`     </td><td> BigInt       </td><td> BigInt::signedRightShift   </td></tr>\n      <tr><td> `>>>` </td><td> Number       </td><td> Number::unsignedRightShift </td></tr>\n      <tr><td> `&`        </td><td> Number       </td><td> Number::bitwiseAND         </td></tr>\n      <tr><td> `&`        </td><td> BigInt       </td><td> BigInt::bitwiseAND         </td></tr>\n      <tr><td> `^`            </td><td> Number       </td><td> Number::bitwiseXOR         </td></tr>\n      <tr><td> `^`            </td><td> BigInt       </td><td> BigInt::bitwiseXOR         </td></tr>\n      <tr><td> `|`            </td><td> Number       </td><td> Number::bitwiseOR          </td></tr>\n      <tr><td> `|`            </td><td> BigInt       </td><td> BigInt::bitwiseOR          </td></tr>\n      </tbody></table>\n    </figure>\n  1. Return _operation_(_lnum_, _rnum_).","code":"\n        1. If _opText_ is `+`, then\n          1. [id=\"step-binary-op-toprimitive-lval\"] Let _lprim_ be ? ToPrimitive(_lval_).\n          1. [id=\"step-binary-op-toprimitive-rval\"] Let _rprim_ be ? ToPrimitive(_rval_).\n          1. [id=\"step-binary-op-string-check\"] If _lprim_ is a String or _rprim_ is a String, then\n            1. Let _lstr_ be ? ToString(_lprim_).\n            1. Let _rstr_ be ? ToString(_rprim_).\n            1. Return the string-concatenation of _lstr_ and _rstr_.\n          1. Set _lval_ to _lprim_.\n          1. Set _rval_ to _rprim_.\n        1. NOTE: At this point, it must be a numeric operation.\n        1. Let _lnum_ be ? ToNumeric(_lval_).\n        1. Let _rnum_ be ? ToNumeric(_rval_).\n        1. If Type(_lnum_) is not Type(_rnum_), throw a *TypeError* exception.\n        1. If _lnum_ is a BigInt, then\n          1. If _opText_ is `**`, return ? BigInt::exponentiate(_lnum_, _rnum_).\n          1. If _opText_ is `/`, return ? BigInt::divide(_lnum_, _rnum_).\n          1. If _opText_ is `%`, return ? BigInt::remainder(_lnum_, _rnum_).\n          1. If _opText_ is `>>>`, return ? BigInt::unsignedRightShift(_lnum_, _rnum_).\n        1. Let _operation_ be the abstract operation associated with _opText_ and Type(_lnum_) in the following table:\n          <figure>\n            <!-- emu-format ignore -->\n            <table class=\"lightweight-table\">\n              <tbody><tr><th> _opText_       </th><th> Type(_lnum_) </th><th> _operation_                </th></tr>\n              <tr><td> `**`           </td><td> Number       </td><td> Number::exponentiate       </td></tr>\n              <tr><td> `*`            </td><td> Number       </td><td> Number::multiply           </td></tr>\n              <tr><td> `*`            </td><td> BigInt       </td><td> BigInt::multiply           </td></tr>\n              <tr><td> `/`            </td><td> Number       </td><td> Number::divide             </td></tr>\n              <tr><td> `%`            </td><td> Number       </td><td> Number::remainder          </td></tr>\n              <tr><td> `+`            </td><td> Number       </td><td> Number::add                </td></tr>\n              <tr><td> `+`            </td><td> BigInt       </td><td> BigInt::add                </td></tr>\n              <tr><td> `-`            </td><td> Number       </td><td> Number::subtract           </td></tr>\n              <tr><td> `-`            </td><td> BigInt       </td><td> BigInt::subtract           </td></tr>\n              <tr><td> `<<`     </td><td> Number       </td><td> Number::leftShift          </td></tr>\n              <tr><td> `<<`     </td><td> BigInt       </td><td> BigInt::leftShift          </td></tr>\n              <tr><td> `>>`     </td><td> Number       </td><td> Number::signedRightShift   </td></tr>\n              <tr><td> `>>`     </td><td> BigInt       </td><td> BigInt::signedRightShift   </td></tr>\n              <tr><td> `>>>` </td><td> Number       </td><td> Number::unsignedRightShift </td></tr>\n              <tr><td> `&`        </td><td> Number       </td><td> Number::bitwiseAND         </td></tr>\n              <tr><td> `&`        </td><td> BigInt       </td><td> BigInt::bitwiseAND         </td></tr>\n              <tr><td> `^`            </td><td> Number       </td><td> Number::bitwiseXOR         </td></tr>\n              <tr><td> `^`            </td><td> BigInt       </td><td> BigInt::bitwiseXOR         </td></tr>\n              <tr><td> `|`            </td><td> Number       </td><td> Number::bitwiseOR          </td></tr>\n              <tr><td> `|`            </td><td> BigInt       </td><td> BigInt::bitwiseOR          </td></tr>\n            </tbody></table>\n          </figure>\n        1. Return _operation_(_lnum_, _rnum_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"EvaluateStringOrNumericBinaryExpression","params":[{"name":"leftOperand","ty":"Ast","kind":{"Normal":{}}},{"name":"opText","ty":"Unknown[\"a sequence of Unicode code points\"]","kind":{"Normal":{}}},{"name":"rightOperand","ty":"Ast","kind":{"Normal":{}}}],"retTy":"Normal[Number | BigInt | String] | Abrupt"}},"body":"\n  1. Let _lref_ be ? the result of evaluating _leftOperand_.\n  1. Let _lval_ be ? GetValue(_lref_).\n  1. Let _rref_ be ? the result of evaluating _rightOperand_.\n  1. Let _rval_ be ? GetValue(_rref_).\n  1. Return ? ApplyStringOrNumericBinaryOperator(_lval_, _opText_, _rval_).","code":"\n        1. Let _lref_ be ? Evaluation of _leftOperand_.\n        1. Let _lval_ be ? GetValue(_lref_).\n        1. Let _rref_ be ? Evaluation of _rightOperand_.\n        1. Let _rval_ be ? GetValue(_rref_).\n        1. Return ? ApplyStringOrNumericBinaryOperator(_lval_, _opText_, _rval_).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ObjectAssignmentPattern","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"DestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Perform ? RequireObjectCoercible(_value_).\n  1. Return ~unused~.","code":"\n          1. Perform ? RequireObjectCoercible(_value_).\n          1. Return ~unused~.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ObjectAssignmentPattern","idx":2,"subIdx":0,"rhsParams":[{"name":"AssignmentPropertyList","ty":"Ast[AssignmentPropertyList]","kind":{"Normal":{}}}]},"methodName":"DestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Perform ? RequireObjectCoercible(_value_).\n  1. Perform ? PropertyDestructuringAssignmentEvaluation of |AssignmentPropertyList| with argument _value_.\n  1. Return ~unused~.","code":"\n          1. Perform ? RequireObjectCoercible(_value_).\n          1. Perform ? PropertyDestructuringAssignmentEvaluation of |AssignmentPropertyList| with argument _value_.\n          1. Return ~unused~.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ObjectAssignmentPattern","idx":3,"subIdx":0,"rhsParams":[{"name":"AssignmentPropertyList","ty":"Ast[AssignmentPropertyList]","kind":{"Normal":{}}}]},"methodName":"DestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Perform ? RequireObjectCoercible(_value_).\n  1. Perform ? PropertyDestructuringAssignmentEvaluation of |AssignmentPropertyList| with argument _value_.\n  1. Return ~unused~.","code":"\n          1. Perform ? RequireObjectCoercible(_value_).\n          1. Perform ? PropertyDestructuringAssignmentEvaluation of |AssignmentPropertyList| with argument _value_.\n          1. Return ~unused~.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ObjectAssignmentPattern","idx":1,"subIdx":0,"rhsParams":[{"name":"AssignmentRestProperty","ty":"Ast[AssignmentRestProperty]","kind":{"Normal":{}}}]},"methodName":"DestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Perform ? RequireObjectCoercible(_value_).\n  1. Let _excludedNames_ be « ».\n  1. Return ? RestDestructuringAssignmentEvaluation of |AssignmentRestProperty| with arguments _value_ and _excludedNames_.","code":"\n          1. Perform ? RequireObjectCoercible(_value_).\n          1. Let _excludedNames_ be a new empty List.\n          1. Return ? RestDestructuringAssignmentEvaluation of |AssignmentRestProperty| with arguments _value_ and _excludedNames_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ObjectAssignmentPattern","idx":3,"subIdx":1,"rhsParams":[{"name":"AssignmentPropertyList","ty":"Ast[AssignmentPropertyList]","kind":{"Normal":{}}},{"name":"AssignmentRestProperty","ty":"Ast[AssignmentRestProperty]","kind":{"Normal":{}}}]},"methodName":"DestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Perform ? RequireObjectCoercible(_value_).\n  1. Let _excludedNames_ be ? PropertyDestructuringAssignmentEvaluation of |AssignmentPropertyList| with argument _value_.\n  1. Return ? RestDestructuringAssignmentEvaluation of |AssignmentRestProperty| with arguments _value_ and _excludedNames_.","code":"\n          1. Perform ? RequireObjectCoercible(_value_).\n          1. Let _excludedNames_ be ? PropertyDestructuringAssignmentEvaluation of |AssignmentPropertyList| with argument _value_.\n          1. Return ? RestDestructuringAssignmentEvaluation of |AssignmentRestProperty| with arguments _value_ and _excludedNames_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayAssignmentPattern","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"DestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n  1. Return ? IteratorClose(_iteratorRecord_, NormalCompletion(~unused~)).","code":"\n          1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n          1. Return ? IteratorClose(_iteratorRecord_, NormalCompletion(~unused~)).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayAssignmentPattern","idx":0,"subIdx":2,"rhsParams":[{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}}]},"methodName":"DestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n  1. Let _result_ be Completion(IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_).\n  1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _result_).\n  1. Return _result_.","code":"\n          1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n          1. Let _result_ be Completion(IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_).\n          1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _result_).\n          1. Return _result_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayAssignmentPattern","idx":0,"subIdx":1,"rhsParams":[{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"AssignmentRestElement","ty":"Ast[AssignmentRestElement]","kind":{"Normal":{}}}]},"methodName":"DestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n  1. If |Elision| is present, then\n    1. Let _status_ be Completion(IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_).\n    1. If _status_ is an abrupt completion, then\n      1. Assert: _iteratorRecord_.[[Done]] is *true*.\n      1. Return ? _status_.\n  1. Let _result_ be Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentRestElement| with argument _iteratorRecord_).\n  1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _result_).\n  1. Return _result_.","code":"\n          1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n          1. If |Elision| is present, then\n            1. Let _status_ be Completion(IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_).\n            1. If _status_ is an abrupt completion, then\n              1. Assert: _iteratorRecord_.[[Done]] is *true*.\n              1. Return ? _status_.\n          1. Let _result_ be Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentRestElement| with argument _iteratorRecord_).\n          1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _result_).\n          1. Return _result_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayAssignmentPattern","idx":0,"subIdx":3,"rhsParams":[{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"AssignmentRestElement","ty":"Ast[AssignmentRestElement]","kind":{"Normal":{}}}]},"methodName":"DestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n  1. If |Elision| is present, then\n    1. Let _status_ be Completion(IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_).\n    1. If _status_ is an abrupt completion, then\n      1. Assert: _iteratorRecord_.[[Done]] is *true*.\n      1. Return ? _status_.\n  1. Let _result_ be Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentRestElement| with argument _iteratorRecord_).\n  1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _result_).\n  1. Return _result_.","code":"\n          1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n          1. If |Elision| is present, then\n            1. Let _status_ be Completion(IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_).\n            1. If _status_ is an abrupt completion, then\n              1. Assert: _iteratorRecord_.[[Done]] is *true*.\n              1. Return ? _status_.\n          1. Let _result_ be Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentRestElement| with argument _iteratorRecord_).\n          1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _result_).\n          1. Return _result_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayAssignmentPattern","idx":1,"subIdx":0,"rhsParams":[{"name":"AssignmentElementList","ty":"Ast[AssignmentElementList]","kind":{"Normal":{}}}]},"methodName":"DestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n  1. Let _result_ be Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentElementList| with argument _iteratorRecord_).\n  1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _result_).\n  1. Return _result_.","code":"\n          1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n          1. Let _result_ be Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentElementList| with argument _iteratorRecord_).\n          1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _result_).\n          1. Return _result_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayAssignmentPattern","idx":2,"subIdx":0,"rhsParams":[{"name":"AssignmentElementList","ty":"Ast[AssignmentElementList]","kind":{"Normal":{}}},{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"AssignmentRestElement","ty":"Ast[AssignmentRestElement]","kind":{"Normal":{}}}]},"methodName":"DestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n  1. Let _status_ be Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentElementList| with argument _iteratorRecord_).\n  1. If _status_ is an abrupt completion, then\n    1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).\n    1. Return ? _status_.\n  1. If |Elision| is present, then\n    1. Set _status_ to Completion(IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_).\n    1. If _status_ is an abrupt completion, then\n      1. Assert: _iteratorRecord_.[[Done]] is *true*.\n      1. Return ? _status_.\n  1. If |AssignmentRestElement| is present, then\n    1. Set _status_ to Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentRestElement| with argument _iteratorRecord_).\n  1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).\n  1. Return ? _status_.","code":"\n          1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n          1. Let _status_ be Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentElementList| with argument _iteratorRecord_).\n          1. If _status_ is an abrupt completion, then\n            1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).\n            1. Return ? _status_.\n          1. If |Elision| is present, then\n            1. Set _status_ to Completion(IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_).\n            1. If _status_ is an abrupt completion, then\n              1. Assert: _iteratorRecord_.[[Done]] is *true*.\n              1. Return ? _status_.\n          1. If |AssignmentRestElement| is present, then\n            1. Set _status_ to Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentRestElement| with argument _iteratorRecord_).\n          1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).\n          1. Return ? _status_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayAssignmentPattern","idx":2,"subIdx":1,"rhsParams":[{"name":"AssignmentElementList","ty":"Ast[AssignmentElementList]","kind":{"Normal":{}}},{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"AssignmentRestElement","ty":"Ast[AssignmentRestElement]","kind":{"Normal":{}}}]},"methodName":"DestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n  1. Let _status_ be Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentElementList| with argument _iteratorRecord_).\n  1. If _status_ is an abrupt completion, then\n    1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).\n    1. Return ? _status_.\n  1. If |Elision| is present, then\n    1. Set _status_ to Completion(IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_).\n    1. If _status_ is an abrupt completion, then\n      1. Assert: _iteratorRecord_.[[Done]] is *true*.\n      1. Return ? _status_.\n  1. If |AssignmentRestElement| is present, then\n    1. Set _status_ to Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentRestElement| with argument _iteratorRecord_).\n  1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).\n  1. Return ? _status_.","code":"\n          1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n          1. Let _status_ be Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentElementList| with argument _iteratorRecord_).\n          1. If _status_ is an abrupt completion, then\n            1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).\n            1. Return ? _status_.\n          1. If |Elision| is present, then\n            1. Set _status_ to Completion(IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_).\n            1. If _status_ is an abrupt completion, then\n              1. Assert: _iteratorRecord_.[[Done]] is *true*.\n              1. Return ? _status_.\n          1. If |AssignmentRestElement| is present, then\n            1. Set _status_ to Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentRestElement| with argument _iteratorRecord_).\n          1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).\n          1. Return ? _status_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayAssignmentPattern","idx":2,"subIdx":2,"rhsParams":[{"name":"AssignmentElementList","ty":"Ast[AssignmentElementList]","kind":{"Normal":{}}},{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"AssignmentRestElement","ty":"Ast[AssignmentRestElement]","kind":{"Normal":{}}}]},"methodName":"DestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n  1. Let _status_ be Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentElementList| with argument _iteratorRecord_).\n  1. If _status_ is an abrupt completion, then\n    1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).\n    1. Return ? _status_.\n  1. If |Elision| is present, then\n    1. Set _status_ to Completion(IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_).\n    1. If _status_ is an abrupt completion, then\n      1. Assert: _iteratorRecord_.[[Done]] is *true*.\n      1. Return ? _status_.\n  1. If |AssignmentRestElement| is present, then\n    1. Set _status_ to Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentRestElement| with argument _iteratorRecord_).\n  1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).\n  1. Return ? _status_.","code":"\n          1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n          1. Let _status_ be Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentElementList| with argument _iteratorRecord_).\n          1. If _status_ is an abrupt completion, then\n            1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).\n            1. Return ? _status_.\n          1. If |Elision| is present, then\n            1. Set _status_ to Completion(IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_).\n            1. If _status_ is an abrupt completion, then\n              1. Assert: _iteratorRecord_.[[Done]] is *true*.\n              1. Return ? _status_.\n          1. If |AssignmentRestElement| is present, then\n            1. Set _status_ to Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentRestElement| with argument _iteratorRecord_).\n          1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).\n          1. Return ? _status_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayAssignmentPattern","idx":2,"subIdx":3,"rhsParams":[{"name":"AssignmentElementList","ty":"Ast[AssignmentElementList]","kind":{"Normal":{}}},{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"AssignmentRestElement","ty":"Ast[AssignmentRestElement]","kind":{"Normal":{}}}]},"methodName":"DestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n  1. Let _status_ be Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentElementList| with argument _iteratorRecord_).\n  1. If _status_ is an abrupt completion, then\n    1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).\n    1. Return ? _status_.\n  1. If |Elision| is present, then\n    1. Set _status_ to Completion(IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_).\n    1. If _status_ is an abrupt completion, then\n      1. Assert: _iteratorRecord_.[[Done]] is *true*.\n      1. Return ? _status_.\n  1. If |AssignmentRestElement| is present, then\n    1. Set _status_ to Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentRestElement| with argument _iteratorRecord_).\n  1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).\n  1. Return ? _status_.","code":"\n          1. Let _iteratorRecord_ be ? GetIterator(_value_, ~sync~).\n          1. Let _status_ be Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentElementList| with argument _iteratorRecord_).\n          1. If _status_ is an abrupt completion, then\n            1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).\n            1. Return ? _status_.\n          1. If |Elision| is present, then\n            1. Set _status_ to Completion(IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_).\n            1. If _status_ is an abrupt completion, then\n              1. Assert: _iteratorRecord_.[[Done]] is *true*.\n              1. Return ? _status_.\n          1. If |AssignmentRestElement| is present, then\n            1. Set _status_ to Completion(IteratorDestructuringAssignmentEvaluation of |AssignmentRestElement| with argument _iteratorRecord_).\n          1. If _iteratorRecord_.[[Done]] is *false*, return ? IteratorClose(_iteratorRecord_, _status_).\n          1. Return ? _status_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentPropertyList","idx":1,"subIdx":0,"rhsParams":[{"name":"AssignmentPropertyList","ty":"Ast[AssignmentPropertyList]","kind":{"Normal":{}}},{"name":"AssignmentProperty","ty":"Ast[AssignmentProperty]","kind":{"Normal":{}}}]},"methodName":"PropertyDestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[List[Record[Symbol] | String]] | Abrupt"}},"body":"\n  1. Let _propertyNames_ be ? PropertyDestructuringAssignmentEvaluation of |AssignmentPropertyList| with argument _value_.\n  1. Let _nextNames_ be ? PropertyDestructuringAssignmentEvaluation of |AssignmentProperty| with argument _value_.\n  1. Return the list-concatenation of _propertyNames_ and _nextNames_.","code":"\n          1. Let _propertyNames_ be ? PropertyDestructuringAssignmentEvaluation of |AssignmentPropertyList| with argument _value_.\n          1. Let _nextNames_ be ? PropertyDestructuringAssignmentEvaluation of |AssignmentProperty| with argument _value_.\n          1. Return the list-concatenation of _propertyNames_ and _nextNames_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentProperty","idx":0,"subIdx":0,"rhsParams":[{"name":"IdentifierReference","ty":"Ast[IdentifierReference]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"PropertyDestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[List[Record[Symbol] | String]] | Abrupt"}},"body":"\n  1. Let _P_ be StringValue of |IdentifierReference|.\n  1. Let _lref_ be ? ResolveBinding(_P_).\n  1. Let _v_ be ? GetV(_value_, _P_).\n  1. If |Initializer| is present and _v_ is *undefined*, then\n    1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then\n      1. Set _v_ to ? NamedEvaluation of |Initializer| with argument _P_.\n    1. Else,\n      1. Let _defaultValue_ be ? the result of evaluating |Initializer|.\n      1. Set _v_ to ? GetValue(_defaultValue_).\n  1. Perform ? PutValue(_lref_, _v_).\n  1. Return « _P_ ».","code":"\n          1. Let _P_ be StringValue of |IdentifierReference|.\n          1. Let _lref_ be ? ResolveBinding(_P_).\n          1. Let _v_ be ? GetV(_value_, _P_).\n          1. If |Initializer| is present and _v_ is *undefined*, then\n            1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then\n              1. Set _v_ to ? NamedEvaluation of |Initializer| with argument _P_.\n            1. Else,\n              1. Let _defaultValue_ be ? Evaluation of |Initializer|.\n              1. Set _v_ to ? GetValue(_defaultValue_).\n          1. Perform ? PutValue(_lref_, _v_).\n          1. Return « _P_ ».\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentProperty","idx":0,"subIdx":1,"rhsParams":[{"name":"IdentifierReference","ty":"Ast[IdentifierReference]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"PropertyDestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[List[Record[Symbol] | String]] | Abrupt"}},"body":"\n  1. Let _P_ be StringValue of |IdentifierReference|.\n  1. Let _lref_ be ? ResolveBinding(_P_).\n  1. Let _v_ be ? GetV(_value_, _P_).\n  1. If |Initializer| is present and _v_ is *undefined*, then\n    1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then\n      1. Set _v_ to ? NamedEvaluation of |Initializer| with argument _P_.\n    1. Else,\n      1. Let _defaultValue_ be ? the result of evaluating |Initializer|.\n      1. Set _v_ to ? GetValue(_defaultValue_).\n  1. Perform ? PutValue(_lref_, _v_).\n  1. Return « _P_ ».","code":"\n          1. Let _P_ be StringValue of |IdentifierReference|.\n          1. Let _lref_ be ? ResolveBinding(_P_).\n          1. Let _v_ be ? GetV(_value_, _P_).\n          1. If |Initializer| is present and _v_ is *undefined*, then\n            1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then\n              1. Set _v_ to ? NamedEvaluation of |Initializer| with argument _P_.\n            1. Else,\n              1. Let _defaultValue_ be ? Evaluation of |Initializer|.\n              1. Set _v_ to ? GetValue(_defaultValue_).\n          1. Perform ? PutValue(_lref_, _v_).\n          1. Return « _P_ ».\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentProperty","idx":1,"subIdx":0,"rhsParams":[{"name":"PropertyName","ty":"Ast[PropertyName]","kind":{"Normal":{}}},{"name":"AssignmentElement","ty":"Ast[AssignmentElement]","kind":{"Normal":{}}}]},"methodName":"PropertyDestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[List[Record[Symbol] | String]] | Abrupt"}},"body":"\n  1. Let _name_ be ? the result of evaluating |PropertyName|.\n  1. Perform ? KeyedDestructuringAssignmentEvaluation of |AssignmentElement| with arguments _value_ and _name_.\n  1. Return « _name_ ».","code":"\n          1. Let _name_ be ? Evaluation of |PropertyName|.\n          1. Perform ? KeyedDestructuringAssignmentEvaluation of |AssignmentElement| with arguments _value_ and _name_.\n          1. Return « _name_ ».\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentRestProperty","idx":0,"subIdx":0,"rhsParams":[{"name":"DestructuringAssignmentTarget","ty":"Ast[DestructuringAssignmentTarget]","kind":{"Normal":{}}}]},"methodName":"RestDestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}},{"name":"excludedNames","ty":"List[Record[Symbol] | String]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _lref_ be ? the result of evaluating |DestructuringAssignmentTarget|.\n  1. Let _restObj_ be OrdinaryObjectCreate(%Object.prototype%).\n  1. Perform ? CopyDataProperties(_restObj_, _value_, _excludedNames_).\n  1. Return ? PutValue(_lref_, _restObj_).","code":"\n          1. Let _lref_ be ? Evaluation of |DestructuringAssignmentTarget|.\n          1. Let _restObj_ be OrdinaryObjectCreate(%Object.prototype%).\n          1. Perform ? CopyDataProperties(_restObj_, _value_, _excludedNames_).\n          1. Return ? PutValue(_lref_, _restObj_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentElementList","idx":0,"subIdx":0,"rhsParams":[{"name":"AssignmentElisionElement","ty":"Ast[AssignmentElisionElement]","kind":{"Normal":{}}}]},"methodName":"IteratorDestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Return ? IteratorDestructuringAssignmentEvaluation of |AssignmentElisionElement| with argument _iteratorRecord_.","code":"\n          1. Return ? IteratorDestructuringAssignmentEvaluation of |AssignmentElisionElement| with argument _iteratorRecord_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentElementList","idx":1,"subIdx":0,"rhsParams":[{"name":"AssignmentElementList","ty":"Ast[AssignmentElementList]","kind":{"Normal":{}}},{"name":"AssignmentElisionElement","ty":"Ast[AssignmentElisionElement]","kind":{"Normal":{}}}]},"methodName":"IteratorDestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Perform ? IteratorDestructuringAssignmentEvaluation of |AssignmentElementList| with argument _iteratorRecord_.\n  1. Return ? IteratorDestructuringAssignmentEvaluation of |AssignmentElisionElement| with argument _iteratorRecord_.","code":"\n          1. Perform ? IteratorDestructuringAssignmentEvaluation of |AssignmentElementList| with argument _iteratorRecord_.\n          1. Return ? IteratorDestructuringAssignmentEvaluation of |AssignmentElisionElement| with argument _iteratorRecord_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentElisionElement","idx":0,"subIdx":0,"rhsParams":[{"name":"AssignmentElement","ty":"Ast[AssignmentElement]","kind":{"Normal":{}}}]},"methodName":"IteratorDestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Return ? IteratorDestructuringAssignmentEvaluation of |AssignmentElement| with argument _iteratorRecord_.","code":"\n          1. Return ? IteratorDestructuringAssignmentEvaluation of |AssignmentElement| with argument _iteratorRecord_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentElisionElement","idx":0,"subIdx":1,"rhsParams":[{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"AssignmentElement","ty":"Ast[AssignmentElement]","kind":{"Normal":{}}}]},"methodName":"IteratorDestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.\n  1. Return ? IteratorDestructuringAssignmentEvaluation of |AssignmentElement| with argument _iteratorRecord_.","code":"\n          1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.\n          1. Return ? IteratorDestructuringAssignmentEvaluation of |AssignmentElement| with argument _iteratorRecord_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Elision","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"IteratorDestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. If _iteratorRecord_.[[Done]] is *false*, then\n    1. Let _next_ be Completion(IteratorStep(_iteratorRecord_)).\n    1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.\n    1. Perform ReturnIfAbrupt(_next_).\n    1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.\n  1. Return ~unused~.","code":"\n          1. If _iteratorRecord_.[[Done]] is *false*, then\n            1. Let _next_ be Completion(IteratorStep(_iteratorRecord_)).\n            1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.\n            1. ReturnIfAbrupt(_next_).\n            1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.\n          1. Return ~unused~.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Elision","idx":1,"subIdx":0,"rhsParams":[{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}}]},"methodName":"IteratorDestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.\n  1. If _iteratorRecord_.[[Done]] is *false*, then\n    1. Let _next_ be Completion(IteratorStep(_iteratorRecord_)).\n    1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.\n    1. Perform ReturnIfAbrupt(_next_).\n    1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.\n  1. Return ~unused~.","code":"\n          1. Perform ? IteratorDestructuringAssignmentEvaluation of |Elision| with argument _iteratorRecord_.\n          1. If _iteratorRecord_.[[Done]] is *false*, then\n            1. Let _next_ be Completion(IteratorStep(_iteratorRecord_)).\n            1. If _next_ is an abrupt completion, set _iteratorRecord_.[[Done]] to *true*.\n            1. ReturnIfAbrupt(_next_).\n            1. If _next_ is *false*, set _iteratorRecord_.[[Done]] to *true*.\n          1. Return ~unused~.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentElement","idx":0,"subIdx":0,"rhsParams":[{"name":"DestructuringAssignmentTarget","ty":"Ast[DestructuringAssignmentTarget]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"IteratorDestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. If |DestructuringAssignmentTarget| is neither a Ast[ObjectLiteral] nor a Ast[ArrayLiteral], then\n    1. Let _lref_ be ? the result of evaluating |DestructuringAssignmentTarget|.\n  1. Let _value_ be *undefined*.\n  1. If _iteratorRecord_.[[Done]] is *false*, then\n    1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n    1. If _next_ is not ~done~, then\n      1. Set _value_ to _next_.\n  1. If |Initializer| is present and _value_ is *undefined*, then\n    1. If IsAnonymousFunctionDefinition(|Initializer|) is *true* and IsIdentifierRef of |DestructuringAssignmentTarget| is *true*, then\n      1. Let _v_ be ? NamedEvaluation of |Initializer| with argument _lref_.[[ReferencedName]].\n    1. Else,\n      1. Let _defaultValue_ be ? the result of evaluating |Initializer|.\n      1. Let _v_ be ? GetValue(_defaultValue_).\n  1. Else,\n    1. Let _v_ be _value_.\n  1. If |DestructuringAssignmentTarget| is a Ast[ArrayLiteral | ObjectLiteral], then\n    1. Let _nestedAssignmentPattern_ be the |AssignmentPattern| that is covered by |DestructuringAssignmentTarget|.\n    1. Return ? DestructuringAssignmentEvaluation of _nestedAssignmentPattern_ with argument _v_.\n  1. Return ? PutValue(_lref_, _v_).","code":"\n          1. If |DestructuringAssignmentTarget| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then\n            1. Let _lref_ be ? Evaluation of |DestructuringAssignmentTarget|.\n          1. Let _value_ be *undefined*.\n          1. If _iteratorRecord_.[[Done]] is *false*, then\n            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n            1. If _next_ is not ~done~, then\n              1. Set _value_ to _next_.\n          1. If |Initializer| is present and _value_ is *undefined*, then\n            1. If IsAnonymousFunctionDefinition(|Initializer|) is *true* and IsIdentifierRef of |DestructuringAssignmentTarget| is *true*, then\n              1. Let _v_ be ? NamedEvaluation of |Initializer| with argument _lref_.[[ReferencedName]].\n            1. Else,\n              1. Let _defaultValue_ be ? Evaluation of |Initializer|.\n              1. Let _v_ be ? GetValue(_defaultValue_).\n          1. Else,\n            1. Let _v_ be _value_.\n          1. If |DestructuringAssignmentTarget| is either an |ObjectLiteral| or an |ArrayLiteral|, then\n            1. Let _nestedAssignmentPattern_ be the |AssignmentPattern| that is covered by |DestructuringAssignmentTarget|.\n            1. Return ? DestructuringAssignmentEvaluation of _nestedAssignmentPattern_ with argument _v_.\n          1. Return ? PutValue(_lref_, _v_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentElement","idx":0,"subIdx":1,"rhsParams":[{"name":"DestructuringAssignmentTarget","ty":"Ast[DestructuringAssignmentTarget]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"IteratorDestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. If |DestructuringAssignmentTarget| is neither a Ast[ObjectLiteral] nor a Ast[ArrayLiteral], then\n    1. Let _lref_ be ? the result of evaluating |DestructuringAssignmentTarget|.\n  1. Let _value_ be *undefined*.\n  1. If _iteratorRecord_.[[Done]] is *false*, then\n    1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n    1. If _next_ is not ~done~, then\n      1. Set _value_ to _next_.\n  1. If |Initializer| is present and _value_ is *undefined*, then\n    1. If IsAnonymousFunctionDefinition(|Initializer|) is *true* and IsIdentifierRef of |DestructuringAssignmentTarget| is *true*, then\n      1. Let _v_ be ? NamedEvaluation of |Initializer| with argument _lref_.[[ReferencedName]].\n    1. Else,\n      1. Let _defaultValue_ be ? the result of evaluating |Initializer|.\n      1. Let _v_ be ? GetValue(_defaultValue_).\n  1. Else,\n    1. Let _v_ be _value_.\n  1. If |DestructuringAssignmentTarget| is a Ast[ArrayLiteral | ObjectLiteral], then\n    1. Let _nestedAssignmentPattern_ be the |AssignmentPattern| that is covered by |DestructuringAssignmentTarget|.\n    1. Return ? DestructuringAssignmentEvaluation of _nestedAssignmentPattern_ with argument _v_.\n  1. Return ? PutValue(_lref_, _v_).","code":"\n          1. If |DestructuringAssignmentTarget| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then\n            1. Let _lref_ be ? Evaluation of |DestructuringAssignmentTarget|.\n          1. Let _value_ be *undefined*.\n          1. If _iteratorRecord_.[[Done]] is *false*, then\n            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n            1. If _next_ is not ~done~, then\n              1. Set _value_ to _next_.\n          1. If |Initializer| is present and _value_ is *undefined*, then\n            1. If IsAnonymousFunctionDefinition(|Initializer|) is *true* and IsIdentifierRef of |DestructuringAssignmentTarget| is *true*, then\n              1. Let _v_ be ? NamedEvaluation of |Initializer| with argument _lref_.[[ReferencedName]].\n            1. Else,\n              1. Let _defaultValue_ be ? Evaluation of |Initializer|.\n              1. Let _v_ be ? GetValue(_defaultValue_).\n          1. Else,\n            1. Let _v_ be _value_.\n          1. If |DestructuringAssignmentTarget| is either an |ObjectLiteral| or an |ArrayLiteral|, then\n            1. Let _nestedAssignmentPattern_ be the |AssignmentPattern| that is covered by |DestructuringAssignmentTarget|.\n            1. Return ? DestructuringAssignmentEvaluation of _nestedAssignmentPattern_ with argument _v_.\n          1. Return ? PutValue(_lref_, _v_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentRestElement","idx":0,"subIdx":0,"rhsParams":[{"name":"DestructuringAssignmentTarget","ty":"Ast[DestructuringAssignmentTarget]","kind":{"Normal":{}}}]},"methodName":"IteratorDestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. If |DestructuringAssignmentTarget| is neither a Ast[ObjectLiteral] nor a Ast[ArrayLiteral], then\n    1. Let _lref_ be ? the result of evaluating |DestructuringAssignmentTarget|.\n  1. Let _A_ be ! ArrayCreate(0).\n  1. Let _n_ be 0.\n  1. Repeat, while _iteratorRecord_.[[Done]] is *false*,\n    1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n    1. If _next_ is not ~done~, then\n      1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _next_).\n      1. Set _n_ to _n_ + 1.\n  1. If |DestructuringAssignmentTarget| is neither a Ast[ObjectLiteral] nor a Ast[ArrayLiteral], then\n    1. Return ? PutValue(_lref_, _A_).\n  1. Let _nestedAssignmentPattern_ be the |AssignmentPattern| that is covered by |DestructuringAssignmentTarget|.\n  1. Return ? DestructuringAssignmentEvaluation of _nestedAssignmentPattern_ with argument _A_.","code":"\n          1. If |DestructuringAssignmentTarget| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then\n            1. Let _lref_ be ? Evaluation of |DestructuringAssignmentTarget|.\n          1. Let _A_ be ! ArrayCreate(0).\n          1. Let _n_ be 0.\n          1. Repeat, while _iteratorRecord_.[[Done]] is *false*,\n            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n            1. If _next_ is not ~done~, then\n              1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _next_).\n              1. Set _n_ to _n_ + 1.\n          1. If |DestructuringAssignmentTarget| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then\n            1. Return ? PutValue(_lref_, _A_).\n          1. Let _nestedAssignmentPattern_ be the |AssignmentPattern| that is covered by |DestructuringAssignmentTarget|.\n          1. Return ? DestructuringAssignmentEvaluation of _nestedAssignmentPattern_ with argument _A_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentElement","idx":0,"subIdx":0,"rhsParams":[{"name":"DestructuringAssignmentTarget","ty":"Ast[DestructuringAssignmentTarget]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"KeyedDestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}},{"name":"propertyName","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. If |DestructuringAssignmentTarget| is neither a Ast[ObjectLiteral] nor a Ast[ArrayLiteral], then\n    1. Let _lref_ be ? the result of evaluating |DestructuringAssignmentTarget|.\n  1. Let _v_ be ? GetV(_value_, _propertyName_).\n  1. If |Initializer| is present and _v_ is *undefined*, then\n    1. If both IsAnonymousFunctionDefinition(|Initializer|) and IsIdentifierRef of |DestructuringAssignmentTarget| are *true*, then\n      1. Let _rhsValue_ be ? NamedEvaluation of |Initializer| with argument _lref_.[[ReferencedName]].\n    1. Else,\n      1. Let _defaultValue_ be ? the result of evaluating |Initializer|.\n      1. Let _rhsValue_ be ? GetValue(_defaultValue_).\n  1. Else,\n    1. Let _rhsValue_ be _v_.\n  1. If |DestructuringAssignmentTarget| is a Ast[ArrayLiteral | ObjectLiteral], then\n    1. Let _assignmentPattern_ be the |AssignmentPattern| that is covered by |DestructuringAssignmentTarget|.\n    1. Return ? DestructuringAssignmentEvaluation of _assignmentPattern_ with argument _rhsValue_.\n  1. Return ? PutValue(_lref_, _rhsValue_).","code":"\n          1. If |DestructuringAssignmentTarget| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then\n            1. Let _lref_ be ? Evaluation of |DestructuringAssignmentTarget|.\n          1. Let _v_ be ? GetV(_value_, _propertyName_).\n          1. If |Initializer| is present and _v_ is *undefined*, then\n            1. If IsAnonymousFunctionDefinition(|Initializer|) and IsIdentifierRef of |DestructuringAssignmentTarget| are both *true*, then\n              1. Let _rhsValue_ be ? NamedEvaluation of |Initializer| with argument _lref_.[[ReferencedName]].\n            1. Else,\n              1. Let _defaultValue_ be ? Evaluation of |Initializer|.\n              1. Let _rhsValue_ be ? GetValue(_defaultValue_).\n          1. Else,\n            1. Let _rhsValue_ be _v_.\n          1. If |DestructuringAssignmentTarget| is either an |ObjectLiteral| or an |ArrayLiteral|, then\n            1. Let _assignmentPattern_ be the |AssignmentPattern| that is covered by |DestructuringAssignmentTarget|.\n            1. Return ? DestructuringAssignmentEvaluation of _assignmentPattern_ with argument _rhsValue_.\n          1. Return ? PutValue(_lref_, _rhsValue_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentElement","idx":0,"subIdx":1,"rhsParams":[{"name":"DestructuringAssignmentTarget","ty":"Ast[DestructuringAssignmentTarget]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"KeyedDestructuringAssignmentEvaluation","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}},{"name":"propertyName","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. If |DestructuringAssignmentTarget| is neither a Ast[ObjectLiteral] nor a Ast[ArrayLiteral], then\n    1. Let _lref_ be ? the result of evaluating |DestructuringAssignmentTarget|.\n  1. Let _v_ be ? GetV(_value_, _propertyName_).\n  1. If |Initializer| is present and _v_ is *undefined*, then\n    1. If both IsAnonymousFunctionDefinition(|Initializer|) and IsIdentifierRef of |DestructuringAssignmentTarget| are *true*, then\n      1. Let _rhsValue_ be ? NamedEvaluation of |Initializer| with argument _lref_.[[ReferencedName]].\n    1. Else,\n      1. Let _defaultValue_ be ? the result of evaluating |Initializer|.\n      1. Let _rhsValue_ be ? GetValue(_defaultValue_).\n  1. Else,\n    1. Let _rhsValue_ be _v_.\n  1. If |DestructuringAssignmentTarget| is a Ast[ArrayLiteral | ObjectLiteral], then\n    1. Let _assignmentPattern_ be the |AssignmentPattern| that is covered by |DestructuringAssignmentTarget|.\n    1. Return ? DestructuringAssignmentEvaluation of _assignmentPattern_ with argument _rhsValue_.\n  1. Return ? PutValue(_lref_, _rhsValue_).","code":"\n          1. If |DestructuringAssignmentTarget| is neither an |ObjectLiteral| nor an |ArrayLiteral|, then\n            1. Let _lref_ be ? Evaluation of |DestructuringAssignmentTarget|.\n          1. Let _v_ be ? GetV(_value_, _propertyName_).\n          1. If |Initializer| is present and _v_ is *undefined*, then\n            1. If IsAnonymousFunctionDefinition(|Initializer|) and IsIdentifierRef of |DestructuringAssignmentTarget| are both *true*, then\n              1. Let _rhsValue_ be ? NamedEvaluation of |Initializer| with argument _lref_.[[ReferencedName]].\n            1. Else,\n              1. Let _defaultValue_ be ? Evaluation of |Initializer|.\n              1. Let _rhsValue_ be ? GetValue(_defaultValue_).\n          1. Else,\n            1. Let _rhsValue_ be _v_.\n          1. If |DestructuringAssignmentTarget| is either an |ObjectLiteral| or an |ArrayLiteral|, then\n            1. Let _assignmentPattern_ be the |AssignmentPattern| that is covered by |DestructuringAssignmentTarget|.\n            1. Return ? DestructuringAssignmentEvaluation of _assignmentPattern_ with argument _rhsValue_.\n          1. Return ? PutValue(_lref_, _rhsValue_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Expression","idx":1,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _lref_ be ? the result of evaluating |Expression|.\n  1. Perform ? GetValue(_lref_).\n  1. Let _rref_ be ? the result of evaluating |AssignmentExpression|.\n  1. Return ? GetValue(_rref_).","code":"\n        1. Let _lref_ be ? Evaluation of |Expression|.\n        1. Perform ? GetValue(_lref_).\n        1. Let _rref_ be ? Evaluation of |AssignmentExpression|.\n        1. Return ? GetValue(_rref_).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"HoistableDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"GeneratorDeclaration","ty":"Ast[GeneratorDeclaration]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ~empty~.","code":"\n        1. Return ~empty~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"HoistableDeclaration","idx":2,"subIdx":0,"rhsParams":[{"name":"AsyncFunctionDeclaration","ty":"Ast[AsyncFunctionDeclaration]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ~empty~.","code":"\n        1. Return ~empty~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"HoistableDeclaration","idx":3,"subIdx":0,"rhsParams":[{"name":"AsyncGeneratorDeclaration","ty":"Ast[AsyncGeneratorDeclaration]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ~empty~.","code":"\n        1. Return ~empty~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"HoistableDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"FunctionDeclaration","ty":"Ast[FunctionDeclaration]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ? the result of evaluating |FunctionDeclaration|.","code":"\n        1. Return ? Evaluation of |FunctionDeclaration|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BreakableStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"IterationStatement","ty":"Ast[IterationStatement]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _newLabelSet_ be « ».\n  1. Return ? LabelledEvaluation of *this* value with argument _newLabelSet_.","code":"\n        1. Let _newLabelSet_ be a new empty List.\n        1. Return ? LabelledEvaluation of this |BreakableStatement| with argument _newLabelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BreakableStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"SwitchStatement","ty":"Ast[SwitchStatement]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _newLabelSet_ be « ».\n  1. Return ? LabelledEvaluation of *this* value with argument _newLabelSet_.","code":"\n        1. Let _newLabelSet_ be a new empty List.\n        1. Return ? LabelledEvaluation of this |BreakableStatement| with argument _newLabelSet_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Block","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ~empty~.","code":"\n        1. Return ~empty~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Block","idx":0,"subIdx":1,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _oldEnv_ be the running execution context.LexicalEnvironment.\n  1. Let _blockEnv_ be NewDeclarativeEnvironment(_oldEnv_).\n  1. Perform BlockDeclarationInstantiation(|StatementList|, _blockEnv_).\n  1. Set the running execution context.LexicalEnvironment to _blockEnv_.\n  1. Let _blockValue_ be Completion(the result of evaluating |StatementList|).\n  1. Set the running execution context.LexicalEnvironment to _oldEnv_.\n  1. Return ? _blockValue_.","code":"\n        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.\n        1. Let _blockEnv_ be NewDeclarativeEnvironment(_oldEnv_).\n        1. Perform BlockDeclarationInstantiation(|StatementList|, _blockEnv_).\n        1. Set the running execution context's LexicalEnvironment to _blockEnv_.\n        1. Let _blockValue_ be Completion(Evaluation of |StatementList|).\n        1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n        1. Return ? _blockValue_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementList","idx":1,"subIdx":0,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}},{"name":"StatementListItem","ty":"Ast[StatementListItem]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _sl_ be ? the result of evaluating |StatementList|.\n  1. Let _s_ be Completion(the result of evaluating |StatementListItem|).\n  1. Return ? UpdateEmpty(_s_, _sl_).","code":"\n        1. Let _sl_ be ? Evaluation of |StatementList|.\n        1. Let _s_ be Completion(Evaluation of |StatementListItem|).\n        1. Return ? UpdateEmpty(_s_, _sl_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"BlockDeclarationInstantiation","params":[{"name":"code","ty":"Ast","kind":{"Normal":{}}},{"name":"env","ty":"Record[DeclarativeEnvironmentRecord]","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Let _declarations_ be LexicallyScopedDeclarations of _code_.\n  1. Let _privateEnv_ be the running execution context.PrivateEnvironment.\n  1. For each _d_ of _declarations_, do\n    1. For each _dn_ of BoundNames of _d_, do\n      1. If IsConstantDeclaration of _d_ is *true*, then\n        1. Perform ! _env_.CreateImmutableBinding(_dn_, *true*).\n      1. Else,\n        1. [id=\"step-blockdeclarationinstantiation-createmutablebinding\"] Perform ! _env_.CreateMutableBinding(_dn_, *false*).\n    1. If _d_ is a Ast[AsyncFunctionDeclaration | AsyncGeneratorDeclaration | FunctionDeclaration | GeneratorDeclaration], then\n      1. Let _fn_ be the sole element of BoundNames of _d_.\n      1. Let _fo_ be InstantiateFunctionObject of _d_ with arguments _env_ and _privateEnv_.\n      1. [id=\"step-blockdeclarationinstantiation-initializebinding\"] Perform ! _env_.InitializeBinding(_fn_, _fo_).\n  1. Return ~unused~.","code":"\n        1. Let _declarations_ be the LexicallyScopedDeclarations of _code_.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. For each element _d_ of _declarations_, do\n          1. For each element _dn_ of the BoundNames of _d_, do\n            1. If IsConstantDeclaration of _d_ is *true*, then\n              1. Perform ! _env_.CreateImmutableBinding(_dn_, *true*).\n            1. Else,\n              1. [id=\"step-blockdeclarationinstantiation-createmutablebinding\"] Perform ! _env_.CreateMutableBinding(_dn_, *false*). NOTE: This step is replaced in section <emu-xref href=\"#sec-web-compat-blockdeclarationinstantiation\"></emu-xref>.\n          1. If _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|, then\n            1. Let _fn_ be the sole element of the BoundNames of _d_.\n            1. Let _fo_ be InstantiateFunctionObject of _d_ with arguments _env_ and _privateEnv_.\n            1. [id=\"step-blockdeclarationinstantiation-initializebinding\"] Perform ! _env_.InitializeBinding(_fn_, _fo_). NOTE: This step is replaced in section <emu-xref href=\"#sec-web-compat-blockdeclarationinstantiation\"></emu-xref>.\n        1. Return ~unused~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LexicalDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"LetOrConst","ty":"Ast[LetOrConst]","kind":{"Normal":{}}},{"name":"BindingList","ty":"Ast[BindingList]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Perform ? the result of evaluating |BindingList|.\n  1. Return ~empty~.","code":"\n          1. Perform ? Evaluation of |BindingList|.\n          1. Return ~empty~.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingList","idx":1,"subIdx":0,"rhsParams":[{"name":"BindingList","ty":"Ast[BindingList]","kind":{"Normal":{}}},{"name":"LexicalBinding","ty":"Ast[LexicalBinding]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Perform ? the result of evaluating |BindingList|.\n  1. Return ? the result of evaluating |LexicalBinding|.","code":"\n          1. Perform ? Evaluation of |BindingList|.\n          1. Return ? Evaluation of |LexicalBinding|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LexicalBinding","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _lhs_ be ! ResolveBinding(StringValue of |BindingIdentifier|).\n  1. Perform ! InitializeReferencedBinding(_lhs_, *undefined*).\n  1. Return ~empty~.","code":"\n          1. Let _lhs_ be ! ResolveBinding(StringValue of |BindingIdentifier|).\n          1. Perform ! InitializeReferencedBinding(_lhs_, *undefined*).\n          1. Return ~empty~.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LexicalBinding","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _bindingId_ be StringValue of |BindingIdentifier|.\n  1. Let _lhs_ be ! ResolveBinding(_bindingId_).\n  1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then\n    1. Let _value_ be ? NamedEvaluation of |Initializer| with argument _bindingId_.\n  1. Else,\n    1. Let _rhs_ be ? the result of evaluating |Initializer|.\n    1. Let _value_ be ? GetValue(_rhs_).\n  1. Perform ! InitializeReferencedBinding(_lhs_, _value_).\n  1. Return ~empty~.","code":"\n          1. Let _bindingId_ be StringValue of |BindingIdentifier|.\n          1. Let _lhs_ be ! ResolveBinding(_bindingId_).\n          1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then\n            1. Let _value_ be ? NamedEvaluation of |Initializer| with argument _bindingId_.\n          1. Else,\n            1. Let _rhs_ be ? Evaluation of |Initializer|.\n            1. Let _value_ be ? GetValue(_rhs_).\n          1. Perform ! InitializeReferencedBinding(_lhs_, _value_).\n          1. Return ~empty~.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LexicalBinding","idx":1,"subIdx":0,"rhsParams":[{"name":"BindingPattern","ty":"Ast[BindingPattern]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _rhs_ be ? the result of evaluating |Initializer|.\n  1. Let _value_ be ? GetValue(_rhs_).\n  1. Let _env_ be the running execution context.LexicalEnvironment.\n  1. Return ? BindingInitialization of |BindingPattern| with arguments _value_ and _env_.","code":"\n          1. Let _rhs_ be ? Evaluation of |Initializer|.\n          1. Let _value_ be ? GetValue(_rhs_).\n          1. Let _env_ be the running execution context's LexicalEnvironment.\n          1. Return ? BindingInitialization of |BindingPattern| with arguments _value_ and _env_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"VariableStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Perform ? the result of evaluating |VariableDeclarationList|.\n  1. Return ~empty~.","code":"\n          1. Perform ? Evaluation of |VariableDeclarationList|.\n          1. Return ~empty~.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"VariableDeclarationList","idx":1,"subIdx":0,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"VariableDeclaration","ty":"Ast[VariableDeclaration]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Perform ? the result of evaluating |VariableDeclarationList|.\n  1. Return ? the result of evaluating |VariableDeclaration|.","code":"\n          1. Perform ? Evaluation of |VariableDeclarationList|.\n          1. Return ? Evaluation of |VariableDeclaration|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"VariableDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ~empty~.","code":"\n          1. Return ~empty~.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"VariableDeclaration","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _bindingId_ be StringValue of |BindingIdentifier|.\n  1. Let _lhs_ be ? ResolveBinding(_bindingId_).\n  1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then\n    1. Let _value_ be ? NamedEvaluation of |Initializer| with argument _bindingId_.\n  1. Else,\n    1. Let _rhs_ be ? the result of evaluating |Initializer|.\n    1. Let _value_ be ? GetValue(_rhs_).\n  1. [id=\"step-vardecllist-evaluation-putvalue\"] Perform ? PutValue(_lhs_, _value_).\n  1. Return ~empty~.","code":"\n          1. Let _bindingId_ be StringValue of |BindingIdentifier|.\n          1. Let _lhs_ be ? ResolveBinding(_bindingId_).\n          1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then\n            1. Let _value_ be ? NamedEvaluation of |Initializer| with argument _bindingId_.\n          1. Else,\n            1. Let _rhs_ be ? Evaluation of |Initializer|.\n            1. Let _value_ be ? GetValue(_rhs_).\n          1. [id=\"step-vardecllist-evaluation-putvalue\"] Perform ? PutValue(_lhs_, _value_).\n          1. Return ~empty~.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"VariableDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"BindingPattern","ty":"Ast[BindingPattern]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _rhs_ be ? the result of evaluating |Initializer|.\n  1. Let _rval_ be ? GetValue(_rhs_).\n  1. Return ? BindingInitialization of |BindingPattern| with arguments _rval_ and *undefined*.","code":"\n          1. Let _rhs_ be ? Evaluation of |Initializer|.\n          1. Let _rval_ be ? GetValue(_rhs_).\n          1. Return ? BindingInitialization of |BindingPattern| with arguments _rval_ and *undefined*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingPropertyList","idx":1,"subIdx":0,"rhsParams":[{"name":"BindingPropertyList","ty":"Ast[BindingPropertyList]","kind":{"Normal":{}}},{"name":"BindingProperty","ty":"Ast[BindingProperty]","kind":{"Normal":{}}}]},"methodName":"PropertyBindingInitialization","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[List[Record[Symbol] | String]] | Abrupt"}},"body":"\n  1. Let _boundNames_ be ? PropertyBindingInitialization of |BindingPropertyList| with arguments _value_ and _environment_.\n  1. Let _nextNames_ be ? PropertyBindingInitialization of |BindingProperty| with arguments _value_ and _environment_.\n  1. Return the list-concatenation of _boundNames_ and _nextNames_.","code":"\n          1. Let _boundNames_ be ? PropertyBindingInitialization of |BindingPropertyList| with arguments _value_ and _environment_.\n          1. Let _nextNames_ be ? PropertyBindingInitialization of |BindingProperty| with arguments _value_ and _environment_.\n          1. Return the list-concatenation of _boundNames_ and _nextNames_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingProperty","idx":0,"subIdx":0,"rhsParams":[{"name":"SingleNameBinding","ty":"Ast[SingleNameBinding]","kind":{"Normal":{}}}]},"methodName":"PropertyBindingInitialization","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[List[Record[Symbol] | String]] | Abrupt"}},"body":"\n  1. Let _name_ be the sole element of BoundNames of |SingleNameBinding|.\n  1. Perform ? KeyedBindingInitialization of |SingleNameBinding| with arguments _value_, _environment_, and _name_.\n  1. Return « _name_ ».","code":"\n          1. Let _name_ be the sole element of the BoundNames of |SingleNameBinding|.\n          1. Perform ? KeyedBindingInitialization of |SingleNameBinding| with arguments _value_, _environment_, and _name_.\n          1. Return « _name_ ».\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingProperty","idx":1,"subIdx":0,"rhsParams":[{"name":"PropertyName","ty":"Ast[PropertyName]","kind":{"Normal":{}}},{"name":"BindingElement","ty":"Ast[BindingElement]","kind":{"Normal":{}}}]},"methodName":"PropertyBindingInitialization","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[List[Record[Symbol] | String]] | Abrupt"}},"body":"\n  1. Let _P_ be ? the result of evaluating |PropertyName|.\n  1. Perform ? KeyedBindingInitialization of |BindingElement| with arguments _value_, _environment_, and _P_.\n  1. Return « _P_ ».","code":"\n          1. Let _P_ be ? Evaluation of |PropertyName|.\n          1. Perform ? KeyedBindingInitialization of |BindingElement| with arguments _value_, _environment_, and _P_.\n          1. Return « _P_ ».\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingRestProperty","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}}]},"methodName":"RestBindingInitialization","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}},{"name":"excludedNames","ty":"List[Record[Symbol] | String]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _lhs_ be ? ResolveBinding(StringValue of |BindingIdentifier|, _environment_).\n  1. Let _restObj_ be OrdinaryObjectCreate(%Object.prototype%).\n  1. Perform ? CopyDataProperties(_restObj_, _value_, _excludedNames_).\n  1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _restObj_).\n  1. Return ? InitializeReferencedBinding(_lhs_, _restObj_).","code":"\n          1. Let _lhs_ be ? ResolveBinding(StringValue of |BindingIdentifier|, _environment_).\n          1. Let _restObj_ be OrdinaryObjectCreate(%Object.prototype%).\n          1. Perform ? CopyDataProperties(_restObj_, _value_, _excludedNames_).\n          1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _restObj_).\n          1. Return ? InitializeReferencedBinding(_lhs_, _restObj_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingElement","idx":1,"subIdx":0,"rhsParams":[{"name":"BindingPattern","ty":"Ast[BindingPattern]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"KeyedBindingInitialization","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}},{"name":"propertyName","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _v_ be ? GetV(_value_, _propertyName_).\n  1. If |Initializer| is present and _v_ is *undefined*, then\n    1. Let _defaultValue_ be ? the result of evaluating |Initializer|.\n    1. Set _v_ to ? GetValue(_defaultValue_).\n  1. Return ? BindingInitialization of |BindingPattern| with arguments _v_ and _environment_.","code":"\n          1. Let _v_ be ? GetV(_value_, _propertyName_).\n          1. If |Initializer| is present and _v_ is *undefined*, then\n            1. Let _defaultValue_ be ? Evaluation of |Initializer|.\n            1. Set _v_ to ? GetValue(_defaultValue_).\n          1. Return ? BindingInitialization of |BindingPattern| with arguments _v_ and _environment_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingElement","idx":1,"subIdx":1,"rhsParams":[{"name":"BindingPattern","ty":"Ast[BindingPattern]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"KeyedBindingInitialization","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}},{"name":"propertyName","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _v_ be ? GetV(_value_, _propertyName_).\n  1. If |Initializer| is present and _v_ is *undefined*, then\n    1. Let _defaultValue_ be ? the result of evaluating |Initializer|.\n    1. Set _v_ to ? GetValue(_defaultValue_).\n  1. Return ? BindingInitialization of |BindingPattern| with arguments _v_ and _environment_.","code":"\n          1. Let _v_ be ? GetV(_value_, _propertyName_).\n          1. If |Initializer| is present and _v_ is *undefined*, then\n            1. Let _defaultValue_ be ? Evaluation of |Initializer|.\n            1. Set _v_ to ? GetValue(_defaultValue_).\n          1. Return ? BindingInitialization of |BindingPattern| with arguments _v_ and _environment_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"SingleNameBinding","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"KeyedBindingInitialization","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}},{"name":"propertyName","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _bindingId_ be StringValue of |BindingIdentifier|.\n  1. Let _lhs_ be ? ResolveBinding(_bindingId_, _environment_).\n  1. Let _v_ be ? GetV(_value_, _propertyName_).\n  1. If |Initializer| is present and _v_ is *undefined*, then\n    1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then\n      1. Set _v_ to ? NamedEvaluation of |Initializer| with argument _bindingId_.\n    1. Else,\n      1. Let _defaultValue_ be ? the result of evaluating |Initializer|.\n      1. Set _v_ to ? GetValue(_defaultValue_).\n  1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _v_).\n  1. Return ? InitializeReferencedBinding(_lhs_, _v_).","code":"\n          1. Let _bindingId_ be StringValue of |BindingIdentifier|.\n          1. Let _lhs_ be ? ResolveBinding(_bindingId_, _environment_).\n          1. Let _v_ be ? GetV(_value_, _propertyName_).\n          1. If |Initializer| is present and _v_ is *undefined*, then\n            1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then\n              1. Set _v_ to ? NamedEvaluation of |Initializer| with argument _bindingId_.\n            1. Else,\n              1. Let _defaultValue_ be ? Evaluation of |Initializer|.\n              1. Set _v_ to ? GetValue(_defaultValue_).\n          1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _v_).\n          1. Return ? InitializeReferencedBinding(_lhs_, _v_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"SingleNameBinding","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"KeyedBindingInitialization","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}},{"name":"propertyName","ty":"Record[Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _bindingId_ be StringValue of |BindingIdentifier|.\n  1. Let _lhs_ be ? ResolveBinding(_bindingId_, _environment_).\n  1. Let _v_ be ? GetV(_value_, _propertyName_).\n  1. If |Initializer| is present and _v_ is *undefined*, then\n    1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then\n      1. Set _v_ to ? NamedEvaluation of |Initializer| with argument _bindingId_.\n    1. Else,\n      1. Let _defaultValue_ be ? the result of evaluating |Initializer|.\n      1. Set _v_ to ? GetValue(_defaultValue_).\n  1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _v_).\n  1. Return ? InitializeReferencedBinding(_lhs_, _v_).","code":"\n          1. Let _bindingId_ be StringValue of |BindingIdentifier|.\n          1. Let _lhs_ be ? ResolveBinding(_bindingId_, _environment_).\n          1. Let _v_ be ? GetV(_value_, _propertyName_).\n          1. If |Initializer| is present and _v_ is *undefined*, then\n            1. If IsAnonymousFunctionDefinition(|Initializer|) is *true*, then\n              1. Set _v_ to ? NamedEvaluation of |Initializer| with argument _bindingId_.\n            1. Else,\n              1. Let _defaultValue_ be ? Evaluation of |Initializer|.\n              1. Set _v_ to ? GetValue(_defaultValue_).\n          1. If _environment_ is *undefined*, return ? PutValue(_lhs_, _v_).\n          1. Return ? InitializeReferencedBinding(_lhs_, _v_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"EmptyStatement","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ~empty~.","code":"\n        1. Return ~empty~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExpressionStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _exprRef_ be ? the result of evaluating |Expression|.\n  1. Return ? GetValue(_exprRef_).","code":"\n        1. Let _exprRef_ be ? Evaluation of |Expression|.\n        1. Return ? GetValue(_exprRef_).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IfStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _exprRef_ be ? the result of evaluating |Expression|.\n  1. Let _exprValue_ be ToBoolean(? GetValue(_exprRef_)).\n  1. If _exprValue_ is *true*, then\n    1. Let _stmtCompletion_ be Completion(the result of evaluating the first |Statement|).\n  1. Else,\n    1. Let _stmtCompletion_ be Completion(the result of evaluating the second |Statement|).\n  1. Return ? UpdateEmpty(_stmtCompletion_, *undefined*).","code":"\n        1. Let _exprRef_ be ? Evaluation of |Expression|.\n        1. Let _exprValue_ be ToBoolean(? GetValue(_exprRef_)).\n        1. If _exprValue_ is *true*, then\n          1. Let _stmtCompletion_ be Completion(Evaluation of the first |Statement|).\n        1. Else,\n          1. Let _stmtCompletion_ be Completion(Evaluation of the second |Statement|).\n        1. Return ? UpdateEmpty(_stmtCompletion_, *undefined*).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IfStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _exprRef_ be ? the result of evaluating |Expression|.\n  1. Let _exprValue_ be ToBoolean(? GetValue(_exprRef_)).\n  1. If _exprValue_ is *false*, then\n    1. Return *undefined*.\n  1. Else,\n    1. Let _stmtCompletion_ be Completion(the result of evaluating |Statement|).\n    1. Return ? UpdateEmpty(_stmtCompletion_, *undefined*).","code":"\n        1. Let _exprRef_ be ? Evaluation of |Expression|.\n        1. Let _exprValue_ be ToBoolean(? GetValue(_exprRef_)).\n        1. If _exprValue_ is *false*, then\n          1. Return *undefined*.\n        1. Else,\n          1. Let _stmtCompletion_ be Completion(Evaluation of |Statement|).\n          1. Return ? UpdateEmpty(_stmtCompletion_, *undefined*).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"LoopContinues","params":[{"name":"completion","ty":"Completion","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _completion_ is a normal completion, return *true*.\n  1. If _completion_ is not a continue completion, return *false*.\n  1. If _completion_.[[Target]] is ~empty~, return *true*.\n  1. If _labelSet_ contains _completion_.[[Target]], return *true*.\n  1. Return *false*.","code":"\n          1. If _completion_ is a normal completion, return *true*.\n          1. If _completion_ is not a continue completion, return *false*.\n          1. If _completion_.[[Target]] is ~empty~, return *true*.\n          1. If _labelSet_ contains _completion_.[[Target]], return *true*.\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IterationStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"DoWhileStatement","ty":"Ast[DoWhileStatement]","kind":{"Normal":{}}}]},"methodName":"LoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Return ? DoWhileLoopEvaluation of |DoWhileStatement| with argument _labelSet_.","code":"\n          1. Return ? DoWhileLoopEvaluation of |DoWhileStatement| with argument _labelSet_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IterationStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"WhileStatement","ty":"Ast[WhileStatement]","kind":{"Normal":{}}}]},"methodName":"LoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Return ? WhileLoopEvaluation of |WhileStatement| with argument _labelSet_.","code":"\n          1. Return ? WhileLoopEvaluation of |WhileStatement| with argument _labelSet_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IterationStatement","idx":2,"subIdx":0,"rhsParams":[{"name":"ForStatement","ty":"Ast[ForStatement]","kind":{"Normal":{}}}]},"methodName":"LoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Return ? ForLoopEvaluation of |ForStatement| with argument _labelSet_.","code":"\n          1. Return ? ForLoopEvaluation of |ForStatement| with argument _labelSet_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IterationStatement","idx":3,"subIdx":0,"rhsParams":[{"name":"ForInOfStatement","ty":"Ast[ForInOfStatement]","kind":{"Normal":{}}}]},"methodName":"LoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Return ? ForInOfLoopEvaluation of |ForInOfStatement| with argument _labelSet_.","code":"\n          1. Return ? ForInOfLoopEvaluation of |ForInOfStatement| with argument _labelSet_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DoWhileStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"DoWhileLoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _V_ be *undefined*.\n  1. Repeat, \n    1. Let _stmtResult_ be Completion(the result of evaluating |Statement|).\n    1. If LoopContinues(_stmtResult_, _labelSet_) is *false*, return ? UpdateEmpty(_stmtResult_, _V_).\n    1. If _stmtResult_.[[Value]] is not ~empty~, set _V_ to _stmtResult_.[[Value]].\n    1. Let _exprRef_ be ? the result of evaluating |Expression|.\n    1. Let _exprValue_ be ? GetValue(_exprRef_).\n    1. If ToBoolean(_exprValue_) is *false*, return _V_.","code":"\n          1. Let _V_ be *undefined*.\n          1. Repeat,\n            1. Let _stmtResult_ be Completion(Evaluation of |Statement|).\n            1. If LoopContinues(_stmtResult_, _labelSet_) is *false*, return ? UpdateEmpty(_stmtResult_, _V_).\n            1. If _stmtResult_.[[Value]] is not ~empty~, set _V_ to _stmtResult_.[[Value]].\n            1. Let _exprRef_ be ? Evaluation of |Expression|.\n            1. Let _exprValue_ be ? GetValue(_exprRef_).\n            1. If ToBoolean(_exprValue_) is *false*, return _V_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"WhileStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"WhileLoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _V_ be *undefined*.\n  1. Repeat, \n    1. Let _exprRef_ be ? the result of evaluating |Expression|.\n    1. Let _exprValue_ be ? GetValue(_exprRef_).\n    1. If ToBoolean(_exprValue_) is *false*, return _V_.\n    1. Let _stmtResult_ be Completion(the result of evaluating |Statement|).\n    1. If LoopContinues(_stmtResult_, _labelSet_) is *false*, return ? UpdateEmpty(_stmtResult_, _V_).\n    1. If _stmtResult_.[[Value]] is not ~empty~, set _V_ to _stmtResult_.[[Value]].","code":"\n          1. Let _V_ be *undefined*.\n          1. Repeat,\n            1. Let _exprRef_ be ? Evaluation of |Expression|.\n            1. Let _exprValue_ be ? GetValue(_exprRef_).\n            1. If ToBoolean(_exprValue_) is *false*, return _V_.\n            1. Let _stmtResult_ be Completion(Evaluation of |Statement|).\n            1. If LoopContinues(_stmtResult_, _labelSet_) is *false*, return ? UpdateEmpty(_stmtResult_, _V_).\n            1. If _stmtResult_.[[Value]] is not ~empty~, set _V_ to _stmtResult_.[[Value]].\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ForLoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. If the first |Expression| is present, then\n    1. Let _exprRef_ be ? the result of evaluating the first |Expression|.\n    1. Perform ? GetValue(_exprRef_).\n  1. If the second |Expression| is present, let _test_ be the second |Expression|.\n  1. Else, let _test_ be ~empty~.\n  1. If the third |Expression| is present, let _increment_ be the third |Expression|.\n  1. Else, let _increment_ be ~empty~.\n  1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).","code":"\n          1. If the first |Expression| is present, then\n            1. Let _exprRef_ be ? Evaluation of the first |Expression|.\n            1. Perform ? GetValue(_exprRef_).\n          1. If the second |Expression| is present, let _test_ be the second |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the third |Expression| is present, let _increment_ be the third |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":1,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ForLoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. If the first |Expression| is present, then\n    1. Let _exprRef_ be ? the result of evaluating the first |Expression|.\n    1. Perform ? GetValue(_exprRef_).\n  1. If the second |Expression| is present, let _test_ be the second |Expression|.\n  1. Else, let _test_ be ~empty~.\n  1. If the third |Expression| is present, let _increment_ be the third |Expression|.\n  1. Else, let _increment_ be ~empty~.\n  1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).","code":"\n          1. If the first |Expression| is present, then\n            1. Let _exprRef_ be ? Evaluation of the first |Expression|.\n            1. Perform ? GetValue(_exprRef_).\n          1. If the second |Expression| is present, let _test_ be the second |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the third |Expression| is present, let _increment_ be the third |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":2,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ForLoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. If the first |Expression| is present, then\n    1. Let _exprRef_ be ? the result of evaluating the first |Expression|.\n    1. Perform ? GetValue(_exprRef_).\n  1. If the second |Expression| is present, let _test_ be the second |Expression|.\n  1. Else, let _test_ be ~empty~.\n  1. If the third |Expression| is present, let _increment_ be the third |Expression|.\n  1. Else, let _increment_ be ~empty~.\n  1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).","code":"\n          1. If the first |Expression| is present, then\n            1. Let _exprRef_ be ? Evaluation of the first |Expression|.\n            1. Perform ? GetValue(_exprRef_).\n          1. If the second |Expression| is present, let _test_ be the second |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the third |Expression| is present, let _increment_ be the third |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":3,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ForLoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. If the first |Expression| is present, then\n    1. Let _exprRef_ be ? the result of evaluating the first |Expression|.\n    1. Perform ? GetValue(_exprRef_).\n  1. If the second |Expression| is present, let _test_ be the second |Expression|.\n  1. Else, let _test_ be ~empty~.\n  1. If the third |Expression| is present, let _increment_ be the third |Expression|.\n  1. Else, let _increment_ be ~empty~.\n  1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).","code":"\n          1. If the first |Expression| is present, then\n            1. Let _exprRef_ be ? Evaluation of the first |Expression|.\n            1. Perform ? GetValue(_exprRef_).\n          1. If the second |Expression| is present, let _test_ be the second |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the third |Expression| is present, let _increment_ be the third |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":4,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ForLoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. If the first |Expression| is present, then\n    1. Let _exprRef_ be ? the result of evaluating the first |Expression|.\n    1. Perform ? GetValue(_exprRef_).\n  1. If the second |Expression| is present, let _test_ be the second |Expression|.\n  1. Else, let _test_ be ~empty~.\n  1. If the third |Expression| is present, let _increment_ be the third |Expression|.\n  1. Else, let _increment_ be ~empty~.\n  1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).","code":"\n          1. If the first |Expression| is present, then\n            1. Let _exprRef_ be ? Evaluation of the first |Expression|.\n            1. Perform ? GetValue(_exprRef_).\n          1. If the second |Expression| is present, let _test_ be the second |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the third |Expression| is present, let _increment_ be the third |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":5,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ForLoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. If the first |Expression| is present, then\n    1. Let _exprRef_ be ? the result of evaluating the first |Expression|.\n    1. Perform ? GetValue(_exprRef_).\n  1. If the second |Expression| is present, let _test_ be the second |Expression|.\n  1. Else, let _test_ be ~empty~.\n  1. If the third |Expression| is present, let _increment_ be the third |Expression|.\n  1. Else, let _increment_ be ~empty~.\n  1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).","code":"\n          1. If the first |Expression| is present, then\n            1. Let _exprRef_ be ? Evaluation of the first |Expression|.\n            1. Perform ? GetValue(_exprRef_).\n          1. If the second |Expression| is present, let _test_ be the second |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the third |Expression| is present, let _increment_ be the third |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":6,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ForLoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. If the first |Expression| is present, then\n    1. Let _exprRef_ be ? the result of evaluating the first |Expression|.\n    1. Perform ? GetValue(_exprRef_).\n  1. If the second |Expression| is present, let _test_ be the second |Expression|.\n  1. Else, let _test_ be ~empty~.\n  1. If the third |Expression| is present, let _increment_ be the third |Expression|.\n  1. Else, let _increment_ be ~empty~.\n  1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).","code":"\n          1. If the first |Expression| is present, then\n            1. Let _exprRef_ be ? Evaluation of the first |Expression|.\n            1. Perform ? GetValue(_exprRef_).\n          1. If the second |Expression| is present, let _test_ be the second |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the third |Expression| is present, let _increment_ be the third |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":7,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ForLoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. If the first |Expression| is present, then\n    1. Let _exprRef_ be ? the result of evaluating the first |Expression|.\n    1. Perform ? GetValue(_exprRef_).\n  1. If the second |Expression| is present, let _test_ be the second |Expression|.\n  1. Else, let _test_ be ~empty~.\n  1. If the third |Expression| is present, let _increment_ be the third |Expression|.\n  1. Else, let _increment_ be ~empty~.\n  1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).","code":"\n          1. If the first |Expression| is present, then\n            1. Let _exprRef_ be ? Evaluation of the first |Expression|.\n            1. Perform ? GetValue(_exprRef_).\n          1. If the second |Expression| is present, let _test_ be the second |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the third |Expression| is present, let _increment_ be the third |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ForLoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Perform ? the result of evaluating |VariableDeclarationList|.\n  1. If the first |Expression| is present, let _test_ be the first |Expression|.\n  1. Else, let _test_ be ~empty~.\n  1. If the second |Expression| is present, let _increment_ be the second |Expression|.\n  1. Else, let _increment_ be ~empty~.\n  1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).","code":"\n          1. Perform ? Evaluation of |VariableDeclarationList|.\n          1. If the first |Expression| is present, let _test_ be the first |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the second |Expression| is present, let _increment_ be the second |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":1,"subIdx":1,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ForLoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Perform ? the result of evaluating |VariableDeclarationList|.\n  1. If the first |Expression| is present, let _test_ be the first |Expression|.\n  1. Else, let _test_ be ~empty~.\n  1. If the second |Expression| is present, let _increment_ be the second |Expression|.\n  1. Else, let _increment_ be ~empty~.\n  1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).","code":"\n          1. Perform ? Evaluation of |VariableDeclarationList|.\n          1. If the first |Expression| is present, let _test_ be the first |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the second |Expression| is present, let _increment_ be the second |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":1,"subIdx":2,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ForLoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Perform ? the result of evaluating |VariableDeclarationList|.\n  1. If the first |Expression| is present, let _test_ be the first |Expression|.\n  1. Else, let _test_ be ~empty~.\n  1. If the second |Expression| is present, let _increment_ be the second |Expression|.\n  1. Else, let _increment_ be ~empty~.\n  1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).","code":"\n          1. Perform ? Evaluation of |VariableDeclarationList|.\n          1. If the first |Expression| is present, let _test_ be the first |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the second |Expression| is present, let _increment_ be the second |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":1,"subIdx":3,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ForLoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Perform ? the result of evaluating |VariableDeclarationList|.\n  1. If the first |Expression| is present, let _test_ be the first |Expression|.\n  1. Else, let _test_ be ~empty~.\n  1. If the second |Expression| is present, let _increment_ be the second |Expression|.\n  1. Else, let _increment_ be ~empty~.\n  1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).","code":"\n          1. Perform ? Evaluation of |VariableDeclarationList|.\n          1. If the first |Expression| is present, let _test_ be the first |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the second |Expression| is present, let _increment_ be the second |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Return ? ForBodyEvaluation(_test_, _increment_, |Statement|, « », _labelSet_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":2,"subIdx":0,"rhsParams":[{"name":"LexicalDeclaration","ty":"Ast[LexicalDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ForLoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _oldEnv_ be the running execution context.LexicalEnvironment.\n  1. Let _loopEnv_ be NewDeclarativeEnvironment(_oldEnv_).\n  1. Let _isConst_ be IsConstantDeclaration of |LexicalDeclaration|.\n  1. Let _boundNames_ be BoundNames of |LexicalDeclaration|.\n  1. For each _dn_ of _boundNames_, do\n    1. If _isConst_ is *true*, then\n      1. Perform ! _loopEnv_.CreateImmutableBinding(_dn_, *true*).\n    1. Else,\n      1. Perform ! _loopEnv_.CreateMutableBinding(_dn_, *false*).\n  1. Set the running execution context.LexicalEnvironment to _loopEnv_.\n  1. Let _forDcl_ be Completion(the result of evaluating |LexicalDeclaration|).\n  1. If _forDcl_ is an abrupt completion, then\n    1. Set the running execution context.LexicalEnvironment to _oldEnv_.\n    1. Return ? _forDcl_.\n  1. If _isConst_ is *false*, let _perIterationLets_ be _boundNames_.\n  1. Else, let _perIterationLets_ be « ».\n  1. If the first |Expression| is present, let _test_ be the first |Expression|.\n  1. Else, let _test_ be ~empty~.\n  1. If the second |Expression| is present, let _increment_ be the second |Expression|.\n  1. Else, let _increment_ be ~empty~.\n  1. Let _bodyResult_ be Completion(ForBodyEvaluation(_test_, _increment_, |Statement|, _perIterationLets_, _labelSet_)).\n  1. Set the running execution context.LexicalEnvironment to _oldEnv_.\n  1. Return ? _bodyResult_.","code":"\n          1. Let _oldEnv_ be the running execution context's LexicalEnvironment.\n          1. Let _loopEnv_ be NewDeclarativeEnvironment(_oldEnv_).\n          1. Let _isConst_ be IsConstantDeclaration of |LexicalDeclaration|.\n          1. Let _boundNames_ be the BoundNames of |LexicalDeclaration|.\n          1. For each element _dn_ of _boundNames_, do\n            1. If _isConst_ is *true*, then\n              1. Perform ! _loopEnv_.CreateImmutableBinding(_dn_, *true*).\n            1. Else,\n              1. Perform ! _loopEnv_.CreateMutableBinding(_dn_, *false*).\n          1. Set the running execution context's LexicalEnvironment to _loopEnv_.\n          1. Let _forDcl_ be Completion(Evaluation of |LexicalDeclaration|).\n          1. If _forDcl_ is an abrupt completion, then\n            1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n            1. Return ? _forDcl_.\n          1. If _isConst_ is *false*, let _perIterationLets_ be _boundNames_; otherwise let _perIterationLets_ be a new empty List.\n          1. If the first |Expression| is present, let _test_ be the first |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the second |Expression| is present, let _increment_ be the second |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Let _bodyResult_ be Completion(ForBodyEvaluation(_test_, _increment_, |Statement|, _perIterationLets_, _labelSet_)).\n          1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n          1. Return ? _bodyResult_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":2,"subIdx":1,"rhsParams":[{"name":"LexicalDeclaration","ty":"Ast[LexicalDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ForLoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _oldEnv_ be the running execution context.LexicalEnvironment.\n  1. Let _loopEnv_ be NewDeclarativeEnvironment(_oldEnv_).\n  1. Let _isConst_ be IsConstantDeclaration of |LexicalDeclaration|.\n  1. Let _boundNames_ be BoundNames of |LexicalDeclaration|.\n  1. For each _dn_ of _boundNames_, do\n    1. If _isConst_ is *true*, then\n      1. Perform ! _loopEnv_.CreateImmutableBinding(_dn_, *true*).\n    1. Else,\n      1. Perform ! _loopEnv_.CreateMutableBinding(_dn_, *false*).\n  1. Set the running execution context.LexicalEnvironment to _loopEnv_.\n  1. Let _forDcl_ be Completion(the result of evaluating |LexicalDeclaration|).\n  1. If _forDcl_ is an abrupt completion, then\n    1. Set the running execution context.LexicalEnvironment to _oldEnv_.\n    1. Return ? _forDcl_.\n  1. If _isConst_ is *false*, let _perIterationLets_ be _boundNames_.\n  1. Else, let _perIterationLets_ be « ».\n  1. If the first |Expression| is present, let _test_ be the first |Expression|.\n  1. Else, let _test_ be ~empty~.\n  1. If the second |Expression| is present, let _increment_ be the second |Expression|.\n  1. Else, let _increment_ be ~empty~.\n  1. Let _bodyResult_ be Completion(ForBodyEvaluation(_test_, _increment_, |Statement|, _perIterationLets_, _labelSet_)).\n  1. Set the running execution context.LexicalEnvironment to _oldEnv_.\n  1. Return ? _bodyResult_.","code":"\n          1. Let _oldEnv_ be the running execution context's LexicalEnvironment.\n          1. Let _loopEnv_ be NewDeclarativeEnvironment(_oldEnv_).\n          1. Let _isConst_ be IsConstantDeclaration of |LexicalDeclaration|.\n          1. Let _boundNames_ be the BoundNames of |LexicalDeclaration|.\n          1. For each element _dn_ of _boundNames_, do\n            1. If _isConst_ is *true*, then\n              1. Perform ! _loopEnv_.CreateImmutableBinding(_dn_, *true*).\n            1. Else,\n              1. Perform ! _loopEnv_.CreateMutableBinding(_dn_, *false*).\n          1. Set the running execution context's LexicalEnvironment to _loopEnv_.\n          1. Let _forDcl_ be Completion(Evaluation of |LexicalDeclaration|).\n          1. If _forDcl_ is an abrupt completion, then\n            1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n            1. Return ? _forDcl_.\n          1. If _isConst_ is *false*, let _perIterationLets_ be _boundNames_; otherwise let _perIterationLets_ be a new empty List.\n          1. If the first |Expression| is present, let _test_ be the first |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the second |Expression| is present, let _increment_ be the second |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Let _bodyResult_ be Completion(ForBodyEvaluation(_test_, _increment_, |Statement|, _perIterationLets_, _labelSet_)).\n          1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n          1. Return ? _bodyResult_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":2,"subIdx":2,"rhsParams":[{"name":"LexicalDeclaration","ty":"Ast[LexicalDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ForLoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _oldEnv_ be the running execution context.LexicalEnvironment.\n  1. Let _loopEnv_ be NewDeclarativeEnvironment(_oldEnv_).\n  1. Let _isConst_ be IsConstantDeclaration of |LexicalDeclaration|.\n  1. Let _boundNames_ be BoundNames of |LexicalDeclaration|.\n  1. For each _dn_ of _boundNames_, do\n    1. If _isConst_ is *true*, then\n      1. Perform ! _loopEnv_.CreateImmutableBinding(_dn_, *true*).\n    1. Else,\n      1. Perform ! _loopEnv_.CreateMutableBinding(_dn_, *false*).\n  1. Set the running execution context.LexicalEnvironment to _loopEnv_.\n  1. Let _forDcl_ be Completion(the result of evaluating |LexicalDeclaration|).\n  1. If _forDcl_ is an abrupt completion, then\n    1. Set the running execution context.LexicalEnvironment to _oldEnv_.\n    1. Return ? _forDcl_.\n  1. If _isConst_ is *false*, let _perIterationLets_ be _boundNames_.\n  1. Else, let _perIterationLets_ be « ».\n  1. If the first |Expression| is present, let _test_ be the first |Expression|.\n  1. Else, let _test_ be ~empty~.\n  1. If the second |Expression| is present, let _increment_ be the second |Expression|.\n  1. Else, let _increment_ be ~empty~.\n  1. Let _bodyResult_ be Completion(ForBodyEvaluation(_test_, _increment_, |Statement|, _perIterationLets_, _labelSet_)).\n  1. Set the running execution context.LexicalEnvironment to _oldEnv_.\n  1. Return ? _bodyResult_.","code":"\n          1. Let _oldEnv_ be the running execution context's LexicalEnvironment.\n          1. Let _loopEnv_ be NewDeclarativeEnvironment(_oldEnv_).\n          1. Let _isConst_ be IsConstantDeclaration of |LexicalDeclaration|.\n          1. Let _boundNames_ be the BoundNames of |LexicalDeclaration|.\n          1. For each element _dn_ of _boundNames_, do\n            1. If _isConst_ is *true*, then\n              1. Perform ! _loopEnv_.CreateImmutableBinding(_dn_, *true*).\n            1. Else,\n              1. Perform ! _loopEnv_.CreateMutableBinding(_dn_, *false*).\n          1. Set the running execution context's LexicalEnvironment to _loopEnv_.\n          1. Let _forDcl_ be Completion(Evaluation of |LexicalDeclaration|).\n          1. If _forDcl_ is an abrupt completion, then\n            1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n            1. Return ? _forDcl_.\n          1. If _isConst_ is *false*, let _perIterationLets_ be _boundNames_; otherwise let _perIterationLets_ be a new empty List.\n          1. If the first |Expression| is present, let _test_ be the first |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the second |Expression| is present, let _increment_ be the second |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Let _bodyResult_ be Completion(ForBodyEvaluation(_test_, _increment_, |Statement|, _perIterationLets_, _labelSet_)).\n          1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n          1. Return ? _bodyResult_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":2,"subIdx":3,"rhsParams":[{"name":"LexicalDeclaration","ty":"Ast[LexicalDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ForLoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _oldEnv_ be the running execution context.LexicalEnvironment.\n  1. Let _loopEnv_ be NewDeclarativeEnvironment(_oldEnv_).\n  1. Let _isConst_ be IsConstantDeclaration of |LexicalDeclaration|.\n  1. Let _boundNames_ be BoundNames of |LexicalDeclaration|.\n  1. For each _dn_ of _boundNames_, do\n    1. If _isConst_ is *true*, then\n      1. Perform ! _loopEnv_.CreateImmutableBinding(_dn_, *true*).\n    1. Else,\n      1. Perform ! _loopEnv_.CreateMutableBinding(_dn_, *false*).\n  1. Set the running execution context.LexicalEnvironment to _loopEnv_.\n  1. Let _forDcl_ be Completion(the result of evaluating |LexicalDeclaration|).\n  1. If _forDcl_ is an abrupt completion, then\n    1. Set the running execution context.LexicalEnvironment to _oldEnv_.\n    1. Return ? _forDcl_.\n  1. If _isConst_ is *false*, let _perIterationLets_ be _boundNames_.\n  1. Else, let _perIterationLets_ be « ».\n  1. If the first |Expression| is present, let _test_ be the first |Expression|.\n  1. Else, let _test_ be ~empty~.\n  1. If the second |Expression| is present, let _increment_ be the second |Expression|.\n  1. Else, let _increment_ be ~empty~.\n  1. Let _bodyResult_ be Completion(ForBodyEvaluation(_test_, _increment_, |Statement|, _perIterationLets_, _labelSet_)).\n  1. Set the running execution context.LexicalEnvironment to _oldEnv_.\n  1. Return ? _bodyResult_.","code":"\n          1. Let _oldEnv_ be the running execution context's LexicalEnvironment.\n          1. Let _loopEnv_ be NewDeclarativeEnvironment(_oldEnv_).\n          1. Let _isConst_ be IsConstantDeclaration of |LexicalDeclaration|.\n          1. Let _boundNames_ be the BoundNames of |LexicalDeclaration|.\n          1. For each element _dn_ of _boundNames_, do\n            1. If _isConst_ is *true*, then\n              1. Perform ! _loopEnv_.CreateImmutableBinding(_dn_, *true*).\n            1. Else,\n              1. Perform ! _loopEnv_.CreateMutableBinding(_dn_, *false*).\n          1. Set the running execution context's LexicalEnvironment to _loopEnv_.\n          1. Let _forDcl_ be Completion(Evaluation of |LexicalDeclaration|).\n          1. If _forDcl_ is an abrupt completion, then\n            1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n            1. Return ? _forDcl_.\n          1. If _isConst_ is *false*, let _perIterationLets_ be _boundNames_; otherwise let _perIterationLets_ be a new empty List.\n          1. If the first |Expression| is present, let _test_ be the first |Expression|; otherwise, let _test_ be ~empty~.\n          1. If the second |Expression| is present, let _increment_ be the second |Expression|; otherwise, let _increment_ be ~empty~.\n          1. Let _bodyResult_ be Completion(ForBodyEvaluation(_test_, _increment_, |Statement|, _perIterationLets_, _labelSet_)).\n          1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n          1. Return ? _bodyResult_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ForBodyEvaluation","params":[{"name":"test","ty":"Unknown[\"an |Expression| Parse Node or ~empty~\"]","kind":{"Normal":{}}},{"name":"increment","ty":"Unknown[\"an |Expression| Parse Node or ~empty~\"]","kind":{"Normal":{}}},{"name":"stmt","ty":"Unknown[\"a |Statement| Parse Node\"]","kind":{"Normal":{}}},{"name":"perIterationBindings","ty":"List[String]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _V_ be *undefined*.\n  1. Perform ? CreatePerIterationEnvironment(_perIterationBindings_).\n  1. Repeat, \n    1. If _test_ is not ~empty~, then\n      1. Let _testRef_ be ? the result of evaluating _test_.\n      1. Let _testValue_ be ? GetValue(_testRef_).\n      1. If ToBoolean(_testValue_) is *false*, return _V_.\n    1. Let _result_ be Completion(the result of evaluating _stmt_).\n    1. If LoopContinues(_result_, _labelSet_) is *false*, return ? UpdateEmpty(_result_, _V_).\n    1. If _result_.[[Value]] is not ~empty~, set _V_ to _result_.[[Value]].\n    1. Perform ? CreatePerIterationEnvironment(_perIterationBindings_).\n    1. If _increment_ is not ~empty~, then\n      1. Let _incRef_ be ? the result of evaluating _increment_.\n      1. Perform ? GetValue(_incRef_).","code":"\n          1. Let _V_ be *undefined*.\n          1. Perform ? CreatePerIterationEnvironment(_perIterationBindings_).\n          1. Repeat,\n            1. If _test_ is not ~empty~, then\n              1. Let _testRef_ be ? Evaluation of _test_.\n              1. Let _testValue_ be ? GetValue(_testRef_).\n              1. If ToBoolean(_testValue_) is *false*, return _V_.\n            1. Let _result_ be Completion(Evaluation of _stmt_).\n            1. If LoopContinues(_result_, _labelSet_) is *false*, return ? UpdateEmpty(_result_, _V_).\n            1. If _result_.[[Value]] is not ~empty~, set _V_ to _result_.[[Value]].\n            1. Perform ? CreatePerIterationEnvironment(_perIterationBindings_).\n            1. If _increment_ is not ~empty~, then\n              1. Let _incRef_ be ? Evaluation of _increment_.\n              1. Perform ? GetValue(_incRef_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CreatePerIterationEnvironment","params":[{"name":"perIterationBindings","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. If _perIterationBindings_ is not empty, then\n    1. Let _lastIterationEnv_ be the running execution context.LexicalEnvironment.\n    1. Let _outer_ be _lastIterationEnv_.[[OuterEnv]].\n    1. Assert: _outer_ is not *null*.\n    1. Let _thisIterationEnv_ be NewDeclarativeEnvironment(_outer_).\n    1. For each _bn_ of _perIterationBindings_, do\n      1. Perform ! _thisIterationEnv_.CreateMutableBinding(_bn_, *false*).\n      1. Let _lastValue_ be ? _lastIterationEnv_.GetBindingValue(_bn_, *true*).\n      1. Perform ! _thisIterationEnv_.InitializeBinding(_bn_, _lastValue_).\n    1. Set the running execution context.LexicalEnvironment to _thisIterationEnv_.\n  1. Return ~unused~.","code":"\n          1. If _perIterationBindings_ has any elements, then\n            1. Let _lastIterationEnv_ be the running execution context's LexicalEnvironment.\n            1. Let _outer_ be _lastIterationEnv_.[[OuterEnv]].\n            1. Assert: _outer_ is not *null*.\n            1. Let _thisIterationEnv_ be NewDeclarativeEnvironment(_outer_).\n            1. For each element _bn_ of _perIterationBindings_, do\n              1. Perform ! _thisIterationEnv_.CreateMutableBinding(_bn_, *false*).\n              1. Let _lastValue_ be ? _lastIterationEnv_.GetBindingValue(_bn_, *true*).\n              1. Perform ! _thisIterationEnv_.InitializeBinding(_bn_, _lastValue_).\n            1. Set the running execution context's LexicalEnvironment to _thisIterationEnv_.\n          1. Return ~unused~.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"PrimaryExpression","ty":"Ast[PrimaryExpression]","kind":{"Normal":{}}}]},"methodName":"IsDestructuring","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. If |PrimaryExpression| is a Ast[ArrayLiteral | ObjectLiteral], return *true*.\n  1. Return *false*.","code":"\n          1. If |PrimaryExpression| is either an |ObjectLiteral| or an |ArrayLiteral|, return *true*.\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"IsDestructuring","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"IdentifierName","ty":"Ast[IdentifierName]","kind":{"Normal":{}}}]},"methodName":"IsDestructuring","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"TemplateLiteral","ty":"Ast[TemplateLiteral]","kind":{"Normal":{}}}]},"methodName":"IsDestructuring","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"SuperProperty","ty":"Ast[SuperProperty]","kind":{"Normal":{}}}]},"methodName":"IsDestructuring","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":5,"subIdx":0,"rhsParams":[{"name":"MetaProperty","ty":"Ast[MetaProperty]","kind":{"Normal":{}}}]},"methodName":"IsDestructuring","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":6,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"Arguments","ty":"Ast[Arguments]","kind":{"Normal":{}}}]},"methodName":"IsDestructuring","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":7,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"PrivateIdentifier","ty":"Ast[PrivateIdentifier]","kind":{"Normal":{}}}]},"methodName":"IsDestructuring","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NewExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"NewExpression","ty":"Ast[NewExpression]","kind":{"Normal":{}}}]},"methodName":"IsDestructuring","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LeftHandSideExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"CallExpression","ty":"Ast[CallExpression]","kind":{"Normal":{}}}]},"methodName":"IsDestructuring","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LeftHandSideExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"OptionalExpression","ty":"Ast[OptionalExpression]","kind":{"Normal":{}}}]},"methodName":"IsDestructuring","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"LetOrConst","ty":"Ast[LetOrConst]","kind":{"Normal":{}}},{"name":"ForBinding","ty":"Ast[ForBinding]","kind":{"Normal":{}}}]},"methodName":"IsDestructuring","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return IsDestructuring of |ForBinding|.","code":"\n          1. Return IsDestructuring of |ForBinding|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForBinding","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}}]},"methodName":"IsDestructuring","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForBinding","idx":1,"subIdx":0,"rhsParams":[{"name":"BindingPattern","ty":"Ast[BindingPattern]","kind":{"Normal":{}}}]},"methodName":"IsDestructuring","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n          1. Return *true*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"LetOrConst","ty":"Ast[LetOrConst]","kind":{"Normal":{}}},{"name":"ForBinding","ty":"Ast[ForBinding]","kind":{"Normal":{}}}]},"methodName":"ForDeclarationBindingInitialization","isStatic":false,"withParams":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}},{"name":"environment","ty":"Record[EnvironmentRecord] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Abrupt"}},"body":"\n  1. Return ? BindingInitialization of |ForBinding| with arguments _value_ and _environment_.","code":"\n          1. Return ? BindingInitialization of |ForBinding| with arguments _value_ and _environment_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"LetOrConst","ty":"Ast[LetOrConst]","kind":{"Normal":{}}},{"name":"ForBinding","ty":"Ast[ForBinding]","kind":{"Normal":{}}}]},"methodName":"ForDeclarationBindingInstantiation","isStatic":false,"withParams":[{"name":"environment","ty":"Record[DeclarativeEnvironmentRecord]","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. For each _name_ of BoundNames of |ForBinding|, do\n    1. If IsConstantDeclaration of |LetOrConst| is *true*, then\n      1. Perform ! _environment_.CreateImmutableBinding(_name_, *true*).\n    1. Else,\n      1. Perform ! _environment_.CreateMutableBinding(_name_, *false*).\n  1. Return ~unused~.","code":"\n          1. For each element _name_ of the BoundNames of |ForBinding|, do\n            1. If IsConstantDeclaration of |LetOrConst| is *true*, then\n              1. Perform ! _environment_.CreateImmutableBinding(_name_, *true*).\n            1. Else,\n              1. Perform ! _environment_.CreateMutableBinding(_name_, *false*).\n          1. Return ~unused~.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ForInOfLoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |Expression|, ~enumerate~).\n  1. Return ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~enumerate~, ~assignment~, _labelSet_).","code":"\n          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |Expression|, ~enumerate~).\n          1. Return ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~enumerate~, ~assignment~, _labelSet_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"ForBinding","ty":"Ast[ForBinding]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ForInOfLoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |Expression|, ~enumerate~).\n  1. Return ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~enumerate~, ~var-binding~, _labelSet_).","code":"\n          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |Expression|, ~enumerate~).\n          1. Return ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~enumerate~, ~var-binding~, _labelSet_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":2,"subIdx":0,"rhsParams":[{"name":"ForDeclaration","ty":"Ast[ForDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ForInOfLoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |Expression|, ~enumerate~).\n  1. Return ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~enumerate~, ~lexical-binding~, _labelSet_).","code":"\n          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |Expression|, ~enumerate~).\n          1. Return ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~enumerate~, ~lexical-binding~, _labelSet_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":3,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ForInOfLoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~iterate~).\n  1. Return ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~iterate~, ~assignment~, _labelSet_).","code":"\n          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~iterate~).\n          1. Return ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~iterate~, ~assignment~, _labelSet_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":4,"subIdx":0,"rhsParams":[{"name":"ForBinding","ty":"Ast[ForBinding]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ForInOfLoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~iterate~).\n  1. Return ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~iterate~, ~var-binding~, _labelSet_).","code":"\n          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~iterate~).\n          1. Return ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~iterate~, ~var-binding~, _labelSet_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":5,"subIdx":0,"rhsParams":[{"name":"ForDeclaration","ty":"Ast[ForDeclaration]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ForInOfLoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |AssignmentExpression|, ~iterate~).\n  1. Return ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~iterate~, ~lexical-binding~, _labelSet_).","code":"\n          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |AssignmentExpression|, ~iterate~).\n          1. Return ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~iterate~, ~lexical-binding~, _labelSet_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":6,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ForInOfLoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~async-iterate~).\n  1. Return ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~iterate~, ~assignment~, _labelSet_, ~async~).","code":"\n          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~async-iterate~).\n          1. Return ? ForIn/OfBodyEvaluation(|LeftHandSideExpression|, |Statement|, _keyResult_, ~iterate~, ~assignment~, _labelSet_, ~async~).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":7,"subIdx":0,"rhsParams":[{"name":"ForBinding","ty":"Ast[ForBinding]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ForInOfLoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~async-iterate~).\n  1. Return ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~iterate~, ~var-binding~, _labelSet_, ~async~).","code":"\n          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(« », |AssignmentExpression|, ~async-iterate~).\n          1. Return ? ForIn/OfBodyEvaluation(|ForBinding|, |Statement|, _keyResult_, ~iterate~, ~var-binding~, _labelSet_, ~async~).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":8,"subIdx":0,"rhsParams":[{"name":"ForDeclaration","ty":"Ast[ForDeclaration]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"ForInOfLoopEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |AssignmentExpression|, ~async-iterate~).\n  1. Return ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~iterate~, ~lexical-binding~, _labelSet_, ~async~).","code":"\n          1. Let _keyResult_ be ? ForIn/OfHeadEvaluation(BoundNames of |ForDeclaration|, |AssignmentExpression|, ~async-iterate~).\n          1. Return ? ForIn/OfBodyEvaluation(|ForDeclaration|, |Statement|, _keyResult_, ~iterate~, ~lexical-binding~, _labelSet_, ~async~).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ForIn/OfHeadEvaluation","params":[{"name":"uninitializedBoundNames","ty":"List[String]","kind":{"Normal":{}}},{"name":"expr","ty":"Unknown[\"an |Expression| Parse Node or an |AssignmentExpression| Parse Node\"]","kind":{"Normal":{}}},{"name":"iterationKind","ty":"Enum[~async-iterate~, ~enumerate~, ~iterate~]","kind":{"Normal":{}}}],"retTy":"Normal[Record[IteratorRecord]] | Abrupt"}},"body":"\n  1. Let _oldEnv_ be the running execution context.LexicalEnvironment.\n  1. If _uninitializedBoundNames_ is not empty, then\n    1. Assert: _uninitializedBoundNames_ is not duplicate entries.\n    1. Let _newEnv_ be NewDeclarativeEnvironment(_oldEnv_).\n    1. For each String _name_ of _uninitializedBoundNames_, do\n      1. Perform ! _newEnv_.CreateMutableBinding(_name_, *false*).\n    1. Set the running execution context.LexicalEnvironment to _newEnv_.\n  1. Let _exprRef_ be Completion(the result of evaluating _expr_).\n  1. Set the running execution context.LexicalEnvironment to _oldEnv_.\n  1. Let _exprValue_ be ? GetValue(? _exprRef_).\n  1. If _iterationKind_ is ~enumerate~, then\n    1. If _exprValue_ is either *undefined* or *null*, then\n      1. Return Completion Record { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: ~empty~ }.\n    1. Let _obj_ be ! ToObject(_exprValue_).\n    1. Let _iterator_ be EnumerateObjectProperties(_obj_).\n    1. Let _nextMethod_ be ! GetV(_iterator_, *\"next\"*).\n    1. Return Iterator Record { [[Iterator]]: _iterator_, [[NextMethod]]: _nextMethod_, [[Done]]: *false* }.\n  1. Else,\n    1. Assert: _iterationKind_ is either ~iterate~ or ~async-iterate~.\n    1. If _iterationKind_ is ~async-iterate~, let _iteratorKind_ be ~async~.\n    1. Else, let _iteratorKind_ be ~sync~.\n    1. Return ? GetIterator(_exprValue_, _iteratorKind_).","code":"\n          1. Let _oldEnv_ be the running execution context's LexicalEnvironment.\n          1. If _uninitializedBoundNames_ is not empty, then\n            1. Assert: _uninitializedBoundNames_ has no duplicate entries.\n            1. Let _newEnv_ be NewDeclarativeEnvironment(_oldEnv_).\n            1. For each String _name_ of _uninitializedBoundNames_, do\n              1. Perform ! _newEnv_.CreateMutableBinding(_name_, *false*).\n            1. Set the running execution context's LexicalEnvironment to _newEnv_.\n          1. Let _exprRef_ be Completion(Evaluation of _expr_).\n          1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n          1. Let _exprValue_ be ? GetValue(? _exprRef_).\n          1. If _iterationKind_ is ~enumerate~, then\n            1. If _exprValue_ is either *undefined* or *null*, then\n              1. Return Completion Record { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: ~empty~ }.\n            1. Let _obj_ be ! ToObject(_exprValue_).\n            1. Let _iterator_ be EnumerateObjectProperties(_obj_).\n            1. Let _nextMethod_ be ! GetV(_iterator_, *\"next\"*).\n            1. Return the Iterator Record { [[Iterator]]: _iterator_, [[NextMethod]]: _nextMethod_, [[Done]]: *false* }.\n          1. Else,\n            1. Assert: _iterationKind_ is either ~iterate~ or ~async-iterate~.\n            1. If _iterationKind_ is ~async-iterate~, let _iteratorKind_ be ~async~.\n            1. Else, let _iteratorKind_ be ~sync~.\n            1. Return ? GetIterator(_exprValue_, _iteratorKind_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ForIn/OfBodyEvaluation","params":[{"name":"lhs","ty":"Ast","kind":{"Normal":{}}},{"name":"stmt","ty":"Unknown[\"a |Statement| Parse Node\"]","kind":{"Normal":{}}},{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}},{"name":"iterationKind","ty":"Enum[~enumerate~, ~iterate~]","kind":{"Normal":{}}},{"name":"lhsKind","ty":"Enum[~assignment~, ~lexical-binding~, ~var-binding~]","kind":{"Normal":{}}},{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}},{"name":"iteratorKind","ty":"Enum[~async~, ~sync~]","kind":{"Optional":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. If _iteratorKind_ is not present, set _iteratorKind_ to ~sync~.\n  1. Let _oldEnv_ be the running execution context.LexicalEnvironment.\n  1. Let _V_ be *undefined*.\n  1. Let _destructuring_ be IsDestructuring of _lhs_.\n  1. If _destructuring_ is *true* and _lhsKind_ is ~assignment~, then\n    1. Assert: _lhs_ is a Ast[LeftHandSideExpression].\n    1. Let _assignmentPattern_ be the |AssignmentPattern| that is covered by _lhs_.\n  1. Repeat, \n    1. Let _nextResult_ be ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]]).\n    1. If _iteratorKind_ is ~async~, set _nextResult_ to ? Await(_nextResult_).\n    1. If _nextResult_ is not a Record[Object], throw a *TypeError* exception.\n    1. Let _done_ be ? IteratorComplete(_nextResult_).\n    1. If _done_ is *true*, return _V_.\n    1. Let _nextValue_ be ? IteratorValue(_nextResult_).\n    1. If _lhsKind_ is either ~assignment~ or ~var-binding~, then\n      1. If _destructuring_ is *true*, then\n        1. If _lhsKind_ is ~assignment~, then\n          1. Let _status_ be Completion(DestructuringAssignmentEvaluation of _assignmentPattern_ with argument _nextValue_).\n        1. Else,\n          1. Assert: _lhsKind_ is ~var-binding~.\n          1. Assert: _lhs_ is a Ast[ForBinding].\n          1. Let _status_ be Completion(BindingInitialization of _lhs_ with arguments _nextValue_ and *undefined*).\n      1. Else,\n        1. Let _lhsRef_ be Completion(the result of evaluating _lhs_).\n        1. If _lhsRef_ is an abrupt completion, then\n          1. Let _status_ be _lhsRef_.\n        1. Else,\n          1. Let _status_ be Completion(PutValue(_lhsRef_.[[Value]], _nextValue_)).\n    1. Else,\n      1. Assert: _lhsKind_ is ~lexical-binding~.\n      1. Assert: _lhs_ is a Ast[ForDeclaration].\n      1. Let _iterationEnv_ be NewDeclarativeEnvironment(_oldEnv_).\n      1. Perform ForDeclarationBindingInstantiation of _lhs_ with argument _iterationEnv_.\n      1. Set the running execution context.LexicalEnvironment to _iterationEnv_.\n      1. If _destructuring_ is *true*, then\n        1. Let _status_ be Completion(ForDeclarationBindingInitialization of _lhs_ with arguments _nextValue_ and _iterationEnv_).\n      1. Else,\n        1. Assert: _lhs_ binds a single name..\n        1. Let _lhsName_ be the sole element of BoundNames of _lhs_.\n        1. Let _lhsRef_ be ! ResolveBinding(_lhsName_).\n        1. Let _status_ be Completion(InitializeReferencedBinding(_lhsRef_, _nextValue_)).\n    1. If _status_ is an abrupt completion, then\n      1. Set the running execution context.LexicalEnvironment to _oldEnv_.\n      1. If _iteratorKind_ is ~async~, return ? AsyncIteratorClose(_iteratorRecord_, _status_).\n      1. If _iterationKind_ is ~enumerate~, then\n        1. Return ? _status_.\n      1. Else,\n        1. Assert: _iterationKind_ is ~iterate~.\n        1. Return ? IteratorClose(_iteratorRecord_, _status_).\n    1. Let _result_ be Completion(the result of evaluating _stmt_).\n    1. Set the running execution context.LexicalEnvironment to _oldEnv_.\n    1. If LoopContinues(_result_, _labelSet_) is *false*, then\n      1. If _iterationKind_ is ~enumerate~, then\n        1. Return ? UpdateEmpty(_result_, _V_).\n      1. Else,\n        1. Assert: _iterationKind_ is ~iterate~.\n        1. Set _status_ to Completion(UpdateEmpty(_result_, _V_)).\n        1. If _iteratorKind_ is ~async~, return ? AsyncIteratorClose(_iteratorRecord_, _status_).\n        1. Return ? IteratorClose(_iteratorRecord_, _status_).\n    1. If _result_.[[Value]] is not ~empty~, set _V_ to _result_.[[Value]].","code":"\n          1. If _iteratorKind_ is not present, set _iteratorKind_ to ~sync~.\n          1. Let _oldEnv_ be the running execution context's LexicalEnvironment.\n          1. Let _V_ be *undefined*.\n          1. Let _destructuring_ be IsDestructuring of _lhs_.\n          1. If _destructuring_ is *true* and _lhsKind_ is ~assignment~, then\n            1. Assert: _lhs_ is a |LeftHandSideExpression|.\n            1. Let _assignmentPattern_ be the |AssignmentPattern| that is covered by _lhs_.\n          1. Repeat,\n            1. Let _nextResult_ be ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]]).\n            1. If _iteratorKind_ is ~async~, set _nextResult_ to ? Await(_nextResult_).\n            1. If _nextResult_ is not an Object, throw a *TypeError* exception.\n            1. Let _done_ be ? IteratorComplete(_nextResult_).\n            1. If _done_ is *true*, return _V_.\n            1. Let _nextValue_ be ? IteratorValue(_nextResult_).\n            1. If _lhsKind_ is either ~assignment~ or ~var-binding~, then\n              1. If _destructuring_ is *true*, then\n                1. If _lhsKind_ is ~assignment~, then\n                  1. Let _status_ be Completion(DestructuringAssignmentEvaluation of _assignmentPattern_ with argument _nextValue_).\n                1. Else,\n                  1. Assert: _lhsKind_ is ~var-binding~.\n                  1. Assert: _lhs_ is a |ForBinding|.\n                  1. Let _status_ be Completion(BindingInitialization of _lhs_ with arguments _nextValue_ and *undefined*).\n              1. Else,\n                1. Let _lhsRef_ be Completion(Evaluation of _lhs_). (It may be evaluated repeatedly.)\n                1. If _lhsRef_ is an abrupt completion, then\n                  1. Let _status_ be _lhsRef_.\n                1. Else,\n                  1. Let _status_ be Completion(PutValue(_lhsRef_.[[Value]], _nextValue_)).\n            1. Else,\n              1. Assert: _lhsKind_ is ~lexical-binding~.\n              1. Assert: _lhs_ is a |ForDeclaration|.\n              1. Let _iterationEnv_ be NewDeclarativeEnvironment(_oldEnv_).\n              1. Perform ForDeclarationBindingInstantiation of _lhs_ with argument _iterationEnv_.\n              1. Set the running execution context's LexicalEnvironment to _iterationEnv_.\n              1. If _destructuring_ is *true*, then\n                1. Let _status_ be Completion(ForDeclarationBindingInitialization of _lhs_ with arguments _nextValue_ and _iterationEnv_).\n              1. Else,\n                1. Assert: _lhs_ binds a single name.\n                1. Let _lhsName_ be the sole element of BoundNames of _lhs_.\n                1. Let _lhsRef_ be ! ResolveBinding(_lhsName_).\n                1. Let _status_ be Completion(InitializeReferencedBinding(_lhsRef_, _nextValue_)).\n            1. If _status_ is an abrupt completion, then\n              1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n              1. If _iteratorKind_ is ~async~, return ? AsyncIteratorClose(_iteratorRecord_, _status_).\n              1. If _iterationKind_ is ~enumerate~, then\n                1. Return ? _status_.\n              1. Else,\n                1. Assert: _iterationKind_ is ~iterate~.\n                1. Return ? IteratorClose(_iteratorRecord_, _status_).\n            1. Let _result_ be Completion(Evaluation of _stmt_).\n            1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n            1. If LoopContinues(_result_, _labelSet_) is *false*, then\n              1. If _iterationKind_ is ~enumerate~, then\n                1. Return ? UpdateEmpty(_result_, _V_).\n              1. Else,\n                1. Assert: _iterationKind_ is ~iterate~.\n                1. Set _status_ to Completion(UpdateEmpty(_result_, _V_)).\n                1. If _iteratorKind_ is ~async~, return ? AsyncIteratorClose(_iteratorRecord_, _status_).\n                1. Return ? IteratorClose(_iteratorRecord_, _status_).\n            1. If _result_.[[Value]] is not ~empty~, set _V_ to _result_.[[Value]].\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingIdentifier","idx":0,"subIdx":0,"rhsParams":[{"name":"Identifier","ty":"Ast[Identifier]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _bindingId_ be StringValue of |BindingIdentifier|.\n  1. Return ? ResolveBinding(_bindingId_).","code":"\n          1. Let _bindingId_ be StringValue of |BindingIdentifier|.\n          1. Return ? ResolveBinding(_bindingId_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingIdentifier","idx":1,"subIdx":0,"rhsParams":[]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _bindingId_ be StringValue of |BindingIdentifier|.\n  1. Return ? ResolveBinding(_bindingId_).","code":"\n          1. Let _bindingId_ be StringValue of |BindingIdentifier|.\n          1. Return ? ResolveBinding(_bindingId_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingIdentifier","idx":2,"subIdx":0,"rhsParams":[]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _bindingId_ be StringValue of |BindingIdentifier|.\n  1. Return ? ResolveBinding(_bindingId_).","code":"\n          1. Let _bindingId_ be StringValue of |BindingIdentifier|.\n          1. Return ? ResolveBinding(_bindingId_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"EnumerateObjectProperties","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Record[Iterator]"}},"body":"\n  1. Return an Iterator object (<emu-xref href=\"#sec-iterator-interface\"></emu-xref>) whose `next` method iterates over all the String-valued keys of enumerable properties of _O_. The iterator object is never directly accessible to ECMAScript code. The mechanics and order of enumerating the properties is not specified but must conform to the rules specified below.","code":"\n          1. Return an Iterator object (<emu-xref href=\"#sec-iterator-interface\"></emu-xref>) whose `next` method iterates over all the String-valued keys of enumerable properties of _O_. The iterator object is never directly accessible to ECMAScript code. The mechanics and order of enumerating the properties is not specified but must conform to the rules specified below.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CreateForInIterator","params":[{"name":"object","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Unknown[\"a For-In Iterator\"]"}},"body":"\n  1. Let _iterator_ be OrdinaryObjectCreate(%ForInIteratorPrototype%, « [[Object]], [[ObjectWasVisited]], [[VisitedKeys]], [[RemainingKeys]] »).\n  1. Set _iterator_.[[Object]] to _object_.\n  1. Set _iterator_.[[ObjectWasVisited]] to *false*.\n  1. Set _iterator_.[[VisitedKeys]] to « ».\n  1. Set _iterator_.[[RemainingKeys]] to « ».\n  1. Return _iterator_.","code":"\n            1. Let _iterator_ be OrdinaryObjectCreate(%ForInIteratorPrototype%, « [[Object]], [[ObjectWasVisited]], [[VisitedKeys]], [[RemainingKeys]] »).\n            1. Set _iterator_.[[Object]] to _object_.\n            1. Set _iterator_.[[ObjectWasVisited]] to *false*.\n            1. Set _iterator_.[[VisitedKeys]] to a new empty List.\n            1. Set _iterator_.[[RemainingKeys]] to a new empty List.\n            1. Return _iterator_.\n          "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"ForInIteratorPrototype"}},"name":"next"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Assert: _O_ is a Record[Object].\n  1. Assert: _O_ has all of the internal slots of a For-In Iterator Instance (<emu-xref href=\"#sec-properties-of-for-in-iterator-instances\"></emu-xref>)..\n  1. Let _object_ be _O_.[[Object]].\n  1. Repeat, \n    1. If _O_.[[ObjectWasVisited]] is *false*, then\n      1. Let _keys_ be ? _object_.[[OwnPropertyKeys]]().\n      1. For each _key_ of _keys_, do\n        1. If _key_ is a String, then\n          1. Append _key_ to _O_.[[RemainingKeys]].\n      1. Set _O_.[[ObjectWasVisited]] to *true*.\n    1. Repeat, while _O_.[[RemainingKeys]] is not empty,\n      1. Let _r_ be _O_.[[RemainingKeys]][0].\n      1. Remove the first element from _O_.[[RemainingKeys]].\n      1. If _O_.[[VisitedKeys]] does not contain an element _v_ such that SameValue(_r_, _v_) is *true*, then\n        1. Let _desc_ be ? _object_.[[GetOwnProperty]](_r_).\n        1. If _desc_ is not *undefined*, then\n          1. Append _r_ to _O_.[[VisitedKeys]].\n          1. If _desc_.[[Enumerable]] is *true*, return CreateIterResultObject(_r_, *false*).\n    1. Set _object_ to ? _object_.[[GetPrototypeOf]]().\n    1. Set _O_.[[Object]] to _object_.\n    1. Set _O_.[[ObjectWasVisited]] to *false*.\n    1. If _object_ is *null*, return CreateIterResultObject(*undefined*, *true*).","code":"\n              1. Let _O_ be the *this* value.\n              1. Assert: _O_ is an Object.\n              1. Assert: _O_ has all of the internal slots of a For-In Iterator Instance (<emu-xref href=\"#sec-properties-of-for-in-iterator-instances\"></emu-xref>).\n              1. Let _object_ be _O_.[[Object]].\n              1. Repeat,\n                1. If _O_.[[ObjectWasVisited]] is *false*, then\n                  1. Let _keys_ be ? <emu-meta effects=\"user-code\">_object_.[[OwnPropertyKeys]]()</emu-meta>.\n                  1. For each element _key_ of _keys_, do\n                    1. If _key_ is a String, then\n                      1. Append _key_ to _O_.[[RemainingKeys]].\n                  1. Set _O_.[[ObjectWasVisited]] to *true*.\n                1. Repeat, while _O_.[[RemainingKeys]] is not empty,\n                  1. Let _r_ be the first element of _O_.[[RemainingKeys]].\n                  1. Remove the first element from _O_.[[RemainingKeys]].\n                  1. If there does not exist an element _v_ of _O_.[[VisitedKeys]] such that SameValue(_r_, _v_) is *true*, then\n                    1. Let _desc_ be ? <emu-meta effects=\"user-code\">_object_.[[GetOwnProperty]]</emu-meta>(_r_).\n                    1. If _desc_ is not *undefined*, then\n                      1. Append _r_ to _O_.[[VisitedKeys]].\n                      1. If _desc_.[[Enumerable]] is *true*, return CreateIterResultObject(_r_, *false*).\n                1. Set _object_ to ? <emu-meta effects=\"user-code\">_object_.[[GetPrototypeOf]]()</emu-meta>.\n                1. Set _O_.[[Object]] to _object_.\n                1. Set _O_.[[ObjectWasVisited]] to *false*.\n                1. If _object_ is *null*, return CreateIterResultObject(*undefined*, *true*).\n            "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ContinueStatement","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return Completion Record { [[Type]]: ~continue~, [[Value]]: ~empty~, [[Target]]: ~empty~ }.","code":"\n        1. Return Completion Record { [[Type]]: ~continue~, [[Value]]: ~empty~, [[Target]]: ~empty~ }.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ContinueStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"LabelIdentifier","ty":"Ast[LabelIdentifier]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _label_ be StringValue of |LabelIdentifier|.\n  1. Return Completion Record { [[Type]]: ~continue~, [[Value]]: ~empty~, [[Target]]: _label_ }.","code":"\n        1. Let _label_ be the StringValue of |LabelIdentifier|.\n        1. Return Completion Record { [[Type]]: ~continue~, [[Value]]: ~empty~, [[Target]]: _label_ }.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BreakStatement","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return Completion Record { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: ~empty~ }.","code":"\n        1. Return Completion Record { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: ~empty~ }.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BreakStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"LabelIdentifier","ty":"Ast[LabelIdentifier]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _label_ be StringValue of |LabelIdentifier|.\n  1. Return Completion Record { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: _label_ }.","code":"\n        1. Let _label_ be the StringValue of |LabelIdentifier|.\n        1. Return Completion Record { [[Type]]: ~break~, [[Value]]: ~empty~, [[Target]]: _label_ }.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ReturnStatement","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return Completion Record { [[Type]]: ~return~, [[Value]]: *undefined*, [[Target]]: ~empty~ }.","code":"\n        1. Return Completion Record { [[Type]]: ~return~, [[Value]]: *undefined*, [[Target]]: ~empty~ }.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ReturnStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _exprRef_ be ? the result of evaluating |Expression|.\n  1. Let _exprValue_ be ? GetValue(_exprRef_).\n  1. If GetGeneratorKind() is ~async~, set _exprValue_ to ? Await(_exprValue_).\n  1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _exprValue_, [[Target]]: ~empty~ }.","code":"\n        1. Let _exprRef_ be ? Evaluation of |Expression|.\n        1. Let _exprValue_ be ? GetValue(_exprRef_).\n        1. If GetGeneratorKind() is ~async~, set _exprValue_ to ? Await(_exprValue_).\n        1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _exprValue_, [[Target]]: ~empty~ }.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"WithStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _val_ be ? the result of evaluating |Expression|.\n  1. Let _obj_ be ? ToObject(? GetValue(_val_)).\n  1. Let _oldEnv_ be the running execution context.LexicalEnvironment.\n  1. Let _newEnv_ be NewObjectEnvironment(_obj_, *true*, _oldEnv_).\n  1. Set the running execution context.LexicalEnvironment to _newEnv_.\n  1. Let _C_ be Completion(the result of evaluating |Statement|).\n  1. Set the running execution context.LexicalEnvironment to _oldEnv_.\n  1. Return ? UpdateEmpty(_C_, *undefined*).","code":"\n        1. Let _val_ be ? Evaluation of |Expression|.\n        1. Let _obj_ be ? ToObject(? GetValue(_val_)).\n        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.\n        1. Let _newEnv_ be NewObjectEnvironment(_obj_, *true*, _oldEnv_).\n        1. Set the running execution context's LexicalEnvironment to _newEnv_.\n        1. Let _C_ be Completion(Evaluation of |Statement|).\n        1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n        1. Return ? UpdateEmpty(_C_, *undefined*).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"CaseBlockEvaluation","isStatic":false,"withParams":[{"name":"input","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Return *undefined*.","code":"\n        1. Return *undefined*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":0,"subIdx":1,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"CaseBlockEvaluation","isStatic":false,"withParams":[{"name":"input","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _V_ be *undefined*.\n  1. Let _A_ be the List of |CaseClause| items in |CaseClauses|, in source text order.\n  1. Let _found_ be *false*.\n  1. For each Ast[CaseClause] _C_ of _A_, do\n    1. If _found_ is *false*, then\n      1. Set _found_ to ? CaseClauseIsSelected(_C_, _input_).\n    1. If _found_ is *true*, then\n      1. Let _R_ be Completion(the result of evaluating _C_).\n      1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n      1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n  1. Return _V_.","code":"\n        1. Let _V_ be *undefined*.\n        1. Let _A_ be the List of |CaseClause| items in |CaseClauses|, in source text order.\n        1. Let _found_ be *false*.\n        1. For each |CaseClause| _C_ of _A_, do\n          1. If _found_ is *false*, then\n            1. Set _found_ to ? CaseClauseIsSelected(_C_, _input_).\n          1. If _found_ is *true*, then\n            1. Let _R_ be Completion(Evaluation of _C_).\n            1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n            1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n        1. Return _V_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":0,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"CaseBlockEvaluation","isStatic":false,"withParams":[{"name":"input","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _V_ be *undefined*.\n  1. If the first |CaseClauses| is present, then\n    1. Let _A_ be the List of |CaseClause| items in the first |CaseClauses|, in source text order.\n  1. Else,\n    1. Let _A_ be « ».\n  1. Let _found_ be *false*.\n  1. For each Ast[CaseClause] _C_ of _A_, do\n    1. If _found_ is *false*, then\n      1. Set _found_ to ? CaseClauseIsSelected(_C_, _input_).\n    1. If _found_ is *true*, then\n      1. Let _R_ be Completion(the result of evaluating _C_).\n      1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n      1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n  1. Let _foundInB_ be *false*.\n  1. If the second |CaseClauses| is present, then\n    1. Let _B_ be the List of |CaseClause| items in the second |CaseClauses|, in source text order.\n  1. Else,\n    1. Let _B_ be « ».\n  1. If _found_ is *false*, then\n    1. For each Ast[CaseClause] _C_ of _B_, do\n      1. If _foundInB_ is *false*, then\n        1. Set _foundInB_ to ? CaseClauseIsSelected(_C_, _input_).\n      1. If _foundInB_ is *true*, then\n        1. Let _R_ be Completion(the result of evaluating _C_).\n        1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n        1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n  1. If _foundInB_ is *true*, return _V_.\n  1. Let _defaultR_ be Completion(the result of evaluating |DefaultClause|).\n  1. If _defaultR_.[[Value]] is not ~empty~, set _V_ to _defaultR_.[[Value]].\n  1. If _defaultR_ is an abrupt completion, return ? UpdateEmpty(_defaultR_, _V_).\n  1. NOTE: The following is another complete iteration of the second |CaseClauses|.\n  1. For each Ast[CaseClause] _C_ of _B_, do\n    1. Let _R_ be Completion(the result of evaluating _C_).\n    1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n    1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n  1. Return _V_.","code":"\n        1. Let _V_ be *undefined*.\n        1. If the first |CaseClauses| is present, then\n          1. Let _A_ be the List of |CaseClause| items in the first |CaseClauses|, in source text order.\n        1. Else,\n          1. Let _A_ be a new empty List.\n        1. Let _found_ be *false*.\n        1. For each |CaseClause| _C_ of _A_, do\n          1. If _found_ is *false*, then\n            1. Set _found_ to ? CaseClauseIsSelected(_C_, _input_).\n          1. If _found_ is *true*, then\n            1. Let _R_ be Completion(Evaluation of _C_).\n            1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n            1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n        1. Let _foundInB_ be *false*.\n        1. If the second |CaseClauses| is present, then\n          1. Let _B_ be the List of |CaseClause| items in the second |CaseClauses|, in source text order.\n        1. Else,\n          1. Let _B_ be a new empty List.\n        1. If _found_ is *false*, then\n          1. For each |CaseClause| _C_ of _B_, do\n            1. If _foundInB_ is *false*, then\n              1. Set _foundInB_ to ? CaseClauseIsSelected(_C_, _input_).\n            1. If _foundInB_ is *true*, then\n              1. Let _R_ be Completion(Evaluation of |CaseClause| _C_).\n              1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n              1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n        1. If _foundInB_ is *true*, return _V_.\n        1. Let _defaultR_ be Completion(Evaluation of |DefaultClause|).\n        1. If _defaultR_.[[Value]] is not ~empty~, set _V_ to _defaultR_.[[Value]].\n        1. If _defaultR_ is an abrupt completion, return ? UpdateEmpty(_defaultR_, _V_).\n        1. NOTE: The following is another complete iteration of the second |CaseClauses|.\n        1. For each |CaseClause| _C_ of _B_, do\n          1. Let _R_ be Completion(Evaluation of |CaseClause| _C_).\n          1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n          1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n        1. Return _V_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":1,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"CaseBlockEvaluation","isStatic":false,"withParams":[{"name":"input","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _V_ be *undefined*.\n  1. If the first |CaseClauses| is present, then\n    1. Let _A_ be the List of |CaseClause| items in the first |CaseClauses|, in source text order.\n  1. Else,\n    1. Let _A_ be « ».\n  1. Let _found_ be *false*.\n  1. For each Ast[CaseClause] _C_ of _A_, do\n    1. If _found_ is *false*, then\n      1. Set _found_ to ? CaseClauseIsSelected(_C_, _input_).\n    1. If _found_ is *true*, then\n      1. Let _R_ be Completion(the result of evaluating _C_).\n      1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n      1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n  1. Let _foundInB_ be *false*.\n  1. If the second |CaseClauses| is present, then\n    1. Let _B_ be the List of |CaseClause| items in the second |CaseClauses|, in source text order.\n  1. Else,\n    1. Let _B_ be « ».\n  1. If _found_ is *false*, then\n    1. For each Ast[CaseClause] _C_ of _B_, do\n      1. If _foundInB_ is *false*, then\n        1. Set _foundInB_ to ? CaseClauseIsSelected(_C_, _input_).\n      1. If _foundInB_ is *true*, then\n        1. Let _R_ be Completion(the result of evaluating _C_).\n        1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n        1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n  1. If _foundInB_ is *true*, return _V_.\n  1. Let _defaultR_ be Completion(the result of evaluating |DefaultClause|).\n  1. If _defaultR_.[[Value]] is not ~empty~, set _V_ to _defaultR_.[[Value]].\n  1. If _defaultR_ is an abrupt completion, return ? UpdateEmpty(_defaultR_, _V_).\n  1. NOTE: The following is another complete iteration of the second |CaseClauses|.\n  1. For each Ast[CaseClause] _C_ of _B_, do\n    1. Let _R_ be Completion(the result of evaluating _C_).\n    1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n    1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n  1. Return _V_.","code":"\n        1. Let _V_ be *undefined*.\n        1. If the first |CaseClauses| is present, then\n          1. Let _A_ be the List of |CaseClause| items in the first |CaseClauses|, in source text order.\n        1. Else,\n          1. Let _A_ be a new empty List.\n        1. Let _found_ be *false*.\n        1. For each |CaseClause| _C_ of _A_, do\n          1. If _found_ is *false*, then\n            1. Set _found_ to ? CaseClauseIsSelected(_C_, _input_).\n          1. If _found_ is *true*, then\n            1. Let _R_ be Completion(Evaluation of _C_).\n            1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n            1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n        1. Let _foundInB_ be *false*.\n        1. If the second |CaseClauses| is present, then\n          1. Let _B_ be the List of |CaseClause| items in the second |CaseClauses|, in source text order.\n        1. Else,\n          1. Let _B_ be a new empty List.\n        1. If _found_ is *false*, then\n          1. For each |CaseClause| _C_ of _B_, do\n            1. If _foundInB_ is *false*, then\n              1. Set _foundInB_ to ? CaseClauseIsSelected(_C_, _input_).\n            1. If _foundInB_ is *true*, then\n              1. Let _R_ be Completion(Evaluation of |CaseClause| _C_).\n              1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n              1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n        1. If _foundInB_ is *true*, return _V_.\n        1. Let _defaultR_ be Completion(Evaluation of |DefaultClause|).\n        1. If _defaultR_.[[Value]] is not ~empty~, set _V_ to _defaultR_.[[Value]].\n        1. If _defaultR_ is an abrupt completion, return ? UpdateEmpty(_defaultR_, _V_).\n        1. NOTE: The following is another complete iteration of the second |CaseClauses|.\n        1. For each |CaseClause| _C_ of _B_, do\n          1. Let _R_ be Completion(Evaluation of |CaseClause| _C_).\n          1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n          1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n        1. Return _V_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":2,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"CaseBlockEvaluation","isStatic":false,"withParams":[{"name":"input","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _V_ be *undefined*.\n  1. If the first |CaseClauses| is present, then\n    1. Let _A_ be the List of |CaseClause| items in the first |CaseClauses|, in source text order.\n  1. Else,\n    1. Let _A_ be « ».\n  1. Let _found_ be *false*.\n  1. For each Ast[CaseClause] _C_ of _A_, do\n    1. If _found_ is *false*, then\n      1. Set _found_ to ? CaseClauseIsSelected(_C_, _input_).\n    1. If _found_ is *true*, then\n      1. Let _R_ be Completion(the result of evaluating _C_).\n      1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n      1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n  1. Let _foundInB_ be *false*.\n  1. If the second |CaseClauses| is present, then\n    1. Let _B_ be the List of |CaseClause| items in the second |CaseClauses|, in source text order.\n  1. Else,\n    1. Let _B_ be « ».\n  1. If _found_ is *false*, then\n    1. For each Ast[CaseClause] _C_ of _B_, do\n      1. If _foundInB_ is *false*, then\n        1. Set _foundInB_ to ? CaseClauseIsSelected(_C_, _input_).\n      1. If _foundInB_ is *true*, then\n        1. Let _R_ be Completion(the result of evaluating _C_).\n        1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n        1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n  1. If _foundInB_ is *true*, return _V_.\n  1. Let _defaultR_ be Completion(the result of evaluating |DefaultClause|).\n  1. If _defaultR_.[[Value]] is not ~empty~, set _V_ to _defaultR_.[[Value]].\n  1. If _defaultR_ is an abrupt completion, return ? UpdateEmpty(_defaultR_, _V_).\n  1. NOTE: The following is another complete iteration of the second |CaseClauses|.\n  1. For each Ast[CaseClause] _C_ of _B_, do\n    1. Let _R_ be Completion(the result of evaluating _C_).\n    1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n    1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n  1. Return _V_.","code":"\n        1. Let _V_ be *undefined*.\n        1. If the first |CaseClauses| is present, then\n          1. Let _A_ be the List of |CaseClause| items in the first |CaseClauses|, in source text order.\n        1. Else,\n          1. Let _A_ be a new empty List.\n        1. Let _found_ be *false*.\n        1. For each |CaseClause| _C_ of _A_, do\n          1. If _found_ is *false*, then\n            1. Set _found_ to ? CaseClauseIsSelected(_C_, _input_).\n          1. If _found_ is *true*, then\n            1. Let _R_ be Completion(Evaluation of _C_).\n            1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n            1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n        1. Let _foundInB_ be *false*.\n        1. If the second |CaseClauses| is present, then\n          1. Let _B_ be the List of |CaseClause| items in the second |CaseClauses|, in source text order.\n        1. Else,\n          1. Let _B_ be a new empty List.\n        1. If _found_ is *false*, then\n          1. For each |CaseClause| _C_ of _B_, do\n            1. If _foundInB_ is *false*, then\n              1. Set _foundInB_ to ? CaseClauseIsSelected(_C_, _input_).\n            1. If _foundInB_ is *true*, then\n              1. Let _R_ be Completion(Evaluation of |CaseClause| _C_).\n              1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n              1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n        1. If _foundInB_ is *true*, return _V_.\n        1. Let _defaultR_ be Completion(Evaluation of |DefaultClause|).\n        1. If _defaultR_.[[Value]] is not ~empty~, set _V_ to _defaultR_.[[Value]].\n        1. If _defaultR_ is an abrupt completion, return ? UpdateEmpty(_defaultR_, _V_).\n        1. NOTE: The following is another complete iteration of the second |CaseClauses|.\n        1. For each |CaseClause| _C_ of _B_, do\n          1. Let _R_ be Completion(Evaluation of |CaseClause| _C_).\n          1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n          1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n        1. Return _V_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":3,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"CaseBlockEvaluation","isStatic":false,"withParams":[{"name":"input","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _V_ be *undefined*.\n  1. If the first |CaseClauses| is present, then\n    1. Let _A_ be the List of |CaseClause| items in the first |CaseClauses|, in source text order.\n  1. Else,\n    1. Let _A_ be « ».\n  1. Let _found_ be *false*.\n  1. For each Ast[CaseClause] _C_ of _A_, do\n    1. If _found_ is *false*, then\n      1. Set _found_ to ? CaseClauseIsSelected(_C_, _input_).\n    1. If _found_ is *true*, then\n      1. Let _R_ be Completion(the result of evaluating _C_).\n      1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n      1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n  1. Let _foundInB_ be *false*.\n  1. If the second |CaseClauses| is present, then\n    1. Let _B_ be the List of |CaseClause| items in the second |CaseClauses|, in source text order.\n  1. Else,\n    1. Let _B_ be « ».\n  1. If _found_ is *false*, then\n    1. For each Ast[CaseClause] _C_ of _B_, do\n      1. If _foundInB_ is *false*, then\n        1. Set _foundInB_ to ? CaseClauseIsSelected(_C_, _input_).\n      1. If _foundInB_ is *true*, then\n        1. Let _R_ be Completion(the result of evaluating _C_).\n        1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n        1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n  1. If _foundInB_ is *true*, return _V_.\n  1. Let _defaultR_ be Completion(the result of evaluating |DefaultClause|).\n  1. If _defaultR_.[[Value]] is not ~empty~, set _V_ to _defaultR_.[[Value]].\n  1. If _defaultR_ is an abrupt completion, return ? UpdateEmpty(_defaultR_, _V_).\n  1. NOTE: The following is another complete iteration of the second |CaseClauses|.\n  1. For each Ast[CaseClause] _C_ of _B_, do\n    1. Let _R_ be Completion(the result of evaluating _C_).\n    1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n    1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n  1. Return _V_.","code":"\n        1. Let _V_ be *undefined*.\n        1. If the first |CaseClauses| is present, then\n          1. Let _A_ be the List of |CaseClause| items in the first |CaseClauses|, in source text order.\n        1. Else,\n          1. Let _A_ be a new empty List.\n        1. Let _found_ be *false*.\n        1. For each |CaseClause| _C_ of _A_, do\n          1. If _found_ is *false*, then\n            1. Set _found_ to ? CaseClauseIsSelected(_C_, _input_).\n          1. If _found_ is *true*, then\n            1. Let _R_ be Completion(Evaluation of _C_).\n            1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n            1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n        1. Let _foundInB_ be *false*.\n        1. If the second |CaseClauses| is present, then\n          1. Let _B_ be the List of |CaseClause| items in the second |CaseClauses|, in source text order.\n        1. Else,\n          1. Let _B_ be a new empty List.\n        1. If _found_ is *false*, then\n          1. For each |CaseClause| _C_ of _B_, do\n            1. If _foundInB_ is *false*, then\n              1. Set _foundInB_ to ? CaseClauseIsSelected(_C_, _input_).\n            1. If _foundInB_ is *true*, then\n              1. Let _R_ be Completion(Evaluation of |CaseClause| _C_).\n              1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n              1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n        1. If _foundInB_ is *true*, return _V_.\n        1. Let _defaultR_ be Completion(Evaluation of |DefaultClause|).\n        1. If _defaultR_.[[Value]] is not ~empty~, set _V_ to _defaultR_.[[Value]].\n        1. If _defaultR_ is an abrupt completion, return ? UpdateEmpty(_defaultR_, _V_).\n        1. NOTE: The following is another complete iteration of the second |CaseClauses|.\n        1. For each |CaseClause| _C_ of _B_, do\n          1. Let _R_ be Completion(Evaluation of |CaseClause| _C_).\n          1. If _R_.[[Value]] is not ~empty~, set _V_ to _R_.[[Value]].\n          1. If _R_ is an abrupt completion, return ? UpdateEmpty(_R_, _V_).\n        1. Return _V_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CaseClauseIsSelected","params":[{"name":"C","ty":"Unknown[\"a |CaseClause| Parse Node\"]","kind":{"Normal":{}}},{"name":"input","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Abrupt"}},"body":"\n  1. Assert: _C_ is an instance of the production <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>..\n  1. Let _exprRef_ be ? the result of evaluating the |Expression| of _C_.\n  1. Let _clauseSelector_ be ? GetValue(_exprRef_).\n  1. Return IsStrictlyEqual(_input_, _clauseSelector_).","code":"\n        1. Assert: _C_ is an instance of the production <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>.\n        1. Let _exprRef_ be ? Evaluation of the |Expression| of _C_.\n        1. Let _clauseSelector_ be ? GetValue(_exprRef_).\n        1. Return IsStrictlyEqual(_input_, _clauseSelector_).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"SwitchStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"CaseBlock","ty":"Ast[CaseBlock]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _exprRef_ be ? the result of evaluating |Expression|.\n  1. Let _switchValue_ be ? GetValue(_exprRef_).\n  1. Let _oldEnv_ be the running execution context.LexicalEnvironment.\n  1. Let _blockEnv_ be NewDeclarativeEnvironment(_oldEnv_).\n  1. Perform BlockDeclarationInstantiation(|CaseBlock|, _blockEnv_).\n  1. Set the running execution context.LexicalEnvironment to _blockEnv_.\n  1. Let _R_ be Completion(CaseBlockEvaluation of |CaseBlock| with argument _switchValue_).\n  1. Set the running execution context.LexicalEnvironment to _oldEnv_.\n  1. Return _R_.","code":"\n        1. Let _exprRef_ be ? Evaluation of |Expression|.\n        1. Let _switchValue_ be ? GetValue(_exprRef_).\n        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.\n        1. Let _blockEnv_ be NewDeclarativeEnvironment(_oldEnv_).\n        1. Perform BlockDeclarationInstantiation(|CaseBlock|, _blockEnv_).\n        1. Set the running execution context's LexicalEnvironment to _blockEnv_.\n        1. Let _R_ be Completion(CaseBlockEvaluation of |CaseBlock| with argument _switchValue_).\n        1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n        1. Return _R_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseClause","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ~empty~.","code":"\n        1. Return ~empty~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseClause","idx":0,"subIdx":1,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ? the result of evaluating |StatementList|.","code":"\n        1. Return ? Evaluation of |StatementList|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DefaultClause","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ~empty~.","code":"\n        1. Return ~empty~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DefaultClause","idx":0,"subIdx":1,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ? the result of evaluating |StatementList|.","code":"\n        1. Return ? Evaluation of |StatementList|.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsLabelledFunction","params":[{"name":"stmt","ty":"Unknown[\"a |Statement| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _stmt_ is not a Ast[LabelledStatement], return *false*.\n  1. Let _item_ be the |LabelledItem| of _stmt_.\n  1. If _item_ is <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>, return *true*.\n  1. Let _subStmt_ be the |Statement| of _item_.\n  1. Return IsLabelledFunction(_subStmt_).","code":"\n        1. If _stmt_ is not a |LabelledStatement|, return *false*.\n        1. Let _item_ be the |LabelledItem| of _stmt_.\n        1. If _item_ is <emu-grammar>LabelledItem : FunctionDeclaration</emu-grammar>, return *true*.\n        1. Let _subStmt_ be the |Statement| of _item_.\n        1. Return IsLabelledFunction(_subStmt_).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LabelledStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"LabelIdentifier","ty":"Ast[LabelIdentifier]","kind":{"Normal":{}}},{"name":"LabelledItem","ty":"Ast[LabelledItem]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ? LabelledEvaluation of *this* value with argument « ».","code":"\n        1. Return ? LabelledEvaluation of this |LabelledStatement| with argument « ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BreakableStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"IterationStatement","ty":"Ast[IterationStatement]","kind":{"Normal":{}}}]},"methodName":"LabelledEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _stmtResult_ be Completion(LoopEvaluation of |IterationStatement| with argument _labelSet_).\n  1. If _stmtResult_ is a break completion, then\n    1. If _stmtResult_.[[Target]] is ~empty~, then\n      1. If _stmtResult_.[[Value]] is ~empty~, set _stmtResult_ to NormalCompletion(*undefined*).\n      1. Else, set _stmtResult_ to NormalCompletion(_stmtResult_.[[Value]]).\n  1. Return ? _stmtResult_.","code":"\n        1. Let _stmtResult_ be Completion(LoopEvaluation of |IterationStatement| with argument _labelSet_).\n        1. If _stmtResult_ is a break completion, then\n          1. If _stmtResult_.[[Target]] is ~empty~, then\n            1. If _stmtResult_.[[Value]] is ~empty~, set _stmtResult_ to NormalCompletion(*undefined*).\n            1. Else, set _stmtResult_ to NormalCompletion(_stmtResult_.[[Value]]).\n        1. Return ? _stmtResult_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BreakableStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"SwitchStatement","ty":"Ast[SwitchStatement]","kind":{"Normal":{}}}]},"methodName":"LabelledEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _stmtResult_ be Completion(the result of evaluating |SwitchStatement|).\n  1. If _stmtResult_ is a break completion, then\n    1. If _stmtResult_.[[Target]] is ~empty~, then\n      1. If _stmtResult_.[[Value]] is ~empty~, set _stmtResult_ to NormalCompletion(*undefined*).\n      1. Else, set _stmtResult_ to NormalCompletion(_stmtResult_.[[Value]]).\n  1. Return ? _stmtResult_.","code":"\n        1. Let _stmtResult_ be Completion(Evaluation of |SwitchStatement|).\n        1. If _stmtResult_ is a break completion, then\n          1. If _stmtResult_.[[Target]] is ~empty~, then\n            1. If _stmtResult_.[[Value]] is ~empty~, set _stmtResult_ to NormalCompletion(*undefined*).\n            1. Else, set _stmtResult_ to NormalCompletion(_stmtResult_.[[Value]]).\n        1. Return ? _stmtResult_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LabelledStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"LabelIdentifier","ty":"Ast[LabelIdentifier]","kind":{"Normal":{}}},{"name":"LabelledItem","ty":"Ast[LabelledItem]","kind":{"Normal":{}}}]},"methodName":"LabelledEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _label_ be StringValue of |LabelIdentifier|.\n  1. Let _newLabelSet_ be the list-concatenation of _labelSet_ and « _label_ ».\n  1. Let _stmtResult_ be Completion(LabelledEvaluation of |LabelledItem| with argument _newLabelSet_).\n  1. If _stmtResult_ is a break completion and _stmtResult_.[[Target]] is _label_, then\n    1. Set _stmtResult_ to NormalCompletion(_stmtResult_.[[Value]]).\n  1. Return ? _stmtResult_.","code":"\n        1. Let _label_ be the StringValue of |LabelIdentifier|.\n        1. Let _newLabelSet_ be the list-concatenation of _labelSet_ and « _label_ ».\n        1. Let _stmtResult_ be Completion(LabelledEvaluation of |LabelledItem| with argument _newLabelSet_).\n        1. If _stmtResult_ is a break completion and _stmtResult_.[[Target]] is _label_, then\n          1. Set _stmtResult_ to NormalCompletion(_stmtResult_.[[Value]]).\n        1. Return ? _stmtResult_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LabelledItem","idx":1,"subIdx":0,"rhsParams":[{"name":"FunctionDeclaration","ty":"Ast[FunctionDeclaration]","kind":{"Normal":{}}}]},"methodName":"LabelledEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Return ? the result of evaluating |FunctionDeclaration|.","code":"\n        1. Return ? Evaluation of |FunctionDeclaration|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":0,"subIdx":0,"rhsParams":[{"name":"BlockStatement","ty":"Ast[BlockStatement]","kind":{"Normal":{}}}]},"methodName":"LabelledEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Return ? the result of evaluating |Statement|.","code":"\n        1. Return ? Evaluation of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":1,"subIdx":0,"rhsParams":[{"name":"VariableStatement","ty":"Ast[VariableStatement]","kind":{"Normal":{}}}]},"methodName":"LabelledEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Return ? the result of evaluating |Statement|.","code":"\n        1. Return ? Evaluation of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":2,"subIdx":0,"rhsParams":[{"name":"EmptyStatement","ty":"Ast[EmptyStatement]","kind":{"Normal":{}}}]},"methodName":"LabelledEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Return ? the result of evaluating |Statement|.","code":"\n        1. Return ? Evaluation of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":3,"subIdx":0,"rhsParams":[{"name":"ExpressionStatement","ty":"Ast[ExpressionStatement]","kind":{"Normal":{}}}]},"methodName":"LabelledEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Return ? the result of evaluating |Statement|.","code":"\n        1. Return ? Evaluation of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":4,"subIdx":0,"rhsParams":[{"name":"IfStatement","ty":"Ast[IfStatement]","kind":{"Normal":{}}}]},"methodName":"LabelledEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Return ? the result of evaluating |Statement|.","code":"\n        1. Return ? Evaluation of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":6,"subIdx":0,"rhsParams":[{"name":"ContinueStatement","ty":"Ast[ContinueStatement]","kind":{"Normal":{}}}]},"methodName":"LabelledEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Return ? the result of evaluating |Statement|.","code":"\n        1. Return ? Evaluation of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":7,"subIdx":0,"rhsParams":[{"name":"BreakStatement","ty":"Ast[BreakStatement]","kind":{"Normal":{}}}]},"methodName":"LabelledEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Return ? the result of evaluating |Statement|.","code":"\n        1. Return ? Evaluation of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":8,"subIdx":0,"rhsParams":[{"name":"ReturnStatement","ty":"Ast[ReturnStatement]","kind":{"Normal":{}}}]},"methodName":"LabelledEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Return ? the result of evaluating |Statement|.","code":"\n        1. Return ? Evaluation of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":9,"subIdx":0,"rhsParams":[{"name":"WithStatement","ty":"Ast[WithStatement]","kind":{"Normal":{}}}]},"methodName":"LabelledEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Return ? the result of evaluating |Statement|.","code":"\n        1. Return ? Evaluation of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":11,"subIdx":0,"rhsParams":[{"name":"ThrowStatement","ty":"Ast[ThrowStatement]","kind":{"Normal":{}}}]},"methodName":"LabelledEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Return ? the result of evaluating |Statement|.","code":"\n        1. Return ? Evaluation of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":12,"subIdx":0,"rhsParams":[{"name":"TryStatement","ty":"Ast[TryStatement]","kind":{"Normal":{}}}]},"methodName":"LabelledEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Return ? the result of evaluating |Statement|.","code":"\n        1. Return ? Evaluation of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":13,"subIdx":0,"rhsParams":[{"name":"DebuggerStatement","ty":"Ast[DebuggerStatement]","kind":{"Normal":{}}}]},"methodName":"LabelledEvaluation","isStatic":false,"withParams":[{"name":"labelSet","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Return ? the result of evaluating |Statement|.","code":"\n        1. Return ? Evaluation of |Statement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ThrowStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _exprRef_ be ? the result of evaluating |Expression|.\n  1. Let _exprValue_ be ? GetValue(_exprRef_).\n  1. Return ThrowCompletion(_exprValue_).","code":"\n        1. Let _exprRef_ be ? Evaluation of |Expression|.\n        1. Let _exprValue_ be ? GetValue(_exprRef_).\n        1. Return ThrowCompletion(_exprValue_).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Catch","idx":0,"subIdx":0,"rhsParams":[{"name":"CatchParameter","ty":"Ast[CatchParameter]","kind":{"Normal":{}}},{"name":"Block","ty":"Ast[Block]","kind":{"Normal":{}}}]},"methodName":"CatchClauseEvaluation","isStatic":false,"withParams":[{"name":"thrownValue","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _oldEnv_ be the running execution context.LexicalEnvironment.\n  1. Let _catchEnv_ be NewDeclarativeEnvironment(_oldEnv_).\n  1. For each _argName_ of BoundNames of |CatchParameter|, do\n    1. Perform ! _catchEnv_.CreateMutableBinding(_argName_, *false*).\n  1. Set the running execution context.LexicalEnvironment to _catchEnv_.\n  1. Let _status_ be Completion(BindingInitialization of |CatchParameter| with arguments _thrownValue_ and _catchEnv_).\n  1. If _status_ is an abrupt completion, then\n    1. Set the running execution context.LexicalEnvironment to _oldEnv_.\n    1. Return ? _status_.\n  1. Let _B_ be Completion(the result of evaluating |Block|).\n  1. Set the running execution context.LexicalEnvironment to _oldEnv_.\n  1. Return ? _B_.","code":"\n        1. Let _oldEnv_ be the running execution context's LexicalEnvironment.\n        1. Let _catchEnv_ be NewDeclarativeEnvironment(_oldEnv_).\n        1. For each element _argName_ of the BoundNames of |CatchParameter|, do\n          1. Perform ! _catchEnv_.CreateMutableBinding(_argName_, *false*).\n        1. Set the running execution context's LexicalEnvironment to _catchEnv_.\n        1. Let _status_ be Completion(BindingInitialization of |CatchParameter| with arguments _thrownValue_ and _catchEnv_).\n        1. If _status_ is an abrupt completion, then\n          1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n          1. Return ? _status_.\n        1. Let _B_ be Completion(Evaluation of |Block|).\n        1. Set the running execution context's LexicalEnvironment to _oldEnv_.\n        1. Return ? _B_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Catch","idx":1,"subIdx":0,"rhsParams":[{"name":"Block","ty":"Ast[Block]","kind":{"Normal":{}}}]},"methodName":"CatchClauseEvaluation","isStatic":false,"withParams":[{"name":"thrownValue","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Return ? the result of evaluating |Block|.","code":"\n        1. Return ? Evaluation of |Block|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TryStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Block","ty":"Ast[Block]","kind":{"Normal":{}}},{"name":"Catch","ty":"Ast[Catch]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _B_ be Completion(the result of evaluating |Block|).\n  1. If _B_ is a throw completion, let _C_ be Completion(CatchClauseEvaluation of |Catch| with argument _B_.[[Value]]).\n  1. Else, let _C_ be _B_.\n  1. Return ? UpdateEmpty(_C_, *undefined*).","code":"\n        1. Let _B_ be Completion(Evaluation of |Block|).\n        1. If _B_ is a throw completion, let _C_ be Completion(CatchClauseEvaluation of |Catch| with argument _B_.[[Value]]).\n        1. Else, let _C_ be _B_.\n        1. Return ? UpdateEmpty(_C_, *undefined*).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TryStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"Block","ty":"Ast[Block]","kind":{"Normal":{}}},{"name":"Finally","ty":"Ast[Finally]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _B_ be Completion(the result of evaluating |Block|).\n  1. Let _F_ be Completion(the result of evaluating |Finally|).\n  1. If _F_ is a normal completion, set _F_ to _B_.\n  1. Return ? UpdateEmpty(_F_, *undefined*).","code":"\n        1. Let _B_ be Completion(Evaluation of |Block|).\n        1. Let _F_ be Completion(Evaluation of |Finally|).\n        1. If _F_ is a normal completion, set _F_ to _B_.\n        1. Return ? UpdateEmpty(_F_, *undefined*).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TryStatement","idx":2,"subIdx":0,"rhsParams":[{"name":"Block","ty":"Ast[Block]","kind":{"Normal":{}}},{"name":"Catch","ty":"Ast[Catch]","kind":{"Normal":{}}},{"name":"Finally","ty":"Ast[Finally]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _B_ be Completion(the result of evaluating |Block|).\n  1. If _B_ is a throw completion, let _C_ be Completion(CatchClauseEvaluation of |Catch| with argument _B_.[[Value]]).\n  1. Else, let _C_ be _B_.\n  1. Let _F_ be Completion(the result of evaluating |Finally|).\n  1. If _F_ is a normal completion, set _F_ to _C_.\n  1. Return ? UpdateEmpty(_F_, *undefined*).","code":"\n        1. Let _B_ be Completion(Evaluation of |Block|).\n        1. If _B_ is a throw completion, let _C_ be Completion(CatchClauseEvaluation of |Catch| with argument _B_.[[Value]]).\n        1. Else, let _C_ be _B_.\n        1. Let _F_ be Completion(Evaluation of |Finally|).\n        1. If _F_ is a normal completion, set _F_ to _C_.\n        1. Return ? UpdateEmpty(_F_, *undefined*).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DebuggerStatement","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. If an implementation-defined debugging facility is available and enabled, then\n    1. Perform an implementation-defined debugging action.\n    1. Return a new implementation-defined Completion Record.\n  1. Else,\n    1. Return ~empty~.","code":"\n        1. If an implementation-defined debugging facility is available and enabled, then\n          1. Perform an implementation-defined debugging action.\n          1. Return a new implementation-defined Completion Record.\n        1. Else,\n          1. Return ~empty~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ObjectBindingPattern","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"ContainsExpression","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ObjectBindingPattern","idx":1,"subIdx":0,"rhsParams":[{"name":"BindingRestProperty","ty":"Ast[BindingRestProperty]","kind":{"Normal":{}}}]},"methodName":"ContainsExpression","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ObjectBindingPattern","idx":3,"subIdx":1,"rhsParams":[{"name":"BindingPropertyList","ty":"Ast[BindingPropertyList]","kind":{"Normal":{}}},{"name":"BindingRestProperty","ty":"Ast[BindingRestProperty]","kind":{"Normal":{}}}]},"methodName":"ContainsExpression","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return ContainsExpression of |BindingPropertyList|.","code":"\n        1. Return ContainsExpression of |BindingPropertyList|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayBindingPattern","idx":0,"subIdx":0,"rhsParams":[{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}}]},"methodName":"ContainsExpression","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayBindingPattern","idx":0,"subIdx":2,"rhsParams":[{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}}]},"methodName":"ContainsExpression","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayBindingPattern","idx":0,"subIdx":1,"rhsParams":[{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"BindingRestElement","ty":"Ast[BindingRestElement]","kind":{"Normal":{}}}]},"methodName":"ContainsExpression","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return ContainsExpression of |BindingRestElement|.","code":"\n        1. Return ContainsExpression of |BindingRestElement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayBindingPattern","idx":0,"subIdx":3,"rhsParams":[{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"BindingRestElement","ty":"Ast[BindingRestElement]","kind":{"Normal":{}}}]},"methodName":"ContainsExpression","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return ContainsExpression of |BindingRestElement|.","code":"\n        1. Return ContainsExpression of |BindingRestElement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayBindingPattern","idx":2,"subIdx":0,"rhsParams":[{"name":"BindingElementList","ty":"Ast[BindingElementList]","kind":{"Normal":{}}},{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}}]},"methodName":"ContainsExpression","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return ContainsExpression of |BindingElementList|.","code":"\n        1. Return ContainsExpression of |BindingElementList|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayBindingPattern","idx":2,"subIdx":2,"rhsParams":[{"name":"BindingElementList","ty":"Ast[BindingElementList]","kind":{"Normal":{}}},{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}}]},"methodName":"ContainsExpression","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return ContainsExpression of |BindingElementList|.","code":"\n        1. Return ContainsExpression of |BindingElementList|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayBindingPattern","idx":2,"subIdx":1,"rhsParams":[{"name":"BindingElementList","ty":"Ast[BindingElementList]","kind":{"Normal":{}}},{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"BindingRestElement","ty":"Ast[BindingRestElement]","kind":{"Normal":{}}}]},"methodName":"ContainsExpression","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Let _has_ be ContainsExpression of |BindingElementList|.\n  1. If _has_ is *true*, return *true*.\n  1. Return ContainsExpression of |BindingRestElement|.","code":"\n        1. Let _has_ be ContainsExpression of |BindingElementList|.\n        1. If _has_ is *true*, return *true*.\n        1. Return ContainsExpression of |BindingRestElement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrayBindingPattern","idx":2,"subIdx":3,"rhsParams":[{"name":"BindingElementList","ty":"Ast[BindingElementList]","kind":{"Normal":{}}},{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"BindingRestElement","ty":"Ast[BindingRestElement]","kind":{"Normal":{}}}]},"methodName":"ContainsExpression","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Let _has_ be ContainsExpression of |BindingElementList|.\n  1. If _has_ is *true*, return *true*.\n  1. Return ContainsExpression of |BindingRestElement|.","code":"\n        1. Let _has_ be ContainsExpression of |BindingElementList|.\n        1. If _has_ is *true*, return *true*.\n        1. Return ContainsExpression of |BindingRestElement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingPropertyList","idx":1,"subIdx":0,"rhsParams":[{"name":"BindingPropertyList","ty":"Ast[BindingPropertyList]","kind":{"Normal":{}}},{"name":"BindingProperty","ty":"Ast[BindingProperty]","kind":{"Normal":{}}}]},"methodName":"ContainsExpression","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Let _has_ be ContainsExpression of |BindingPropertyList|.\n  1. If _has_ is *true*, return *true*.\n  1. Return ContainsExpression of |BindingProperty|.","code":"\n        1. Let _has_ be ContainsExpression of |BindingPropertyList|.\n        1. If _has_ is *true*, return *true*.\n        1. Return ContainsExpression of |BindingProperty|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingElementList","idx":1,"subIdx":0,"rhsParams":[{"name":"BindingElementList","ty":"Ast[BindingElementList]","kind":{"Normal":{}}},{"name":"BindingElisionElement","ty":"Ast[BindingElisionElement]","kind":{"Normal":{}}}]},"methodName":"ContainsExpression","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Let _has_ be ContainsExpression of |BindingElementList|.\n  1. If _has_ is *true*, return *true*.\n  1. Return ContainsExpression of |BindingElisionElement|.","code":"\n        1. Let _has_ be ContainsExpression of |BindingElementList|.\n        1. If _has_ is *true*, return *true*.\n        1. Return ContainsExpression of |BindingElisionElement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingElisionElement","idx":0,"subIdx":0,"rhsParams":[{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"BindingElement","ty":"Ast[BindingElement]","kind":{"Normal":{}}}]},"methodName":"ContainsExpression","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return ContainsExpression of |BindingElement|.","code":"\n        1. Return ContainsExpression of |BindingElement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingElisionElement","idx":0,"subIdx":1,"rhsParams":[{"name":"Elision","ty":"Ast[Elision]","kind":{"Normal":{}}},{"name":"BindingElement","ty":"Ast[BindingElement]","kind":{"Normal":{}}}]},"methodName":"ContainsExpression","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return ContainsExpression of |BindingElement|.","code":"\n        1. Return ContainsExpression of |BindingElement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingProperty","idx":1,"subIdx":0,"rhsParams":[{"name":"PropertyName","ty":"Ast[PropertyName]","kind":{"Normal":{}}},{"name":"BindingElement","ty":"Ast[BindingElement]","kind":{"Normal":{}}}]},"methodName":"ContainsExpression","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Let _has_ be IsComputedPropertyKey of |PropertyName|.\n  1. If _has_ is *true*, return *true*.\n  1. Return ContainsExpression of |BindingElement|.","code":"\n        1. Let _has_ be IsComputedPropertyKey of |PropertyName|.\n        1. If _has_ is *true*, return *true*.\n        1. Return ContainsExpression of |BindingElement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingElement","idx":1,"subIdx":1,"rhsParams":[{"name":"BindingPattern","ty":"Ast[BindingPattern]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"ContainsExpression","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"SingleNameBinding","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}}]},"methodName":"ContainsExpression","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"SingleNameBinding","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"ContainsExpression","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingRestElement","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}}]},"methodName":"ContainsExpression","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingRestElement","idx":1,"subIdx":0,"rhsParams":[{"name":"BindingPattern","ty":"Ast[BindingPattern]","kind":{"Normal":{}}}]},"methodName":"ContainsExpression","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return ContainsExpression of |BindingPattern|.","code":"\n        1. Return ContainsExpression of |BindingPattern|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FormalParameters","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"ContainsExpression","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FormalParameters","idx":4,"subIdx":0,"rhsParams":[{"name":"FormalParameterList","ty":"Ast[FormalParameterList]","kind":{"Normal":{}}},{"name":"FunctionRestParameter","ty":"Ast[FunctionRestParameter]","kind":{"Normal":{}}}]},"methodName":"ContainsExpression","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. If ContainsExpression of |FormalParameterList| is *true*, return *true*.\n  1. Return ContainsExpression of |FunctionRestParameter|.","code":"\n        1. If ContainsExpression of |FormalParameterList| is *true*, return *true*.\n        1. Return ContainsExpression of |FunctionRestParameter|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FormalParameterList","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameterList","ty":"Ast[FormalParameterList]","kind":{"Normal":{}}},{"name":"FormalParameter","ty":"Ast[FormalParameter]","kind":{"Normal":{}}}]},"methodName":"ContainsExpression","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. If ContainsExpression of |FormalParameterList| is *true*, return *true*.\n  1. Return ContainsExpression of |FormalParameter|.","code":"\n        1. If ContainsExpression of |FormalParameterList| is *true*, return *true*.\n        1. Return ContainsExpression of |FormalParameter|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrowParameters","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}}]},"methodName":"ContainsExpression","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrowParameters","idx":1,"subIdx":0,"rhsParams":[{"name":"CoverParenthesizedExpressionAndArrowParameterList","ty":"Ast[CoverParenthesizedExpressionAndArrowParameterList]","kind":{"Normal":{}}}]},"methodName":"ContainsExpression","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Let _formals_ be the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n  1. Return ContainsExpression of _formals_.","code":"\n        1. Let _formals_ be the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n        1. Return ContainsExpression of _formals_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncArrowBindingIdentifier","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}}]},"methodName":"ContainsExpression","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingElement","idx":1,"subIdx":0,"rhsParams":[{"name":"BindingPattern","ty":"Ast[BindingPattern]","kind":{"Normal":{}}}]},"methodName":"IsSimpleParameterList","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingElement","idx":1,"subIdx":1,"rhsParams":[{"name":"BindingPattern","ty":"Ast[BindingPattern]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"IsSimpleParameterList","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"SingleNameBinding","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}}]},"methodName":"IsSimpleParameterList","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"SingleNameBinding","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"IsSimpleParameterList","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FormalParameters","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"IsSimpleParameterList","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FormalParameters","idx":1,"subIdx":0,"rhsParams":[{"name":"FunctionRestParameter","ty":"Ast[FunctionRestParameter]","kind":{"Normal":{}}}]},"methodName":"IsSimpleParameterList","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FormalParameters","idx":4,"subIdx":0,"rhsParams":[{"name":"FormalParameterList","ty":"Ast[FormalParameterList]","kind":{"Normal":{}}},{"name":"FunctionRestParameter","ty":"Ast[FunctionRestParameter]","kind":{"Normal":{}}}]},"methodName":"IsSimpleParameterList","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FormalParameterList","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameterList","ty":"Ast[FormalParameterList]","kind":{"Normal":{}}},{"name":"FormalParameter","ty":"Ast[FormalParameter]","kind":{"Normal":{}}}]},"methodName":"IsSimpleParameterList","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. If IsSimpleParameterList of |FormalParameterList| is *false*, return *false*.\n  1. Return IsSimpleParameterList of |FormalParameter|.","code":"\n        1. If IsSimpleParameterList of |FormalParameterList| is *false*, return *false*.\n        1. Return IsSimpleParameterList of |FormalParameter|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FormalParameter","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingElement","ty":"Ast[BindingElement]","kind":{"Normal":{}}}]},"methodName":"IsSimpleParameterList","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return IsSimpleParameterList of |BindingElement|.","code":"\n        1. Return IsSimpleParameterList of |BindingElement|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrowParameters","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}}]},"methodName":"IsSimpleParameterList","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrowParameters","idx":1,"subIdx":0,"rhsParams":[{"name":"CoverParenthesizedExpressionAndArrowParameterList","ty":"Ast[CoverParenthesizedExpressionAndArrowParameterList]","kind":{"Normal":{}}}]},"methodName":"IsSimpleParameterList","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Let _formals_ be the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n  1. Return IsSimpleParameterList of _formals_.","code":"\n        1. Let _formals_ be the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n        1. Return IsSimpleParameterList of _formals_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncArrowBindingIdentifier","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}}]},"methodName":"IsSimpleParameterList","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CoverCallExpressionAndAsyncArrowHead","idx":0,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"Arguments","ty":"Ast[Arguments]","kind":{"Normal":{}}}]},"methodName":"IsSimpleParameterList","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Let _head_ be the |AsyncArrowHead| that is covered by |CoverCallExpressionAndAsyncArrowHead|.\n  1. Return IsSimpleParameterList of _head_.","code":"\n        1. Let _head_ be the |AsyncArrowHead| that is covered by |CoverCallExpressionAndAsyncArrowHead|.\n        1. Return IsSimpleParameterList of _head_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingElement","idx":1,"subIdx":0,"rhsParams":[{"name":"BindingPattern","ty":"Ast[BindingPattern]","kind":{"Normal":{}}}]},"methodName":"HasInitializer","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BindingElement","idx":1,"subIdx":1,"rhsParams":[{"name":"BindingPattern","ty":"Ast[BindingPattern]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"HasInitializer","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"SingleNameBinding","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}}]},"methodName":"HasInitializer","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"SingleNameBinding","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"HasInitializer","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FormalParameterList","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameterList","ty":"Ast[FormalParameterList]","kind":{"Normal":{}}},{"name":"FormalParameter","ty":"Ast[FormalParameter]","kind":{"Normal":{}}}]},"methodName":"HasInitializer","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. If HasInitializer of |FormalParameterList| is *true*, return *true*.\n  1. Return HasInitializer of |FormalParameter|.","code":"\n        1. If HasInitializer of |FormalParameterList| is *true*, return *true*.\n        1. Return HasInitializer of |FormalParameter|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FormalParameters","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"ExpectedArgumentCount","isStatic":true,"withParams":[],"retTy":"Int"}},"body":"\n  1. Return 0.","code":"\n        1. Return 0.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FormalParameters","idx":1,"subIdx":0,"rhsParams":[{"name":"FunctionRestParameter","ty":"Ast[FunctionRestParameter]","kind":{"Normal":{}}}]},"methodName":"ExpectedArgumentCount","isStatic":true,"withParams":[],"retTy":"Int"}},"body":"\n  1. Return 0.","code":"\n        1. Return 0.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FormalParameters","idx":4,"subIdx":0,"rhsParams":[{"name":"FormalParameterList","ty":"Ast[FormalParameterList]","kind":{"Normal":{}}},{"name":"FunctionRestParameter","ty":"Ast[FunctionRestParameter]","kind":{"Normal":{}}}]},"methodName":"ExpectedArgumentCount","isStatic":true,"withParams":[],"retTy":"Int"}},"body":"\n  1. Return ExpectedArgumentCount of |FormalParameterList|.","code":"\n        1. Return ExpectedArgumentCount of |FormalParameterList|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FormalParameterList","idx":0,"subIdx":0,"rhsParams":[{"name":"FormalParameter","ty":"Ast[FormalParameter]","kind":{"Normal":{}}}]},"methodName":"ExpectedArgumentCount","isStatic":true,"withParams":[],"retTy":"Int"}},"body":"\n  1. If HasInitializer of |FormalParameter| is *true*, return 0.\n  1. Return 1.","code":"\n        1. If HasInitializer of |FormalParameter| is *true*, return 0.\n        1. Return 1.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FormalParameterList","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameterList","ty":"Ast[FormalParameterList]","kind":{"Normal":{}}},{"name":"FormalParameter","ty":"Ast[FormalParameter]","kind":{"Normal":{}}}]},"methodName":"ExpectedArgumentCount","isStatic":true,"withParams":[],"retTy":"Int"}},"body":"\n  1. Let _count_ be ExpectedArgumentCount of |FormalParameterList|.\n  1. If HasInitializer of |FormalParameterList| is *true* or HasInitializer of |FormalParameter| is *true*, return _count_.\n  1. Return _count_ + 1.","code":"\n        1. Let _count_ be ExpectedArgumentCount of |FormalParameterList|.\n        1. If HasInitializer of |FormalParameterList| is *true* or HasInitializer of |FormalParameter| is *true*, return _count_.\n        1. Return _count_ + 1.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrowParameters","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}}]},"methodName":"ExpectedArgumentCount","isStatic":true,"withParams":[],"retTy":"Int"}},"body":"\n  1. Return 1.","code":"\n        1. Return 1.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrowParameters","idx":1,"subIdx":0,"rhsParams":[{"name":"CoverParenthesizedExpressionAndArrowParameterList","ty":"Ast[CoverParenthesizedExpressionAndArrowParameterList]","kind":{"Normal":{}}}]},"methodName":"ExpectedArgumentCount","isStatic":true,"withParams":[],"retTy":"Int"}},"body":"\n  1. Let _formals_ be the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n  1. Return ExpectedArgumentCount of _formals_.","code":"\n        1. Let _formals_ be the |ArrowFormalParameters| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n        1. Return ExpectedArgumentCount of _formals_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PropertySetParameterList","idx":0,"subIdx":0,"rhsParams":[{"name":"FormalParameter","ty":"Ast[FormalParameter]","kind":{"Normal":{}}}]},"methodName":"ExpectedArgumentCount","isStatic":true,"withParams":[],"retTy":"Int"}},"body":"\n  1. If HasInitializer of |FormalParameter| is *true*, return 0.\n  1. Return 1.","code":"\n        1. If HasInitializer of |FormalParameter| is *true*, return 0.\n        1. Return 1.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncArrowBindingIdentifier","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}}]},"methodName":"ExpectedArgumentCount","isStatic":true,"withParams":[],"retTy":"Int"}},"body":"\n  1. Return 1.","code":"\n        1. Return 1.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionBody","idx":0,"subIdx":0,"rhsParams":[{"name":"FunctionStatementList","ty":"Ast[FunctionStatementList]","kind":{"Normal":{}}}]},"methodName":"FunctionBodyContainsUseStrict","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. If the Directive Prologue of |FunctionBody| contains a Use Strict Directive, return *true*; otherwise, return *false*.","code":"\n        1. If the Directive Prologue of |FunctionBody| contains a Use Strict Directive, return *true*; otherwise, return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionBody","idx":0,"subIdx":0,"rhsParams":[{"name":"FunctionStatementList","ty":"Ast[FunctionStatementList]","kind":{"Normal":{}}}]},"methodName":"EvaluateFunctionBody","isStatic":false,"withParams":[{"name":"functionObject","ty":"Record[ECMAScriptFunctionObject]","kind":{"Normal":{}}},{"name":"argumentsList","ty":"List[ESValue]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).\n  1. Return ? the result of evaluating |FunctionStatementList|.","code":"\n        1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).\n        1. Return ? Evaluation of |FunctionStatementList|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"InstantiateOrdinaryFunctionObject","isStatic":false,"withParams":[{"name":"env","ty":"Record[EnvironmentRecord]","kind":{"Normal":{}}},{"name":"privateEnv","ty":"Record[PrivateEnvironmentRecord] | Null","kind":{"Normal":{}}}],"retTy":"Record[ECMAScriptFunctionObject]"}},"body":"\n  1. Let _name_ be StringValue of |BindingIdentifier|.\n  1. Let _sourceText_ be the source text matched by |FunctionDeclaration|.\n  1. Let _F_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n  1. Perform SetFunctionName(_F_, _name_).\n  1. Perform MakeConstructor(_F_).\n  1. Return _F_.","code":"\n        1. Let _name_ be StringValue of |BindingIdentifier|.\n        1. Let _sourceText_ be the source text matched by |FunctionDeclaration|.\n        1. Let _F_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_F_, _name_).\n        1. Perform MakeConstructor(_F_).\n        1. Return _F_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"InstantiateOrdinaryFunctionObject","isStatic":false,"withParams":[{"name":"env","ty":"Record[EnvironmentRecord]","kind":{"Normal":{}}},{"name":"privateEnv","ty":"Record[PrivateEnvironmentRecord] | Null","kind":{"Normal":{}}}],"retTy":"Record[ECMAScriptFunctionObject]"}},"body":"\n  1. Let _sourceText_ be the source text matched by |FunctionDeclaration|.\n  1. Let _F_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n  1. Perform SetFunctionName(_F_, *\"default\"*).\n  1. Perform MakeConstructor(_F_).\n  1. Return _F_.","code":"\n        1. Let _sourceText_ be the source text matched by |FunctionDeclaration|.\n        1. Let _F_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_F_, *\"default\"*).\n        1. Perform MakeConstructor(_F_).\n        1. Return _F_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"InstantiateOrdinaryFunctionExpression","isStatic":false,"withParams":[{"name":"name","ty":"Record[PrivateName | Symbol] | String","kind":{"Optional":{}}}],"retTy":"Record[ECMAScriptFunctionObject]"}},"body":"\n  1. If _name_ is not present, set _name_ to *\"\"*.\n  1. Let _env_ be the running execution context.LexicalEnvironment.\n  1. Let _privateEnv_ be the running execution context.PrivateEnvironment.\n  1. Let _sourceText_ be the source text matched by |FunctionExpression|.\n  1. Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n  1. Perform SetFunctionName(_closure_, _name_).\n  1. Perform MakeConstructor(_closure_).\n  1. Return _closure_.","code":"\n        1. If _name_ is not present, set _name_ to *\"\"*.\n        1. Let _env_ be the LexicalEnvironment of the running execution context.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |FunctionExpression|.\n        1. Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_closure_, _name_).\n        1. Perform MakeConstructor(_closure_).\n        1. Return _closure_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionExpression","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"InstantiateOrdinaryFunctionExpression","isStatic":false,"withParams":[{"name":"name","ty":"Record[PrivateName | Symbol] | String","kind":{"Optional":{}}}],"retTy":"Record[ECMAScriptFunctionObject]"}},"body":"\n  1. Assert: _name_ is not present.\n  1. Set _name_ to StringValue of |BindingIdentifier|.\n  1. Let _outerEnv_ be the running execution context.LexicalEnvironment.\n  1. Let _funcEnv_ be NewDeclarativeEnvironment(_outerEnv_).\n  1. Perform ! _funcEnv_.CreateImmutableBinding(_name_, *false*).\n  1. Let _privateEnv_ be the running execution context.PrivateEnvironment.\n  1. Let _sourceText_ be the source text matched by |FunctionExpression|.\n  1. Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_).\n  1. Perform SetFunctionName(_closure_, _name_).\n  1. Perform MakeConstructor(_closure_).\n  1. Perform ! _funcEnv_.InitializeBinding(_name_, _closure_).\n  1. Return _closure_.","code":"\n        1. Assert: _name_ is not present.\n        1. Set _name_ to StringValue of |BindingIdentifier|.\n        1. Let _outerEnv_ be the running execution context's LexicalEnvironment.\n        1. Let _funcEnv_ be NewDeclarativeEnvironment(_outerEnv_).\n        1. Perform ! _funcEnv_.CreateImmutableBinding(_name_, *false*).\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |FunctionExpression|.\n        1. Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |FormalParameters|, |FunctionBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_).\n        1. Perform SetFunctionName(_closure_, _name_).\n        1. Perform MakeConstructor(_closure_).\n        1. Perform ! _funcEnv_.InitializeBinding(_name_, _closure_).\n        1. Return _closure_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ~empty~.","code":"\n        1. Return ~empty~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ~empty~.","code":"\n        1. Return ~empty~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return InstantiateOrdinaryFunctionExpression of |FunctionExpression|.","code":"\n        1. Return InstantiateOrdinaryFunctionExpression of |FunctionExpression|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionExpression","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return InstantiateOrdinaryFunctionExpression of |FunctionExpression|.","code":"\n        1. Return InstantiateOrdinaryFunctionExpression of |FunctionExpression|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionStatementList","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return *undefined*.","code":"\n        1. Return *undefined*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ConciseBody","idx":0,"subIdx":0,"rhsParams":[{"name":"ExpressionBody","ty":"Ast[ExpressionBody]","kind":{"Normal":{}}}]},"methodName":"ConciseBodyContainsUseStrict","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ConciseBody","idx":1,"subIdx":0,"rhsParams":[{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"ConciseBodyContainsUseStrict","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return FunctionBodyContainsUseStrict of |FunctionBody|.","code":"\n        1. Return FunctionBodyContainsUseStrict of |FunctionBody|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ConciseBody","idx":0,"subIdx":0,"rhsParams":[{"name":"ExpressionBody","ty":"Ast[ExpressionBody]","kind":{"Normal":{}}}]},"methodName":"EvaluateConciseBody","isStatic":false,"withParams":[{"name":"functionObject","ty":"Record[ECMAScriptFunctionObject]","kind":{"Normal":{}}},{"name":"argumentsList","ty":"List[ESValue]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).\n  1. Return ? the result of evaluating |ExpressionBody|.","code":"\n        1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).\n        1. Return ? Evaluation of |ExpressionBody|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrowFunction","idx":0,"subIdx":0,"rhsParams":[{"name":"ArrowParameters","ty":"Ast[ArrowParameters]","kind":{"Normal":{}}},{"name":"ConciseBody","ty":"Ast[ConciseBody]","kind":{"Normal":{}}}]},"methodName":"InstantiateArrowFunctionExpression","isStatic":false,"withParams":[{"name":"name","ty":"Record[PrivateName | Symbol] | String","kind":{"Optional":{}}}],"retTy":"Record[ECMAScriptFunctionObject]"}},"body":"\n  1. If _name_ is not present, set _name_ to *\"\"*.\n  1. Let _env_ be the running execution context.LexicalEnvironment.\n  1. Let _privateEnv_ be the running execution context.PrivateEnvironment.\n  1. Let _sourceText_ be the source text matched by |ArrowFunction|.\n  1. [id=\"step-arrowfunction-evaluation-functioncreate\"] Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |ArrowParameters|, |ConciseBody|, ~lexical-this~, _env_, _privateEnv_).\n  1. Perform SetFunctionName(_closure_, _name_).\n  1. Return _closure_.","code":"\n        1. If _name_ is not present, set _name_ to *\"\"*.\n        1. Let _env_ be the LexicalEnvironment of the running execution context.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |ArrowFunction|.\n        1. [id=\"step-arrowfunction-evaluation-functioncreate\"] Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |ArrowParameters|, |ConciseBody|, ~lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_closure_, _name_).\n        1. Return _closure_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ArrowFunction","idx":0,"subIdx":0,"rhsParams":[{"name":"ArrowParameters","ty":"Ast[ArrowParameters]","kind":{"Normal":{}}},{"name":"ConciseBody","ty":"Ast[ConciseBody]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return InstantiateArrowFunctionExpression of |ArrowFunction|.","code":"\n        1. Return InstantiateArrowFunctionExpression of |ArrowFunction|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExpressionBody","idx":0,"subIdx":0,"rhsParams":[{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _exprRef_ be ? the result of evaluating |AssignmentExpression|.\n  1. Let _exprValue_ be ? GetValue(_exprRef_).\n  1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _exprValue_, [[Target]]: ~empty~ }.","code":"\n        1. Let _exprRef_ be ? Evaluation of |AssignmentExpression|.\n        1. Let _exprValue_ be ? GetValue(_exprRef_).\n        1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _exprValue_, [[Target]]: ~empty~ }.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MethodDefinition","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"UniqueFormalParameters","ty":"Ast[UniqueFormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"HasDirectSuper","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. If |UniqueFormalParameters| Contains |SuperCall| is *true*, return *true*.\n  1. Return |FunctionBody| Contains |SuperCall|.","code":"\n        1. If |UniqueFormalParameters| Contains |SuperCall| is *true*, return *true*.\n        1. Return |FunctionBody| Contains |SuperCall|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MethodDefinition","idx":4,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"HasDirectSuper","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return |FunctionBody| Contains |SuperCall|.","code":"\n        1. Return |FunctionBody| Contains |SuperCall|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MethodDefinition","idx":5,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"PropertySetParameterList","ty":"Ast[PropertySetParameterList]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"HasDirectSuper","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. If |PropertySetParameterList| Contains |SuperCall| is *true*, return *true*.\n  1. Return |FunctionBody| Contains |SuperCall|.","code":"\n        1. If |PropertySetParameterList| Contains |SuperCall| is *true*, return *true*.\n        1. Return |FunctionBody| Contains |SuperCall|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorMethod","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"UniqueFormalParameters","ty":"Ast[UniqueFormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"HasDirectSuper","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. If |UniqueFormalParameters| Contains |SuperCall| is *true*, return *true*.\n  1. Return |GeneratorBody| Contains |SuperCall|.","code":"\n        1. If |UniqueFormalParameters| Contains |SuperCall| is *true*, return *true*.\n        1. Return |GeneratorBody| Contains |SuperCall|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorMethod","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"UniqueFormalParameters","ty":"Ast[UniqueFormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"HasDirectSuper","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. If |UniqueFormalParameters| Contains |SuperCall| is *true*, return *true*.\n  1. Return |AsyncGeneratorBody| Contains |SuperCall|.","code":"\n        1. If |UniqueFormalParameters| Contains |SuperCall| is *true*, return *true*.\n        1. Return |AsyncGeneratorBody| Contains |SuperCall|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncMethod","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"UniqueFormalParameters","ty":"Ast[UniqueFormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"HasDirectSuper","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. If |UniqueFormalParameters| Contains |SuperCall| is *true*, return *true*.\n  1. Return |AsyncFunctionBody| Contains |SuperCall|.","code":"\n        1. If |UniqueFormalParameters| Contains |SuperCall| is *true*, return *true*.\n        1. Return |AsyncFunctionBody| Contains |SuperCall|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MethodDefinition","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"UniqueFormalParameters","ty":"Ast[UniqueFormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"SpecialMethod","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MethodDefinition","idx":1,"subIdx":0,"rhsParams":[{"name":"GeneratorMethod","ty":"Ast[GeneratorMethod]","kind":{"Normal":{}}}]},"methodName":"SpecialMethod","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MethodDefinition","idx":2,"subIdx":0,"rhsParams":[{"name":"AsyncMethod","ty":"Ast[AsyncMethod]","kind":{"Normal":{}}}]},"methodName":"SpecialMethod","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MethodDefinition","idx":3,"subIdx":0,"rhsParams":[{"name":"AsyncGeneratorMethod","ty":"Ast[AsyncGeneratorMethod]","kind":{"Normal":{}}}]},"methodName":"SpecialMethod","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MethodDefinition","idx":4,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"SpecialMethod","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MethodDefinition","idx":5,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"PropertySetParameterList","ty":"Ast[PropertySetParameterList]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"SpecialMethod","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MethodDefinition","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"UniqueFormalParameters","ty":"Ast[UniqueFormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"DefineMethod","isStatic":false,"withParams":[{"name":"object","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"functionPrototype","ty":"Record[Object]","kind":{"Optional":{}}}],"retTy":"Unknown[\"either a normal completion containing a Record with fields [[Key]] (a property key) and [[Closure]] (an ECMAScript function object) or an abrupt completion\"]"}},"body":"\n  1. Let _propKey_ be ? the result of evaluating |ClassElementName|.\n  1. Let _env_ be the running execution context.LexicalEnvironment.\n  1. Let _privateEnv_ be the running execution context.PrivateEnvironment.\n  1. If _functionPrototype_ is present, then\n    1. Let _prototype_ be _functionPrototype_.\n  1. Else,\n    1. Let _prototype_ be %Function.prototype%.\n  1. Let _sourceText_ be the source text matched by |MethodDefinition|.\n  1. Let _closure_ be OrdinaryFunctionCreate(_prototype_, _sourceText_, |UniqueFormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n  1. Perform MakeMethod(_closure_, _object_).\n  1. Return Record { [[Key]]: _propKey_, [[Closure]]: _closure_ }.","code":"\n        1. Let _propKey_ be ? Evaluation of |ClassElementName|.\n        1. Let _env_ be the running execution context's LexicalEnvironment.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. If _functionPrototype_ is present, then\n          1. Let _prototype_ be _functionPrototype_.\n        1. Else,\n          1. Let _prototype_ be %Function.prototype%.\n        1. Let _sourceText_ be the source text matched by |MethodDefinition|.\n        1. Let _closure_ be OrdinaryFunctionCreate(_prototype_, _sourceText_, |UniqueFormalParameters|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform MakeMethod(_closure_, _object_).\n        1. Return the Record { [[Key]]: _propKey_, [[Closure]]: _closure_ }.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MethodDefinition","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"UniqueFormalParameters","ty":"Ast[UniqueFormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"MethodDefinitionEvaluation","isStatic":false,"withParams":[{"name":"object","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"enumerable","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[Record[PrivateElement] | Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _methodDef_ be ? DefineMethod of |MethodDefinition| with argument _object_.\n  1. Perform SetFunctionName(_methodDef_.[[Closure]], _methodDef_.[[Key]]).\n  1. Return ? DefineMethodProperty(_object_, _methodDef_.[[Key]], _methodDef_.[[Closure]], _enumerable_).","code":"\n        1. Let _methodDef_ be ? DefineMethod of |MethodDefinition| with argument _object_.\n        1. Perform SetFunctionName(_methodDef_.[[Closure]], _methodDef_.[[Key]]).\n        1. Return ? DefineMethodProperty(_object_, _methodDef_.[[Key]], _methodDef_.[[Closure]], _enumerable_).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MethodDefinition","idx":4,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"MethodDefinitionEvaluation","isStatic":false,"withParams":[{"name":"object","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"enumerable","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[Record[PrivateElement] | Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _propKey_ be ? the result of evaluating |ClassElementName|.\n  1. Let _env_ be the running execution context.LexicalEnvironment.\n  1. Let _privateEnv_ be the running execution context.PrivateEnvironment.\n  1. Let _sourceText_ be the source text matched by |MethodDefinition|.\n  1. Let _formalParameterList_ be <emu-grammar>FormalParameters : [empty]</emu-grammar>.\n  1. Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _formalParameterList_, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n  1. Perform MakeMethod(_closure_, _object_).\n  1. Perform SetFunctionName(_closure_, _propKey_, *\"get\"*).\n  1. If _propKey_ is a Record[PrivateName], then\n    1. Return PrivateElement { [[Key]]: _propKey_, [[Kind]]: ~accessor~, [[Get]]: _closure_, [[Set]]: *undefined* }.\n  1. Else,\n    1. Let _desc_ be PropertyDescriptor { [[Get]]: _closure_, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.\n    1. Perform ? DefinePropertyOrThrow(_object_, _propKey_, _desc_).\n    1. Return ~unused~.","code":"\n        1. Let _propKey_ be ? Evaluation of |ClassElementName|.\n        1. Let _env_ be the running execution context's LexicalEnvironment.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |MethodDefinition|.\n        1. Let _formalParameterList_ be an instance of the production <emu-grammar>FormalParameters : [empty]</emu-grammar>.\n        1. Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _formalParameterList_, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform MakeMethod(_closure_, _object_).\n        1. Perform SetFunctionName(_closure_, _propKey_, *\"get\"*).\n        1. If _propKey_ is a Private Name, then\n          1. Return PrivateElement { [[Key]]: _propKey_, [[Kind]]: ~accessor~, [[Get]]: _closure_, [[Set]]: *undefined* }.\n        1. Else,\n          1. Let _desc_ be the PropertyDescriptor { [[Get]]: _closure_, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.\n          1. Perform ? DefinePropertyOrThrow(_object_, _propKey_, _desc_).\n          1. Return ~unused~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MethodDefinition","idx":5,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"PropertySetParameterList","ty":"Ast[PropertySetParameterList]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"MethodDefinitionEvaluation","isStatic":false,"withParams":[{"name":"object","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"enumerable","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[Record[PrivateElement] | Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _propKey_ be ? the result of evaluating |ClassElementName|.\n  1. Let _env_ be the running execution context.LexicalEnvironment.\n  1. Let _privateEnv_ be the running execution context.PrivateEnvironment.\n  1. Let _sourceText_ be the source text matched by |MethodDefinition|.\n  1. Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |PropertySetParameterList|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n  1. Perform MakeMethod(_closure_, _object_).\n  1. Perform SetFunctionName(_closure_, _propKey_, *\"set\"*).\n  1. If _propKey_ is a Record[PrivateName], then\n    1. Return PrivateElement { [[Key]]: _propKey_, [[Kind]]: ~accessor~, [[Get]]: *undefined*, [[Set]]: _closure_ }.\n  1. Else,\n    1. Let _desc_ be PropertyDescriptor { [[Set]]: _closure_, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.\n    1. Perform ? DefinePropertyOrThrow(_object_, _propKey_, _desc_).\n    1. Return ~unused~.","code":"\n        1. Let _propKey_ be ? Evaluation of |ClassElementName|.\n        1. Let _env_ be the running execution context's LexicalEnvironment.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |MethodDefinition|.\n        1. Let _closure_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, |PropertySetParameterList|, |FunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform MakeMethod(_closure_, _object_).\n        1. Perform SetFunctionName(_closure_, _propKey_, *\"set\"*).\n        1. If _propKey_ is a Private Name, then\n          1. Return PrivateElement { [[Key]]: _propKey_, [[Kind]]: ~accessor~, [[Get]]: *undefined*, [[Set]]: _closure_ }.\n        1. Else,\n          1. Let _desc_ be the PropertyDescriptor { [[Set]]: _closure_, [[Enumerable]]: _enumerable_, [[Configurable]]: *true* }.\n          1. Perform ? DefinePropertyOrThrow(_object_, _propKey_, _desc_).\n          1. Return ~unused~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorMethod","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"UniqueFormalParameters","ty":"Ast[UniqueFormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"MethodDefinitionEvaluation","isStatic":false,"withParams":[{"name":"object","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"enumerable","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[Record[PrivateElement] | Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _propKey_ be ? the result of evaluating |ClassElementName|.\n  1. Let _env_ be the running execution context.LexicalEnvironment.\n  1. Let _privateEnv_ be the running execution context.PrivateEnvironment.\n  1. Let _sourceText_ be the source text matched by |GeneratorMethod|.\n  1. Let _closure_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).\n  1. Perform MakeMethod(_closure_, _object_).\n  1. Perform SetFunctionName(_closure_, _propKey_).\n  1. Let _prototype_ be OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).\n  1. Perform ! DefinePropertyOrThrow(_closure_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n  1. Return ? DefineMethodProperty(_object_, _propKey_, _closure_, _enumerable_).","code":"\n        1. Let _propKey_ be ? Evaluation of |ClassElementName|.\n        1. Let _env_ be the running execution context's LexicalEnvironment.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |GeneratorMethod|.\n        1. Let _closure_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform MakeMethod(_closure_, _object_).\n        1. Perform SetFunctionName(_closure_, _propKey_).\n        1. Let _prototype_ be OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).\n        1. Perform ! DefinePropertyOrThrow(_closure_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n        1. Return ? DefineMethodProperty(_object_, _propKey_, _closure_, _enumerable_).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorMethod","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"UniqueFormalParameters","ty":"Ast[UniqueFormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"MethodDefinitionEvaluation","isStatic":false,"withParams":[{"name":"object","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"enumerable","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[Record[PrivateElement] | Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _propKey_ be ? the result of evaluating |ClassElementName|.\n  1. Let _env_ be the running execution context.LexicalEnvironment.\n  1. Let _privateEnv_ be the running execution context.PrivateEnvironment.\n  1. Let _sourceText_ be the source text matched by |AsyncGeneratorMethod|.\n  1. Let _closure_ be OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).\n  1. Perform MakeMethod(_closure_, _object_).\n  1. Perform SetFunctionName(_closure_, _propKey_).\n  1. Let _prototype_ be OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).\n  1. Perform ! DefinePropertyOrThrow(_closure_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n  1. Return ? DefineMethodProperty(_object_, _propKey_, _closure_, _enumerable_).","code":"\n        1. Let _propKey_ be ? Evaluation of |ClassElementName|.\n        1. Let _env_ be the running execution context's LexicalEnvironment.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |AsyncGeneratorMethod|.\n        1. Let _closure_ be OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform MakeMethod(_closure_, _object_).\n        1. Perform SetFunctionName(_closure_, _propKey_).\n        1. Let _prototype_ be OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).\n        1. Perform ! DefinePropertyOrThrow(_closure_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n        1. Return ? DefineMethodProperty(_object_, _propKey_, _closure_, _enumerable_).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncMethod","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"UniqueFormalParameters","ty":"Ast[UniqueFormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"MethodDefinitionEvaluation","isStatic":false,"withParams":[{"name":"object","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"enumerable","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[Record[PrivateElement] | Enum[~unused~]] | Abrupt"}},"body":"\n  1. Let _propKey_ be ? the result of evaluating |ClassElementName|.\n  1. Let _env_ be the running execution context.LexicalEnvironment.\n  1. Let _privateEnv_ be the running execution context.PrivateEnvironment.\n  1. Let _sourceText_ be the source text matched by |AsyncMethod|.\n  1. Let _closure_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n  1. Perform MakeMethod(_closure_, _object_).\n  1. Perform SetFunctionName(_closure_, _propKey_).\n  1. Return ? DefineMethodProperty(_object_, _propKey_, _closure_, _enumerable_).","code":"\n        1. Let _propKey_ be ? Evaluation of |ClassElementName|.\n        1. Let _env_ be the LexicalEnvironment of the running execution context.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |AsyncMethod|.\n        1. Let _closure_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |UniqueFormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform MakeMethod(_closure_, _object_).\n        1. Perform SetFunctionName(_closure_, _propKey_).\n        1. Return ? DefineMethodProperty(_object_, _propKey_, _closure_, _enumerable_).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorBody","idx":0,"subIdx":0,"rhsParams":[{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"EvaluateGeneratorBody","isStatic":false,"withParams":[{"name":"functionObject","ty":"Record[ECMAScriptFunctionObject]","kind":{"Normal":{}}},{"name":"argumentsList","ty":"List[ESValue]","kind":{"Normal":{}}}],"retTy":"Return | Throw"}},"body":"\n  1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).\n  1. Let _G_ be ? OrdinaryCreateFromConstructor(_functionObject_, *\"%GeneratorFunction.prototype.prototype%\"*, « [[GeneratorState]], [[GeneratorContext]], [[GeneratorBrand]] »).\n  1. Set _G_.[[GeneratorBrand]] to ~empty~.\n  1. Set _G_.[[GeneratorState]] to *undefined*.\n  1. Perform GeneratorStart(_G_, |FunctionBody|).\n  1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _G_, [[Target]]: ~empty~ }.","code":"\n        1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).\n        1. Let _G_ be ? OrdinaryCreateFromConstructor(_functionObject_, *\"%GeneratorFunction.prototype.prototype%\"*, « [[GeneratorState]], [[GeneratorContext]], [[GeneratorBrand]] »).\n        1. Set _G_.[[GeneratorBrand]] to ~empty~.\n        1. Set _G_.[[GeneratorState]] to *undefined*.\n        1. Perform GeneratorStart(_G_, |FunctionBody|).\n        1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _G_, [[Target]]: ~empty~ }.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"InstantiateGeneratorFunctionObject","isStatic":false,"withParams":[{"name":"env","ty":"Record[EnvironmentRecord]","kind":{"Normal":{}}},{"name":"privateEnv","ty":"Record[PrivateEnvironmentRecord] | Null","kind":{"Normal":{}}}],"retTy":"Record[ECMAScriptFunctionObject]"}},"body":"\n  1. Let _name_ be StringValue of |BindingIdentifier|.\n  1. Let _sourceText_ be the source text matched by |GeneratorDeclaration|.\n  1. Let _F_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).\n  1. Perform SetFunctionName(_F_, _name_).\n  1. Let _prototype_ be OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).\n  1. Perform ! DefinePropertyOrThrow(_F_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n  1. Return _F_.","code":"\n        1. Let _name_ be StringValue of |BindingIdentifier|.\n        1. Let _sourceText_ be the source text matched by |GeneratorDeclaration|.\n        1. Let _F_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_F_, _name_).\n        1. Let _prototype_ be OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).\n        1. Perform ! DefinePropertyOrThrow(_F_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n        1. Return _F_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"InstantiateGeneratorFunctionObject","isStatic":false,"withParams":[{"name":"env","ty":"Record[EnvironmentRecord]","kind":{"Normal":{}}},{"name":"privateEnv","ty":"Record[PrivateEnvironmentRecord] | Null","kind":{"Normal":{}}}],"retTy":"Record[ECMAScriptFunctionObject]"}},"body":"\n  1. Let _sourceText_ be the source text matched by |GeneratorDeclaration|.\n  1. Let _F_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).\n  1. Perform SetFunctionName(_F_, *\"default\"*).\n  1. Let _prototype_ be OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).\n  1. Perform ! DefinePropertyOrThrow(_F_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n  1. Return _F_.","code":"\n        1. Let _sourceText_ be the source text matched by |GeneratorDeclaration|.\n        1. Let _F_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_F_, *\"default\"*).\n        1. Let _prototype_ be OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).\n        1. Perform ! DefinePropertyOrThrow(_F_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n        1. Return _F_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"InstantiateGeneratorFunctionExpression","isStatic":false,"withParams":[{"name":"name","ty":"Record[PrivateName | Symbol] | String","kind":{"Optional":{}}}],"retTy":"Record[ECMAScriptFunctionObject]"}},"body":"\n  1. If _name_ is not present, set _name_ to *\"\"*.\n  1. Let _env_ be the running execution context.LexicalEnvironment.\n  1. Let _privateEnv_ be the running execution context.PrivateEnvironment.\n  1. Let _sourceText_ be the source text matched by |GeneratorExpression|.\n  1. Let _closure_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).\n  1. Perform SetFunctionName(_closure_, _name_).\n  1. Let _prototype_ be OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).\n  1. Perform ! DefinePropertyOrThrow(_closure_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n  1. Return _closure_.","code":"\n        1. If _name_ is not present, set _name_ to *\"\"*.\n        1. Let _env_ be the LexicalEnvironment of the running execution context.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |GeneratorExpression|.\n        1. Let _closure_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_closure_, _name_).\n        1. Let _prototype_ be OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).\n        1. Perform ! DefinePropertyOrThrow(_closure_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n        1. Return _closure_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorExpression","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"InstantiateGeneratorFunctionExpression","isStatic":false,"withParams":[{"name":"name","ty":"Record[PrivateName | Symbol] | String","kind":{"Optional":{}}}],"retTy":"Record[ECMAScriptFunctionObject]"}},"body":"\n  1. Assert: _name_ is not present.\n  1. Set _name_ to StringValue of |BindingIdentifier|.\n  1. Let _outerEnv_ be the running execution context.LexicalEnvironment.\n  1. Let _funcEnv_ be NewDeclarativeEnvironment(_outerEnv_).\n  1. Perform ! _funcEnv_.CreateImmutableBinding(_name_, *false*).\n  1. Let _privateEnv_ be the running execution context.PrivateEnvironment.\n  1. Let _sourceText_ be the source text matched by |GeneratorExpression|.\n  1. Let _closure_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_).\n  1. Perform SetFunctionName(_closure_, _name_).\n  1. Let _prototype_ be OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).\n  1. Perform ! DefinePropertyOrThrow(_closure_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n  1. Perform ! _funcEnv_.InitializeBinding(_name_, _closure_).\n  1. Return _closure_.","code":"\n        1. Assert: _name_ is not present.\n        1. Set _name_ to StringValue of |BindingIdentifier|.\n        1. Let _outerEnv_ be the running execution context's LexicalEnvironment.\n        1. Let _funcEnv_ be NewDeclarativeEnvironment(_outerEnv_).\n        1. Perform ! _funcEnv_.CreateImmutableBinding(_name_, *false*).\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |GeneratorExpression|.\n        1. Let _closure_ be OrdinaryFunctionCreate(%GeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |GeneratorBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_).\n        1. Perform SetFunctionName(_closure_, _name_).\n        1. Let _prototype_ be OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).\n        1. Perform ! DefinePropertyOrThrow(_closure_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n        1. Perform ! _funcEnv_.InitializeBinding(_name_, _closure_).\n        1. Return _closure_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return InstantiateGeneratorFunctionExpression of |GeneratorExpression|.","code":"\n        1. Return InstantiateGeneratorFunctionExpression of |GeneratorExpression|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorExpression","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return InstantiateGeneratorFunctionExpression of |GeneratorExpression|.","code":"\n        1. Return InstantiateGeneratorFunctionExpression of |GeneratorExpression|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"YieldExpression","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ? Yield(*undefined*).","code":"\n        1. Return ? Yield(*undefined*).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"YieldExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _exprRef_ be ? the result of evaluating |AssignmentExpression|.\n  1. Let _value_ be ? GetValue(_exprRef_).\n  1. Return ? Yield(_value_).","code":"\n        1. Let _exprRef_ be ? Evaluation of |AssignmentExpression|.\n        1. Let _value_ be ? GetValue(_exprRef_).\n        1. Return ? Yield(_value_).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"YieldExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _generatorKind_ be GetGeneratorKind().\n  1. Let _exprRef_ be ? the result of evaluating |AssignmentExpression|.\n  1. Let _value_ be ? GetValue(_exprRef_).\n  1. Let _iteratorRecord_ be ? GetIterator(_value_, _generatorKind_).\n  1. Let _iterator_ be _iteratorRecord_.[[Iterator]].\n  1. Let _received_ be NormalCompletion(*undefined*).\n  1. Repeat, \n    1. If _received_ is a normal completion, then\n      1. Let _innerResult_ be ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]], « _received_.[[Value]] »).\n      1. If _generatorKind_ is ~async~, set _innerResult_ to ? Await(_innerResult_).\n      1. If _innerResult_ is not a Record[Object], throw a *TypeError* exception.\n      1. Let _done_ be ? IteratorComplete(_innerResult_).\n      1. If _done_ is *true*, then\n        1. Return ? IteratorValue(_innerResult_).\n      1. If _generatorKind_ is ~async~, set _received_ to Completion(AsyncGeneratorYield(? IteratorValue(_innerResult_))).\n      1. Else, set _received_ to Completion(GeneratorYield(_innerResult_)).\n    1. Else if _received_ is a throw completion, then\n      1. Let _throw_ be ? GetMethod(_iterator_, *\"throw\"*).\n      1. If _throw_ is not *undefined*, then\n        1. Let _innerResult_ be ? Call(_throw_, _iterator_, « _received_.[[Value]] »).\n        1. If _generatorKind_ is ~async~, set _innerResult_ to ? Await(_innerResult_).\n        1. NOTE: Exceptions from the inner iterator `throw` method are propagated. Normal completions from an inner `throw` method are processed similarly to an inner `next`.\n        1. If _innerResult_ is not a Record[Object], throw a *TypeError* exception.\n        1. Let _done_ be ? IteratorComplete(_innerResult_).\n        1. If _done_ is *true*, then\n          1. Return ? IteratorValue(_innerResult_).\n        1. If _generatorKind_ is ~async~, set _received_ to Completion(AsyncGeneratorYield(? IteratorValue(_innerResult_))).\n        1. Else, set _received_ to Completion(GeneratorYield(_innerResult_)).\n      1. Else,\n        1. NOTE: If _iterator_ does not have a `throw` method, this throw is going to terminate the `yield*` loop. But first we need to give _iterator_ a chance to clean up.\n        1. Let _closeCompletion_ be Completion Record { [[Type]]: ~normal~, [[Value]]: ~empty~, [[Target]]: ~empty~ }.\n        1. If _generatorKind_ is ~async~, perform ? AsyncIteratorClose(_iteratorRecord_, _closeCompletion_).\n        1. Else, perform ? IteratorClose(_iteratorRecord_, _closeCompletion_).\n        1. NOTE: The next step throws a *TypeError* to indicate that there was a `yield*` protocol violation: _iterator_ does not have a `throw` method.\n        1. Throw a *TypeError* exception.\n    1. Else,\n      1. Assert: _received_ is a return completion.\n      1. Let _return_ be ? GetMethod(_iterator_, *\"return\"*).\n      1. If _return_ is *undefined*, then\n        1. Set _value_ to _received_.[[Value]].\n        1. If _generatorKind_ is ~async~, then\n          1. Set _value_ to ? Await(_value_).\n        1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _value_, [[Target]]: ~empty~ }.\n      1. Let _innerReturnResult_ be ? Call(_return_, _iterator_, « _received_.[[Value]] »).\n      1. If _generatorKind_ is ~async~, set _innerReturnResult_ to ? Await(_innerReturnResult_).\n      1. If _innerReturnResult_ is not a Record[Object], throw a *TypeError* exception.\n      1. Let _done_ be ? IteratorComplete(_innerReturnResult_).\n      1. If _done_ is *true*, then\n        1. Set _value_ to ? IteratorValue(_innerReturnResult_).\n        1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _value_, [[Target]]: ~empty~ }.\n      1. If _generatorKind_ is ~async~, set _received_ to Completion(AsyncGeneratorYield(? IteratorValue(_innerReturnResult_))).\n      1. Else, set _received_ to Completion(GeneratorYield(_innerReturnResult_)).","code":"\n        1. Let _generatorKind_ be GetGeneratorKind().\n        1. Let _exprRef_ be ? Evaluation of |AssignmentExpression|.\n        1. Let _value_ be ? GetValue(_exprRef_).\n        1. Let _iteratorRecord_ be ? GetIterator(_value_, _generatorKind_).\n        1. Let _iterator_ be _iteratorRecord_.[[Iterator]].\n        1. Let _received_ be NormalCompletion(*undefined*).\n        1. Repeat,\n          1. If _received_ is a normal completion, then\n            1. Let _innerResult_ be ? Call(_iteratorRecord_.[[NextMethod]], _iteratorRecord_.[[Iterator]], « _received_.[[Value]] »).\n            1. If _generatorKind_ is ~async~, set _innerResult_ to ? Await(_innerResult_).\n            1. If _innerResult_ is not an Object, throw a *TypeError* exception.\n            1. Let _done_ be ? IteratorComplete(_innerResult_).\n            1. If _done_ is *true*, then\n              1. Return ? IteratorValue(_innerResult_).\n            1. If _generatorKind_ is ~async~, set _received_ to Completion(AsyncGeneratorYield(? IteratorValue(_innerResult_))).\n            1. Else, set _received_ to Completion(GeneratorYield(_innerResult_)).\n          1. Else if _received_ is a throw completion, then\n            1. Let _throw_ be ? GetMethod(_iterator_, *\"throw\"*).\n            1. If _throw_ is not *undefined*, then\n              1. Let _innerResult_ be ? Call(_throw_, _iterator_, « _received_.[[Value]] »).\n              1. If _generatorKind_ is ~async~, set _innerResult_ to ? Await(_innerResult_).\n              1. NOTE: Exceptions from the inner iterator `throw` method are propagated. Normal completions from an inner `throw` method are processed similarly to an inner `next`.\n              1. If _innerResult_ is not an Object, throw a *TypeError* exception.\n              1. Let _done_ be ? IteratorComplete(_innerResult_).\n              1. If _done_ is *true*, then\n                1. Return ? IteratorValue(_innerResult_).\n              1. If _generatorKind_ is ~async~, set _received_ to Completion(AsyncGeneratorYield(? IteratorValue(_innerResult_))).\n              1. Else, set _received_ to Completion(GeneratorYield(_innerResult_)).\n            1. Else,\n              1. NOTE: If _iterator_ does not have a `throw` method, this throw is going to terminate the `yield*` loop. But first we need to give _iterator_ a chance to clean up.\n              1. Let _closeCompletion_ be Completion Record { [[Type]]: ~normal~, [[Value]]: ~empty~, [[Target]]: ~empty~ }.\n              1. If _generatorKind_ is ~async~, perform ? AsyncIteratorClose(_iteratorRecord_, _closeCompletion_).\n              1. Else, perform ? IteratorClose(_iteratorRecord_, _closeCompletion_).\n              1. NOTE: The next step throws a *TypeError* to indicate that there was a `yield*` protocol violation: _iterator_ does not have a `throw` method.\n              1. Throw a *TypeError* exception.\n          1. Else,\n            1. Assert: _received_ is a return completion.\n            1. Let _return_ be ? GetMethod(_iterator_, *\"return\"*).\n            1. If _return_ is *undefined*, then\n              1. Set _value_ to _received_.[[Value]].\n              1. If _generatorKind_ is ~async~, then\n                1. Set _value_ to ? Await(_value_).\n              1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _value_, [[Target]]: ~empty~ }.\n            1. Let _innerReturnResult_ be ? Call(_return_, _iterator_, « _received_.[[Value]] »).\n            1. If _generatorKind_ is ~async~, set _innerReturnResult_ to ? Await(_innerReturnResult_).\n            1. If _innerReturnResult_ is not an Object, throw a *TypeError* exception.\n            1. Let _done_ be ? IteratorComplete(_innerReturnResult_).\n            1. If _done_ is *true*, then\n              1. Set _value_ to ? IteratorValue(_innerReturnResult_).\n              1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _value_, [[Target]]: ~empty~ }.\n            1. If _generatorKind_ is ~async~, set _received_ to Completion(AsyncGeneratorYield(? IteratorValue(_innerReturnResult_))).\n            1. Else, set _received_ to Completion(GeneratorYield(_innerReturnResult_)).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorBody","idx":0,"subIdx":0,"rhsParams":[{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"EvaluateAsyncGeneratorBody","isStatic":false,"withParams":[{"name":"functionObject","ty":"Record[ECMAScriptFunctionObject]","kind":{"Normal":{}}},{"name":"argumentsList","ty":"List[ESValue]","kind":{"Normal":{}}}],"retTy":"Return | Throw"}},"body":"\n  1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).\n  1. Let _generator_ be ? OrdinaryCreateFromConstructor(_functionObject_, *\"%AsyncGeneratorFunction.prototype.prototype%\"*, « [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]], [[GeneratorBrand]] »).\n  1. Set _generator_.[[GeneratorBrand]] to ~empty~.\n  1. Set _generator_.[[AsyncGeneratorState]] to *undefined*.\n  1. Perform AsyncGeneratorStart(_generator_, |FunctionBody|).\n  1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _generator_, [[Target]]: ~empty~ }.","code":"\n        1. Perform ? FunctionDeclarationInstantiation(_functionObject_, _argumentsList_).\n        1. Let _generator_ be ? OrdinaryCreateFromConstructor(_functionObject_, *\"%AsyncGeneratorFunction.prototype.prototype%\"*, « [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]], [[GeneratorBrand]] »).\n        1. Set _generator_.[[GeneratorBrand]] to ~empty~.\n        1. Set _generator_.[[AsyncGeneratorState]] to *undefined*.\n        1. Perform AsyncGeneratorStart(_generator_, |FunctionBody|).\n        1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _generator_, [[Target]]: ~empty~ }.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"InstantiateAsyncGeneratorFunctionObject","isStatic":false,"withParams":[{"name":"env","ty":"Record[EnvironmentRecord]","kind":{"Normal":{}}},{"name":"privateEnv","ty":"Record[PrivateEnvironmentRecord] | Null","kind":{"Normal":{}}}],"retTy":"Record[ECMAScriptFunctionObject]"}},"body":"\n  1. Let _name_ be StringValue of |BindingIdentifier|.\n  1. Let _sourceText_ be the source text matched by |AsyncGeneratorDeclaration|.\n  1. Let _F_ be OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).\n  1. Perform SetFunctionName(_F_, _name_).\n  1. Let _prototype_ be OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).\n  1. Perform ! DefinePropertyOrThrow(_F_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n  1. Return _F_.","code":"\n        1. Let _name_ be StringValue of |BindingIdentifier|.\n        1. Let _sourceText_ be the source text matched by |AsyncGeneratorDeclaration|.\n        1. Let _F_ be OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_F_, _name_).\n        1. Let _prototype_ be OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).\n        1. Perform ! DefinePropertyOrThrow(_F_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n        1. Return _F_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"InstantiateAsyncGeneratorFunctionObject","isStatic":false,"withParams":[{"name":"env","ty":"Record[EnvironmentRecord]","kind":{"Normal":{}}},{"name":"privateEnv","ty":"Record[PrivateEnvironmentRecord] | Null","kind":{"Normal":{}}}],"retTy":"Record[ECMAScriptFunctionObject]"}},"body":"\n  1. Let _sourceText_ be the source text matched by |AsyncGeneratorDeclaration|.\n  1. Let _F_ be OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).\n  1. Perform SetFunctionName(_F_, *\"default\"*).\n  1. Let _prototype_ be OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).\n  1. Perform ! DefinePropertyOrThrow(_F_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n  1. Return _F_.","code":"\n        1. Let _sourceText_ be the source text matched by |AsyncGeneratorDeclaration|.\n        1. Let _F_ be OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_F_, *\"default\"*).\n        1. Let _prototype_ be OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).\n        1. Perform ! DefinePropertyOrThrow(_F_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n        1. Return _F_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"InstantiateAsyncGeneratorFunctionExpression","isStatic":false,"withParams":[{"name":"name","ty":"Record[PrivateName | Symbol] | String","kind":{"Optional":{}}}],"retTy":"Record[ECMAScriptFunctionObject]"}},"body":"\n  1. If _name_ is not present, set _name_ to *\"\"*.\n  1. Let _env_ be the running execution context.LexicalEnvironment.\n  1. Let _privateEnv_ be the running execution context.PrivateEnvironment.\n  1. Let _sourceText_ be the source text matched by |AsyncGeneratorExpression|.\n  1. Let _closure_ be OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).\n  1. Perform SetFunctionName(_closure_, _name_).\n  1. Let _prototype_ be OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).\n  1. Perform ! DefinePropertyOrThrow(_closure_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n  1. Return _closure_.","code":"\n        1. If _name_ is not present, set _name_ to *\"\"*.\n        1. Let _env_ be the LexicalEnvironment of the running execution context.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |AsyncGeneratorExpression|.\n        1. Let _closure_ be OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_closure_, _name_).\n        1. Let _prototype_ be OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).\n        1. Perform ! DefinePropertyOrThrow(_closure_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n        1. Return _closure_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorExpression","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"InstantiateAsyncGeneratorFunctionExpression","isStatic":false,"withParams":[{"name":"name","ty":"Record[PrivateName | Symbol] | String","kind":{"Optional":{}}}],"retTy":"Record[ECMAScriptFunctionObject]"}},"body":"\n  1. Assert: _name_ is not present.\n  1. Set _name_ to StringValue of |BindingIdentifier|.\n  1. Let _outerEnv_ be the running execution context.LexicalEnvironment.\n  1. Let _funcEnv_ be NewDeclarativeEnvironment(_outerEnv_).\n  1. Perform ! _funcEnv_.CreateImmutableBinding(_name_, *false*).\n  1. Let _privateEnv_ be the running execution context.PrivateEnvironment.\n  1. Let _sourceText_ be the source text matched by |AsyncGeneratorExpression|.\n  1. Let _closure_ be OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_).\n  1. Perform SetFunctionName(_closure_, _name_).\n  1. Let _prototype_ be OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).\n  1. Perform ! DefinePropertyOrThrow(_closure_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n  1. Perform ! _funcEnv_.InitializeBinding(_name_, _closure_).\n  1. Return _closure_.","code":"\n        1. Assert: _name_ is not present.\n        1. Set _name_ to StringValue of |BindingIdentifier|.\n        1. Let _outerEnv_ be the running execution context's LexicalEnvironment.\n        1. Let _funcEnv_ be NewDeclarativeEnvironment(_outerEnv_).\n        1. Perform ! _funcEnv_.CreateImmutableBinding(_name_, *false*).\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |AsyncGeneratorExpression|.\n        1. Let _closure_ be OrdinaryFunctionCreate(%AsyncGeneratorFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncGeneratorBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_).\n        1. Perform SetFunctionName(_closure_, _name_).\n        1. Let _prototype_ be OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).\n        1. Perform ! DefinePropertyOrThrow(_closure_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n        1. Perform ! _funcEnv_.InitializeBinding(_name_, _closure_).\n        1. Return _closure_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return InstantiateAsyncGeneratorFunctionExpression of |AsyncGeneratorExpression|.","code":"\n        1. Return InstantiateAsyncGeneratorFunctionExpression of |AsyncGeneratorExpression|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorExpression","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return InstantiateAsyncGeneratorFunctionExpression of |AsyncGeneratorExpression|.","code":"\n        1. Return InstantiateAsyncGeneratorFunctionExpression of |AsyncGeneratorExpression|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElement","idx":0,"subIdx":0,"rhsParams":[{"name":"MethodDefinition","ty":"Ast[MethodDefinition]","kind":{"Normal":{}}}]},"methodName":"ClassElementKind","isStatic":true,"withParams":[],"retTy":"Enum[~constructor-method~, ~empty~, ~non-constructor-method~]"}},"body":"\n  1. If PropName of |MethodDefinition| is *\"constructor\"*, return ~constructor-method~.\n  1. Return ~non-constructor-method~.","code":"\n        1. If PropName of |MethodDefinition| is *\"constructor\"*, return ~constructor-method~.\n        1. Return ~non-constructor-method~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElement","idx":1,"subIdx":0,"rhsParams":[{"name":"MethodDefinition","ty":"Ast[MethodDefinition]","kind":{"Normal":{}}}]},"methodName":"ClassElementKind","isStatic":true,"withParams":[],"retTy":"Enum[~constructor-method~, ~empty~, ~non-constructor-method~]"}},"body":"\n  1. Return ~non-constructor-method~.","code":"\n        1. Return ~non-constructor-method~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElement","idx":2,"subIdx":0,"rhsParams":[{"name":"FieldDefinition","ty":"Ast[FieldDefinition]","kind":{"Normal":{}}}]},"methodName":"ClassElementKind","isStatic":true,"withParams":[],"retTy":"Enum[~constructor-method~, ~empty~, ~non-constructor-method~]"}},"body":"\n  1. Return ~non-constructor-method~.","code":"\n        1. Return ~non-constructor-method~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElement","idx":3,"subIdx":0,"rhsParams":[{"name":"FieldDefinition","ty":"Ast[FieldDefinition]","kind":{"Normal":{}}}]},"methodName":"ClassElementKind","isStatic":true,"withParams":[],"retTy":"Enum[~constructor-method~, ~empty~, ~non-constructor-method~]"}},"body":"\n  1. Return ~non-constructor-method~.","code":"\n        1. Return ~non-constructor-method~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElement","idx":4,"subIdx":0,"rhsParams":[{"name":"ClassStaticBlock","ty":"Ast[ClassStaticBlock]","kind":{"Normal":{}}}]},"methodName":"ClassElementKind","isStatic":true,"withParams":[],"retTy":"Enum[~constructor-method~, ~empty~, ~non-constructor-method~]"}},"body":"\n  1. Return ~non-constructor-method~.","code":"\n        1. Return ~non-constructor-method~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElement","idx":5,"subIdx":0,"rhsParams":[]},"methodName":"ClassElementKind","isStatic":true,"withParams":[],"retTy":"Enum[~constructor-method~, ~empty~, ~non-constructor-method~]"}},"body":"\n  1. Return ~empty~.","code":"\n        1. Return ~empty~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElementList","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElement","ty":"Ast[ClassElement]","kind":{"Normal":{}}}]},"methodName":"ConstructorMethod","isStatic":true,"withParams":[],"retTy":"Unknown[\"a |ClassElement| Parse Node or ~empty~\"]"}},"body":"\n  1. If ClassElementKind of |ClassElement| is ~constructor-method~, return |ClassElement|.\n  1. Return ~empty~.","code":"\n        1. If ClassElementKind of |ClassElement| is ~constructor-method~, return |ClassElement|.\n        1. Return ~empty~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElementList","idx":1,"subIdx":0,"rhsParams":[{"name":"ClassElementList","ty":"Ast[ClassElementList]","kind":{"Normal":{}}},{"name":"ClassElement","ty":"Ast[ClassElement]","kind":{"Normal":{}}}]},"methodName":"ConstructorMethod","isStatic":true,"withParams":[],"retTy":"Unknown[\"a |ClassElement| Parse Node or ~empty~\"]"}},"body":"\n  1. Let _head_ be ConstructorMethod of |ClassElementList|.\n  1. If _head_ is not ~empty~, return _head_.\n  1. If ClassElementKind of |ClassElement| is ~constructor-method~, return |ClassElement|.\n  1. Return ~empty~.","code":"\n        1. Let _head_ be ConstructorMethod of |ClassElementList|.\n        1. If _head_ is not ~empty~, return _head_.\n        1. If ClassElementKind of |ClassElement| is ~constructor-method~, return |ClassElement|.\n        1. Return ~empty~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElement","idx":0,"subIdx":0,"rhsParams":[{"name":"MethodDefinition","ty":"Ast[MethodDefinition]","kind":{"Normal":{}}}]},"methodName":"IsStatic","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElement","idx":1,"subIdx":0,"rhsParams":[{"name":"MethodDefinition","ty":"Ast[MethodDefinition]","kind":{"Normal":{}}}]},"methodName":"IsStatic","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElement","idx":2,"subIdx":0,"rhsParams":[{"name":"FieldDefinition","ty":"Ast[FieldDefinition]","kind":{"Normal":{}}}]},"methodName":"IsStatic","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElement","idx":3,"subIdx":0,"rhsParams":[{"name":"FieldDefinition","ty":"Ast[FieldDefinition]","kind":{"Normal":{}}}]},"methodName":"IsStatic","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElement","idx":4,"subIdx":0,"rhsParams":[{"name":"ClassStaticBlock","ty":"Ast[ClassStaticBlock]","kind":{"Normal":{}}}]},"methodName":"IsStatic","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElement","idx":5,"subIdx":0,"rhsParams":[]},"methodName":"IsStatic","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElementList","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElement","ty":"Ast[ClassElement]","kind":{"Normal":{}}}]},"methodName":"NonConstructorElements","isStatic":true,"withParams":[],"retTy":"Unknown[\"a List of |ClassElement| Parse Nodes\"]"}},"body":"\n  1. If ClassElementKind of |ClassElement| is ~non-constructor-method~, then\n    1. Return « |ClassElement| ».\n  1. Return « ».","code":"\n        1. If ClassElementKind of |ClassElement| is ~non-constructor-method~, then\n          1. Return « |ClassElement| ».\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElementList","idx":1,"subIdx":0,"rhsParams":[{"name":"ClassElementList","ty":"Ast[ClassElementList]","kind":{"Normal":{}}},{"name":"ClassElement","ty":"Ast[ClassElement]","kind":{"Normal":{}}}]},"methodName":"NonConstructorElements","isStatic":true,"withParams":[],"retTy":"Unknown[\"a List of |ClassElement| Parse Nodes\"]"}},"body":"\n  1. Let _list_ be NonConstructorElements of |ClassElementList|.\n  1. If ClassElementKind of |ClassElement| is ~non-constructor-method~, then\n    1. Append |ClassElement| to _list_.\n  1. Return _list_.","code":"\n        1. Let _list_ be NonConstructorElements of |ClassElementList|.\n        1. If ClassElementKind of |ClassElement| is ~non-constructor-method~, then\n          1. Append |ClassElement| to the end of _list_.\n        1. Return _list_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElementList","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElement","ty":"Ast[ClassElement]","kind":{"Normal":{}}}]},"methodName":"PrototypePropertyNameList","isStatic":true,"withParams":[],"retTy":"List[Record[Symbol] | String]"}},"body":"\n  1. Let _propName_ be PropName of |ClassElement|.\n  1. If _propName_ is ~empty~, return « ».\n  1. If IsStatic of |ClassElement| is *true*, return « ».\n  1. Return « _propName_ ».","code":"\n        1. Let _propName_ be PropName of |ClassElement|.\n        1. If _propName_ is ~empty~, return a new empty List.\n        1. If IsStatic of |ClassElement| is *true*, return a new empty List.\n        1. Return « _propName_ ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElementList","idx":1,"subIdx":0,"rhsParams":[{"name":"ClassElementList","ty":"Ast[ClassElementList]","kind":{"Normal":{}}},{"name":"ClassElement","ty":"Ast[ClassElement]","kind":{"Normal":{}}}]},"methodName":"PrototypePropertyNameList","isStatic":true,"withParams":[],"retTy":"List[Record[Symbol] | String]"}},"body":"\n  1. Let _list_ be PrototypePropertyNameList of |ClassElementList|.\n  1. Let _propName_ be PropName of |ClassElement|.\n  1. If _propName_ is ~empty~, return _list_.\n  1. If IsStatic of |ClassElement| is *true*, return _list_.\n  1. Return the list-concatenation of _list_ and « _propName_ ».","code":"\n        1. Let _list_ be PrototypePropertyNameList of |ClassElementList|.\n        1. Let _propName_ be PropName of |ClassElement|.\n        1. If _propName_ is ~empty~, return _list_.\n        1. If IsStatic of |ClassElement| is *true*, return _list_.\n        1. Return the list-concatenation of _list_ and « _propName_ ».\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":null,"methodName":"AllPrivateIdentifiersValid","isStatic":true,"withParams":[{"name":"names","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. For each child node _child_ of *this* value, do\n    1. If _child_ is an instance of a nonterminal, then\n      1. If AllPrivateIdentifiersValid of _child_ with argument _names_ is *false*, return *false*.\n  1. Return *true*.","code":"\n        1. For each child node _child_ of this Parse Node, do\n          1. If _child_ is an instance of a nonterminal, then\n            1. If AllPrivateIdentifiersValid of _child_ with argument _names_ is *false*, return *false*.\n        1. Return *true*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":7,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"PrivateIdentifier","ty":"Ast[PrivateIdentifier]","kind":{"Normal":{}}}]},"methodName":"AllPrivateIdentifiersValid","isStatic":true,"withParams":[{"name":"names","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _names_ contains StringValue of |PrivateIdentifier|, then\n    1. Return AllPrivateIdentifiersValid of |MemberExpression| with argument _names_.\n  1. Return *false*.","code":"\n        1. If _names_ contains the StringValue of |PrivateIdentifier|, then\n          1. Return AllPrivateIdentifiersValid of |MemberExpression| with argument _names_.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CallExpression","idx":7,"subIdx":0,"rhsParams":[{"name":"CallExpression","ty":"Ast[CallExpression]","kind":{"Normal":{}}},{"name":"PrivateIdentifier","ty":"Ast[PrivateIdentifier]","kind":{"Normal":{}}}]},"methodName":"AllPrivateIdentifiersValid","isStatic":true,"withParams":[{"name":"names","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _names_ contains StringValue of |PrivateIdentifier|, then\n    1. Return AllPrivateIdentifiersValid of |CallExpression| with argument _names_.\n  1. Return *false*.","code":"\n        1. If _names_ contains the StringValue of |PrivateIdentifier|, then\n          1. Return AllPrivateIdentifiersValid of |CallExpression| with argument _names_.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"OptionalChain","idx":4,"subIdx":0,"rhsParams":[{"name":"PrivateIdentifier","ty":"Ast[PrivateIdentifier]","kind":{"Normal":{}}}]},"methodName":"AllPrivateIdentifiersValid","isStatic":true,"withParams":[{"name":"names","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _names_ contains StringValue of |PrivateIdentifier|, return *true*.\n  1. Return *false*.","code":"\n        1. If _names_ contains the StringValue of |PrivateIdentifier|, return *true*.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"OptionalChain","idx":9,"subIdx":0,"rhsParams":[{"name":"OptionalChain","ty":"Ast[OptionalChain]","kind":{"Normal":{}}},{"name":"PrivateIdentifier","ty":"Ast[PrivateIdentifier]","kind":{"Normal":{}}}]},"methodName":"AllPrivateIdentifiersValid","isStatic":true,"withParams":[{"name":"names","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _names_ contains StringValue of |PrivateIdentifier|, then\n    1. Return AllPrivateIdentifiersValid of |OptionalChain| with argument _names_.\n  1. Return *false*.","code":"\n        1. If _names_ contains the StringValue of |PrivateIdentifier|, then\n          1. Return AllPrivateIdentifiersValid of |OptionalChain| with argument _names_.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassBody","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementList","ty":"Ast[ClassElementList]","kind":{"Normal":{}}}]},"methodName":"AllPrivateIdentifiersValid","isStatic":true,"withParams":[{"name":"names","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _newNames_ be the list-concatenation of _names_ and PrivateBoundIdentifiers of |ClassBody|.\n  1. Return AllPrivateIdentifiersValid of |ClassElementList| with argument _newNames_.","code":"\n        1. Let _newNames_ be the list-concatenation of _names_ and PrivateBoundIdentifiers of |ClassBody|.\n        1. Return AllPrivateIdentifiersValid of |ClassElementList| with argument _newNames_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RelationalExpression","idx":7,"subIdx":0,"rhsParams":[{"name":"PrivateIdentifier","ty":"Ast[PrivateIdentifier]","kind":{"Normal":{}}},{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}}]},"methodName":"AllPrivateIdentifiersValid","isStatic":true,"withParams":[{"name":"names","ty":"List[String]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _names_ contains StringValue of |PrivateIdentifier|, then\n    1. Return AllPrivateIdentifiersValid of |ShiftExpression| with argument _names_.\n  1. Return *false*.","code":"\n        1. If _names_ contains the StringValue of |PrivateIdentifier|, then\n          1. Return AllPrivateIdentifiersValid of |ShiftExpression| with argument _names_.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FieldDefinition","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"PrivateBoundIdentifiers","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return PrivateBoundIdentifiers of |ClassElementName|.","code":"\n        1. Return PrivateBoundIdentifiers of |ClassElementName|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FieldDefinition","idx":0,"subIdx":1,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"PrivateBoundIdentifiers","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return PrivateBoundIdentifiers of |ClassElementName|.","code":"\n        1. Return PrivateBoundIdentifiers of |ClassElementName|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElementName","idx":1,"subIdx":0,"rhsParams":[{"name":"PrivateIdentifier","ty":"Ast[PrivateIdentifier]","kind":{"Normal":{}}}]},"methodName":"PrivateBoundIdentifiers","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « StringValue of |PrivateIdentifier| ».","code":"\n        1. Return a List whose sole element is the StringValue of |PrivateIdentifier|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElementName","idx":0,"subIdx":0,"rhsParams":[{"name":"PropertyName","ty":"Ast[PropertyName]","kind":{"Normal":{}}}]},"methodName":"PrivateBoundIdentifiers","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElement","idx":4,"subIdx":0,"rhsParams":[{"name":"ClassStaticBlock","ty":"Ast[ClassStaticBlock]","kind":{"Normal":{}}}]},"methodName":"PrivateBoundIdentifiers","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElement","idx":5,"subIdx":0,"rhsParams":[]},"methodName":"PrivateBoundIdentifiers","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n        1. Return a new empty List.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElementList","idx":1,"subIdx":0,"rhsParams":[{"name":"ClassElementList","ty":"Ast[ClassElementList]","kind":{"Normal":{}}},{"name":"ClassElement","ty":"Ast[ClassElement]","kind":{"Normal":{}}}]},"methodName":"PrivateBoundIdentifiers","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be PrivateBoundIdentifiers of |ClassElementList|.\n  1. Let _names2_ be PrivateBoundIdentifiers of |ClassElement|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n        1. Let _names1_ be PrivateBoundIdentifiers of |ClassElementList|.\n        1. Let _names2_ be PrivateBoundIdentifiers of |ClassElement|.\n        1. Return the list-concatenation of _names1_ and _names2_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MethodDefinition","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"UniqueFormalParameters","ty":"Ast[UniqueFormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"PrivateBoundIdentifiers","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return PrivateBoundIdentifiers of |ClassElementName|.","code":"\n        1. Return PrivateBoundIdentifiers of |ClassElementName|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MethodDefinition","idx":4,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"PrivateBoundIdentifiers","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return PrivateBoundIdentifiers of |ClassElementName|.","code":"\n        1. Return PrivateBoundIdentifiers of |ClassElementName|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MethodDefinition","idx":5,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"PropertySetParameterList","ty":"Ast[PropertySetParameterList]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"PrivateBoundIdentifiers","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return PrivateBoundIdentifiers of |ClassElementName|.","code":"\n        1. Return PrivateBoundIdentifiers of |ClassElementName|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorMethod","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"UniqueFormalParameters","ty":"Ast[UniqueFormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"PrivateBoundIdentifiers","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return PrivateBoundIdentifiers of |ClassElementName|.","code":"\n        1. Return PrivateBoundIdentifiers of |ClassElementName|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncMethod","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"UniqueFormalParameters","ty":"Ast[UniqueFormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"PrivateBoundIdentifiers","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return PrivateBoundIdentifiers of |ClassElementName|.","code":"\n        1. Return PrivateBoundIdentifiers of |ClassElementName|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorMethod","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"UniqueFormalParameters","ty":"Ast[UniqueFormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"PrivateBoundIdentifiers","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return PrivateBoundIdentifiers of |ClassElementName|.","code":"\n        1. Return PrivateBoundIdentifiers of |ClassElementName|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":null,"methodName":"ContainsArguments","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. For each child node _child_ of *this* value, do\n    1. If _child_ is an instance of a nonterminal, then\n      1. If ContainsArguments of _child_ is *true*, return *true*.\n  1. Return *false*.","code":"\n        1. For each child node _child_ of this Parse Node, do\n          1. If _child_ is an instance of a nonterminal, then\n            1. If ContainsArguments of _child_ is *true*, return *true*.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IdentifierReference","idx":0,"subIdx":0,"rhsParams":[{"name":"Identifier","ty":"Ast[Identifier]","kind":{"Normal":{}}}]},"methodName":"ContainsArguments","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. If StringValue of |Identifier| is *\"arguments\"*, return *true*.\n  1. Return *false*.","code":"\n        1. If the StringValue of |Identifier| is *\"arguments\"*, return *true*.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"ContainsArguments","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"ContainsArguments","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"ContainsArguments","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionExpression","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"ContainsArguments","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"ContainsArguments","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"ContainsArguments","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"ContainsArguments","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorExpression","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"ContainsArguments","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"ContainsArguments","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"ContainsArguments","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"ContainsArguments","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorExpression","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"ContainsArguments","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncFunctionDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"ContainsArguments","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncFunctionDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"ContainsArguments","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncFunctionExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"ContainsArguments","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncFunctionExpression","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"ContainsArguments","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MethodDefinition","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"UniqueFormalParameters","ty":"Ast[UniqueFormalParameters]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"ContainsArguments","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return ContainsArguments of |ClassElementName|.","code":"\n        1. Return ContainsArguments of |ClassElementName|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MethodDefinition","idx":4,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"ContainsArguments","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return ContainsArguments of |ClassElementName|.","code":"\n        1. Return ContainsArguments of |ClassElementName|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MethodDefinition","idx":5,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"PropertySetParameterList","ty":"Ast[PropertySetParameterList]","kind":{"Normal":{}}},{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"ContainsArguments","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return ContainsArguments of |ClassElementName|.","code":"\n        1. Return ContainsArguments of |ClassElementName|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GeneratorMethod","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"UniqueFormalParameters","ty":"Ast[UniqueFormalParameters]","kind":{"Normal":{}}},{"name":"GeneratorBody","ty":"Ast[GeneratorBody]","kind":{"Normal":{}}}]},"methodName":"ContainsArguments","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return ContainsArguments of |ClassElementName|.","code":"\n        1. Return ContainsArguments of |ClassElementName|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncGeneratorMethod","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"UniqueFormalParameters","ty":"Ast[UniqueFormalParameters]","kind":{"Normal":{}}},{"name":"AsyncGeneratorBody","ty":"Ast[AsyncGeneratorBody]","kind":{"Normal":{}}}]},"methodName":"ContainsArguments","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return ContainsArguments of |ClassElementName|.","code":"\n        1. Return ContainsArguments of |ClassElementName|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncMethod","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"UniqueFormalParameters","ty":"Ast[UniqueFormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"ContainsArguments","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return ContainsArguments of |ClassElementName|.","code":"\n        1. Return ContainsArguments of |ClassElementName|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FieldDefinition","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"ClassFieldDefinitionEvaluation","isStatic":false,"withParams":[{"name":"homeObject","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Normal[Record[ClassFieldDefinitionRecord]] | Abrupt"}},"body":"\n  1. Let _name_ be ? the result of evaluating |ClassElementName|.\n  1. If |Initializer| is present, then\n    1. Let _formalParameterList_ be <emu-grammar>FormalParameters : [empty]</emu-grammar>.\n    1. Let _env_ be the running execution context.LexicalEnvironment.\n    1. Let _privateEnv_ be the running execution context.PrivateEnvironment.\n    1. Let _sourceText_ be *\"\"*.\n    1. Let _initializer_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _formalParameterList_, |Initializer|, ~non-lexical-this~, _env_, _privateEnv_).\n    1. Perform MakeMethod(_initializer_, _homeObject_).\n    1. Set _initializer_.[[ClassFieldInitializerName]] to _name_.\n  1. Else,\n    1. Let _initializer_ be ~empty~.\n  1. Return ClassFieldDefinition Record { [[Name]]: _name_, [[Initializer]]: _initializer_ }.","code":"\n        1. Let _name_ be ? Evaluation of |ClassElementName|.\n        1. If |Initializer| is present, then\n          1. Let _formalParameterList_ be an instance of the production <emu-grammar>FormalParameters : [empty]</emu-grammar>.\n          1. Let _env_ be the LexicalEnvironment of the running execution context.\n          1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n          1. Let _sourceText_ be the empty sequence of Unicode code points.\n          1. Let _initializer_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _formalParameterList_, |Initializer|, ~non-lexical-this~, _env_, _privateEnv_).\n          1. Perform MakeMethod(_initializer_, _homeObject_).\n          1. Set _initializer_.[[ClassFieldInitializerName]] to _name_.\n        1. Else,\n          1. Let _initializer_ be ~empty~.\n        1. Return the ClassFieldDefinition Record { [[Name]]: _name_, [[Initializer]]: _initializer_ }.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FieldDefinition","idx":0,"subIdx":1,"rhsParams":[{"name":"ClassElementName","ty":"Ast[ClassElementName]","kind":{"Normal":{}}},{"name":"Initializer","ty":"Ast[Initializer]","kind":{"Normal":{}}}]},"methodName":"ClassFieldDefinitionEvaluation","isStatic":false,"withParams":[{"name":"homeObject","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Normal[Record[ClassFieldDefinitionRecord]] | Abrupt"}},"body":"\n  1. Let _name_ be ? the result of evaluating |ClassElementName|.\n  1. If |Initializer| is present, then\n    1. Let _formalParameterList_ be <emu-grammar>FormalParameters : [empty]</emu-grammar>.\n    1. Let _env_ be the running execution context.LexicalEnvironment.\n    1. Let _privateEnv_ be the running execution context.PrivateEnvironment.\n    1. Let _sourceText_ be *\"\"*.\n    1. Let _initializer_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _formalParameterList_, |Initializer|, ~non-lexical-this~, _env_, _privateEnv_).\n    1. Perform MakeMethod(_initializer_, _homeObject_).\n    1. Set _initializer_.[[ClassFieldInitializerName]] to _name_.\n  1. Else,\n    1. Let _initializer_ be ~empty~.\n  1. Return ClassFieldDefinition Record { [[Name]]: _name_, [[Initializer]]: _initializer_ }.","code":"\n        1. Let _name_ be ? Evaluation of |ClassElementName|.\n        1. If |Initializer| is present, then\n          1. Let _formalParameterList_ be an instance of the production <emu-grammar>FormalParameters : [empty]</emu-grammar>.\n          1. Let _env_ be the LexicalEnvironment of the running execution context.\n          1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n          1. Let _sourceText_ be the empty sequence of Unicode code points.\n          1. Let _initializer_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _formalParameterList_, |Initializer|, ~non-lexical-this~, _env_, _privateEnv_).\n          1. Perform MakeMethod(_initializer_, _homeObject_).\n          1. Set _initializer_.[[ClassFieldInitializerName]] to _name_.\n        1. Else,\n          1. Let _initializer_ be ~empty~.\n        1. Return the ClassFieldDefinition Record { [[Name]]: _name_, [[Initializer]]: _initializer_ }.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassStaticBlock","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassStaticBlockBody","ty":"Ast[ClassStaticBlockBody]","kind":{"Normal":{}}}]},"methodName":"ClassStaticBlockDefinitionEvaluation","isStatic":false,"withParams":[{"name":"homeObject","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Record[ClassStaticBlockDefinitionRecord]"}},"body":"\n  1. Let _lex_ be the running execution context.LexicalEnvironment.\n  1. Let _privateEnv_ be the running execution context.PrivateEnvironment.\n  1. Let _sourceText_ be *\"\"*.\n  1. Let _formalParameters_ be <emu-grammar>FormalParameters : [empty]</emu-grammar>.\n  1. [id=\"step-synthetic-class-static-block-fn\"] Let _bodyFunction_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _formalParameters_, |ClassStaticBlockBody|, ~non-lexical-this~, _lex_, _privateEnv_).\n  1. Perform MakeMethod(_bodyFunction_, _homeObject_).\n  1. Return ClassStaticBlockDefinition Record { [[BodyFunction]]: _bodyFunction_ }.","code":"\n        1. Let _lex_ be the running execution context's LexicalEnvironment.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the empty sequence of Unicode code points.\n        1. Let _formalParameters_ be an instance of the production <emu-grammar>FormalParameters : [empty]</emu-grammar>.\n        1. [id=\"step-synthetic-class-static-block-fn\"] Let _bodyFunction_ be OrdinaryFunctionCreate(%Function.prototype%, _sourceText_, _formalParameters_, |ClassStaticBlockBody|, ~non-lexical-this~, _lex_, _privateEnv_).\n        1. Perform MakeMethod(_bodyFunction_, _homeObject_).\n        1. Return the ClassStaticBlockDefinition Record { [[BodyFunction]]: _bodyFunction_ }.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassStaticBlockBody","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassStaticBlockStatementList","ty":"Ast[ClassStaticBlockStatementList]","kind":{"Normal":{}}}]},"methodName":"EvaluateClassStaticBlockBody","isStatic":false,"withParams":[{"name":"functionObject","ty":"Record[ECMAScriptFunctionObject]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Assert: _functionObject_ is a synthetic function created by ClassStaticBlockDefinitionEvaluation step <emu-xref href=\"#step-synthetic-class-static-block-fn\"></emu-xref>..\n  1. Perform ! FunctionDeclarationInstantiation(_functionObject_, « »).\n  1. Return ? the result of evaluating |ClassStaticBlockStatementList|.","code":"\n        1. Assert: _functionObject_ is a synthetic function created by ClassStaticBlockDefinitionEvaluation step <emu-xref href=\"#step-synthetic-class-static-block-fn\"></emu-xref>.\n        1. Perform ! FunctionDeclarationInstantiation(_functionObject_, « »).\n        1. Return ? Evaluation of |ClassStaticBlockStatementList|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElement","idx":2,"subIdx":0,"rhsParams":[{"name":"FieldDefinition","ty":"Ast[FieldDefinition]","kind":{"Normal":{}}}]},"methodName":"ClassElementEvaluation","isStatic":false,"withParams":[{"name":"object","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Normal[Record[ClassFieldDefinitionRecord | ClassStaticBlockDefinitionRecord | PrivateElement] | Enum[~unused~]] | Abrupt"}},"body":"\n  1. Return ? ClassFieldDefinitionEvaluation of |FieldDefinition| with argument _object_.","code":"\n        1. Return ? ClassFieldDefinitionEvaluation of |FieldDefinition| with argument _object_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElement","idx":3,"subIdx":0,"rhsParams":[{"name":"FieldDefinition","ty":"Ast[FieldDefinition]","kind":{"Normal":{}}}]},"methodName":"ClassElementEvaluation","isStatic":false,"withParams":[{"name":"object","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Normal[Record[ClassFieldDefinitionRecord | ClassStaticBlockDefinitionRecord | PrivateElement] | Enum[~unused~]] | Abrupt"}},"body":"\n  1. Return ? ClassFieldDefinitionEvaluation of |FieldDefinition| with argument _object_.","code":"\n        1. Return ? ClassFieldDefinitionEvaluation of |FieldDefinition| with argument _object_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElement","idx":0,"subIdx":0,"rhsParams":[{"name":"MethodDefinition","ty":"Ast[MethodDefinition]","kind":{"Normal":{}}}]},"methodName":"ClassElementEvaluation","isStatic":false,"withParams":[{"name":"object","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Normal[Record[ClassFieldDefinitionRecord | ClassStaticBlockDefinitionRecord | PrivateElement] | Enum[~unused~]] | Abrupt"}},"body":"\n  1. Return ? MethodDefinitionEvaluation of |MethodDefinition| with arguments _object_ and *false*.","code":"\n        1. Return ? MethodDefinitionEvaluation of |MethodDefinition| with arguments _object_ and *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElement","idx":1,"subIdx":0,"rhsParams":[{"name":"MethodDefinition","ty":"Ast[MethodDefinition]","kind":{"Normal":{}}}]},"methodName":"ClassElementEvaluation","isStatic":false,"withParams":[{"name":"object","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Normal[Record[ClassFieldDefinitionRecord | ClassStaticBlockDefinitionRecord | PrivateElement] | Enum[~unused~]] | Abrupt"}},"body":"\n  1. Return ? MethodDefinitionEvaluation of |MethodDefinition| with arguments _object_ and *false*.","code":"\n        1. Return ? MethodDefinitionEvaluation of |MethodDefinition| with arguments _object_ and *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElement","idx":4,"subIdx":0,"rhsParams":[{"name":"ClassStaticBlock","ty":"Ast[ClassStaticBlock]","kind":{"Normal":{}}}]},"methodName":"ClassElementEvaluation","isStatic":false,"withParams":[{"name":"object","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Normal[Record[ClassFieldDefinitionRecord | ClassStaticBlockDefinitionRecord | PrivateElement] | Enum[~unused~]] | Abrupt"}},"body":"\n  1. Return ClassStaticBlockDefinitionEvaluation of |ClassStaticBlock| with argument _object_.","code":"\n        1. Return ClassStaticBlockDefinitionEvaluation of |ClassStaticBlock| with argument _object_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElement","idx":5,"subIdx":0,"rhsParams":[]},"methodName":"ClassElementEvaluation","isStatic":false,"withParams":[{"name":"object","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Normal[Record[ClassFieldDefinitionRecord | ClassStaticBlockDefinitionRecord | PrivateElement] | Enum[~unused~]] | Abrupt"}},"body":"\n  1. Return ~unused~.","code":"\n        1. Return ~unused~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassTail","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassHeritage","ty":"Ast[ClassHeritage]","kind":{"Normal":{}}},{"name":"ClassBody","ty":"Ast[ClassBody]","kind":{"Normal":{}}}]},"methodName":"ClassDefinitionEvaluation","isStatic":false,"withParams":[{"name":"classBinding","ty":"String | Undefined","kind":{"Normal":{}}},{"name":"className","ty":"Record[PrivateName | Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Record[FunctionObject]] | Abrupt"}},"body":"\n  1. Let _env_ be the running execution context.LexicalEnvironment.\n  1. Let _classEnv_ be NewDeclarativeEnvironment(_env_).\n  1. If _classBinding_ is not *undefined*, then\n    1. Perform ! _classEnv_.CreateImmutableBinding(_classBinding_, *true*).\n  1. Let _outerPrivateEnvironment_ be the running execution context.PrivateEnvironment.\n  1. Let _classPrivateEnvironment_ be NewPrivateEnvironment(_outerPrivateEnvironment_).\n  1. If |ClassBody| is present, then\n    1. For each String _dn_ of PrivateBoundIdentifiers of |ClassBody|, do\n      1. If _classPrivateEnvironment_.[[Names]] contains a Record[PrivateName] _pn_ such that _pn_.[[Description]] is _dn_, then\n        1. Assert: This is only possible for getter/setter pairs..\n      1. Else,\n        1. Let _name_ be Private Name { [[Description]]: _dn_ }.\n        1. Append _name_ to _classPrivateEnvironment_.[[Names]].\n  1. If |ClassHeritage| is not present, then\n    1. Let _protoParent_ be %Object.prototype%.\n    1. Let _constructorParent_ be %Function.prototype%.\n  1. Else,\n    1. Set the running execution context.LexicalEnvironment to _classEnv_.\n    1. NOTE: The running execution context's PrivateEnvironment is _outerPrivateEnvironment_ when evaluating |ClassHeritage|.\n    1. Let _superclassRef_ be Completion(the result of evaluating |ClassHeritage|).\n    1. Set the running execution context.LexicalEnvironment to _env_.\n    1. Let _superclass_ be ? GetValue(? _superclassRef_).\n    1. If _superclass_ is *null*, then\n      1. Let _protoParent_ be *null*.\n      1. Let _constructorParent_ be %Function.prototype%.\n    1. Else if IsConstructor(_superclass_) is *false*, then\n      1. Throw a *TypeError* exception.\n    1. Else,\n      1. Let _protoParent_ be ? Get(_superclass_, *\"prototype\"*).\n      1. If _protoParent_ is not a Record[Object] and _protoParent_ is not *null*, throw a *TypeError* exception.\n      1. Let _constructorParent_ be _superclass_.\n  1. Let _proto_ be OrdinaryObjectCreate(_protoParent_).\n  1. If |ClassBody| is not present, let _constructor_ be ~empty~.\n  1. Else, let _constructor_ be ConstructorMethod of |ClassBody|.\n  1. Set the running execution context.LexicalEnvironment to _classEnv_.\n  1. Set the running execution context.PrivateEnvironment to _classPrivateEnvironment_.\n  1. If _constructor_ is ~empty~, then\n    1. Let _defaultConstructor_ be a new Abstract Closure with no parameters that captures  and performs the following steps when called:\n      1. Let _args_ be the List of arguments that was passed to this function by [[Call]] or [[Construct]].\n      1. If NewTarget is *undefined*, throw a *TypeError* exception.\n      1. Let _F_ be the active function object.\n      1. If _F_.[[ConstructorKind]] is ~derived~, then\n        1. NOTE: This branch behaves similarly to `constructor(...args) { super(...args); }`. The most notable distinction is that while the aforementioned ECMAScript source text observably calls the @@iterator method on `%Array.prototype%`, this function does not.\n        1. Let _func_ be ! _F_.[[GetPrototypeOf]]().\n        1. If IsConstructor(_func_) is *false*, throw a *TypeError* exception.\n        1. Let _result_ be ? Construct(_func_, _args_, NewTarget).\n      1. Else,\n        1. NOTE: This branch behaves similarly to `constructor() {}`.\n        1. Let _result_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Object.prototype%\"*).\n      1. Perform ? InitializeInstanceElements(_result_, _F_).\n      1. Return _result_.\n    1. Let _F_ be CreateBuiltinFunction(_defaultConstructor_, 0, _className_, « [[ConstructorKind]], [[SourceText]] », the current Realm Record, _constructorParent_).\n  1. Else,\n    1. Let _constructorInfo_ be ! DefineMethod of _constructor_ with arguments _proto_ and _constructorParent_.\n    1. Let _F_ be _constructorInfo_.[[Closure]].\n    1. Perform MakeClassConstructor(_F_).\n    1. Perform SetFunctionName(_F_, _className_).\n  1. Perform MakeConstructor(_F_, *false*, _proto_).\n  1. If |ClassHeritage| is present, set _F_.[[ConstructorKind]] to ~derived~.\n  1. Perform ! DefineMethodProperty(_proto_, *\"constructor\"*, _F_, *false*).\n  1. If |ClassBody| is not present, let _elements_ be « ».\n  1. Else, let _elements_ be NonConstructorElements of |ClassBody|.\n  1. Let _instancePrivateMethods_ be « ».\n  1. Let _staticPrivateMethods_ be « ».\n  1. Let _instanceFields_ be « ».\n  1. Let _staticElements_ be « ».\n  1. For each Ast[ClassElement] _e_ of _elements_, do\n    1. If IsStatic of _e_ is *false*, then\n      1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _proto_).\n    1. Else,\n      1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _F_).\n    1. If _element_ is an abrupt completion, then\n      1. Set the running execution context.LexicalEnvironment to _env_.\n      1. Set the running execution context.PrivateEnvironment to _outerPrivateEnvironment_.\n      1. Return ? _element_.\n    1. Set _element_ to ! _element_.\n    1. If _element_ is a Record[PrivateElement], then\n      1. Assert: _element_.[[Kind]] is either ~method~ or ~accessor~.\n      1. If IsStatic of _e_ is *false*, let _container_ be _instancePrivateMethods_.\n      1. Else, let _container_ be _staticPrivateMethods_.\n      1. If _container_ contains a Record[PrivateElement] _pe_ such that _pe_.[[Key]] is _element_.[[Key]], then\n        1. Assert: both _element_.[[Kind]] and _pe_.[[Kind]] are ~accessor~.\n        1. If _element_.[[Get]] is *undefined*, then\n          1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _pe_.[[Get]], [[Set]]: _element_.[[Set]] }.\n        1. Else,\n          1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _element_.[[Get]], [[Set]]: _pe_.[[Set]] }.\n        1. Replace _pe_ in _container_ with _combined_.\n      1. Else,\n        1. Append _element_ to _container_.\n    1. Else if _element_ is a Record[ClassFieldDefinitionRecord], then\n      1. If IsStatic of _e_ is *false*, append _element_ to _instanceFields_.\n      1. Else, append _element_ to _staticElements_.\n    1. Else if _element_ is a Record[ClassStaticBlockDefinitionRecord], then\n      1. Append _element_ to _staticElements_.\n  1. Set the running execution context.LexicalEnvironment to _env_.\n  1. If _classBinding_ is not *undefined*, then\n    1. Perform ! _classEnv_.InitializeBinding(_classBinding_, _F_).\n  1. Set _F_.[[PrivateMethods]] to _instancePrivateMethods_.\n  1. Set _F_.[[Fields]] to _instanceFields_.\n  1. For each Record[PrivateElement] _method_ of _staticPrivateMethods_, do\n    1. Perform ! PrivateMethodOrAccessorAdd(_F_, _method_).\n  1. For each _elementRecord_ of _staticElements_, do\n    1. If _elementRecord_ is a Record[ClassFieldDefinitionRecord], then\n      1. Let _result_ be Completion(DefineField(_F_, _elementRecord_)).\n    1. Else,\n      1. Assert: _elementRecord_ is a Record[ClassStaticBlockDefinitionRecord].\n      1. Let _result_ be Completion(Call(_elementRecord_.[[BodyFunction]], _F_)).\n    1. If _result_ is an abrupt completion, then\n      1. Set the running execution context.PrivateEnvironment to _outerPrivateEnvironment_.\n      1. Return ? _result_.\n  1. Set the running execution context.PrivateEnvironment to _outerPrivateEnvironment_.\n  1. Return _F_.","code":"\n        1. Let _env_ be the LexicalEnvironment of the running execution context.\n        1. Let _classEnv_ be NewDeclarativeEnvironment(_env_).\n        1. If _classBinding_ is not *undefined*, then\n          1. Perform ! _classEnv_.CreateImmutableBinding(_classBinding_, *true*).\n        1. Let _outerPrivateEnvironment_ be the running execution context's PrivateEnvironment.\n        1. Let _classPrivateEnvironment_ be NewPrivateEnvironment(_outerPrivateEnvironment_).\n        1. If |ClassBody| is present, then\n          1. For each String _dn_ of the PrivateBoundIdentifiers of |ClassBody|, do\n            1. If _classPrivateEnvironment_.[[Names]] contains a Private Name _pn_ such that _pn_.[[Description]] is _dn_, then\n              1. Assert: This is only possible for getter/setter pairs.\n            1. Else,\n              1. Let _name_ be a new Private Name whose [[Description]] is _dn_.\n              1. Append _name_ to _classPrivateEnvironment_.[[Names]].\n        1. If |ClassHeritage| is not present, then\n          1. Let _protoParent_ be %Object.prototype%.\n          1. Let _constructorParent_ be %Function.prototype%.\n        1. Else,\n          1. Set the running execution context's LexicalEnvironment to _classEnv_.\n          1. NOTE: The running execution context's PrivateEnvironment is _outerPrivateEnvironment_ when evaluating |ClassHeritage|.\n          1. Let _superclassRef_ be Completion(Evaluation of |ClassHeritage|).\n          1. Set the running execution context's LexicalEnvironment to _env_.\n          1. Let _superclass_ be ? GetValue(? _superclassRef_).\n          1. If _superclass_ is *null*, then\n            1. Let _protoParent_ be *null*.\n            1. Let _constructorParent_ be %Function.prototype%.\n          1. Else if IsConstructor(_superclass_) is *false*, then\n            1. Throw a *TypeError* exception.\n          1. Else,\n            1. Let _protoParent_ be ? Get(_superclass_, *\"prototype\"*).\n            1. If _protoParent_ is not an Object and _protoParent_ is not *null*, throw a *TypeError* exception.\n            1. Let _constructorParent_ be _superclass_.\n        1. Let _proto_ be OrdinaryObjectCreate(_protoParent_).\n        1. If |ClassBody| is not present, let _constructor_ be ~empty~.\n        1. Else, let _constructor_ be ConstructorMethod of |ClassBody|.\n        1. Set the running execution context's LexicalEnvironment to _classEnv_.\n        1. Set the running execution context's PrivateEnvironment to _classPrivateEnvironment_.\n        1. If _constructor_ is ~empty~, then\n          1. Let _defaultConstructor_ be a new Abstract Closure with no parameters that captures nothing and performs the following steps when called:\n            1. Let _args_ be the List of arguments that was passed to this function by [[Call]] or [[Construct]].\n            1. If NewTarget is *undefined*, throw a *TypeError* exception.\n            1. Let _F_ be the active function object.\n            1. If _F_.[[ConstructorKind]] is ~derived~, then\n              1. NOTE: This branch behaves similarly to `constructor(...args) { super(...args); }`. The most notable distinction is that while the aforementioned ECMAScript source text observably calls the @@iterator method on `%Array.prototype%`, this function does not.\n              1. Let _func_ be ! _F_.[[GetPrototypeOf]]().\n              1. If IsConstructor(_func_) is *false*, throw a *TypeError* exception.\n              1. Let _result_ be ? Construct(_func_, _args_, NewTarget).\n            1. Else,\n              1. NOTE: This branch behaves similarly to `constructor() {}`.\n              1. Let _result_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Object.prototype%\"*).\n            1. Perform ? InitializeInstanceElements(_result_, _F_).\n            1. Return _result_.\n          1. Let _F_ be CreateBuiltinFunction(_defaultConstructor_, 0, _className_, « [[ConstructorKind]], [[SourceText]] », the current Realm Record, _constructorParent_).\n        1. Else,\n          1. Let _constructorInfo_ be ! DefineMethod of _constructor_ with arguments _proto_ and _constructorParent_.\n          1. Let _F_ be _constructorInfo_.[[Closure]].\n          1. Perform MakeClassConstructor(_F_).\n          1. Perform SetFunctionName(_F_, _className_).\n        1. Perform MakeConstructor(_F_, *false*, _proto_).\n        1. If |ClassHeritage| is present, set _F_.[[ConstructorKind]] to ~derived~.\n        1. Perform ! DefineMethodProperty(_proto_, *\"constructor\"*, _F_, *false*).\n        1. If |ClassBody| is not present, let _elements_ be a new empty List.\n        1. Else, let _elements_ be NonConstructorElements of |ClassBody|.\n        1. Let _instancePrivateMethods_ be a new empty List.\n        1. Let _staticPrivateMethods_ be a new empty List.\n        1. Let _instanceFields_ be a new empty List.\n        1. Let _staticElements_ be a new empty List.\n        1. For each |ClassElement| _e_ of _elements_, do\n          1. If IsStatic of _e_ is *false*, then\n            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _proto_).\n          1. Else,\n            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _F_).\n          1. If _element_ is an abrupt completion, then\n            1. Set the running execution context's LexicalEnvironment to _env_.\n            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n            1. Return ? _element_.\n          1. Set _element_ to ! _element_.\n          1. If _element_ is a PrivateElement, then\n            1. Assert: _element_.[[Kind]] is either ~method~ or ~accessor~.\n            1. If IsStatic of _e_ is *false*, let _container_ be _instancePrivateMethods_.\n            1. Else, let _container_ be _staticPrivateMethods_.\n            1. If _container_ contains a PrivateElement _pe_ such that _pe_.[[Key]] is _element_.[[Key]], then\n              1. Assert: _element_.[[Kind]] and _pe_.[[Kind]] are both ~accessor~.\n              1. If _element_.[[Get]] is *undefined*, then\n                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _pe_.[[Get]], [[Set]]: _element_.[[Set]] }.\n              1. Else,\n                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _element_.[[Get]], [[Set]]: _pe_.[[Set]] }.\n              1. Replace _pe_ in _container_ with _combined_.\n            1. Else,\n              1. Append _element_ to _container_.\n          1. Else if _element_ is a ClassFieldDefinition Record, then\n            1. If IsStatic of _e_ is *false*, append _element_ to _instanceFields_.\n            1. Else, append _element_ to _staticElements_.\n          1. Else if _element_ is a ClassStaticBlockDefinition Record, then\n            1. Append _element_ to _staticElements_.\n        1. Set the running execution context's LexicalEnvironment to _env_.\n        1. If _classBinding_ is not *undefined*, then\n          1. Perform ! _classEnv_.InitializeBinding(_classBinding_, _F_).\n        1. Set _F_.[[PrivateMethods]] to _instancePrivateMethods_.\n        1. Set _F_.[[Fields]] to _instanceFields_.\n        1. For each PrivateElement _method_ of _staticPrivateMethods_, do\n          1. Perform ! PrivateMethodOrAccessorAdd(_F_, _method_).\n        1. For each element _elementRecord_ of _staticElements_, do\n          1. If _elementRecord_ is a ClassFieldDefinition Record, then\n            1. Let _result_ be Completion(DefineField(_F_, _elementRecord_)).\n          1. Else,\n            1. Assert: _elementRecord_ is a ClassStaticBlockDefinition Record.\n            1. Let _result_ be Completion(Call(_elementRecord_.[[BodyFunction]], _F_)).\n          1. If _result_ is an abrupt completion, then\n            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n            1. Return ? _result_.\n        1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n        1. Return _F_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassTail","idx":0,"subIdx":1,"rhsParams":[{"name":"ClassHeritage","ty":"Ast[ClassHeritage]","kind":{"Normal":{}}},{"name":"ClassBody","ty":"Ast[ClassBody]","kind":{"Normal":{}}}]},"methodName":"ClassDefinitionEvaluation","isStatic":false,"withParams":[{"name":"classBinding","ty":"String | Undefined","kind":{"Normal":{}}},{"name":"className","ty":"Record[PrivateName | Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Record[FunctionObject]] | Abrupt"}},"body":"\n  1. Let _env_ be the running execution context.LexicalEnvironment.\n  1. Let _classEnv_ be NewDeclarativeEnvironment(_env_).\n  1. If _classBinding_ is not *undefined*, then\n    1. Perform ! _classEnv_.CreateImmutableBinding(_classBinding_, *true*).\n  1. Let _outerPrivateEnvironment_ be the running execution context.PrivateEnvironment.\n  1. Let _classPrivateEnvironment_ be NewPrivateEnvironment(_outerPrivateEnvironment_).\n  1. If |ClassBody| is present, then\n    1. For each String _dn_ of PrivateBoundIdentifiers of |ClassBody|, do\n      1. If _classPrivateEnvironment_.[[Names]] contains a Record[PrivateName] _pn_ such that _pn_.[[Description]] is _dn_, then\n        1. Assert: This is only possible for getter/setter pairs..\n      1. Else,\n        1. Let _name_ be Private Name { [[Description]]: _dn_ }.\n        1. Append _name_ to _classPrivateEnvironment_.[[Names]].\n  1. If |ClassHeritage| is not present, then\n    1. Let _protoParent_ be %Object.prototype%.\n    1. Let _constructorParent_ be %Function.prototype%.\n  1. Else,\n    1. Set the running execution context.LexicalEnvironment to _classEnv_.\n    1. NOTE: The running execution context's PrivateEnvironment is _outerPrivateEnvironment_ when evaluating |ClassHeritage|.\n    1. Let _superclassRef_ be Completion(the result of evaluating |ClassHeritage|).\n    1. Set the running execution context.LexicalEnvironment to _env_.\n    1. Let _superclass_ be ? GetValue(? _superclassRef_).\n    1. If _superclass_ is *null*, then\n      1. Let _protoParent_ be *null*.\n      1. Let _constructorParent_ be %Function.prototype%.\n    1. Else if IsConstructor(_superclass_) is *false*, then\n      1. Throw a *TypeError* exception.\n    1. Else,\n      1. Let _protoParent_ be ? Get(_superclass_, *\"prototype\"*).\n      1. If _protoParent_ is not a Record[Object] and _protoParent_ is not *null*, throw a *TypeError* exception.\n      1. Let _constructorParent_ be _superclass_.\n  1. Let _proto_ be OrdinaryObjectCreate(_protoParent_).\n  1. If |ClassBody| is not present, let _constructor_ be ~empty~.\n  1. Else, let _constructor_ be ConstructorMethod of |ClassBody|.\n  1. Set the running execution context.LexicalEnvironment to _classEnv_.\n  1. Set the running execution context.PrivateEnvironment to _classPrivateEnvironment_.\n  1. If _constructor_ is ~empty~, then\n    1. Let _defaultConstructor_ be a new Abstract Closure with no parameters that captures  and performs the following steps when called:\n      1. Let _args_ be the List of arguments that was passed to this function by [[Call]] or [[Construct]].\n      1. If NewTarget is *undefined*, throw a *TypeError* exception.\n      1. Let _F_ be the active function object.\n      1. If _F_.[[ConstructorKind]] is ~derived~, then\n        1. NOTE: This branch behaves similarly to `constructor(...args) { super(...args); }`. The most notable distinction is that while the aforementioned ECMAScript source text observably calls the @@iterator method on `%Array.prototype%`, this function does not.\n        1. Let _func_ be ! _F_.[[GetPrototypeOf]]().\n        1. If IsConstructor(_func_) is *false*, throw a *TypeError* exception.\n        1. Let _result_ be ? Construct(_func_, _args_, NewTarget).\n      1. Else,\n        1. NOTE: This branch behaves similarly to `constructor() {}`.\n        1. Let _result_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Object.prototype%\"*).\n      1. Perform ? InitializeInstanceElements(_result_, _F_).\n      1. Return _result_.\n    1. Let _F_ be CreateBuiltinFunction(_defaultConstructor_, 0, _className_, « [[ConstructorKind]], [[SourceText]] », the current Realm Record, _constructorParent_).\n  1. Else,\n    1. Let _constructorInfo_ be ! DefineMethod of _constructor_ with arguments _proto_ and _constructorParent_.\n    1. Let _F_ be _constructorInfo_.[[Closure]].\n    1. Perform MakeClassConstructor(_F_).\n    1. Perform SetFunctionName(_F_, _className_).\n  1. Perform MakeConstructor(_F_, *false*, _proto_).\n  1. If |ClassHeritage| is present, set _F_.[[ConstructorKind]] to ~derived~.\n  1. Perform ! DefineMethodProperty(_proto_, *\"constructor\"*, _F_, *false*).\n  1. If |ClassBody| is not present, let _elements_ be « ».\n  1. Else, let _elements_ be NonConstructorElements of |ClassBody|.\n  1. Let _instancePrivateMethods_ be « ».\n  1. Let _staticPrivateMethods_ be « ».\n  1. Let _instanceFields_ be « ».\n  1. Let _staticElements_ be « ».\n  1. For each Ast[ClassElement] _e_ of _elements_, do\n    1. If IsStatic of _e_ is *false*, then\n      1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _proto_).\n    1. Else,\n      1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _F_).\n    1. If _element_ is an abrupt completion, then\n      1. Set the running execution context.LexicalEnvironment to _env_.\n      1. Set the running execution context.PrivateEnvironment to _outerPrivateEnvironment_.\n      1. Return ? _element_.\n    1. Set _element_ to ! _element_.\n    1. If _element_ is a Record[PrivateElement], then\n      1. Assert: _element_.[[Kind]] is either ~method~ or ~accessor~.\n      1. If IsStatic of _e_ is *false*, let _container_ be _instancePrivateMethods_.\n      1. Else, let _container_ be _staticPrivateMethods_.\n      1. If _container_ contains a Record[PrivateElement] _pe_ such that _pe_.[[Key]] is _element_.[[Key]], then\n        1. Assert: both _element_.[[Kind]] and _pe_.[[Kind]] are ~accessor~.\n        1. If _element_.[[Get]] is *undefined*, then\n          1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _pe_.[[Get]], [[Set]]: _element_.[[Set]] }.\n        1. Else,\n          1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _element_.[[Get]], [[Set]]: _pe_.[[Set]] }.\n        1. Replace _pe_ in _container_ with _combined_.\n      1. Else,\n        1. Append _element_ to _container_.\n    1. Else if _element_ is a Record[ClassFieldDefinitionRecord], then\n      1. If IsStatic of _e_ is *false*, append _element_ to _instanceFields_.\n      1. Else, append _element_ to _staticElements_.\n    1. Else if _element_ is a Record[ClassStaticBlockDefinitionRecord], then\n      1. Append _element_ to _staticElements_.\n  1. Set the running execution context.LexicalEnvironment to _env_.\n  1. If _classBinding_ is not *undefined*, then\n    1. Perform ! _classEnv_.InitializeBinding(_classBinding_, _F_).\n  1. Set _F_.[[PrivateMethods]] to _instancePrivateMethods_.\n  1. Set _F_.[[Fields]] to _instanceFields_.\n  1. For each Record[PrivateElement] _method_ of _staticPrivateMethods_, do\n    1. Perform ! PrivateMethodOrAccessorAdd(_F_, _method_).\n  1. For each _elementRecord_ of _staticElements_, do\n    1. If _elementRecord_ is a Record[ClassFieldDefinitionRecord], then\n      1. Let _result_ be Completion(DefineField(_F_, _elementRecord_)).\n    1. Else,\n      1. Assert: _elementRecord_ is a Record[ClassStaticBlockDefinitionRecord].\n      1. Let _result_ be Completion(Call(_elementRecord_.[[BodyFunction]], _F_)).\n    1. If _result_ is an abrupt completion, then\n      1. Set the running execution context.PrivateEnvironment to _outerPrivateEnvironment_.\n      1. Return ? _result_.\n  1. Set the running execution context.PrivateEnvironment to _outerPrivateEnvironment_.\n  1. Return _F_.","code":"\n        1. Let _env_ be the LexicalEnvironment of the running execution context.\n        1. Let _classEnv_ be NewDeclarativeEnvironment(_env_).\n        1. If _classBinding_ is not *undefined*, then\n          1. Perform ! _classEnv_.CreateImmutableBinding(_classBinding_, *true*).\n        1. Let _outerPrivateEnvironment_ be the running execution context's PrivateEnvironment.\n        1. Let _classPrivateEnvironment_ be NewPrivateEnvironment(_outerPrivateEnvironment_).\n        1. If |ClassBody| is present, then\n          1. For each String _dn_ of the PrivateBoundIdentifiers of |ClassBody|, do\n            1. If _classPrivateEnvironment_.[[Names]] contains a Private Name _pn_ such that _pn_.[[Description]] is _dn_, then\n              1. Assert: This is only possible for getter/setter pairs.\n            1. Else,\n              1. Let _name_ be a new Private Name whose [[Description]] is _dn_.\n              1. Append _name_ to _classPrivateEnvironment_.[[Names]].\n        1. If |ClassHeritage| is not present, then\n          1. Let _protoParent_ be %Object.prototype%.\n          1. Let _constructorParent_ be %Function.prototype%.\n        1. Else,\n          1. Set the running execution context's LexicalEnvironment to _classEnv_.\n          1. NOTE: The running execution context's PrivateEnvironment is _outerPrivateEnvironment_ when evaluating |ClassHeritage|.\n          1. Let _superclassRef_ be Completion(Evaluation of |ClassHeritage|).\n          1. Set the running execution context's LexicalEnvironment to _env_.\n          1. Let _superclass_ be ? GetValue(? _superclassRef_).\n          1. If _superclass_ is *null*, then\n            1. Let _protoParent_ be *null*.\n            1. Let _constructorParent_ be %Function.prototype%.\n          1. Else if IsConstructor(_superclass_) is *false*, then\n            1. Throw a *TypeError* exception.\n          1. Else,\n            1. Let _protoParent_ be ? Get(_superclass_, *\"prototype\"*).\n            1. If _protoParent_ is not an Object and _protoParent_ is not *null*, throw a *TypeError* exception.\n            1. Let _constructorParent_ be _superclass_.\n        1. Let _proto_ be OrdinaryObjectCreate(_protoParent_).\n        1. If |ClassBody| is not present, let _constructor_ be ~empty~.\n        1. Else, let _constructor_ be ConstructorMethod of |ClassBody|.\n        1. Set the running execution context's LexicalEnvironment to _classEnv_.\n        1. Set the running execution context's PrivateEnvironment to _classPrivateEnvironment_.\n        1. If _constructor_ is ~empty~, then\n          1. Let _defaultConstructor_ be a new Abstract Closure with no parameters that captures nothing and performs the following steps when called:\n            1. Let _args_ be the List of arguments that was passed to this function by [[Call]] or [[Construct]].\n            1. If NewTarget is *undefined*, throw a *TypeError* exception.\n            1. Let _F_ be the active function object.\n            1. If _F_.[[ConstructorKind]] is ~derived~, then\n              1. NOTE: This branch behaves similarly to `constructor(...args) { super(...args); }`. The most notable distinction is that while the aforementioned ECMAScript source text observably calls the @@iterator method on `%Array.prototype%`, this function does not.\n              1. Let _func_ be ! _F_.[[GetPrototypeOf]]().\n              1. If IsConstructor(_func_) is *false*, throw a *TypeError* exception.\n              1. Let _result_ be ? Construct(_func_, _args_, NewTarget).\n            1. Else,\n              1. NOTE: This branch behaves similarly to `constructor() {}`.\n              1. Let _result_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Object.prototype%\"*).\n            1. Perform ? InitializeInstanceElements(_result_, _F_).\n            1. Return _result_.\n          1. Let _F_ be CreateBuiltinFunction(_defaultConstructor_, 0, _className_, « [[ConstructorKind]], [[SourceText]] », the current Realm Record, _constructorParent_).\n        1. Else,\n          1. Let _constructorInfo_ be ! DefineMethod of _constructor_ with arguments _proto_ and _constructorParent_.\n          1. Let _F_ be _constructorInfo_.[[Closure]].\n          1. Perform MakeClassConstructor(_F_).\n          1. Perform SetFunctionName(_F_, _className_).\n        1. Perform MakeConstructor(_F_, *false*, _proto_).\n        1. If |ClassHeritage| is present, set _F_.[[ConstructorKind]] to ~derived~.\n        1. Perform ! DefineMethodProperty(_proto_, *\"constructor\"*, _F_, *false*).\n        1. If |ClassBody| is not present, let _elements_ be a new empty List.\n        1. Else, let _elements_ be NonConstructorElements of |ClassBody|.\n        1. Let _instancePrivateMethods_ be a new empty List.\n        1. Let _staticPrivateMethods_ be a new empty List.\n        1. Let _instanceFields_ be a new empty List.\n        1. Let _staticElements_ be a new empty List.\n        1. For each |ClassElement| _e_ of _elements_, do\n          1. If IsStatic of _e_ is *false*, then\n            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _proto_).\n          1. Else,\n            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _F_).\n          1. If _element_ is an abrupt completion, then\n            1. Set the running execution context's LexicalEnvironment to _env_.\n            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n            1. Return ? _element_.\n          1. Set _element_ to ! _element_.\n          1. If _element_ is a PrivateElement, then\n            1. Assert: _element_.[[Kind]] is either ~method~ or ~accessor~.\n            1. If IsStatic of _e_ is *false*, let _container_ be _instancePrivateMethods_.\n            1. Else, let _container_ be _staticPrivateMethods_.\n            1. If _container_ contains a PrivateElement _pe_ such that _pe_.[[Key]] is _element_.[[Key]], then\n              1. Assert: _element_.[[Kind]] and _pe_.[[Kind]] are both ~accessor~.\n              1. If _element_.[[Get]] is *undefined*, then\n                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _pe_.[[Get]], [[Set]]: _element_.[[Set]] }.\n              1. Else,\n                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _element_.[[Get]], [[Set]]: _pe_.[[Set]] }.\n              1. Replace _pe_ in _container_ with _combined_.\n            1. Else,\n              1. Append _element_ to _container_.\n          1. Else if _element_ is a ClassFieldDefinition Record, then\n            1. If IsStatic of _e_ is *false*, append _element_ to _instanceFields_.\n            1. Else, append _element_ to _staticElements_.\n          1. Else if _element_ is a ClassStaticBlockDefinition Record, then\n            1. Append _element_ to _staticElements_.\n        1. Set the running execution context's LexicalEnvironment to _env_.\n        1. If _classBinding_ is not *undefined*, then\n          1. Perform ! _classEnv_.InitializeBinding(_classBinding_, _F_).\n        1. Set _F_.[[PrivateMethods]] to _instancePrivateMethods_.\n        1. Set _F_.[[Fields]] to _instanceFields_.\n        1. For each PrivateElement _method_ of _staticPrivateMethods_, do\n          1. Perform ! PrivateMethodOrAccessorAdd(_F_, _method_).\n        1. For each element _elementRecord_ of _staticElements_, do\n          1. If _elementRecord_ is a ClassFieldDefinition Record, then\n            1. Let _result_ be Completion(DefineField(_F_, _elementRecord_)).\n          1. Else,\n            1. Assert: _elementRecord_ is a ClassStaticBlockDefinition Record.\n            1. Let _result_ be Completion(Call(_elementRecord_.[[BodyFunction]], _F_)).\n          1. If _result_ is an abrupt completion, then\n            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n            1. Return ? _result_.\n        1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n        1. Return _F_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassTail","idx":0,"subIdx":2,"rhsParams":[{"name":"ClassHeritage","ty":"Ast[ClassHeritage]","kind":{"Normal":{}}},{"name":"ClassBody","ty":"Ast[ClassBody]","kind":{"Normal":{}}}]},"methodName":"ClassDefinitionEvaluation","isStatic":false,"withParams":[{"name":"classBinding","ty":"String | Undefined","kind":{"Normal":{}}},{"name":"className","ty":"Record[PrivateName | Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Record[FunctionObject]] | Abrupt"}},"body":"\n  1. Let _env_ be the running execution context.LexicalEnvironment.\n  1. Let _classEnv_ be NewDeclarativeEnvironment(_env_).\n  1. If _classBinding_ is not *undefined*, then\n    1. Perform ! _classEnv_.CreateImmutableBinding(_classBinding_, *true*).\n  1. Let _outerPrivateEnvironment_ be the running execution context.PrivateEnvironment.\n  1. Let _classPrivateEnvironment_ be NewPrivateEnvironment(_outerPrivateEnvironment_).\n  1. If |ClassBody| is present, then\n    1. For each String _dn_ of PrivateBoundIdentifiers of |ClassBody|, do\n      1. If _classPrivateEnvironment_.[[Names]] contains a Record[PrivateName] _pn_ such that _pn_.[[Description]] is _dn_, then\n        1. Assert: This is only possible for getter/setter pairs..\n      1. Else,\n        1. Let _name_ be Private Name { [[Description]]: _dn_ }.\n        1. Append _name_ to _classPrivateEnvironment_.[[Names]].\n  1. If |ClassHeritage| is not present, then\n    1. Let _protoParent_ be %Object.prototype%.\n    1. Let _constructorParent_ be %Function.prototype%.\n  1. Else,\n    1. Set the running execution context.LexicalEnvironment to _classEnv_.\n    1. NOTE: The running execution context's PrivateEnvironment is _outerPrivateEnvironment_ when evaluating |ClassHeritage|.\n    1. Let _superclassRef_ be Completion(the result of evaluating |ClassHeritage|).\n    1. Set the running execution context.LexicalEnvironment to _env_.\n    1. Let _superclass_ be ? GetValue(? _superclassRef_).\n    1. If _superclass_ is *null*, then\n      1. Let _protoParent_ be *null*.\n      1. Let _constructorParent_ be %Function.prototype%.\n    1. Else if IsConstructor(_superclass_) is *false*, then\n      1. Throw a *TypeError* exception.\n    1. Else,\n      1. Let _protoParent_ be ? Get(_superclass_, *\"prototype\"*).\n      1. If _protoParent_ is not a Record[Object] and _protoParent_ is not *null*, throw a *TypeError* exception.\n      1. Let _constructorParent_ be _superclass_.\n  1. Let _proto_ be OrdinaryObjectCreate(_protoParent_).\n  1. If |ClassBody| is not present, let _constructor_ be ~empty~.\n  1. Else, let _constructor_ be ConstructorMethod of |ClassBody|.\n  1. Set the running execution context.LexicalEnvironment to _classEnv_.\n  1. Set the running execution context.PrivateEnvironment to _classPrivateEnvironment_.\n  1. If _constructor_ is ~empty~, then\n    1. Let _defaultConstructor_ be a new Abstract Closure with no parameters that captures  and performs the following steps when called:\n      1. Let _args_ be the List of arguments that was passed to this function by [[Call]] or [[Construct]].\n      1. If NewTarget is *undefined*, throw a *TypeError* exception.\n      1. Let _F_ be the active function object.\n      1. If _F_.[[ConstructorKind]] is ~derived~, then\n        1. NOTE: This branch behaves similarly to `constructor(...args) { super(...args); }`. The most notable distinction is that while the aforementioned ECMAScript source text observably calls the @@iterator method on `%Array.prototype%`, this function does not.\n        1. Let _func_ be ! _F_.[[GetPrototypeOf]]().\n        1. If IsConstructor(_func_) is *false*, throw a *TypeError* exception.\n        1. Let _result_ be ? Construct(_func_, _args_, NewTarget).\n      1. Else,\n        1. NOTE: This branch behaves similarly to `constructor() {}`.\n        1. Let _result_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Object.prototype%\"*).\n      1. Perform ? InitializeInstanceElements(_result_, _F_).\n      1. Return _result_.\n    1. Let _F_ be CreateBuiltinFunction(_defaultConstructor_, 0, _className_, « [[ConstructorKind]], [[SourceText]] », the current Realm Record, _constructorParent_).\n  1. Else,\n    1. Let _constructorInfo_ be ! DefineMethod of _constructor_ with arguments _proto_ and _constructorParent_.\n    1. Let _F_ be _constructorInfo_.[[Closure]].\n    1. Perform MakeClassConstructor(_F_).\n    1. Perform SetFunctionName(_F_, _className_).\n  1. Perform MakeConstructor(_F_, *false*, _proto_).\n  1. If |ClassHeritage| is present, set _F_.[[ConstructorKind]] to ~derived~.\n  1. Perform ! DefineMethodProperty(_proto_, *\"constructor\"*, _F_, *false*).\n  1. If |ClassBody| is not present, let _elements_ be « ».\n  1. Else, let _elements_ be NonConstructorElements of |ClassBody|.\n  1. Let _instancePrivateMethods_ be « ».\n  1. Let _staticPrivateMethods_ be « ».\n  1. Let _instanceFields_ be « ».\n  1. Let _staticElements_ be « ».\n  1. For each Ast[ClassElement] _e_ of _elements_, do\n    1. If IsStatic of _e_ is *false*, then\n      1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _proto_).\n    1. Else,\n      1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _F_).\n    1. If _element_ is an abrupt completion, then\n      1. Set the running execution context.LexicalEnvironment to _env_.\n      1. Set the running execution context.PrivateEnvironment to _outerPrivateEnvironment_.\n      1. Return ? _element_.\n    1. Set _element_ to ! _element_.\n    1. If _element_ is a Record[PrivateElement], then\n      1. Assert: _element_.[[Kind]] is either ~method~ or ~accessor~.\n      1. If IsStatic of _e_ is *false*, let _container_ be _instancePrivateMethods_.\n      1. Else, let _container_ be _staticPrivateMethods_.\n      1. If _container_ contains a Record[PrivateElement] _pe_ such that _pe_.[[Key]] is _element_.[[Key]], then\n        1. Assert: both _element_.[[Kind]] and _pe_.[[Kind]] are ~accessor~.\n        1. If _element_.[[Get]] is *undefined*, then\n          1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _pe_.[[Get]], [[Set]]: _element_.[[Set]] }.\n        1. Else,\n          1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _element_.[[Get]], [[Set]]: _pe_.[[Set]] }.\n        1. Replace _pe_ in _container_ with _combined_.\n      1. Else,\n        1. Append _element_ to _container_.\n    1. Else if _element_ is a Record[ClassFieldDefinitionRecord], then\n      1. If IsStatic of _e_ is *false*, append _element_ to _instanceFields_.\n      1. Else, append _element_ to _staticElements_.\n    1. Else if _element_ is a Record[ClassStaticBlockDefinitionRecord], then\n      1. Append _element_ to _staticElements_.\n  1. Set the running execution context.LexicalEnvironment to _env_.\n  1. If _classBinding_ is not *undefined*, then\n    1. Perform ! _classEnv_.InitializeBinding(_classBinding_, _F_).\n  1. Set _F_.[[PrivateMethods]] to _instancePrivateMethods_.\n  1. Set _F_.[[Fields]] to _instanceFields_.\n  1. For each Record[PrivateElement] _method_ of _staticPrivateMethods_, do\n    1. Perform ! PrivateMethodOrAccessorAdd(_F_, _method_).\n  1. For each _elementRecord_ of _staticElements_, do\n    1. If _elementRecord_ is a Record[ClassFieldDefinitionRecord], then\n      1. Let _result_ be Completion(DefineField(_F_, _elementRecord_)).\n    1. Else,\n      1. Assert: _elementRecord_ is a Record[ClassStaticBlockDefinitionRecord].\n      1. Let _result_ be Completion(Call(_elementRecord_.[[BodyFunction]], _F_)).\n    1. If _result_ is an abrupt completion, then\n      1. Set the running execution context.PrivateEnvironment to _outerPrivateEnvironment_.\n      1. Return ? _result_.\n  1. Set the running execution context.PrivateEnvironment to _outerPrivateEnvironment_.\n  1. Return _F_.","code":"\n        1. Let _env_ be the LexicalEnvironment of the running execution context.\n        1. Let _classEnv_ be NewDeclarativeEnvironment(_env_).\n        1. If _classBinding_ is not *undefined*, then\n          1. Perform ! _classEnv_.CreateImmutableBinding(_classBinding_, *true*).\n        1. Let _outerPrivateEnvironment_ be the running execution context's PrivateEnvironment.\n        1. Let _classPrivateEnvironment_ be NewPrivateEnvironment(_outerPrivateEnvironment_).\n        1. If |ClassBody| is present, then\n          1. For each String _dn_ of the PrivateBoundIdentifiers of |ClassBody|, do\n            1. If _classPrivateEnvironment_.[[Names]] contains a Private Name _pn_ such that _pn_.[[Description]] is _dn_, then\n              1. Assert: This is only possible for getter/setter pairs.\n            1. Else,\n              1. Let _name_ be a new Private Name whose [[Description]] is _dn_.\n              1. Append _name_ to _classPrivateEnvironment_.[[Names]].\n        1. If |ClassHeritage| is not present, then\n          1. Let _protoParent_ be %Object.prototype%.\n          1. Let _constructorParent_ be %Function.prototype%.\n        1. Else,\n          1. Set the running execution context's LexicalEnvironment to _classEnv_.\n          1. NOTE: The running execution context's PrivateEnvironment is _outerPrivateEnvironment_ when evaluating |ClassHeritage|.\n          1. Let _superclassRef_ be Completion(Evaluation of |ClassHeritage|).\n          1. Set the running execution context's LexicalEnvironment to _env_.\n          1. Let _superclass_ be ? GetValue(? _superclassRef_).\n          1. If _superclass_ is *null*, then\n            1. Let _protoParent_ be *null*.\n            1. Let _constructorParent_ be %Function.prototype%.\n          1. Else if IsConstructor(_superclass_) is *false*, then\n            1. Throw a *TypeError* exception.\n          1. Else,\n            1. Let _protoParent_ be ? Get(_superclass_, *\"prototype\"*).\n            1. If _protoParent_ is not an Object and _protoParent_ is not *null*, throw a *TypeError* exception.\n            1. Let _constructorParent_ be _superclass_.\n        1. Let _proto_ be OrdinaryObjectCreate(_protoParent_).\n        1. If |ClassBody| is not present, let _constructor_ be ~empty~.\n        1. Else, let _constructor_ be ConstructorMethod of |ClassBody|.\n        1. Set the running execution context's LexicalEnvironment to _classEnv_.\n        1. Set the running execution context's PrivateEnvironment to _classPrivateEnvironment_.\n        1. If _constructor_ is ~empty~, then\n          1. Let _defaultConstructor_ be a new Abstract Closure with no parameters that captures nothing and performs the following steps when called:\n            1. Let _args_ be the List of arguments that was passed to this function by [[Call]] or [[Construct]].\n            1. If NewTarget is *undefined*, throw a *TypeError* exception.\n            1. Let _F_ be the active function object.\n            1. If _F_.[[ConstructorKind]] is ~derived~, then\n              1. NOTE: This branch behaves similarly to `constructor(...args) { super(...args); }`. The most notable distinction is that while the aforementioned ECMAScript source text observably calls the @@iterator method on `%Array.prototype%`, this function does not.\n              1. Let _func_ be ! _F_.[[GetPrototypeOf]]().\n              1. If IsConstructor(_func_) is *false*, throw a *TypeError* exception.\n              1. Let _result_ be ? Construct(_func_, _args_, NewTarget).\n            1. Else,\n              1. NOTE: This branch behaves similarly to `constructor() {}`.\n              1. Let _result_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Object.prototype%\"*).\n            1. Perform ? InitializeInstanceElements(_result_, _F_).\n            1. Return _result_.\n          1. Let _F_ be CreateBuiltinFunction(_defaultConstructor_, 0, _className_, « [[ConstructorKind]], [[SourceText]] », the current Realm Record, _constructorParent_).\n        1. Else,\n          1. Let _constructorInfo_ be ! DefineMethod of _constructor_ with arguments _proto_ and _constructorParent_.\n          1. Let _F_ be _constructorInfo_.[[Closure]].\n          1. Perform MakeClassConstructor(_F_).\n          1. Perform SetFunctionName(_F_, _className_).\n        1. Perform MakeConstructor(_F_, *false*, _proto_).\n        1. If |ClassHeritage| is present, set _F_.[[ConstructorKind]] to ~derived~.\n        1. Perform ! DefineMethodProperty(_proto_, *\"constructor\"*, _F_, *false*).\n        1. If |ClassBody| is not present, let _elements_ be a new empty List.\n        1. Else, let _elements_ be NonConstructorElements of |ClassBody|.\n        1. Let _instancePrivateMethods_ be a new empty List.\n        1. Let _staticPrivateMethods_ be a new empty List.\n        1. Let _instanceFields_ be a new empty List.\n        1. Let _staticElements_ be a new empty List.\n        1. For each |ClassElement| _e_ of _elements_, do\n          1. If IsStatic of _e_ is *false*, then\n            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _proto_).\n          1. Else,\n            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _F_).\n          1. If _element_ is an abrupt completion, then\n            1. Set the running execution context's LexicalEnvironment to _env_.\n            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n            1. Return ? _element_.\n          1. Set _element_ to ! _element_.\n          1. If _element_ is a PrivateElement, then\n            1. Assert: _element_.[[Kind]] is either ~method~ or ~accessor~.\n            1. If IsStatic of _e_ is *false*, let _container_ be _instancePrivateMethods_.\n            1. Else, let _container_ be _staticPrivateMethods_.\n            1. If _container_ contains a PrivateElement _pe_ such that _pe_.[[Key]] is _element_.[[Key]], then\n              1. Assert: _element_.[[Kind]] and _pe_.[[Kind]] are both ~accessor~.\n              1. If _element_.[[Get]] is *undefined*, then\n                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _pe_.[[Get]], [[Set]]: _element_.[[Set]] }.\n              1. Else,\n                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _element_.[[Get]], [[Set]]: _pe_.[[Set]] }.\n              1. Replace _pe_ in _container_ with _combined_.\n            1. Else,\n              1. Append _element_ to _container_.\n          1. Else if _element_ is a ClassFieldDefinition Record, then\n            1. If IsStatic of _e_ is *false*, append _element_ to _instanceFields_.\n            1. Else, append _element_ to _staticElements_.\n          1. Else if _element_ is a ClassStaticBlockDefinition Record, then\n            1. Append _element_ to _staticElements_.\n        1. Set the running execution context's LexicalEnvironment to _env_.\n        1. If _classBinding_ is not *undefined*, then\n          1. Perform ! _classEnv_.InitializeBinding(_classBinding_, _F_).\n        1. Set _F_.[[PrivateMethods]] to _instancePrivateMethods_.\n        1. Set _F_.[[Fields]] to _instanceFields_.\n        1. For each PrivateElement _method_ of _staticPrivateMethods_, do\n          1. Perform ! PrivateMethodOrAccessorAdd(_F_, _method_).\n        1. For each element _elementRecord_ of _staticElements_, do\n          1. If _elementRecord_ is a ClassFieldDefinition Record, then\n            1. Let _result_ be Completion(DefineField(_F_, _elementRecord_)).\n          1. Else,\n            1. Assert: _elementRecord_ is a ClassStaticBlockDefinition Record.\n            1. Let _result_ be Completion(Call(_elementRecord_.[[BodyFunction]], _F_)).\n          1. If _result_ is an abrupt completion, then\n            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n            1. Return ? _result_.\n        1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n        1. Return _F_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassTail","idx":0,"subIdx":3,"rhsParams":[{"name":"ClassHeritage","ty":"Ast[ClassHeritage]","kind":{"Normal":{}}},{"name":"ClassBody","ty":"Ast[ClassBody]","kind":{"Normal":{}}}]},"methodName":"ClassDefinitionEvaluation","isStatic":false,"withParams":[{"name":"classBinding","ty":"String | Undefined","kind":{"Normal":{}}},{"name":"className","ty":"Record[PrivateName | Symbol] | String","kind":{"Normal":{}}}],"retTy":"Normal[Record[FunctionObject]] | Abrupt"}},"body":"\n  1. Let _env_ be the running execution context.LexicalEnvironment.\n  1. Let _classEnv_ be NewDeclarativeEnvironment(_env_).\n  1. If _classBinding_ is not *undefined*, then\n    1. Perform ! _classEnv_.CreateImmutableBinding(_classBinding_, *true*).\n  1. Let _outerPrivateEnvironment_ be the running execution context.PrivateEnvironment.\n  1. Let _classPrivateEnvironment_ be NewPrivateEnvironment(_outerPrivateEnvironment_).\n  1. If |ClassBody| is present, then\n    1. For each String _dn_ of PrivateBoundIdentifiers of |ClassBody|, do\n      1. If _classPrivateEnvironment_.[[Names]] contains a Record[PrivateName] _pn_ such that _pn_.[[Description]] is _dn_, then\n        1. Assert: This is only possible for getter/setter pairs..\n      1. Else,\n        1. Let _name_ be Private Name { [[Description]]: _dn_ }.\n        1. Append _name_ to _classPrivateEnvironment_.[[Names]].\n  1. If |ClassHeritage| is not present, then\n    1. Let _protoParent_ be %Object.prototype%.\n    1. Let _constructorParent_ be %Function.prototype%.\n  1. Else,\n    1. Set the running execution context.LexicalEnvironment to _classEnv_.\n    1. NOTE: The running execution context's PrivateEnvironment is _outerPrivateEnvironment_ when evaluating |ClassHeritage|.\n    1. Let _superclassRef_ be Completion(the result of evaluating |ClassHeritage|).\n    1. Set the running execution context.LexicalEnvironment to _env_.\n    1. Let _superclass_ be ? GetValue(? _superclassRef_).\n    1. If _superclass_ is *null*, then\n      1. Let _protoParent_ be *null*.\n      1. Let _constructorParent_ be %Function.prototype%.\n    1. Else if IsConstructor(_superclass_) is *false*, then\n      1. Throw a *TypeError* exception.\n    1. Else,\n      1. Let _protoParent_ be ? Get(_superclass_, *\"prototype\"*).\n      1. If _protoParent_ is not a Record[Object] and _protoParent_ is not *null*, throw a *TypeError* exception.\n      1. Let _constructorParent_ be _superclass_.\n  1. Let _proto_ be OrdinaryObjectCreate(_protoParent_).\n  1. If |ClassBody| is not present, let _constructor_ be ~empty~.\n  1. Else, let _constructor_ be ConstructorMethod of |ClassBody|.\n  1. Set the running execution context.LexicalEnvironment to _classEnv_.\n  1. Set the running execution context.PrivateEnvironment to _classPrivateEnvironment_.\n  1. If _constructor_ is ~empty~, then\n    1. Let _defaultConstructor_ be a new Abstract Closure with no parameters that captures  and performs the following steps when called:\n      1. Let _args_ be the List of arguments that was passed to this function by [[Call]] or [[Construct]].\n      1. If NewTarget is *undefined*, throw a *TypeError* exception.\n      1. Let _F_ be the active function object.\n      1. If _F_.[[ConstructorKind]] is ~derived~, then\n        1. NOTE: This branch behaves similarly to `constructor(...args) { super(...args); }`. The most notable distinction is that while the aforementioned ECMAScript source text observably calls the @@iterator method on `%Array.prototype%`, this function does not.\n        1. Let _func_ be ! _F_.[[GetPrototypeOf]]().\n        1. If IsConstructor(_func_) is *false*, throw a *TypeError* exception.\n        1. Let _result_ be ? Construct(_func_, _args_, NewTarget).\n      1. Else,\n        1. NOTE: This branch behaves similarly to `constructor() {}`.\n        1. Let _result_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Object.prototype%\"*).\n      1. Perform ? InitializeInstanceElements(_result_, _F_).\n      1. Return _result_.\n    1. Let _F_ be CreateBuiltinFunction(_defaultConstructor_, 0, _className_, « [[ConstructorKind]], [[SourceText]] », the current Realm Record, _constructorParent_).\n  1. Else,\n    1. Let _constructorInfo_ be ! DefineMethod of _constructor_ with arguments _proto_ and _constructorParent_.\n    1. Let _F_ be _constructorInfo_.[[Closure]].\n    1. Perform MakeClassConstructor(_F_).\n    1. Perform SetFunctionName(_F_, _className_).\n  1. Perform MakeConstructor(_F_, *false*, _proto_).\n  1. If |ClassHeritage| is present, set _F_.[[ConstructorKind]] to ~derived~.\n  1. Perform ! DefineMethodProperty(_proto_, *\"constructor\"*, _F_, *false*).\n  1. If |ClassBody| is not present, let _elements_ be « ».\n  1. Else, let _elements_ be NonConstructorElements of |ClassBody|.\n  1. Let _instancePrivateMethods_ be « ».\n  1. Let _staticPrivateMethods_ be « ».\n  1. Let _instanceFields_ be « ».\n  1. Let _staticElements_ be « ».\n  1. For each Ast[ClassElement] _e_ of _elements_, do\n    1. If IsStatic of _e_ is *false*, then\n      1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _proto_).\n    1. Else,\n      1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _F_).\n    1. If _element_ is an abrupt completion, then\n      1. Set the running execution context.LexicalEnvironment to _env_.\n      1. Set the running execution context.PrivateEnvironment to _outerPrivateEnvironment_.\n      1. Return ? _element_.\n    1. Set _element_ to ! _element_.\n    1. If _element_ is a Record[PrivateElement], then\n      1. Assert: _element_.[[Kind]] is either ~method~ or ~accessor~.\n      1. If IsStatic of _e_ is *false*, let _container_ be _instancePrivateMethods_.\n      1. Else, let _container_ be _staticPrivateMethods_.\n      1. If _container_ contains a Record[PrivateElement] _pe_ such that _pe_.[[Key]] is _element_.[[Key]], then\n        1. Assert: both _element_.[[Kind]] and _pe_.[[Kind]] are ~accessor~.\n        1. If _element_.[[Get]] is *undefined*, then\n          1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _pe_.[[Get]], [[Set]]: _element_.[[Set]] }.\n        1. Else,\n          1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _element_.[[Get]], [[Set]]: _pe_.[[Set]] }.\n        1. Replace _pe_ in _container_ with _combined_.\n      1. Else,\n        1. Append _element_ to _container_.\n    1. Else if _element_ is a Record[ClassFieldDefinitionRecord], then\n      1. If IsStatic of _e_ is *false*, append _element_ to _instanceFields_.\n      1. Else, append _element_ to _staticElements_.\n    1. Else if _element_ is a Record[ClassStaticBlockDefinitionRecord], then\n      1. Append _element_ to _staticElements_.\n  1. Set the running execution context.LexicalEnvironment to _env_.\n  1. If _classBinding_ is not *undefined*, then\n    1. Perform ! _classEnv_.InitializeBinding(_classBinding_, _F_).\n  1. Set _F_.[[PrivateMethods]] to _instancePrivateMethods_.\n  1. Set _F_.[[Fields]] to _instanceFields_.\n  1. For each Record[PrivateElement] _method_ of _staticPrivateMethods_, do\n    1. Perform ! PrivateMethodOrAccessorAdd(_F_, _method_).\n  1. For each _elementRecord_ of _staticElements_, do\n    1. If _elementRecord_ is a Record[ClassFieldDefinitionRecord], then\n      1. Let _result_ be Completion(DefineField(_F_, _elementRecord_)).\n    1. Else,\n      1. Assert: _elementRecord_ is a Record[ClassStaticBlockDefinitionRecord].\n      1. Let _result_ be Completion(Call(_elementRecord_.[[BodyFunction]], _F_)).\n    1. If _result_ is an abrupt completion, then\n      1. Set the running execution context.PrivateEnvironment to _outerPrivateEnvironment_.\n      1. Return ? _result_.\n  1. Set the running execution context.PrivateEnvironment to _outerPrivateEnvironment_.\n  1. Return _F_.","code":"\n        1. Let _env_ be the LexicalEnvironment of the running execution context.\n        1. Let _classEnv_ be NewDeclarativeEnvironment(_env_).\n        1. If _classBinding_ is not *undefined*, then\n          1. Perform ! _classEnv_.CreateImmutableBinding(_classBinding_, *true*).\n        1. Let _outerPrivateEnvironment_ be the running execution context's PrivateEnvironment.\n        1. Let _classPrivateEnvironment_ be NewPrivateEnvironment(_outerPrivateEnvironment_).\n        1. If |ClassBody| is present, then\n          1. For each String _dn_ of the PrivateBoundIdentifiers of |ClassBody|, do\n            1. If _classPrivateEnvironment_.[[Names]] contains a Private Name _pn_ such that _pn_.[[Description]] is _dn_, then\n              1. Assert: This is only possible for getter/setter pairs.\n            1. Else,\n              1. Let _name_ be a new Private Name whose [[Description]] is _dn_.\n              1. Append _name_ to _classPrivateEnvironment_.[[Names]].\n        1. If |ClassHeritage| is not present, then\n          1. Let _protoParent_ be %Object.prototype%.\n          1. Let _constructorParent_ be %Function.prototype%.\n        1. Else,\n          1. Set the running execution context's LexicalEnvironment to _classEnv_.\n          1. NOTE: The running execution context's PrivateEnvironment is _outerPrivateEnvironment_ when evaluating |ClassHeritage|.\n          1. Let _superclassRef_ be Completion(Evaluation of |ClassHeritage|).\n          1. Set the running execution context's LexicalEnvironment to _env_.\n          1. Let _superclass_ be ? GetValue(? _superclassRef_).\n          1. If _superclass_ is *null*, then\n            1. Let _protoParent_ be *null*.\n            1. Let _constructorParent_ be %Function.prototype%.\n          1. Else if IsConstructor(_superclass_) is *false*, then\n            1. Throw a *TypeError* exception.\n          1. Else,\n            1. Let _protoParent_ be ? Get(_superclass_, *\"prototype\"*).\n            1. If _protoParent_ is not an Object and _protoParent_ is not *null*, throw a *TypeError* exception.\n            1. Let _constructorParent_ be _superclass_.\n        1. Let _proto_ be OrdinaryObjectCreate(_protoParent_).\n        1. If |ClassBody| is not present, let _constructor_ be ~empty~.\n        1. Else, let _constructor_ be ConstructorMethod of |ClassBody|.\n        1. Set the running execution context's LexicalEnvironment to _classEnv_.\n        1. Set the running execution context's PrivateEnvironment to _classPrivateEnvironment_.\n        1. If _constructor_ is ~empty~, then\n          1. Let _defaultConstructor_ be a new Abstract Closure with no parameters that captures nothing and performs the following steps when called:\n            1. Let _args_ be the List of arguments that was passed to this function by [[Call]] or [[Construct]].\n            1. If NewTarget is *undefined*, throw a *TypeError* exception.\n            1. Let _F_ be the active function object.\n            1. If _F_.[[ConstructorKind]] is ~derived~, then\n              1. NOTE: This branch behaves similarly to `constructor(...args) { super(...args); }`. The most notable distinction is that while the aforementioned ECMAScript source text observably calls the @@iterator method on `%Array.prototype%`, this function does not.\n              1. Let _func_ be ! _F_.[[GetPrototypeOf]]().\n              1. If IsConstructor(_func_) is *false*, throw a *TypeError* exception.\n              1. Let _result_ be ? Construct(_func_, _args_, NewTarget).\n            1. Else,\n              1. NOTE: This branch behaves similarly to `constructor() {}`.\n              1. Let _result_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Object.prototype%\"*).\n            1. Perform ? InitializeInstanceElements(_result_, _F_).\n            1. Return _result_.\n          1. Let _F_ be CreateBuiltinFunction(_defaultConstructor_, 0, _className_, « [[ConstructorKind]], [[SourceText]] », the current Realm Record, _constructorParent_).\n        1. Else,\n          1. Let _constructorInfo_ be ! DefineMethod of _constructor_ with arguments _proto_ and _constructorParent_.\n          1. Let _F_ be _constructorInfo_.[[Closure]].\n          1. Perform MakeClassConstructor(_F_).\n          1. Perform SetFunctionName(_F_, _className_).\n        1. Perform MakeConstructor(_F_, *false*, _proto_).\n        1. If |ClassHeritage| is present, set _F_.[[ConstructorKind]] to ~derived~.\n        1. Perform ! DefineMethodProperty(_proto_, *\"constructor\"*, _F_, *false*).\n        1. If |ClassBody| is not present, let _elements_ be a new empty List.\n        1. Else, let _elements_ be NonConstructorElements of |ClassBody|.\n        1. Let _instancePrivateMethods_ be a new empty List.\n        1. Let _staticPrivateMethods_ be a new empty List.\n        1. Let _instanceFields_ be a new empty List.\n        1. Let _staticElements_ be a new empty List.\n        1. For each |ClassElement| _e_ of _elements_, do\n          1. If IsStatic of _e_ is *false*, then\n            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _proto_).\n          1. Else,\n            1. Let _element_ be Completion(ClassElementEvaluation of _e_ with argument _F_).\n          1. If _element_ is an abrupt completion, then\n            1. Set the running execution context's LexicalEnvironment to _env_.\n            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n            1. Return ? _element_.\n          1. Set _element_ to ! _element_.\n          1. If _element_ is a PrivateElement, then\n            1. Assert: _element_.[[Kind]] is either ~method~ or ~accessor~.\n            1. If IsStatic of _e_ is *false*, let _container_ be _instancePrivateMethods_.\n            1. Else, let _container_ be _staticPrivateMethods_.\n            1. If _container_ contains a PrivateElement _pe_ such that _pe_.[[Key]] is _element_.[[Key]], then\n              1. Assert: _element_.[[Kind]] and _pe_.[[Kind]] are both ~accessor~.\n              1. If _element_.[[Get]] is *undefined*, then\n                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _pe_.[[Get]], [[Set]]: _element_.[[Set]] }.\n              1. Else,\n                1. Let _combined_ be PrivateElement { [[Key]]: _element_.[[Key]], [[Kind]]: ~accessor~, [[Get]]: _element_.[[Get]], [[Set]]: _pe_.[[Set]] }.\n              1. Replace _pe_ in _container_ with _combined_.\n            1. Else,\n              1. Append _element_ to _container_.\n          1. Else if _element_ is a ClassFieldDefinition Record, then\n            1. If IsStatic of _e_ is *false*, append _element_ to _instanceFields_.\n            1. Else, append _element_ to _staticElements_.\n          1. Else if _element_ is a ClassStaticBlockDefinition Record, then\n            1. Append _element_ to _staticElements_.\n        1. Set the running execution context's LexicalEnvironment to _env_.\n        1. If _classBinding_ is not *undefined*, then\n          1. Perform ! _classEnv_.InitializeBinding(_classBinding_, _F_).\n        1. Set _F_.[[PrivateMethods]] to _instancePrivateMethods_.\n        1. Set _F_.[[Fields]] to _instanceFields_.\n        1. For each PrivateElement _method_ of _staticPrivateMethods_, do\n          1. Perform ! PrivateMethodOrAccessorAdd(_F_, _method_).\n        1. For each element _elementRecord_ of _staticElements_, do\n          1. If _elementRecord_ is a ClassFieldDefinition Record, then\n            1. Let _result_ be Completion(DefineField(_F_, _elementRecord_)).\n          1. Else,\n            1. Assert: _elementRecord_ is a ClassStaticBlockDefinition Record.\n            1. Let _result_ be Completion(Call(_elementRecord_.[[BodyFunction]], _F_)).\n          1. If _result_ is an abrupt completion, then\n            1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n            1. Return ? _result_.\n        1. Set the running execution context's PrivateEnvironment to _outerPrivateEnvironment_.\n        1. Return _F_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"ClassTail","ty":"Ast[ClassTail]","kind":{"Normal":{}}}]},"methodName":"BindingClassDeclarationEvaluation","isStatic":false,"withParams":[],"retTy":"Normal[Record[FunctionObject]] | Abrupt"}},"body":"\n  1. Let _className_ be StringValue of |BindingIdentifier|.\n  1. Let _value_ be ? ClassDefinitionEvaluation of |ClassTail| with arguments _className_ and _className_.\n  1. Set _value_.[[SourceText]] to the source text matched by |ClassDeclaration|.\n  1. Let _env_ be the running execution context.LexicalEnvironment.\n  1. Perform ? InitializeBoundName(_className_, _value_, _env_).\n  1. Return _value_.","code":"\n        1. Let _className_ be StringValue of |BindingIdentifier|.\n        1. Let _value_ be ? ClassDefinitionEvaluation of |ClassTail| with arguments _className_ and _className_.\n        1. Set _value_.[[SourceText]] to the source text matched by |ClassDeclaration|.\n        1. Let _env_ be the running execution context's LexicalEnvironment.\n        1. Perform ? InitializeBoundName(_className_, _value_, _env_).\n        1. Return _value_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"ClassTail","ty":"Ast[ClassTail]","kind":{"Normal":{}}}]},"methodName":"BindingClassDeclarationEvaluation","isStatic":false,"withParams":[],"retTy":"Normal[Record[FunctionObject]] | Abrupt"}},"body":"\n  1. Let _value_ be ? ClassDefinitionEvaluation of |ClassTail| with arguments *undefined* and *\"default\"*.\n  1. Set _value_.[[SourceText]] to the source text matched by |ClassDeclaration|.\n  1. Return _value_.","code":"\n        1. Let _value_ be ? ClassDefinitionEvaluation of |ClassTail| with arguments *undefined* and *\"default\"*.\n        1. Set _value_.[[SourceText]] to the source text matched by |ClassDeclaration|.\n        1. Return _value_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"ClassTail","ty":"Ast[ClassTail]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Perform ? BindingClassDeclarationEvaluation of *this* value.\n  1. Return ~empty~.","code":"\n        1. Perform ? BindingClassDeclarationEvaluation of this |ClassDeclaration|.\n        1. Return ~empty~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassTail","ty":"Ast[ClassTail]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _value_ be ? ClassDefinitionEvaluation of |ClassTail| with arguments *undefined* and *\"\"*.\n  1. Set _value_.[[SourceText]] to the source text matched by |ClassExpression|.\n  1. Return _value_.","code":"\n        1. Let _value_ be ? ClassDefinitionEvaluation of |ClassTail| with arguments *undefined* and *\"\"*.\n        1. Set _value_.[[SourceText]] to the source text matched by |ClassExpression|.\n        1. Return _value_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassExpression","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"ClassTail","ty":"Ast[ClassTail]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _className_ be StringValue of |BindingIdentifier|.\n  1. Let _value_ be ? ClassDefinitionEvaluation of |ClassTail| with arguments _className_ and _className_.\n  1. Set _value_.[[SourceText]] to the source text matched by |ClassExpression|.\n  1. Return _value_.","code":"\n        1. Let _className_ be StringValue of |BindingIdentifier|.\n        1. Let _value_ be ? ClassDefinitionEvaluation of |ClassTail| with arguments _className_ and _className_.\n        1. Set _value_.[[SourceText]] to the source text matched by |ClassExpression|.\n        1. Return _value_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassElementName","idx":1,"subIdx":0,"rhsParams":[{"name":"PrivateIdentifier","ty":"Ast[PrivateIdentifier]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _privateIdentifier_ be StringValue of |PrivateIdentifier|.\n  1. Let _privateEnvRec_ be the running execution context.PrivateEnvironment.\n  1. Let _names_ be _privateEnvRec_.[[Names]].\n  1. Assert: Exactly one element of _names_ is a Private Name whose [[Description]] is _privateIdentifier_..\n  1. Let _privateName_ be the Private Name in _names_ whose [[Description]] is _privateIdentifier_.\n  1. Return _privateName_.","code":"\n        1. Let _privateIdentifier_ be StringValue of |PrivateIdentifier|.\n        1. Let _privateEnvRec_ be the running execution context's PrivateEnvironment.\n        1. Let _names_ be _privateEnvRec_.[[Names]].\n        1. Assert: Exactly one element of _names_ is a Private Name whose [[Description]] is _privateIdentifier_.\n        1. Let _privateName_ be the Private Name in _names_ whose [[Description]] is _privateIdentifier_.\n        1. Return _privateName_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassStaticBlockStatementList","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return *undefined*.","code":"\n        1. Return *undefined*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncFunctionDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"InstantiateAsyncFunctionObject","isStatic":false,"withParams":[{"name":"env","ty":"Record[EnvironmentRecord]","kind":{"Normal":{}}},{"name":"privateEnv","ty":"Record[PrivateEnvironmentRecord] | Null","kind":{"Normal":{}}}],"retTy":"Record[ECMAScriptFunctionObject]"}},"body":"\n  1. Let _name_ be StringValue of |BindingIdentifier|.\n  1. Let _sourceText_ be the source text matched by |AsyncFunctionDeclaration|.\n  1. Let _F_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n  1. Perform SetFunctionName(_F_, _name_).\n  1. Return _F_.","code":"\n        1. Let _name_ be StringValue of |BindingIdentifier|.\n        1. Let _sourceText_ be the source text matched by |AsyncFunctionDeclaration|.\n        1. Let _F_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_F_, _name_).\n        1. Return _F_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncFunctionDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"InstantiateAsyncFunctionObject","isStatic":false,"withParams":[{"name":"env","ty":"Record[EnvironmentRecord]","kind":{"Normal":{}}},{"name":"privateEnv","ty":"Record[PrivateEnvironmentRecord] | Null","kind":{"Normal":{}}}],"retTy":"Record[ECMAScriptFunctionObject]"}},"body":"\n  1. Let _sourceText_ be the source text matched by |AsyncFunctionDeclaration|.\n  1. Let _F_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n  1. Perform SetFunctionName(_F_, *\"default\"*).\n  1. Return _F_.","code":"\n        1. Let _sourceText_ be the source text matched by |AsyncFunctionDeclaration|.\n        1. Let _F_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_F_, *\"default\"*).\n        1. Return _F_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncFunctionExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"InstantiateAsyncFunctionExpression","isStatic":false,"withParams":[{"name":"name","ty":"Record[PrivateName | Symbol] | String","kind":{"Optional":{}}}],"retTy":"Record[ECMAScriptFunctionObject]"}},"body":"\n  1. If _name_ is not present, set _name_ to *\"\"*.\n  1. Let _env_ be the running execution context.LexicalEnvironment.\n  1. Let _privateEnv_ be the running execution context.PrivateEnvironment.\n  1. Let _sourceText_ be the source text matched by |AsyncFunctionExpression|.\n  1. Let _closure_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n  1. Perform SetFunctionName(_closure_, _name_).\n  1. Return _closure_.","code":"\n        1. If _name_ is not present, set _name_ to *\"\"*.\n        1. Let _env_ be the LexicalEnvironment of the running execution context.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |AsyncFunctionExpression|.\n        1. Let _closure_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_closure_, _name_).\n        1. Return _closure_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncFunctionExpression","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"InstantiateAsyncFunctionExpression","isStatic":false,"withParams":[{"name":"name","ty":"Record[PrivateName | Symbol] | String","kind":{"Optional":{}}}],"retTy":"Record[ECMAScriptFunctionObject]"}},"body":"\n  1. Assert: _name_ is not present.\n  1. Set _name_ to StringValue of |BindingIdentifier|.\n  1. Let _outerEnv_ be the running execution context.LexicalEnvironment.\n  1. Let _funcEnv_ be NewDeclarativeEnvironment(_outerEnv_).\n  1. Perform ! _funcEnv_.CreateImmutableBinding(_name_, *false*).\n  1. Let _privateEnv_ be the running execution context.PrivateEnvironment.\n  1. Let _sourceText_ be the source text matched by |AsyncFunctionExpression|.\n  1. Let _closure_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_).\n  1. Perform SetFunctionName(_closure_, _name_).\n  1. Perform ! _funcEnv_.InitializeBinding(_name_, _closure_).\n  1. Return _closure_.","code":"\n        1. Assert: _name_ is not present.\n        1. Set _name_ to StringValue of |BindingIdentifier|.\n        1. Let _outerEnv_ be the LexicalEnvironment of the running execution context.\n        1. Let _funcEnv_ be NewDeclarativeEnvironment(_outerEnv_).\n        1. Perform ! _funcEnv_.CreateImmutableBinding(_name_, *false*).\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |AsyncFunctionExpression|.\n        1. Let _closure_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, |FormalParameters|, |AsyncFunctionBody|, ~non-lexical-this~, _funcEnv_, _privateEnv_).\n        1. Perform SetFunctionName(_closure_, _name_).\n        1. Perform ! _funcEnv_.InitializeBinding(_name_, _closure_).\n        1. Return _closure_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncFunctionBody","idx":0,"subIdx":0,"rhsParams":[{"name":"FunctionBody","ty":"Ast[FunctionBody]","kind":{"Normal":{}}}]},"methodName":"EvaluateAsyncFunctionBody","isStatic":false,"withParams":[{"name":"functionObject","ty":"Record[ECMAScriptFunctionObject]","kind":{"Normal":{}}},{"name":"argumentsList","ty":"List[ESValue]","kind":{"Normal":{}}}],"retTy":"Return"}},"body":"\n  1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n  1. Let _declResult_ be Completion(FunctionDeclarationInstantiation(_functionObject_, _argumentsList_)).\n  1. If _declResult_ is an abrupt completion, then\n    1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _declResult_.[[Value]] »).\n  1. Else,\n    1. Perform AsyncFunctionStart(_promiseCapability_, |FunctionBody|).\n  1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _promiseCapability_.[[Promise]], [[Target]]: ~empty~ }.","code":"\n        1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n        1. Let _declResult_ be Completion(FunctionDeclarationInstantiation(_functionObject_, _argumentsList_)).\n        1. If _declResult_ is an abrupt completion, then\n          1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _declResult_.[[Value]] »).\n        1. Else,\n          1. Perform AsyncFunctionStart(_promiseCapability_, |FunctionBody|).\n        1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _promiseCapability_.[[Promise]], [[Target]]: ~empty~ }.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncFunctionExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return InstantiateAsyncFunctionExpression of |AsyncFunctionExpression|.","code":"\n        1. Return InstantiateAsyncFunctionExpression of |AsyncFunctionExpression|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncFunctionExpression","idx":0,"subIdx":1,"rhsParams":[{"name":"BindingIdentifier","ty":"Ast[BindingIdentifier]","kind":{"Normal":{}}},{"name":"FormalParameters","ty":"Ast[FormalParameters]","kind":{"Normal":{}}},{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return InstantiateAsyncFunctionExpression of |AsyncFunctionExpression|.","code":"\n        1. Return InstantiateAsyncFunctionExpression of |AsyncFunctionExpression|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AwaitExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _exprRef_ be ? the result of evaluating |UnaryExpression|.\n  1. Let _value_ be ? GetValue(_exprRef_).\n  1. Return ? Await(_value_).","code":"\n        1. Let _exprRef_ be ? Evaluation of |UnaryExpression|.\n        1. Let _value_ be ? GetValue(_exprRef_).\n        1. Return ? Await(_value_).\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncConciseBody","idx":0,"subIdx":0,"rhsParams":[{"name":"ExpressionBody","ty":"Ast[ExpressionBody]","kind":{"Normal":{}}}]},"methodName":"AsyncConciseBodyContainsUseStrict","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncConciseBody","idx":1,"subIdx":0,"rhsParams":[{"name":"AsyncFunctionBody","ty":"Ast[AsyncFunctionBody]","kind":{"Normal":{}}}]},"methodName":"AsyncConciseBodyContainsUseStrict","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return FunctionBodyContainsUseStrict of |AsyncFunctionBody|.","code":"\n        1. Return FunctionBodyContainsUseStrict of |AsyncFunctionBody|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncConciseBody","idx":0,"subIdx":0,"rhsParams":[{"name":"ExpressionBody","ty":"Ast[ExpressionBody]","kind":{"Normal":{}}}]},"methodName":"EvaluateAsyncConciseBody","isStatic":false,"withParams":[{"name":"functionObject","ty":"Record[ECMAScriptFunctionObject]","kind":{"Normal":{}}},{"name":"argumentsList","ty":"List[ESValue]","kind":{"Normal":{}}}],"retTy":"Return"}},"body":"\n  1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n  1. Let _declResult_ be Completion(FunctionDeclarationInstantiation(_functionObject_, _argumentsList_)).\n  1. If _declResult_ is an abrupt completion, then\n    1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _declResult_.[[Value]] »).\n  1. Else,\n    1. Perform AsyncFunctionStart(_promiseCapability_, |ExpressionBody|).\n  1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _promiseCapability_.[[Promise]], [[Target]]: ~empty~ }.","code":"\n        1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n        1. Let _declResult_ be Completion(FunctionDeclarationInstantiation(_functionObject_, _argumentsList_)).\n        1. If _declResult_ is an abrupt completion, then\n          1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _declResult_.[[Value]] »).\n        1. Else,\n          1. Perform AsyncFunctionStart(_promiseCapability_, |ExpressionBody|).\n        1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _promiseCapability_.[[Promise]], [[Target]]: ~empty~ }.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncArrowFunction","idx":0,"subIdx":0,"rhsParams":[{"name":"AsyncArrowBindingIdentifier","ty":"Ast[AsyncArrowBindingIdentifier]","kind":{"Normal":{}}},{"name":"AsyncConciseBody","ty":"Ast[AsyncConciseBody]","kind":{"Normal":{}}}]},"methodName":"InstantiateAsyncArrowFunctionExpression","isStatic":false,"withParams":[{"name":"name","ty":"Record[PrivateName | Symbol] | String","kind":{"Optional":{}}}],"retTy":"Record[ECMAScriptFunctionObject]"}},"body":"\n  1. If _name_ is not present, set _name_ to *\"\"*.\n  1. Let _env_ be the running execution context.LexicalEnvironment.\n  1. Let _privateEnv_ be the running execution context.PrivateEnvironment.\n  1. Let _sourceText_ be the source text matched by |AsyncArrowFunction|.\n  1. Let _parameters_ be |AsyncArrowBindingIdentifier|.\n  1. Let _closure_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, _parameters_, |AsyncConciseBody|, ~lexical-this~, _env_, _privateEnv_).\n  1. Perform SetFunctionName(_closure_, _name_).\n  1. Return _closure_.","code":"\n        1. If _name_ is not present, set _name_ to *\"\"*.\n        1. Let _env_ be the LexicalEnvironment of the running execution context.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |AsyncArrowFunction|.\n        1. Let _parameters_ be |AsyncArrowBindingIdentifier|.\n        1. Let _closure_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, _parameters_, |AsyncConciseBody|, ~lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_closure_, _name_).\n        1. Return _closure_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncArrowFunction","idx":1,"subIdx":0,"rhsParams":[{"name":"CoverCallExpressionAndAsyncArrowHead","ty":"Ast[CoverCallExpressionAndAsyncArrowHead]","kind":{"Normal":{}}},{"name":"AsyncConciseBody","ty":"Ast[AsyncConciseBody]","kind":{"Normal":{}}}]},"methodName":"InstantiateAsyncArrowFunctionExpression","isStatic":false,"withParams":[{"name":"name","ty":"Record[PrivateName | Symbol] | String","kind":{"Optional":{}}}],"retTy":"Record[ECMAScriptFunctionObject]"}},"body":"\n  1. If _name_ is not present, set _name_ to *\"\"*.\n  1. Let _env_ be the running execution context.LexicalEnvironment.\n  1. Let _privateEnv_ be the running execution context.PrivateEnvironment.\n  1. Let _sourceText_ be the source text matched by |AsyncArrowFunction|.\n  1. Let _head_ be the |AsyncArrowHead| that is covered by |CoverCallExpressionAndAsyncArrowHead|.\n  1. Let _parameters_ be the |ArrowFormalParameters| of _head_.\n  1. Let _closure_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, _parameters_, |AsyncConciseBody|, ~lexical-this~, _env_, _privateEnv_).\n  1. Perform SetFunctionName(_closure_, _name_).\n  1. Return _closure_.","code":"\n        1. If _name_ is not present, set _name_ to *\"\"*.\n        1. Let _env_ be the LexicalEnvironment of the running execution context.\n        1. Let _privateEnv_ be the running execution context's PrivateEnvironment.\n        1. Let _sourceText_ be the source text matched by |AsyncArrowFunction|.\n        1. Let _head_ be the |AsyncArrowHead| that is covered by |CoverCallExpressionAndAsyncArrowHead|.\n        1. Let _parameters_ be the |ArrowFormalParameters| of _head_.\n        1. Let _closure_ be OrdinaryFunctionCreate(%AsyncFunction.prototype%, _sourceText_, _parameters_, |AsyncConciseBody|, ~lexical-this~, _env_, _privateEnv_).\n        1. Perform SetFunctionName(_closure_, _name_).\n        1. Return _closure_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncArrowFunction","idx":0,"subIdx":0,"rhsParams":[{"name":"AsyncArrowBindingIdentifier","ty":"Ast[AsyncArrowBindingIdentifier]","kind":{"Normal":{}}},{"name":"AsyncConciseBody","ty":"Ast[AsyncConciseBody]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return InstantiateAsyncArrowFunctionExpression of |AsyncArrowFunction|.","code":"\n        1. Return InstantiateAsyncArrowFunctionExpression of |AsyncArrowFunction|.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AsyncArrowFunction","idx":1,"subIdx":0,"rhsParams":[{"name":"CoverCallExpressionAndAsyncArrowHead","ty":"Ast[CoverCallExpressionAndAsyncArrowHead]","kind":{"Normal":{}}},{"name":"AsyncConciseBody","ty":"Ast[AsyncConciseBody]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return InstantiateAsyncArrowFunctionExpression of |AsyncArrowFunction|.","code":"\n        1. Return InstantiateAsyncArrowFunctionExpression of |AsyncArrowFunction|.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsInTailPosition","params":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If the source text matched by _call_ is non-strict code, return *false*.\n  1. If _call_ is not contained within a |FunctionBody|, a |ConciseBody|, or an |AsyncConciseBody|, return *false*.\n  1. Let _body_ be the |FunctionBody|, |ConciseBody|, or |AsyncConciseBody| that most closely contains _call_.\n  1. If _body_ is the |FunctionBody| of a |GeneratorBody|, return *false*.\n  1. If _body_ is the |FunctionBody| of an |AsyncFunctionBody|, return *false*.\n  1. If _body_ is the |FunctionBody| of an |AsyncGeneratorBody|, return *false*.\n  1. If _body_ is a Ast[AsyncConciseBody], return *false*.\n  1. Return HasCallInTailPosition of _body_ with argument _call_.","code":"\n        1. If the source text matched by _call_ is non-strict code, return *false*.\n        1. If _call_ is not contained within a |FunctionBody|, a |ConciseBody|, or an |AsyncConciseBody|, return *false*.\n        1. Let _body_ be the |FunctionBody|, |ConciseBody|, or |AsyncConciseBody| that most closely contains _call_.\n        1. If _body_ is the |FunctionBody| of a |GeneratorBody|, return *false*.\n        1. If _body_ is the |FunctionBody| of an |AsyncFunctionBody|, return *false*.\n        1. If _body_ is the |FunctionBody| of an |AsyncGeneratorBody|, return *false*.\n        1. If _body_ is an |AsyncConciseBody|, return *false*.\n        1. Return the result of HasCallInTailPosition of _body_ with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementList","idx":1,"subIdx":0,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}},{"name":"StatementListItem","ty":"Ast[StatementListItem]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _has_ be HasCallInTailPosition of |StatementList| with argument _call_.\n  1. If _has_ is *true*, return *true*.\n  1. Return HasCallInTailPosition of |StatementListItem| with argument _call_.","code":"\n        1. Let _has_ be HasCallInTailPosition of |StatementList| with argument _call_.\n        1. If _has_ is *true*, return *true*.\n        1. Return HasCallInTailPosition of |StatementListItem| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"FunctionStatementList","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"StatementListItem","idx":1,"subIdx":0,"rhsParams":[{"name":"Declaration","ty":"Ast[Declaration]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":1,"subIdx":0,"rhsParams":[{"name":"VariableStatement","ty":"Ast[VariableStatement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":2,"subIdx":0,"rhsParams":[{"name":"EmptyStatement","ty":"Ast[EmptyStatement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":3,"subIdx":0,"rhsParams":[{"name":"ExpressionStatement","ty":"Ast[ExpressionStatement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":6,"subIdx":0,"rhsParams":[{"name":"ContinueStatement","ty":"Ast[ContinueStatement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":7,"subIdx":0,"rhsParams":[{"name":"BreakStatement","ty":"Ast[BreakStatement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":11,"subIdx":0,"rhsParams":[{"name":"ThrowStatement","ty":"Ast[ThrowStatement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Statement","idx":13,"subIdx":0,"rhsParams":[{"name":"DebuggerStatement","ty":"Ast[DebuggerStatement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Block","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ReturnStatement","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LabelledItem","idx":1,"subIdx":0,"rhsParams":[{"name":"FunctionDeclaration","ty":"Ast[FunctionDeclaration]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":3,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":4,"subIdx":0,"rhsParams":[{"name":"ForBinding","ty":"Ast[ForBinding]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":5,"subIdx":0,"rhsParams":[{"name":"ForDeclaration","ty":"Ast[ForDeclaration]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IfStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _has_ be HasCallInTailPosition of the first |Statement| with argument _call_.\n  1. If _has_ is *true*, return *true*.\n  1. Return HasCallInTailPosition of the second |Statement| with argument _call_.","code":"\n        1. Let _has_ be HasCallInTailPosition of the first |Statement| with argument _call_.\n        1. If _has_ is *true*, return *true*.\n        1. Return HasCallInTailPosition of the second |Statement| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"IfStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |Statement| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DoWhileStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |Statement| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"WhileStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |Statement| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |Statement| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":1,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |Statement| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":2,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |Statement| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":3,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |Statement| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":4,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |Statement| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":5,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |Statement| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":6,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |Statement| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":0,"subIdx":7,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |Statement| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |Statement| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":1,"subIdx":1,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |Statement| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":1,"subIdx":2,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |Statement| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":1,"subIdx":3,"rhsParams":[{"name":"VariableDeclarationList","ty":"Ast[VariableDeclarationList]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |Statement| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":2,"subIdx":0,"rhsParams":[{"name":"LexicalDeclaration","ty":"Ast[LexicalDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |Statement| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":2,"subIdx":1,"rhsParams":[{"name":"LexicalDeclaration","ty":"Ast[LexicalDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |Statement| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":2,"subIdx":2,"rhsParams":[{"name":"LexicalDeclaration","ty":"Ast[LexicalDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |Statement| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForStatement","idx":2,"subIdx":3,"rhsParams":[{"name":"LexicalDeclaration","ty":"Ast[LexicalDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |Statement| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |Statement| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"ForBinding","ty":"Ast[ForBinding]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |Statement| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ForInOfStatement","idx":2,"subIdx":0,"rhsParams":[{"name":"ForDeclaration","ty":"Ast[ForDeclaration]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |Statement| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"WithStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"Statement","ty":"Ast[Statement]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |Statement| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |Statement| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LabelledStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"LabelIdentifier","ty":"Ast[LabelIdentifier]","kind":{"Normal":{}}},{"name":"LabelledItem","ty":"Ast[LabelledItem]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |LabelledItem| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |LabelledItem| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ReturnStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |Expression| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |Expression| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"SwitchStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"CaseBlock","ty":"Ast[CaseBlock]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |CaseBlock| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |CaseBlock| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":0,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _has_ be *false*.\n  1. If the first |CaseClauses| is present, set _has_ to HasCallInTailPosition of the first |CaseClauses| with argument _call_.\n  1. If _has_ is *true*, return *true*.\n  1. Set _has_ to HasCallInTailPosition of |DefaultClause| with argument _call_.\n  1. If _has_ is *true*, return *true*.\n  1. If the second |CaseClauses| is present, set _has_ to HasCallInTailPosition of the second |CaseClauses| with argument _call_.\n  1. Return _has_.","code":"\n        1. Let _has_ be *false*.\n        1. If the first |CaseClauses| is present, set _has_ to HasCallInTailPosition of the first |CaseClauses| with argument _call_.\n        1. If _has_ is *true*, return *true*.\n        1. Set _has_ to HasCallInTailPosition of |DefaultClause| with argument _call_.\n        1. If _has_ is *true*, return *true*.\n        1. If the second |CaseClauses| is present, set _has_ to HasCallInTailPosition of the second |CaseClauses| with argument _call_.\n        1. Return _has_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":1,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _has_ be *false*.\n  1. If the first |CaseClauses| is present, set _has_ to HasCallInTailPosition of the first |CaseClauses| with argument _call_.\n  1. If _has_ is *true*, return *true*.\n  1. Set _has_ to HasCallInTailPosition of |DefaultClause| with argument _call_.\n  1. If _has_ is *true*, return *true*.\n  1. If the second |CaseClauses| is present, set _has_ to HasCallInTailPosition of the second |CaseClauses| with argument _call_.\n  1. Return _has_.","code":"\n        1. Let _has_ be *false*.\n        1. If the first |CaseClauses| is present, set _has_ to HasCallInTailPosition of the first |CaseClauses| with argument _call_.\n        1. If _has_ is *true*, return *true*.\n        1. Set _has_ to HasCallInTailPosition of |DefaultClause| with argument _call_.\n        1. If _has_ is *true*, return *true*.\n        1. If the second |CaseClauses| is present, set _has_ to HasCallInTailPosition of the second |CaseClauses| with argument _call_.\n        1. Return _has_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":2,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _has_ be *false*.\n  1. If the first |CaseClauses| is present, set _has_ to HasCallInTailPosition of the first |CaseClauses| with argument _call_.\n  1. If _has_ is *true*, return *true*.\n  1. Set _has_ to HasCallInTailPosition of |DefaultClause| with argument _call_.\n  1. If _has_ is *true*, return *true*.\n  1. If the second |CaseClauses| is present, set _has_ to HasCallInTailPosition of the second |CaseClauses| with argument _call_.\n  1. Return _has_.","code":"\n        1. Let _has_ be *false*.\n        1. If the first |CaseClauses| is present, set _has_ to HasCallInTailPosition of the first |CaseClauses| with argument _call_.\n        1. If _has_ is *true*, return *true*.\n        1. Set _has_ to HasCallInTailPosition of |DefaultClause| with argument _call_.\n        1. If _has_ is *true*, return *true*.\n        1. If the second |CaseClauses| is present, set _has_ to HasCallInTailPosition of the second |CaseClauses| with argument _call_.\n        1. Return _has_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseBlock","idx":1,"subIdx":3,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"DefaultClause","ty":"Ast[DefaultClause]","kind":{"Normal":{}}},{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _has_ be *false*.\n  1. If the first |CaseClauses| is present, set _has_ to HasCallInTailPosition of the first |CaseClauses| with argument _call_.\n  1. If _has_ is *true*, return *true*.\n  1. Set _has_ to HasCallInTailPosition of |DefaultClause| with argument _call_.\n  1. If _has_ is *true*, return *true*.\n  1. If the second |CaseClauses| is present, set _has_ to HasCallInTailPosition of the second |CaseClauses| with argument _call_.\n  1. Return _has_.","code":"\n        1. Let _has_ be *false*.\n        1. If the first |CaseClauses| is present, set _has_ to HasCallInTailPosition of the first |CaseClauses| with argument _call_.\n        1. If _has_ is *true*, return *true*.\n        1. Set _has_ to HasCallInTailPosition of |DefaultClause| with argument _call_.\n        1. If _has_ is *true*, return *true*.\n        1. If the second |CaseClauses| is present, set _has_ to HasCallInTailPosition of the second |CaseClauses| with argument _call_.\n        1. Return _has_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseClauses","idx":1,"subIdx":0,"rhsParams":[{"name":"CaseClauses","ty":"Ast[CaseClauses]","kind":{"Normal":{}}},{"name":"CaseClause","ty":"Ast[CaseClause]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _has_ be HasCallInTailPosition of |CaseClauses| with argument _call_.\n  1. If _has_ is *true*, return *true*.\n  1. Return HasCallInTailPosition of |CaseClause| with argument _call_.","code":"\n        1. Let _has_ be HasCallInTailPosition of |CaseClauses| with argument _call_.\n        1. If _has_ is *true*, return *true*.\n        1. Return HasCallInTailPosition of |CaseClause| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseClause","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If |StatementList| is present, return HasCallInTailPosition of |StatementList| with argument _call_.\n  1. Return *false*.","code":"\n        1. If |StatementList| is present, return HasCallInTailPosition of |StatementList| with argument _call_.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CaseClause","idx":0,"subIdx":1,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If |StatementList| is present, return HasCallInTailPosition of |StatementList| with argument _call_.\n  1. Return *false*.","code":"\n        1. If |StatementList| is present, return HasCallInTailPosition of |StatementList| with argument _call_.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DefaultClause","idx":0,"subIdx":0,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If |StatementList| is present, return HasCallInTailPosition of |StatementList| with argument _call_.\n  1. Return *false*.","code":"\n        1. If |StatementList| is present, return HasCallInTailPosition of |StatementList| with argument _call_.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DefaultClause","idx":0,"subIdx":1,"rhsParams":[{"name":"StatementList","ty":"Ast[StatementList]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If |StatementList| is present, return HasCallInTailPosition of |StatementList| with argument _call_.\n  1. Return *false*.","code":"\n        1. If |StatementList| is present, return HasCallInTailPosition of |StatementList| with argument _call_.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TryStatement","idx":0,"subIdx":0,"rhsParams":[{"name":"Block","ty":"Ast[Block]","kind":{"Normal":{}}},{"name":"Catch","ty":"Ast[Catch]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |Catch| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |Catch| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TryStatement","idx":1,"subIdx":0,"rhsParams":[{"name":"Block","ty":"Ast[Block]","kind":{"Normal":{}}},{"name":"Finally","ty":"Ast[Finally]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |Finally| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |Finally| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"TryStatement","idx":2,"subIdx":0,"rhsParams":[{"name":"Block","ty":"Ast[Block]","kind":{"Normal":{}}},{"name":"Catch","ty":"Ast[Catch]","kind":{"Normal":{}}},{"name":"Finally","ty":"Ast[Finally]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |Finally| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |Finally| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Catch","idx":0,"subIdx":0,"rhsParams":[{"name":"CatchParameter","ty":"Ast[CatchParameter]","kind":{"Normal":{}}},{"name":"Block","ty":"Ast[Block]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |Block| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |Block| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"YieldExpression","ty":"Ast[YieldExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"ArrowFunction","ty":"Ast[ArrowFunction]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"AsyncArrowFunction","ty":"Ast[AsyncArrowFunction]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentExpression","idx":5,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentOperator","ty":"Ast[AssignmentOperator]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentExpression","idx":6,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentExpression","idx":7,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AssignmentExpression","idx":8,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BitwiseANDExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"BitwiseANDExpression","ty":"Ast[BitwiseANDExpression]","kind":{"Normal":{}}},{"name":"EqualityExpression","ty":"Ast[EqualityExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BitwiseXORExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"BitwiseXORExpression","ty":"Ast[BitwiseXORExpression]","kind":{"Normal":{}}},{"name":"BitwiseANDExpression","ty":"Ast[BitwiseANDExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"BitwiseORExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"BitwiseORExpression","ty":"Ast[BitwiseORExpression]","kind":{"Normal":{}}},{"name":"BitwiseXORExpression","ty":"Ast[BitwiseXORExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"EqualityExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"EqualityExpression","ty":"Ast[EqualityExpression]","kind":{"Normal":{}}},{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"EqualityExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"EqualityExpression","ty":"Ast[EqualityExpression]","kind":{"Normal":{}}},{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"EqualityExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"EqualityExpression","ty":"Ast[EqualityExpression]","kind":{"Normal":{}}},{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"EqualityExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"EqualityExpression","ty":"Ast[EqualityExpression]","kind":{"Normal":{}}},{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RelationalExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}},{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RelationalExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}},{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RelationalExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}},{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RelationalExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}},{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RelationalExpression","idx":5,"subIdx":0,"rhsParams":[{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}},{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RelationalExpression","idx":6,"subIdx":0,"rhsParams":[{"name":"RelationalExpression","ty":"Ast[RelationalExpression]","kind":{"Normal":{}}},{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RelationalExpression","idx":7,"subIdx":0,"rhsParams":[{"name":"PrivateIdentifier","ty":"Ast[PrivateIdentifier]","kind":{"Normal":{}}},{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ShiftExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}},{"name":"AdditiveExpression","ty":"Ast[AdditiveExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ShiftExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}},{"name":"AdditiveExpression","ty":"Ast[AdditiveExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ShiftExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"ShiftExpression","ty":"Ast[ShiftExpression]","kind":{"Normal":{}}},{"name":"AdditiveExpression","ty":"Ast[AdditiveExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AdditiveExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"AdditiveExpression","ty":"Ast[AdditiveExpression]","kind":{"Normal":{}}},{"name":"MultiplicativeExpression","ty":"Ast[MultiplicativeExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AdditiveExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"AdditiveExpression","ty":"Ast[AdditiveExpression]","kind":{"Normal":{}}},{"name":"MultiplicativeExpression","ty":"Ast[MultiplicativeExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MultiplicativeExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"MultiplicativeExpression","ty":"Ast[MultiplicativeExpression]","kind":{"Normal":{}}},{"name":"MultiplicativeOperator","ty":"Ast[MultiplicativeOperator]","kind":{"Normal":{}}},{"name":"ExponentiationExpression","ty":"Ast[ExponentiationExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExponentiationExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"UpdateExpression","ty":"Ast[UpdateExpression]","kind":{"Normal":{}}},{"name":"ExponentiationExpression","ty":"Ast[ExponentiationExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UpdateExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UpdateExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"LeftHandSideExpression","ty":"Ast[LeftHandSideExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UpdateExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UpdateExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":5,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":6,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":7,"subIdx":0,"rhsParams":[{"name":"UnaryExpression","ty":"Ast[UnaryExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnaryExpression","idx":8,"subIdx":0,"rhsParams":[{"name":"AwaitExpression","ty":"Ast[AwaitExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CallExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"SuperCall","ty":"Ast[SuperCall]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CallExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"ImportCall","ty":"Ast[ImportCall]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CallExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"CallExpression","ty":"Ast[CallExpression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CallExpression","idx":5,"subIdx":0,"rhsParams":[{"name":"CallExpression","ty":"Ast[CallExpression]","kind":{"Normal":{}}},{"name":"IdentifierName","ty":"Ast[IdentifierName]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CallExpression","idx":7,"subIdx":0,"rhsParams":[{"name":"CallExpression","ty":"Ast[CallExpression]","kind":{"Normal":{}}},{"name":"PrivateIdentifier","ty":"Ast[PrivateIdentifier]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NewExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"NewExpression","ty":"Ast[NewExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"IdentifierName","ty":"Ast[IdentifierName]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"SuperProperty","ty":"Ast[SuperProperty]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":5,"subIdx":0,"rhsParams":[{"name":"MetaProperty","ty":"Ast[MetaProperty]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":6,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"Arguments","ty":"Ast[Arguments]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":7,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"PrivateIdentifier","ty":"Ast[PrivateIdentifier]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"IdentifierReference","ty":"Ast[IdentifierReference]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"Literal","ty":"Ast[Literal]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"ArrayLiteral","ty":"Ast[ArrayLiteral]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":4,"subIdx":0,"rhsParams":[{"name":"ObjectLiteral","ty":"Ast[ObjectLiteral]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":5,"subIdx":0,"rhsParams":[{"name":"FunctionExpression","ty":"Ast[FunctionExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":6,"subIdx":0,"rhsParams":[{"name":"ClassExpression","ty":"Ast[ClassExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":7,"subIdx":0,"rhsParams":[{"name":"GeneratorExpression","ty":"Ast[GeneratorExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":8,"subIdx":0,"rhsParams":[{"name":"AsyncFunctionExpression","ty":"Ast[AsyncFunctionExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":9,"subIdx":0,"rhsParams":[{"name":"AsyncGeneratorExpression","ty":"Ast[AsyncGeneratorExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":10,"subIdx":0,"rhsParams":[{"name":"RegularExpressionLiteral","ty":"Ast[RegularExpressionLiteral]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":11,"subIdx":0,"rhsParams":[{"name":"TemplateLiteral","ty":"Ast[TemplateLiteral]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Expression","idx":0,"subIdx":0,"rhsParams":[{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |AssignmentExpression| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |AssignmentExpression| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Expression","idx":1,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |AssignmentExpression| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |AssignmentExpression| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ConditionalExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"ShortCircuitExpression","ty":"Ast[ShortCircuitExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}},{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _has_ be HasCallInTailPosition of the first |AssignmentExpression| with argument _call_.\n  1. If _has_ is *true*, return *true*.\n  1. Return HasCallInTailPosition of the second |AssignmentExpression| with argument _call_.","code":"\n        1. Let _has_ be HasCallInTailPosition of the first |AssignmentExpression| with argument _call_.\n        1. If _has_ is *true*, return *true*.\n        1. Return HasCallInTailPosition of the second |AssignmentExpression| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LogicalANDExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"LogicalANDExpression","ty":"Ast[LogicalANDExpression]","kind":{"Normal":{}}},{"name":"BitwiseORExpression","ty":"Ast[BitwiseORExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |BitwiseORExpression| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |BitwiseORExpression| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"LogicalORExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"LogicalORExpression","ty":"Ast[LogicalORExpression]","kind":{"Normal":{}}},{"name":"LogicalANDExpression","ty":"Ast[LogicalANDExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |LogicalANDExpression| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |LogicalANDExpression| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CoalesceExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"CoalesceExpressionHead","ty":"Ast[CoalesceExpressionHead]","kind":{"Normal":{}}},{"name":"BitwiseORExpression","ty":"Ast[BitwiseORExpression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |BitwiseORExpression| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |BitwiseORExpression| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CallExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"CoverCallExpressionAndAsyncArrowHead","ty":"Ast[CoverCallExpressionAndAsyncArrowHead]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If *this* value is _call_, return *true*.\n  1. Return *false*.","code":"\n        1. If this |CallExpression| is _call_, return *true*.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CallExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"CallExpression","ty":"Ast[CallExpression]","kind":{"Normal":{}}},{"name":"Arguments","ty":"Ast[Arguments]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If *this* value is _call_, return *true*.\n  1. Return *false*.","code":"\n        1. If this |CallExpression| is _call_, return *true*.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CallExpression","idx":6,"subIdx":0,"rhsParams":[{"name":"CallExpression","ty":"Ast[CallExpression]","kind":{"Normal":{}}},{"name":"TemplateLiteral","ty":"Ast[TemplateLiteral]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If *this* value is _call_, return *true*.\n  1. Return *false*.","code":"\n        1. If this |CallExpression| is _call_, return *true*.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"OptionalExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"OptionalChain","ty":"Ast[OptionalChain]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |OptionalChain| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |OptionalChain| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"OptionalExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"CallExpression","ty":"Ast[CallExpression]","kind":{"Normal":{}}},{"name":"OptionalChain","ty":"Ast[OptionalChain]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |OptionalChain| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |OptionalChain| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"OptionalExpression","idx":2,"subIdx":0,"rhsParams":[{"name":"OptionalExpression","ty":"Ast[OptionalExpression]","kind":{"Normal":{}}},{"name":"OptionalChain","ty":"Ast[OptionalChain]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |OptionalChain| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |OptionalChain| with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"OptionalChain","idx":1,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"OptionalChain","idx":2,"subIdx":0,"rhsParams":[{"name":"IdentifierName","ty":"Ast[IdentifierName]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"OptionalChain","idx":4,"subIdx":0,"rhsParams":[{"name":"PrivateIdentifier","ty":"Ast[PrivateIdentifier]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"OptionalChain","idx":6,"subIdx":0,"rhsParams":[{"name":"OptionalChain","ty":"Ast[OptionalChain]","kind":{"Normal":{}}},{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"OptionalChain","idx":7,"subIdx":0,"rhsParams":[{"name":"OptionalChain","ty":"Ast[OptionalChain]","kind":{"Normal":{}}},{"name":"IdentifierName","ty":"Ast[IdentifierName]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"OptionalChain","idx":9,"subIdx":0,"rhsParams":[{"name":"OptionalChain","ty":"Ast[OptionalChain]","kind":{"Normal":{}}},{"name":"PrivateIdentifier","ty":"Ast[PrivateIdentifier]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"OptionalChain","idx":0,"subIdx":0,"rhsParams":[{"name":"Arguments","ty":"Ast[Arguments]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If *this* value is _call_, return *true*.\n  1. Return *false*.","code":"\n        1. If this |OptionalChain| is _call_, return *true*.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"OptionalChain","idx":5,"subIdx":0,"rhsParams":[{"name":"OptionalChain","ty":"Ast[OptionalChain]","kind":{"Normal":{}}},{"name":"Arguments","ty":"Ast[Arguments]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If *this* value is _call_, return *true*.\n  1. Return *false*.","code":"\n        1. If this |OptionalChain| is _call_, return *true*.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"MemberExpression","idx":3,"subIdx":0,"rhsParams":[{"name":"MemberExpression","ty":"Ast[MemberExpression]","kind":{"Normal":{}}},{"name":"TemplateLiteral","ty":"Ast[TemplateLiteral]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If *this* value is _call_, return *true*.\n  1. Return *false*.","code":"\n        1. If this |MemberExpression| is _call_, return *true*.\n        1. Return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"PrimaryExpression","idx":12,"subIdx":0,"rhsParams":[{"name":"CoverParenthesizedExpressionAndArrowParameterList","ty":"Ast[CoverParenthesizedExpressionAndArrowParameterList]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _expr_ be the |ParenthesizedExpression| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n  1. Return HasCallInTailPosition of _expr_ with argument _call_.","code":"\n        1. Let _expr_ be the |ParenthesizedExpression| that is covered by |CoverParenthesizedExpressionAndArrowParameterList|.\n        1. Return HasCallInTailPosition of _expr_ with argument _call_.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ParenthesizedExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"Expression","ty":"Ast[Expression]","kind":{"Normal":{}}}]},"methodName":"HasCallInTailPosition","isStatic":true,"withParams":[{"name":"call","ty":"Unknown[\"a |CallExpression| Parse Node, a |MemberExpression| Parse Node, or an |OptionalChain| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Return HasCallInTailPosition of |Expression| with argument _call_.","code":"\n        1. Return HasCallInTailPosition of |Expression| with argument _call_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"PrepareForTailCall","params":[],"retTy":"Enum[~unused~]"}},"body":"\n  1. Assert: The current execution context will not subsequently be used for the evaluation of any ECMAScript code or built-in functions. The invocation of Call subsequent to the invocation of this abstract operation will create and push a new execution context before performing any such evaluation..\n  1. Discard all resources associated with the current execution context.\n  1. Return ~unused~.","code":"\n        1. Assert: The current execution context will not subsequently be used for the evaluation of any ECMAScript code or built-in functions. The invocation of Call subsequent to the invocation of this abstract operation will create and push a new execution context before performing any such evaluation.\n        1. Discard all resources associated with the current execution context.\n        1. Return ~unused~.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Script","idx":0,"subIdx":0,"rhsParams":[{"name":"ScriptBody","ty":"Ast[ScriptBody]","kind":{"Normal":{}}}]},"methodName":"IsStrict","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. If |ScriptBody| is present and *true*, return *true*.\n  1. Else, return *false*.","code":"\n        1. If |ScriptBody| is present and the Directive Prologue of |ScriptBody| contains a Use Strict Directive, return *true*; otherwise, return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Script","idx":0,"subIdx":1,"rhsParams":[{"name":"ScriptBody","ty":"Ast[ScriptBody]","kind":{"Normal":{}}}]},"methodName":"IsStrict","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. If |ScriptBody| is present and *true*, return *true*.\n  1. Else, return *false*.","code":"\n        1. If |ScriptBody| is present and the Directive Prologue of |ScriptBody| contains a Use Strict Directive, return *true*; otherwise, return *false*.\n      "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Script","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return *undefined*.","code":"\n        1. Return *undefined*.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ParseScript","params":[{"name":"sourceText","ty":"Unknown[\"ECMAScript source text\"]","kind":{"Normal":{}}},{"name":"realm","ty":"Record[RealmRecord] | Undefined","kind":{"Normal":{}}},{"name":"hostDefined","ty":"Unknown[\"anything\"]","kind":{"Normal":{}}}],"retTy":"Unknown[\"a Script Record or a non-empty List of *SyntaxError* objects\"]"}},"body":"\n  1. Let _script_ be ParseText(_sourceText_, |Script|).\n  1. If _script_ is a List[Record[Error]], return _script_.\n  1. Return Script Record { [[Realm]]: _realm_, [[ECMAScriptCode]]: _script_, [[LoadedModules]]: « », [[HostDefined]]: _hostDefined_ }.","code":"\n        1. Let _script_ be ParseText(_sourceText_, |Script|).\n        1. If _script_ is a List of errors, return _script_.\n        1. Return Script Record { [[Realm]]: _realm_, [[ECMAScriptCode]]: _script_, [[LoadedModules]]: « », [[HostDefined]]: _hostDefined_ }.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ScriptEvaluation","params":[{"name":"scriptRecord","ty":"Record[ScriptRecord]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _globalEnv_ be _scriptRecord_.[[Realm]].[[GlobalEnv]].\n  1. Let _scriptContext_ be ExecutionContext { }.\n  1. Set _scriptContext_.Function to *null*.\n  1. Set _scriptContext_.Realm to _scriptRecord_.[[Realm]].\n  1. Set _scriptContext_.ScriptOrModule to _scriptRecord_.\n  1. Set _scriptContext_.VariableEnvironment to _globalEnv_.\n  1. Set _scriptContext_.LexicalEnvironment to _globalEnv_.\n  1. Set _scriptContext_.PrivateEnvironment to *null*.\n  1. Suspend the running execution context.\n  1. Push _scriptContext_ onto the execution context stack; _scriptContext_ is now the running execution context.\n  1. Let _script_ be _scriptRecord_.[[ECMAScriptCode]].\n  1. Let _result_ be Completion(GlobalDeclarationInstantiation(_script_, _globalEnv_)).\n  1. If _result_ is a normal completion, then\n    1. Set _result_ to Completion(the result of evaluating _script_).\n    1. If _result_ is a normal completion and _result_.[[Value]] is ~empty~, then\n      1. Set _result_ to NormalCompletion(*undefined*).\n  1. Suspend _scriptContext_ and remove it from the execution context stack.\n  1. Assert: The execution context stack is not empty..\n  1. Resume the context that is now on the top of the execution context stack as the running execution context.\n  1. Return ? _result_.","code":"\n        1. Let _globalEnv_ be _scriptRecord_.[[Realm]].[[GlobalEnv]].\n        1. Let _scriptContext_ be a new ECMAScript code execution context.\n        1. Set the Function of _scriptContext_ to *null*.\n        1. Set the Realm of _scriptContext_ to _scriptRecord_.[[Realm]].\n        1. Set the ScriptOrModule of _scriptContext_ to _scriptRecord_.\n        1. Set the VariableEnvironment of _scriptContext_ to _globalEnv_.\n        1. Set the LexicalEnvironment of _scriptContext_ to _globalEnv_.\n        1. Set the PrivateEnvironment of _scriptContext_ to *null*.\n        1. Suspend the running execution context.\n        1. Push _scriptContext_ onto the execution context stack; _scriptContext_ is now the running execution context.\n        1. Let _script_ be _scriptRecord_.[[ECMAScriptCode]].\n        1. Let _result_ be Completion(GlobalDeclarationInstantiation(_script_, _globalEnv_)).\n        1. If _result_ is a normal completion, then\n          1. Set _result_ to Completion(Evaluation of _script_).\n          1. If _result_ is a normal completion and _result_.[[Value]] is ~empty~, then\n            1. Set _result_ to NormalCompletion(*undefined*).\n        1. Suspend _scriptContext_ and remove it from the execution context stack.\n        1. Assert: The execution context stack is not empty.\n        1. Resume the context that is now on the top of the execution context stack as the running execution context.\n        1. Return ? _result_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GlobalDeclarationInstantiation","params":[{"name":"script","ty":"Unknown[\"a |Script| Parse Node\"]","kind":{"Normal":{}}},{"name":"env","ty":"Record[GlobalEnvironmentRecord]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Let _lexNames_ be LexicallyDeclaredNames of _script_.\n  1. Let _varNames_ be VarDeclaredNames of _script_.\n  1. For each _name_ of _lexNames_, do\n    1. If _env_.HasVarDeclaration(_name_) is *true*, throw a *SyntaxError* exception.\n    1. If _env_.HasLexicalDeclaration(_name_) is *true*, throw a *SyntaxError* exception.\n    1. Let _hasRestrictedGlobal_ be ? _env_.HasRestrictedGlobalProperty(_name_).\n    1. If _hasRestrictedGlobal_ is *true*, throw a *SyntaxError* exception.\n  1. For each _name_ of _varNames_, do\n    1. If _env_.HasLexicalDeclaration(_name_) is *true*, throw a *SyntaxError* exception.\n  1. Let _varDeclarations_ be VarScopedDeclarations of _script_.\n  1. Let _functionsToInitialize_ be « ».\n  1. Let _declaredFunctionNames_ be « ».\n  1. For each _d_ of _varDeclarations_, in reverse List order, do\n    1. If _d_ is not a Ast[BindingIdentifier | ForBinding | VariableDeclaration], then\n      1. Assert: _d_ is a Ast[AsyncFunctionDeclaration | AsyncGeneratorDeclaration | FunctionDeclaration | GeneratorDeclaration].\n      1. NOTE: If there are multiple function declarations for the same name, the last declaration is used.\n      1. Let _fn_ be the sole element of BoundNames of _d_.\n      1. If _declaredFunctionNames_ does not contain _fn_, then\n        1. Let _fnDefinable_ be ? _env_.CanDeclareGlobalFunction(_fn_).\n        1. If _fnDefinable_ is *false*, throw a *TypeError* exception.\n        1. Append _fn_ to _declaredFunctionNames_.\n        1. Insert _d_ as the first element of _functionsToInitialize_.\n  1. Let _declaredVarNames_ be « ».\n  1. For each _d_ of _varDeclarations_, do\n    1. If _d_ is a Ast[BindingIdentifier | ForBinding | VariableDeclaration], then\n      1. For each String _vn_ of BoundNames of _d_, do\n        1. If _declaredFunctionNames_ does not contain _vn_, then\n          1. Let _vnDefinable_ be ? _env_.CanDeclareGlobalVar(_vn_).\n          1. If _vnDefinable_ is *false*, throw a *TypeError* exception.\n          1. If _declaredVarNames_ does not contain _vn_, then\n            1. Append _vn_ to _declaredVarNames_.\n  1. NOTE: No abnormal terminations occur after this algorithm step if the global object is an ordinary object. However, if the global object is a Proxy exotic object it may exhibit behaviours that cause abnormal terminations in some of the following steps.\n  1. [id=\"step-globaldeclarationinstantiation-web-compat-insertion-point\"] NOTE: Annex <emu-xref href=\"#sec-web-compat-globaldeclarationinstantiation\"></emu-xref> adds additional steps at this point.\n  1. Let _lexDeclarations_ be LexicallyScopedDeclarations of _script_.\n  1. Let _privateEnv_ be *null*.\n  1. For each _d_ of _lexDeclarations_, do\n    1. NOTE: Lexically declared names are only instantiated here but not initialized.\n    1. For each _dn_ of BoundNames of _d_, do\n      1. If IsConstantDeclaration of _d_ is *true*, then\n        1. Perform ? _env_.CreateImmutableBinding(_dn_, *true*).\n      1. Else,\n        1. Perform ? _env_.CreateMutableBinding(_dn_, *false*).\n  1. For each Ast _f_ of _functionsToInitialize_, do\n    1. Let _fn_ be the sole element of BoundNames of _f_.\n    1. Let _fo_ be InstantiateFunctionObject of _f_ with arguments _env_ and _privateEnv_.\n    1. Perform ? _env_.CreateGlobalFunctionBinding(_fn_, _fo_, *false*).\n  1. For each String _vn_ of _declaredVarNames_, do\n    1. Perform ? _env_.CreateGlobalVarBinding(_vn_, *false*).\n  1. Return ~unused~.","code":"\n        1. Let _lexNames_ be the LexicallyDeclaredNames of _script_.\n        1. Let _varNames_ be the VarDeclaredNames of _script_.\n        1. For each element _name_ of _lexNames_, do\n          1. If _env_.HasVarDeclaration(_name_) is *true*, throw a *SyntaxError* exception.\n          1. If _env_.HasLexicalDeclaration(_name_) is *true*, throw a *SyntaxError* exception.\n          1. Let _hasRestrictedGlobal_ be ? _env_.HasRestrictedGlobalProperty(_name_).\n          1. If _hasRestrictedGlobal_ is *true*, throw a *SyntaxError* exception.\n        1. For each element _name_ of _varNames_, do\n          1. If _env_.HasLexicalDeclaration(_name_) is *true*, throw a *SyntaxError* exception.\n        1. Let _varDeclarations_ be the VarScopedDeclarations of _script_.\n        1. Let _functionsToInitialize_ be a new empty List.\n        1. Let _declaredFunctionNames_ be a new empty List.\n        1. For each element _d_ of _varDeclarations_, in reverse List order, do\n          1. If _d_ is not either a |VariableDeclaration|, a |ForBinding|, or a |BindingIdentifier|, then\n            1. Assert: _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|.\n            1. NOTE: If there are multiple function declarations for the same name, the last declaration is used.\n            1. Let _fn_ be the sole element of the BoundNames of _d_.\n            1. If _declaredFunctionNames_ does not contain _fn_, then\n              1. Let _fnDefinable_ be ? _env_.CanDeclareGlobalFunction(_fn_).\n              1. If _fnDefinable_ is *false*, throw a *TypeError* exception.\n              1. Append _fn_ to _declaredFunctionNames_.\n              1. Insert _d_ as the first element of _functionsToInitialize_.\n        1. Let _declaredVarNames_ be a new empty List.\n        1. For each element _d_ of _varDeclarations_, do\n          1. If _d_ is either a |VariableDeclaration|, a |ForBinding|, or a |BindingIdentifier|, then\n            1. For each String _vn_ of the BoundNames of _d_, do\n              1. If _declaredFunctionNames_ does not contain _vn_, then\n                1. Let _vnDefinable_ be ? _env_.CanDeclareGlobalVar(_vn_).\n                1. If _vnDefinable_ is *false*, throw a *TypeError* exception.\n                1. If _declaredVarNames_ does not contain _vn_, then\n                  1. Append _vn_ to _declaredVarNames_.\n        1. NOTE: No abnormal terminations occur after this algorithm step if the global object is an ordinary object. However, if the global object is a Proxy exotic object it may exhibit behaviours that cause abnormal terminations in some of the following steps.\n        1. [id=\"step-globaldeclarationinstantiation-web-compat-insertion-point\"] NOTE: Annex <emu-xref href=\"#sec-web-compat-globaldeclarationinstantiation\"></emu-xref> adds additional steps at this point.\n        1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _script_.\n        1. Let _privateEnv_ be *null*.\n        1. For each element _d_ of _lexDeclarations_, do\n          1. NOTE: Lexically declared names are only instantiated here but not initialized.\n          1. For each element _dn_ of the BoundNames of _d_, do\n            1. If IsConstantDeclaration of _d_ is *true*, then\n              1. Perform ? <emu-meta effects=\"user-code\">_env_.CreateImmutableBinding</emu-meta>(_dn_, *true*).\n            1. Else,\n              1. Perform ? <emu-meta effects=\"user-code\">_env_.CreateMutableBinding</emu-meta>(_dn_, *false*).\n        1. For each Parse Node _f_ of _functionsToInitialize_, do\n          1. Let _fn_ be the sole element of the BoundNames of _f_.\n          1. Let _fo_ be InstantiateFunctionObject of _f_ with arguments _env_ and _privateEnv_.\n          1. Perform ? <emu-meta effects=\"user-code\">_env_.CreateGlobalFunctionBinding</emu-meta>(_fn_, _fo_, *false*).\n        1. For each String _vn_ of _declaredVarNames_, do\n          1. Perform ? <emu-meta effects=\"user-code\">_env_.CreateGlobalVarBinding</emu-meta>(_vn_, *false*).\n        1. Return ~unused~.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ImportedLocalNames","params":[{"name":"importEntries","ty":"List[Record[ImportEntryRecord]]","kind":{"Normal":{}}}],"retTy":"List[String]"}},"body":"\n  1. Let _localNames_ be « ».\n  1. For each Record[ImportEntryRecord] _i_ of _importEntries_, do\n    1. Append _i_.[[LocalName]] to _localNames_.\n  1. Return _localNames_.","code":"\n          1. Let _localNames_ be a new empty List.\n          1. For each ImportEntry Record _i_ of _importEntries_, do\n            1. Append _i_.[[LocalName]] to _localNames_.\n          1. Return _localNames_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Module","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"ModuleRequests","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n          1. Return a new empty List.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItemList","idx":0,"subIdx":0,"rhsParams":[{"name":"ModuleItem","ty":"Ast[ModuleItem]","kind":{"Normal":{}}}]},"methodName":"ModuleRequests","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return ModuleRequests of |ModuleItem|.","code":"\n          1. Return ModuleRequests of |ModuleItem|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItemList","idx":1,"subIdx":0,"rhsParams":[{"name":"ModuleItemList","ty":"Ast[ModuleItemList]","kind":{"Normal":{}}},{"name":"ModuleItem","ty":"Ast[ModuleItem]","kind":{"Normal":{}}}]},"methodName":"ModuleRequests","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _moduleNames_ be ModuleRequests of |ModuleItemList|.\n  1. Let _additionalNames_ be ModuleRequests of |ModuleItem|.\n  1. For each String _name_ of _additionalNames_, do\n    1. If _moduleNames_ does not contain _name_, then\n      1. Append _name_ to _moduleNames_.\n  1. Return _moduleNames_.","code":"\n          1. Let _moduleNames_ be ModuleRequests of |ModuleItemList|.\n          1. Let _additionalNames_ be ModuleRequests of |ModuleItem|.\n          1. For each String _name_ of _additionalNames_, do\n            1. If _moduleNames_ does not contain _name_, then\n              1. Append _name_ to _moduleNames_.\n          1. Return _moduleNames_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItem","idx":2,"subIdx":0,"rhsParams":[{"name":"StatementListItem","ty":"Ast[StatementListItem]","kind":{"Normal":{}}}]},"methodName":"ModuleRequests","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n          1. Return a new empty List.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ImportDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"ImportClause","ty":"Ast[ImportClause]","kind":{"Normal":{}}},{"name":"FromClause","ty":"Ast[FromClause]","kind":{"Normal":{}}}]},"methodName":"ModuleRequests","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return ModuleRequests of |FromClause|.","code":"\n          1. Return ModuleRequests of |FromClause|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleSpecifier","idx":0,"subIdx":0,"rhsParams":[{"name":"StringLiteral","ty":"Ast[StringLiteral]","kind":{"Normal":{}}}]},"methodName":"ModuleRequests","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « SV of |StringLiteral| ».","code":"\n          1. Return a List whose sole element is the SV of |StringLiteral|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"ExportFromClause","ty":"Ast[ExportFromClause]","kind":{"Normal":{}}},{"name":"FromClause","ty":"Ast[FromClause]","kind":{"Normal":{}}}]},"methodName":"ModuleRequests","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return ModuleRequests of |FromClause|.","code":"\n          1. Return the ModuleRequests of |FromClause|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"NamedExports","ty":"Ast[NamedExports]","kind":{"Normal":{}}}]},"methodName":"ModuleRequests","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n          1. Return a new empty List.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":2,"subIdx":0,"rhsParams":[{"name":"VariableStatement","ty":"Ast[VariableStatement]","kind":{"Normal":{}}}]},"methodName":"ModuleRequests","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n          1. Return a new empty List.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":3,"subIdx":0,"rhsParams":[{"name":"Declaration","ty":"Ast[Declaration]","kind":{"Normal":{}}}]},"methodName":"ModuleRequests","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n          1. Return a new empty List.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":4,"subIdx":0,"rhsParams":[{"name":"HoistableDeclaration","ty":"Ast[HoistableDeclaration]","kind":{"Normal":{}}}]},"methodName":"ModuleRequests","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n          1. Return a new empty List.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":5,"subIdx":0,"rhsParams":[{"name":"ClassDeclaration","ty":"Ast[ClassDeclaration]","kind":{"Normal":{}}}]},"methodName":"ModuleRequests","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n          1. Return a new empty List.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":6,"subIdx":0,"rhsParams":[{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"ModuleRequests","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n          1. Return a new empty List.\n        "},{"head":{"ConcreteMethodHead":{"concMethodName":"LoadRequestedModules","receiver":{"name":"module","ty":"Record[CyclicModuleRecord]","kind":{"Normal":{}}},"params":[{"name":"hostDefined","ty":"Unknown[\"anything\"]","kind":{"Optional":{}}}],"retTy":"Record[Promise]"}},"body":"\n  1. If _hostDefined_ is not present, let _hostDefined_ be ~empty~.\n  1. Let _pc_ be ! NewPromiseCapability(%Promise%).\n  1. Let _state_ be GraphLoadingState Record { [[IsLoading]]: *true*, [[PendingModulesCount]]: 1, [[Visited]]: « », [[PromiseCapability]]: _pc_, [[HostDefined]]: _hostDefined_ }.\n  1. Perform InnerModuleLoading(_state_, _module_).\n  1. Return _pc_.[[Promise]].","code":"\n            1. If _hostDefined_ is not present, let _hostDefined_ be ~empty~.\n            1. Let _pc_ be ! NewPromiseCapability(%Promise%).\n            1. Let _state_ be the GraphLoadingState Record { [[IsLoading]]: *true*, [[PendingModulesCount]]: 1, [[Visited]]: « », [[PromiseCapability]]: _pc_, [[HostDefined]]: _hostDefined_ }.\n            1. Perform InnerModuleLoading(_state_, _module_).\n            1. Return _pc_.[[Promise]].\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"InnerModuleLoading","params":[{"name":"state","ty":"Record[GraphLoadingStateRecord]","kind":{"Normal":{}}},{"name":"module","ty":"Record[ModuleRecord]","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Assert: _state_.[[IsLoading]] is *true*.\n  1. If _module_ is a Record[CyclicModuleRecord] and _module_.[[Status]] is ~new~ and _state_.[[Visited]] does not contain _module_, then\n    1. Append _module_ to _state_.[[Visited]].\n    1. Let _requestedModulesCount_ be the number of elements in _module_.[[RequestedModules]].\n    1. Set _state_.[[PendingModulesCount]] to _state_.[[PendingModulesCount]] + _requestedModulesCount_.\n    1. For each String _required_ of _module_.[[RequestedModules]], do\n      1. If _module_.[[LoadedModules]] contains a Record[Record] whose [[Specifier]] is _required_, then\n        1. Let _record_ be that Record.\n        1. Perform InnerModuleLoading(_state_, _record_.[[Module]]).\n      1. Else,\n        1. Perform HostLoadImportedModule(_module_, _required_, _state_.[[HostDefined]], _state_).\n        1. NOTE: HostLoadImportedModule will call FinishLoadingImportedModule, which re-enters the graph loading process through ContinueModuleLoading.\n      1. If _state_.[[IsLoading]] is *false*, return ~unused~.\n  1. Assert: _state_.[[PendingModulesCount]] ≥ 1.\n  1. Set _state_.[[PendingModulesCount]] to _state_.[[PendingModulesCount]] - 1.\n  1. If _state_.[[PendingModulesCount]] = 0, then\n    1. Set _state_.[[IsLoading]] to *false*.\n    1. For each Record[CyclicModuleRecord] _loaded_ of _state_.[[Visited]], do\n      1. If _loaded_.[[Status]] is ~new~, set _loaded_.[[Status]] to ~unlinked~.\n    1. Perform ! Call(_state_.[[PromiseCapability]].[[Resolve]], *undefined*, « *undefined* »).\n  1. Return ~unused~.","code":"\n              1. Assert: _state_.[[IsLoading]] is *true*.\n              1. If _module_ is a Cyclic Module Record, _module_.[[Status]] is ~new~, and _state_.[[Visited]] does not contain _module_, then\n                1. Append _module_ to _state_.[[Visited]].\n                1. Let _requestedModulesCount_ be the number of elements in _module_.[[RequestedModules]].\n                1. Set _state_.[[PendingModulesCount]] to _state_.[[PendingModulesCount]] + _requestedModulesCount_.\n                1. For each String _required_ of _module_.[[RequestedModules]], do\n                  1. If _module_.[[LoadedModules]] contains a Record whose [[Specifier]] is _required_, then\n                    1. Let _record_ be that Record.\n                    1. Perform InnerModuleLoading(_state_, _record_.[[Module]]).\n                  1. Else,\n                    1. Perform HostLoadImportedModule(_module_, _required_, _state_.[[HostDefined]], _state_).\n                    1. NOTE: HostLoadImportedModule will call FinishLoadingImportedModule, which re-enters the graph loading process through ContinueModuleLoading.\n                  1. If _state_.[[IsLoading]] is *false*, return ~unused~.\n              1. Assert: _state_.[[PendingModulesCount]] ≥ 1.\n              1. Set _state_.[[PendingModulesCount]] to _state_.[[PendingModulesCount]] - 1.\n              1. If _state_.[[PendingModulesCount]] = 0, then\n                1. Set _state_.[[IsLoading]] to *false*.\n                1. For each Cyclic Module Record _loaded_ of _state_.[[Visited]], do\n                  1. If _loaded_.[[Status]] is ~new~, set _loaded_.[[Status]] to ~unlinked~.\n                1. Perform ! Call(_state_.[[PromiseCapability]].[[Resolve]], *undefined*, « *undefined* »).\n              1. Return ~unused~.\n            "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ContinueModuleLoading","params":[{"name":"state","ty":"Record[GraphLoadingStateRecord]","kind":{"Normal":{}}},{"name":"moduleCompletion","ty":"Normal[Record[ModuleRecord]] | Throw","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. If _state_.[[IsLoading]] is *false*, return ~unused~.\n  1. If _moduleCompletion_ is a normal completion, then\n    1. Perform InnerModuleLoading(_state_, _moduleCompletion_.[[Value]]).\n  1. Else,\n    1. Set _state_.[[IsLoading]] to *false*.\n    1. Perform ! Call(_state_.[[PromiseCapability]].[[Reject]], *undefined*, « _moduleCompletion_.[[Value]] »).\n  1. Return ~unused~.","code":"\n              1. If _state_.[[IsLoading]] is *false*, return ~unused~.\n              1. If _moduleCompletion_ is a normal completion, then\n                1. Perform InnerModuleLoading(_state_, _moduleCompletion_.[[Value]]).\n              1. Else,\n                1. Set _state_.[[IsLoading]] to *false*.\n                1. Perform ! Call(_state_.[[PromiseCapability]].[[Reject]], *undefined*, « _moduleCompletion_.[[Value]] »).\n              1. Return ~unused~.\n            "},{"head":{"ConcreteMethodHead":{"concMethodName":"Link","receiver":{"name":"module","ty":"Record[CyclicModuleRecord]","kind":{"Normal":{}}},"params":[],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Assert: _module_.[[Status]] is either ~unlinked~, ~linked~, ~evaluating-async~, or ~evaluated~.\n  1. Let _stack_ be « ».\n  1. Let _result_ be Completion(InnerModuleLinking(_module_, _stack_, 0)).\n  1. If _result_ is an abrupt completion, then\n    1. For each Record[CyclicModuleRecord] _m_ of _stack_, do\n      1. Assert: _m_.[[Status]] is ~linking~.\n      1. Set _m_.[[Status]] to ~unlinked~.\n    1. Assert: _module_.[[Status]] is ~unlinked~.\n    1. Return ? _result_.\n  1. Assert: _module_.[[Status]] is either ~linked~, ~evaluating-async~, or ~evaluated~.\n  1. Assert: _stack_ is empty.\n  1. Return ~unused~.","code":"\n            1. Assert: _module_.[[Status]] is one of ~unlinked~, ~linked~, ~evaluating-async~, or ~evaluated~.\n            1. Let _stack_ be a new empty List.\n            1. Let _result_ be Completion(InnerModuleLinking(_module_, _stack_, 0)).\n            1. If _result_ is an abrupt completion, then\n              1. For each Cyclic Module Record _m_ of _stack_, do\n                1. Assert: _m_.[[Status]] is ~linking~.\n                1. Set _m_.[[Status]] to ~unlinked~.\n              1. Assert: _module_.[[Status]] is ~unlinked~.\n              1. Return ? _result_.\n            1. Assert: _module_.[[Status]] is one of ~linked~, ~evaluating-async~, or ~evaluated~.\n            1. Assert: _stack_ is empty.\n            1. Return ~unused~.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"InnerModuleLinking","params":[{"name":"module","ty":"Record[ModuleRecord]","kind":{"Normal":{}}},{"name":"stack","ty":"List[Record[CyclicModuleRecord]]","kind":{"Normal":{}}},{"name":"index","ty":"NonNegInt","kind":{"Normal":{}}}],"retTy":"Normal[NonNegInt] | Throw"}},"body":"\n  1. If _module_ is not a Record[CyclicModuleRecord], then\n    1. Perform ? _module_.Link().\n    1. Return _index_.\n  1. If _module_.[[Status]] is either ~linking~, ~linked~, ~evaluating-async~, or ~evaluated~, then\n    1. Return _index_.\n  1. Assert: _module_.[[Status]] is ~unlinked~.\n  1. Set _module_.[[Status]] to ~linking~.\n  1. Set _module_.[[DFSIndex]] to _index_.\n  1. Set _module_.[[DFSAncestorIndex]] to _index_.\n  1. Set _index_ to _index_ + 1.\n  1. Append _module_ to _stack_.\n  1. For each String _required_ of _module_.[[RequestedModules]], do\n    1. Let _requiredModule_ be GetImportedModule(_module_, _required_).\n    1. Set _index_ to ? InnerModuleLinking(_requiredModule_, _stack_, _index_).\n    1. If _requiredModule_ is a Record[CyclicModuleRecord], then\n      1. Assert: _requiredModule_.[[Status]] is either ~linking~, ~linked~, ~evaluating-async~, or ~evaluated~.\n      1. Assert: _requiredModule_.[[Status]] is ~linking~ if and only if _stack_ contains _requiredModule_..\n      1. If _requiredModule_.[[Status]] is ~linking~, then\n        1. Set _module_.[[DFSAncestorIndex]] to min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).\n  1. Perform ? _module_.InitializeEnvironment().\n  1. Assert: _module_ occurs exactly once in _stack_..\n  1. Assert: _module_.[[DFSAncestorIndex]] ≤ _module_.[[DFSIndex]].\n  1. If _module_.[[DFSAncestorIndex]] = _module_.[[DFSIndex]], then\n    1. Let _done_ be *false*.\n    1. Repeat, while _done_ is *false*,\n      1. Let _requiredModule_ be the last element of _stack_.\n      1. Remove the last element of _stack_.\n      1. Assert: _requiredModule_ is a Record[CyclicModuleRecord].\n      1. Set _requiredModule_.[[Status]] to ~linked~.\n      1. If _requiredModule_ is _module_, set _done_ to *true*.\n  1. Return _index_.","code":"\n              1. If _module_ is not a Cyclic Module Record, then\n                1. Perform ? _module_.Link().\n                1. Return _index_.\n              1. If _module_.[[Status]] is one of ~linking~, ~linked~, ~evaluating-async~, or ~evaluated~, then\n                1. Return _index_.\n              1. Assert: _module_.[[Status]] is ~unlinked~.\n              1. Set _module_.[[Status]] to ~linking~.\n              1. Set _module_.[[DFSIndex]] to _index_.\n              1. Set _module_.[[DFSAncestorIndex]] to _index_.\n              1. Set _index_ to _index_ + 1.\n              1. Append _module_ to _stack_.\n              1. For each String _required_ of _module_.[[RequestedModules]], do\n                1. Let _requiredModule_ be GetImportedModule(_module_, _required_).\n                1. Set _index_ to ? InnerModuleLinking(_requiredModule_, _stack_, _index_).\n                1. If _requiredModule_ is a Cyclic Module Record, then\n                  1. Assert: _requiredModule_.[[Status]] is one of ~linking~, ~linked~, ~evaluating-async~, or ~evaluated~.\n                  1. Assert: _requiredModule_.[[Status]] is ~linking~ if and only if _stack_ contains _requiredModule_.\n                  1. If _requiredModule_.[[Status]] is ~linking~, then\n                    1. Set _module_.[[DFSAncestorIndex]] to min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).\n              1. Perform ? _module_.InitializeEnvironment().\n              1. Assert: _module_ occurs exactly once in _stack_.\n              1. Assert: _module_.[[DFSAncestorIndex]] ≤ _module_.[[DFSIndex]].\n              1. If _module_.[[DFSAncestorIndex]] = _module_.[[DFSIndex]], then\n                1. Let _done_ be *false*.\n                1. Repeat, while _done_ is *false*,\n                  1. Let _requiredModule_ be the last element of _stack_.\n                  1. Remove the last element of _stack_.\n                  1. Assert: _requiredModule_ is a Cyclic Module Record.\n                  1. Set _requiredModule_.[[Status]] to ~linked~.\n                  1. If _requiredModule_ and _module_ are the same Module Record, set _done_ to *true*.\n              1. Return _index_.\n            "},{"head":{"ConcreteMethodHead":{"concMethodName":"Evaluate","receiver":{"name":"module","ty":"Record[CyclicModuleRecord]","kind":{"Normal":{}}},"params":[],"retTy":"Record[Promise]"}},"body":"\n  1. Assert: This call to Evaluate is not happening at the same time as another call to Evaluate within the surrounding agent..\n  1. Assert: _module_.[[Status]] is either ~linked~, ~evaluating-async~, or ~evaluated~.\n  1. If _module_.[[Status]] is either ~evaluating-async~ or ~evaluated~, set _module_ to _module_.[[CycleRoot]].\n  1. If _module_.[[TopLevelCapability]] is not ~empty~, then\n    1. Return _module_.[[TopLevelCapability]].[[Promise]].\n  1. Let _stack_ be « ».\n  1. Let _capability_ be ! NewPromiseCapability(%Promise%).\n  1. Set _module_.[[TopLevelCapability]] to _capability_.\n  1. Let _result_ be Completion(InnerModuleEvaluation(_module_, _stack_, 0)).\n  1. If _result_ is an abrupt completion, then\n    1. For each Record[CyclicModuleRecord] _m_ of _stack_, do\n      1. Assert: _m_.[[Status]] is ~evaluating~.\n      1. Set _m_.[[Status]] to ~evaluated~.\n      1. Set _m_.[[EvaluationError]] to _result_.\n    1. Assert: _module_.[[Status]] is ~evaluated~.\n    1. Assert: _module_.[[EvaluationError]] is _result_.\n    1. Perform ! Call(_capability_.[[Reject]], *undefined*, « _result_.[[Value]] »).\n  1. Else,\n    1. Assert: _module_.[[Status]] is either ~evaluating-async~ or ~evaluated~.\n    1. Assert: _module_.[[EvaluationError]] is ~empty~.\n    1. If _module_.[[AsyncEvaluation]] is *false*, then\n      1. Assert: _module_.[[Status]] is ~evaluated~.\n      1. Perform ! Call(_capability_.[[Resolve]], *undefined*, « *undefined* »).\n    1. Assert: _stack_ is empty.\n  1. Return _capability_.[[Promise]].","code":"\n            1. Assert: This call to Evaluate is not happening at the same time as another call to Evaluate within the surrounding agent.\n            1. Assert: _module_.[[Status]] is one of ~linked~, ~evaluating-async~, or ~evaluated~.\n            1. If _module_.[[Status]] is either ~evaluating-async~ or ~evaluated~, set _module_ to _module_.[[CycleRoot]].\n            1. If _module_.[[TopLevelCapability]] is not ~empty~, then\n              1. Return _module_.[[TopLevelCapability]].[[Promise]].\n            1. Let _stack_ be a new empty List.\n            1. Let _capability_ be ! NewPromiseCapability(%Promise%).\n            1. Set _module_.[[TopLevelCapability]] to _capability_.\n            1. Let _result_ be Completion(InnerModuleEvaluation(_module_, _stack_, 0)).\n            1. If _result_ is an abrupt completion, then\n              1. For each Cyclic Module Record _m_ of _stack_, do\n                1. Assert: _m_.[[Status]] is ~evaluating~.\n                1. Set _m_.[[Status]] to ~evaluated~.\n                1. Set _m_.[[EvaluationError]] to _result_.\n              1. Assert: _module_.[[Status]] is ~evaluated~.\n              1. Assert: _module_.[[EvaluationError]] is _result_.\n              1. Perform ! Call(_capability_.[[Reject]], *undefined*, « _result_.[[Value]] »).\n            1. Else,\n              1. Assert: _module_.[[Status]] is either ~evaluating-async~ or ~evaluated~.\n              1. Assert: _module_.[[EvaluationError]] is ~empty~.\n              1. If _module_.[[AsyncEvaluation]] is *false*, then\n                1. Assert: _module_.[[Status]] is ~evaluated~.\n                1. Perform ! Call(_capability_.[[Resolve]], *undefined*, « *undefined* »).\n              1. Assert: _stack_ is empty.\n            1. Return _capability_.[[Promise]].\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"InnerModuleEvaluation","params":[{"name":"module","ty":"Record[ModuleRecord]","kind":{"Normal":{}}},{"name":"stack","ty":"List[Record[CyclicModuleRecord]]","kind":{"Normal":{}}},{"name":"index","ty":"NonNegInt","kind":{"Normal":{}}}],"retTy":"Normal[NonNegInt] | Throw"}},"body":"\n  1. If _module_ is not a Record[CyclicModuleRecord], then\n    1. Let _promise_ be ! _module_.Evaluate().\n    1. Assert: _promise_.[[PromiseState]] is not ~pending~.\n    1. If _promise_.[[PromiseState]] is ~rejected~, then\n      1. Return ThrowCompletion(_promise_.[[PromiseResult]]).\n    1. Return _index_.\n  1. If _module_.[[Status]] is either ~evaluating-async~ or ~evaluated~, then\n    1. If _module_.[[EvaluationError]] is ~empty~, return _index_.\n    1. Else, return ? _module_.[[EvaluationError]].\n  1. If _module_.[[Status]] is ~evaluating~, return _index_.\n  1. Assert: _module_.[[Status]] is ~linked~.\n  1. Set _module_.[[Status]] to ~evaluating~.\n  1. Set _module_.[[DFSIndex]] to _index_.\n  1. Set _module_.[[DFSAncestorIndex]] to _index_.\n  1. Set _module_.[[PendingAsyncDependencies]] to 0.\n  1. Set _index_ to _index_ + 1.\n  1. Append _module_ to _stack_.\n  1. For each String _required_ of _module_.[[RequestedModules]], do\n    1. Let _requiredModule_ be GetImportedModule(_module_, _required_).\n    1. Set _index_ to ? InnerModuleEvaluation(_requiredModule_, _stack_, _index_).\n    1. If _requiredModule_ is a Record[CyclicModuleRecord], then\n      1. Assert: _requiredModule_.[[Status]] is either ~evaluating~, ~evaluating-async~, or ~evaluated~.\n      1. Assert: _requiredModule_.[[Status]] is ~evaluating~ if and only if _stack_ contains _requiredModule_..\n      1. If _requiredModule_.[[Status]] is ~evaluating~, then\n        1. Set _module_.[[DFSAncestorIndex]] to min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).\n      1. Else,\n        1. Set _requiredModule_ to _requiredModule_.[[CycleRoot]].\n        1. Assert: _requiredModule_.[[Status]] is either ~evaluating-async~ or ~evaluated~.\n        1. If _requiredModule_.[[EvaluationError]] is not ~empty~, return ? _requiredModule_.[[EvaluationError]].\n      1. If _requiredModule_.[[AsyncEvaluation]] is *true*, then\n        1. Set _module_.[[PendingAsyncDependencies]] to _module_.[[PendingAsyncDependencies]] + 1.\n        1. Append _module_ to _requiredModule_.[[AsyncParentModules]].\n  1. If _module_.[[PendingAsyncDependencies]] > 0 or _module_.[[HasTLA]] is *true*, then\n    1. Assert: _module_.[[AsyncEvaluation]] is *false* and was never previously set to *true*..\n    1. Set _module_.[[AsyncEvaluation]] to *true*.\n    1. NOTE: The order in which module records have their [[AsyncEvaluation]] fields transition to *true* is significant. (See <emu-xref href=\"#sec-async-module-execution-fulfilled\"></emu-xref>.)\n    1. If _module_.[[PendingAsyncDependencies]] = 0, perform ExecuteAsyncModule(_module_).\n  1. Else,\n    1. Perform ? _module_.ExecuteModule().\n  1. Assert: _module_ occurs exactly once in _stack_..\n  1. Assert: _module_.[[DFSAncestorIndex]] ≤ _module_.[[DFSIndex]].\n  1. If _module_.[[DFSAncestorIndex]] = _module_.[[DFSIndex]], then\n    1. Let _done_ be *false*.\n    1. Repeat, while _done_ is *false*,\n      1. Let _requiredModule_ be the last element of _stack_.\n      1. Remove the last element of _stack_.\n      1. Assert: _requiredModule_ is a Record[CyclicModuleRecord].\n      1. If _requiredModule_.[[AsyncEvaluation]] is *false*, set _requiredModule_.[[Status]] to ~evaluated~.\n      1. Else, set _requiredModule_.[[Status]] to ~evaluating-async~.\n      1. If _requiredModule_ is _module_, set _done_ to *true*.\n      1. Set _requiredModule_.[[CycleRoot]] to _module_.\n  1. Return _index_.","code":"\n              1. If _module_ is not a Cyclic Module Record, then\n                1. Let _promise_ be ! _module_.Evaluate().\n                1. Assert: _promise_.[[PromiseState]] is not ~pending~.\n                1. If _promise_.[[PromiseState]] is ~rejected~, then\n                  1. Return ThrowCompletion(_promise_.[[PromiseResult]]).\n                1. Return _index_.\n              1. If _module_.[[Status]] is either ~evaluating-async~ or ~evaluated~, then\n                1. If _module_.[[EvaluationError]] is ~empty~, return _index_.\n                1. Otherwise, return ? _module_.[[EvaluationError]].\n              1. If _module_.[[Status]] is ~evaluating~, return _index_.\n              1. Assert: _module_.[[Status]] is ~linked~.\n              1. Set _module_.[[Status]] to ~evaluating~.\n              1. Set _module_.[[DFSIndex]] to _index_.\n              1. Set _module_.[[DFSAncestorIndex]] to _index_.\n              1. Set _module_.[[PendingAsyncDependencies]] to 0.\n              1. Set _index_ to _index_ + 1.\n              1. Append _module_ to _stack_.\n              1. For each String _required_ of _module_.[[RequestedModules]], do\n                1. Let _requiredModule_ be GetImportedModule(_module_, _required_).\n                1. Set _index_ to ? InnerModuleEvaluation(_requiredModule_, _stack_, _index_).\n                1. If _requiredModule_ is a Cyclic Module Record, then\n                  1. Assert: _requiredModule_.[[Status]] is one of ~evaluating~, ~evaluating-async~, or ~evaluated~.\n                  1. Assert: _requiredModule_.[[Status]] is ~evaluating~ if and only if _stack_ contains _requiredModule_.\n                  1. If _requiredModule_.[[Status]] is ~evaluating~, then\n                    1. Set _module_.[[DFSAncestorIndex]] to min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).\n                  1. Else,\n                    1. Set _requiredModule_ to _requiredModule_.[[CycleRoot]].\n                    1. Assert: _requiredModule_.[[Status]] is either ~evaluating-async~ or ~evaluated~.\n                    1. If _requiredModule_.[[EvaluationError]] is not ~empty~, return ? _requiredModule_.[[EvaluationError]].\n                  1. If _requiredModule_.[[AsyncEvaluation]] is *true*, then\n                    1. Set _module_.[[PendingAsyncDependencies]] to _module_.[[PendingAsyncDependencies]] + 1.\n                    1. Append _module_ to _requiredModule_.[[AsyncParentModules]].\n              1. If _module_.[[PendingAsyncDependencies]] > 0 or _module_.[[HasTLA]] is *true*, then\n                1. Assert: _module_.[[AsyncEvaluation]] is *false* and was never previously set to *true*.\n                1. Set _module_.[[AsyncEvaluation]] to *true*.\n                1. NOTE: The order in which module records have their [[AsyncEvaluation]] fields transition to *true* is significant. (See <emu-xref href=\"#sec-async-module-execution-fulfilled\"></emu-xref>.)\n                1. If _module_.[[PendingAsyncDependencies]] = 0, perform ExecuteAsyncModule(_module_).\n              1. Else,\n                1. Perform ? <emu-meta effects=\"user-code\">_module_.ExecuteModule()</emu-meta>.\n              1. Assert: _module_ occurs exactly once in _stack_.\n              1. Assert: _module_.[[DFSAncestorIndex]] ≤ _module_.[[DFSIndex]].\n              1. If _module_.[[DFSAncestorIndex]] = _module_.[[DFSIndex]], then\n                1. Let _done_ be *false*.\n                1. Repeat, while _done_ is *false*,\n                  1. Let _requiredModule_ be the last element of _stack_.\n                  1. Remove the last element of _stack_.\n                  1. Assert: _requiredModule_ is a Cyclic Module Record.\n                  1. If _requiredModule_.[[AsyncEvaluation]] is *false*, set _requiredModule_.[[Status]] to ~evaluated~.\n                  1. Otherwise, set _requiredModule_.[[Status]] to ~evaluating-async~.\n                  1. If _requiredModule_ and _module_ are the same Module Record, set _done_ to *true*.\n                  1. Set _requiredModule_.[[CycleRoot]] to _module_.\n              1. Return _index_.\n            "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ExecuteAsyncModule","params":[{"name":"module","ty":"Record[CyclicModuleRecord]","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Assert: _module_.[[Status]] is either ~evaluating~ or ~evaluating-async~.\n  1. Assert: _module_.[[HasTLA]] is *true*.\n  1. Let _capability_ be ! NewPromiseCapability(%Promise%).\n  1. Let _fulfilledClosure_ be a new Abstract Closure with no parameters that captures _module_ and performs the following steps when called:\n    1. Perform AsyncModuleExecutionFulfilled(_module_).\n    1. Return *undefined*.\n  1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 0, *\"\"*, « »).\n  1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_error_) that captures _module_ and performs the following steps when called:\n    1. Perform AsyncModuleExecutionRejected(_module_, _error_).\n    1. Return *undefined*.\n  1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 0, *\"\"*, « »).\n  1. Perform PerformPromiseThen(_capability_.[[Promise]], _onFulfilled_, _onRejected_).\n  1. Perform ! _module_.ExecuteModule(_capability_).\n  1. Return ~unused~.","code":"\n              1. Assert: _module_.[[Status]] is either ~evaluating~ or ~evaluating-async~.\n              1. Assert: _module_.[[HasTLA]] is *true*.\n              1. Let _capability_ be ! NewPromiseCapability(%Promise%).\n              1. Let _fulfilledClosure_ be a new Abstract Closure with no parameters that captures _module_ and performs the following steps when called:\n                1. Perform AsyncModuleExecutionFulfilled(_module_).\n                1. Return *undefined*.\n              1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 0, *\"\"*, « »).\n              1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_error_) that captures _module_ and performs the following steps when called:\n                1. Perform AsyncModuleExecutionRejected(_module_, _error_).\n                1. Return *undefined*.\n              1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 0, *\"\"*, « »).\n              1. Perform PerformPromiseThen(_capability_.[[Promise]], _onFulfilled_, _onRejected_).\n              1. Perform ! <emu-meta effects=\"user-code\">_module_.ExecuteModule</emu-meta>(_capability_).\n              1. Return ~unused~.\n            "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GatherAvailableAncestors","params":[{"name":"module","ty":"Record[CyclicModuleRecord]","kind":{"Normal":{}}},{"name":"execList","ty":"List[Record[CyclicModuleRecord]]","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. For each Record[CyclicModuleRecord] _m_ of _module_.[[AsyncParentModules]], do\n    1. If _execList_ does not contain _m_ and _m_.[[CycleRoot]].[[EvaluationError]] is ~empty~, then\n      1. Assert: _m_.[[Status]] is ~evaluating-async~.\n      1. Assert: _m_.[[EvaluationError]] is ~empty~.\n      1. Assert: _m_.[[AsyncEvaluation]] is *true*.\n      1. Assert: _m_.[[PendingAsyncDependencies]] > 0.\n      1. Set _m_.[[PendingAsyncDependencies]] to _m_.[[PendingAsyncDependencies]] - 1.\n      1. If _m_.[[PendingAsyncDependencies]] = 0, then\n        1. Append _m_ to _execList_.\n        1. If _m_.[[HasTLA]] is *false*, perform GatherAvailableAncestors(_m_, _execList_).\n  1. Return ~unused~.","code":"\n              1. For each Cyclic Module Record _m_ of _module_.[[AsyncParentModules]], do\n                1. If _execList_ does not contain _m_ and _m_.[[CycleRoot]].[[EvaluationError]] is ~empty~, then\n                  1. Assert: _m_.[[Status]] is ~evaluating-async~.\n                  1. Assert: _m_.[[EvaluationError]] is ~empty~.\n                  1. Assert: _m_.[[AsyncEvaluation]] is *true*.\n                  1. Assert: _m_.[[PendingAsyncDependencies]] > 0.\n                  1. Set _m_.[[PendingAsyncDependencies]] to _m_.[[PendingAsyncDependencies]] - 1.\n                  1. If _m_.[[PendingAsyncDependencies]] = 0, then\n                    1. Append _m_ to _execList_.\n                    1. If _m_.[[HasTLA]] is *false*, perform GatherAvailableAncestors(_m_, _execList_).\n              1. Return ~unused~.\n            "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AsyncModuleExecutionFulfilled","params":[{"name":"module","ty":"Record[CyclicModuleRecord]","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. If _module_.[[Status]] is ~evaluated~, then\n    1. Assert: _module_.[[EvaluationError]] is not ~empty~.\n    1. Return ~unused~.\n  1. Assert: _module_.[[Status]] is ~evaluating-async~.\n  1. Assert: _module_.[[AsyncEvaluation]] is *true*.\n  1. Assert: _module_.[[EvaluationError]] is ~empty~.\n  1. Set _module_.[[AsyncEvaluation]] to *false*.\n  1. Set _module_.[[Status]] to ~evaluated~.\n  1. If _module_.[[TopLevelCapability]] is not ~empty~, then\n    1. Assert: _module_.[[CycleRoot]] is _module_.\n    1. Perform ! Call(_module_.[[TopLevelCapability]].[[Resolve]], *undefined*, « *undefined* »).\n  1. Let _execList_ be « ».\n  1. Perform GatherAvailableAncestors(_module_, _execList_).\n  1. Let _sortedExecList_ be a List whose elements are the elements of _execList_, in the order in which they had their [[AsyncEvaluation]] fields set to *true* in InnerModuleEvaluation.\n  1. Assert: All elements of _sortedExecList_ have their [[AsyncEvaluation]] field set to *true*, [[PendingAsyncDependencies]] field set to 0, and [[EvaluationError]] field set to ~empty~..\n  1. For each Record[CyclicModuleRecord] _m_ of _sortedExecList_, do\n    1. If _m_.[[Status]] is ~evaluated~, then\n      1. Assert: _m_.[[EvaluationError]] is not ~empty~.\n    1. Else if _m_.[[HasTLA]] is *true*, then\n      1. Perform ExecuteAsyncModule(_m_).\n    1. Else,\n      1. Let _result_ be _m_.ExecuteModule().\n      1. If _result_ is an abrupt completion, then\n        1. Perform AsyncModuleExecutionRejected(_m_, _result_.[[Value]]).\n      1. Else,\n        1. Set _m_.[[Status]] to ~evaluated~.\n        1. If _m_.[[TopLevelCapability]] is not ~empty~, then\n          1. Assert: _m_.[[CycleRoot]] is _m_.\n          1. Perform ! Call(_m_.[[TopLevelCapability]].[[Resolve]], *undefined*, « *undefined* »).\n  1. Return ~unused~.","code":"\n              1. If _module_.[[Status]] is ~evaluated~, then\n                1. Assert: _module_.[[EvaluationError]] is not ~empty~.\n                1. Return ~unused~.\n              1. Assert: _module_.[[Status]] is ~evaluating-async~.\n              1. Assert: _module_.[[AsyncEvaluation]] is *true*.\n              1. Assert: _module_.[[EvaluationError]] is ~empty~.\n              1. Set _module_.[[AsyncEvaluation]] to *false*.\n              1. Set _module_.[[Status]] to ~evaluated~.\n              1. If _module_.[[TopLevelCapability]] is not ~empty~, then\n                1. Assert: _module_.[[CycleRoot]] is _module_.\n                1. Perform ! Call(_module_.[[TopLevelCapability]].[[Resolve]], *undefined*, « *undefined* »).\n              1. Let _execList_ be a new empty List.\n              1. Perform GatherAvailableAncestors(_module_, _execList_).\n              1. Let _sortedExecList_ be a List whose elements are the elements of _execList_, in the order in which they had their [[AsyncEvaluation]] fields set to *true* in InnerModuleEvaluation.\n              1. Assert: All elements of _sortedExecList_ have their [[AsyncEvaluation]] field set to *true*, [[PendingAsyncDependencies]] field set to 0, and [[EvaluationError]] field set to ~empty~.\n              1. For each Cyclic Module Record _m_ of _sortedExecList_, do\n                1. If _m_.[[Status]] is ~evaluated~, then\n                  1. Assert: _m_.[[EvaluationError]] is not ~empty~.\n                1. Else if _m_.[[HasTLA]] is *true*, then\n                  1. Perform ExecuteAsyncModule(_m_).\n                1. Else,\n                  1. Let _result_ be <emu-meta effects=\"user-code\">_m_.ExecuteModule()</emu-meta>.\n                  1. If _result_ is an abrupt completion, then\n                    1. Perform AsyncModuleExecutionRejected(_m_, _result_.[[Value]]).\n                  1. Else,\n                    1. Set _m_.[[Status]] to ~evaluated~.\n                    1. If _m_.[[TopLevelCapability]] is not ~empty~, then\n                      1. Assert: _m_.[[CycleRoot]] is _m_.\n                      1. Perform ! Call(_m_.[[TopLevelCapability]].[[Resolve]], *undefined*, « *undefined* »).\n              1. Return ~unused~.\n            "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AsyncModuleExecutionRejected","params":[{"name":"module","ty":"Record[CyclicModuleRecord]","kind":{"Normal":{}}},{"name":"error","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. If _module_.[[Status]] is ~evaluated~, then\n    1. Assert: _module_.[[EvaluationError]] is not ~empty~.\n    1. Return ~unused~.\n  1. Assert: _module_.[[Status]] is ~evaluating-async~.\n  1. Assert: _module_.[[AsyncEvaluation]] is *true*.\n  1. Assert: _module_.[[EvaluationError]] is ~empty~.\n  1. Set _module_.[[EvaluationError]] to ThrowCompletion(_error_).\n  1. Set _module_.[[Status]] to ~evaluated~.\n  1. For each Record[CyclicModuleRecord] _m_ of _module_.[[AsyncParentModules]], do\n    1. Perform AsyncModuleExecutionRejected(_m_, _error_).\n  1. If _module_.[[TopLevelCapability]] is not ~empty~, then\n    1. Assert: _module_.[[CycleRoot]] is _module_.\n    1. Perform ! Call(_module_.[[TopLevelCapability]].[[Reject]], *undefined*, « _error_ »).\n  1. Return ~unused~.","code":"\n              1. If _module_.[[Status]] is ~evaluated~, then\n                1. Assert: _module_.[[EvaluationError]] is not ~empty~.\n                1. Return ~unused~.\n              1. Assert: _module_.[[Status]] is ~evaluating-async~.\n              1. Assert: _module_.[[AsyncEvaluation]] is *true*.\n              1. Assert: _module_.[[EvaluationError]] is ~empty~.\n              1. Set _module_.[[EvaluationError]] to ThrowCompletion(_error_).\n              1. Set _module_.[[Status]] to ~evaluated~.\n              1. For each Cyclic Module Record _m_ of _module_.[[AsyncParentModules]], do\n                1. Perform AsyncModuleExecutionRejected(_m_, _error_).\n              1. If _module_.[[TopLevelCapability]] is not ~empty~, then\n                1. Assert: _module_.[[CycleRoot]] is _module_.\n                1. Perform ! Call(_module_.[[TopLevelCapability]].[[Reject]], *undefined*, « _error_ »).\n              1. Return ~unused~.\n            "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ParseModule","params":[{"name":"sourceText","ty":"Unknown[\"ECMAScript source text\"]","kind":{"Normal":{}}},{"name":"realm","ty":"Record[RealmRecord]","kind":{"Normal":{}}},{"name":"hostDefined","ty":"Unknown[\"anything\"]","kind":{"Normal":{}}}],"retTy":"Unknown[\"a Source Text Module Record or a non-empty List of *SyntaxError* objects\"]"}},"body":"\n  1. Let _body_ be ParseText(_sourceText_, |Module|).\n  1. If _body_ is a List[Record[Error]], return _body_.\n  1. Let _requestedModules_ be ModuleRequests of _body_.\n  1. Let _importEntries_ be ImportEntries of _body_.\n  1. Let _importedBoundNames_ be ImportedLocalNames(_importEntries_).\n  1. Let _indirectExportEntries_ be « ».\n  1. Let _localExportEntries_ be « ».\n  1. Let _starExportEntries_ be « ».\n  1. Let _exportEntries_ be ExportEntries of _body_.\n  1. For each Record[ExportEntryRecord] _ee_ of _exportEntries_, do\n    1. If _ee_.[[ModuleRequest]] is *null*, then\n      1. If _importedBoundNames_ does not contain _ee_.[[LocalName]], then\n        1. Append _ee_ to _localExportEntries_.\n      1. Else,\n        1. Let _ie_ be the element of _importEntries_ whose [[LocalName]] is _ee_.[[LocalName]].\n        1. If _ie_.[[ImportName]] is ~namespace-object~, then\n          1. NOTE: This is a re-export of an imported module namespace object.\n          1. Append _ee_ to _localExportEntries_.\n        1. Else,\n          1. NOTE: This is a re-export of a single name.\n          1. Append ExportEntry Record { [[ModuleRequest]]: _ie_.[[ModuleRequest]], [[ImportName]]: _ie_.[[ImportName]], [[LocalName]]: *null*, [[ExportName]]: _ee_.[[ExportName]] } to _indirectExportEntries_.\n    1. Else if _ee_.[[ImportName]] is ~all-but-default~, then\n      1. Assert: _ee_.[[ExportName]] is *null*.\n      1. Append _ee_ to _starExportEntries_.\n    1. Else,\n      1. Append _ee_ to _indirectExportEntries_.\n  1. Let _async_ be _body_ Contains `await`.\n  1. Return Source Text Module Record { [[Realm]]: _realm_, [[Environment]]: ~empty~, [[Namespace]]: ~empty~, [[CycleRoot]]: ~empty~, [[HasTLA]]: _async_, [[AsyncEvaluation]]: *false*, [[TopLevelCapability]]: ~empty~, [[AsyncParentModules]]: « », [[PendingAsyncDependencies]]: ~empty~, [[Status]]: ~new~, [[EvaluationError]]: ~empty~, [[HostDefined]]: _hostDefined_, [[ECMAScriptCode]]: _body_, [[Context]]: ~empty~, [[ImportMeta]]: ~empty~, [[RequestedModules]]: _requestedModules_, [[LoadedModules]]: « », [[ImportEntries]]: _importEntries_, [[LocalExportEntries]]: _localExportEntries_, [[IndirectExportEntries]]: _indirectExportEntries_, [[StarExportEntries]]: _starExportEntries_, [[DFSIndex]]: ~empty~, [[DFSAncestorIndex]]: ~empty~ }.","code":"\n            1. Let _body_ be ParseText(_sourceText_, |Module|).\n            1. If _body_ is a List of errors, return _body_.\n            1. Let _requestedModules_ be the ModuleRequests of _body_.\n            1. Let _importEntries_ be ImportEntries of _body_.\n            1. Let _importedBoundNames_ be ImportedLocalNames(_importEntries_).\n            1. Let _indirectExportEntries_ be a new empty List.\n            1. Let _localExportEntries_ be a new empty List.\n            1. Let _starExportEntries_ be a new empty List.\n            1. Let _exportEntries_ be ExportEntries of _body_.\n            1. For each ExportEntry Record _ee_ of _exportEntries_, do\n              1. If _ee_.[[ModuleRequest]] is *null*, then\n                1. If _importedBoundNames_ does not contain _ee_.[[LocalName]], then\n                  1. Append _ee_ to _localExportEntries_.\n                1. Else,\n                  1. Let _ie_ be the element of _importEntries_ whose [[LocalName]] is _ee_.[[LocalName]].\n                  1. If _ie_.[[ImportName]] is ~namespace-object~, then\n                    1. NOTE: This is a re-export of an imported module namespace object.\n                    1. Append _ee_ to _localExportEntries_.\n                  1. Else,\n                    1. NOTE: This is a re-export of a single name.\n                    1. Append the ExportEntry Record { [[ModuleRequest]]: _ie_.[[ModuleRequest]], [[ImportName]]: _ie_.[[ImportName]], [[LocalName]]: *null*, [[ExportName]]: _ee_.[[ExportName]] } to _indirectExportEntries_.\n              1. Else if _ee_.[[ImportName]] is ~all-but-default~, then\n                1. Assert: _ee_.[[ExportName]] is *null*.\n                1. Append _ee_ to _starExportEntries_.\n              1. Else,\n                1. Append _ee_ to _indirectExportEntries_.\n            1. Let _async_ be _body_ Contains `await`.\n            1. Return Source Text Module Record { [[Realm]]: _realm_, [[Environment]]: ~empty~, [[Namespace]]: ~empty~, [[CycleRoot]]: ~empty~, [[HasTLA]]: _async_, [[AsyncEvaluation]]: *false*, [[TopLevelCapability]]: ~empty~, [[AsyncParentModules]]: « », [[PendingAsyncDependencies]]: ~empty~, [[Status]]: ~new~, [[EvaluationError]]: ~empty~, [[HostDefined]]: _hostDefined_, [[ECMAScriptCode]]: _body_, [[Context]]: ~empty~, [[ImportMeta]]: ~empty~, [[RequestedModules]]: _requestedModules_, [[LoadedModules]]: « », [[ImportEntries]]: _importEntries_, [[LocalExportEntries]]: _localExportEntries_, [[IndirectExportEntries]]: _indirectExportEntries_, [[StarExportEntries]]: _starExportEntries_, [[DFSIndex]]: ~empty~, [[DFSAncestorIndex]]: ~empty~ }.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"GetExportedNames","receiver":{"name":"module","ty":"Record[SourceTextModuleRecord]","kind":{"Normal":{}}},"params":[{"name":"exportStarSet","ty":"List[Record[SourceTextModuleRecord]]","kind":{"Optional":{}}}],"retTy":"List[String]"}},"body":"\n  1. Assert: _module_.[[Status]] is not ~new~.\n  1. If _exportStarSet_ is not present, set _exportStarSet_ to « ».\n  1. If _exportStarSet_ contains _module_, then\n    1. Assert: We've reached the starting point of an `export *` circularity..\n    1. Return « ».\n  1. Append _module_ to _exportStarSet_.\n  1. Let _exportedNames_ be « ».\n  1. For each Record[ExportEntryRecord] _e_ of _module_.[[LocalExportEntries]], do\n    1. Assert: _module_ provides the direct binding for this export..\n    1. Assert: _e_.[[ExportName]] is not *null*.\n    1. Append _e_.[[ExportName]] to _exportedNames_.\n  1. For each Record[ExportEntryRecord] _e_ of _module_.[[IndirectExportEntries]], do\n    1. Assert: _module_ imports a specific binding for this export..\n    1. Assert: _e_.[[ExportName]] is not *null*.\n    1. Append _e_.[[ExportName]] to _exportedNames_.\n  1. For each Record[ExportEntryRecord] _e_ of _module_.[[StarExportEntries]], do\n    1. Assert: _e_.[[ModuleRequest]] is not *null*.\n    1. Let _requestedModule_ be GetImportedModule(_module_, _e_.[[ModuleRequest]]).\n    1. Let _starNames_ be _requestedModule_.GetExportedNames(_exportStarSet_).\n    1. For each _n_ of _starNames_, do\n      1. If SameValue(_n_, *\"default\"*) is *false*, then\n        1. If _exportedNames_ does not contain _n_, then\n          1. Append _n_ to _exportedNames_.\n  1. Return _exportedNames_.","code":"\n            1. Assert: _module_.[[Status]] is not ~new~.\n            1. If _exportStarSet_ is not present, set _exportStarSet_ to a new empty List.\n            1. If _exportStarSet_ contains _module_, then\n              1. Assert: We've reached the starting point of an `export *` circularity.\n              1. Return a new empty List.\n            1. Append _module_ to _exportStarSet_.\n            1. Let _exportedNames_ be a new empty List.\n            1. For each ExportEntry Record _e_ of _module_.[[LocalExportEntries]], do\n              1. Assert: _module_ provides the direct binding for this export.\n              1. Assert: _e_.[[ExportName]] is not *null*.\n              1. Append _e_.[[ExportName]] to _exportedNames_.\n            1. For each ExportEntry Record _e_ of _module_.[[IndirectExportEntries]], do\n              1. Assert: _module_ imports a specific binding for this export.\n              1. Assert: _e_.[[ExportName]] is not *null*.\n              1. Append _e_.[[ExportName]] to _exportedNames_.\n            1. For each ExportEntry Record _e_ of _module_.[[StarExportEntries]], do\n              1. Assert: _e_.[[ModuleRequest]] is not *null*.\n              1. Let _requestedModule_ be GetImportedModule(_module_, _e_.[[ModuleRequest]]).\n              1. Let _starNames_ be _requestedModule_.GetExportedNames(_exportStarSet_).\n              1. For each element _n_ of _starNames_, do\n                1. If SameValue(_n_, *\"default\"*) is *false*, then\n                  1. If _exportedNames_ does not contain _n_, then\n                    1. Append _n_ to _exportedNames_.\n            1. Return _exportedNames_.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"ResolveExport","receiver":{"name":"module","ty":"Record[SourceTextModuleRecord]","kind":{"Normal":{}}},"params":[{"name":"exportName","ty":"String","kind":{"Normal":{}}},{"name":"resolveSet","ty":"Unknown[\"a List of Records with fields [[Module]] (a Module Record) and [[ExportName]] (a String)\"]","kind":{"Optional":{}}}],"retTy":"Record[ResolvedBindingRecord] | Enum[~ambiguous~] | Null"}},"body":"\n  1. Assert: _module_.[[Status]] is not ~new~.\n  1. If _resolveSet_ is not present, set _resolveSet_ to « ».\n  1. For each Record[{ ExportName, Module }] _r_ of _resolveSet_, do\n    1. If _module_ is _r_.[[Module]] and SameValue(_exportName_, _r_.[[ExportName]]) is *true*, then\n      1. Assert: This is a circular import request..\n      1. Return *null*.\n  1. Append Record { [[Module]]: _module_, [[ExportName]]: _exportName_ } to _resolveSet_.\n  1. For each Record[ExportEntryRecord] _e_ of _module_.[[LocalExportEntries]], do\n    1. If SameValue(_exportName_, _e_.[[ExportName]]) is *true*, then\n      1. Assert: _module_ provides the direct binding for this export..\n      1. Return ResolvedBinding Record { [[Module]]: _module_, [[BindingName]]: _e_.[[LocalName]] }.\n  1. For each Record[ExportEntryRecord] _e_ of _module_.[[IndirectExportEntries]], do\n    1. If SameValue(_exportName_, _e_.[[ExportName]]) is *true*, then\n      1. Assert: _e_.[[ModuleRequest]] is not *null*.\n      1. Let _importedModule_ be GetImportedModule(_module_, _e_.[[ModuleRequest]]).\n      1. If _e_.[[ImportName]] is ~all~, then\n        1. Assert: _module_ does not provide the direct binding for this export..\n        1. Return ResolvedBinding Record { [[Module]]: _importedModule_, [[BindingName]]: ~namespace~ }.\n      1. Else,\n        1. Assert: _module_ imports a specific binding for this export..\n        1. Return _importedModule_.ResolveExport(_e_.[[ImportName]], _resolveSet_).\n  1. If SameValue(_exportName_, *\"default\"*) is *true*, then\n    1. Assert: A `default` export was not explicitly defined by this module..\n    1. Return *null*.\n    1. NOTE: A `default` export cannot be provided by an `export * from \"mod\"` declaration.\n  1. Let _starResolution_ be *null*.\n  1. For each Record[ExportEntryRecord] _e_ of _module_.[[StarExportEntries]], do\n    1. Assert: _e_.[[ModuleRequest]] is not *null*.\n    1. Let _importedModule_ be GetImportedModule(_module_, _e_.[[ModuleRequest]]).\n    1. Let _resolution_ be _importedModule_.ResolveExport(_exportName_, _resolveSet_).\n    1. If _resolution_ is ~ambiguous~, return ~ambiguous~.\n    1. If _resolution_ is not *null*, then\n      1. Assert: _resolution_ is a Record[ResolvedBindingRecord].\n      1. If _starResolution_ is *null*, then\n        1. Set _starResolution_ to _resolution_.\n      1. Else,\n        1. Assert: There is more than one `*` import that includes the requested name..\n        1. If _resolution_.[[Module]] is not _starResolution_.[[Module]], return ~ambiguous~.\n        1. If _resolution_.[[BindingName]] is not _starResolution_.[[BindingName]] and either _resolution_.[[BindingName]] or _starResolution_.[[BindingName]] is ~namespace~, return ~ambiguous~.\n        1. If _resolution_.[[BindingName]] is a String and _starResolution_.[[BindingName]] is a String and SameValue(_resolution_.[[BindingName]], _starResolution_.[[BindingName]]) is *false*, return ~ambiguous~.\n  1. Return _starResolution_.","code":"\n            1. Assert: _module_.[[Status]] is not ~new~.\n            1. If _resolveSet_ is not present, set _resolveSet_ to a new empty List.\n            1. For each Record { [[Module]], [[ExportName]] } _r_ of _resolveSet_, do\n              1. If _module_ and _r_.[[Module]] are the same Module Record and SameValue(_exportName_, _r_.[[ExportName]]) is *true*, then\n                1. Assert: This is a circular import request.\n                1. Return *null*.\n            1. Append the Record { [[Module]]: _module_, [[ExportName]]: _exportName_ } to _resolveSet_.\n            1. For each ExportEntry Record _e_ of _module_.[[LocalExportEntries]], do\n              1. If SameValue(_exportName_, _e_.[[ExportName]]) is *true*, then\n                1. Assert: _module_ provides the direct binding for this export.\n                1. Return ResolvedBinding Record { [[Module]]: _module_, [[BindingName]]: _e_.[[LocalName]] }.\n            1. For each ExportEntry Record _e_ of _module_.[[IndirectExportEntries]], do\n              1. If SameValue(_exportName_, _e_.[[ExportName]]) is *true*, then\n                1. Assert: _e_.[[ModuleRequest]] is not *null*.\n                1. Let _importedModule_ be GetImportedModule(_module_, _e_.[[ModuleRequest]]).\n                1. If _e_.[[ImportName]] is ~all~, then\n                  1. Assert: _module_ does not provide the direct binding for this export.\n                  1. Return ResolvedBinding Record { [[Module]]: _importedModule_, [[BindingName]]: ~namespace~ }.\n                1. Else,\n                  1. Assert: _module_ imports a specific binding for this export.\n                  1. Return _importedModule_.ResolveExport(_e_.[[ImportName]], _resolveSet_).\n            1. If SameValue(_exportName_, *\"default\"*) is *true*, then\n              1. Assert: A `default` export was not explicitly defined by this module.\n              1. Return *null*.\n              1. NOTE: A `default` export cannot be provided by an `export * from \"mod\"` declaration.\n            1. Let _starResolution_ be *null*.\n            1. For each ExportEntry Record _e_ of _module_.[[StarExportEntries]], do\n              1. Assert: _e_.[[ModuleRequest]] is not *null*.\n              1. Let _importedModule_ be GetImportedModule(_module_, _e_.[[ModuleRequest]]).\n              1. Let _resolution_ be _importedModule_.ResolveExport(_exportName_, _resolveSet_).\n              1. If _resolution_ is ~ambiguous~, return ~ambiguous~.\n              1. If _resolution_ is not *null*, then\n                1. Assert: _resolution_ is a ResolvedBinding Record.\n                1. If _starResolution_ is *null*, then\n                  1. Set _starResolution_ to _resolution_.\n                1. Else,\n                  1. Assert: There is more than one `*` import that includes the requested name.\n                  1. If _resolution_.[[Module]] and _starResolution_.[[Module]] are not the same Module Record, return ~ambiguous~.\n                  1. If _resolution_.[[BindingName]] is not _starResolution_.[[BindingName]] and either _resolution_.[[BindingName]] or _starResolution_.[[BindingName]] is ~namespace~, return ~ambiguous~.\n                  1. If _resolution_.[[BindingName]] is a String, _starResolution_.[[BindingName]] is a String, and SameValue(_resolution_.[[BindingName]], _starResolution_.[[BindingName]]) is *false*, return ~ambiguous~.\n            1. Return _starResolution_.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"InitializeEnvironment","receiver":{"name":"module","ty":"Record[SourceTextModuleRecord]","kind":{"Normal":{}}},"params":[],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. For each Record[ExportEntryRecord] _e_ of _module_.[[IndirectExportEntries]], do\n    1. Assert: _e_.[[ExportName]] is not *null*.\n    1. Let _resolution_ be _module_.ResolveExport(_e_.[[ExportName]]).\n    1. If _resolution_ is either *null* or ~ambiguous~, throw a *SyntaxError* exception.\n    1. Assert: _resolution_ is a Record[ResolvedBindingRecord].\n  1. Assert: All named exports from _module_ are resolvable..\n  1. Let _realm_ be _module_.[[Realm]].\n  1. Assert: _realm_ is not *undefined*.\n  1. Let _env_ be NewModuleEnvironment(_realm_.[[GlobalEnv]]).\n  1. Set _module_.[[Environment]] to _env_.\n  1. For each Record[ImportEntryRecord] _in_ of _module_.[[ImportEntries]], do\n    1. Let _importedModule_ be GetImportedModule(_module_, _in_.[[ModuleRequest]]).\n    1. If _in_.[[ImportName]] is ~namespace-object~, then\n      1. Let _namespace_ be GetModuleNamespace(_importedModule_).\n      1. Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).\n      1. Perform ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_).\n    1. Else,\n      1. Let _resolution_ be _importedModule_.ResolveExport(_in_.[[ImportName]]).\n      1. If _resolution_ is either *null* or ~ambiguous~, throw a *SyntaxError* exception.\n      1. If _resolution_.[[BindingName]] is ~namespace~, then\n        1. Let _namespace_ be GetModuleNamespace(_resolution_.[[Module]]).\n        1. Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).\n        1. Perform ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_).\n      1. Else,\n        1. Perform _env_.CreateImportBinding(_in_.[[LocalName]], _resolution_.[[Module]], _resolution_.[[BindingName]]).\n  1. Let _moduleContext_ be ExecutionContext { }.\n  1. Set _moduleContext_.Function to *null*.\n  1. Assert: _module_.[[Realm]] is not *undefined*.\n  1. Set _moduleContext_.Realm to _module_.[[Realm]].\n  1. Set _moduleContext_.ScriptOrModule to _module_.\n  1. Set _moduleContext_.VariableEnvironment to _module_.[[Environment]].\n  1. Set _moduleContext_.LexicalEnvironment to _module_.[[Environment]].\n  1. Set _moduleContext_.PrivateEnvironment to *null*.\n  1. Set _module_.[[Context]] to _moduleContext_.\n  1. Push _moduleContext_ onto the execution context stack; _moduleContext_ is now the running execution context.\n  1. Let _code_ be _module_.[[ECMAScriptCode]].\n  1. Let _varDeclarations_ be VarScopedDeclarations of _code_.\n  1. Let _declaredVarNames_ be « ».\n  1. For each _d_ of _varDeclarations_, do\n    1. For each _dn_ of BoundNames of _d_, do\n      1. If _declaredVarNames_ does not contain _dn_, then\n        1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).\n        1. Perform ! _env_.InitializeBinding(_dn_, *undefined*).\n        1. Append _dn_ to _declaredVarNames_.\n  1. Let _lexDeclarations_ be LexicallyScopedDeclarations of _code_.\n  1. Let _privateEnv_ be *null*.\n  1. For each _d_ of _lexDeclarations_, do\n    1. For each _dn_ of BoundNames of _d_, do\n      1. If IsConstantDeclaration of _d_ is *true*, then\n        1. Perform ! _env_.CreateImmutableBinding(_dn_, *true*).\n      1. Else,\n        1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).\n      1. If _d_ is a Ast[AsyncFunctionDeclaration | AsyncGeneratorDeclaration | FunctionDeclaration | GeneratorDeclaration], then\n        1. Let _fo_ be InstantiateFunctionObject of _d_ with arguments _env_ and _privateEnv_.\n        1. Perform ! _env_.InitializeBinding(_dn_, _fo_).\n  1. Remove _moduleContext_ from the execution context stack.\n  1. Return ~unused~.","code":"\n            1. For each ExportEntry Record _e_ of _module_.[[IndirectExportEntries]], do\n              1. Assert: _e_.[[ExportName]] is not *null*.\n              1. Let _resolution_ be _module_.ResolveExport(_e_.[[ExportName]]).\n              1. If _resolution_ is either *null* or ~ambiguous~, throw a *SyntaxError* exception.\n              1. Assert: _resolution_ is a ResolvedBinding Record.\n            1. Assert: All named exports from _module_ are resolvable.\n            1. Let _realm_ be _module_.[[Realm]].\n            1. Assert: _realm_ is not *undefined*.\n            1. Let _env_ be NewModuleEnvironment(_realm_.[[GlobalEnv]]).\n            1. Set _module_.[[Environment]] to _env_.\n            1. For each ImportEntry Record _in_ of _module_.[[ImportEntries]], do\n              1. Let _importedModule_ be GetImportedModule(_module_, _in_.[[ModuleRequest]]).\n              1. If _in_.[[ImportName]] is ~namespace-object~, then\n                1. Let _namespace_ be GetModuleNamespace(_importedModule_).\n                1. Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).\n                1. Perform ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_).\n              1. Else,\n                1. Let _resolution_ be _importedModule_.ResolveExport(_in_.[[ImportName]]).\n                1. If _resolution_ is either *null* or ~ambiguous~, throw a *SyntaxError* exception.\n                1. If _resolution_.[[BindingName]] is ~namespace~, then\n                  1. Let _namespace_ be GetModuleNamespace(_resolution_.[[Module]]).\n                  1. Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).\n                  1. Perform ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_).\n                1. Else,\n                  1. Perform _env_.CreateImportBinding(_in_.[[LocalName]], _resolution_.[[Module]], _resolution_.[[BindingName]]).\n            1. Let _moduleContext_ be a new ECMAScript code execution context.\n            1. Set the Function of _moduleContext_ to *null*.\n            1. Assert: _module_.[[Realm]] is not *undefined*.\n            1. Set the Realm of _moduleContext_ to _module_.[[Realm]].\n            1. Set the ScriptOrModule of _moduleContext_ to _module_.\n            1. Set the VariableEnvironment of _moduleContext_ to _module_.[[Environment]].\n            1. Set the LexicalEnvironment of _moduleContext_ to _module_.[[Environment]].\n            1. Set the PrivateEnvironment of _moduleContext_ to *null*.\n            1. Set _module_.[[Context]] to _moduleContext_.\n            1. Push _moduleContext_ onto the execution context stack; _moduleContext_ is now the running execution context.\n            1. Let _code_ be _module_.[[ECMAScriptCode]].\n            1. Let _varDeclarations_ be the VarScopedDeclarations of _code_.\n            1. Let _declaredVarNames_ be a new empty List.\n            1. For each element _d_ of _varDeclarations_, do\n              1. For each element _dn_ of the BoundNames of _d_, do\n                1. If _declaredVarNames_ does not contain _dn_, then\n                  1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).\n                  1. Perform ! _env_.InitializeBinding(_dn_, *undefined*).\n                  1. Append _dn_ to _declaredVarNames_.\n            1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _code_.\n            1. Let _privateEnv_ be *null*.\n            1. For each element _d_ of _lexDeclarations_, do\n              1. For each element _dn_ of the BoundNames of _d_, do\n                1. If IsConstantDeclaration of _d_ is *true*, then\n                  1. Perform ! _env_.CreateImmutableBinding(_dn_, *true*).\n                1. Else,\n                  1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).\n                1. If _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|, then\n                  1. Let _fo_ be InstantiateFunctionObject of _d_ with arguments _env_ and _privateEnv_.\n                  1. Perform ! _env_.InitializeBinding(_dn_, _fo_).\n            1. Remove _moduleContext_ from the execution context stack.\n            1. Return ~unused~.\n          "},{"head":{"ConcreteMethodHead":{"concMethodName":"ExecuteModule","receiver":{"name":"module","ty":"Record[SourceTextModuleRecord]","kind":{"Normal":{}}},"params":[{"name":"capability","ty":"Record[PromiseCapabilityRecord]","kind":{"Optional":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Let _moduleContext_ be ExecutionContext { }.\n  1. Set _moduleContext_.Function to *null*.\n  1. Set _moduleContext_.Realm to _module_.[[Realm]].\n  1. Set _moduleContext_.ScriptOrModule to _module_.\n  1. Assert: _module_ has been linked and declarations in its module environment have been instantiated..\n  1. Set _moduleContext_.VariableEnvironment to _module_.[[Environment]].\n  1. Set _moduleContext_.LexicalEnvironment to _module_.[[Environment]].\n  1. Suspend the running execution context.\n  1. If _module_.[[HasTLA]] is *false*, then\n    1. Assert: _capability_ is not present.\n    1. Push _moduleContext_ onto the execution context stack; _moduleContext_ is now the running execution context.\n    1. Let _result_ be Completion(the result of evaluating _module_.[[ECMAScriptCode]]).\n    1. Suspend _moduleContext_ and remove it from the execution context stack.\n    1. Resume the context that is now on the top of the execution context stack as the running execution context.\n    1. If _result_ is an abrupt completion, then\n      1. Return ? _result_.\n  1. Else,\n    1. Assert: _capability_ is a Record[PromiseCapabilityRecord].\n    1. Perform AsyncBlockStart(_capability_, _module_.[[ECMAScriptCode]], _moduleContext_).\n  1. Return ~unused~.","code":"\n            1. Let _moduleContext_ be a new ECMAScript code execution context.\n            1. Set the Function of _moduleContext_ to *null*.\n            1. Set the Realm of _moduleContext_ to _module_.[[Realm]].\n            1. Set the ScriptOrModule of _moduleContext_ to _module_.\n            1. Assert: _module_ has been linked and declarations in its module environment have been instantiated.\n            1. Set the VariableEnvironment of _moduleContext_ to _module_.[[Environment]].\n            1. Set the LexicalEnvironment of _moduleContext_ to _module_.[[Environment]].\n            1. Suspend the running execution context.\n            1. If _module_.[[HasTLA]] is *false*, then\n              1. Assert: _capability_ is not present.\n              1. Push _moduleContext_ onto the execution context stack; _moduleContext_ is now the running execution context.\n              1. Let _result_ be Completion(Evaluation of _module_.[[ECMAScriptCode]]).\n              1. Suspend _moduleContext_ and remove it from the execution context stack.\n              1. Resume the context that is now on the top of the execution context stack as the running execution context.\n              1. If _result_ is an abrupt completion, then\n                1. Return ? _result_.\n            1. Else,\n              1. Assert: _capability_ is a PromiseCapability Record.\n              1. Perform AsyncBlockStart(_capability_, _module_.[[ECMAScriptCode]], _moduleContext_).\n            1. Return ~unused~.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetImportedModule","params":[{"name":"referrer","ty":"Record[CyclicModuleRecord]","kind":{"Normal":{}}},{"name":"specifier","ty":"String","kind":{"Normal":{}}}],"retTy":"Record[ModuleRecord]"}},"body":"\n  1. Assert: Exactly one element of _referrer_.[[LoadedModules]] is a Record whose [[Specifier]] is _specifier_, since LoadRequestedModules has completed successfully on _referrer_ prior to invoking this abstract operation..\n  1. Let _record_ be the Record in _referrer_.[[LoadedModules]] whose [[Specifier]] is _specifier_.\n  1. Return _record_.[[Module]].","code":"\n          1. Assert: Exactly one element of _referrer_.[[LoadedModules]] is a Record whose [[Specifier]] is _specifier_, since LoadRequestedModules has completed successfully on _referrer_ prior to invoking this abstract operation.\n          1. Let _record_ be the Record in _referrer_.[[LoadedModules]] whose [[Specifier]] is _specifier_.\n          1. Return _record_.[[Module]].\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"FinishLoadingImportedModule","params":[{"name":"referrer","ty":"Record[CyclicModuleRecord | RealmRecord | ScriptRecord]","kind":{"Normal":{}}},{"name":"specifier","ty":"String","kind":{"Normal":{}}},{"name":"payload","ty":"Record[GraphLoadingStateRecord | PromiseCapabilityRecord]","kind":{"Normal":{}}},{"name":"result","ty":"Normal[Record[ModuleRecord]] | Throw","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. If _result_ is a normal completion, then\n    1. If _referrer_.[[LoadedModules]] contains a Record[Record] whose [[Specifier]] is _specifier_, then\n      1. Assert: That Record's [[Module]] is _result_.[[Value]]..\n    1. Else,\n      1. Append Record { [[Specifier]]: _specifier_, [[Module]]: _result_.[[Value]] } to _referrer_.[[LoadedModules]].\n  1. If _payload_ is a Record[GraphLoadingStateRecord], then\n    1. Perform ContinueModuleLoading(_payload_, _result_).\n  1. Else,\n    1. Perform ContinueDynamicImport(_payload_, _result_).\n  1. Return ~unused~.","code":"\n          1. If _result_ is a normal completion, then\n            1. If _referrer_.[[LoadedModules]] contains a Record whose [[Specifier]] is _specifier_, then\n              1. Assert: That Record's [[Module]] is _result_.[[Value]].\n            1. Else,\n              1. Append the Record { [[Specifier]]: _specifier_, [[Module]]: _result_.[[Value]] } to _referrer_.[[LoadedModules]].\n          1. If _payload_ is a GraphLoadingState Record, then\n            1. Perform ContinueModuleLoading(_payload_, _result_).\n          1. Else,\n            1. Perform ContinueDynamicImport(_payload_, _result_).\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetModuleNamespace","params":[{"name":"module","ty":"Unknown[\"an instance of a concrete subclass of Module Record\"]","kind":{"Normal":{}}}],"retTy":"Record[ModuleNamespaceExoticObject] | Enum[~empty~]"}},"body":"\n  1. Assert: If _module_ is a Record[CyclicModuleRecord], then _module_.[[Status]] is neither ~new~ nor ~unlinked~.\n  1. Let _namespace_ be _module_.[[Namespace]].\n  1. If _namespace_ is ~empty~, then\n    1. Let _exportedNames_ be _module_.GetExportedNames().\n    1. Let _unambiguousNames_ be « ».\n    1. For each _name_ of _exportedNames_, do\n      1. Let _resolution_ be _module_.ResolveExport(_name_).\n      1. If _resolution_ is a Record[ResolvedBindingRecord], append _name_ to _unambiguousNames_.\n    1. Set _namespace_ to ModuleNamespaceCreate(_module_, _unambiguousNames_).\n  1. Return _namespace_.","code":"\n          1. Assert: If _module_ is a Cyclic Module Record, then _module_.[[Status]] is not ~new~ or ~unlinked~.\n          1. Let _namespace_ be _module_.[[Namespace]].\n          1. If _namespace_ is ~empty~, then\n            1. Let _exportedNames_ be _module_.GetExportedNames().\n            1. Let _unambiguousNames_ be a new empty List.\n            1. For each element _name_ of _exportedNames_, do\n              1. Let _resolution_ be _module_.ResolveExport(_name_).\n              1. If _resolution_ is a ResolvedBinding Record, append _name_ to _unambiguousNames_.\n            1. Set _namespace_ to ModuleNamespaceCreate(_module_, _unambiguousNames_).\n          1. Return _namespace_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Module","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return *undefined*.","code":"\n          1. Return *undefined*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleBody","idx":0,"subIdx":0,"rhsParams":[{"name":"ModuleItemList","ty":"Ast[ModuleItemList]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _result_ be Completion(the result of evaluating |ModuleItemList|).\n  1. If _result_ is a normal completion and _result_.[[Value]] is ~empty~, then\n    1. Return *undefined*.\n  1. Return ? _result_.","code":"\n          1. Let _result_ be Completion(Evaluation of |ModuleItemList|).\n          1. If _result_ is a normal completion and _result_.[[Value]] is ~empty~, then\n            1. Return *undefined*.\n          1. Return ? _result_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItemList","idx":1,"subIdx":0,"rhsParams":[{"name":"ModuleItemList","ty":"Ast[ModuleItemList]","kind":{"Normal":{}}},{"name":"ModuleItem","ty":"Ast[ModuleItem]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _sl_ be ? the result of evaluating |ModuleItemList|.\n  1. Let _s_ be Completion(the result of evaluating |ModuleItem|).\n  1. Return ? UpdateEmpty(_s_, _sl_).","code":"\n          1. Let _sl_ be ? Evaluation of |ModuleItemList|.\n          1. Let _s_ be Completion(Evaluation of |ModuleItem|).\n          1. Return ? UpdateEmpty(_s_, _sl_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItem","idx":0,"subIdx":0,"rhsParams":[{"name":"ImportDeclaration","ty":"Ast[ImportDeclaration]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ~empty~.","code":"\n          1. Return ~empty~.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Module","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"ImportEntries","isStatic":true,"withParams":[],"retTy":"List[Record[ImportEntryRecord]]"}},"body":"\n  1. Return « ».","code":"\n          1. Return a new empty List.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItemList","idx":1,"subIdx":0,"rhsParams":[{"name":"ModuleItemList","ty":"Ast[ModuleItemList]","kind":{"Normal":{}}},{"name":"ModuleItem","ty":"Ast[ModuleItem]","kind":{"Normal":{}}}]},"methodName":"ImportEntries","isStatic":true,"withParams":[],"retTy":"List[Record[ImportEntryRecord]]"}},"body":"\n  1. Let _entries1_ be ImportEntries of |ModuleItemList|.\n  1. Let _entries2_ be ImportEntries of |ModuleItem|.\n  1. Return the list-concatenation of _entries1_ and _entries2_.","code":"\n          1. Let _entries1_ be ImportEntries of |ModuleItemList|.\n          1. Let _entries2_ be ImportEntries of |ModuleItem|.\n          1. Return the list-concatenation of _entries1_ and _entries2_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItem","idx":1,"subIdx":0,"rhsParams":[{"name":"ExportDeclaration","ty":"Ast[ExportDeclaration]","kind":{"Normal":{}}}]},"methodName":"ImportEntries","isStatic":true,"withParams":[],"retTy":"List[Record[ImportEntryRecord]]"}},"body":"\n  1. Return « ».","code":"\n          1. Return a new empty List.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItem","idx":2,"subIdx":0,"rhsParams":[{"name":"StatementListItem","ty":"Ast[StatementListItem]","kind":{"Normal":{}}}]},"methodName":"ImportEntries","isStatic":true,"withParams":[],"retTy":"List[Record[ImportEntryRecord]]"}},"body":"\n  1. Return « ».","code":"\n          1. Return a new empty List.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ImportDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"ImportClause","ty":"Ast[ImportClause]","kind":{"Normal":{}}},{"name":"FromClause","ty":"Ast[FromClause]","kind":{"Normal":{}}}]},"methodName":"ImportEntries","isStatic":true,"withParams":[],"retTy":"List[Record[ImportEntryRecord]]"}},"body":"\n  1. Let _module_ be the sole element of ModuleRequests of |FromClause|.\n  1. Return ImportEntriesForModule of |ImportClause| with argument _module_.","code":"\n          1. Let _module_ be the sole element of ModuleRequests of |FromClause|.\n          1. Return ImportEntriesForModule of |ImportClause| with argument _module_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ImportDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"ModuleSpecifier","ty":"Ast[ModuleSpecifier]","kind":{"Normal":{}}}]},"methodName":"ImportEntries","isStatic":true,"withParams":[],"retTy":"List[Record[ImportEntryRecord]]"}},"body":"\n  1. Return « ».","code":"\n          1. Return a new empty List.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ImportClause","idx":3,"subIdx":0,"rhsParams":[{"name":"ImportedDefaultBinding","ty":"Ast[ImportedDefaultBinding]","kind":{"Normal":{}}},{"name":"NameSpaceImport","ty":"Ast[NameSpaceImport]","kind":{"Normal":{}}}]},"methodName":"ImportEntriesForModule","isStatic":true,"withParams":[{"name":"module","ty":"String","kind":{"Normal":{}}}],"retTy":"List[Record[ImportEntryRecord]]"}},"body":"\n  1. Let _entries1_ be ImportEntriesForModule of |ImportedDefaultBinding| with argument _module_.\n  1. Let _entries2_ be ImportEntriesForModule of |NameSpaceImport| with argument _module_.\n  1. Return the list-concatenation of _entries1_ and _entries2_.","code":"\n          1. Let _entries1_ be ImportEntriesForModule of |ImportedDefaultBinding| with argument _module_.\n          1. Let _entries2_ be ImportEntriesForModule of |NameSpaceImport| with argument _module_.\n          1. Return the list-concatenation of _entries1_ and _entries2_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ImportClause","idx":4,"subIdx":0,"rhsParams":[{"name":"ImportedDefaultBinding","ty":"Ast[ImportedDefaultBinding]","kind":{"Normal":{}}},{"name":"NamedImports","ty":"Ast[NamedImports]","kind":{"Normal":{}}}]},"methodName":"ImportEntriesForModule","isStatic":true,"withParams":[{"name":"module","ty":"String","kind":{"Normal":{}}}],"retTy":"List[Record[ImportEntryRecord]]"}},"body":"\n  1. Let _entries1_ be ImportEntriesForModule of |ImportedDefaultBinding| with argument _module_.\n  1. Let _entries2_ be ImportEntriesForModule of |NamedImports| with argument _module_.\n  1. Return the list-concatenation of _entries1_ and _entries2_.","code":"\n          1. Let _entries1_ be ImportEntriesForModule of |ImportedDefaultBinding| with argument _module_.\n          1. Let _entries2_ be ImportEntriesForModule of |NamedImports| with argument _module_.\n          1. Return the list-concatenation of _entries1_ and _entries2_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ImportedDefaultBinding","idx":0,"subIdx":0,"rhsParams":[{"name":"ImportedBinding","ty":"Ast[ImportedBinding]","kind":{"Normal":{}}}]},"methodName":"ImportEntriesForModule","isStatic":true,"withParams":[{"name":"module","ty":"String","kind":{"Normal":{}}}],"retTy":"List[Record[ImportEntryRecord]]"}},"body":"\n  1. Let _localName_ be the sole element of BoundNames of |ImportedBinding|.\n  1. Let _defaultEntry_ be ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: *\"default\"*, [[LocalName]]: _localName_ }.\n  1. Return « _defaultEntry_ ».","code":"\n          1. Let _localName_ be the sole element of BoundNames of |ImportedBinding|.\n          1. Let _defaultEntry_ be the ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: *\"default\"*, [[LocalName]]: _localName_ }.\n          1. Return « _defaultEntry_ ».\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NameSpaceImport","idx":0,"subIdx":0,"rhsParams":[{"name":"ImportedBinding","ty":"Ast[ImportedBinding]","kind":{"Normal":{}}}]},"methodName":"ImportEntriesForModule","isStatic":true,"withParams":[{"name":"module","ty":"String","kind":{"Normal":{}}}],"retTy":"List[Record[ImportEntryRecord]]"}},"body":"\n  1. Let _localName_ be StringValue of |ImportedBinding|.\n  1. Let _entry_ be ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: ~namespace-object~, [[LocalName]]: _localName_ }.\n  1. Return « _entry_ ».","code":"\n          1. Let _localName_ be the StringValue of |ImportedBinding|.\n          1. Let _entry_ be the ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: ~namespace-object~, [[LocalName]]: _localName_ }.\n          1. Return « _entry_ ».\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NamedImports","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"ImportEntriesForModule","isStatic":true,"withParams":[{"name":"module","ty":"String","kind":{"Normal":{}}}],"retTy":"List[Record[ImportEntryRecord]]"}},"body":"\n  1. Return « ».","code":"\n          1. Return a new empty List.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ImportsList","idx":1,"subIdx":0,"rhsParams":[{"name":"ImportsList","ty":"Ast[ImportsList]","kind":{"Normal":{}}},{"name":"ImportSpecifier","ty":"Ast[ImportSpecifier]","kind":{"Normal":{}}}]},"methodName":"ImportEntriesForModule","isStatic":true,"withParams":[{"name":"module","ty":"String","kind":{"Normal":{}}}],"retTy":"List[Record[ImportEntryRecord]]"}},"body":"\n  1. Let _specs1_ be ImportEntriesForModule of |ImportsList| with argument _module_.\n  1. Let _specs2_ be ImportEntriesForModule of |ImportSpecifier| with argument _module_.\n  1. Return the list-concatenation of _specs1_ and _specs2_.","code":"\n          1. Let _specs1_ be the ImportEntriesForModule of |ImportsList| with argument _module_.\n          1. Let _specs2_ be the ImportEntriesForModule of |ImportSpecifier| with argument _module_.\n          1. Return the list-concatenation of _specs1_ and _specs2_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ImportSpecifier","idx":0,"subIdx":0,"rhsParams":[{"name":"ImportedBinding","ty":"Ast[ImportedBinding]","kind":{"Normal":{}}}]},"methodName":"ImportEntriesForModule","isStatic":true,"withParams":[{"name":"module","ty":"String","kind":{"Normal":{}}}],"retTy":"List[Record[ImportEntryRecord]]"}},"body":"\n  1. Let _localName_ be the sole element of BoundNames of |ImportedBinding|.\n  1. Let _entry_ be ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _localName_, [[LocalName]]: _localName_ }.\n  1. Return « _entry_ ».","code":"\n          1. Let _localName_ be the sole element of BoundNames of |ImportedBinding|.\n          1. Let _entry_ be the ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _localName_, [[LocalName]]: _localName_ }.\n          1. Return « _entry_ ».\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ImportSpecifier","idx":1,"subIdx":0,"rhsParams":[{"name":"ModuleExportName","ty":"Ast[ModuleExportName]","kind":{"Normal":{}}},{"name":"ImportedBinding","ty":"Ast[ImportedBinding]","kind":{"Normal":{}}}]},"methodName":"ImportEntriesForModule","isStatic":true,"withParams":[{"name":"module","ty":"String","kind":{"Normal":{}}}],"retTy":"List[Record[ImportEntryRecord]]"}},"body":"\n  1. Let _importName_ be StringValue of |ModuleExportName|.\n  1. Let _localName_ be StringValue of |ImportedBinding|.\n  1. Let _entry_ be ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_ }.\n  1. Return « _entry_ ».","code":"\n          1. Let _importName_ be the StringValue of |ModuleExportName|.\n          1. Let _localName_ be the StringValue of |ImportedBinding|.\n          1. Let _entry_ be the ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_ }.\n          1. Return « _entry_ ».\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItemList","idx":1,"subIdx":0,"rhsParams":[{"name":"ModuleItemList","ty":"Ast[ModuleItemList]","kind":{"Normal":{}}},{"name":"ModuleItem","ty":"Ast[ModuleItem]","kind":{"Normal":{}}}]},"methodName":"ExportedBindings","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be ExportedBindings of |ModuleItemList|.\n  1. Let _names2_ be ExportedBindings of |ModuleItem|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n          1. Let _names1_ be ExportedBindings of |ModuleItemList|.\n          1. Let _names2_ be ExportedBindings of |ModuleItem|.\n          1. Return the list-concatenation of _names1_ and _names2_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItem","idx":0,"subIdx":0,"rhsParams":[{"name":"ImportDeclaration","ty":"Ast[ImportDeclaration]","kind":{"Normal":{}}}]},"methodName":"ExportedBindings","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n          1. Return a new empty List.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItem","idx":2,"subIdx":0,"rhsParams":[{"name":"StatementListItem","ty":"Ast[StatementListItem]","kind":{"Normal":{}}}]},"methodName":"ExportedBindings","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n          1. Return a new empty List.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"ExportFromClause","ty":"Ast[ExportFromClause]","kind":{"Normal":{}}},{"name":"FromClause","ty":"Ast[FromClause]","kind":{"Normal":{}}}]},"methodName":"ExportedBindings","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n          1. Return a new empty List.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"NamedExports","ty":"Ast[NamedExports]","kind":{"Normal":{}}}]},"methodName":"ExportedBindings","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return ExportedBindings of |NamedExports|.","code":"\n          1. Return the ExportedBindings of |NamedExports|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":2,"subIdx":0,"rhsParams":[{"name":"VariableStatement","ty":"Ast[VariableStatement]","kind":{"Normal":{}}}]},"methodName":"ExportedBindings","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |VariableStatement|.","code":"\n          1. Return the BoundNames of |VariableStatement|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":3,"subIdx":0,"rhsParams":[{"name":"Declaration","ty":"Ast[Declaration]","kind":{"Normal":{}}}]},"methodName":"ExportedBindings","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |Declaration|.","code":"\n          1. Return the BoundNames of |Declaration|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":4,"subIdx":0,"rhsParams":[{"name":"HoistableDeclaration","ty":"Ast[HoistableDeclaration]","kind":{"Normal":{}}}]},"methodName":"ExportedBindings","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of *this* value.","code":"\n          1. Return the BoundNames of this |ExportDeclaration|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":5,"subIdx":0,"rhsParams":[{"name":"ClassDeclaration","ty":"Ast[ClassDeclaration]","kind":{"Normal":{}}}]},"methodName":"ExportedBindings","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of *this* value.","code":"\n          1. Return the BoundNames of this |ExportDeclaration|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":6,"subIdx":0,"rhsParams":[{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"ExportedBindings","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of *this* value.","code":"\n          1. Return the BoundNames of this |ExportDeclaration|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NamedExports","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"ExportedBindings","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n          1. Return a new empty List.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportsList","idx":1,"subIdx":0,"rhsParams":[{"name":"ExportsList","ty":"Ast[ExportsList]","kind":{"Normal":{}}},{"name":"ExportSpecifier","ty":"Ast[ExportSpecifier]","kind":{"Normal":{}}}]},"methodName":"ExportedBindings","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be ExportedBindings of |ExportsList|.\n  1. Let _names2_ be ExportedBindings of |ExportSpecifier|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n          1. Let _names1_ be the ExportedBindings of |ExportsList|.\n          1. Let _names2_ be the ExportedBindings of |ExportSpecifier|.\n          1. Return the list-concatenation of _names1_ and _names2_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportSpecifier","idx":0,"subIdx":0,"rhsParams":[{"name":"ModuleExportName","ty":"Ast[ModuleExportName]","kind":{"Normal":{}}}]},"methodName":"ExportedBindings","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « StringValue of |ModuleExportName| ».","code":"\n          1. Return a List whose sole element is the StringValue of |ModuleExportName|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportSpecifier","idx":1,"subIdx":0,"rhsParams":[{"name":"ModuleExportName","ty":"Ast[ModuleExportName]","kind":{"Normal":{}}},{"name":"ModuleExportName","ty":"Ast[ModuleExportName]","kind":{"Normal":{}}}]},"methodName":"ExportedBindings","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « StringValue of the first |ModuleExportName| ».","code":"\n          1. Return a List whose sole element is the StringValue of the first |ModuleExportName|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItemList","idx":1,"subIdx":0,"rhsParams":[{"name":"ModuleItemList","ty":"Ast[ModuleItemList]","kind":{"Normal":{}}},{"name":"ModuleItem","ty":"Ast[ModuleItem]","kind":{"Normal":{}}}]},"methodName":"ExportedNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be ExportedNames of |ModuleItemList|.\n  1. Let _names2_ be ExportedNames of |ModuleItem|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n          1. Let _names1_ be ExportedNames of |ModuleItemList|.\n          1. Let _names2_ be ExportedNames of |ModuleItem|.\n          1. Return the list-concatenation of _names1_ and _names2_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItem","idx":1,"subIdx":0,"rhsParams":[{"name":"ExportDeclaration","ty":"Ast[ExportDeclaration]","kind":{"Normal":{}}}]},"methodName":"ExportedNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return ExportedNames of |ExportDeclaration|.","code":"\n          1. Return the ExportedNames of |ExportDeclaration|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItem","idx":0,"subIdx":0,"rhsParams":[{"name":"ImportDeclaration","ty":"Ast[ImportDeclaration]","kind":{"Normal":{}}}]},"methodName":"ExportedNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n          1. Return a new empty List.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItem","idx":2,"subIdx":0,"rhsParams":[{"name":"StatementListItem","ty":"Ast[StatementListItem]","kind":{"Normal":{}}}]},"methodName":"ExportedNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n          1. Return a new empty List.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"ExportFromClause","ty":"Ast[ExportFromClause]","kind":{"Normal":{}}},{"name":"FromClause","ty":"Ast[FromClause]","kind":{"Normal":{}}}]},"methodName":"ExportedNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return ExportedNames of |ExportFromClause|.","code":"\n          1. Return the ExportedNames of |ExportFromClause|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportFromClause","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"ExportedNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n          1. Return a new empty List.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportFromClause","idx":1,"subIdx":0,"rhsParams":[{"name":"ModuleExportName","ty":"Ast[ModuleExportName]","kind":{"Normal":{}}}]},"methodName":"ExportedNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « StringValue of |ModuleExportName| ».","code":"\n          1. Return a List whose sole element is the StringValue of |ModuleExportName|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportFromClause","idx":2,"subIdx":0,"rhsParams":[{"name":"NamedExports","ty":"Ast[NamedExports]","kind":{"Normal":{}}}]},"methodName":"ExportedNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return ExportedNames of |NamedExports|.","code":"\n          1. Return the ExportedNames of |NamedExports|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":2,"subIdx":0,"rhsParams":[{"name":"VariableStatement","ty":"Ast[VariableStatement]","kind":{"Normal":{}}}]},"methodName":"ExportedNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |VariableStatement|.","code":"\n          1. Return the BoundNames of |VariableStatement|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":3,"subIdx":0,"rhsParams":[{"name":"Declaration","ty":"Ast[Declaration]","kind":{"Normal":{}}}]},"methodName":"ExportedNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return BoundNames of |Declaration|.","code":"\n          1. Return the BoundNames of |Declaration|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":4,"subIdx":0,"rhsParams":[{"name":"HoistableDeclaration","ty":"Ast[HoistableDeclaration]","kind":{"Normal":{}}}]},"methodName":"ExportedNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « *\"default\"* ».","code":"\n          1. Return « *\"default\"* ».\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":5,"subIdx":0,"rhsParams":[{"name":"ClassDeclaration","ty":"Ast[ClassDeclaration]","kind":{"Normal":{}}}]},"methodName":"ExportedNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « *\"default\"* ».","code":"\n          1. Return « *\"default\"* ».\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":6,"subIdx":0,"rhsParams":[{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"ExportedNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « *\"default\"* ».","code":"\n          1. Return « *\"default\"* ».\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NamedExports","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"ExportedNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « ».","code":"\n          1. Return a new empty List.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportsList","idx":1,"subIdx":0,"rhsParams":[{"name":"ExportsList","ty":"Ast[ExportsList]","kind":{"Normal":{}}},{"name":"ExportSpecifier","ty":"Ast[ExportSpecifier]","kind":{"Normal":{}}}]},"methodName":"ExportedNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Let _names1_ be ExportedNames of |ExportsList|.\n  1. Let _names2_ be ExportedNames of |ExportSpecifier|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n          1. Let _names1_ be the ExportedNames of |ExportsList|.\n          1. Let _names2_ be the ExportedNames of |ExportSpecifier|.\n          1. Return the list-concatenation of _names1_ and _names2_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportSpecifier","idx":0,"subIdx":0,"rhsParams":[{"name":"ModuleExportName","ty":"Ast[ModuleExportName]","kind":{"Normal":{}}}]},"methodName":"ExportedNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « StringValue of |ModuleExportName| ».","code":"\n          1. Return a List whose sole element is the StringValue of |ModuleExportName|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportSpecifier","idx":1,"subIdx":0,"rhsParams":[{"name":"ModuleExportName","ty":"Ast[ModuleExportName]","kind":{"Normal":{}}},{"name":"ModuleExportName","ty":"Ast[ModuleExportName]","kind":{"Normal":{}}}]},"methodName":"ExportedNames","isStatic":true,"withParams":[],"retTy":"List[String]"}},"body":"\n  1. Return « StringValue of the second |ModuleExportName| ».","code":"\n          1. Return a List whose sole element is the StringValue of the second |ModuleExportName|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Module","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"ExportEntries","isStatic":true,"withParams":[],"retTy":"List[Record[ExportEntryRecord]]"}},"body":"\n  1. Return « ».","code":"\n          1. Return a new empty List.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItemList","idx":1,"subIdx":0,"rhsParams":[{"name":"ModuleItemList","ty":"Ast[ModuleItemList]","kind":{"Normal":{}}},{"name":"ModuleItem","ty":"Ast[ModuleItem]","kind":{"Normal":{}}}]},"methodName":"ExportEntries","isStatic":true,"withParams":[],"retTy":"List[Record[ExportEntryRecord]]"}},"body":"\n  1. Let _entries1_ be ExportEntries of |ModuleItemList|.\n  1. Let _entries2_ be ExportEntries of |ModuleItem|.\n  1. Return the list-concatenation of _entries1_ and _entries2_.","code":"\n          1. Let _entries1_ be ExportEntries of |ModuleItemList|.\n          1. Let _entries2_ be ExportEntries of |ModuleItem|.\n          1. Return the list-concatenation of _entries1_ and _entries2_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItem","idx":0,"subIdx":0,"rhsParams":[{"name":"ImportDeclaration","ty":"Ast[ImportDeclaration]","kind":{"Normal":{}}}]},"methodName":"ExportEntries","isStatic":true,"withParams":[],"retTy":"List[Record[ExportEntryRecord]]"}},"body":"\n  1. Return « ».","code":"\n          1. Return a new empty List.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleItem","idx":2,"subIdx":0,"rhsParams":[{"name":"StatementListItem","ty":"Ast[StatementListItem]","kind":{"Normal":{}}}]},"methodName":"ExportEntries","isStatic":true,"withParams":[],"retTy":"List[Record[ExportEntryRecord]]"}},"body":"\n  1. Return « ».","code":"\n          1. Return a new empty List.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"ExportFromClause","ty":"Ast[ExportFromClause]","kind":{"Normal":{}}},{"name":"FromClause","ty":"Ast[FromClause]","kind":{"Normal":{}}}]},"methodName":"ExportEntries","isStatic":true,"withParams":[],"retTy":"List[Record[ExportEntryRecord]]"}},"body":"\n  1. Let _module_ be the sole element of ModuleRequests of |FromClause|.\n  1. Return ExportEntriesForModule of |ExportFromClause| with argument _module_.","code":"\n          1. Let _module_ be the sole element of ModuleRequests of |FromClause|.\n          1. Return ExportEntriesForModule of |ExportFromClause| with argument _module_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"NamedExports","ty":"Ast[NamedExports]","kind":{"Normal":{}}}]},"methodName":"ExportEntries","isStatic":true,"withParams":[],"retTy":"List[Record[ExportEntryRecord]]"}},"body":"\n  1. Return ExportEntriesForModule of |NamedExports| with argument *null*.","code":"\n          1. Return ExportEntriesForModule of |NamedExports| with argument *null*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":2,"subIdx":0,"rhsParams":[{"name":"VariableStatement","ty":"Ast[VariableStatement]","kind":{"Normal":{}}}]},"methodName":"ExportEntries","isStatic":true,"withParams":[],"retTy":"List[Record[ExportEntryRecord]]"}},"body":"\n  1. Let _entries_ be « ».\n  1. Let _names_ be BoundNames of |VariableStatement|.\n  1. For each _name_ of _names_, do\n    1. Append ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _name_, [[ExportName]]: _name_ } to _entries_.\n  1. Return _entries_.","code":"\n          1. Let _entries_ be a new empty List.\n          1. Let _names_ be the BoundNames of |VariableStatement|.\n          1. For each element _name_ of _names_, do\n            1. Append the ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _name_, [[ExportName]]: _name_ } to _entries_.\n          1. Return _entries_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":3,"subIdx":0,"rhsParams":[{"name":"Declaration","ty":"Ast[Declaration]","kind":{"Normal":{}}}]},"methodName":"ExportEntries","isStatic":true,"withParams":[],"retTy":"List[Record[ExportEntryRecord]]"}},"body":"\n  1. Let _entries_ be « ».\n  1. Let _names_ be BoundNames of |Declaration|.\n  1. For each _name_ of _names_, do\n    1. Append ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _name_, [[ExportName]]: _name_ } to _entries_.\n  1. Return _entries_.","code":"\n          1. Let _entries_ be a new empty List.\n          1. Let _names_ be the BoundNames of |Declaration|.\n          1. For each element _name_ of _names_, do\n            1. Append the ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _name_, [[ExportName]]: _name_ } to _entries_.\n          1. Return _entries_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":4,"subIdx":0,"rhsParams":[{"name":"HoistableDeclaration","ty":"Ast[HoistableDeclaration]","kind":{"Normal":{}}}]},"methodName":"ExportEntries","isStatic":true,"withParams":[],"retTy":"List[Record[ExportEntryRecord]]"}},"body":"\n  1. Let _names_ be BoundNames of |HoistableDeclaration|.\n  1. Let _localName_ be the sole element of _names_.\n  1. Return a List whose sole element is a new ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _localName_, [[ExportName]]: *\"default\"* }.","code":"\n          1. Let _names_ be BoundNames of |HoistableDeclaration|.\n          1. Let _localName_ be the sole element of _names_.\n          1. Return a List whose sole element is a new ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _localName_, [[ExportName]]: *\"default\"* }.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":5,"subIdx":0,"rhsParams":[{"name":"ClassDeclaration","ty":"Ast[ClassDeclaration]","kind":{"Normal":{}}}]},"methodName":"ExportEntries","isStatic":true,"withParams":[],"retTy":"List[Record[ExportEntryRecord]]"}},"body":"\n  1. Let _names_ be BoundNames of |ClassDeclaration|.\n  1. Let _localName_ be the sole element of _names_.\n  1. Return a List whose sole element is a new ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _localName_, [[ExportName]]: *\"default\"* }.","code":"\n          1. Let _names_ be BoundNames of |ClassDeclaration|.\n          1. Let _localName_ be the sole element of _names_.\n          1. Return a List whose sole element is a new ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _localName_, [[ExportName]]: *\"default\"* }.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":6,"subIdx":0,"rhsParams":[{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"ExportEntries","isStatic":true,"withParams":[],"retTy":"List[Record[ExportEntryRecord]]"}},"body":"\n  1. Let _entry_ be ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: *\"\\*default\\*\"*, [[ExportName]]: *\"default\"* }.\n  1. Return « _entry_ ».","code":"\n          1. Let _entry_ be the ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: *\"\\*default\\*\"*, [[ExportName]]: *\"default\"* }.\n          1. Return « _entry_ ».\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportFromClause","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"ExportEntriesForModule","isStatic":true,"withParams":[{"name":"module","ty":"String | Null","kind":{"Normal":{}}}],"retTy":"List[Record[ExportEntryRecord]]"}},"body":"\n  1. Let _entry_ be ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: ~all-but-default~, [[LocalName]]: *null*, [[ExportName]]: *null* }.\n  1. Return « _entry_ ».","code":"\n          1. Let _entry_ be the ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: ~all-but-default~, [[LocalName]]: *null*, [[ExportName]]: *null* }.\n          1. Return « _entry_ ».\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportFromClause","idx":1,"subIdx":0,"rhsParams":[{"name":"ModuleExportName","ty":"Ast[ModuleExportName]","kind":{"Normal":{}}}]},"methodName":"ExportEntriesForModule","isStatic":true,"withParams":[{"name":"module","ty":"String | Null","kind":{"Normal":{}}}],"retTy":"List[Record[ExportEntryRecord]]"}},"body":"\n  1. Let _exportName_ be StringValue of |ModuleExportName|.\n  1. Let _entry_ be ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: ~all~, [[LocalName]]: *null*, [[ExportName]]: _exportName_ }.\n  1. Return « _entry_ ».","code":"\n          1. Let _exportName_ be the StringValue of |ModuleExportName|.\n          1. Let _entry_ be the ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: ~all~, [[LocalName]]: *null*, [[ExportName]]: _exportName_ }.\n          1. Return « _entry_ ».\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NamedExports","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"ExportEntriesForModule","isStatic":true,"withParams":[{"name":"module","ty":"String | Null","kind":{"Normal":{}}}],"retTy":"List[Record[ExportEntryRecord]]"}},"body":"\n  1. Return « ».","code":"\n          1. Return a new empty List.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportsList","idx":1,"subIdx":0,"rhsParams":[{"name":"ExportsList","ty":"Ast[ExportsList]","kind":{"Normal":{}}},{"name":"ExportSpecifier","ty":"Ast[ExportSpecifier]","kind":{"Normal":{}}}]},"methodName":"ExportEntriesForModule","isStatic":true,"withParams":[{"name":"module","ty":"String | Null","kind":{"Normal":{}}}],"retTy":"List[Record[ExportEntryRecord]]"}},"body":"\n  1. Let _specs1_ be ExportEntriesForModule of |ExportsList| with argument _module_.\n  1. Let _specs2_ be ExportEntriesForModule of |ExportSpecifier| with argument _module_.\n  1. Return the list-concatenation of _specs1_ and _specs2_.","code":"\n          1. Let _specs1_ be the ExportEntriesForModule of |ExportsList| with argument _module_.\n          1. Let _specs2_ be the ExportEntriesForModule of |ExportSpecifier| with argument _module_.\n          1. Return the list-concatenation of _specs1_ and _specs2_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportSpecifier","idx":0,"subIdx":0,"rhsParams":[{"name":"ModuleExportName","ty":"Ast[ModuleExportName]","kind":{"Normal":{}}}]},"methodName":"ExportEntriesForModule","isStatic":true,"withParams":[{"name":"module","ty":"String | Null","kind":{"Normal":{}}}],"retTy":"List[Record[ExportEntryRecord]]"}},"body":"\n  1. Let _sourceName_ be StringValue of |ModuleExportName|.\n  1. If _module_ is *null*, then\n    1. Let _localName_ be _sourceName_.\n    1. Let _importName_ be *null*.\n  1. Else,\n    1. Let _localName_ be *null*.\n    1. Let _importName_ be _sourceName_.\n  1. Return a List whose sole element is a new ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_, [[ExportName]]: _sourceName_ }.","code":"\n          1. Let _sourceName_ be the StringValue of |ModuleExportName|.\n          1. If _module_ is *null*, then\n            1. Let _localName_ be _sourceName_.\n            1. Let _importName_ be *null*.\n          1. Else,\n            1. Let _localName_ be *null*.\n            1. Let _importName_ be _sourceName_.\n          1. Return a List whose sole element is a new ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_, [[ExportName]]: _sourceName_ }.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportSpecifier","idx":1,"subIdx":0,"rhsParams":[{"name":"ModuleExportName","ty":"Ast[ModuleExportName]","kind":{"Normal":{}}},{"name":"ModuleExportName","ty":"Ast[ModuleExportName]","kind":{"Normal":{}}}]},"methodName":"ExportEntriesForModule","isStatic":true,"withParams":[{"name":"module","ty":"String | Null","kind":{"Normal":{}}}],"retTy":"List[Record[ExportEntryRecord]]"}},"body":"\n  1. Let _sourceName_ be StringValue of the first |ModuleExportName|.\n  1. Let _exportName_ be StringValue of the second |ModuleExportName|.\n  1. If _module_ is *null*, then\n    1. Let _localName_ be _sourceName_.\n    1. Let _importName_ be *null*.\n  1. Else,\n    1. Let _localName_ be *null*.\n    1. Let _importName_ be _sourceName_.\n  1. Return a List whose sole element is a new ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_, [[ExportName]]: _exportName_ }.","code":"\n          1. Let _sourceName_ be the StringValue of the first |ModuleExportName|.\n          1. Let _exportName_ be the StringValue of the second |ModuleExportName|.\n          1. If _module_ is *null*, then\n            1. Let _localName_ be _sourceName_.\n            1. Let _importName_ be *null*.\n          1. Else,\n            1. Let _localName_ be *null*.\n            1. Let _importName_ be _sourceName_.\n          1. Return a List whose sole element is a new ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_, [[ExportName]]: _exportName_ }.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NamedExports","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"ReferencedBindings","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « ».","code":"\n          1. Return a new empty List.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportsList","idx":1,"subIdx":0,"rhsParams":[{"name":"ExportsList","ty":"Ast[ExportsList]","kind":{"Normal":{}}},{"name":"ExportSpecifier","ty":"Ast[ExportSpecifier]","kind":{"Normal":{}}}]},"methodName":"ReferencedBindings","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Let _names1_ be ReferencedBindings of |ExportsList|.\n  1. Let _names2_ be ReferencedBindings of |ExportSpecifier|.\n  1. Return the list-concatenation of _names1_ and _names2_.","code":"\n          1. Let _names1_ be the ReferencedBindings of |ExportsList|.\n          1. Let _names2_ be the ReferencedBindings of |ExportSpecifier|.\n          1. Return the list-concatenation of _names1_ and _names2_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportSpecifier","idx":1,"subIdx":0,"rhsParams":[{"name":"ModuleExportName","ty":"Ast[ModuleExportName]","kind":{"Normal":{}}},{"name":"ModuleExportName","ty":"Ast[ModuleExportName]","kind":{"Normal":{}}}]},"methodName":"ReferencedBindings","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return ReferencedBindings of the first |ModuleExportName|.","code":"\n          1. Return the ReferencedBindings of the first |ModuleExportName|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleExportName","idx":0,"subIdx":0,"rhsParams":[{"name":"IdentifierName","ty":"Ast[IdentifierName]","kind":{"Normal":{}}}]},"methodName":"ReferencedBindings","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « |IdentifierName| ».","code":"\n          1. Return a List whose sole element is the |IdentifierName|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ModuleExportName","idx":1,"subIdx":0,"rhsParams":[{"name":"StringLiteral","ty":"Ast[StringLiteral]","kind":{"Normal":{}}}]},"methodName":"ReferencedBindings","isStatic":true,"withParams":[],"retTy":"List[Ast]"}},"body":"\n  1. Return « |StringLiteral| ».","code":"\n          1. Return a List whose sole element is the |StringLiteral|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":0,"subIdx":0,"rhsParams":[{"name":"ExportFromClause","ty":"Ast[ExportFromClause]","kind":{"Normal":{}}},{"name":"FromClause","ty":"Ast[FromClause]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ~empty~.","code":"\n          1. Return ~empty~.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":1,"subIdx":0,"rhsParams":[{"name":"NamedExports","ty":"Ast[NamedExports]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ~empty~.","code":"\n          1. Return ~empty~.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":2,"subIdx":0,"rhsParams":[{"name":"VariableStatement","ty":"Ast[VariableStatement]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ? the result of evaluating |VariableStatement|.","code":"\n          1. Return ? Evaluation of |VariableStatement|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":3,"subIdx":0,"rhsParams":[{"name":"Declaration","ty":"Ast[Declaration]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ? the result of evaluating |Declaration|.","code":"\n          1. Return ? Evaluation of |Declaration|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":4,"subIdx":0,"rhsParams":[{"name":"HoistableDeclaration","ty":"Ast[HoistableDeclaration]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Return ? the result of evaluating |HoistableDeclaration|.","code":"\n          1. Return ? Evaluation of |HoistableDeclaration|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":5,"subIdx":0,"rhsParams":[{"name":"ClassDeclaration","ty":"Ast[ClassDeclaration]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. Let _value_ be ? BindingClassDeclarationEvaluation of |ClassDeclaration|.\n  1. Let _className_ be the sole element of BoundNames of |ClassDeclaration|.\n  1. If _className_ is *\"\\*default\\*\"*, then\n    1. Let _env_ be the running execution context.LexicalEnvironment.\n    1. Perform ? InitializeBoundName(*\"\\*default\\*\"*, _value_, _env_).\n  1. Return ~empty~.","code":"\n          1. Let _value_ be ? BindingClassDeclarationEvaluation of |ClassDeclaration|.\n          1. Let _className_ be the sole element of BoundNames of |ClassDeclaration|.\n          1. If _className_ is *\"\\*default\\*\"*, then\n            1. Let _env_ be the running execution context's LexicalEnvironment.\n            1. Perform ? InitializeBoundName(*\"\\*default\\*\"*, _value_, _env_).\n          1. Return ~empty~.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ExportDeclaration","idx":6,"subIdx":0,"rhsParams":[{"name":"AssignmentExpression","ty":"Ast[AssignmentExpression]","kind":{"Normal":{}}}]},"methodName":"Evaluation","isStatic":false,"withParams":[],"retTy":"Unknown"}},"body":"\n  1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true*, then\n    1. Let _value_ be ? NamedEvaluation of |AssignmentExpression| with argument *\"default\"*.\n  1. Else,\n    1. Let _rhs_ be ? the result of evaluating |AssignmentExpression|.\n    1. Let _value_ be ? GetValue(_rhs_).\n  1. Let _env_ be the running execution context.LexicalEnvironment.\n  1. Perform ? InitializeBoundName(*\"\\*default\\*\"*, _value_, _env_).\n  1. Return ~empty~.","code":"\n          1. If IsAnonymousFunctionDefinition(|AssignmentExpression|) is *true*, then\n            1. Let _value_ be ? NamedEvaluation of |AssignmentExpression| with argument *\"default\"*.\n          1. Else,\n            1. Let _rhs_ be ? Evaluation of |AssignmentExpression|.\n            1. Let _value_ be ? GetValue(_rhs_).\n          1. Let _env_ be the running execution context's LexicalEnvironment.\n          1. Perform ? InitializeBoundName(*\"\\*default\\*\"*, _value_, _env_).\n          1. Return ~empty~.\n        "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"eval"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Return ? PerformEval(_x_, *false*, *false*).","code":"\n        1. Return ? PerformEval(_x_, *false*, *false*).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"PerformEval","params":[{"name":"x","ty":"ESValue","kind":{"Normal":{}}},{"name":"strictCaller","ty":"Boolean","kind":{"Normal":{}}},{"name":"direct","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Assert: If _direct_ is *false*, then _strictCaller_ is also *false*..\n  1. If _x_ is not a String, return _x_.\n  1. Let _evalRealm_ be the current Realm Record.\n  1. NOTE: In the case of a direct eval, _evalRealm_ is the realm of both the caller of `eval` and of the `eval` function itself.\n  1. Perform ? HostEnsureCanCompileStrings(_evalRealm_, « », _x_, _direct_).\n  1. Let _inFunction_ be *false*.\n  1. Let _inMethod_ be *false*.\n  1. Let _inDerivedConstructor_ be *false*.\n  1. Let _inClassFieldInitializer_ be *false*.\n  1. If _direct_ is *true*, then\n    1. Let _thisEnvRec_ be GetThisEnvironment().\n    1. If _thisEnvRec_ is a Record[FunctionEnvironmentRecord], then\n      1. Let _F_ be _thisEnvRec_.[[FunctionObject]].\n      1. Set _inFunction_ to *true*.\n      1. Set _inMethod_ to _thisEnvRec_.HasSuperBinding().\n      1. If IsConstructor(_F_) is *true* and _F_.[[ConstructorKind]] is ~derived~, set _inDerivedConstructor_ to *true*.\n      1. Let _classFieldInitializerName_ be _F_.[[ClassFieldInitializerName]].\n      1. If _classFieldInitializerName_ is not ~empty~, set _inClassFieldInitializer_ to *true*.\n  1. Perform the following substeps in an implementation-defined order:\n    1. Let _script_ be ParseText(StringToCodePoints(_x_), |Script|).\n    1. If _script_ is a List[Record[Error]], throw a *SyntaxError* exception.\n    1. If _script_ Contains |ScriptBody| is *false*, return *undefined*.\n    1. Let _body_ be the |ScriptBody| of _script_.\n    1. If _inFunction_ is *false* and _body_ Contains |NewTarget|, throw a *SyntaxError* exception.\n    1. If _inMethod_ is *false* and _body_ Contains |SuperProperty|, throw a *SyntaxError* exception.\n    1. If _inDerivedConstructor_ is *false* and _body_ Contains |SuperCall|, throw a *SyntaxError* exception.\n    1. If _inClassFieldInitializer_ is *true* and ContainsArguments of _body_ is *true*, throw a *SyntaxError* exception.\n  1. If _strictCaller_ is *true*, let _strictEval_ be *true*.\n  1. Else, let _strictEval_ be IsStrict of _script_.\n  1. Let _runningContext_ be the running execution context.\n  1. NOTE: If _direct_ is *true*, _runningContext_ will be the execution context that performed the direct eval. If _direct_ is *false*, _runningContext_ will be the execution context for the invocation of the `eval` function.\n  1. If _direct_ is *true*, then\n    1. Let _lexEnv_ be NewDeclarativeEnvironment(_runningContext_.LexicalEnvironment).\n    1. Let _varEnv_ be _runningContext_.VariableEnvironment.\n    1. Let _privateEnv_ be _runningContext_.PrivateEnvironment.\n  1. Else,\n    1. Let _lexEnv_ be NewDeclarativeEnvironment(_evalRealm_.[[GlobalEnv]]).\n    1. Let _varEnv_ be _evalRealm_.[[GlobalEnv]].\n    1. Let _privateEnv_ be *null*.\n  1. If _strictEval_ is *true*, set _varEnv_ to _lexEnv_.\n  1. If _runningContext_ is not already suspended, suspend _runningContext_.\n  1. Let _evalContext_ be ExecutionContext { }.\n  1. Set _evalContext_.Function to *null*.\n  1. Set _evalContext_.Realm to _evalRealm_.\n  1. Set _evalContext_.ScriptOrModule to _runningContext_.ScriptOrModule.\n  1. Set _evalContext_.VariableEnvironment to _varEnv_.\n  1. Set _evalContext_.LexicalEnvironment to _lexEnv_.\n  1. Set _evalContext_.PrivateEnvironment to _privateEnv_.\n  1. Push _evalContext_ onto the execution context stack; _evalContext_ is now the running execution context.\n  1. Let _result_ be Completion(EvalDeclarationInstantiation(_body_, _varEnv_, _lexEnv_, _privateEnv_, _strictEval_)).\n  1. If _result_ is a normal completion, then\n    1. Set _result_ to Completion(the result of evaluating _body_).\n  1. If _result_ is a normal completion and _result_.[[Value]] is ~empty~, then\n    1. Set _result_ to NormalCompletion(*undefined*).\n  1. Suspend _evalContext_ and remove it from the execution context stack.\n  1. Resume the context that is now on the top of the execution context stack as the running execution context.\n  1. Return ? _result_.","code":"\n          1. Assert: If _direct_ is *false*, then _strictCaller_ is also *false*.\n          1. If _x_ is not a String, return _x_.\n          1. Let _evalRealm_ be the current Realm Record.\n          1. NOTE: In the case of a direct eval, _evalRealm_ is the realm of both the caller of `eval` and of the `eval` function itself.\n          1. Perform ? HostEnsureCanCompileStrings(_evalRealm_, « », _x_, _direct_).\n          1. Let _inFunction_ be *false*.\n          1. Let _inMethod_ be *false*.\n          1. Let _inDerivedConstructor_ be *false*.\n          1. Let _inClassFieldInitializer_ be *false*.\n          1. If _direct_ is *true*, then\n            1. Let _thisEnvRec_ be GetThisEnvironment().\n            1. If _thisEnvRec_ is a Function Environment Record, then\n              1. Let _F_ be _thisEnvRec_.[[FunctionObject]].\n              1. Set _inFunction_ to *true*.\n              1. Set _inMethod_ to _thisEnvRec_.HasSuperBinding().\n              1. If IsConstructor(_F_) is *true* and _F_.[[ConstructorKind]] is ~derived~, set _inDerivedConstructor_ to *true*.\n              1. Let _classFieldInitializerName_ be _F_.[[ClassFieldInitializerName]].\n              1. If _classFieldInitializerName_ is not ~empty~, set _inClassFieldInitializer_ to *true*.\n          1. Perform the following substeps in an implementation-defined order, possibly interleaving parsing and error detection:\n            1. Let _script_ be ParseText(StringToCodePoints(_x_), |Script|).\n            1. If _script_ is a List of errors, throw a *SyntaxError* exception.\n            1. If _script_ Contains |ScriptBody| is *false*, return *undefined*.\n            1. Let _body_ be the |ScriptBody| of _script_.\n            1. If _inFunction_ is *false* and _body_ Contains |NewTarget|, throw a *SyntaxError* exception.\n            1. If _inMethod_ is *false* and _body_ Contains |SuperProperty|, throw a *SyntaxError* exception.\n            1. If _inDerivedConstructor_ is *false* and _body_ Contains |SuperCall|, throw a *SyntaxError* exception.\n            1. If _inClassFieldInitializer_ is *true* and ContainsArguments of _body_ is *true*, throw a *SyntaxError* exception.\n          1. If _strictCaller_ is *true*, let _strictEval_ be *true*.\n          1. Else, let _strictEval_ be IsStrict of _script_.\n          1. Let _runningContext_ be the running execution context.\n          1. NOTE: If _direct_ is *true*, _runningContext_ will be the execution context that performed the direct eval. If _direct_ is *false*, _runningContext_ will be the execution context for the invocation of the `eval` function.\n          1. If _direct_ is *true*, then\n            1. Let _lexEnv_ be NewDeclarativeEnvironment(_runningContext_'s LexicalEnvironment).\n            1. Let _varEnv_ be _runningContext_'s VariableEnvironment.\n            1. Let _privateEnv_ be _runningContext_'s PrivateEnvironment.\n          1. Else,\n            1. Let _lexEnv_ be NewDeclarativeEnvironment(_evalRealm_.[[GlobalEnv]]).\n            1. Let _varEnv_ be _evalRealm_.[[GlobalEnv]].\n            1. Let _privateEnv_ be *null*.\n          1. If _strictEval_ is *true*, set _varEnv_ to _lexEnv_.\n          1. If _runningContext_ is not already suspended, suspend _runningContext_.\n          1. Let _evalContext_ be a new ECMAScript code execution context.\n          1. Set _evalContext_'s Function to *null*.\n          1. Set _evalContext_'s Realm to _evalRealm_.\n          1. Set _evalContext_'s ScriptOrModule to _runningContext_'s ScriptOrModule.\n          1. Set _evalContext_'s VariableEnvironment to _varEnv_.\n          1. Set _evalContext_'s LexicalEnvironment to _lexEnv_.\n          1. Set _evalContext_'s PrivateEnvironment to _privateEnv_.\n          1. Push _evalContext_ onto the execution context stack; _evalContext_ is now the running execution context.\n          1. Let _result_ be Completion(EvalDeclarationInstantiation(_body_, _varEnv_, _lexEnv_, _privateEnv_, _strictEval_)).\n          1. If _result_ is a normal completion, then\n            1. Set _result_ to Completion(Evaluation of _body_).\n          1. If _result_ is a normal completion and _result_.[[Value]] is ~empty~, then\n            1. Set _result_ to NormalCompletion(*undefined*).\n          1. Suspend _evalContext_ and remove it from the execution context stack.\n          1. Resume the context that is now on the top of the execution context stack as the running execution context.\n          1. Return ? _result_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"EvalDeclarationInstantiation","params":[{"name":"body","ty":"Unknown[\"a |ScriptBody| Parse Node\"]","kind":{"Normal":{}}},{"name":"varEnv","ty":"Record[EnvironmentRecord]","kind":{"Normal":{}}},{"name":"lexEnv","ty":"Record[DeclarativeEnvironmentRecord]","kind":{"Normal":{}}},{"name":"privateEnv","ty":"Record[PrivateEnvironmentRecord] | Null","kind":{"Normal":{}}},{"name":"strict","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Let _varNames_ be VarDeclaredNames of _body_.\n  1. Let _varDeclarations_ be VarScopedDeclarations of _body_.\n  1. If _strict_ is *false*, then\n    1. If _varEnv_ is a Record[GlobalEnvironmentRecord], then\n      1. For each _name_ of _varNames_, do\n        1. If _varEnv_.HasLexicalDeclaration(_name_) is *true*, throw a *SyntaxError* exception.\n        1. NOTE: `eval` will not create a global var declaration that would be shadowed by a global lexical declaration.\n    1. Let _thisEnv_ be _lexEnv_.\n    1. Assert: The following loop will terminate..\n    1. Repeat, while _thisEnv_ is not _varEnv_,\n      1. If _thisEnv_ is not a Record[ObjectEnvironmentRecord], then\n        1. NOTE: The environment of with statements cannot contain any lexical declaration so it doesn't need to be checked for var/let hoisting conflicts.\n        1. For each _name_ of _varNames_, do\n          1. If ! _thisEnv_.HasBinding(_name_) is *true*, then\n            1. [id=\"step-evaldeclarationinstantiation-throw-duplicate-binding\"] Throw a *SyntaxError* exception.\n            1. NOTE: Annex <emu-xref href=\"#sec-variablestatements-in-catch-blocks\"></emu-xref> defines alternate semantics for the above step.\n          1. NOTE: A direct eval will not hoist var declaration over a like-named lexical declaration.\n      1. Set _thisEnv_ to _thisEnv_.[[OuterEnv]].\n  1. Let _privateIdentifiers_ be « ».\n  1. Let _pointer_ be _privateEnv_.\n  1. Repeat, while _pointer_ is not *null*,\n    1. For each Record[PrivateName] _binding_ of _pointer_.[[Names]], do\n      1. If _privateIdentifiers_ does not contain _binding_.[[Description]], append _binding_.[[Description]] to _privateIdentifiers_.\n    1. Set _pointer_ to _pointer_.[[OuterPrivateEnvironment]].\n  1. If AllPrivateIdentifiersValid of _body_ with argument _privateIdentifiers_ is *false*, throw a *SyntaxError* exception.\n  1. Let _functionsToInitialize_ be « ».\n  1. Let _declaredFunctionNames_ be « ».\n  1. For each _d_ of _varDeclarations_, in reverse List order, do\n    1. If _d_ is not a Ast[BindingIdentifier | ForBinding | VariableDeclaration], then\n      1. Assert: _d_ is a Ast[AsyncFunctionDeclaration | AsyncGeneratorDeclaration | FunctionDeclaration | GeneratorDeclaration].\n      1. NOTE: If there are multiple function declarations for the same name, the last declaration is used.\n      1. Let _fn_ be the sole element of BoundNames of _d_.\n      1. If _declaredFunctionNames_ does not contain _fn_, then\n        1. If _varEnv_ is a Record[GlobalEnvironmentRecord], then\n          1. Let _fnDefinable_ be ? _varEnv_.CanDeclareGlobalFunction(_fn_).\n          1. If _fnDefinable_ is *false*, throw a *TypeError* exception.\n        1. Append _fn_ to _declaredFunctionNames_.\n        1. Insert _d_ as the first element of _functionsToInitialize_.\n  1. Let _declaredVarNames_ be « ».\n  1. For each _d_ of _varDeclarations_, do\n    1. If _d_ is a Ast[BindingIdentifier | ForBinding | VariableDeclaration], then\n      1. For each String _vn_ of BoundNames of _d_, do\n        1. If _declaredFunctionNames_ does not contain _vn_, then\n          1. If _varEnv_ is a Record[GlobalEnvironmentRecord], then\n            1. Let _vnDefinable_ be ? _varEnv_.CanDeclareGlobalVar(_vn_).\n            1. If _vnDefinable_ is *false*, throw a *TypeError* exception.\n          1. If _declaredVarNames_ does not contain _vn_, then\n            1. Append _vn_ to _declaredVarNames_.\n  1. [id=\"step-evaldeclarationinstantiation-web-compat-insertion-point\"] NOTE: Annex <emu-xref href=\"#sec-web-compat-evaldeclarationinstantiation\"></emu-xref> adds additional steps at this point.\n  1. [id=\"step-evaldeclarationinstantiation-post-validation\"] NOTE: No abnormal terminations occur after this algorithm step unless _varEnv_ is a Global Environment Record and the global object is a Proxy exotic object.\n  1. Let _lexDeclarations_ be LexicallyScopedDeclarations of _body_.\n  1. For each _d_ of _lexDeclarations_, do\n    1. NOTE: Lexically declared names are only instantiated here but not initialized.\n    1. For each _dn_ of BoundNames of _d_, do\n      1. If IsConstantDeclaration of _d_ is *true*, then\n        1. Perform ? _lexEnv_.CreateImmutableBinding(_dn_, *true*).\n      1. Else,\n        1. Perform ? _lexEnv_.CreateMutableBinding(_dn_, *false*).\n  1. For each Ast _f_ of _functionsToInitialize_, do\n    1. Let _fn_ be the sole element of BoundNames of _f_.\n    1. Let _fo_ be InstantiateFunctionObject of _f_ with arguments _lexEnv_ and _privateEnv_.\n    1. If _varEnv_ is a Record[GlobalEnvironmentRecord], then\n      1. Perform ? _varEnv_.CreateGlobalFunctionBinding(_fn_, _fo_, *true*).\n    1. Else,\n      1. Let _bindingExists_ be ! _varEnv_.HasBinding(_fn_).\n      1. If _bindingExists_ is *false*, then\n        1. NOTE: The following invocation cannot return an abrupt completion because of the validation preceding step <emu-xref href=\"#step-evaldeclarationinstantiation-post-validation\"></emu-xref>.\n        1. Perform ! _varEnv_.CreateMutableBinding(_fn_, *true*).\n        1. Perform ! _varEnv_.InitializeBinding(_fn_, _fo_).\n      1. Else,\n        1. Perform ! _varEnv_.SetMutableBinding(_fn_, _fo_, *false*).\n  1. For each String _vn_ of _declaredVarNames_, do\n    1. If _varEnv_ is a Record[GlobalEnvironmentRecord], then\n      1. Perform ? _varEnv_.CreateGlobalVarBinding(_vn_, *true*).\n    1. Else,\n      1. Let _bindingExists_ be ! _varEnv_.HasBinding(_vn_).\n      1. If _bindingExists_ is *false*, then\n        1. NOTE: The following invocation cannot return an abrupt completion because of the validation preceding step <emu-xref href=\"#step-evaldeclarationinstantiation-post-validation\"></emu-xref>.\n        1. Perform ! _varEnv_.CreateMutableBinding(_vn_, *true*).\n        1. Perform ! _varEnv_.InitializeBinding(_vn_, *undefined*).\n  1. Return ~unused~.","code":"\n          1. Let _varNames_ be the VarDeclaredNames of _body_.\n          1. Let _varDeclarations_ be the VarScopedDeclarations of _body_.\n          1. If _strict_ is *false*, then\n            1. If _varEnv_ is a Global Environment Record, then\n              1. For each element _name_ of _varNames_, do\n                1. If _varEnv_.HasLexicalDeclaration(_name_) is *true*, throw a *SyntaxError* exception.\n                1. NOTE: `eval` will not create a global var declaration that would be shadowed by a global lexical declaration.\n            1. Let _thisEnv_ be _lexEnv_.\n            1. Assert: The following loop will terminate.\n            1. Repeat, while _thisEnv_ is not _varEnv_,\n              1. If _thisEnv_ is not an Object Environment Record, then\n                1. NOTE: The environment of with statements cannot contain any lexical declaration so it doesn't need to be checked for var/let hoisting conflicts.\n                1. For each element _name_ of _varNames_, do\n                  1. If ! _thisEnv_.HasBinding(_name_) is *true*, then\n                    1. [id=\"step-evaldeclarationinstantiation-throw-duplicate-binding\"] Throw a *SyntaxError* exception.\n                    1. NOTE: Annex <emu-xref href=\"#sec-variablestatements-in-catch-blocks\"></emu-xref> defines alternate semantics for the above step.\n                  1. NOTE: A direct eval will not hoist var declaration over a like-named lexical declaration.\n              1. Set _thisEnv_ to _thisEnv_.[[OuterEnv]].\n          1. Let _privateIdentifiers_ be a new empty List.\n          1. Let _pointer_ be _privateEnv_.\n          1. Repeat, while _pointer_ is not *null*,\n            1. For each Private Name _binding_ of _pointer_.[[Names]], do\n              1. If _privateIdentifiers_ does not contain _binding_.[[Description]], append _binding_.[[Description]] to _privateIdentifiers_.\n            1. Set _pointer_ to _pointer_.[[OuterPrivateEnvironment]].\n          1. If AllPrivateIdentifiersValid of _body_ with argument _privateIdentifiers_ is *false*, throw a *SyntaxError* exception.\n          1. Let _functionsToInitialize_ be a new empty List.\n          1. Let _declaredFunctionNames_ be a new empty List.\n          1. For each element _d_ of _varDeclarations_, in reverse List order, do\n            1. If _d_ is not either a |VariableDeclaration|, a |ForBinding|, or a |BindingIdentifier|, then\n              1. Assert: _d_ is either a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|.\n              1. NOTE: If there are multiple function declarations for the same name, the last declaration is used.\n              1. Let _fn_ be the sole element of the BoundNames of _d_.\n              1. If _declaredFunctionNames_ does not contain _fn_, then\n                1. If _varEnv_ is a Global Environment Record, then\n                  1. Let _fnDefinable_ be ? _varEnv_.CanDeclareGlobalFunction(_fn_).\n                  1. If _fnDefinable_ is *false*, throw a *TypeError* exception.\n                1. Append _fn_ to _declaredFunctionNames_.\n                1. Insert _d_ as the first element of _functionsToInitialize_.\n          1. Let _declaredVarNames_ be a new empty List.\n          1. For each element _d_ of _varDeclarations_, do\n            1. If _d_ is either a |VariableDeclaration|, a |ForBinding|, or a |BindingIdentifier|, then\n              1. For each String _vn_ of the BoundNames of _d_, do\n                1. If _declaredFunctionNames_ does not contain _vn_, then\n                  1. If _varEnv_ is a Global Environment Record, then\n                    1. Let _vnDefinable_ be ? _varEnv_.CanDeclareGlobalVar(_vn_).\n                    1. If _vnDefinable_ is *false*, throw a *TypeError* exception.\n                  1. If _declaredVarNames_ does not contain _vn_, then\n                    1. Append _vn_ to _declaredVarNames_.\n          1. [id=\"step-evaldeclarationinstantiation-web-compat-insertion-point\"] NOTE: Annex <emu-xref href=\"#sec-web-compat-evaldeclarationinstantiation\"></emu-xref> adds additional steps at this point.\n          1. [id=\"step-evaldeclarationinstantiation-post-validation\"] NOTE: No abnormal terminations occur after this algorithm step unless _varEnv_ is a Global Environment Record and the global object is a Proxy exotic object.\n          1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _body_.\n          1. For each element _d_ of _lexDeclarations_, do\n            1. NOTE: Lexically declared names are only instantiated here but not initialized.\n            1. For each element _dn_ of the BoundNames of _d_, do\n              1. If IsConstantDeclaration of _d_ is *true*, then\n                1. Perform ? _lexEnv_.CreateImmutableBinding(_dn_, *true*).\n              1. Else,\n                1. Perform ? _lexEnv_.CreateMutableBinding(_dn_, *false*).\n          1. For each Parse Node _f_ of _functionsToInitialize_, do\n            1. Let _fn_ be the sole element of the BoundNames of _f_.\n            1. Let _fo_ be InstantiateFunctionObject of _f_ with arguments _lexEnv_ and _privateEnv_.\n            1. If _varEnv_ is a Global Environment Record, then\n              1. Perform ? _varEnv_.CreateGlobalFunctionBinding(_fn_, _fo_, *true*).\n            1. Else,\n              1. Let _bindingExists_ be ! _varEnv_.HasBinding(_fn_).\n              1. If _bindingExists_ is *false*, then\n                1. NOTE: The following invocation cannot return an abrupt completion because of the validation preceding step <emu-xref href=\"#step-evaldeclarationinstantiation-post-validation\"></emu-xref>.\n                1. Perform ! _varEnv_.CreateMutableBinding(_fn_, *true*).\n                1. Perform ! _varEnv_.InitializeBinding(_fn_, _fo_).\n              1. Else,\n                1. Perform ! _varEnv_.SetMutableBinding(_fn_, _fo_, *false*).\n          1. For each String _vn_ of _declaredVarNames_, do\n            1. If _varEnv_ is a Global Environment Record, then\n              1. Perform ? _varEnv_.CreateGlobalVarBinding(_vn_, *true*).\n            1. Else,\n              1. Let _bindingExists_ be ! _varEnv_.HasBinding(_vn_).\n              1. If _bindingExists_ is *false*, then\n                1. NOTE: The following invocation cannot return an abrupt completion because of the validation preceding step <emu-xref href=\"#step-evaldeclarationinstantiation-post-validation\"></emu-xref>.\n                1. Perform ! _varEnv_.CreateMutableBinding(_vn_, *true*).\n                1. Perform ! _varEnv_.InitializeBinding(_vn_, *undefined*).\n          1. Return ~unused~.\n        "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"isFinite"}},"params":[{"name":"number","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _num_ be ? ToNumber(_number_).\n  1. If _num_ is not finite, return *false*.\n  1. Else, return *true*.","code":"\n        1. Let _num_ be ? ToNumber(_number_).\n        1. If _num_ is not finite, return *false*.\n        1. Otherwise, return *true*.\n      "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"isNaN"}},"params":[{"name":"number","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _num_ be ? ToNumber(_number_).\n  1. If _num_ is *NaN*, return *true*.\n  1. Else, return *false*.","code":"\n        1. Let _num_ be ? ToNumber(_number_).\n        1. If _num_ is *NaN*, return *true*.\n        1. Otherwise, return *false*.\n      "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"parseFloat"}},"params":[{"name":"string","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _inputString_ be ? ToString(_string_).\n  1. Let _trimmedString_ be ! TrimString(_inputString_, ~start~).\n  1. Let _trimmed_ be StringToCodePoints(_trimmedString_).\n  1. Let _trimmedPrefix_ be the longest prefix of _trimmed_ that satisfies the syntax of a |StrDecimalLiteral|, which might be _trimmed_ itself. If there is no such prefix, return *NaN*.\n  1. Let _parsedNumber_ be ParseText(_trimmedPrefix_, |StrDecimalLiteral|).\n  1. Assert: _parsedNumber_ is a Ast.\n  1. Return StringNumericValue of _parsedNumber_.","code":"\n        1. Let _inputString_ be ? ToString(_string_).\n        1. Let _trimmedString_ be ! TrimString(_inputString_, ~start~).\n        1. Let _trimmed_ be StringToCodePoints(_trimmedString_).\n        1. Let _trimmedPrefix_ be the longest prefix of _trimmed_ that satisfies the syntax of a |StrDecimalLiteral|, which might be _trimmed_ itself. If there is no such prefix, return *NaN*.\n        1. Let _parsedNumber_ be ParseText(_trimmedPrefix_, |StrDecimalLiteral|).\n        1. Assert: _parsedNumber_ is a Parse Node.\n        1. Return StringNumericValue of _parsedNumber_.\n      "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"parseInt"}},"params":[{"name":"string","ty":"Unknown","kind":{"Normal":{}}},{"name":"radix","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _inputString_ be ? ToString(_string_).\n  1. Let _S_ be ! TrimString(_inputString_, ~start~).\n  1. Let _sign_ be 1.\n  1. If _S_ is not empty and the first code unit of _S_ is the code unit 0x002D (HYPHEN-MINUS), set _sign_ to -1.\n  1. If _S_ is not empty and the first code unit of _S_ is either the code unit 0x002B (PLUS SIGN) or the code unit 0x002D (HYPHEN-MINUS), set _S_ to the substring of _S_ from index 1.\n  1. Let _R_ be ℝ(? ToInt32(_radix_)).\n  1. Let _stripPrefix_ be *true*.\n  1. If _R_ ≠ 0, then\n    1. If _R_ < 2 or _R_ > 36, return *NaN*.\n    1. If _R_ ≠ 16, set _stripPrefix_ to *false*.\n  1. Else,\n    1. Set _R_ to 10.\n  1. If _stripPrefix_ is *true*, then\n    1. If the length of _S_ is at least 2 and the first two code units of _S_ are either *\"0x\"* or *\"0X\"*, then\n      1. Set _S_ to the substring of _S_ from index 2.\n      1. Set _R_ to 16.\n  1. If _S_ contains a code unit that is not a radix-_R_ digit, let _end_ be the index within _S_ of the first such code unit; otherwise, let _end_ be the length of _S_.\n  1. Let _Z_ be the substring of _S_ from 0 to _end_.\n  1. If _Z_ is empty, return *NaN*.\n  1. Let _mathInt_ be the integer value that is represented by _Z_ in radix-_R_ notation, using the letters <b>A</b> through <b>Z</b> and <b>a</b> through <b>z</b> for digits with values 10 through 35. (However, if _R_ = 10 and _Z_ contains more than 20 significant digits, every significant digit after the 20th may be replaced by a 0 digit, at the option of the implementation; and if _R_ is not one of 2, 4, 8, 10, 16, or 32, then _mathInt_ may be an implementation-approximated integer representing the integer value denoted by _Z_ in radix-_R_ notation.)\n  1. If _mathInt_ = 0, then\n    1. If _sign_ = -1, return *-0*<sub>𝔽</sub>.\n    1. Return *+0*<sub>𝔽</sub>.\n  1. Return 𝔽(_sign_ × _mathInt_).","code":"\n        1. Let _inputString_ be ? ToString(_string_).\n        1. Let _S_ be ! TrimString(_inputString_, ~start~).\n        1. Let _sign_ be 1.\n        1. If _S_ is not empty and the first code unit of _S_ is the code unit 0x002D (HYPHEN-MINUS), set _sign_ to -1.\n        1. If _S_ is not empty and the first code unit of _S_ is either the code unit 0x002B (PLUS SIGN) or the code unit 0x002D (HYPHEN-MINUS), set _S_ to the substring of _S_ from index 1.\n        1. Let _R_ be ℝ(? ToInt32(_radix_)).\n        1. Let _stripPrefix_ be *true*.\n        1. If _R_ ≠ 0, then\n          1. If _R_ < 2 or _R_ > 36, return *NaN*.\n          1. If _R_ ≠ 16, set _stripPrefix_ to *false*.\n        1. Else,\n          1. Set _R_ to 10.\n        1. If _stripPrefix_ is *true*, then\n          1. If the length of _S_ is at least 2 and the first two code units of _S_ are either *\"0x\"* or *\"0X\"*, then\n            1. Set _S_ to the substring of _S_ from index 2.\n            1. Set _R_ to 16.\n        1. If _S_ contains a code unit that is not a radix-_R_ digit, let _end_ be the index within _S_ of the first such code unit; otherwise, let _end_ be the length of _S_.\n        1. Let _Z_ be the substring of _S_ from 0 to _end_.\n        1. If _Z_ is empty, return *NaN*.\n        1. Let _mathInt_ be the integer value that is represented by _Z_ in radix-_R_ notation, using the letters <b>A</b> through <b>Z</b> and <b>a</b> through <b>z</b> for digits with values 10 through 35. (However, if _R_ = 10 and _Z_ contains more than 20 significant digits, every significant digit after the 20th may be replaced by a 0 digit, at the option of the implementation; and if _R_ is not one of 2, 4, 8, 10, 16, or 32, then _mathInt_ may be an implementation-approximated integer representing the integer value denoted by _Z_ in radix-_R_ notation.)\n        1. If _mathInt_ = 0, then\n          1. If _sign_ = -1, return *-0*<sub>𝔽</sub>.\n          1. Return *+0*<sub>𝔽</sub>.\n        1. Return 𝔽(_sign_ × _mathInt_).\n      "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"decodeURI"}},"params":[{"name":"encodedURI","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _uriString_ be ? ToString(_encodedURI_).\n  1. Let _preserveEscapeSet_ be *\";/?:@&=+$,#\"*.\n  1. Return ? Decode(_uriString_, _preserveEscapeSet_).","code":"\n          1. Let _uriString_ be ? ToString(_encodedURI_).\n          1. Let _preserveEscapeSet_ be *\";/?:@&=+$,#\"*.\n          1. Return ? Decode(_uriString_, _preserveEscapeSet_).\n        "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"decodeURIComponent"}},"params":[{"name":"encodedURIComponent","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _componentString_ be ? ToString(_encodedURIComponent_).\n  1. Let _preserveEscapeSet_ be *\"\"*.\n  1. Return ? Decode(_componentString_, _preserveEscapeSet_).","code":"\n          1. Let _componentString_ be ? ToString(_encodedURIComponent_).\n          1. Let _preserveEscapeSet_ be the empty String.\n          1. Return ? Decode(_componentString_, _preserveEscapeSet_).\n        "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"encodeURI"}},"params":[{"name":"uri","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _uriString_ be ? ToString(_uri_).\n  1. Let _extraUnescaped_ be *\";/?:@&=+$,#\"*.\n  1. Return ? Encode(_uriString_, _extraUnescaped_).","code":"\n          1. Let _uriString_ be ? ToString(_uri_).\n          1. Let _extraUnescaped_ be *\";/?:@&=+$,#\"*.\n          1. Return ? Encode(_uriString_, _extraUnescaped_).\n        "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"encodeURIComponent"}},"params":[{"name":"uriComponent","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _componentString_ be ? ToString(_uriComponent_).\n  1. Let _extraUnescaped_ be *\"\"*.\n  1. Return ? Encode(_componentString_, _extraUnescaped_).","code":"\n          1. Let _componentString_ be ? ToString(_uriComponent_).\n          1. Let _extraUnescaped_ be the empty String.\n          1. Return ? Encode(_componentString_, _extraUnescaped_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"Encode","params":[{"name":"string","ty":"String","kind":{"Normal":{}}},{"name":"extraUnescaped","ty":"String","kind":{"Normal":{}}}],"retTy":"Normal[String] | Throw"}},"body":"\n  1. Let _len_ be the length of _string_.\n  1. Let _R_ be *\"\"*.\n  1. Let _alwaysUnescaped_ be the string-concatenation of the ASCII word characters and *\"-.!~\\*'()\"*.\n  1. Let _unescapedSet_ be the string-concatenation of _alwaysUnescaped_ and _extraUnescaped_.\n  1. Let _k_ be 0.\n  1. Repeat, while _k_ < _len_,\n    1. Let _C_ be the code unit at index _k_ within _string_.\n    1. If _unescapedSet_ contains _C_, then\n      1. Set _k_ to _k_ + 1.\n      1. Set _R_ to the string-concatenation of _R_ and _C_.\n    1. Else,\n      1. Let _cp_ be CodePointAt(_string_, _k_).\n      1. If _cp_.[[IsUnpairedSurrogate]] is *true*, throw a *URIError* exception.\n      1. Set _k_ to _k_ + _cp_.[[CodeUnitCount]].\n      1. Let _Octets_ be the List of octets resulting by applying the UTF-8 transformation to _cp_.[[CodePoint]].\n      1. For each _octet_ of _Octets_, do\n        1. Let _hex_ be the String representation of _octet_, formatted as an uppercase hexadecimal number.\n        1. Set _R_ to the string-concatenation of _R_, *\"%\"*, and StringPad(_hex_, 2, *\"0\"*, ~start~).\n  1. Return _R_.","code":"\n          1. Let _len_ be the length of _string_.\n          1. Let _R_ be the empty String.\n          1. Let _alwaysUnescaped_ be the string-concatenation of the ASCII word characters and *\"-.!~\\*'()\"*.\n          1. Let _unescapedSet_ be the string-concatenation of _alwaysUnescaped_ and _extraUnescaped_.\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _C_ be the code unit at index _k_ within _string_.\n            1. If _unescapedSet_ contains _C_, then\n              1. Set _k_ to _k_ + 1.\n              1. Set _R_ to the string-concatenation of _R_ and _C_.\n            1. Else,\n              1. Let _cp_ be CodePointAt(_string_, _k_).\n              1. If _cp_.[[IsUnpairedSurrogate]] is *true*, throw a *URIError* exception.\n              1. Set _k_ to _k_ + _cp_.[[CodeUnitCount]].\n              1. Let _Octets_ be the List of octets resulting by applying the UTF-8 transformation to _cp_.[[CodePoint]].\n              1. For each element _octet_ of _Octets_, do\n                1. Let _hex_ be the String representation of _octet_, formatted as an uppercase hexadecimal number.\n                1. Set _R_ to the string-concatenation of _R_, *\"%\"*, and StringPad(_hex_, 2, *\"0\"*, ~start~).\n          1. Return _R_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"Decode","params":[{"name":"string","ty":"String","kind":{"Normal":{}}},{"name":"preserveEscapeSet","ty":"String","kind":{"Normal":{}}}],"retTy":"Normal[String] | Throw"}},"body":"\n  1. Let _len_ be the length of _string_.\n  1. Let _R_ be *\"\"*.\n  1. Let _k_ be 0.\n  1. Repeat, while _k_ < _len_,\n    1. Let _C_ be the code unit at index _k_ within _string_.\n    1. Let _S_ be _C_.\n    1. If _C_ is 0x0025 (PERCENT SIGN), then\n      1. If _k_ + 3 > _len_, throw a *URIError* exception.\n      1. Let _escape_ be the substring of _string_ from _k_ to _k_ + 3.\n      1. Let _B_ be ParseHexOctet(_string_, _k_ + 1).\n      1. If _B_ is not a Int, throw a *URIError* exception.\n      1. Set _k_ to _k_ + 2.\n      1. Let _n_ be the number of leading 1 bits in _B_.\n      1. If _n_ = 0, then\n        1. Let _asciiChar_ be the code unit whose numeric value is _B_.\n        1. If _preserveEscapeSet_ contains _asciiChar_, set _S_ to _escape_. Otherwise, set _S_ to _asciiChar_.\n      1. Else,\n        1. If _n_ = 1 or _n_ > 4, throw a *URIError* exception.\n        1. Let _Octets_ be « _B_ ».\n        1. Let _j_ be 1.\n        1. Repeat, while _j_ < _n_,\n          1. Set _k_ to _k_ + 1.\n          1. If _k_ + 3 > _len_, throw a *URIError* exception.\n          1. If the code unit at index _k_ within _string_ is not 0x0025 (PERCENT SIGN), throw a *URIError* exception.\n          1. Let _continuationByte_ be ParseHexOctet(_string_, _k_ + 1).\n          1. If _continuationByte_ is not a Int, throw a *URIError* exception.\n          1. Append _continuationByte_ to _Octets_.\n          1. Set _k_ to _k_ + 2.\n          1. Set _j_ to _j_ + 1.\n        1. Assert: the length of _Octets_ is _n_.\n        1. If _Octets_ does not contain a valid UTF-8 encoding of a Unicode code point, throw a *URIError* exception.\n        1. Let _V_ be the code point obtained by applying the UTF-8 transformation to _Octets_, that is, from a List of octets into a 21-bit value.\n        1. Set _S_ to UTF16EncodeCodePoint(_V_).\n    1. Set _R_ to the string-concatenation of _R_ and _S_.\n    1. Set _k_ to _k_ + 1.\n  1. Return _R_.","code":"\n          1. Let _len_ be the length of _string_.\n          1. Let _R_ be the empty String.\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _C_ be the code unit at index _k_ within _string_.\n            1. Let _S_ be _C_.\n            1. If _C_ is the code unit 0x0025 (PERCENT SIGN), then\n              1. If _k_ + 3 > _len_, throw a *URIError* exception.\n              1. Let _escape_ be the substring of _string_ from _k_ to _k_ + 3.\n              1. Let _B_ be ParseHexOctet(_string_, _k_ + 1).\n              1. If _B_ is not an integer, throw a *URIError* exception.\n              1. Set _k_ to _k_ + 2.\n              1. Let _n_ be the number of leading 1 bits in _B_.\n              1. If _n_ = 0, then\n                1. Let _asciiChar_ be the code unit whose numeric value is _B_.\n                1. If _preserveEscapeSet_ contains _asciiChar_, set _S_ to _escape_. Otherwise, set _S_ to _asciiChar_.\n              1. Else,\n                1. If _n_ = 1 or _n_ > 4, throw a *URIError* exception.\n                1. Let _Octets_ be « _B_ ».\n                1. Let _j_ be 1.\n                1. Repeat, while _j_ < _n_,\n                  1. Set _k_ to _k_ + 1.\n                  1. If _k_ + 3 > _len_, throw a *URIError* exception.\n                  1. If the code unit at index _k_ within _string_ is not the code unit 0x0025 (PERCENT SIGN), throw a *URIError* exception.\n                  1. Let _continuationByte_ be ParseHexOctet(_string_, _k_ + 1).\n                  1. If _continuationByte_ is not an integer, throw a *URIError* exception.\n                  1. Append _continuationByte_ to _Octets_.\n                  1. Set _k_ to _k_ + 2.\n                  1. Set _j_ to _j_ + 1.\n                1. Assert: The length of _Octets_ is _n_.\n                1. If _Octets_ does not contain a valid UTF-8 encoding of a Unicode code point, throw a *URIError* exception.\n                1. Let _V_ be the code point obtained by applying the UTF-8 transformation to _Octets_, that is, from a List of octets into a 21-bit value.\n                1. Set _S_ to UTF16EncodeCodePoint(_V_).\n            1. Set _R_ to the string-concatenation of _R_ and _S_.\n            1. Set _k_ to _k_ + 1.\n          1. Return _R_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ParseHexOctet","params":[{"name":"string","ty":"String","kind":{"Normal":{}}},{"name":"position","ty":"NonNegInt","kind":{"Normal":{}}}],"retTy":"Unknown[\"either a non-negative integer or a non-empty List of *SyntaxError* objects\"]"}},"body":"\n  1. Let _len_ be the length of _string_.\n  1. Assert: _position_ + 2 ≤ _len_.\n  1. Let _hexDigits_ be the substring of _string_ from _position_ to _position_ + 2.\n  1. Let _parseResult_ be ParseText(StringToCodePoints(_hexDigits_), |HexDigits[~Sep]|).\n  1. If _parseResult_ is not a Ast, return _parseResult_.\n  1. Let _n_ be MV of _parseResult_.\n  1. Assert: _n_ is in the inclusive interval from 0 to 255.\n  1. Return _n_.","code":"\n          1. Let _len_ be the length of _string_.\n          1. Assert: _position_ + 2 ≤ _len_.\n          1. Let _hexDigits_ be the substring of _string_ from _position_ to _position_ + 2.\n          1. Let _parseResult_ be ParseText(StringToCodePoints(_hexDigits_), |HexDigits[~Sep]|).\n          1. If _parseResult_ is not a Parse Node, return _parseResult_.\n          1. Let _n_ be the MV of _parseResult_.\n          1. Assert: _n_ is in the inclusive interval from 0 to 255.\n          1. Return _n_.\n        "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"Object"}},"params":[{"name":"value","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. If NewTarget is neither *undefined* nor the active function object, then\n    1. Return ? OrdinaryCreateFromConstructor(NewTarget, *\"%Object.prototype%\"*).\n  1. If _value_ is either *undefined* or *null*, return OrdinaryObjectCreate(%Object.prototype%).\n  1. Return ! ToObject(_value_).","code":"\n          1. If NewTarget is neither *undefined* nor the active function object, then\n            1. Return ? OrdinaryCreateFromConstructor(NewTarget, *\"%Object.prototype%\"*).\n          1. If _value_ is either *undefined* or *null*, return OrdinaryObjectCreate(%Object.prototype%).\n          1. Return ! ToObject(_value_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"assign"}},"params":[{"name":"target","ty":"Unknown","kind":{"Normal":{}}},{"name":"sources","ty":"Unknown","kind":{"Variadic":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _to_ be ? ToObject(_target_).\n  1. If only one argument was passed, return _to_.\n  1. For each _nextSource_ of _sources_, do\n    1. If _nextSource_ is neither *undefined* nor *null*, then\n      1. Let _from_ be ! ToObject(_nextSource_).\n      1. Let _keys_ be ? _from_.[[OwnPropertyKeys]]().\n      1. For each _nextKey_ of _keys_, do\n        1. Let _desc_ be ? _from_.[[GetOwnProperty]](_nextKey_).\n        1. If _desc_ is not *undefined* and _desc_.[[Enumerable]] is *true*, then\n          1. Let _propValue_ be ? Get(_from_, _nextKey_).\n          1. Perform ? Set(_to_, _nextKey_, _propValue_, *true*).\n  1. Return _to_.","code":"\n          1. Let _to_ be ? ToObject(_target_).\n          1. If only one argument was passed, return _to_.\n          1. For each element _nextSource_ of _sources_, do\n            1. If _nextSource_ is neither *undefined* nor *null*, then\n              1. Let _from_ be ! ToObject(_nextSource_).\n              1. Let _keys_ be ? <emu-meta effects=\"user-code\">_from_.[[OwnPropertyKeys]]()</emu-meta>.\n              1. For each element _nextKey_ of _keys_, do\n                1. Let _desc_ be ? <emu-meta effects=\"user-code\">_from_.[[GetOwnProperty]]</emu-meta>(_nextKey_).\n                1. If _desc_ is not *undefined* and _desc_.[[Enumerable]] is *true*, then\n                  1. Let _propValue_ be ? Get(_from_, _nextKey_).\n                  1. Perform ? Set(_to_, _nextKey_, _propValue_, *true*).\n          1. Return _to_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"create"}},"params":[{"name":"O","ty":"Unknown","kind":{"Normal":{}}},{"name":"Properties","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If _O_ is not a Record[Object] and _O_ is not *null*, throw a *TypeError* exception.\n  1. Let _obj_ be OrdinaryObjectCreate(_O_).\n  1. If _Properties_ is not *undefined*, then\n    1. Return ? ObjectDefineProperties(_obj_, _Properties_).\n  1. Return _obj_.","code":"\n          1. If _O_ is not an Object and _O_ is not *null*, throw a *TypeError* exception.\n          1. Let _obj_ be OrdinaryObjectCreate(_O_).\n          1. If _Properties_ is not *undefined*, then\n            1. Return ? ObjectDefineProperties(_obj_, _Properties_).\n          1. Return _obj_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"defineProperties"}},"params":[{"name":"O","ty":"Unknown","kind":{"Normal":{}}},{"name":"Properties","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If _O_ is not a Record[Object], throw a *TypeError* exception.\n  1. Return ? ObjectDefineProperties(_O_, _Properties_).","code":"\n          1. If _O_ is not an Object, throw a *TypeError* exception.\n          1. Return ? ObjectDefineProperties(_O_, _Properties_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ObjectDefineProperties","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"Properties","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Record[Object]] | Throw"}},"body":"\n  1. Let _props_ be ? ToObject(_Properties_).\n  1. Let _keys_ be ? _props_.[[OwnPropertyKeys]]().\n  1. Let _descriptors_ be « ».\n  1. For each _nextKey_ of _keys_, do\n    1. Let _propDesc_ be ? _props_.[[GetOwnProperty]](_nextKey_).\n    1. If _propDesc_ is not *undefined* and _propDesc_.[[Enumerable]] is *true*, then\n      1. Let _descObj_ be ? Get(_props_, _nextKey_).\n      1. Let _desc_ be ? ToPropertyDescriptor(_descObj_).\n      1. Append Record { [[Key]]: _nextKey_, [[Descriptor]]: _desc_ } to _descriptors_.\n  1. For each _property_ of _descriptors_, do\n    1. Perform ? DefinePropertyOrThrow(_O_, _property_.[[Key]], _property_.[[Descriptor]]).\n  1. Return _O_.","code":"\n            1. Let _props_ be ? ToObject(_Properties_).\n            1. Let _keys_ be ? <emu-meta effects=\"user-code\">_props_.[[OwnPropertyKeys]]()</emu-meta>.\n            1. Let _descriptors_ be a new empty List.\n            1. For each element _nextKey_ of _keys_, do\n              1. Let _propDesc_ be ? <emu-meta effects=\"user-code\">_props_.[[GetOwnProperty]]</emu-meta>(_nextKey_).\n              1. If _propDesc_ is not *undefined* and _propDesc_.[[Enumerable]] is *true*, then\n                1. Let _descObj_ be ? Get(_props_, _nextKey_).\n                1. Let _desc_ be ? ToPropertyDescriptor(_descObj_).\n                1. Append the Record { [[Key]]: _nextKey_, [[Descriptor]]: _desc_ } to _descriptors_.\n            1. For each element _property_ of _descriptors_, do\n              1. Perform ? DefinePropertyOrThrow(_O_, _property_.[[Key]], _property_.[[Descriptor]]).\n            1. Return _O_.\n          "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"defineProperty"}},"params":[{"name":"O","ty":"Unknown","kind":{"Normal":{}}},{"name":"P","ty":"Unknown","kind":{"Normal":{}}},{"name":"Attributes","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If _O_ is not a Record[Object], throw a *TypeError* exception.\n  1. Let _key_ be ? ToPropertyKey(_P_).\n  1. Let _desc_ be ? ToPropertyDescriptor(_Attributes_).\n  1. Perform ? DefinePropertyOrThrow(_O_, _key_, _desc_).\n  1. Return _O_.","code":"\n          1. If _O_ is not an Object, throw a *TypeError* exception.\n          1. Let _key_ be ? ToPropertyKey(_P_).\n          1. Let _desc_ be ? ToPropertyDescriptor(_Attributes_).\n          1. Perform ? DefinePropertyOrThrow(_O_, _key_, _desc_).\n          1. Return _O_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"entries"}},"params":[{"name":"O","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _obj_ be ? ToObject(_O_).\n  1. Let _entryList_ be ? EnumerableOwnProperties(_obj_, ~key+value~).\n  1. Return CreateArrayFromList(_entryList_).","code":"\n          1. Let _obj_ be ? ToObject(_O_).\n          1. Let _entryList_ be ? EnumerableOwnProperties(_obj_, ~key+value~).\n          1. Return CreateArrayFromList(_entryList_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"freeze"}},"params":[{"name":"O","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If _O_ is not a Record[Object], return _O_.\n  1. Let _status_ be ? SetIntegrityLevel(_O_, ~frozen~).\n  1. If _status_ is *false*, throw a *TypeError* exception.\n  1. Return _O_.","code":"\n          1. If _O_ is not an Object, return _O_.\n          1. Let _status_ be ? SetIntegrityLevel(_O_, ~frozen~).\n          1. If _status_ is *false*, throw a *TypeError* exception.\n          1. Return _O_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"fromEntries"}},"params":[{"name":"iterable","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Perform ? RequireObjectCoercible(_iterable_).\n  1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).\n  1. Assert: _obj_ is an extensible ordinary object with no own properties..\n  1. Let _closure_ be a new Abstract Closure with parameters (_key_, _value_) that captures _obj_ and performs the following steps when called:\n    1. Let _propertyKey_ be ? ToPropertyKey(_key_).\n    1. Perform ! CreateDataPropertyOrThrow(_obj_, _propertyKey_, _value_).\n    1. Return *undefined*.\n  1. Let _adder_ be CreateBuiltinFunction(_closure_, 2, *\"\"*, « »).\n  1. Return ? AddEntriesFromIterable(_obj_, _iterable_, _adder_).","code":"\n          1. Perform ? RequireObjectCoercible(_iterable_).\n          1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).\n          1. Assert: _obj_ is an extensible ordinary object with no own properties.\n          1. Let _closure_ be a new Abstract Closure with parameters (_key_, _value_) that captures _obj_ and performs the following steps when called:\n            1. Let _propertyKey_ be ? ToPropertyKey(_key_).\n            1. Perform ! CreateDataPropertyOrThrow(_obj_, _propertyKey_, _value_).\n            1. Return *undefined*.\n          1. Let _adder_ be CreateBuiltinFunction(_closure_, 2, *\"\"*, « »).\n          1. Return ? AddEntriesFromIterable(_obj_, _iterable_, _adder_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"getOwnPropertyDescriptor"}},"params":[{"name":"O","ty":"Unknown","kind":{"Normal":{}}},{"name":"P","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _obj_ be ? ToObject(_O_).\n  1. Let _key_ be ? ToPropertyKey(_P_).\n  1. Let _desc_ be ? _obj_.[[GetOwnProperty]](_key_).\n  1. Return FromPropertyDescriptor(_desc_).","code":"\n          1. Let _obj_ be ? ToObject(_O_).\n          1. Let _key_ be ? ToPropertyKey(_P_).\n          1. Let _desc_ be ? <emu-meta effects=\"user-code\">_obj_.[[GetOwnProperty]]</emu-meta>(_key_).\n          1. Return FromPropertyDescriptor(_desc_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"getOwnPropertyDescriptors"}},"params":[{"name":"O","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _obj_ be ? ToObject(_O_).\n  1. Let _ownKeys_ be ? _obj_.[[OwnPropertyKeys]]().\n  1. Let _descriptors_ be OrdinaryObjectCreate(%Object.prototype%).\n  1. For each _key_ of _ownKeys_, do\n    1. Let _desc_ be ? _obj_.[[GetOwnProperty]](_key_).\n    1. Let _descriptor_ be FromPropertyDescriptor(_desc_).\n    1. If _descriptor_ is not *undefined*, perform ! CreateDataPropertyOrThrow(_descriptors_, _key_, _descriptor_).\n  1. Return _descriptors_.","code":"\n          1. Let _obj_ be ? ToObject(_O_).\n          1. Let _ownKeys_ be ? <emu-meta effects=\"user-code\">_obj_.[[OwnPropertyKeys]]()</emu-meta>.\n          1. Let _descriptors_ be OrdinaryObjectCreate(%Object.prototype%).\n          1. For each element _key_ of _ownKeys_, do\n            1. Let _desc_ be ? <emu-meta effects=\"user-code\">_obj_.[[GetOwnProperty]]</emu-meta>(_key_).\n            1. Let _descriptor_ be FromPropertyDescriptor(_desc_).\n            1. If _descriptor_ is not *undefined*, perform ! CreateDataPropertyOrThrow(_descriptors_, _key_, _descriptor_).\n          1. Return _descriptors_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"getOwnPropertyNames"}},"params":[{"name":"O","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Return CreateArrayFromList(? GetOwnPropertyKeys(_O_, ~string~)).","code":"\n          1. Return CreateArrayFromList(? GetOwnPropertyKeys(_O_, ~string~)).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"getOwnPropertySymbols"}},"params":[{"name":"O","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Return CreateArrayFromList(? GetOwnPropertyKeys(_O_, ~symbol~)).","code":"\n          1. Return CreateArrayFromList(? GetOwnPropertyKeys(_O_, ~symbol~)).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetOwnPropertyKeys","params":[{"name":"O","ty":"ESValue","kind":{"Normal":{}}},{"name":"type","ty":"Enum[~string~, ~symbol~]","kind":{"Normal":{}}}],"retTy":"Normal[List[Record[Symbol] | String]] | Throw"}},"body":"\n  1. Let _obj_ be ? ToObject(_O_).\n  1. Let _keys_ be ? _obj_.[[OwnPropertyKeys]]().\n  1. Let _nameList_ be « ».\n  1. For each _nextKey_ of _keys_, do\n    1. If _nextKey_ is a Record[Symbol] and _type_ is ~symbol~ or _nextKey_ is a String and _type_ is ~string~, then\n      1. Append _nextKey_ to _nameList_.\n  1. Return _nameList_.","code":"\n            1. Let _obj_ be ? ToObject(_O_).\n            1. Let _keys_ be ? <emu-meta effects=\"user-code\">_obj_.[[OwnPropertyKeys]]()</emu-meta>.\n            1. Let _nameList_ be a new empty List.\n            1. For each element _nextKey_ of _keys_, do\n              1. If _nextKey_ is a Symbol and _type_ is ~symbol~, or if _nextKey_ is a String and _type_ is ~string~, then\n                1. Append _nextKey_ to _nameList_.\n            1. Return _nameList_.\n          "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"getPrototypeOf"}},"params":[{"name":"O","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _obj_ be ? ToObject(_O_).\n  1. Return ? _obj_.[[GetPrototypeOf]]().","code":"\n          1. Let _obj_ be ? ToObject(_O_).\n          1. Return ? <emu-meta effects=\"user-code\">_obj_.[[GetPrototypeOf]]()</emu-meta>.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"groupBy"}},"params":[{"name":"items","ty":"Unknown","kind":{"Normal":{}}},{"name":"callbackfn","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _groups_ be ? GroupBy(_items_, _callbackfn_, ~property~).\n  1. Let _obj_ be OrdinaryObjectCreate(*null*).\n  1. For each Record[{ Elements, Key }] _g_ of _groups_, do\n    1. Let _elements_ be CreateArrayFromList(_g_.[[Elements]]).\n    1. Perform ! CreateDataPropertyOrThrow(_obj_, _g_.[[Key]], _elements_).\n  1. Return _obj_.","code":"\n          1. Let _groups_ be ? GroupBy(_items_, _callbackfn_, ~property~).\n          1. Let _obj_ be OrdinaryObjectCreate(*null*).\n          1. For each Record { [[Key]], [[Elements]] } _g_ of _groups_, do\n            1. Let _elements_ be CreateArrayFromList(_g_.[[Elements]]).\n            1. Perform ! CreateDataPropertyOrThrow(_obj_, _g_.[[Key]], _elements_).\n          1. Return _obj_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"hasOwn"}},"params":[{"name":"O","ty":"Unknown","kind":{"Normal":{}}},{"name":"P","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _obj_ be ? ToObject(_O_).\n  1. Let _key_ be ? ToPropertyKey(_P_).\n  1. Return ? HasOwnProperty(_obj_, _key_).","code":"\n          1. Let _obj_ be ? ToObject(_O_).\n          1. Let _key_ be ? ToPropertyKey(_P_).\n          1. Return ? HasOwnProperty(_obj_, _key_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"is"}},"params":[{"name":"value1","ty":"Unknown","kind":{"Normal":{}}},{"name":"value2","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Return SameValue(_value1_, _value2_).","code":"\n          1. Return SameValue(_value1_, _value2_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"isExtensible"}},"params":[{"name":"O","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If _O_ is not a Record[Object], return *false*.\n  1. Return ? IsExtensible(_O_).","code":"\n          1. If _O_ is not an Object, return *false*.\n          1. Return ? IsExtensible(_O_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"isFrozen"}},"params":[{"name":"O","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If _O_ is not a Record[Object], return *true*.\n  1. Return ? TestIntegrityLevel(_O_, ~frozen~).","code":"\n          1. If _O_ is not an Object, return *true*.\n          1. Return ? TestIntegrityLevel(_O_, ~frozen~).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"isSealed"}},"params":[{"name":"O","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If _O_ is not a Record[Object], return *true*.\n  1. Return ? TestIntegrityLevel(_O_, ~sealed~).","code":"\n          1. If _O_ is not an Object, return *true*.\n          1. Return ? TestIntegrityLevel(_O_, ~sealed~).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"keys"}},"params":[{"name":"O","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _obj_ be ? ToObject(_O_).\n  1. Let _keyList_ be ? EnumerableOwnProperties(_obj_, ~key~).\n  1. Return CreateArrayFromList(_keyList_).","code":"\n          1. Let _obj_ be ? ToObject(_O_).\n          1. Let _keyList_ be ? EnumerableOwnProperties(_obj_, ~key~).\n          1. Return CreateArrayFromList(_keyList_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"preventExtensions"}},"params":[{"name":"O","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If _O_ is not a Record[Object], return _O_.\n  1. Let _status_ be ? _O_.[[PreventExtensions]]().\n  1. If _status_ is *false*, throw a *TypeError* exception.\n  1. Return _O_.","code":"\n          1. If _O_ is not an Object, return _O_.\n          1. Let _status_ be ? <emu-meta effects=\"user-code\">_O_.[[PreventExtensions]]()</emu-meta>.\n          1. If _status_ is *false*, throw a *TypeError* exception.\n          1. Return _O_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"seal"}},"params":[{"name":"O","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If _O_ is not a Record[Object], return _O_.\n  1. Let _status_ be ? SetIntegrityLevel(_O_, ~sealed~).\n  1. If _status_ is *false*, throw a *TypeError* exception.\n  1. Return _O_.","code":"\n          1. If _O_ is not an Object, return _O_.\n          1. Let _status_ be ? SetIntegrityLevel(_O_, ~sealed~).\n          1. If _status_ is *false*, throw a *TypeError* exception.\n          1. Return _O_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"setPrototypeOf"}},"params":[{"name":"O","ty":"Unknown","kind":{"Normal":{}}},{"name":"proto","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Set _O_ to ? RequireObjectCoercible(_O_).\n  1. If _proto_ is not a Record[Object] and _proto_ is not *null*, throw a *TypeError* exception.\n  1. If _O_ is not a Record[Object], return _O_.\n  1. Let _status_ be ? _O_.[[SetPrototypeOf]](_proto_).\n  1. If _status_ is *false*, throw a *TypeError* exception.\n  1. Return _O_.","code":"\n          1. Set _O_ to ? RequireObjectCoercible(_O_).\n          1. If _proto_ is not an Object and _proto_ is not *null*, throw a *TypeError* exception.\n          1. If _O_ is not an Object, return _O_.\n          1. Let _status_ be ? <emu-meta effects=\"user-code\">_O_.[[SetPrototypeOf]]</emu-meta>(_proto_).\n          1. If _status_ is *false*, throw a *TypeError* exception.\n          1. Return _O_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"values"}},"params":[{"name":"O","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _obj_ be ? ToObject(_O_).\n  1. Let _valueList_ be ? EnumerableOwnProperties(_obj_, ~value~).\n  1. Return CreateArrayFromList(_valueList_).","code":"\n          1. Let _obj_ be ? ToObject(_O_).\n          1. Let _valueList_ be ? EnumerableOwnProperties(_obj_, ~value~).\n          1. Return CreateArrayFromList(_valueList_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"prototype"}},"name":"hasOwnProperty"}},"params":[{"name":"V","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. [id=\"step-hasownproperty-topropertykey\"] Let _P_ be ? ToPropertyKey(_V_).\n  1. [id=\"step-hasownproperty-toobject\"] Let _O_ be ? ToObject(*this* value).\n  1. Return ? HasOwnProperty(_O_, _P_).","code":"\n          1. [id=\"step-hasownproperty-topropertykey\"] Let _P_ be ? ToPropertyKey(_V_).\n          1. [id=\"step-hasownproperty-toobject\"] Let _O_ be ? ToObject(*this* value).\n          1. Return ? HasOwnProperty(_O_, _P_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"prototype"}},"name":"isPrototypeOf"}},"params":[{"name":"V","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. [id=\"step-isprototypeof-check-object\"] If _V_ is not a Record[Object], return *false*.\n  1. [id=\"step-isprototypeof-toobject\"] Let _O_ be ? ToObject(*this* value).\n  1. Repeat, \n    1. Set _V_ to ? _V_.[[GetPrototypeOf]]().\n    1. If _V_ is *null*, return *false*.\n    1. If SameValue(_O_, _V_) is *true*, return *true*.","code":"\n          1. [id=\"step-isprototypeof-check-object\"] If _V_ is not an Object, return *false*.\n          1. [id=\"step-isprototypeof-toobject\"] Let _O_ be ? ToObject(*this* value).\n          1. Repeat,\n            1. Set _V_ to ? <emu-meta effects=\"user-code\">_V_.[[GetPrototypeOf]]()</emu-meta>.\n            1. If _V_ is *null*, return *false*.\n            1. If SameValue(_O_, _V_) is *true*, return *true*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"prototype"}},"name":"propertyIsEnumerable"}},"params":[{"name":"V","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. [id=\"step-propertyisenumerable-topropertykey\"] Let _P_ be ? ToPropertyKey(_V_).\n  1. [id=\"step-propertyisenumerable-toobject\"] Let _O_ be ? ToObject(*this* value).\n  1. Let _desc_ be ? _O_.[[GetOwnProperty]](_P_).\n  1. If _desc_ is *undefined*, return *false*.\n  1. Return _desc_.[[Enumerable]].","code":"\n          1. [id=\"step-propertyisenumerable-topropertykey\"] Let _P_ be ? ToPropertyKey(_V_).\n          1. [id=\"step-propertyisenumerable-toobject\"] Let _O_ be ? ToObject(*this* value).\n          1. Let _desc_ be ? <emu-meta effects=\"user-code\">_O_.[[GetOwnProperty]]</emu-meta>(_P_).\n          1. If _desc_ is *undefined*, return *false*.\n          1. Return _desc_.[[Enumerable]].\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"prototype"}},"name":"toLocaleString"}},"params":[{"name":"reserved1","ty":"Unknown","kind":{"Optional":{}}},{"name":"reserved2","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Return ? Invoke(_O_, *\"toString\"*).","code":"\n          1. Let _O_ be the *this* value.\n          1. Return ? Invoke(_O_, *\"toString\"*).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"prototype"}},"name":"toString"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. If *this* value is *undefined*, return *\"[object Undefined]\"*.\n  1. If *this* value is *null*, return *\"[object Null]\"*.\n  1. Let _O_ be ! ToObject(*this* value).\n  1. Let _isArray_ be ? IsArray(_O_).\n  1. If _isArray_ is *true*, let _builtinTag_ be *\"Array\"*.\n  1. Else if _O_ has a [[ParameterMap]] internal slot, let _builtinTag_ be *\"Arguments\"*.\n  1. Else if _O_ has a [[Call]] internal slot, let _builtinTag_ be *\"Function\"*.\n  1. Else if _O_ has a [[ErrorData]] internal slot, let _builtinTag_ be *\"Error\"*.\n  1. Else if _O_ has a [[BooleanData]] internal slot, let _builtinTag_ be *\"Boolean\"*.\n  1. Else if _O_ has a [[NumberData]] internal slot, let _builtinTag_ be *\"Number\"*.\n  1. Else if _O_ has a [[StringData]] internal slot, let _builtinTag_ be *\"String\"*.\n  1. Else if _O_ has a [[DateValue]] internal slot, let _builtinTag_ be *\"Date\"*.\n  1. Else if _O_ has a [[RegExpMatcher]] internal slot, let _builtinTag_ be *\"RegExp\"*.\n  1. Else, let _builtinTag_ be *\"Object\"*.\n  1. Let _tag_ be ? Get(_O_, @@toStringTag).\n  1. If _tag_ is not a String, set _tag_ to _builtinTag_.\n  1. Return the string-concatenation of *\"[object \"*, _tag_, and *\"]\"*.","code":"\n          1. If the *this* value is *undefined*, return *\"[object Undefined]\"*.\n          1. If the *this* value is *null*, return *\"[object Null]\"*.\n          1. Let _O_ be ! ToObject(*this* value).\n          1. Let _isArray_ be ? IsArray(_O_).\n          1. If _isArray_ is *true*, let _builtinTag_ be *\"Array\"*.\n          1. Else if _O_ has a [[ParameterMap]] internal slot, let _builtinTag_ be *\"Arguments\"*.\n          1. Else if _O_ has a [[Call]] internal method, let _builtinTag_ be *\"Function\"*.\n          1. Else if _O_ has an [[ErrorData]] internal slot, let _builtinTag_ be *\"Error\"*.\n          1. Else if _O_ has a [[BooleanData]] internal slot, let _builtinTag_ be *\"Boolean\"*.\n          1. Else if _O_ has a [[NumberData]] internal slot, let _builtinTag_ be *\"Number\"*.\n          1. Else if _O_ has a [[StringData]] internal slot, let _builtinTag_ be *\"String\"*.\n          1. Else if _O_ has a [[DateValue]] internal slot, let _builtinTag_ be *\"Date\"*.\n          1. Else if _O_ has a [[RegExpMatcher]] internal slot, let _builtinTag_ be *\"RegExp\"*.\n          1. Else, let _builtinTag_ be *\"Object\"*.\n          1. Let _tag_ be ? Get(_O_, @@toStringTag).\n          1. If _tag_ is not a String, set _tag_ to _builtinTag_.\n          1. Return the string-concatenation of *\"[object \"*, _tag_, and *\"]\"*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"prototype"}},"name":"valueOf"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Return ? ToObject(*this* value).","code":"\n          1. Return ? ToObject(*this* value).\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"prototype"}},"name":"__proto__"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Return ? _O_.[[GetPrototypeOf]]().","code":"\n            1. Let _O_ be ? ToObject(*this* value).\n            1. Return ? <emu-meta effects=\"user-code\">_O_.[[GetPrototypeOf]]()</emu-meta>.\n          "},{"head":{"BuiltinHead":{"path":{"Setter":{"base":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"prototype"}},"name":"__proto__"}}}},"params":[{"name":"proto","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? RequireObjectCoercible(*this* value).\n  1. If _proto_ is not a Record[Object] and _proto_ is not *null*, return *undefined*.\n  1. If _O_ is not a Record[Object], return *undefined*.\n  1. Let _status_ be ? _O_.[[SetPrototypeOf]](_proto_).\n  1. If _status_ is *false*, throw a *TypeError* exception.\n  1. Return *undefined*.","code":"\n            1. Let _O_ be ? RequireObjectCoercible(*this* value).\n            1. If _proto_ is not an Object and _proto_ is not *null*, return *undefined*.\n            1. If _O_ is not an Object, return *undefined*.\n            1. Let _status_ be ? <emu-meta effects=\"user-code\">_O_.[[SetPrototypeOf]]</emu-meta>(_proto_).\n            1. If _status_ is *false*, throw a *TypeError* exception.\n            1. Return *undefined*.\n          "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"prototype"}},"name":"__defineGetter__"}},"params":[{"name":"P","ty":"Unknown","kind":{"Normal":{}}},{"name":"getter","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. If IsCallable(_getter_) is *false*, throw a *TypeError* exception.\n  1. Let _desc_ be PropertyDescriptor { [[Get]]: _getter_, [[Enumerable]]: *true*, [[Configurable]]: *true* }.\n  1. Let _key_ be ? ToPropertyKey(_P_).\n  1. Perform ? DefinePropertyOrThrow(_O_, _key_, _desc_).\n  1. Return *undefined*.","code":"\n            1. Let _O_ be ? ToObject(*this* value).\n            1. If IsCallable(_getter_) is *false*, throw a *TypeError* exception.\n            1. Let _desc_ be PropertyDescriptor { [[Get]]: _getter_, [[Enumerable]]: *true*, [[Configurable]]: *true* }.\n            1. Let _key_ be ? ToPropertyKey(_P_).\n            1. Perform ? DefinePropertyOrThrow(_O_, _key_, _desc_).\n            1. Return *undefined*.\n          "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"prototype"}},"name":"__defineSetter__"}},"params":[{"name":"P","ty":"Unknown","kind":{"Normal":{}}},{"name":"setter","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. If IsCallable(_setter_) is *false*, throw a *TypeError* exception.\n  1. Let _desc_ be PropertyDescriptor { [[Set]]: _setter_, [[Enumerable]]: *true*, [[Configurable]]: *true* }.\n  1. Let _key_ be ? ToPropertyKey(_P_).\n  1. Perform ? DefinePropertyOrThrow(_O_, _key_, _desc_).\n  1. Return *undefined*.","code":"\n            1. Let _O_ be ? ToObject(*this* value).\n            1. If IsCallable(_setter_) is *false*, throw a *TypeError* exception.\n            1. Let _desc_ be PropertyDescriptor { [[Set]]: _setter_, [[Enumerable]]: *true*, [[Configurable]]: *true* }.\n            1. Let _key_ be ? ToPropertyKey(_P_).\n            1. Perform ? DefinePropertyOrThrow(_O_, _key_, _desc_).\n            1. Return *undefined*.\n          "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"prototype"}},"name":"__lookupGetter__"}},"params":[{"name":"P","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _key_ be ? ToPropertyKey(_P_).\n  1. Repeat, \n    1. Let _desc_ be ? _O_.[[GetOwnProperty]](_key_).\n    1. If _desc_ is not *undefined*, then\n      1. If IsAccessorDescriptor(_desc_) is *true*, return _desc_.[[Get]].\n      1. Return *undefined*.\n    1. Set _O_ to ? _O_.[[GetPrototypeOf]]().\n    1. If _O_ is *null*, return *undefined*.","code":"\n            1. Let _O_ be ? ToObject(*this* value).\n            1. Let _key_ be ? ToPropertyKey(_P_).\n            1. Repeat,\n              1. Let _desc_ be ? <emu-meta effects=\"user-code\">_O_.[[GetOwnProperty]]</emu-meta>(_key_).\n              1. If _desc_ is not *undefined*, then\n                1. If IsAccessorDescriptor(_desc_) is *true*, return _desc_.[[Get]].\n                1. Return *undefined*.\n              1. Set _O_ to ? <emu-meta effects=\"user-code\">_O_.[[GetPrototypeOf]]()</emu-meta>.\n              1. If _O_ is *null*, return *undefined*.\n          "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Object"}},"name":"prototype"}},"name":"__lookupSetter__"}},"params":[{"name":"P","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _key_ be ? ToPropertyKey(_P_).\n  1. Repeat, \n    1. Let _desc_ be ? _O_.[[GetOwnProperty]](_key_).\n    1. If _desc_ is not *undefined*, then\n      1. If IsAccessorDescriptor(_desc_) is *true*, return _desc_.[[Set]].\n      1. Return *undefined*.\n    1. Set _O_ to ? _O_.[[GetPrototypeOf]]().\n    1. If _O_ is *null*, return *undefined*.","code":"\n            1. Let _O_ be ? ToObject(*this* value).\n            1. Let _key_ be ? ToPropertyKey(_P_).\n            1. Repeat,\n              1. Let _desc_ be ? <emu-meta effects=\"user-code\">_O_.[[GetOwnProperty]]</emu-meta>(_key_).\n              1. If _desc_ is not *undefined*, then\n                1. If IsAccessorDescriptor(_desc_) is *true*, return _desc_.[[Set]].\n                1. Return *undefined*.\n              1. Set _O_ to ? <emu-meta effects=\"user-code\">_O_.[[GetPrototypeOf]]()</emu-meta>.\n              1. If _O_ is *null*, return *undefined*.\n          "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"Function"}},"params":[{"name":"parameterArgs","ty":"Unknown","kind":{"Variadic":{}}},{"name":"bodyArg","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _C_ be the active function object.\n  1. If _bodyArg_ is not present, set _bodyArg_ to *\"\"*.\n  1. Return ? CreateDynamicFunction(_C_, NewTarget, ~normal~, _parameterArgs_, _bodyArg_).","code":"\n          1. Let _C_ be the active function object.\n          1. If _bodyArg_ is not present, set _bodyArg_ to the empty String.\n          1. Return ? CreateDynamicFunction(_C_, NewTarget, ~normal~, _parameterArgs_, _bodyArg_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CreateDynamicFunction","params":[{"name":"constructor","ty":"Record[Constructor]","kind":{"Normal":{}}},{"name":"newTarget","ty":"Record[Constructor]","kind":{"Normal":{}}},{"name":"kind","ty":"Enum[~async-generator~, ~async~, ~generator~, ~normal~]","kind":{"Normal":{}}},{"name":"parameterArgs","ty":"List[ESValue]","kind":{"Normal":{}}},{"name":"bodyArg","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Record[ECMAScriptFunctionObject]] | Throw"}},"body":"\n  1. If _newTarget_ is *undefined*, set _newTarget_ to _constructor_.\n  1. If _kind_ is ~normal~, then\n    1. Let _prefix_ be *\"function\"*.\n    1. Let _exprSym_ be the grammar symbol |FunctionExpression|.\n    1. Let _bodySym_ be the grammar symbol |FunctionBody[~Yield, ~Await]|.\n    1. Let _parameterSym_ be the grammar symbol |FormalParameters[~Yield, ~Await]|.\n    1. Let _fallbackProto_ be *\"%Function.prototype%\"*.\n  1. Else if _kind_ is ~generator~, then\n    1. Let _prefix_ be *\"function\\*\"*.\n    1. Let _exprSym_ be the grammar symbol |GeneratorExpression|.\n    1. Let _bodySym_ be the grammar symbol |GeneratorBody|.\n    1. Let _parameterSym_ be the grammar symbol |FormalParameters[+Yield, ~Await]|.\n    1. Let _fallbackProto_ be *\"%GeneratorFunction.prototype%\"*.\n  1. Else if _kind_ is ~async~, then\n    1. Let _prefix_ be *\"async function\"*.\n    1. Let _exprSym_ be the grammar symbol |AsyncFunctionExpression|.\n    1. Let _bodySym_ be the grammar symbol |AsyncFunctionBody|.\n    1. Let _parameterSym_ be the grammar symbol |FormalParameters[~Yield, +Await]|.\n    1. Let _fallbackProto_ be *\"%AsyncFunction.prototype%\"*.\n  1. Else,\n    1. Assert: _kind_ is ~async-generator~.\n    1. Let _prefix_ be *\"async function\\*\"*.\n    1. Let _exprSym_ be the grammar symbol |AsyncGeneratorExpression|.\n    1. Let _bodySym_ be the grammar symbol |AsyncGeneratorBody|.\n    1. Let _parameterSym_ be the grammar symbol |FormalParameters[+Yield, +Await]|.\n    1. Let _fallbackProto_ be *\"%AsyncGeneratorFunction.prototype%\"*.\n  1. Let _argCount_ be the number of elements in _parameterArgs_.\n  1. Let _parameterStrings_ be « ».\n  1. For each _arg_ of _parameterArgs_, do\n    1. Append ? ToString(_arg_) to _parameterStrings_.\n  1. Let _bodyString_ be ? ToString(_bodyArg_).\n  1. Let _currentRealm_ be the current Realm Record.\n  1. Perform ? HostEnsureCanCompileStrings(_currentRealm_, _parameterStrings_, _bodyString_, *false*).\n  1. Let _P_ be *\"\"*.\n  1. If _argCount_ > 0, then\n    1. Set _P_ to _parameterStrings_[0].\n    1. Let _k_ be 1.\n    1. Repeat, while _k_ < _argCount_,\n      1. Let _nextArgString_ be _parameterStrings_[_k_].\n      1. Set _P_ to the string-concatenation of _P_, *\",\"*, and _nextArgString_.\n      1. Set _k_ to _k_ + 1.\n  1. Let _bodyParseString_ be the string-concatenation of 0x000a (LINE FEED), _bodyString_, and 0x000a (LINE FEED).\n  1. Let _sourceString_ be the string-concatenation of _prefix_, *\" anonymous(\"*, _P_, 0x000a (LINE FEED), *\") {\"*, _bodyParseString_, and *\"}\"*.\n  1. Let _sourceText_ be StringToCodePoints(_sourceString_).\n  1. Let _parameters_ be ParseText(StringToCodePoints(_P_), _parameterSym_).\n  1. If _parameters_ is a List[Record[Error]], throw a *SyntaxError* exception.\n  1. Let _body_ be ParseText(StringToCodePoints(_bodyParseString_), _bodySym_).\n  1. If _body_ is a List[Record[Error]], throw a *SyntaxError* exception.\n  1. NOTE: The parameters and body are parsed separately to ensure that each is valid alone. For example, `new Function(\"/*\", \"*/ ) {\")` does not evaluate to a function.\n  1. NOTE: If this step is reached, _sourceText_ must have the syntax of _exprSym_ (although the reverse implication does not hold). The purpose of the next two steps is to enforce any Early Error rules which apply to _exprSym_ directly.\n  1. Let _expr_ be ParseText(_sourceText_, _exprSym_).\n  1. If _expr_ is a List[Record[Error]], throw a *SyntaxError* exception.\n  1. Let _proto_ be ? GetPrototypeFromConstructor(_newTarget_, _fallbackProto_).\n  1. Let _env_ be _currentRealm_.[[GlobalEnv]].\n  1. Let _privateEnv_ be *null*.\n  1. Let _F_ be OrdinaryFunctionCreate(_proto_, _sourceText_, _parameters_, _body_, ~non-lexical-this~, _env_, _privateEnv_).\n  1. Perform SetFunctionName(_F_, *\"anonymous\"*).\n  1. If _kind_ is ~generator~, then\n    1. Let _prototype_ be OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).\n    1. Perform ! DefinePropertyOrThrow(_F_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n  1. Else if _kind_ is ~async-generator~, then\n    1. Let _prototype_ be OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).\n    1. Perform ! DefinePropertyOrThrow(_F_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n  1. Else if _kind_ is ~normal~, then\n    1. Perform MakeConstructor(_F_).\n  1. NOTE: Functions whose _kind_ is ~async~ are not constructible and do not have a [[Construct]] internal method or a *\"prototype\"* property.\n  1. Return _F_.","code":"\n            1. If _newTarget_ is *undefined*, set _newTarget_ to _constructor_.\n            1. If _kind_ is ~normal~, then\n              1. Let _prefix_ be *\"function\"*.\n              1. Let _exprSym_ be the grammar symbol |FunctionExpression|.\n              1. Let _bodySym_ be the grammar symbol |FunctionBody[~Yield, ~Await]|.\n              1. Let _parameterSym_ be the grammar symbol |FormalParameters[~Yield, ~Await]|.\n              1. Let _fallbackProto_ be *\"%Function.prototype%\"*.\n            1. Else if _kind_ is ~generator~, then\n              1. Let _prefix_ be *\"function\\*\"*.\n              1. Let _exprSym_ be the grammar symbol |GeneratorExpression|.\n              1. Let _bodySym_ be the grammar symbol |GeneratorBody|.\n              1. Let _parameterSym_ be the grammar symbol |FormalParameters[+Yield, ~Await]|.\n              1. Let _fallbackProto_ be *\"%GeneratorFunction.prototype%\"*.\n            1. Else if _kind_ is ~async~, then\n              1. Let _prefix_ be *\"async function\"*.\n              1. Let _exprSym_ be the grammar symbol |AsyncFunctionExpression|.\n              1. Let _bodySym_ be the grammar symbol |AsyncFunctionBody|.\n              1. Let _parameterSym_ be the grammar symbol |FormalParameters[~Yield, +Await]|.\n              1. Let _fallbackProto_ be *\"%AsyncFunction.prototype%\"*.\n            1. Else,\n              1. Assert: _kind_ is ~async-generator~.\n              1. Let _prefix_ be *\"async function\\*\"*.\n              1. Let _exprSym_ be the grammar symbol |AsyncGeneratorExpression|.\n              1. Let _bodySym_ be the grammar symbol |AsyncGeneratorBody|.\n              1. Let _parameterSym_ be the grammar symbol |FormalParameters[+Yield, +Await]|.\n              1. Let _fallbackProto_ be *\"%AsyncGeneratorFunction.prototype%\"*.\n            1. Let _argCount_ be the number of elements in _parameterArgs_.\n            1. Let _parameterStrings_ be a new empty List.\n            1. For each element _arg_ of _parameterArgs_, do\n              1. Append ? ToString(_arg_) to _parameterStrings_.\n            1. Let _bodyString_ be ? ToString(_bodyArg_).\n            1. Let _currentRealm_ be the current Realm Record.\n            1. Perform ? HostEnsureCanCompileStrings(_currentRealm_, _parameterStrings_, _bodyString_, *false*).\n            1. Let _P_ be the empty String.\n            1. If _argCount_ > 0, then\n              1. Set _P_ to _parameterStrings_[0].\n              1. Let _k_ be 1.\n              1. Repeat, while _k_ < _argCount_,\n                1. Let _nextArgString_ be _parameterStrings_[_k_].\n                1. Set _P_ to the string-concatenation of _P_, *\",\"* (a comma), and _nextArgString_.\n                1. Set _k_ to _k_ + 1.\n            1. Let _bodyParseString_ be the string-concatenation of 0x000A (LINE FEED), _bodyString_, and 0x000A (LINE FEED).\n            1. Let _sourceString_ be the string-concatenation of _prefix_, *\" anonymous(\"*, _P_, 0x000A (LINE FEED), *\") {\"*, _bodyParseString_, and *\"}\"*.\n            1. Let _sourceText_ be StringToCodePoints(_sourceString_).\n            1. Let _parameters_ be ParseText(StringToCodePoints(_P_), _parameterSym_).\n            1. If _parameters_ is a List of errors, throw a *SyntaxError* exception.\n            1. Let _body_ be ParseText(StringToCodePoints(_bodyParseString_), _bodySym_).\n            1. If _body_ is a List of errors, throw a *SyntaxError* exception.\n            1. NOTE: The parameters and body are parsed separately to ensure that each is valid alone. For example, `new Function(\"/*\", \"*/ ) {\")` does not evaluate to a function.\n            1. NOTE: If this step is reached, _sourceText_ must have the syntax of _exprSym_ (although the reverse implication does not hold). The purpose of the next two steps is to enforce any Early Error rules which apply to _exprSym_ directly.\n            1. Let _expr_ be ParseText(_sourceText_, _exprSym_).\n            1. If _expr_ is a List of errors, throw a *SyntaxError* exception.\n            1. Let _proto_ be ? GetPrototypeFromConstructor(_newTarget_, _fallbackProto_).\n            1. Let _env_ be _currentRealm_.[[GlobalEnv]].\n            1. Let _privateEnv_ be *null*.\n            1. Let _F_ be OrdinaryFunctionCreate(_proto_, _sourceText_, _parameters_, _body_, ~non-lexical-this~, _env_, _privateEnv_).\n            1. Perform SetFunctionName(_F_, *\"anonymous\"*).\n            1. If _kind_ is ~generator~, then\n              1. Let _prototype_ be OrdinaryObjectCreate(%GeneratorFunction.prototype.prototype%).\n              1. Perform ! DefinePropertyOrThrow(_F_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n            1. Else if _kind_ is ~async-generator~, then\n              1. Let _prototype_ be OrdinaryObjectCreate(%AsyncGeneratorFunction.prototype.prototype%).\n              1. Perform ! DefinePropertyOrThrow(_F_, *\"prototype\"*, PropertyDescriptor { [[Value]]: _prototype_, [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n            1. Else if _kind_ is ~normal~, then\n              1. Perform MakeConstructor(_F_).\n            1. NOTE: Functions whose _kind_ is ~async~ are not constructible and do not have a [[Construct]] internal method or a *\"prototype\"* property.\n            1. Return _F_.\n          "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Function"}},"name":"prototype"}},"name":"apply"}},"params":[{"name":"thisArg","ty":"Unknown","kind":{"Normal":{}}},{"name":"argArray","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _func_ be *this* value.\n  1. If IsCallable(_func_) is *false*, throw a *TypeError* exception.\n  1. If _argArray_ is either *undefined* or *null*, then\n    1. Perform PrepareForTailCall().\n    1. Return ? Call(_func_, _thisArg_).\n  1. Let _argList_ be ? CreateListFromArrayLike(_argArray_).\n  1. Perform PrepareForTailCall().\n  1. [id=\"step-function-proto-apply-call\"] Return ? Call(_func_, _thisArg_, _argList_).","code":"\n          1. Let _func_ be the *this* value.\n          1. If IsCallable(_func_) is *false*, throw a *TypeError* exception.\n          1. If _argArray_ is either *undefined* or *null*, then\n            1. Perform PrepareForTailCall().\n            1. Return ? Call(_func_, _thisArg_).\n          1. Let _argList_ be ? CreateListFromArrayLike(_argArray_).\n          1. Perform PrepareForTailCall().\n          1. [id=\"step-function-proto-apply-call\"] Return ? Call(_func_, _thisArg_, _argList_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Function"}},"name":"prototype"}},"name":"bind"}},"params":[{"name":"thisArg","ty":"Unknown","kind":{"Normal":{}}},{"name":"args","ty":"Unknown","kind":{"Variadic":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _Target_ be *this* value.\n  1. If IsCallable(_Target_) is *false*, throw a *TypeError* exception.\n  1. Let _F_ be ? BoundFunctionCreate(_Target_, _thisArg_, _args_).\n  1. Let _L_ be 0.\n  1. Let _targetHasLength_ be ? HasOwnProperty(_Target_, *\"length\"*).\n  1. If _targetHasLength_ is *true*, then\n    1. Let _targetLen_ be ? Get(_Target_, *\"length\"*).\n    1. If _targetLen_ is a Number, then\n      1. If _targetLen_ is *+∞*<sub>𝔽</sub>, then\n        1. Set _L_ to +∞.\n      1. Else if _targetLen_ is *-∞*<sub>𝔽</sub>, then\n        1. Set _L_ to 0.\n      1. Else,\n        1. Let _targetLenAsInt_ be ! ToIntegerOrInfinity(_targetLen_).\n        1. Assert: _targetLenAsInt_ is finite.\n        1. Let _argCount_ be the number of elements in _args_.\n        1. Set _L_ to max(_targetLenAsInt_ - _argCount_, 0).\n  1. Perform SetFunctionLength(_F_, _L_).\n  1. Let _targetName_ be ? Get(_Target_, *\"name\"*).\n  1. If _targetName_ is not a String, set _targetName_ to *\"\"*.\n  1. Perform SetFunctionName(_F_, _targetName_, *\"bound\"*).\n  1. Return _F_.","code":"\n          1. Let _Target_ be the *this* value.\n          1. If IsCallable(_Target_) is *false*, throw a *TypeError* exception.\n          1. Let _F_ be ? BoundFunctionCreate(_Target_, _thisArg_, _args_).\n          1. Let _L_ be 0.\n          1. Let _targetHasLength_ be ? HasOwnProperty(_Target_, *\"length\"*).\n          1. If _targetHasLength_ is *true*, then\n            1. Let _targetLen_ be ? Get(_Target_, *\"length\"*).\n            1. If _targetLen_ is a Number, then\n              1. If _targetLen_ is *+∞*<sub>𝔽</sub>, then\n                1. Set _L_ to +∞.\n              1. Else if _targetLen_ is *-∞*<sub>𝔽</sub>, then\n                1. Set _L_ to 0.\n              1. Else,\n                1. Let _targetLenAsInt_ be ! ToIntegerOrInfinity(_targetLen_).\n                1. Assert: _targetLenAsInt_ is finite.\n                1. Let _argCount_ be the number of elements in _args_.\n                1. Set _L_ to max(_targetLenAsInt_ - _argCount_, 0).\n          1. Perform SetFunctionLength(_F_, _L_).\n          1. Let _targetName_ be ? Get(_Target_, *\"name\"*).\n          1. If _targetName_ is not a String, set _targetName_ to the empty String.\n          1. Perform SetFunctionName(_F_, _targetName_, *\"bound\"*).\n          1. Return _F_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Function"}},"name":"prototype"}},"name":"call"}},"params":[{"name":"thisArg","ty":"Unknown","kind":{"Normal":{}}},{"name":"args","ty":"Unknown","kind":{"Variadic":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _func_ be *this* value.\n  1. If IsCallable(_func_) is *false*, throw a *TypeError* exception.\n  1. Perform PrepareForTailCall().\n  1. [id=\"step-function-proto-call-call\"] Return ? Call(_func_, _thisArg_, _args_).","code":"\n          1. Let _func_ be the *this* value.\n          1. If IsCallable(_func_) is *false*, throw a *TypeError* exception.\n          1. Perform PrepareForTailCall().\n          1. [id=\"step-function-proto-call-call\"] Return ? Call(_func_, _thisArg_, _args_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Function"}},"name":"prototype"}},"name":"toString"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _func_ be *this* value.\n  1. If _func_ is a Record[Object], _func_ has a [[SourceText]] internal slot, _func_.[[SourceText]] is a sequence of Unicode code points, and HostHasSourceTextAvailable(_func_) is *true*, then\n    1. Return CodePointsToString(_func_.[[SourceText]]).\n  1. If _func_ is a <emu-xref href=\"#sec-built-in-function-objects\">built-in function object</emu-xref>, return an implementation-defined String source code representation of _func_. The representation must have the syntax of a |NativeFunction|. Additionally, if _func_ has an [[InitialName]] internal slot and _func_.[[InitialName]] is a String, the portion of the returned String that would be matched by |NativeFunctionAccessor?| |PropertyName| must be the value of _func_.[[InitialName]].\n  1. If _func_ is a Record[Object] and IsCallable(_func_) is *true*, return an implementation-defined String source code representation of _func_. The representation must have the syntax of a |NativeFunction|.\n  1. Throw a *TypeError* exception.","code":"\n          1. Let _func_ be the *this* value.\n          1. If _func_ is an Object, _func_ has a [[SourceText]] internal slot, _func_.[[SourceText]] is a sequence of Unicode code points, and HostHasSourceTextAvailable(_func_) is *true*, then\n            1. Return CodePointsToString(_func_.[[SourceText]]).\n          1. If _func_ is a <emu-xref href=\"#sec-built-in-function-objects\">built-in function object</emu-xref>, return an implementation-defined String source code representation of _func_. The representation must have the syntax of a |NativeFunction|. Additionally, if _func_ has an [[InitialName]] internal slot and _func_.[[InitialName]] is a String, the portion of the returned String that would be matched by |NativeFunctionAccessor?| |PropertyName| must be the value of _func_.[[InitialName]].\n          1. If _func_ is an Object and IsCallable(_func_) is *true*, return an implementation-defined String source code representation of _func_. The representation must have the syntax of a |NativeFunction|.\n          1. Throw a *TypeError* exception.\n        "},{"head":{"BuiltinHead":{"path":{"SymbolAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Function"}},"name":"prototype"}},"symbol":"hasInstance"}},"params":[{"name":"V","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _F_ be *this* value.\n  1. Return ? OrdinaryHasInstance(_F_, _V_).","code":"\n          1. Let _F_ be the *this* value.\n          1. Return ? OrdinaryHasInstance(_F_, _V_).\n        "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"Boolean"}},"params":[{"name":"value","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _b_ be ToBoolean(_value_).\n  1. If NewTarget is *undefined*, return _b_.\n  1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Boolean.prototype%\"*, « [[BooleanData]] »).\n  1. Set _O_.[[BooleanData]] to _b_.\n  1. Return _O_.","code":"\n          1. Let _b_ be ToBoolean(_value_).\n          1. If NewTarget is *undefined*, return _b_.\n          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Boolean.prototype%\"*, « [[BooleanData]] »).\n          1. Set _O_.[[BooleanData]] to _b_.\n          1. Return _O_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Boolean"}},"name":"prototype"}},"name":"toString"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _b_ be ? ThisBooleanValue(*this* value).\n  1. If _b_ is *true*, return *\"true\"*.\n  1. Else, return *\"false\"*.","code":"\n          1. Let _b_ be ? ThisBooleanValue(*this* value).\n          1. If _b_ is *true*, return *\"true\"*; else return *\"false\"*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Boolean"}},"name":"prototype"}},"name":"valueOf"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Return ? ThisBooleanValue(*this* value).","code":"\n          1. Return ? ThisBooleanValue(*this* value).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ThisBooleanValue","params":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. If _value_ is a Boolean, return _value_.\n  1. If _value_ is a Record[Object] and _value_ has a [[BooleanData]] internal slot, then\n    1. Let _b_ be _value_.[[BooleanData]].\n    1. Assert: _b_ is a Boolean.\n    1. Return _b_.\n  1. Throw a *TypeError* exception.","code":"\n            1. If _value_ is a Boolean, return _value_.\n            1. If _value_ is an Object and _value_ has a [[BooleanData]] internal slot, then\n              1. Let _b_ be _value_.[[BooleanData]].\n              1. Assert: _b_ is a Boolean.\n              1. Return _b_.\n            1. Throw a *TypeError* exception.\n          "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"Symbol"}},"params":[{"name":"description","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. If NewTarget is not *undefined*, throw a *TypeError* exception.\n  1. If _description_ is *undefined*, let _descString_ be *undefined*.\n  1. Else, let _descString_ be ? ToString(_description_).\n  1. Return Symbol { [[Description]]: _descString_ }.","code":"\n          1. If NewTarget is not *undefined*, throw a *TypeError* exception.\n          1. If _description_ is *undefined*, let _descString_ be *undefined*.\n          1. Else, let _descString_ be ? ToString(_description_).\n          1. Return a new Symbol whose [[Description]] is _descString_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Symbol"}},"name":"for"}},"params":[{"name":"key","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _stringKey_ be ? ToString(_key_).\n  1. For each element _e_ of the GlobalSymbolRegistry List, do\n    1. If SameValue(_e_.[[Key]], _stringKey_) is *true*, return _e_.[[Symbol]].\n  1. Assert: GlobalSymbolRegistry does not currently contain an entry for _stringKey_..\n  1. Let _newSymbol_ be Symbol { [[Description]]: _stringKey_ }.\n  1. Append the Record { [[Key]]: _stringKey_, [[Symbol]]: _newSymbol_ } to the GlobalSymbolRegistry List.\n  1. Return _newSymbol_.","code":"\n          1. Let _stringKey_ be ? ToString(_key_).\n          1. For each element _e_ of the GlobalSymbolRegistry List, do\n            1. If SameValue(_e_.[[Key]], _stringKey_) is *true*, return _e_.[[Symbol]].\n          1. Assert: GlobalSymbolRegistry does not currently contain an entry for _stringKey_.\n          1. Let _newSymbol_ be a new Symbol whose [[Description]] is _stringKey_.\n          1. Append the Record { [[Key]]: _stringKey_, [[Symbol]]: _newSymbol_ } to the GlobalSymbolRegistry List.\n          1. Return _newSymbol_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Symbol"}},"name":"keyFor"}},"params":[{"name":"sym","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If _sym_ is not a Record[Symbol], throw a *TypeError* exception.\n  1. Return KeyForSymbol(_sym_).","code":"\n          1. If _sym_ is not a Symbol, throw a *TypeError* exception.\n          1. Return KeyForSymbol(_sym_).\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Symbol"}},"name":"prototype"}},"name":"description"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _s_ be *this* value.\n  1. Let _sym_ be ? ThisSymbolValue(_s_).\n  1. Return _sym_.[[Description]].","code":"\n          1. Let _s_ be the *this* value.\n          1. Let _sym_ be ? ThisSymbolValue(_s_).\n          1. Return _sym_.[[Description]].\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Symbol"}},"name":"prototype"}},"name":"toString"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _sym_ be ? ThisSymbolValue(*this* value).\n  1. Return SymbolDescriptiveString(_sym_).","code":"\n          1. Let _sym_ be ? ThisSymbolValue(*this* value).\n          1. Return SymbolDescriptiveString(_sym_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"SymbolDescriptiveString","params":[{"name":"sym","ty":"Record[Symbol]","kind":{"Normal":{}}}],"retTy":"String"}},"body":"\n  1. Let _desc_ be _sym_.[[Description]].\n  1. If _desc_ is *undefined*, set _desc_ to *\"\"*.\n  1. Assert: _desc_ is a String.\n  1. Return the string-concatenation of *\"Symbol(\"*, _desc_, and *\")\"*.","code":"\n            1. Let _desc_ be _sym_'s [[Description]] value.\n            1. If _desc_ is *undefined*, set _desc_ to the empty String.\n            1. Assert: _desc_ is a String.\n            1. Return the string-concatenation of *\"Symbol(\"*, _desc_, and *\")\"*.\n          "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Symbol"}},"name":"prototype"}},"name":"valueOf"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Return ? ThisSymbolValue(*this* value).","code":"\n          1. Return ? ThisSymbolValue(*this* value).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ThisSymbolValue","params":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Record[Symbol]] | Throw"}},"body":"\n  1. If _value_ is a Record[Symbol], return _value_.\n  1. If _value_ is a Record[Object] and _value_ has a [[SymbolData]] internal slot, then\n    1. Let _s_ be _value_.[[SymbolData]].\n    1. Assert: _s_ is a Record[Symbol].\n    1. Return _s_.\n  1. Throw a *TypeError* exception.","code":"\n            1. If _value_ is a Symbol, return _value_.\n            1. If _value_ is an Object and _value_ has a [[SymbolData]] internal slot, then\n              1. Let _s_ be _value_.[[SymbolData]].\n              1. Assert: _s_ is a Symbol.\n              1. Return _s_.\n            1. Throw a *TypeError* exception.\n          "},{"head":{"BuiltinHead":{"path":{"SymbolAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Symbol"}},"name":"prototype"}},"symbol":"toPrimitive"}},"params":[{"name":"hint","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Return ? ThisSymbolValue(*this* value).","code":"\n          1. Return ? ThisSymbolValue(*this* value).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"KeyForSymbol","params":[{"name":"sym","ty":"Record[Symbol]","kind":{"Normal":{}}}],"retTy":"String | Undefined"}},"body":"\n  1. For each element _e_ of the GlobalSymbolRegistry List, do\n    1. If SameValue(_e_.[[Symbol]], _sym_) is *true*, return _e_.[[Key]].\n  1. Assert: GlobalSymbolRegistry does not currently contain an entry for _sym_..\n  1. Return *undefined*.","code":"\n          1. For each element _e_ of the GlobalSymbolRegistry List, do\n            1. If SameValue(_e_.[[Symbol]], _sym_) is *true*, return _e_.[[Key]].\n          1. Assert: GlobalSymbolRegistry does not currently contain an entry for _sym_.\n          1. Return *undefined*.\n        "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"Error"}},"params":[{"name":"message","ty":"Unknown","kind":{"Normal":{}}},{"name":"options","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. If NewTarget is *undefined*, let _newTarget_ be the active function object.\n  1. Else, let _newTarget_ be NewTarget.\n  1. Let _O_ be ? OrdinaryCreateFromConstructor(_newTarget_, *\"%Error.prototype%\"*, « [[ErrorData]] »).\n  1. If _message_ is not *undefined*, then\n    1. Let _msg_ be ? ToString(_message_).\n    1. Perform CreateNonEnumerableDataPropertyOrThrow(_O_, *\"message\"*, _msg_).\n  1. Perform ? InstallErrorCause(_O_, _options_).\n  1. Return _O_.","code":"\n          1. If NewTarget is *undefined*, let _newTarget_ be the active function object; else let _newTarget_ be NewTarget.\n          1. Let _O_ be ? OrdinaryCreateFromConstructor(_newTarget_, *\"%Error.prototype%\"*, « [[ErrorData]] »).\n          1. If _message_ is not *undefined*, then\n            1. Let _msg_ be ? ToString(_message_).\n            1. Perform CreateNonEnumerableDataPropertyOrThrow(_O_, *\"message\"*, _msg_).\n          1. Perform ? InstallErrorCause(_O_, _options_).\n          1. Return _O_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Error"}},"name":"prototype"}},"name":"toString"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. If _O_ is not a Record[Object], throw a *TypeError* exception.\n  1. Let _name_ be ? Get(_O_, *\"name\"*).\n  1. If _name_ is *undefined*, set _name_ to *\"Error\"*.\n  1. Else, set _name_ to ? ToString(_name_).\n  1. Let _msg_ be ? Get(_O_, *\"message\"*).\n  1. If _msg_ is *undefined*, set _msg_ to *\"\"*.\n  1. Else, set _msg_ to ? ToString(_msg_).\n  1. If _name_ is *\"\"*, return _msg_.\n  1. If _msg_ is *\"\"*, return _name_.\n  1. Return the string-concatenation of _name_, 0x003a (COLON), 0x0020 (SPACE), and _msg_.","code":"\n          1. Let _O_ be the *this* value.\n          1. If _O_ is not an Object, throw a *TypeError* exception.\n          1. Let _name_ be ? Get(_O_, *\"name\"*).\n          1. If _name_ is *undefined*, set _name_ to *\"Error\"*; otherwise set _name_ to ? ToString(_name_).\n          1. Let _msg_ be ? Get(_O_, *\"message\"*).\n          1. If _msg_ is *undefined*, set _msg_ to the empty String; otherwise set _msg_ to ? ToString(_msg_).\n          1. If _name_ is the empty String, return _msg_.\n          1. If _msg_ is the empty String, return _name_.\n          1. Return the string-concatenation of _name_, the code unit 0x003A (COLON), the code unit 0x0020 (SPACE), and _msg_.\n        "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"_NativeError_"}},"params":[{"name":"message","ty":"Unknown","kind":{"Normal":{}}},{"name":"options","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. If NewTarget is *undefined*, let _newTarget_ be the active function object.\n  1. Else, let _newTarget_ be NewTarget.\n  1. [id=\"step-nativerror-ordinarycreatefromconstructor\"] Let _O_ be ? OrdinaryCreateFromConstructor(_newTarget_, <code>\"%<var>NativeError</var>.prototype%\"</code>, « [[ErrorData]] »).\n  1. If _message_ is not *undefined*, then\n    1. Let _msg_ be ? ToString(_message_).\n    1. Perform CreateNonEnumerableDataPropertyOrThrow(_O_, *\"message\"*, _msg_).\n  1. Perform ? InstallErrorCause(_O_, _options_).\n  1. Return _O_.","code":"\n            1. If NewTarget is *undefined*, let _newTarget_ be the active function object; else let _newTarget_ be NewTarget.\n            1. [id=\"step-nativerror-ordinarycreatefromconstructor\"] Let _O_ be ? OrdinaryCreateFromConstructor(_newTarget_, <code>\"%<var>NativeError</var>.prototype%\"</code>, « [[ErrorData]] »).\n            1. If _message_ is not *undefined*, then\n              1. Let _msg_ be ? ToString(_message_).\n              1. Perform CreateNonEnumerableDataPropertyOrThrow(_O_, *\"message\"*, _msg_).\n            1. Perform ? InstallErrorCause(_O_, _options_).\n            1. Return _O_.\n          "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"AggregateError"}},"params":[{"name":"errors","ty":"Unknown","kind":{"Normal":{}}},{"name":"message","ty":"Unknown","kind":{"Normal":{}}},{"name":"options","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. If NewTarget is *undefined*, let _newTarget_ be the active function object.\n  1. Else, let _newTarget_ be NewTarget.\n  1. Let _O_ be ? OrdinaryCreateFromConstructor(_newTarget_, *\"%AggregateError.prototype%\"*, « [[ErrorData]] »).\n  1. If _message_ is not *undefined*, then\n    1. Let _msg_ be ? ToString(_message_).\n    1. Perform CreateNonEnumerableDataPropertyOrThrow(_O_, *\"message\"*, _msg_).\n  1. Perform ? InstallErrorCause(_O_, _options_).\n  1. Let _errorsList_ be ? IteratorToList(? GetIterator(_errors_, ~sync~)).\n  1. Perform ! DefinePropertyOrThrow(_O_, *\"errors\"*, PropertyDescriptor { [[Configurable]]: *true*, [[Enumerable]]: *false*, [[Writable]]: *true*, [[Value]]: CreateArrayFromList(_errorsList_) }).\n  1. Return _O_.","code":"\n            1. If NewTarget is *undefined*, let _newTarget_ be the active function object; else let _newTarget_ be NewTarget.\n            1. Let _O_ be ? OrdinaryCreateFromConstructor(_newTarget_, *\"%AggregateError.prototype%\"*, « [[ErrorData]] »).\n            1. If _message_ is not *undefined*, then\n              1. Let _msg_ be ? ToString(_message_).\n              1. Perform CreateNonEnumerableDataPropertyOrThrow(_O_, *\"message\"*, _msg_).\n            1. Perform ? InstallErrorCause(_O_, _options_).\n            1. Let _errorsList_ be ? IteratorToList(? GetIterator(_errors_, ~sync~)).\n            1. Perform ! DefinePropertyOrThrow(_O_, *\"errors\"*, PropertyDescriptor { [[Configurable]]: *true*, [[Enumerable]]: *false*, [[Writable]]: *true*, [[Value]]: CreateArrayFromList(_errorsList_) }).\n            1. Return _O_.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"InstallErrorCause","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"options","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. If _options_ is a Record[Object] and ? HasProperty(_options_, *\"cause\"*) is *true*, then\n    1. Let _cause_ be ? Get(_options_, *\"cause\"*).\n    1. Perform CreateNonEnumerableDataPropertyOrThrow(_O_, *\"cause\"*, _cause_).\n  1. Return ~unused~.","code":"\n          1. If _options_ is an Object and ? HasProperty(_options_, *\"cause\"*) is *true*, then\n            1. Let _cause_ be ? Get(_options_, *\"cause\"*).\n            1. Perform CreateNonEnumerableDataPropertyOrThrow(_O_, *\"cause\"*, _cause_).\n          1. Return ~unused~.\n        "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"Number"}},"params":[{"name":"value","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If _value_ is present, then\n    1. Let _prim_ be ? ToNumeric(_value_).\n    1. If _prim_ is a BigInt, let _n_ be 𝔽(ℝ(_prim_)).\n    1. Else, let _n_ be _prim_.\n  1. Else,\n    1. Let _n_ be *+0*<sub>𝔽</sub>.\n  1. If NewTarget is *undefined*, return _n_.\n  1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Number.prototype%\"*, « [[NumberData]] »).\n  1. Set _O_.[[NumberData]] to _n_.\n  1. Return _O_.","code":"\n          1. If _value_ is present, then\n            1. Let _prim_ be ? ToNumeric(_value_).\n            1. If _prim_ is a BigInt, let _n_ be 𝔽(ℝ(_prim_)).\n            1. Otherwise, let _n_ be _prim_.\n          1. Else,\n            1. Let _n_ be *+0*<sub>𝔽</sub>.\n          1. If NewTarget is *undefined*, return _n_.\n          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Number.prototype%\"*, « [[NumberData]] »).\n          1. Set _O_.[[NumberData]] to _n_.\n          1. Return _O_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Number"}},"name":"isFinite"}},"params":[{"name":"number","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If _number_ is not a Number, return *false*.\n  1. If _number_ is not finite, return *false*.\n  1. Else, return *true*.","code":"\n          1. If _number_ is not a Number, return *false*.\n          1. If _number_ is not finite, return *false*.\n          1. Otherwise, return *true*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Number"}},"name":"isInteger"}},"params":[{"name":"number","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Return IsIntegralNumber(_number_).","code":"\n          1. Return IsIntegralNumber(_number_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Number"}},"name":"isNaN"}},"params":[{"name":"number","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If _number_ is not a Number, return *false*.\n  1. If _number_ is *NaN*, return *true*.\n  1. Else, return *false*.","code":"\n          1. If _number_ is not a Number, return *false*.\n          1. If _number_ is *NaN*, return *true*.\n          1. Otherwise, return *false*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Number"}},"name":"isSafeInteger"}},"params":[{"name":"number","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If IsIntegralNumber(_number_) is *true*, then\n    1. If abs(ℝ(_number_)) ≤ 2<sup>53</sup> - 1, return *true*.\n  1. Return *false*.","code":"\n          1. If IsIntegralNumber(_number_) is *true*, then\n            1. If abs(ℝ(_number_)) ≤ 2<sup>53</sup> - 1, return *true*.\n          1. Return *false*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Number"}},"name":"prototype"}},"name":"toExponential"}},"params":[{"name":"fractionDigits","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _x_ be ? ThisNumberValue(*this* value).\n  1. Let _f_ be ? ToIntegerOrInfinity(_fractionDigits_).\n  1. Assert: If _fractionDigits_ is *undefined*, then _f_ is 0.\n  1. If _x_ is not finite, return Number::toString(_x_, 10).\n  1. If _f_ < 0 or _f_ > 100, throw a *RangeError* exception.\n  1. Set _x_ to ℝ(_x_).\n  1. Let _s_ be *\"\"*.\n  1. If _x_ < 0, then\n    1. Set _s_ to *\"-\"*.\n    1. Set _x_ to -_x_.\n  1. If _x_ = 0, then\n    1. Let _m_ be the String value consisting of _f_ + 1 occurrences of the code unit 0x0030 (DIGIT ZERO).\n    1. Let _e_ be 0.\n  1. Else,\n    1. If _fractionDigits_ is not *undefined*, then\n      1. Let _e_ and _n_ be integers such that 10<sup>_f_</sup> ≤ _n_ < 10<sup>_f_ + 1</sup> and for which _n_ × 10<sup>_e_ - _f_</sup> - _x_ is as close to zero as possible. If there are two such sets of _e_ and _n_, pick the _e_ and _n_ for which _n_ × 10<sup>_e_ - _f_</sup> is larger.\n    1. Else,\n      1. [id=\"step-number-proto-toexponential-intermediate-values\"] Let _e_, _n_, and _ff_ be integers such that _ff_ ≥ 0, 10<sup>_ff_</sup> ≤ _n_ < 10<sup>_ff_ + 1</sup>, 𝔽(_n_ × 10<sup>_e_ - _ff_</sup>) is 𝔽(_x_), and _ff_ is as small as possible. Note that the decimal representation of _n_ has _ff_ + 1 digits, _n_ is not divisible by 10, and the least significant digit of _n_ is not necessarily uniquely determined by these criteria.\n      1. Set _f_ to _ff_.\n    1. Let _m_ be the String value consisting of the digits of the decimal representation of _n_ (in order, with no leading zeroes).\n  1. If _f_ ≠ 0, then\n    1. Let _a_ be the first code unit of _m_.\n    1. Let _b_ be the other _f_ code units of _m_.\n    1. Set _m_ to the string-concatenation of _a_, *\".\"*, and _b_.\n  1. If _e_ = 0, then\n    1. Let _c_ be *\"+\"*.\n    1. Let _d_ be *\"0\"*.\n  1. Else,\n    1. If _e_ > 0, then\n      1. Let _c_ be *\"+\"*.\n    1. Else,\n      1. Assert: _e_ < 0.\n      1. Let _c_ be *\"-\"*.\n      1. Set _e_ to -_e_.\n    1. Let _d_ be the String value consisting of the digits of the decimal representation of _e_ (in order, with no leading zeroes).\n  1. Set _m_ to the string-concatenation of _m_, *\"e\"*, _c_, and _d_.\n  1. Return the string-concatenation of _s_ and _m_.","code":"\n          1. Let _x_ be ? ThisNumberValue(*this* value).\n          1. Let _f_ be ? ToIntegerOrInfinity(_fractionDigits_).\n          1. Assert: If _fractionDigits_ is *undefined*, then _f_ is 0.\n          1. If _x_ is not finite, return Number::toString(_x_, 10).\n          1. If _f_ < 0 or _f_ > 100, throw a *RangeError* exception.\n          1. Set _x_ to ℝ(_x_).\n          1. Let _s_ be the empty String.\n          1. If _x_ < 0, then\n            1. Set _s_ to *\"-\"*.\n            1. Set _x_ to -_x_.\n          1. If _x_ = 0, then\n            1. Let _m_ be the String value consisting of _f_ + 1 occurrences of the code unit 0x0030 (DIGIT ZERO).\n            1. Let _e_ be 0.\n          1. Else,\n            1. If _fractionDigits_ is not *undefined*, then\n              1. Let _e_ and _n_ be integers such that 10<sup>_f_</sup> ≤ _n_ < 10<sup>_f_ + 1</sup> and for which _n_ × 10<sup>_e_ - _f_</sup> - _x_ is as close to zero as possible. If there are two such sets of _e_ and _n_, pick the _e_ and _n_ for which _n_ × 10<sup>_e_ - _f_</sup> is larger.\n            1. Else,\n              1. [id=\"step-number-proto-toexponential-intermediate-values\"] Let _e_, _n_, and _ff_ be integers such that _ff_ ≥ 0, 10<sup>_ff_</sup> ≤ _n_ < 10<sup>_ff_ + 1</sup>, 𝔽(_n_ × 10<sup>_e_ - _ff_</sup>) is 𝔽(_x_), and _ff_ is as small as possible. Note that the decimal representation of _n_ has _ff_ + 1 digits, _n_ is not divisible by 10, and the least significant digit of _n_ is not necessarily uniquely determined by these criteria.\n              1. Set _f_ to _ff_.\n            1. Let _m_ be the String value consisting of the digits of the decimal representation of _n_ (in order, with no leading zeroes).\n          1. If _f_ ≠ 0, then\n            1. Let _a_ be the first code unit of _m_.\n            1. Let _b_ be the other _f_ code units of _m_.\n            1. Set _m_ to the string-concatenation of _a_, *\".\"*, and _b_.\n          1. If _e_ = 0, then\n            1. Let _c_ be *\"+\"*.\n            1. Let _d_ be *\"0\"*.\n          1. Else,\n            1. If _e_ > 0, then\n              1. Let _c_ be *\"+\"*.\n            1. Else,\n              1. Assert: _e_ < 0.\n              1. Let _c_ be *\"-\"*.\n              1. Set _e_ to -_e_.\n            1. Let _d_ be the String value consisting of the digits of the decimal representation of _e_ (in order, with no leading zeroes).\n          1. Set _m_ to the string-concatenation of _m_, *\"e\"*, _c_, and _d_.\n          1. Return the string-concatenation of _s_ and _m_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Number"}},"name":"prototype"}},"name":"toFixed"}},"params":[{"name":"fractionDigits","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _x_ be ? ThisNumberValue(*this* value).\n  1. Let _f_ be ? ToIntegerOrInfinity(_fractionDigits_).\n  1. Assert: If _fractionDigits_ is *undefined*, then _f_ is 0.\n  1. If _f_ is not finite, throw a *RangeError* exception.\n  1. If _f_ < 0 or _f_ > 100, throw a *RangeError* exception.\n  1. If _x_ is not finite, return Number::toString(_x_, 10).\n  1. Set _x_ to ℝ(_x_).\n  1. Let _s_ be *\"\"*.\n  1. If _x_ < 0, then\n    1. Set _s_ to *\"-\"*.\n    1. Set _x_ to -_x_.\n  1. If _x_ ≥ 10<sup>21</sup>, then\n    1. Let _m_ be ! ToString(𝔽(_x_)).\n  1. Else,\n    1. Let _n_ be an integer for which _n_ / 10<sup>_f_</sup> - _x_ is as close to zero as possible. If there are two such _n_, pick the larger _n_.\n    1. If _n_ = 0, let _m_ be *\"0\"*.\n    1. Else, let _m_ be the String value consisting of the digits of the decimal representation of _n_ (in order, with no leading zeroes).\n    1. If _f_ ≠ 0, then\n      1. Let _k_ be the length of _m_.\n      1. If _k_ ≤ _f_, then\n        1. Let _z_ be the String value consisting of _f_ + 1 - _k_ occurrences of the code unit 0x0030 (DIGIT ZERO).\n        1. Set _m_ to the string-concatenation of _z_ and _m_.\n        1. Set _k_ to _f_ + 1.\n      1. Let _a_ be the first _k_ - _f_ code units of _m_.\n      1. Let _b_ be the other _f_ code units of _m_.\n      1. Set _m_ to the string-concatenation of _a_, *\".\"*, and _b_.\n  1. Return the string-concatenation of _s_ and _m_.","code":"\n          1. Let _x_ be ? ThisNumberValue(*this* value).\n          1. Let _f_ be ? ToIntegerOrInfinity(_fractionDigits_).\n          1. Assert: If _fractionDigits_ is *undefined*, then _f_ is 0.\n          1. If _f_ is not finite, throw a *RangeError* exception.\n          1. If _f_ < 0 or _f_ > 100, throw a *RangeError* exception.\n          1. If _x_ is not finite, return Number::toString(_x_, 10).\n          1. Set _x_ to ℝ(_x_).\n          1. Let _s_ be the empty String.\n          1. If _x_ < 0, then\n            1. Set _s_ to *\"-\"*.\n            1. Set _x_ to -_x_.\n          1. If _x_ ≥ 10<sup>21</sup>, then\n            1. Let _m_ be ! ToString(𝔽(_x_)).\n          1. Else,\n            1. Let _n_ be an integer for which _n_ / 10<sup>_f_</sup> - _x_ is as close to zero as possible. If there are two such _n_, pick the larger _n_.\n            1. If _n_ = 0, let _m_ be *\"0\"*. Otherwise, let _m_ be the String value consisting of the digits of the decimal representation of _n_ (in order, with no leading zeroes).\n            1. If _f_ ≠ 0, then\n              1. Let _k_ be the length of _m_.\n              1. If _k_ ≤ _f_, then\n                1. Let _z_ be the String value consisting of _f_ + 1 - _k_ occurrences of the code unit 0x0030 (DIGIT ZERO).\n                1. Set _m_ to the string-concatenation of _z_ and _m_.\n                1. Set _k_ to _f_ + 1.\n              1. Let _a_ be the first _k_ - _f_ code units of _m_.\n              1. Let _b_ be the other _f_ code units of _m_.\n              1. Set _m_ to the string-concatenation of _a_, *\".\"*, and _b_.\n          1. Return the string-concatenation of _s_ and _m_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Number"}},"name":"prototype"}},"name":"toPrecision"}},"params":[{"name":"precision","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _x_ be ? ThisNumberValue(*this* value).\n  1. If _precision_ is *undefined*, return ! ToString(_x_).\n  1. Let _p_ be ? ToIntegerOrInfinity(_precision_).\n  1. If _x_ is not finite, return Number::toString(_x_, 10).\n  1. If _p_ < 1 or _p_ > 100, throw a *RangeError* exception.\n  1. Set _x_ to ℝ(_x_).\n  1. Let _s_ be *\"\"*.\n  1. If _x_ < 0, then\n    1. Set _s_ to the code unit 0x002D (HYPHEN-MINUS).\n    1. Set _x_ to -_x_.\n  1. If _x_ = 0, then\n    1. Let _m_ be the String value consisting of _p_ occurrences of the code unit 0x0030 (DIGIT ZERO).\n    1. Let _e_ be 0.\n  1. Else,\n    1. Let _e_ and _n_ be integers such that 10<sup>_p_ - 1</sup> ≤ _n_ < 10<sup>_p_</sup> and for which _n_ × 10<sup>_e_ - _p_ + 1</sup> - _x_ is as close to zero as possible. If there are two such sets of _e_ and _n_, pick the _e_ and _n_ for which _n_ × 10<sup>_e_ - _p_ + 1</sup> is larger.\n    1. Let _m_ be the String value consisting of the digits of the decimal representation of _n_ (in order, with no leading zeroes).\n    1. If _e_ < -6 or _e_ ≥ _p_, then\n      1. Assert: _e_ ≠ 0.\n      1. If _p_ ≠ 1, then\n        1. Let _a_ be the first code unit of _m_.\n        1. Let _b_ be the other _p_ - 1 code units of _m_.\n        1. Set _m_ to the string-concatenation of _a_, *\".\"*, and _b_.\n      1. If _e_ > 0, then\n        1. Let _c_ be 0x002b (PLUS SIGN).\n      1. Else,\n        1. Assert: _e_ < 0.\n        1. Let _c_ be the code unit 0x002D (HYPHEN-MINUS).\n        1. Set _e_ to -_e_.\n      1. Let _d_ be the String value consisting of the digits of the decimal representation of _e_ (in order, with no leading zeroes).\n      1. Return the string-concatenation of _s_, _m_, 0x0065 (LATIN SMALL LETTER E), _c_, and _d_.\n  1. If _e_ = _p_ - 1, return the string-concatenation of _s_ and _m_.\n  1. If _e_ ≥ 0, then\n    1. Set _m_ to the string-concatenation of the first _e_ + 1 code units of _m_, the code unit 0x002E (FULL STOP), and the remaining _p_ - (_e_ + 1) code units of _m_.\n  1. Else,\n    1. Set _m_ to the string-concatenation of the code unit 0x0030 (DIGIT ZERO), the code unit 0x002E (FULL STOP), -(_e_ + 1) occurrences of the code unit 0x0030 (DIGIT ZERO), and the String _m_.\n  1. Return the string-concatenation of _s_ and _m_.","code":"\n          1. Let _x_ be ? ThisNumberValue(*this* value).\n          1. If _precision_ is *undefined*, return ! ToString(_x_).\n          1. Let _p_ be ? ToIntegerOrInfinity(_precision_).\n          1. If _x_ is not finite, return Number::toString(_x_, 10).\n          1. If _p_ < 1 or _p_ > 100, throw a *RangeError* exception.\n          1. Set _x_ to ℝ(_x_).\n          1. Let _s_ be the empty String.\n          1. If _x_ < 0, then\n            1. Set _s_ to the code unit 0x002D (HYPHEN-MINUS).\n            1. Set _x_ to -_x_.\n          1. If _x_ = 0, then\n            1. Let _m_ be the String value consisting of _p_ occurrences of the code unit 0x0030 (DIGIT ZERO).\n            1. Let _e_ be 0.\n          1. Else,\n            1. Let _e_ and _n_ be integers such that 10<sup>_p_ - 1</sup> ≤ _n_ < 10<sup>_p_</sup> and for which _n_ × 10<sup>_e_ - _p_ + 1</sup> - _x_ is as close to zero as possible. If there are two such sets of _e_ and _n_, pick the _e_ and _n_ for which _n_ × 10<sup>_e_ - _p_ + 1</sup> is larger.\n            1. Let _m_ be the String value consisting of the digits of the decimal representation of _n_ (in order, with no leading zeroes).\n            1. If _e_ < -6 or _e_ ≥ _p_, then\n              1. Assert: _e_ ≠ 0.\n              1. If _p_ ≠ 1, then\n                1. Let _a_ be the first code unit of _m_.\n                1. Let _b_ be the other _p_ - 1 code units of _m_.\n                1. Set _m_ to the string-concatenation of _a_, *\".\"*, and _b_.\n              1. If _e_ > 0, then\n                1. Let _c_ be the code unit 0x002B (PLUS SIGN).\n              1. Else,\n                1. Assert: _e_ < 0.\n                1. Let _c_ be the code unit 0x002D (HYPHEN-MINUS).\n                1. Set _e_ to -_e_.\n              1. Let _d_ be the String value consisting of the digits of the decimal representation of _e_ (in order, with no leading zeroes).\n              1. Return the string-concatenation of _s_, _m_, the code unit 0x0065 (LATIN SMALL LETTER E), _c_, and _d_.\n          1. If _e_ = _p_ - 1, return the string-concatenation of _s_ and _m_.\n          1. If _e_ ≥ 0, then\n            1. Set _m_ to the string-concatenation of the first _e_ + 1 code units of _m_, the code unit 0x002E (FULL STOP), and the remaining _p_ - (_e_ + 1) code units of _m_.\n          1. Else,\n            1. Set _m_ to the string-concatenation of the code unit 0x0030 (DIGIT ZERO), the code unit 0x002E (FULL STOP), -(_e_ + 1) occurrences of the code unit 0x0030 (DIGIT ZERO), and the String _m_.\n          1. Return the string-concatenation of _s_ and _m_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Number"}},"name":"prototype"}},"name":"toString"}},"params":[{"name":"radix","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _x_ be ? ThisNumberValue(*this* value).\n  1. If _radix_ is *undefined*, let _radixMV_ be 10.\n  1. Else, let _radixMV_ be ? ToIntegerOrInfinity(_radix_).\n  1. If _radixMV_ is not in the inclusive interval from 2 to 36, throw a *RangeError* exception.\n  1. Return Number::toString(_x_, _radixMV_).","code":"\n          1. Let _x_ be ? ThisNumberValue(*this* value).\n          1. If _radix_ is *undefined*, let _radixMV_ be 10.\n          1. Else, let _radixMV_ be ? ToIntegerOrInfinity(_radix_).\n          1. If _radixMV_ is not in the inclusive interval from 2 to 36, throw a *RangeError* exception.\n          1. Return Number::toString(_x_, _radixMV_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Number"}},"name":"prototype"}},"name":"valueOf"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Return ? ThisNumberValue(*this* value).","code":"\n          1. Return ? ThisNumberValue(*this* value).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ThisNumberValue","params":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Number] | Throw"}},"body":"\n  1. If _value_ is a Number, return _value_.\n  1. If _value_ is a Record[Object] and _value_ has a [[NumberData]] internal slot, then\n    1. Let _n_ be _value_.[[NumberData]].\n    1. Assert: _n_ is a Number.\n    1. Return _n_.\n  1. Throw a *TypeError* exception.","code":"\n            1. If _value_ is a Number, return _value_.\n            1. If _value_ is an Object and _value_ has a [[NumberData]] internal slot, then\n              1. Let _n_ be _value_.[[NumberData]].\n              1. Assert: _n_ is a Number.\n              1. Return _n_.\n            1. Throw a *TypeError* exception.\n          "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"BigInt"}},"params":[{"name":"value","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If NewTarget is not *undefined*, throw a *TypeError* exception.\n  1. Let _prim_ be ? ToPrimitive(_value_, ~number~).\n  1. If _prim_ is a Number, return ? NumberToBigInt(_prim_).\n  1. Else, return ? ToBigInt(_prim_).","code":"\n          1. If NewTarget is not *undefined*, throw a *TypeError* exception.\n          1. Let _prim_ be ? ToPrimitive(_value_, ~number~).\n          1. If _prim_ is a Number, return ? NumberToBigInt(_prim_).\n          1. Otherwise, return ? <emu-meta suppress-effects=\"user-code\">ToBigInt(_prim_)</emu-meta>.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"NumberToBigInt","params":[{"name":"number","ty":"Number","kind":{"Normal":{}}}],"retTy":"Normal[BigInt] | Throw"}},"body":"\n  1. If IsIntegralNumber(_number_) is *false*, throw a *RangeError* exception.\n  1. Return ℤ(ℝ(_number_)).","code":"\n            1. If IsIntegralNumber(_number_) is *false*, throw a *RangeError* exception.\n            1. Return ℤ(ℝ(_number_)).\n          "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"BigInt"}},"name":"asIntN"}},"params":[{"name":"bits","ty":"Unknown","kind":{"Normal":{}}},{"name":"bigint","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Set _bits_ to ? ToIndex(_bits_).\n  1. Set _bigint_ to ? ToBigInt(_bigint_).\n  1. Let _mod_ be ℝ(_bigint_) modulo 2<sup>_bits_</sup>.\n  1. If _mod_ ≥ 2<sup>(_bits_ - 1)</sup>, return ℤ(_mod_ - 2<sup>_bits_</sup>).\n  1. Else, return ℤ(_mod_).","code":"\n          1. Set _bits_ to ? ToIndex(_bits_).\n          1. Set _bigint_ to ? ToBigInt(_bigint_).\n          1. Let _mod_ be ℝ(_bigint_) modulo 2<sup>_bits_</sup>.\n          1. If _mod_ ≥ 2<sup>_bits_ - 1</sup>, return ℤ(_mod_ - 2<sup>_bits_</sup>); otherwise, return ℤ(_mod_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"BigInt"}},"name":"asUintN"}},"params":[{"name":"bits","ty":"Unknown","kind":{"Normal":{}}},{"name":"bigint","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Set _bits_ to ? ToIndex(_bits_).\n  1. Set _bigint_ to ? ToBigInt(_bigint_).\n  1. Return ℤ(ℝ(_bigint_) modulo 2<sup>_bits_</sup>).","code":"\n          1. Set _bits_ to ? ToIndex(_bits_).\n          1. Set _bigint_ to ? ToBigInt(_bigint_).\n          1. Return ℤ(ℝ(_bigint_) modulo 2<sup>_bits_</sup>).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"BigInt"}},"name":"prototype"}},"name":"toString"}},"params":[{"name":"radix","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _x_ be ? ThisBigIntValue(*this* value).\n  1. If _radix_ is *undefined*, let _radixMV_ be 10.\n  1. Else, let _radixMV_ be ? ToIntegerOrInfinity(_radix_).\n  1. If _radixMV_ is not in the inclusive interval from 2 to 36, throw a *RangeError* exception.\n  1. Return BigInt::toString(_x_, _radixMV_).","code":"\n          1. Let _x_ be ? ThisBigIntValue(*this* value).\n          1. If _radix_ is *undefined*, let _radixMV_ be 10.\n          1. Else, let _radixMV_ be ? ToIntegerOrInfinity(_radix_).\n          1. If _radixMV_ is not in the inclusive interval from 2 to 36, throw a *RangeError* exception.\n          1. Return BigInt::toString(_x_, _radixMV_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"BigInt"}},"name":"prototype"}},"name":"valueOf"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Return ? ThisBigIntValue(*this* value).","code":"\n          1. Return ? ThisBigIntValue(*this* value).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ThisBigIntValue","params":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[BigInt] | Throw"}},"body":"\n  1. If _value_ is a BigInt, return _value_.\n  1. If _value_ is a Record[Object] and _value_ has a [[BigIntData]] internal slot, then\n    1. Assert: _value_.[[BigIntData]] is a BigInt.\n    1. Return _value_.[[BigIntData]].\n  1. Throw a *TypeError* exception.","code":"\n            1. If _value_ is a BigInt, return _value_.\n            1. If _value_ is an Object and _value_ has a [[BigIntData]] internal slot, then\n              1. Assert: _value_.[[BigIntData]] is a BigInt.\n              1. Return _value_.[[BigIntData]].\n            1. Throw a *TypeError* exception.\n          "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"abs"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _n_ be ? ToNumber(_x_).\n  1. If _n_ is *NaN*, return *NaN*.\n  1. If _n_ is *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n  1. If _n_ is *-∞*<sub>𝔽</sub>, return *+∞*<sub>𝔽</sub>.\n  1. If _n_ < *-0*<sub>𝔽</sub>, return -_n_.\n  1. Return _n_.","code":"\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is *NaN*, return *NaN*.\n          1. If _n_ is *-0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n          1. If _n_ is *-∞*<sub>𝔽</sub>, return *+∞*<sub>𝔽</sub>.\n          1. If _n_ < *-0*<sub>𝔽</sub>, return -_n_.\n          1. Return _n_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"acos"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _n_ be ? ToNumber(_x_).\n  1. If _n_ is *NaN* or _n_ > *1*<sub>𝔽</sub> or _n_ < *-1*<sub>𝔽</sub>, return *NaN*.\n  1. If _n_ is *1*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n  1. Return an implementation-approximated Number value representing the inverse cosine of ℝ(_n_).","code":"\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is *NaN*, _n_ > *1*<sub>𝔽</sub>, or _n_ < *-1*<sub>𝔽</sub>, return *NaN*.\n          1. If _n_ is *1*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n          1. Return an implementation-approximated Number value representing the result of the inverse cosine of ℝ(_n_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"acosh"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _n_ be ? ToNumber(_x_).\n  1. If _n_ is either *NaN* or *+∞*<sub>𝔽</sub>, return _n_.\n  1. If _n_ is *1*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n  1. If _n_ < *1*<sub>𝔽</sub>, return *NaN*.\n  1. Return an implementation-approximated Number value representing the inverse hyperbolic cosine of ℝ(_n_).","code":"\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is either *NaN* or *+∞*<sub>𝔽</sub>, return _n_.\n          1. If _n_ is *1*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n          1. If _n_ < *1*<sub>𝔽</sub>, return *NaN*.\n          1. Return an implementation-approximated Number value representing the result of the inverse hyperbolic cosine of ℝ(_n_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"asin"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _n_ be ? ToNumber(_x_).\n  1. If _n_ is either *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return _n_.\n  1. If _n_ > *1*<sub>𝔽</sub> or _n_ < *-1*<sub>𝔽</sub>, return *NaN*.\n  1. Return an implementation-approximated Number value representing the inverse sine of ℝ(_n_).","code":"\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return _n_.\n          1. If _n_ > *1*<sub>𝔽</sub> or _n_ < *-1*<sub>𝔽</sub>, return *NaN*.\n          1. Return an implementation-approximated Number value representing the result of the inverse sine of ℝ(_n_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"asinh"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _n_ be ? ToNumber(_x_).\n  1. If _n_ is not finite or _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return _n_.\n  1. Return an implementation-approximated Number value representing the inverse hyperbolic sine of ℝ(_n_).","code":"\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is not finite or _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return _n_.\n          1. Return an implementation-approximated Number value representing the result of the inverse hyperbolic sine of ℝ(_n_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"atan"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _n_ be ? ToNumber(_x_).\n  1. If _n_ is either *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return _n_.\n  1. If _n_ is *+∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing π / 2.\n  1. If _n_ is *-∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing -π / 2.\n  1. Return an implementation-approximated Number value representing the inverse tangent of ℝ(_n_).","code":"\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return _n_.\n          1. If _n_ is *+∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing π / 2.\n          1. If _n_ is *-∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing -π / 2.\n          1. Return an implementation-approximated Number value representing the result of the inverse tangent of ℝ(_n_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"atanh"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _n_ be ? ToNumber(_x_).\n  1. If _n_ is either *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return _n_.\n  1. If _n_ > *1*<sub>𝔽</sub> or _n_ < *-1*<sub>𝔽</sub>, return *NaN*.\n  1. If _n_ is *1*<sub>𝔽</sub>, return *+∞*<sub>𝔽</sub>.\n  1. If _n_ is *-1*<sub>𝔽</sub>, return *-∞*<sub>𝔽</sub>.\n  1. Return an implementation-approximated Number value representing the inverse hyperbolic tangent of ℝ(_n_).","code":"\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return _n_.\n          1. If _n_ > *1*<sub>𝔽</sub> or _n_ < *-1*<sub>𝔽</sub>, return *NaN*.\n          1. If _n_ is *1*<sub>𝔽</sub>, return *+∞*<sub>𝔽</sub>.\n          1. If _n_ is *-1*<sub>𝔽</sub>, return *-∞*<sub>𝔽</sub>.\n          1. Return an implementation-approximated Number value representing the result of the inverse hyperbolic tangent of ℝ(_n_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"atan2"}},"params":[{"name":"y","ty":"Unknown","kind":{"Normal":{}}},{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _ny_ be ? ToNumber(_y_).\n  1. Let _nx_ be ? ToNumber(_x_).\n  1. If _ny_ is *NaN* or _nx_ is *NaN*, return *NaN*.\n  1. If _ny_ is *+∞*<sub>𝔽</sub>, then\n    1. If _nx_ is *+∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing π / 4.\n    1. If _nx_ is *-∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing 3π / 4.\n    1. Return an implementation-approximated Number value representing π / 2.\n  1. If _ny_ is *-∞*<sub>𝔽</sub>, then\n    1. If _nx_ is *+∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing -π / 4.\n    1. If _nx_ is *-∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing -3π / 4.\n    1. Return an implementation-approximated Number value representing -π / 2.\n  1. If _ny_ is *+0*<sub>𝔽</sub>, then\n    1. If _nx_ > *+0*<sub>𝔽</sub> or _nx_ is *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n    1. Return an implementation-approximated Number value representing π.\n  1. If _ny_ is *-0*<sub>𝔽</sub>, then\n    1. If _nx_ > *+0*<sub>𝔽</sub> or _nx_ is *+0*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.\n    1. Return an implementation-approximated Number value representing -π.\n  1. Assert: _ny_ is finite and is neither *+0*<sub>𝔽</sub> nor *-0*<sub>𝔽</sub>..\n  1. If _ny_ > *+0*<sub>𝔽</sub>, then\n    1. If _nx_ is *+∞*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n    1. If _nx_ is *-∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing π.\n    1. If _nx_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return an implementation-approximated Number value representing π / 2.\n  1. If _ny_ < *-0*<sub>𝔽</sub>, then\n    1. If _nx_ is *+∞*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.\n    1. If _nx_ is *-∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing -π.\n    1. If _nx_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return an implementation-approximated Number value representing -π / 2.\n  1. Assert: _nx_ is finite and is neither *+0*<sub>𝔽</sub> nor *-0*<sub>𝔽</sub>..\n  1. Let _r_ be the inverse tangent of abs(ℝ(_ny_) / ℝ(_nx_)).\n  1. If _nx_ < *-0*<sub>𝔽</sub>, then\n    1. If _ny_ > *+0*<sub>𝔽</sub>, set _r_ to π - _r_.\n    1. Else, set _r_ to -π + _r_.\n  1. Else,\n    1. If _ny_ < *-0*<sub>𝔽</sub>, set _r_ to -_r_.\n  1. Return an implementation-approximated Number value representing _r_.","code":"\n          1. Let _ny_ be ? ToNumber(_y_).\n          1. Let _nx_ be ? ToNumber(_x_).\n          1. If _ny_ is *NaN* or _nx_ is *NaN*, return *NaN*.\n          1. If _ny_ is *+∞*<sub>𝔽</sub>, then\n            1. If _nx_ is *+∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing π / 4.\n            1. If _nx_ is *-∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing 3π / 4.\n            1. Return an implementation-approximated Number value representing π / 2.\n          1. If _ny_ is *-∞*<sub>𝔽</sub>, then\n            1. If _nx_ is *+∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing -π / 4.\n            1. If _nx_ is *-∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing -3π / 4.\n            1. Return an implementation-approximated Number value representing -π / 2.\n          1. If _ny_ is *+0*<sub>𝔽</sub>, then\n            1. If _nx_ > *+0*<sub>𝔽</sub> or _nx_ is *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n            1. Return an implementation-approximated Number value representing π.\n          1. If _ny_ is *-0*<sub>𝔽</sub>, then\n            1. If _nx_ > *+0*<sub>𝔽</sub> or _nx_ is *+0*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.\n            1. Return an implementation-approximated Number value representing -π.\n          1. Assert: _ny_ is finite and is neither *+0*<sub>𝔽</sub> nor *-0*<sub>𝔽</sub>.\n          1. If _ny_ > *+0*<sub>𝔽</sub>, then\n            1. If _nx_ is *+∞*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n            1. If _nx_ is *-∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing π.\n            1. If _nx_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return an implementation-approximated Number value representing π / 2.\n          1. If _ny_ < *-0*<sub>𝔽</sub>, then\n            1. If _nx_ is *+∞*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.\n            1. If _nx_ is *-∞*<sub>𝔽</sub>, return an implementation-approximated Number value representing -π.\n            1. If _nx_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return an implementation-approximated Number value representing -π / 2.\n          1. Assert: _nx_ is finite and is neither *+0*<sub>𝔽</sub> nor *-0*<sub>𝔽</sub>.\n          1. Let _r_ be the inverse tangent of abs(ℝ(_ny_) / ℝ(_nx_)).\n          1. If _nx_ < *-0*<sub>𝔽</sub>, then\n            1. If _ny_ > *+0*<sub>𝔽</sub>, set _r_ to π - _r_.\n            1. Else, set _r_ to -π + _r_.\n          1. Else,\n            1. If _ny_ < *-0*<sub>𝔽</sub>, set _r_ to -_r_.\n          1. Return an implementation-approximated Number value representing _r_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"cbrt"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _n_ be ? ToNumber(_x_).\n  1. If _n_ is not finite or _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return _n_.\n  1. Return an implementation-approximated Number value representing the cube root of ℝ(_n_).","code":"\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is not finite or _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return _n_.\n          1. Return an implementation-approximated Number value representing the result of the cube root of ℝ(_n_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"ceil"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _n_ be ? ToNumber(_x_).\n  1. If _n_ is not finite or _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return _n_.\n  1. If _n_ < *-0*<sub>𝔽</sub> and _n_ > *-1*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.\n  1. If _n_ is a Number[Int], return _n_.\n  1. Return the smallest (closest to -∞) integral Number value that is not less than _n_.","code":"\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is not finite or _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return _n_.\n          1. If _n_ < *-0*<sub>𝔽</sub> and _n_ > *-1*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.\n          1. If _n_ is an integral Number, return _n_.\n          1. Return the smallest (closest to -∞) integral Number value that is not less than _n_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"clz32"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _n_ be ? ToUint32(_x_).\n  1. Let _p_ be the number of leading zero bits in the unsigned 32-bit binary representation of _n_.\n  1. Return 𝔽(_p_).","code":"\n          1. Let _n_ be ? ToUint32(_x_).\n          1. Let _p_ be the number of leading zero bits in the unsigned 32-bit binary representation of _n_.\n          1. Return 𝔽(_p_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"cos"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _n_ be ? ToNumber(_x_).\n  1. If _n_ is not finite, return *NaN*.\n  1. If _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.\n  1. Return an implementation-approximated Number value representing the cosine of ℝ(_n_).","code":"\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is not finite, return *NaN*.\n          1. If _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.\n          1. Return an implementation-approximated Number value representing the result of the cosine of ℝ(_n_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"cosh"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _n_ be ? ToNumber(_x_).\n  1. If _n_ is *NaN*, return *NaN*.\n  1. If _n_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return *+∞*<sub>𝔽</sub>.\n  1. If _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.\n  1. Return an implementation-approximated Number value representing the hyperbolic cosine of ℝ(_n_).","code":"\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is *NaN*, return *NaN*.\n          1. If _n_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return *+∞*<sub>𝔽</sub>.\n          1. If _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.\n          1. Return an implementation-approximated Number value representing the result of the hyperbolic cosine of ℝ(_n_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"exp"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _n_ be ? ToNumber(_x_).\n  1. If _n_ is either *NaN* or *+∞*<sub>𝔽</sub>, return _n_.\n  1. If _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.\n  1. If _n_ is *-∞*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n  1. Return an implementation-approximated Number value representing the exponential function of ℝ(_n_).","code":"\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is either *NaN* or *+∞*<sub>𝔽</sub>, return _n_.\n          1. If _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.\n          1. If _n_ is *-∞*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n          1. Return an implementation-approximated Number value representing the result of the exponential function of ℝ(_n_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"expm1"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _n_ be ? ToNumber(_x_).\n  1. If _n_ is either *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, or *+∞*<sub>𝔽</sub>, return _n_.\n  1. If _n_ is *-∞*<sub>𝔽</sub>, return *-1*<sub>𝔽</sub>.\n  1. Return an implementation-approximated Number value representing the subtracting 1 from the exponential function of ℝ(_n_).","code":"\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, or *+∞*<sub>𝔽</sub>, return _n_.\n          1. If _n_ is *-∞*<sub>𝔽</sub>, return *-1*<sub>𝔽</sub>.\n          1. Return an implementation-approximated Number value representing the result of subtracting 1 from the exponential function of ℝ(_n_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"floor"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _n_ be ? ToNumber(_x_).\n  1. If _n_ is not finite or _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return _n_.\n  1. If _n_ < *1*<sub>𝔽</sub> and _n_ > *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n  1. If _n_ is a Number[Int], return _n_.\n  1. Return the greatest (closest to +∞) integral Number value that is not greater than _n_.","code":"\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is not finite or _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return _n_.\n          1. If _n_ < *1*<sub>𝔽</sub> and _n_ > *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n          1. If _n_ is an integral Number, return _n_.\n          1. Return the greatest (closest to +∞) integral Number value that is not greater than _n_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"fround"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _n_ be ? ToNumber(_x_).\n  1. If _n_ is *NaN*, return *NaN*.\n  1. If _n_ is either *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, *+∞*<sub>𝔽</sub>, or *-∞*<sub>𝔽</sub>, return _n_.\n  1. Let _n32_ be the result of converting _n_ to IEEE 754-2019 binary32 format using roundTiesToEven mode.\n  1. Let _n64_ be the result of converting _n32_ to IEEE 754-2019 binary64 format.\n  1. Return the ECMAScript Number value corresponding to _n64_.","code":"\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is *NaN*, return *NaN*.\n          1. If _n_ is one of *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, *+∞*<sub>𝔽</sub>, or *-∞*<sub>𝔽</sub>, return _n_.\n          1. Let _n32_ be the result of converting _n_ to IEEE 754-2019 binary32 format using roundTiesToEven mode.\n          1. Let _n64_ be the result of converting _n32_ to IEEE 754-2019 binary64 format.\n          1. Return the ECMAScript Number value corresponding to _n64_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"hypot"}},"params":[{"name":"args","ty":"Unknown","kind":{"Variadic":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _coerced_ be « ».\n  1. For each _arg_ of _args_, do\n    1. Let _n_ be ? ToNumber(_arg_).\n    1. Append _n_ to _coerced_.\n  1. For each _number_ of _coerced_, do\n    1. If _number_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return *+∞*<sub>𝔽</sub>.\n  1. Let _onlyZero_ be *true*.\n  1. For each _number_ of _coerced_, do\n    1. If _number_ is *NaN*, return *NaN*.\n    1. If _number_ is neither *+0*<sub>𝔽</sub> nor *-0*<sub>𝔽</sub>, set _onlyZero_ to *false*.\n  1. If _onlyZero_ is *true*, return *+0*<sub>𝔽</sub>.\n  1. Return an implementation-approximated Number value representing the square root of the sum of squares of the mathematical values of the elements of _coerced_.","code":"\n          1. Let _coerced_ be a new empty List.\n          1. For each element _arg_ of _args_, do\n            1. Let _n_ be ? ToNumber(_arg_).\n            1. Append _n_ to _coerced_.\n          1. For each element _number_ of _coerced_, do\n            1. If _number_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return *+∞*<sub>𝔽</sub>.\n          1. Let _onlyZero_ be *true*.\n          1. For each element _number_ of _coerced_, do\n            1. If _number_ is *NaN*, return *NaN*.\n            1. If _number_ is neither *+0*<sub>𝔽</sub> nor *-0*<sub>𝔽</sub>, set _onlyZero_ to *false*.\n          1. If _onlyZero_ is *true*, return *+0*<sub>𝔽</sub>.\n          1. Return an implementation-approximated Number value representing the square root of the sum of squares of the mathematical values of the elements of _coerced_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"imul"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}},{"name":"y","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _a_ be ℝ(? ToUint32(_x_)).\n  1. Let _b_ be ℝ(? ToUint32(_y_)).\n  1. Let _product_ be _a_ × _b_ modulo 2<sup>32</sup>.\n  1. If _product_ ≥ 2<sup>31</sup>, return 𝔽(_product_ - 2<sup>32</sup>).\n  1. Else, return 𝔽(_product_).","code":"\n          1. Let _a_ be ℝ(? ToUint32(_x_)).\n          1. Let _b_ be ℝ(? ToUint32(_y_)).\n          1. Let _product_ be (_a_ × _b_) modulo 2<sup>32</sup>.\n          1. If _product_ ≥ 2<sup>31</sup>, return 𝔽(_product_ - 2<sup>32</sup>); otherwise return 𝔽(_product_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"log"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _n_ be ? ToNumber(_x_).\n  1. If _n_ is either *NaN* or *+∞*<sub>𝔽</sub>, return _n_.\n  1. If _n_ is *1*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n  1. If _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *-∞*<sub>𝔽</sub>.\n  1. If _n_ < *-0*<sub>𝔽</sub>, return *NaN*.\n  1. Return an implementation-approximated Number value representing the natural logarithm of ℝ(_n_).","code":"\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is either *NaN* or *+∞*<sub>𝔽</sub>, return _n_.\n          1. If _n_ is *1*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n          1. If _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *-∞*<sub>𝔽</sub>.\n          1. If _n_ < *-0*<sub>𝔽</sub>, return *NaN*.\n          1. Return an implementation-approximated Number value representing the result of the natural logarithm of ℝ(_n_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"log1p"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _n_ be ? ToNumber(_x_).\n  1. If _n_ is either *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, or *+∞*<sub>𝔽</sub>, return _n_.\n  1. If _n_ is *-1*<sub>𝔽</sub>, return *-∞*<sub>𝔽</sub>.\n  1. If _n_ < *-1*<sub>𝔽</sub>, return *NaN*.\n  1. Return an implementation-approximated Number value representing the natural logarithm of 1 + ℝ(_n_).","code":"\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, or *+∞*<sub>𝔽</sub>, return _n_.\n          1. If _n_ is *-1*<sub>𝔽</sub>, return *-∞*<sub>𝔽</sub>.\n          1. If _n_ < *-1*<sub>𝔽</sub>, return *NaN*.\n          1. Return an implementation-approximated Number value representing the result of the natural logarithm of 1 + ℝ(_n_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"log10"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _n_ be ? ToNumber(_x_).\n  1. If _n_ is either *NaN* or *+∞*<sub>𝔽</sub>, return _n_.\n  1. If _n_ is *1*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n  1. If _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *-∞*<sub>𝔽</sub>.\n  1. If _n_ < *-0*<sub>𝔽</sub>, return *NaN*.\n  1. Return an implementation-approximated Number value representing the base 10 logarithm of ℝ(_n_).","code":"\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is either *NaN* or *+∞*<sub>𝔽</sub>, return _n_.\n          1. If _n_ is *1*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n          1. If _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *-∞*<sub>𝔽</sub>.\n          1. If _n_ < *-0*<sub>𝔽</sub>, return *NaN*.\n          1. Return an implementation-approximated Number value representing the result of the base 10 logarithm of ℝ(_n_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"log2"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _n_ be ? ToNumber(_x_).\n  1. If _n_ is either *NaN* or *+∞*<sub>𝔽</sub>, return _n_.\n  1. If _n_ is *1*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n  1. If _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *-∞*<sub>𝔽</sub>.\n  1. If _n_ < *-0*<sub>𝔽</sub>, return *NaN*.\n  1. Return an implementation-approximated Number value representing the base 2 logarithm of ℝ(_n_).","code":"\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is either *NaN* or *+∞*<sub>𝔽</sub>, return _n_.\n          1. If _n_ is *1*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n          1. If _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return *-∞*<sub>𝔽</sub>.\n          1. If _n_ < *-0*<sub>𝔽</sub>, return *NaN*.\n          1. Return an implementation-approximated Number value representing the result of the base 2 logarithm of ℝ(_n_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"max"}},"params":[{"name":"args","ty":"Unknown","kind":{"Variadic":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _coerced_ be « ».\n  1. For each _arg_ of _args_, do\n    1. Let _n_ be ? ToNumber(_arg_).\n    1. Append _n_ to _coerced_.\n  1. Let _highest_ be *-∞*<sub>𝔽</sub>.\n  1. For each _number_ of _coerced_, do\n    1. If _number_ is *NaN*, return *NaN*.\n    1. If _number_ is *+0*<sub>𝔽</sub> and _highest_ is *-0*<sub>𝔽</sub>, set _highest_ to *+0*<sub>𝔽</sub>.\n    1. If _number_ > _highest_, set _highest_ to _number_.\n  1. Return _highest_.","code":"\n          1. Let _coerced_ be a new empty List.\n          1. For each element _arg_ of _args_, do\n            1. Let _n_ be ? ToNumber(_arg_).\n            1. Append _n_ to _coerced_.\n          1. Let _highest_ be *-∞*<sub>𝔽</sub>.\n          1. For each element _number_ of _coerced_, do\n            1. If _number_ is *NaN*, return *NaN*.\n            1. If _number_ is *+0*<sub>𝔽</sub> and _highest_ is *-0*<sub>𝔽</sub>, set _highest_ to *+0*<sub>𝔽</sub>.\n            1. If _number_ > _highest_, set _highest_ to _number_.\n          1. Return _highest_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"min"}},"params":[{"name":"args","ty":"Unknown","kind":{"Variadic":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _coerced_ be « ».\n  1. For each _arg_ of _args_, do\n    1. Let _n_ be ? ToNumber(_arg_).\n    1. Append _n_ to _coerced_.\n  1. Let _lowest_ be *+∞*<sub>𝔽</sub>.\n  1. For each _number_ of _coerced_, do\n    1. If _number_ is *NaN*, return *NaN*.\n    1. If _number_ is *-0*<sub>𝔽</sub> and _lowest_ is *+0*<sub>𝔽</sub>, set _lowest_ to *-0*<sub>𝔽</sub>.\n    1. If _number_ < _lowest_, set _lowest_ to _number_.\n  1. Return _lowest_.","code":"\n          1. Let _coerced_ be a new empty List.\n          1. For each element _arg_ of _args_, do\n            1. Let _n_ be ? ToNumber(_arg_).\n            1. Append _n_ to _coerced_.\n          1. Let _lowest_ be *+∞*<sub>𝔽</sub>.\n          1. For each element _number_ of _coerced_, do\n            1. If _number_ is *NaN*, return *NaN*.\n            1. If _number_ is *-0*<sub>𝔽</sub> and _lowest_ is *+0*<sub>𝔽</sub>, set _lowest_ to *-0*<sub>𝔽</sub>.\n            1. If _number_ < _lowest_, set _lowest_ to _number_.\n          1. Return _lowest_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"pow"}},"params":[{"name":"base","ty":"Unknown","kind":{"Normal":{}}},{"name":"exponent","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Set _base_ to ? ToNumber(_base_).\n  1. Set _exponent_ to ? ToNumber(_exponent_).\n  1. Return Number::exponentiate(_base_, _exponent_).","code":"\n          1. Set _base_ to ? ToNumber(_base_).\n          1. Set _exponent_ to ? ToNumber(_exponent_).\n          1. Return Number::exponentiate(_base_, _exponent_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"round"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _n_ be ? ToNumber(_x_).\n  1. If _n_ is not finite or _n_ is a Number[Int], return _n_.\n  1. If _n_ < *0.5*<sub>𝔽</sub> and _n_ > *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n  1. If _n_ < *-0*<sub>𝔽</sub> and _n_ ≥ *-0.5*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.\n  1. Return the integral Number closest to _n_, preferring the Number closer to +∞ in the case of a tie.","code":"\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is not finite or _n_ is an integral Number, return _n_.\n          1. If _n_ < *0.5*<sub>𝔽</sub> and _n_ > *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n          1. If _n_ < *-0*<sub>𝔽</sub> and _n_ ≥ *-0.5*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.\n          1. Return the integral Number closest to _n_, preferring the Number closer to +∞ in the case of a tie.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"sign"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _n_ be ? ToNumber(_x_).\n  1. If _n_ is either *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return _n_.\n  1. If _n_ < *-0*<sub>𝔽</sub>, return *-1*<sub>𝔽</sub>.\n  1. Return *1*<sub>𝔽</sub>.","code":"\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return _n_.\n          1. If _n_ < *-0*<sub>𝔽</sub>, return *-1*<sub>𝔽</sub>.\n          1. Return *1*<sub>𝔽</sub>.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"sin"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _n_ be ? ToNumber(_x_).\n  1. If _n_ is either *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return _n_.\n  1. If _n_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return *NaN*.\n  1. Return an implementation-approximated Number value representing the sine of ℝ(_n_).","code":"\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return _n_.\n          1. If _n_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return *NaN*.\n          1. Return an implementation-approximated Number value representing the result of the sine of ℝ(_n_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"sinh"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _n_ be ? ToNumber(_x_).\n  1. If _n_ is not finite or _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return _n_.\n  1. Return an implementation-approximated Number value representing the hyperbolic sine of ℝ(_n_).","code":"\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is not finite or _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return _n_.\n          1. Return an implementation-approximated Number value representing the result of the hyperbolic sine of ℝ(_n_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"sqrt"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _n_ be ? ToNumber(_x_).\n  1. If _n_ is either *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, or *+∞*<sub>𝔽</sub>, return _n_.\n  1. If _n_ < *-0*<sub>𝔽</sub>, return *NaN*.\n  1. Return an implementation-approximated Number value representing the square root of ℝ(_n_).","code":"\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, *-0*<sub>𝔽</sub>, or *+∞*<sub>𝔽</sub>, return _n_.\n          1. If _n_ < *-0*<sub>𝔽</sub>, return *NaN*.\n          1. Return an implementation-approximated Number value representing the result of the square root of ℝ(_n_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"tan"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _n_ be ? ToNumber(_x_).\n  1. If _n_ is either *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return _n_.\n  1. If _n_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return *NaN*.\n  1. Return an implementation-approximated Number value representing the tangent of ℝ(_n_).","code":"\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return _n_.\n          1. If _n_ is either *+∞*<sub>𝔽</sub> or *-∞*<sub>𝔽</sub>, return *NaN*.\n          1. Return an implementation-approximated Number value representing the result of the tangent of ℝ(_n_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"tanh"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _n_ be ? ToNumber(_x_).\n  1. If _n_ is either *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return _n_.\n  1. If _n_ is *+∞*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.\n  1. If _n_ is *-∞*<sub>𝔽</sub>, return *-1*<sub>𝔽</sub>.\n  1. Return an implementation-approximated Number value representing the hyperbolic tangent of ℝ(_n_).","code":"\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is one of *NaN*, *+0*<sub>𝔽</sub>, or *-0*<sub>𝔽</sub>, return _n_.\n          1. If _n_ is *+∞*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.\n          1. If _n_ is *-∞*<sub>𝔽</sub>, return *-1*<sub>𝔽</sub>.\n          1. Return an implementation-approximated Number value representing the result of the hyperbolic tangent of ℝ(_n_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Math"}},"name":"trunc"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _n_ be ? ToNumber(_x_).\n  1. If _n_ is not finite or _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return _n_.\n  1. If _n_ < *1*<sub>𝔽</sub> and _n_ > *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n  1. If _n_ < *-0*<sub>𝔽</sub> and _n_ > *-1*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.\n  1. Return the integral Number nearest _n_ in the direction of *+0*<sub>𝔽</sub>.","code":"\n          1. Let _n_ be ? ToNumber(_x_).\n          1. If _n_ is not finite or _n_ is either *+0*<sub>𝔽</sub> or *-0*<sub>𝔽</sub>, return _n_.\n          1. If _n_ < *1*<sub>𝔽</sub> and _n_ > *+0*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n          1. If _n_ < *-0*<sub>𝔽</sub> and _n_ > *-1*<sub>𝔽</sub>, return *-0*<sub>𝔽</sub>.\n          1. Return the integral Number nearest _n_ in the direction of *+0*<sub>𝔽</sub>.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"Day","params":[{"name":"t","ty":"Unknown[\"a finite time value\"]","kind":{"Normal":{}}}],"retTy":"Number[Int]"}},"body":"\n  1. Return 𝔽(floor(ℝ(_t_ / msPerDay))).","code":"\n          1. Return 𝔽(floor(ℝ(_t_ / msPerDay))).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"TimeWithinDay","params":[{"name":"t","ty":"Unknown[\"a finite time value\"]","kind":{"Normal":{}}}],"retTy":"Unknown[\"an integral Number in the interval from *+0*<sub>𝔽</sub> (inclusive) to msPerDay (exclusive)\"]"}},"body":"\n  1. Return 𝔽(ℝ(_t_) modulo ℝ(msPerDay)).","code":"\n          1. Return 𝔽(ℝ(_t_) modulo ℝ(msPerDay)).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"DaysInYear","params":[{"name":"y","ty":"Number[Int]","kind":{"Normal":{}}}],"retTy":"Unknown[\"*365*<sub>𝔽</sub> or *366*<sub>𝔽</sub>\"]"}},"body":"\n  1. Let _ry_ be ℝ(_y_).\n  1. If _ry_ modulo 400 = 0, return *366*<sub>𝔽</sub>.\n  1. If _ry_ modulo 100 = 0, return *365*<sub>𝔽</sub>.\n  1. If _ry_ modulo 4 = 0, return *366*<sub>𝔽</sub>.\n  1. Return *365*<sub>𝔽</sub>.","code":"\n          1. Let _ry_ be ℝ(_y_).\n          1. If (_ry_ modulo 400) = 0, return *366*<sub>𝔽</sub>.\n          1. If (_ry_ modulo 100) = 0, return *365*<sub>𝔽</sub>.\n          1. If (_ry_ modulo 4) = 0, return *366*<sub>𝔽</sub>.\n          1. Return *365*<sub>𝔽</sub>.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"DayFromYear","params":[{"name":"y","ty":"Number[Int]","kind":{"Normal":{}}}],"retTy":"Number[Int]"}},"body":"\n  1. Let _ry_ be ℝ(_y_).\n  1. [declared=\"numYears1,numYears4,numYears100,numYears400\"] NOTE: In the following steps, _numYears1_, _numYears4_, _numYears100_, and _numYears400_ represent the number of years divisible by 1, 4, 100, and 400, respectively, that occur between the epoch and the start of year _y_. The number is negative if _y_ is before the epoch.\n  1. Let _numYears1_ be _ry_ - 1970.\n  1. Let _numYears4_ be floor((_ry_ - 1969) / 4).\n  1. Let _numYears100_ be floor((_ry_ - 1901) / 100).\n  1. Let _numYears400_ be floor((_ry_ - 1601) / 400).\n  1. Return 𝔽(365 × _numYears1_ + _numYears4_ - _numYears100_ + _numYears400_).","code":"\n          1. Let _ry_ be ℝ(_y_).\n          1. [declared=\"numYears1,numYears4,numYears100,numYears400\"] NOTE: In the following steps, _numYears1_, _numYears4_, _numYears100_, and _numYears400_ represent the number of years divisible by 1, 4, 100, and 400, respectively, that occur between the epoch and the start of year _y_. The number is negative if _y_ is before the epoch.\n          1. Let _numYears1_ be (_ry_ - 1970).\n          1. Let _numYears4_ be floor((_ry_ - 1969) / 4).\n          1. Let _numYears100_ be floor((_ry_ - 1901) / 100).\n          1. Let _numYears400_ be floor((_ry_ - 1601) / 400).\n          1. Return 𝔽(365 × _numYears1_ + _numYears4_ - _numYears100_ + _numYears400_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"TimeFromYear","params":[{"name":"y","ty":"Number[Int]","kind":{"Normal":{}}}],"retTy":"Unknown[\"a time value\"]"}},"body":"\n  1. Return msPerDay × DayFromYear(_y_).","code":"\n          1. Return msPerDay × DayFromYear(_y_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"YearFromTime","params":[{"name":"t","ty":"Unknown[\"a finite time value\"]","kind":{"Normal":{}}}],"retTy":"Number[Int]"}},"body":"\n  1. [declared=\"y\"] Return the largest integral Number _y_ (closest to +∞) such that TimeFromYear(_y_) ≤ _t_.","code":"\n          1. [declared=\"y\"] Return the largest integral Number _y_ (closest to +∞) such that TimeFromYear(_y_) ≤ _t_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"DayWithinYear","params":[{"name":"t","ty":"Unknown[\"a finite time value\"]","kind":{"Normal":{}}}],"retTy":"Unknown[\"an integral Number in the inclusive interval from *+0*<sub>𝔽</sub> to *365*<sub>𝔽</sub>\"]"}},"body":"\n  1. Return Day(_t_) - DayFromYear(YearFromTime(_t_)).","code":"\n          1. Return Day(_t_) - DayFromYear(YearFromTime(_t_)).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"InLeapYear","params":[{"name":"t","ty":"Unknown[\"a finite time value\"]","kind":{"Normal":{}}}],"retTy":"Unknown[\"*+0*<sub>𝔽</sub> or *1*<sub>𝔽</sub>\"]"}},"body":"\n  1. If DaysInYear(YearFromTime(_t_)) is *366*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.\n  1. Else, return *+0*<sub>𝔽</sub>.","code":"\n          1. If DaysInYear(YearFromTime(_t_)) is *366*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>; else return *+0*<sub>𝔽</sub>.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"MonthFromTime","params":[{"name":"t","ty":"Unknown[\"a finite time value\"]","kind":{"Normal":{}}}],"retTy":"Unknown[\"an integral Number in the inclusive interval from *+0*<sub>𝔽</sub> to *11*<sub>𝔽</sub>\"]"}},"body":"\n  1. Let _inLeapYear_ be InLeapYear(_t_).\n  1. Let _dayWithinYear_ be DayWithinYear(_t_).\n  1. If _dayWithinYear_ < *31*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n  1. If _dayWithinYear_ < *59*<sub>𝔽</sub> + _inLeapYear_, return *1*<sub>𝔽</sub>.\n  1. If _dayWithinYear_ < *90*<sub>𝔽</sub> + _inLeapYear_, return *2*<sub>𝔽</sub>.\n  1. If _dayWithinYear_ < *120*<sub>𝔽</sub> + _inLeapYear_, return *3*<sub>𝔽</sub>.\n  1. If _dayWithinYear_ < *151*<sub>𝔽</sub> + _inLeapYear_, return *4*<sub>𝔽</sub>.\n  1. If _dayWithinYear_ < *181*<sub>𝔽</sub> + _inLeapYear_, return *5*<sub>𝔽</sub>.\n  1. If _dayWithinYear_ < *212*<sub>𝔽</sub> + _inLeapYear_, return *6*<sub>𝔽</sub>.\n  1. If _dayWithinYear_ < *243*<sub>𝔽</sub> + _inLeapYear_, return *7*<sub>𝔽</sub>.\n  1. If _dayWithinYear_ < *273*<sub>𝔽</sub> + _inLeapYear_, return *8*<sub>𝔽</sub>.\n  1. If _dayWithinYear_ < *304*<sub>𝔽</sub> + _inLeapYear_, return *9*<sub>𝔽</sub>.\n  1. If _dayWithinYear_ < *334*<sub>𝔽</sub> + _inLeapYear_, return *10*<sub>𝔽</sub>.\n  1. Assert: _dayWithinYear_ < *365*<sub>𝔽</sub> + _inLeapYear_.\n  1. Return *11*<sub>𝔽</sub>.","code":"\n          1. Let _inLeapYear_ be InLeapYear(_t_).\n          1. Let _dayWithinYear_ be DayWithinYear(_t_).\n          1. If _dayWithinYear_ < *31*<sub>𝔽</sub>, return *+0*<sub>𝔽</sub>.\n          1. If _dayWithinYear_ < *59*<sub>𝔽</sub> + _inLeapYear_, return *1*<sub>𝔽</sub>.\n          1. If _dayWithinYear_ < *90*<sub>𝔽</sub> + _inLeapYear_, return *2*<sub>𝔽</sub>.\n          1. If _dayWithinYear_ < *120*<sub>𝔽</sub> + _inLeapYear_, return *3*<sub>𝔽</sub>.\n          1. If _dayWithinYear_ < *151*<sub>𝔽</sub> + _inLeapYear_, return *4*<sub>𝔽</sub>.\n          1. If _dayWithinYear_ < *181*<sub>𝔽</sub> + _inLeapYear_, return *5*<sub>𝔽</sub>.\n          1. If _dayWithinYear_ < *212*<sub>𝔽</sub> + _inLeapYear_, return *6*<sub>𝔽</sub>.\n          1. If _dayWithinYear_ < *243*<sub>𝔽</sub> + _inLeapYear_, return *7*<sub>𝔽</sub>.\n          1. If _dayWithinYear_ < *273*<sub>𝔽</sub> + _inLeapYear_, return *8*<sub>𝔽</sub>.\n          1. If _dayWithinYear_ < *304*<sub>𝔽</sub> + _inLeapYear_, return *9*<sub>𝔽</sub>.\n          1. If _dayWithinYear_ < *334*<sub>𝔽</sub> + _inLeapYear_, return *10*<sub>𝔽</sub>.\n          1. Assert: _dayWithinYear_ < *365*<sub>𝔽</sub> + _inLeapYear_.\n          1. Return *11*<sub>𝔽</sub>.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"DateFromTime","params":[{"name":"t","ty":"Unknown[\"a finite time value\"]","kind":{"Normal":{}}}],"retTy":"Unknown[\"an integral Number in the inclusive interval from *1*<sub>𝔽</sub> to *31*<sub>𝔽</sub>\"]"}},"body":"\n  1. Let _inLeapYear_ be InLeapYear(_t_).\n  1. Let _dayWithinYear_ be DayWithinYear(_t_).\n  1. Let _month_ be MonthFromTime(_t_).\n  1. If _month_ is *+0*<sub>𝔽</sub>, return _dayWithinYear_ + *1*<sub>𝔽</sub>.\n  1. If _month_ is *1*<sub>𝔽</sub>, return _dayWithinYear_ - *30*<sub>𝔽</sub>.\n  1. If _month_ is *2*<sub>𝔽</sub>, return _dayWithinYear_ - *58*<sub>𝔽</sub> - _inLeapYear_.\n  1. If _month_ is *3*<sub>𝔽</sub>, return _dayWithinYear_ - *89*<sub>𝔽</sub> - _inLeapYear_.\n  1. If _month_ is *4*<sub>𝔽</sub>, return _dayWithinYear_ - *119*<sub>𝔽</sub> - _inLeapYear_.\n  1. If _month_ is *5*<sub>𝔽</sub>, return _dayWithinYear_ - *150*<sub>𝔽</sub> - _inLeapYear_.\n  1. If _month_ is *6*<sub>𝔽</sub>, return _dayWithinYear_ - *180*<sub>𝔽</sub> - _inLeapYear_.\n  1. If _month_ is *7*<sub>𝔽</sub>, return _dayWithinYear_ - *211*<sub>𝔽</sub> - _inLeapYear_.\n  1. If _month_ is *8*<sub>𝔽</sub>, return _dayWithinYear_ - *242*<sub>𝔽</sub> - _inLeapYear_.\n  1. If _month_ is *9*<sub>𝔽</sub>, return _dayWithinYear_ - *272*<sub>𝔽</sub> - _inLeapYear_.\n  1. If _month_ is *10*<sub>𝔽</sub>, return _dayWithinYear_ - *303*<sub>𝔽</sub> - _inLeapYear_.\n  1. Assert: _month_ is *11*<sub>𝔽</sub>.\n  1. Return _dayWithinYear_ - *333*<sub>𝔽</sub> - _inLeapYear_.","code":"\n          1. Let _inLeapYear_ be InLeapYear(_t_).\n          1. Let _dayWithinYear_ be DayWithinYear(_t_).\n          1. Let _month_ be MonthFromTime(_t_).\n          1. If _month_ is *+0*<sub>𝔽</sub>, return _dayWithinYear_ + *1*<sub>𝔽</sub>.\n          1. If _month_ is *1*<sub>𝔽</sub>, return _dayWithinYear_ - *30*<sub>𝔽</sub>.\n          1. If _month_ is *2*<sub>𝔽</sub>, return _dayWithinYear_ - *58*<sub>𝔽</sub> - _inLeapYear_.\n          1. If _month_ is *3*<sub>𝔽</sub>, return _dayWithinYear_ - *89*<sub>𝔽</sub> - _inLeapYear_.\n          1. If _month_ is *4*<sub>𝔽</sub>, return _dayWithinYear_ - *119*<sub>𝔽</sub> - _inLeapYear_.\n          1. If _month_ is *5*<sub>𝔽</sub>, return _dayWithinYear_ - *150*<sub>𝔽</sub> - _inLeapYear_.\n          1. If _month_ is *6*<sub>𝔽</sub>, return _dayWithinYear_ - *180*<sub>𝔽</sub> - _inLeapYear_.\n          1. If _month_ is *7*<sub>𝔽</sub>, return _dayWithinYear_ - *211*<sub>𝔽</sub> - _inLeapYear_.\n          1. If _month_ is *8*<sub>𝔽</sub>, return _dayWithinYear_ - *242*<sub>𝔽</sub> - _inLeapYear_.\n          1. If _month_ is *9*<sub>𝔽</sub>, return _dayWithinYear_ - *272*<sub>𝔽</sub> - _inLeapYear_.\n          1. If _month_ is *10*<sub>𝔽</sub>, return _dayWithinYear_ - *303*<sub>𝔽</sub> - _inLeapYear_.\n          1. Assert: _month_ is *11*<sub>𝔽</sub>.\n          1. Return _dayWithinYear_ - *333*<sub>𝔽</sub> - _inLeapYear_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"WeekDay","params":[{"name":"t","ty":"Unknown[\"a finite time value\"]","kind":{"Normal":{}}}],"retTy":"Unknown[\"an integral Number in the inclusive interval from *+0*<sub>𝔽</sub> to *6*<sub>𝔽</sub>\"]"}},"body":"\n  1. Return 𝔽(ℝ(Day(_t_) + *4*<sub>𝔽</sub>) modulo 7).","code":"\n          1. Return 𝔽(ℝ(Day(_t_) + *4*<sub>𝔽</sub>) modulo 7).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"HourFromTime","params":[{"name":"t","ty":"Unknown[\"a finite time value\"]","kind":{"Normal":{}}}],"retTy":"Unknown[\"an integral Number in the inclusive interval from *+0*<sub>𝔽</sub> to *23*<sub>𝔽</sub>\"]"}},"body":"\n  1. Return 𝔽(floor(ℝ(_t_ / msPerHour)) modulo HoursPerDay).","code":"\n          1. Return 𝔽(floor(ℝ(_t_ / msPerHour)) modulo HoursPerDay).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"MinFromTime","params":[{"name":"t","ty":"Unknown[\"a finite time value\"]","kind":{"Normal":{}}}],"retTy":"Unknown[\"an integral Number in the inclusive interval from *+0*<sub>𝔽</sub> to *59*<sub>𝔽</sub>\"]"}},"body":"\n  1. Return 𝔽(floor(ℝ(_t_ / msPerMinute)) modulo MinutesPerHour).","code":"\n          1. Return 𝔽(floor(ℝ(_t_ / msPerMinute)) modulo MinutesPerHour).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"SecFromTime","params":[{"name":"t","ty":"Unknown[\"a finite time value\"]","kind":{"Normal":{}}}],"retTy":"Unknown[\"an integral Number in the inclusive interval from *+0*<sub>𝔽</sub> to *59*<sub>𝔽</sub>\"]"}},"body":"\n  1. Return 𝔽(floor(ℝ(_t_ / msPerSecond)) modulo SecondsPerMinute).","code":"\n          1. Return 𝔽(floor(ℝ(_t_ / msPerSecond)) modulo SecondsPerMinute).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"msFromTime","params":[{"name":"t","ty":"Unknown[\"a finite time value\"]","kind":{"Normal":{}}}],"retTy":"Unknown[\"an integral Number in the inclusive interval from *+0*<sub>𝔽</sub> to *999*<sub>𝔽</sub>\"]"}},"body":"\n  1. Return 𝔽(ℝ(_t_) modulo ℝ(msPerSecond)).","code":"\n          1. Return 𝔽(ℝ(_t_) modulo ℝ(msPerSecond)).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetUTCEpochNanoseconds","params":[{"name":"year","ty":"Int","kind":{"Normal":{}}},{"name":"month","ty":"Unknown[\"an integer in the inclusive interval from 1 to 12\"]","kind":{"Normal":{}}},{"name":"day","ty":"Unknown[\"an integer in the inclusive interval from 1 to 31\"]","kind":{"Normal":{}}},{"name":"hour","ty":"Unknown[\"an integer in the inclusive interval from 0 to 23\"]","kind":{"Normal":{}}},{"name":"minute","ty":"Unknown[\"an integer in the inclusive interval from 0 to 59\"]","kind":{"Normal":{}}},{"name":"second","ty":"Unknown[\"an integer in the inclusive interval from 0 to 59\"]","kind":{"Normal":{}}},{"name":"millisecond","ty":"Unknown[\"an integer in the inclusive interval from 0 to 999\"]","kind":{"Normal":{}}},{"name":"microsecond","ty":"Unknown[\"an integer in the inclusive interval from 0 to 999\"]","kind":{"Normal":{}}},{"name":"nanosecond","ty":"Unknown[\"an integer in the inclusive interval from 0 to 999\"]","kind":{"Normal":{}}}],"retTy":"BigInt"}},"body":"\n  1. Let _date_ be MakeDay(𝔽(_year_), 𝔽(_month_ - 1), 𝔽(_day_)).\n  1. Let _time_ be MakeTime(𝔽(_hour_), 𝔽(_minute_), 𝔽(_second_), 𝔽(_millisecond_)).\n  1. Let _ms_ be MakeDate(_date_, _time_).\n  1. Assert: _ms_ is a Number[Int].\n  1. Return ℤ(ℝ(_ms_) × 10<sup>6</sup> + _microsecond_ × 10<sup>3</sup> + _nanosecond_).","code":"\n          1. Let _date_ be MakeDay(𝔽(_year_), 𝔽(_month_ - 1), 𝔽(_day_)).\n          1. Let _time_ be MakeTime(𝔽(_hour_), 𝔽(_minute_), 𝔽(_second_), 𝔽(_millisecond_)).\n          1. Let _ms_ be MakeDate(_date_, _time_).\n          1. Assert: _ms_ is an integral Number.\n          1. Return ℤ(ℝ(_ms_) × 10<sup>6</sup> + _microsecond_ × 10<sup>3</sup> + _nanosecond_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":true,"name":"GetNamedTimeZoneEpochNanoseconds","params":[{"name":"timeZoneIdentifier","ty":"String","kind":{"Normal":{}}},{"name":"year","ty":"Int","kind":{"Normal":{}}},{"name":"month","ty":"Unknown[\"an integer in the inclusive interval from 1 to 12\"]","kind":{"Normal":{}}},{"name":"day","ty":"Unknown[\"an integer in the inclusive interval from 1 to 31\"]","kind":{"Normal":{}}},{"name":"hour","ty":"Unknown[\"an integer in the inclusive interval from 0 to 23\"]","kind":{"Normal":{}}},{"name":"minute","ty":"Unknown[\"an integer in the inclusive interval from 0 to 59\"]","kind":{"Normal":{}}},{"name":"second","ty":"Unknown[\"an integer in the inclusive interval from 0 to 59\"]","kind":{"Normal":{}}},{"name":"millisecond","ty":"Unknown[\"an integer in the inclusive interval from 0 to 999\"]","kind":{"Normal":{}}},{"name":"microsecond","ty":"Unknown[\"an integer in the inclusive interval from 0 to 999\"]","kind":{"Normal":{}}},{"name":"nanosecond","ty":"Unknown[\"an integer in the inclusive interval from 0 to 999\"]","kind":{"Normal":{}}}],"retTy":"List[BigInt]"}},"body":"\n  1. Assert: _timeZoneIdentifier_ is *\"UTC\"*.\n  1. Let _epochNanoseconds_ be GetUTCEpochNanoseconds(_year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_).\n  1. Return « _epochNanoseconds_ ».","code":"\n          1. Assert: _timeZoneIdentifier_ is *\"UTC\"*.\n          1. Let _epochNanoseconds_ be GetUTCEpochNanoseconds(_year_, _month_, _day_, _hour_, _minute_, _second_, _millisecond_, _microsecond_, _nanosecond_).\n          1. Return « _epochNanoseconds_ ».\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":true,"name":"GetNamedTimeZoneOffsetNanoseconds","params":[{"name":"timeZoneIdentifier","ty":"String","kind":{"Normal":{}}},{"name":"epochNanoseconds","ty":"BigInt","kind":{"Normal":{}}}],"retTy":"Int"}},"body":"\n  1. Assert: _timeZoneIdentifier_ is *\"UTC\"*.\n  1. Return 0.","code":"\n          1. Assert: _timeZoneIdentifier_ is *\"UTC\"*.\n          1. Return 0.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":true,"name":"AvailableNamedTimeZoneIdentifiers","params":[],"retTy":"List[Record[TimeZoneIdentifierRecord]]"}},"body":"\n  1. If the implementation does not include local political rules for any time zones, then\n    1. Return « Time Zone Identifier Record { [[Identifier]]: *\"UTC\"*, [[PrimaryIdentifier]]: *\"UTC\"* } ».\n  1. Let _identifiers_ be the List of unique available named time zone identifiers.\n  1. [declared=\"comparefn\"] Sort _identifiers_ into the same order as if an Array of the same values had been sorted using %Array.prototype.sort% with *undefined* as _comparefn_.\n  1. Let _result_ be « ».\n  1. For each _identifier_ of _identifiers_, do\n    1. Let _primary_ be _identifier_.\n    1. If _identifier_ is a non-primary time zone identifier in this implementation and _identifier_ is not *\"UTC\"*, then\n      1. Set _primary_ to the primary time zone identifier associated with _identifier_.\n      1. NOTE: An implementation may need to resolve _identifier_ iteratively to obtain the primary time zone identifier.\n    1. Let _record_ be Time Zone Identifier Record { [[Identifier]]: _identifier_, [[PrimaryIdentifier]]: _primary_ }.\n    1. Append _record_ to _result_.\n  1. Assert: _result_ contains a Record[TimeZoneIdentifierRecord] _r_ such that _r_.[[Identifier]] is *\"UTC\"* and _r_.[[PrimaryIdentifier]] is *\"UTC\"*.\n  1. Return _result_.","code":"\n          1. If the implementation does not include local political rules for any time zones, then\n            1. Return « the Time Zone Identifier Record { [[Identifier]]: *\"UTC\"*, [[PrimaryIdentifier]]: *\"UTC\"* } ».\n          1. Let _identifiers_ be the List of unique available named time zone identifiers.\n          1. [declared=\"comparefn\"] Sort _identifiers_ into the same order as if an Array of the same values had been sorted using %Array.prototype.sort% with *undefined* as _comparefn_.\n          1. Let _result_ be a new empty List.\n          1. For each element _identifier_ of _identifiers_, do\n            1. Let _primary_ be _identifier_.\n            1. If _identifier_ is a non-primary time zone identifier in this implementation and _identifier_ is not *\"UTC\"*, then\n              1. Set _primary_ to the primary time zone identifier associated with _identifier_.\n              1. NOTE: An implementation may need to resolve _identifier_ iteratively to obtain the primary time zone identifier.\n            1. Let _record_ be the Time Zone Identifier Record { [[Identifier]]: _identifier_, [[PrimaryIdentifier]]: _primary_ }.\n            1. Append _record_ to _result_.\n          1. Assert: _result_ contains a Time Zone Identifier Record _r_ such that _r_.[[Identifier]] is *\"UTC\"* and _r_.[[PrimaryIdentifier]] is *\"UTC\"*.\n          1. Return _result_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":true,"name":"SystemTimeZoneIdentifier","params":[],"retTy":"String"}},"body":"\n  1. If the implementation only supports the UTC time zone, return *\"UTC\"*.\n  1. Let _systemTimeZoneString_ be the String representing the host environment's current time zone, either a primary time zone identifier or an offset time zone identifier.\n  1. Return _systemTimeZoneString_.","code":"\n          1. If the implementation only supports the UTC time zone, return *\"UTC\"*.\n          1. Let _systemTimeZoneString_ be the String representing the host environment's current time zone, either a primary time zone identifier or an offset time zone identifier.\n          1. Return _systemTimeZoneString_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"LocalTime","params":[{"name":"t","ty":"Unknown[\"a finite time value\"]","kind":{"Normal":{}}}],"retTy":"Number[Int]"}},"body":"\n  1. Let _systemTimeZoneIdentifier_ be SystemTimeZoneIdentifier().\n  1. If IsTimeZoneOffsetString(_systemTimeZoneIdentifier_) is *true*, then\n    1. Let _offsetNs_ be ParseTimeZoneOffsetString(_systemTimeZoneIdentifier_).\n  1. Else,\n    1. Let _offsetNs_ be GetNamedTimeZoneOffsetNanoseconds(_systemTimeZoneIdentifier_, ℤ(ℝ(_t_) × 10<sup>6</sup>)).\n  1. Let _offsetMs_ be truncate(_offsetNs_ / 10<sup>6</sup>).\n  1. Return _t_ + 𝔽(_offsetMs_).","code":"\n          1. Let _systemTimeZoneIdentifier_ be SystemTimeZoneIdentifier().\n          1. If IsTimeZoneOffsetString(_systemTimeZoneIdentifier_) is *true*, then\n            1. Let _offsetNs_ be ParseTimeZoneOffsetString(_systemTimeZoneIdentifier_).\n          1. Else,\n            1. Let _offsetNs_ be GetNamedTimeZoneOffsetNanoseconds(_systemTimeZoneIdentifier_, ℤ(ℝ(_t_) × 10<sup>6</sup>)).\n          1. Let _offsetMs_ be truncate(_offsetNs_ / 10<sup>6</sup>).\n          1. Return _t_ + 𝔽(_offsetMs_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"UTC","params":[{"name":"t","ty":"Number","kind":{"Normal":{}}}],"retTy":"Unknown[\"a time value\"]"}},"body":"\n  1. If _t_ is not finite, return *NaN*.\n  1. Let _systemTimeZoneIdentifier_ be SystemTimeZoneIdentifier().\n  1. If IsTimeZoneOffsetString(_systemTimeZoneIdentifier_) is *true*, then\n    1. Let _offsetNs_ be ParseTimeZoneOffsetString(_systemTimeZoneIdentifier_).\n  1. Else,\n    1. Let _possibleInstants_ be GetNamedTimeZoneEpochNanoseconds(_systemTimeZoneIdentifier_, ℝ(YearFromTime(_t_)), ℝ(MonthFromTime(_t_)) + 1, ℝ(DateFromTime(_t_)), ℝ(HourFromTime(_t_)), ℝ(MinFromTime(_t_)), ℝ(SecFromTime(_t_)), ℝ(msFromTime(_t_)), 0, 0).\n    1. NOTE: The following steps ensure that when _t_ represents local time repeating multiple times at a negative time zone transition (e.g. when the daylight saving time ends or the time zone offset is decreased due to a time zone rule change) or skipped local time at a positive time zone transition (e.g. when the daylight saving time starts or the time zone offset is increased due to a time zone rule change), _t_ is interpreted using the time zone offset before the transition.\n    1. If _possibleInstants_ is not empty, then\n      1. Let _disambiguatedInstant_ be _possibleInstants_[0].\n    1. Else,\n      1. NOTE: _t_ represents a local time skipped at a positive time zone transition (e.g. due to daylight saving time starting or a time zone rule change increasing the UTC offset).\n      1. [declared=\"tBefore\"] Let _possibleInstantsBefore_ be GetNamedTimeZoneEpochNanoseconds(_systemTimeZoneIdentifier_, ℝ(YearFromTime(_tBefore_)), ℝ(MonthFromTime(_tBefore_)) + 1, ℝ(DateFromTime(_tBefore_)), ℝ(HourFromTime(_tBefore_)), ℝ(MinFromTime(_tBefore_)), ℝ(SecFromTime(_tBefore_)), ℝ(msFromTime(_tBefore_)), 0, 0), where _tBefore_ is the largest integral Number < _t_ for which _possibleInstantsBefore_ is not empty (i.e., _tBefore_ represents the last local time before the transition).\n      1. Let _disambiguatedInstant_ be the last element of _possibleInstantsBefore_.\n    1. Let _offsetNs_ be GetNamedTimeZoneOffsetNanoseconds(_systemTimeZoneIdentifier_, _disambiguatedInstant_).\n  1. Let _offsetMs_ be truncate(_offsetNs_ / 10<sup>6</sup>).\n  1. Return _t_ - 𝔽(_offsetMs_).","code":"\n          1. If _t_ is not finite, return *NaN*.\n          1. Let _systemTimeZoneIdentifier_ be SystemTimeZoneIdentifier().\n          1. If IsTimeZoneOffsetString(_systemTimeZoneIdentifier_) is *true*, then\n            1. Let _offsetNs_ be ParseTimeZoneOffsetString(_systemTimeZoneIdentifier_).\n          1. Else,\n            1. Let _possibleInstants_ be GetNamedTimeZoneEpochNanoseconds(_systemTimeZoneIdentifier_, ℝ(YearFromTime(_t_)), ℝ(MonthFromTime(_t_)) + 1, ℝ(DateFromTime(_t_)), ℝ(HourFromTime(_t_)), ℝ(MinFromTime(_t_)), ℝ(SecFromTime(_t_)), ℝ(msFromTime(_t_)), 0, 0).\n            1. NOTE: The following steps ensure that when _t_ represents local time repeating multiple times at a negative time zone transition (e.g. when the daylight saving time ends or the time zone offset is decreased due to a time zone rule change) or skipped local time at a positive time zone transition (e.g. when the daylight saving time starts or the time zone offset is increased due to a time zone rule change), _t_ is interpreted using the time zone offset before the transition.\n            1. If _possibleInstants_ is not empty, then\n              1. Let _disambiguatedInstant_ be _possibleInstants_[0].\n            1. Else,\n              1. NOTE: _t_ represents a local time skipped at a positive time zone transition (e.g. due to daylight saving time starting or a time zone rule change increasing the UTC offset).\n              1. [declared=\"tBefore\"] Let _possibleInstantsBefore_ be GetNamedTimeZoneEpochNanoseconds(_systemTimeZoneIdentifier_, ℝ(YearFromTime(_tBefore_)), ℝ(MonthFromTime(_tBefore_)) + 1, ℝ(DateFromTime(_tBefore_)), ℝ(HourFromTime(_tBefore_)), ℝ(MinFromTime(_tBefore_)), ℝ(SecFromTime(_tBefore_)), ℝ(msFromTime(_tBefore_)), 0, 0), where _tBefore_ is the largest integral Number < _t_ for which _possibleInstantsBefore_ is not empty (i.e., _tBefore_ represents the last local time before the transition).\n              1. Let _disambiguatedInstant_ be the last element of _possibleInstantsBefore_.\n            1. Let _offsetNs_ be GetNamedTimeZoneOffsetNanoseconds(_systemTimeZoneIdentifier_, _disambiguatedInstant_).\n          1. Let _offsetMs_ be truncate(_offsetNs_ / 10<sup>6</sup>).\n          1. Return _t_ - 𝔽(_offsetMs_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"MakeTime","params":[{"name":"hour","ty":"Number","kind":{"Normal":{}}},{"name":"min","ty":"Number","kind":{"Normal":{}}},{"name":"sec","ty":"Number","kind":{"Normal":{}}},{"name":"ms","ty":"Number","kind":{"Normal":{}}}],"retTy":"Number"}},"body":"\n  1. If _hour_ is not finite or _min_ is not finite or _sec_ is not finite or _ms_ is not finite, return *NaN*.\n  1. Let _h_ be 𝔽(! ToIntegerOrInfinity(_hour_)).\n  1. Let _m_ be 𝔽(! ToIntegerOrInfinity(_min_)).\n  1. Let _s_ be 𝔽(! ToIntegerOrInfinity(_sec_)).\n  1. Let _milli_ be 𝔽(! ToIntegerOrInfinity(_ms_)).\n  1. Return ((_h_ × msPerHour + _m_ × msPerMinute) + _s_ × msPerSecond) + _milli_.","code":"\n          1. If _hour_ is not finite, _min_ is not finite, _sec_ is not finite, or _ms_ is not finite, return *NaN*.\n          1. Let _h_ be 𝔽(! ToIntegerOrInfinity(_hour_)).\n          1. Let _m_ be 𝔽(! ToIntegerOrInfinity(_min_)).\n          1. Let _s_ be 𝔽(! ToIntegerOrInfinity(_sec_)).\n          1. Let _milli_ be 𝔽(! ToIntegerOrInfinity(_ms_)).\n          1. Return ((_h_ × msPerHour + _m_ × msPerMinute) + _s_ × msPerSecond) + _milli_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"MakeDay","params":[{"name":"year","ty":"Number","kind":{"Normal":{}}},{"name":"month","ty":"Number","kind":{"Normal":{}}},{"name":"date","ty":"Number","kind":{"Normal":{}}}],"retTy":"Number"}},"body":"\n  1. If _year_ is not finite or _month_ is not finite or _date_ is not finite, return *NaN*.\n  1. Let _y_ be 𝔽(! ToIntegerOrInfinity(_year_)).\n  1. Let _m_ be 𝔽(! ToIntegerOrInfinity(_month_)).\n  1. Let _dt_ be 𝔽(! ToIntegerOrInfinity(_date_)).\n  1. Let _ym_ be _y_ + 𝔽(floor(ℝ(_m_) / 12)).\n  1. If _ym_ is not finite, return *NaN*.\n  1. Let _mn_ be 𝔽(ℝ(_m_) modulo 12).\n  1. Find a finite time value _t_ such that YearFromTime(_t_) is _ym_, MonthFromTime(_t_) is _mn_, and DateFromTime(_t_) is *1*<sub>𝔽</sub>; but if this is not possible (because some argument is out of range), return *NaN*.\n  1. Return Day(_t_) + _dt_ - *1*<sub>𝔽</sub>.","code":"\n          1. If _year_ is not finite, _month_ is not finite, or _date_ is not finite, return *NaN*.\n          1. Let _y_ be 𝔽(! ToIntegerOrInfinity(_year_)).\n          1. Let _m_ be 𝔽(! ToIntegerOrInfinity(_month_)).\n          1. Let _dt_ be 𝔽(! ToIntegerOrInfinity(_date_)).\n          1. Let _ym_ be _y_ + 𝔽(floor(ℝ(_m_) / 12)).\n          1. If _ym_ is not finite, return *NaN*.\n          1. Let _mn_ be 𝔽(ℝ(_m_) modulo 12).\n          1. Find a finite time value _t_ such that YearFromTime(_t_) is _ym_, MonthFromTime(_t_) is _mn_, and DateFromTime(_t_) is *1*<sub>𝔽</sub>; but if this is not possible (because some argument is out of range), return *NaN*.\n          1. Return Day(_t_) + _dt_ - *1*<sub>𝔽</sub>.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"MakeDate","params":[{"name":"day","ty":"Number","kind":{"Normal":{}}},{"name":"time","ty":"Number","kind":{"Normal":{}}}],"retTy":"Number"}},"body":"\n  1. If _day_ is not finite or _time_ is not finite, return *NaN*.\n  1. Let _tv_ be _day_ × msPerDay + _time_.\n  1. If _tv_ is not finite, return *NaN*.\n  1. Return _tv_.","code":"\n          1. If _day_ is not finite or _time_ is not finite, return *NaN*.\n          1. Let _tv_ be _day_ × msPerDay + _time_.\n          1. If _tv_ is not finite, return *NaN*.\n          1. Return _tv_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"MakeFullYear","params":[{"name":"year","ty":"Number","kind":{"Normal":{}}}],"retTy":"Number[Int, NaN]"}},"body":"\n  1. If _year_ is *NaN*, return *NaN*.\n  1. Let _truncated_ be ! ToIntegerOrInfinity(_year_).\n  1. If _truncated_ is in the inclusive interval from 0 to 99, return *1900*<sub>𝔽</sub> + 𝔽(_truncated_).\n  1. Return 𝔽(_truncated_).","code":"\n          1. If _year_ is *NaN*, return *NaN*.\n          1. Let _truncated_ be ! ToIntegerOrInfinity(_year_).\n          1. If _truncated_ is in the inclusive interval from 0 to 99, return *1900*<sub>𝔽</sub> + 𝔽(_truncated_).\n          1. Return 𝔽(_truncated_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"TimeClip","params":[{"name":"time","ty":"Number","kind":{"Normal":{}}}],"retTy":"Number"}},"body":"\n  1. If _time_ is not finite, return *NaN*.\n  1. If abs(ℝ(_time_)) > 8.64 × 10<sup>15</sup>, return *NaN*.\n  1. Return 𝔽(! ToIntegerOrInfinity(_time_)).","code":"\n          1. If _time_ is not finite, return *NaN*.\n          1. If abs(ℝ(_time_)) > 8.64 × 10<sup>15</sup>, return *NaN*.\n          1. Return 𝔽(! ToIntegerOrInfinity(_time_)).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsTimeZoneOffsetString","params":[{"name":"offsetString","ty":"String","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _parseResult_ be ParseText(StringToCodePoints(_offsetString_), |UTCOffset|).\n  1. If _parseResult_ is a List[Record[Error]], return *false*.\n  1. Return *true*.","code":"\n            1. Let _parseResult_ be ParseText(StringToCodePoints(_offsetString_), |UTCOffset|).\n            1. If _parseResult_ is a List of errors, return *false*.\n            1. Return *true*.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ParseTimeZoneOffsetString","params":[{"name":"offsetString","ty":"String","kind":{"Normal":{}}}],"retTy":"Int"}},"body":"\n  1. Let _parseResult_ be ParseText(StringToCodePoints(_offsetString_), |UTCOffset|).\n  1. Assert: _parseResult_ is not a List[Record[Error]].\n  1. Assert: _parseResult_ contains a |TemporalSign| Parse Node..\n  1. Let _parsedSign_ be the source text matched by the |TemporalSign| Parse Node contained within _parseResult_.\n  1. If _parsedSign_ is the single code point U+002D (HYPHEN-MINUS) or U+2212 (MINUS SIGN), then\n    1. Let _sign_ be -1.\n  1. Else,\n    1. Let _sign_ be 1.\n  1. NOTE: Applications of StringToNumber below do not lose precision, since each of the parsed values is guaranteed to be a sufficiently short string of decimal digits.\n  1. Assert: _parseResult_ contains an |Hour| Parse Node..\n  1. Let _parsedHours_ be the source text matched by the |Hour| Parse Node contained within _parseResult_.\n  1. Let _hours_ be ℝ(StringToNumber(CodePointsToString(_parsedHours_))).\n  1. If _parseResult_ does not contain a |MinuteSecond| Parse Node, then\n    1. Let _minutes_ be 0.\n  1. Else,\n    1. Let _parsedMinutes_ be the source text matched by the first |MinuteSecond| Parse Node contained within _parseResult_.\n    1. Let _minutes_ be ℝ(StringToNumber(CodePointsToString(_parsedMinutes_))).\n  1. If _parseResult_ does not contain two |MinuteSecond| Parse Nodes, then\n    1. Let _seconds_ be 0.\n  1. Else,\n    1. Let _parsedSeconds_ be the source text matched by the second |MinuteSecond| Parse Node contained within _parseResult_.\n    1. Let _seconds_ be ℝ(StringToNumber(CodePointsToString(_parsedSeconds_))).\n  1. If _parseResult_ does not contain a |TemporalDecimalFraction| Parse Node, then\n    1. Let _nanoseconds_ be 0.\n  1. Else,\n    1. Let _parsedFraction_ be the source text matched by the |TemporalDecimalFraction| Parse Node contained within _parseResult_.\n    1. Let _fraction_ be the string-concatenation of CodePointsToString(_parsedFraction_) and *\"000000000\"*.\n    1. Let _nanosecondsString_ be the substring of _fraction_ from 1 to 10.\n    1. Let _nanoseconds_ be ℝ(StringToNumber(_nanosecondsString_)).\n  1. Return _sign_ × (((_hours_ × 60 + _minutes_) × 60 + _seconds_) × 10<sup>9</sup> + _nanoseconds_).","code":"\n            1. Let _parseResult_ be ParseText(StringToCodePoints(_offsetString_), |UTCOffset|).\n            1. Assert: _parseResult_ is not a List of errors.\n            1. Assert: _parseResult_ contains a |TemporalSign| Parse Node.\n            1. Let _parsedSign_ be the source text matched by the |TemporalSign| Parse Node contained within _parseResult_.\n            1. If _parsedSign_ is the single code point U+002D (HYPHEN-MINUS) or U+2212 (MINUS SIGN), then\n              1. Let _sign_ be -1.\n            1. Else,\n              1. Let _sign_ be 1.\n            1. NOTE: Applications of StringToNumber below do not lose precision, since each of the parsed values is guaranteed to be a sufficiently short string of decimal digits.\n            1. Assert: _parseResult_ contains an |Hour| Parse Node.\n            1. Let _parsedHours_ be the source text matched by the |Hour| Parse Node contained within _parseResult_.\n            1. Let _hours_ be ℝ(StringToNumber(CodePointsToString(_parsedHours_))).\n            1. If _parseResult_ does not contain a |MinuteSecond| Parse Node, then\n              1. Let _minutes_ be 0.\n            1. Else,\n              1. Let _parsedMinutes_ be the source text matched by the first |MinuteSecond| Parse Node contained within _parseResult_.\n              1. Let _minutes_ be ℝ(StringToNumber(CodePointsToString(_parsedMinutes_))).\n            1. If _parseResult_ does not contain two |MinuteSecond| Parse Nodes, then\n              1. Let _seconds_ be 0.\n            1. Else,\n              1. Let _parsedSeconds_ be the source text matched by the second |MinuteSecond| Parse Node contained within _parseResult_.\n              1. Let _seconds_ be ℝ(StringToNumber(CodePointsToString(_parsedSeconds_))).\n            1. If _parseResult_ does not contain a |TemporalDecimalFraction| Parse Node, then\n              1. Let _nanoseconds_ be 0.\n            1. Else,\n              1. Let _parsedFraction_ be the source text matched by the |TemporalDecimalFraction| Parse Node contained within _parseResult_.\n              1. Let _fraction_ be the string-concatenation of CodePointsToString(_parsedFraction_) and *\"000000000\"*.\n              1. Let _nanosecondsString_ be the substring of _fraction_ from 1 to 10.\n              1. Let _nanoseconds_ be ℝ(StringToNumber(_nanosecondsString_)).\n            1. Return _sign_ × (((_hours_ × 60 + _minutes_) × 60 + _seconds_) × 10<sup>9</sup> + _nanoseconds_).\n          "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"Date"}},"params":[{"name":"values","ty":"Unknown","kind":{"Variadic":{}}}],"retTy":"Unknown"}},"body":"\n  1. If NewTarget is *undefined*, then\n    1. Let _now_ be the time value (UTC) identifying the current time.\n    1. Return ToDateString(_now_).\n  1. Let _numberOfArgs_ be the number of elements in _values_.\n  1. If _numberOfArgs_ = 0, then\n    1. Let _dv_ be the time value (UTC) identifying the current time.\n  1. Else if _numberOfArgs_ = 1, then\n    1. Let _value_ be _values_[0].\n    1. If _value_ is a Record[Object] and _value_ has a [[DateValue]] internal slot, then\n      1. Let _tv_ be _value_.[[DateValue]].\n    1. Else,\n      1. Let _v_ be ? ToPrimitive(_value_).\n      1. If _v_ is a String, then\n        1. Assert: The next step never returns an abrupt completion because _v_ is a String..\n        1. Let _tv_ be the result of parsing _v_ as a date, in exactly the same manner as for the `parse` method (<emu-xref href=\"#sec-date.parse\"></emu-xref>).\n      1. Else,\n        1. Let _tv_ be ? ToNumber(_v_).\n    1. Let _dv_ be TimeClip(_tv_).\n  1. Else,\n    1. Assert: _numberOfArgs_ ≥ 2.\n    1. Let _y_ be ? ToNumber(_values_[0]).\n    1. Let _m_ be ? ToNumber(_values_[1]).\n    1. If _numberOfArgs_ > 2, let _dt_ be ? ToNumber(_values_[2]).\n    1. Else, let _dt_ be *1*<sub>𝔽</sub>.\n    1. If _numberOfArgs_ > 3, let _h_ be ? ToNumber(_values_[3]).\n    1. Else, let _h_ be *+0*<sub>𝔽</sub>.\n    1. If _numberOfArgs_ > 4, let _min_ be ? ToNumber(_values_[4]).\n    1. Else, let _min_ be *+0*<sub>𝔽</sub>.\n    1. If _numberOfArgs_ > 5, let _s_ be ? ToNumber(_values_[5]).\n    1. Else, let _s_ be *+0*<sub>𝔽</sub>.\n    1. If _numberOfArgs_ > 6, let _milli_ be ? ToNumber(_values_[6]).\n    1. Else, let _milli_ be *+0*<sub>𝔽</sub>.\n    1. Let _yr_ be MakeFullYear(_y_).\n    1. Let _finalDate_ be MakeDate(MakeDay(_yr_, _m_, _dt_), MakeTime(_h_, _min_, _s_, _milli_)).\n    1. Let _dv_ be TimeClip(UTC(_finalDate_)).\n  1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Date.prototype%\"*, « [[DateValue]] »).\n  1. Set _O_.[[DateValue]] to _dv_.\n  1. Return _O_.","code":"\n          1. If NewTarget is *undefined*, then\n            1. Let _now_ be the time value (UTC) identifying the current time.\n            1. Return ToDateString(_now_).\n          1. Let _numberOfArgs_ be the number of elements in _values_.\n          1. If _numberOfArgs_ = 0, then\n            1. Let _dv_ be the time value (UTC) identifying the current time.\n          1. Else if _numberOfArgs_ = 1, then\n            1. Let _value_ be _values_[0].\n            1. If _value_ is an Object and _value_ has a [[DateValue]] internal slot, then\n              1. Let _tv_ be _value_.[[DateValue]].\n            1. Else,\n              1. Let _v_ be ? ToPrimitive(_value_).\n              1. If _v_ is a String, then\n                1. Assert: The next step never returns an abrupt completion because _v_ is a String.\n                1. Let _tv_ be the result of parsing _v_ as a date, in exactly the same manner as for the `parse` method (<emu-xref href=\"#sec-date.parse\"></emu-xref>).\n              1. Else,\n                1. Let _tv_ be ? ToNumber(_v_).\n            1. Let _dv_ be TimeClip(_tv_).\n          1. Else,\n            1. Assert: _numberOfArgs_ ≥ 2.\n            1. Let _y_ be ? ToNumber(_values_[0]).\n            1. Let _m_ be ? ToNumber(_values_[1]).\n            1. If _numberOfArgs_ > 2, let _dt_ be ? ToNumber(_values_[2]); else let _dt_ be *1*<sub>𝔽</sub>.\n            1. If _numberOfArgs_ > 3, let _h_ be ? ToNumber(_values_[3]); else let _h_ be *+0*<sub>𝔽</sub>.\n            1. If _numberOfArgs_ > 4, let _min_ be ? ToNumber(_values_[4]); else let _min_ be *+0*<sub>𝔽</sub>.\n            1. If _numberOfArgs_ > 5, let _s_ be ? ToNumber(_values_[5]); else let _s_ be *+0*<sub>𝔽</sub>.\n            1. If _numberOfArgs_ > 6, let _milli_ be ? ToNumber(_values_[6]); else let _milli_ be *+0*<sub>𝔽</sub>.\n            1. Let _yr_ be MakeFullYear(_y_).\n            1. Let _finalDate_ be MakeDate(MakeDay(_yr_, _m_, _dt_), MakeTime(_h_, _min_, _s_, _milli_)).\n            1. Let _dv_ be TimeClip(UTC(_finalDate_)).\n          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Date.prototype%\"*, « [[DateValue]] »).\n          1. Set _O_.[[DateValue]] to _dv_.\n          1. Return _O_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"UTC"}},"params":[{"name":"year","ty":"Unknown","kind":{"Normal":{}}},{"name":"month","ty":"Unknown","kind":{"Optional":{}}},{"name":"date","ty":"Unknown","kind":{"Optional":{}}},{"name":"hours","ty":"Unknown","kind":{"Optional":{}}},{"name":"minutes","ty":"Unknown","kind":{"Optional":{}}},{"name":"seconds","ty":"Unknown","kind":{"Optional":{}}},{"name":"ms","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _y_ be ? ToNumber(_year_).\n  1. If _month_ is present, let _m_ be ? ToNumber(_month_).\n  1. Else, let _m_ be *+0*<sub>𝔽</sub>.\n  1. If _date_ is present, let _dt_ be ? ToNumber(_date_).\n  1. Else, let _dt_ be *1*<sub>𝔽</sub>.\n  1. If _hours_ is present, let _h_ be ? ToNumber(_hours_).\n  1. Else, let _h_ be *+0*<sub>𝔽</sub>.\n  1. If _minutes_ is present, let _min_ be ? ToNumber(_minutes_).\n  1. Else, let _min_ be *+0*<sub>𝔽</sub>.\n  1. If _seconds_ is present, let _s_ be ? ToNumber(_seconds_).\n  1. Else, let _s_ be *+0*<sub>𝔽</sub>.\n  1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).\n  1. Else, let _milli_ be *+0*<sub>𝔽</sub>.\n  1. Let _yr_ be MakeFullYear(_y_).\n  1. Return TimeClip(MakeDate(MakeDay(_yr_, _m_, _dt_), MakeTime(_h_, _min_, _s_, _milli_))).","code":"\n          1. Let _y_ be ? ToNumber(_year_).\n          1. If _month_ is present, let _m_ be ? ToNumber(_month_); else let _m_ be *+0*<sub>𝔽</sub>.\n          1. If _date_ is present, let _dt_ be ? ToNumber(_date_); else let _dt_ be *1*<sub>𝔽</sub>.\n          1. If _hours_ is present, let _h_ be ? ToNumber(_hours_); else let _h_ be *+0*<sub>𝔽</sub>.\n          1. If _minutes_ is present, let _min_ be ? ToNumber(_minutes_); else let _min_ be *+0*<sub>𝔽</sub>.\n          1. If _seconds_ is present, let _s_ be ? ToNumber(_seconds_); else let _s_ be *+0*<sub>𝔽</sub>.\n          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_); else let _milli_ be *+0*<sub>𝔽</sub>.\n          1. Let _yr_ be MakeFullYear(_y_).\n          1. Return TimeClip(MakeDate(MakeDay(_yr_, _m_, _dt_), MakeTime(_h_, _min_, _s_, _milli_))).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"getDate"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. If _t_ is *NaN*, return *NaN*.\n  1. Return DateFromTime(LocalTime(_t_)).","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return DateFromTime(LocalTime(_t_)).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"getDay"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. If _t_ is *NaN*, return *NaN*.\n  1. Return WeekDay(LocalTime(_t_)).","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return WeekDay(LocalTime(_t_)).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"getFullYear"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. If _t_ is *NaN*, return *NaN*.\n  1. Return YearFromTime(LocalTime(_t_)).","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return YearFromTime(LocalTime(_t_)).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"getHours"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. If _t_ is *NaN*, return *NaN*.\n  1. Return HourFromTime(LocalTime(_t_)).","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return HourFromTime(LocalTime(_t_)).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"getMilliseconds"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. If _t_ is *NaN*, return *NaN*.\n  1. Return msFromTime(LocalTime(_t_)).","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return msFromTime(LocalTime(_t_)).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"getMinutes"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. If _t_ is *NaN*, return *NaN*.\n  1. Return MinFromTime(LocalTime(_t_)).","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return MinFromTime(LocalTime(_t_)).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"getMonth"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. If _t_ is *NaN*, return *NaN*.\n  1. Return MonthFromTime(LocalTime(_t_)).","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return MonthFromTime(LocalTime(_t_)).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"getSeconds"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. If _t_ is *NaN*, return *NaN*.\n  1. Return SecFromTime(LocalTime(_t_)).","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return SecFromTime(LocalTime(_t_)).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"getTime"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Return _dateObject_.[[DateValue]].","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Return _dateObject_.[[DateValue]].\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"getTimezoneOffset"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. If _t_ is *NaN*, return *NaN*.\n  1. Return (_t_ - LocalTime(_t_)) / msPerMinute.","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return (_t_ - LocalTime(_t_)) / msPerMinute.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"getUTCDate"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. If _t_ is *NaN*, return *NaN*.\n  1. Return DateFromTime(_t_).","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return DateFromTime(_t_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"getUTCDay"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. If _t_ is *NaN*, return *NaN*.\n  1. Return WeekDay(_t_).","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return WeekDay(_t_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"getUTCFullYear"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. If _t_ is *NaN*, return *NaN*.\n  1. Return YearFromTime(_t_).","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return YearFromTime(_t_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"getUTCHours"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. If _t_ is *NaN*, return *NaN*.\n  1. Return HourFromTime(_t_).","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return HourFromTime(_t_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"getUTCMilliseconds"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. If _t_ is *NaN*, return *NaN*.\n  1. Return msFromTime(_t_).","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return msFromTime(_t_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"getUTCMinutes"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. If _t_ is *NaN*, return *NaN*.\n  1. Return MinFromTime(_t_).","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return MinFromTime(_t_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"getUTCMonth"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. If _t_ is *NaN*, return *NaN*.\n  1. Return MonthFromTime(_t_).","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return MonthFromTime(_t_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"getUTCSeconds"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. If _t_ is *NaN*, return *NaN*.\n  1. Return SecFromTime(_t_).","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Return SecFromTime(_t_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"setDate"}},"params":[{"name":"date","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. Let _dt_ be ? ToNumber(_date_).\n  1. If _t_ is *NaN*, return *NaN*.\n  1. Set _t_ to LocalTime(_t_).\n  1. Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), MonthFromTime(_t_), _dt_), TimeWithinDay(_t_)).\n  1. Let _u_ be TimeClip(UTC(_newDate_)).\n  1. Set _dateObject_.[[DateValue]] to _u_.\n  1. Return _u_.","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. Let _dt_ be ? ToNumber(_date_).\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Set _t_ to LocalTime(_t_).\n          1. Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), MonthFromTime(_t_), _dt_), TimeWithinDay(_t_)).\n          1. Let _u_ be TimeClip(UTC(_newDate_)).\n          1. Set _dateObject_.[[DateValue]] to _u_.\n          1. Return _u_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"setFullYear"}},"params":[{"name":"year","ty":"Unknown","kind":{"Normal":{}}},{"name":"month","ty":"Unknown","kind":{"Optional":{}}},{"name":"date","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. Let _y_ be ? ToNumber(_year_).\n  1. If _t_ is *NaN*, set _t_ to *+0*<sub>𝔽</sub>.\n  1. Else, set _t_ to LocalTime(_t_).\n  1. If _month_ is not present, let _m_ be MonthFromTime(_t_).\n  1. Else, let _m_ be ? ToNumber(_month_).\n  1. If _date_ is not present, let _dt_ be DateFromTime(_t_).\n  1. Else, let _dt_ be ? ToNumber(_date_).\n  1. Let _newDate_ be MakeDate(MakeDay(_y_, _m_, _dt_), TimeWithinDay(_t_)).\n  1. Let _u_ be TimeClip(UTC(_newDate_)).\n  1. Set _dateObject_.[[DateValue]] to _u_.\n  1. Return _u_.","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. Let _y_ be ? ToNumber(_year_).\n          1. If _t_ is *NaN*, set _t_ to *+0*<sub>𝔽</sub>; otherwise, set _t_ to LocalTime(_t_).\n          1. If _month_ is not present, let _m_ be MonthFromTime(_t_); otherwise, let _m_ be ? ToNumber(_month_).\n          1. If _date_ is not present, let _dt_ be DateFromTime(_t_); otherwise, let _dt_ be ? ToNumber(_date_).\n          1. Let _newDate_ be MakeDate(MakeDay(_y_, _m_, _dt_), TimeWithinDay(_t_)).\n          1. Let _u_ be TimeClip(UTC(_newDate_)).\n          1. Set _dateObject_.[[DateValue]] to _u_.\n          1. Return _u_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"setHours"}},"params":[{"name":"hour","ty":"Unknown","kind":{"Normal":{}}},{"name":"min","ty":"Unknown","kind":{"Optional":{}}},{"name":"sec","ty":"Unknown","kind":{"Optional":{}}},{"name":"ms","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. Let _h_ be ? ToNumber(_hour_).\n  1. If _min_ is present, let _m_ be ? ToNumber(_min_).\n  1. If _sec_ is present, let _s_ be ? ToNumber(_sec_).\n  1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).\n  1. If _t_ is *NaN*, return *NaN*.\n  1. Set _t_ to LocalTime(_t_).\n  1. If _min_ is not present, let _m_ be MinFromTime(_t_).\n  1. If _sec_ is not present, let _s_ be SecFromTime(_t_).\n  1. If _ms_ is not present, let _milli_ be msFromTime(_t_).\n  1. Let _date_ be MakeDate(Day(_t_), MakeTime(_h_, _m_, _s_, _milli_)).\n  1. Let _u_ be TimeClip(UTC(_date_)).\n  1. Set _dateObject_.[[DateValue]] to _u_.\n  1. Return _u_.","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. Let _h_ be ? ToNumber(_hour_).\n          1. If _min_ is present, let _m_ be ? ToNumber(_min_).\n          1. If _sec_ is present, let _s_ be ? ToNumber(_sec_).\n          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Set _t_ to LocalTime(_t_).\n          1. If _min_ is not present, let _m_ be MinFromTime(_t_).\n          1. If _sec_ is not present, let _s_ be SecFromTime(_t_).\n          1. If _ms_ is not present, let _milli_ be msFromTime(_t_).\n          1. Let _date_ be MakeDate(Day(_t_), MakeTime(_h_, _m_, _s_, _milli_)).\n          1. Let _u_ be TimeClip(UTC(_date_)).\n          1. Set _dateObject_.[[DateValue]] to _u_.\n          1. Return _u_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"setMilliseconds"}},"params":[{"name":"ms","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. Set _ms_ to ? ToNumber(_ms_).\n  1. If _t_ is *NaN*, return *NaN*.\n  1. Set _t_ to LocalTime(_t_).\n  1. Let _time_ be MakeTime(HourFromTime(_t_), MinFromTime(_t_), SecFromTime(_t_), _ms_).\n  1. Let _u_ be TimeClip(UTC(MakeDate(Day(_t_), _time_))).\n  1. Set _dateObject_.[[DateValue]] to _u_.\n  1. Return _u_.","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. Set _ms_ to ? ToNumber(_ms_).\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Set _t_ to LocalTime(_t_).\n          1. Let _time_ be MakeTime(HourFromTime(_t_), MinFromTime(_t_), SecFromTime(_t_), _ms_).\n          1. Let _u_ be TimeClip(UTC(MakeDate(Day(_t_), _time_))).\n          1. Set _dateObject_.[[DateValue]] to _u_.\n          1. Return _u_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"setMinutes"}},"params":[{"name":"min","ty":"Unknown","kind":{"Normal":{}}},{"name":"sec","ty":"Unknown","kind":{"Optional":{}}},{"name":"ms","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. Let _m_ be ? ToNumber(_min_).\n  1. If _sec_ is present, let _s_ be ? ToNumber(_sec_).\n  1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).\n  1. If _t_ is *NaN*, return *NaN*.\n  1. Set _t_ to LocalTime(_t_).\n  1. If _sec_ is not present, let _s_ be SecFromTime(_t_).\n  1. If _ms_ is not present, let _milli_ be msFromTime(_t_).\n  1. Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), _m_, _s_, _milli_)).\n  1. Let _u_ be TimeClip(UTC(_date_)).\n  1. Set _dateObject_.[[DateValue]] to _u_.\n  1. Return _u_.","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. Let _m_ be ? ToNumber(_min_).\n          1. If _sec_ is present, let _s_ be ? ToNumber(_sec_).\n          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Set _t_ to LocalTime(_t_).\n          1. If _sec_ is not present, let _s_ be SecFromTime(_t_).\n          1. If _ms_ is not present, let _milli_ be msFromTime(_t_).\n          1. Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), _m_, _s_, _milli_)).\n          1. Let _u_ be TimeClip(UTC(_date_)).\n          1. Set _dateObject_.[[DateValue]] to _u_.\n          1. Return _u_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"setMonth"}},"params":[{"name":"month","ty":"Unknown","kind":{"Normal":{}}},{"name":"date","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. Let _m_ be ? ToNumber(_month_).\n  1. If _date_ is present, let _dt_ be ? ToNumber(_date_).\n  1. If _t_ is *NaN*, return *NaN*.\n  1. Set _t_ to LocalTime(_t_).\n  1. If _date_ is not present, let _dt_ be DateFromTime(_t_).\n  1. Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), _m_, _dt_), TimeWithinDay(_t_)).\n  1. Let _u_ be TimeClip(UTC(_newDate_)).\n  1. Set _dateObject_.[[DateValue]] to _u_.\n  1. Return _u_.","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. Let _m_ be ? ToNumber(_month_).\n          1. If _date_ is present, let _dt_ be ? ToNumber(_date_).\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Set _t_ to LocalTime(_t_).\n          1. If _date_ is not present, let _dt_ be DateFromTime(_t_).\n          1. Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), _m_, _dt_), TimeWithinDay(_t_)).\n          1. Let _u_ be TimeClip(UTC(_newDate_)).\n          1. Set _dateObject_.[[DateValue]] to _u_.\n          1. Return _u_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"setSeconds"}},"params":[{"name":"sec","ty":"Unknown","kind":{"Normal":{}}},{"name":"ms","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. Let _s_ be ? ToNumber(_sec_).\n  1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).\n  1. If _t_ is *NaN*, return *NaN*.\n  1. Set _t_ to LocalTime(_t_).\n  1. If _ms_ is not present, let _milli_ be msFromTime(_t_).\n  1. Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), MinFromTime(_t_), _s_, _milli_)).\n  1. Let _u_ be TimeClip(UTC(_date_)).\n  1. Set _dateObject_.[[DateValue]] to _u_.\n  1. Return _u_.","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. Let _s_ be ? ToNumber(_sec_).\n          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Set _t_ to LocalTime(_t_).\n          1. If _ms_ is not present, let _milli_ be msFromTime(_t_).\n          1. Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), MinFromTime(_t_), _s_, _milli_)).\n          1. Let _u_ be TimeClip(UTC(_date_)).\n          1. Set _dateObject_.[[DateValue]] to _u_.\n          1. Return _u_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"setTime"}},"params":[{"name":"time","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be ? ToNumber(_time_).\n  1. Let _v_ be TimeClip(_t_).\n  1. Set _dateObject_.[[DateValue]] to _v_.\n  1. Return _v_.","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be ? ToNumber(_time_).\n          1. Let _v_ be TimeClip(_t_).\n          1. Set _dateObject_.[[DateValue]] to _v_.\n          1. Return _v_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"setUTCDate"}},"params":[{"name":"date","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. Let _dt_ be ? ToNumber(_date_).\n  1. If _t_ is *NaN*, return *NaN*.\n  1. Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), MonthFromTime(_t_), _dt_), TimeWithinDay(_t_)).\n  1. Let _v_ be TimeClip(_newDate_).\n  1. Set _dateObject_.[[DateValue]] to _v_.\n  1. Return _v_.","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. Let _dt_ be ? ToNumber(_date_).\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), MonthFromTime(_t_), _dt_), TimeWithinDay(_t_)).\n          1. Let _v_ be TimeClip(_newDate_).\n          1. Set _dateObject_.[[DateValue]] to _v_.\n          1. Return _v_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"setUTCFullYear"}},"params":[{"name":"year","ty":"Unknown","kind":{"Normal":{}}},{"name":"month","ty":"Unknown","kind":{"Optional":{}}},{"name":"date","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. If _t_ is *NaN*, set _t_ to *+0*<sub>𝔽</sub>.\n  1. Let _y_ be ? ToNumber(_year_).\n  1. If _month_ is not present, let _m_ be MonthFromTime(_t_).\n  1. Else, let _m_ be ? ToNumber(_month_).\n  1. If _date_ is not present, let _dt_ be DateFromTime(_t_).\n  1. Else, let _dt_ be ? ToNumber(_date_).\n  1. Let _newDate_ be MakeDate(MakeDay(_y_, _m_, _dt_), TimeWithinDay(_t_)).\n  1. Let _v_ be TimeClip(_newDate_).\n  1. Set _dateObject_.[[DateValue]] to _v_.\n  1. Return _v_.","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. If _t_ is *NaN*, set _t_ to *+0*<sub>𝔽</sub>.\n          1. Let _y_ be ? ToNumber(_year_).\n          1. If _month_ is not present, let _m_ be MonthFromTime(_t_); otherwise, let _m_ be ? ToNumber(_month_).\n          1. If _date_ is not present, let _dt_ be DateFromTime(_t_); otherwise, let _dt_ be ? ToNumber(_date_).\n          1. Let _newDate_ be MakeDate(MakeDay(_y_, _m_, _dt_), TimeWithinDay(_t_)).\n          1. Let _v_ be TimeClip(_newDate_).\n          1. Set _dateObject_.[[DateValue]] to _v_.\n          1. Return _v_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"setUTCHours"}},"params":[{"name":"hour","ty":"Unknown","kind":{"Normal":{}}},{"name":"min","ty":"Unknown","kind":{"Optional":{}}},{"name":"sec","ty":"Unknown","kind":{"Optional":{}}},{"name":"ms","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. Let _h_ be ? ToNumber(_hour_).\n  1. If _min_ is present, let _m_ be ? ToNumber(_min_).\n  1. If _sec_ is present, let _s_ be ? ToNumber(_sec_).\n  1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).\n  1. If _t_ is *NaN*, return *NaN*.\n  1. If _min_ is not present, let _m_ be MinFromTime(_t_).\n  1. If _sec_ is not present, let _s_ be SecFromTime(_t_).\n  1. If _ms_ is not present, let _milli_ be msFromTime(_t_).\n  1. Let _date_ be MakeDate(Day(_t_), MakeTime(_h_, _m_, _s_, _milli_)).\n  1. Let _v_ be TimeClip(_date_).\n  1. Set _dateObject_.[[DateValue]] to _v_.\n  1. Return _v_.","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. Let _h_ be ? ToNumber(_hour_).\n          1. If _min_ is present, let _m_ be ? ToNumber(_min_).\n          1. If _sec_ is present, let _s_ be ? ToNumber(_sec_).\n          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).\n          1. If _t_ is *NaN*, return *NaN*.\n          1. If _min_ is not present, let _m_ be MinFromTime(_t_).\n          1. If _sec_ is not present, let _s_ be SecFromTime(_t_).\n          1. If _ms_ is not present, let _milli_ be msFromTime(_t_).\n          1. Let _date_ be MakeDate(Day(_t_), MakeTime(_h_, _m_, _s_, _milli_)).\n          1. Let _v_ be TimeClip(_date_).\n          1. Set _dateObject_.[[DateValue]] to _v_.\n          1. Return _v_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"setUTCMilliseconds"}},"params":[{"name":"ms","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. Set _ms_ to ? ToNumber(_ms_).\n  1. If _t_ is *NaN*, return *NaN*.\n  1. Let _time_ be MakeTime(HourFromTime(_t_), MinFromTime(_t_), SecFromTime(_t_), _ms_).\n  1. Let _v_ be TimeClip(MakeDate(Day(_t_), _time_)).\n  1. Set _dateObject_.[[DateValue]] to _v_.\n  1. Return _v_.","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. Set _ms_ to ? ToNumber(_ms_).\n          1. If _t_ is *NaN*, return *NaN*.\n          1. Let _time_ be MakeTime(HourFromTime(_t_), MinFromTime(_t_), SecFromTime(_t_), _ms_).\n          1. Let _v_ be TimeClip(MakeDate(Day(_t_), _time_)).\n          1. Set _dateObject_.[[DateValue]] to _v_.\n          1. Return _v_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"setUTCMinutes"}},"params":[{"name":"min","ty":"Unknown","kind":{"Normal":{}}},{"name":"sec","ty":"Unknown","kind":{"Optional":{}}},{"name":"ms","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. Let _m_ be ? ToNumber(_min_).\n  1. If _sec_ is present, let _s_ be ? ToNumber(_sec_).\n  1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).\n  1. If _t_ is *NaN*, return *NaN*.\n  1. If _sec_ is not present, let _s_ be SecFromTime(_t_).\n  1. If _ms_ is not present, let _milli_ be msFromTime(_t_).\n  1. Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), _m_, _s_, _milli_)).\n  1. Let _v_ be TimeClip(_date_).\n  1. Set _dateObject_.[[DateValue]] to _v_.\n  1. Return _v_.","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. Let _m_ be ? ToNumber(_min_).\n          1. If _sec_ is present, let _s_ be ? ToNumber(_sec_).\n          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).\n          1. If _t_ is *NaN*, return *NaN*.\n          1. If _sec_ is not present, let _s_ be SecFromTime(_t_).\n          1. If _ms_ is not present, let _milli_ be msFromTime(_t_).\n          1. Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), _m_, _s_, _milli_)).\n          1. Let _v_ be TimeClip(_date_).\n          1. Set _dateObject_.[[DateValue]] to _v_.\n          1. Return _v_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"setUTCMonth"}},"params":[{"name":"month","ty":"Unknown","kind":{"Normal":{}}},{"name":"date","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. Let _m_ be ? ToNumber(_month_).\n  1. If _date_ is present, let _dt_ be ? ToNumber(_date_).\n  1. If _t_ is *NaN*, return *NaN*.\n  1. If _date_ is not present, let _dt_ be DateFromTime(_t_).\n  1. Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), _m_, _dt_), TimeWithinDay(_t_)).\n  1. Let _v_ be TimeClip(_newDate_).\n  1. Set _dateObject_.[[DateValue]] to _v_.\n  1. Return _v_.","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. Let _m_ be ? ToNumber(_month_).\n          1. If _date_ is present, let _dt_ be ? ToNumber(_date_).\n          1. If _t_ is *NaN*, return *NaN*.\n          1. If _date_ is not present, let _dt_ be DateFromTime(_t_).\n          1. Let _newDate_ be MakeDate(MakeDay(YearFromTime(_t_), _m_, _dt_), TimeWithinDay(_t_)).\n          1. Let _v_ be TimeClip(_newDate_).\n          1. Set _dateObject_.[[DateValue]] to _v_.\n          1. Return _v_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"setUTCSeconds"}},"params":[{"name":"sec","ty":"Unknown","kind":{"Normal":{}}},{"name":"ms","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _t_ be _dateObject_.[[DateValue]].\n  1. Let _s_ be ? ToNumber(_sec_).\n  1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).\n  1. If _t_ is *NaN*, return *NaN*.\n  1. If _ms_ is not present, let _milli_ be msFromTime(_t_).\n  1. Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), MinFromTime(_t_), _s_, _milli_)).\n  1. Let _v_ be TimeClip(_date_).\n  1. Set _dateObject_.[[DateValue]] to _v_.\n  1. Return _v_.","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _t_ be _dateObject_.[[DateValue]].\n          1. Let _s_ be ? ToNumber(_sec_).\n          1. If _ms_ is present, let _milli_ be ? ToNumber(_ms_).\n          1. If _t_ is *NaN*, return *NaN*.\n          1. If _ms_ is not present, let _milli_ be msFromTime(_t_).\n          1. Let _date_ be MakeDate(Day(_t_), MakeTime(HourFromTime(_t_), MinFromTime(_t_), _s_, _milli_)).\n          1. Let _v_ be TimeClip(_date_).\n          1. Set _dateObject_.[[DateValue]] to _v_.\n          1. Return _v_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"toDateString"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _tv_ be _dateObject_.[[DateValue]].\n  1. If _tv_ is *NaN*, return *\"Invalid Date\"*.\n  1. Let _t_ be LocalTime(_tv_).\n  1. Return DateString(_t_).","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _tv_ be _dateObject_.[[DateValue]].\n          1. If _tv_ is *NaN*, return *\"Invalid Date\"*.\n          1. Let _t_ be LocalTime(_tv_).\n          1. Return DateString(_t_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"toISOString"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _tv_ be _dateObject_.[[DateValue]].\n  1. If _tv_ is not finite, throw a *RangeError* exception.\n  1. If _tv_ corresponds with a year that cannot be represented in the <emu-xref href=\"#sec-date-time-string-format\">Date Time String Format</emu-xref>, throw a *RangeError* exception.\n  1. Return a String representation of _tv_ in the <emu-xref href=\"#sec-date-time-string-format\">Date Time String Format</emu-xref> on the UTC time scale, including all format elements and the UTC offset representation *\"Z\"*.","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _tv_ be _dateObject_.[[DateValue]].\n          1. If _tv_ is not finite, throw a *RangeError* exception.\n          1. If _tv_ corresponds with a year that cannot be represented in the <emu-xref href=\"#sec-date-time-string-format\">Date Time String Format</emu-xref>, throw a *RangeError* exception.\n          1. Return a String representation of _tv_ in the <emu-xref href=\"#sec-date-time-string-format\">Date Time String Format</emu-xref> on the UTC time scale, including all format elements and the UTC offset representation *\"Z\"*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"toJSON"}},"params":[{"name":"key","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _tv_ be ? ToPrimitive(_O_, ~number~).\n  1. If _tv_ is a Number and _tv_ is not finite, return *null*.\n  1. Return ? Invoke(_O_, *\"toISOString\"*).","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _tv_ be ? ToPrimitive(_O_, ~number~).\n          1. If _tv_ is a Number and _tv_ is not finite, return *null*.\n          1. Return ? Invoke(_O_, *\"toISOString\"*).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"toString"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _tv_ be _dateObject_.[[DateValue]].\n  1. Return ToDateString(_tv_).","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _tv_ be _dateObject_.[[DateValue]].\n          1. Return ToDateString(_tv_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"TimeString","params":[{"name":"tv","ty":"Unknown[\"a Number, but not *NaN*\"]","kind":{"Normal":{}}}],"retTy":"String"}},"body":"\n  1. Let _hour_ be ToZeroPaddedDecimalString(ℝ(HourFromTime(_tv_)), 2).\n  1. Let _minute_ be ToZeroPaddedDecimalString(ℝ(MinFromTime(_tv_)), 2).\n  1. Let _second_ be ToZeroPaddedDecimalString(ℝ(SecFromTime(_tv_)), 2).\n  1. Return the string-concatenation of _hour_, *\":\"*, _minute_, *\":\"*, _second_, 0x0020 (SPACE), and *\"GMT\"*.","code":"\n            1. Let _hour_ be ToZeroPaddedDecimalString(ℝ(HourFromTime(_tv_)), 2).\n            1. Let _minute_ be ToZeroPaddedDecimalString(ℝ(MinFromTime(_tv_)), 2).\n            1. Let _second_ be ToZeroPaddedDecimalString(ℝ(SecFromTime(_tv_)), 2).\n            1. Return the string-concatenation of _hour_, *\":\"*, _minute_, *\":\"*, _second_, the code unit 0x0020 (SPACE), and *\"GMT\"*.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"DateString","params":[{"name":"tv","ty":"Unknown[\"a Number, but not *NaN*\"]","kind":{"Normal":{}}}],"retTy":"String"}},"body":"\n  1. Let _weekday_ be the Name of the entry in <emu-xref href=\"#sec-todatestring-day-names\"></emu-xref> with the Number WeekDay(_tv_).\n  1. Let _month_ be the Name of the entry in <emu-xref href=\"#sec-todatestring-month-names\"></emu-xref> with the Number MonthFromTime(_tv_).\n  1. Let _day_ be ToZeroPaddedDecimalString(ℝ(DateFromTime(_tv_)), 2).\n  1. Let _yv_ be YearFromTime(_tv_).\n  1. If _yv_ is *+0*<sub>𝔽</sub> or _yv_ > *+0*<sub>𝔽</sub>, let _yearSign_ be *\"\"*.\n  1. Else, let _yearSign_ be *\"-\"*.\n  1. Let _paddedYear_ be ToZeroPaddedDecimalString(abs(ℝ(_yv_)), 4).\n  1. Return the string-concatenation of _weekday_, 0x0020 (SPACE), _month_, 0x0020 (SPACE), _day_, 0x0020 (SPACE), _yearSign_, and _paddedYear_.","code":"\n            1. Let _weekday_ be the Name of the entry in <emu-xref href=\"#sec-todatestring-day-names\"></emu-xref> with the Number WeekDay(_tv_).\n            1. Let _month_ be the Name of the entry in <emu-xref href=\"#sec-todatestring-month-names\"></emu-xref> with the Number MonthFromTime(_tv_).\n            1. Let _day_ be ToZeroPaddedDecimalString(ℝ(DateFromTime(_tv_)), 2).\n            1. Let _yv_ be YearFromTime(_tv_).\n            1. If _yv_ is *+0*<sub>𝔽</sub> or _yv_ > *+0*<sub>𝔽</sub>, let _yearSign_ be the empty String; otherwise, let _yearSign_ be *\"-\"*.\n            1. Let _paddedYear_ be ToZeroPaddedDecimalString(abs(ℝ(_yv_)), 4).\n            1. Return the string-concatenation of _weekday_, the code unit 0x0020 (SPACE), _month_, the code unit 0x0020 (SPACE), _day_, the code unit 0x0020 (SPACE), _yearSign_, and _paddedYear_.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"TimeZoneString","params":[{"name":"tv","ty":"Number[Int]","kind":{"Normal":{}}}],"retTy":"String"}},"body":"\n  1. Let _systemTimeZoneIdentifier_ be SystemTimeZoneIdentifier().\n  1. If IsTimeZoneOffsetString(_systemTimeZoneIdentifier_) is *true*, then\n    1. Let _offsetNs_ be ParseTimeZoneOffsetString(_systemTimeZoneIdentifier_).\n  1. Else,\n    1. Let _offsetNs_ be GetNamedTimeZoneOffsetNanoseconds(_systemTimeZoneIdentifier_, ℤ(ℝ(_tv_) × 10<sup>6</sup>)).\n  1. Let _offset_ be 𝔽(truncate(_offsetNs_ / 10<sup>6</sup>)).\n  1. If _offset_ is *+0*<sub>𝔽</sub> or _offset_ > *+0*<sub>𝔽</sub>, then\n    1. Let _offsetSign_ be *\"+\"*.\n    1. Let _absOffset_ be _offset_.\n  1. Else,\n    1. Let _offsetSign_ be *\"-\"*.\n    1. Let _absOffset_ be -_offset_.\n  1. Let _offsetMin_ be ToZeroPaddedDecimalString(ℝ(MinFromTime(_absOffset_)), 2).\n  1. Let _offsetHour_ be ToZeroPaddedDecimalString(ℝ(HourFromTime(_absOffset_)), 2).\n  1. Let _tzName_ be an implementation-defined string that is either the empty String or the string-concatenation of the code unit 0x0020 (SPACE), the code unit 0x0028 (LEFT PARENTHESIS), an implementation-defined timezone name, and the code unit 0x0029 (RIGHT PARENTHESIS).\n  1. Return the string-concatenation of _offsetSign_, _offsetHour_, _offsetMin_, and _tzName_.","code":"\n            1. Let _systemTimeZoneIdentifier_ be SystemTimeZoneIdentifier().\n            1. If IsTimeZoneOffsetString(_systemTimeZoneIdentifier_) is *true*, then\n              1. Let _offsetNs_ be ParseTimeZoneOffsetString(_systemTimeZoneIdentifier_).\n            1. Else,\n              1. Let _offsetNs_ be GetNamedTimeZoneOffsetNanoseconds(_systemTimeZoneIdentifier_, ℤ(ℝ(_tv_) × 10<sup>6</sup>)).\n            1. Let _offset_ be 𝔽(truncate(_offsetNs_ / 10<sup>6</sup>)).\n            1. If _offset_ is *+0*<sub>𝔽</sub> or _offset_ > *+0*<sub>𝔽</sub>, then\n              1. Let _offsetSign_ be *\"+\"*.\n              1. Let _absOffset_ be _offset_.\n            1. Else,\n              1. Let _offsetSign_ be *\"-\"*.\n              1. Let _absOffset_ be -_offset_.\n            1. Let _offsetMin_ be ToZeroPaddedDecimalString(ℝ(MinFromTime(_absOffset_)), 2).\n            1. Let _offsetHour_ be ToZeroPaddedDecimalString(ℝ(HourFromTime(_absOffset_)), 2).\n            1. Let _tzName_ be an implementation-defined string that is either the empty String or the string-concatenation of the code unit 0x0020 (SPACE), the code unit 0x0028 (LEFT PARENTHESIS), an implementation-defined timezone name, and the code unit 0x0029 (RIGHT PARENTHESIS).\n            1. Return the string-concatenation of _offsetSign_, _offsetHour_, _offsetMin_, and _tzName_.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ToDateString","params":[{"name":"tv","ty":"Number[Int, NaN]","kind":{"Normal":{}}}],"retTy":"String"}},"body":"\n  1. If _tv_ is *NaN*, return *\"Invalid Date\"*.\n  1. Let _t_ be LocalTime(_tv_).\n  1. Return the string-concatenation of DateString(_t_), 0x0020 (SPACE), TimeString(_t_), and TimeZoneString(_tv_).","code":"\n            1. If _tv_ is *NaN*, return *\"Invalid Date\"*.\n            1. Let _t_ be LocalTime(_tv_).\n            1. Return the string-concatenation of DateString(_t_), the code unit 0x0020 (SPACE), TimeString(_t_), and TimeZoneString(_tv_).\n          "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"toTimeString"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _tv_ be _dateObject_.[[DateValue]].\n  1. If _tv_ is *NaN*, return *\"Invalid Date\"*.\n  1. Let _t_ be LocalTime(_tv_).\n  1. Return the string-concatenation of TimeString(_t_) and TimeZoneString(_tv_).","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _tv_ be _dateObject_.[[DateValue]].\n          1. If _tv_ is *NaN*, return *\"Invalid Date\"*.\n          1. Let _t_ be LocalTime(_tv_).\n          1. Return the string-concatenation of TimeString(_t_) and TimeZoneString(_tv_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"toUTCString"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Let _tv_ be _dateObject_.[[DateValue]].\n  1. If _tv_ is *NaN*, return *\"Invalid Date\"*.\n  1. Let _weekday_ be the Name of the entry in <emu-xref href=\"#sec-todatestring-day-names\"></emu-xref> with the Number WeekDay(_tv_).\n  1. Let _month_ be the Name of the entry in <emu-xref href=\"#sec-todatestring-month-names\"></emu-xref> with the Number MonthFromTime(_tv_).\n  1. Let _day_ be ToZeroPaddedDecimalString(ℝ(DateFromTime(_tv_)), 2).\n  1. Let _yv_ be YearFromTime(_tv_).\n  1. If _yv_ is *+0*<sub>𝔽</sub> or _yv_ > *+0*<sub>𝔽</sub>, let _yearSign_ be *\"\"*.\n  1. Else, let _yearSign_ be *\"-\"*.\n  1. Let _paddedYear_ be ToZeroPaddedDecimalString(abs(ℝ(_yv_)), 4).\n  1. Return the string-concatenation of _weekday_, *\",\"*, 0x0020 (SPACE), _day_, 0x0020 (SPACE), _month_, 0x0020 (SPACE), _yearSign_, _paddedYear_, 0x0020 (SPACE), and TimeString(_tv_).","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Let _tv_ be _dateObject_.[[DateValue]].\n          1. If _tv_ is *NaN*, return *\"Invalid Date\"*.\n          1. Let _weekday_ be the Name of the entry in <emu-xref href=\"#sec-todatestring-day-names\"></emu-xref> with the Number WeekDay(_tv_).\n          1. Let _month_ be the Name of the entry in <emu-xref href=\"#sec-todatestring-month-names\"></emu-xref> with the Number MonthFromTime(_tv_).\n          1. Let _day_ be ToZeroPaddedDecimalString(ℝ(DateFromTime(_tv_)), 2).\n          1. Let _yv_ be YearFromTime(_tv_).\n          1. If _yv_ is *+0*<sub>𝔽</sub> or _yv_ > *+0*<sub>𝔽</sub>, let _yearSign_ be the empty String; otherwise, let _yearSign_ be *\"-\"*.\n          1. Let _paddedYear_ be ToZeroPaddedDecimalString(abs(ℝ(_yv_)), 4).\n          1. Return the string-concatenation of _weekday_, *\",\"*, the code unit 0x0020 (SPACE), _day_, the code unit 0x0020 (SPACE), _month_, the code unit 0x0020 (SPACE), _yearSign_, _paddedYear_, the code unit 0x0020 (SPACE), and TimeString(_tv_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"name":"valueOf"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _dateObject_ be *this* value.\n  1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n  1. Return _dateObject_.[[DateValue]].","code":"\n          1. Let _dateObject_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_dateObject_, [[DateValue]]).\n          1. Return _dateObject_.[[DateValue]].\n        "},{"head":{"BuiltinHead":{"path":{"SymbolAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Date"}},"name":"prototype"}},"symbol":"toPrimitive"}},"params":[{"name":"hint","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. If _O_ is not a Record[Object], throw a *TypeError* exception.\n  1. If _hint_ is either *\"string\"* or *\"default\"*, then\n    1. Let _tryFirst_ be ~string~.\n  1. Else if _hint_ is *\"number\"*, then\n    1. Let _tryFirst_ be ~number~.\n  1. Else,\n    1. Throw a *TypeError* exception.\n  1. Return ? OrdinaryToPrimitive(_O_, _tryFirst_).","code":"\n          1. Let _O_ be the *this* value.\n          1. If _O_ is not an Object, throw a *TypeError* exception.\n          1. If _hint_ is either *\"string\"* or *\"default\"*, then\n            1. Let _tryFirst_ be ~string~.\n          1. Else if _hint_ is *\"number\"*, then\n            1. Let _tryFirst_ be ~number~.\n          1. Else,\n            1. Throw a *TypeError* exception.\n          1. Return ? OrdinaryToPrimitive(_O_, _tryFirst_).\n        "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"String"}},"params":[{"name":"value","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If _value_ is not present, then\n    1. Let _s_ be *\"\"*.\n  1. Else,\n    1. If NewTarget is *undefined* and _value_ is a Record[Symbol], return SymbolDescriptiveString(_value_).\n    1. Let _s_ be ? ToString(_value_).\n  1. If NewTarget is *undefined*, return _s_.\n  1. Return StringCreate(_s_, ? GetPrototypeFromConstructor(NewTarget, *\"%String.prototype%\"*)).","code":"\n          1. If _value_ is not present, then\n            1. Let _s_ be the empty String.\n          1. Else,\n            1. If NewTarget is *undefined* and _value_ is a Symbol, return SymbolDescriptiveString(_value_).\n            1. Let _s_ be ? ToString(_value_).\n          1. If NewTarget is *undefined*, return _s_.\n          1. Return StringCreate(_s_, ? GetPrototypeFromConstructor(NewTarget, *\"%String.prototype%\"*)).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"fromCharCode"}},"params":[{"name":"codeUnits","ty":"Unknown","kind":{"Variadic":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _result_ be *\"\"*.\n  1. For each _next_ of _codeUnits_, do\n    1. Let _nextCU_ be the code unit whose numeric value is ℝ(? ToUint16(_next_)).\n    1. Set _result_ to the string-concatenation of _result_ and _nextCU_.\n  1. Return _result_.","code":"\n          1. Let _result_ be the empty String.\n          1. For each element _next_ of _codeUnits_, do\n            1. Let _nextCU_ be the code unit whose numeric value is ℝ(? ToUint16(_next_)).\n            1. Set _result_ to the string-concatenation of _result_ and _nextCU_.\n          1. Return _result_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"fromCodePoint"}},"params":[{"name":"codePoints","ty":"Unknown","kind":{"Variadic":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _result_ be *\"\"*.\n  1. For each _next_ of _codePoints_, do\n    1. Let _nextCP_ be ? ToNumber(_next_).\n    1. If IsIntegralNumber(_nextCP_) is *false*, throw a *RangeError* exception.\n    1. If ℝ(_nextCP_) < 0 or ℝ(_nextCP_) > 0x10ffff, throw a *RangeError* exception.\n    1. Set _result_ to the string-concatenation of _result_ and UTF16EncodeCodePoint(ℝ(_nextCP_)).\n  1. Assert: If _codePoints_ is empty, then _result_ is *\"\"*.\n  1. Return _result_.","code":"\n          1. Let _result_ be the empty String.\n          1. For each element _next_ of _codePoints_, do\n            1. Let _nextCP_ be ? ToNumber(_next_).\n            1. If IsIntegralNumber(_nextCP_) is *false*, throw a *RangeError* exception.\n            1. If ℝ(_nextCP_) < 0 or ℝ(_nextCP_) > 0x10FFFF, throw a *RangeError* exception.\n            1. Set _result_ to the string-concatenation of _result_ and UTF16EncodeCodePoint(ℝ(_nextCP_)).\n          1. Assert: If _codePoints_ is empty, then _result_ is the empty String.\n          1. Return _result_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"raw"}},"params":[{"name":"template","ty":"Unknown","kind":{"Normal":{}}},{"name":"substitutions","ty":"Unknown","kind":{"Variadic":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _substitutionCount_ be the number of elements in _substitutions_.\n  1. Let _cooked_ be ? ToObject(_template_).\n  1. Let _literals_ be ? ToObject(? Get(_cooked_, *\"raw\"*)).\n  1. Let _literalCount_ be ? LengthOfArrayLike(_literals_).\n  1. If _literalCount_ ≤ 0, return *\"\"*.\n  1. Let _R_ be *\"\"*.\n  1. Let _nextIndex_ be 0.\n  1. Repeat, \n    1. Let _nextLiteralVal_ be ? Get(_literals_, ! ToString(𝔽(_nextIndex_))).\n    1. Let _nextLiteral_ be ? ToString(_nextLiteralVal_).\n    1. Set _R_ to the string-concatenation of _R_ and _nextLiteral_.\n    1. If _nextIndex_ + 1 = _literalCount_, return _R_.\n    1. If _nextIndex_ < _substitutionCount_, then\n      1. Let _nextSubVal_ be _substitutions_[_nextIndex_].\n      1. Let _nextSub_ be ? ToString(_nextSubVal_).\n      1. Set _R_ to the string-concatenation of _R_ and _nextSub_.\n    1. Set _nextIndex_ to _nextIndex_ + 1.","code":"\n          1. Let _substitutionCount_ be the number of elements in _substitutions_.\n          1. Let _cooked_ be ? ToObject(_template_).\n          1. Let _literals_ be ? ToObject(? Get(_cooked_, *\"raw\"*)).\n          1. Let _literalCount_ be ? LengthOfArrayLike(_literals_).\n          1. If _literalCount_ ≤ 0, return the empty String.\n          1. Let _R_ be the empty String.\n          1. Let _nextIndex_ be 0.\n          1. Repeat,\n            1. Let _nextLiteralVal_ be ? Get(_literals_, ! ToString(𝔽(_nextIndex_))).\n            1. Let _nextLiteral_ be ? ToString(_nextLiteralVal_).\n            1. Set _R_ to the string-concatenation of _R_ and _nextLiteral_.\n            1. If _nextIndex_ + 1 = _literalCount_, return _R_.\n            1. If _nextIndex_ < _substitutionCount_, then\n              1. Let _nextSubVal_ be _substitutions_[_nextIndex_].\n              1. Let _nextSub_ be ? ToString(_nextSubVal_).\n              1. Set _R_ to the string-concatenation of _R_ and _nextSub_.\n            1. Set _nextIndex_ to _nextIndex_ + 1.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"at"}},"params":[{"name":"index","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? RequireObjectCoercible(*this* value).\n  1. Let _S_ be ? ToString(_O_).\n  1. Let _len_ be the length of _S_.\n  1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).\n  1. If _relativeIndex_ ≥ 0, then\n    1. Let _k_ be _relativeIndex_.\n  1. Else,\n    1. Let _k_ be _len_ + _relativeIndex_.\n  1. If _k_ < 0 or _k_ ≥ _len_, return *undefined*.\n  1. Return the substring of _S_ from _k_ to _k_ + 1.","code":"\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _len_ be the length of _S_.\n          1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).\n          1. If _relativeIndex_ ≥ 0, then\n            1. Let _k_ be _relativeIndex_.\n          1. Else,\n            1. Let _k_ be _len_ + _relativeIndex_.\n          1. If _k_ < 0 or _k_ ≥ _len_, return *undefined*.\n          1. Return the substring of _S_ from _k_ to _k_ + 1.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"charAt"}},"params":[{"name":"pos","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? RequireObjectCoercible(*this* value).\n  1. Let _S_ be ? ToString(_O_).\n  1. Let _position_ be ? ToIntegerOrInfinity(_pos_).\n  1. Let _size_ be the length of _S_.\n  1. If _position_ < 0 or _position_ ≥ _size_, return *\"\"*.\n  1. Return the substring of _S_ from _position_ to _position_ + 1.","code":"\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _position_ be ? ToIntegerOrInfinity(_pos_).\n          1. Let _size_ be the length of _S_.\n          1. If _position_ < 0 or _position_ ≥ _size_, return the empty String.\n          1. Return the substring of _S_ from _position_ to _position_ + 1.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"charCodeAt"}},"params":[{"name":"pos","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? RequireObjectCoercible(*this* value).\n  1. Let _S_ be ? ToString(_O_).\n  1. Let _position_ be ? ToIntegerOrInfinity(_pos_).\n  1. Let _size_ be the length of _S_.\n  1. If _position_ < 0 or _position_ ≥ _size_, return *NaN*.\n  1. Return 𝔽(the numeric value of the code unit at index _position_ within _S_).","code":"\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _position_ be ? ToIntegerOrInfinity(_pos_).\n          1. Let _size_ be the length of _S_.\n          1. If _position_ < 0 or _position_ ≥ _size_, return *NaN*.\n          1. Return the Number value for the numeric value of the code unit at index _position_ within the String _S_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"codePointAt"}},"params":[{"name":"pos","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? RequireObjectCoercible(*this* value).\n  1. Let _S_ be ? ToString(_O_).\n  1. Let _position_ be ? ToIntegerOrInfinity(_pos_).\n  1. Let _size_ be the length of _S_.\n  1. If _position_ < 0 or _position_ ≥ _size_, return *undefined*.\n  1. Let _cp_ be CodePointAt(_S_, _position_).\n  1. Return 𝔽(_cp_.[[CodePoint]]).","code":"\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _position_ be ? ToIntegerOrInfinity(_pos_).\n          1. Let _size_ be the length of _S_.\n          1. If _position_ < 0 or _position_ ≥ _size_, return *undefined*.\n          1. Let _cp_ be CodePointAt(_S_, _position_).\n          1. Return 𝔽(_cp_.[[CodePoint]]).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"concat"}},"params":[{"name":"args","ty":"Unknown","kind":{"Variadic":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? RequireObjectCoercible(*this* value).\n  1. Let _S_ be ? ToString(_O_).\n  1. Let _R_ be _S_.\n  1. For each _next_ of _args_, do\n    1. Let _nextString_ be ? ToString(_next_).\n    1. Set _R_ to the string-concatenation of _R_ and _nextString_.\n  1. Return _R_.","code":"\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _R_ be _S_.\n          1. For each element _next_ of _args_, do\n            1. Let _nextString_ be ? ToString(_next_).\n            1. Set _R_ to the string-concatenation of _R_ and _nextString_.\n          1. Return _R_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"endsWith"}},"params":[{"name":"searchString","ty":"Unknown","kind":{"Normal":{}}},{"name":"endPosition","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? RequireObjectCoercible(*this* value).\n  1. Let _S_ be ? ToString(_O_).\n  1. Let _isRegExp_ be ? IsRegExp(_searchString_).\n  1. If _isRegExp_ is *true*, throw a *TypeError* exception.\n  1. Let _searchStr_ be ? ToString(_searchString_).\n  1. Let _len_ be the length of _S_.\n  1. If _endPosition_ is *undefined*, let _pos_ be _len_.\n  1. Else, let _pos_ be ? ToIntegerOrInfinity(_endPosition_).\n  1. Let _end_ be the result of clamping _pos_ between 0 and _len_.\n  1. Let _searchLength_ be the length of _searchStr_.\n  1. If _searchLength_ = 0, return *true*.\n  1. Let _start_ be _end_ - _searchLength_.\n  1. If _start_ < 0, return *false*.\n  1. Let _substring_ be the substring of _S_ from _start_ to _end_.\n  1. If _substring_ is _searchStr_, return *true*.\n  1. Return *false*.","code":"\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _isRegExp_ be ? IsRegExp(_searchString_).\n          1. If _isRegExp_ is *true*, throw a *TypeError* exception.\n          1. Let _searchStr_ be ? ToString(_searchString_).\n          1. Let _len_ be the length of _S_.\n          1. If _endPosition_ is *undefined*, let _pos_ be _len_; else let _pos_ be ? ToIntegerOrInfinity(_endPosition_).\n          1. Let _end_ be the result of clamping _pos_ between 0 and _len_.\n          1. Let _searchLength_ be the length of _searchStr_.\n          1. If _searchLength_ = 0, return *true*.\n          1. Let _start_ be _end_ - _searchLength_.\n          1. If _start_ < 0, return *false*.\n          1. Let _substring_ be the substring of _S_ from _start_ to _end_.\n          1. If _substring_ is _searchStr_, return *true*.\n          1. Return *false*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"includes"}},"params":[{"name":"searchString","ty":"Unknown","kind":{"Normal":{}}},{"name":"position","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? RequireObjectCoercible(*this* value).\n  1. Let _S_ be ? ToString(_O_).\n  1. Let _isRegExp_ be ? IsRegExp(_searchString_).\n  1. If _isRegExp_ is *true*, throw a *TypeError* exception.\n  1. Let _searchStr_ be ? ToString(_searchString_).\n  1. Let _pos_ be ? ToIntegerOrInfinity(_position_).\n  1. Assert: If _position_ is *undefined*, then _pos_ is 0.\n  1. Let _len_ be the length of _S_.\n  1. Let _start_ be the result of clamping _pos_ between 0 and _len_.\n  1. Let _index_ be StringIndexOf(_S_, _searchStr_, _start_).\n  1. If _index_ ≠ -1, return *true*.\n  1. Return *false*.","code":"\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _isRegExp_ be ? IsRegExp(_searchString_).\n          1. If _isRegExp_ is *true*, throw a *TypeError* exception.\n          1. Let _searchStr_ be ? ToString(_searchString_).\n          1. Let _pos_ be ? ToIntegerOrInfinity(_position_).\n          1. Assert: If _position_ is *undefined*, then _pos_ is 0.\n          1. Let _len_ be the length of _S_.\n          1. Let _start_ be the result of clamping _pos_ between 0 and _len_.\n          1. Let _index_ be StringIndexOf(_S_, _searchStr_, _start_).\n          1. If _index_ ≠ -1, return *true*.\n          1. Return *false*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"indexOf"}},"params":[{"name":"searchString","ty":"Unknown","kind":{"Normal":{}}},{"name":"position","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? RequireObjectCoercible(*this* value).\n  1. Let _S_ be ? ToString(_O_).\n  1. Let _searchStr_ be ? ToString(_searchString_).\n  1. Let _pos_ be ? ToIntegerOrInfinity(_position_).\n  1. Assert: If _position_ is *undefined*, then _pos_ is 0.\n  1. Let _len_ be the length of _S_.\n  1. Let _start_ be the result of clamping _pos_ between 0 and _len_.\n  1. Return 𝔽(StringIndexOf(_S_, _searchStr_, _start_)).","code":"\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _searchStr_ be ? ToString(_searchString_).\n          1. Let _pos_ be ? ToIntegerOrInfinity(_position_).\n          1. Assert: If _position_ is *undefined*, then _pos_ is 0.\n          1. Let _len_ be the length of _S_.\n          1. Let _start_ be the result of clamping _pos_ between 0 and _len_.\n          1. Return 𝔽(StringIndexOf(_S_, _searchStr_, _start_)).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"isWellFormed"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? RequireObjectCoercible(*this* value).\n  1. Let _S_ be ? ToString(_O_).\n  1. Return IsStringWellFormedUnicode(_S_).","code":"\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Return IsStringWellFormedUnicode(_S_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"lastIndexOf"}},"params":[{"name":"searchString","ty":"Unknown","kind":{"Normal":{}}},{"name":"position","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? RequireObjectCoercible(*this* value).\n  1. Let _S_ be ? ToString(_O_).\n  1. Let _searchStr_ be ? ToString(_searchString_).\n  1. Let _numPos_ be ? ToNumber(_position_).\n  1. Assert: If _position_ is *undefined*, then _numPos_ is *NaN*.\n  1. If _numPos_ is *NaN*, let _pos_ be +∞.\n  1. Else, let _pos_ be ! ToIntegerOrInfinity(_numPos_).\n  1. Let _len_ be the length of _S_.\n  1. Let _searchLen_ be the length of _searchStr_.\n  1. Let _start_ be the result of clamping _pos_ between 0 and _len_ - _searchLen_.\n  1. If _searchStr_ is *\"\"*, return 𝔽(_start_).\n  1. For each integer _i_ such that 0 ≤ _i_ ≤ _start_, in descending order, do\n    1. Let _candidate_ be the substring of _S_ from _i_ to _i_ + _searchLen_.\n    1. If _candidate_ is _searchStr_, return 𝔽(_i_).\n  1. Return *-1*<sub>𝔽</sub>.","code":"\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _searchStr_ be ? ToString(_searchString_).\n          1. Let _numPos_ be ? ToNumber(_position_).\n          1. Assert: If _position_ is *undefined*, then _numPos_ is *NaN*.\n          1. If _numPos_ is *NaN*, let _pos_ be +∞; otherwise, let _pos_ be ! ToIntegerOrInfinity(_numPos_).\n          1. Let _len_ be the length of _S_.\n          1. Let _searchLen_ be the length of _searchStr_.\n          1. Let _start_ be the result of clamping _pos_ between 0 and _len_ - _searchLen_.\n          1. If _searchStr_ is the empty String, return 𝔽(_start_).\n          1. For each integer _i_ such that 0 ≤ _i_ ≤ _start_, in descending order, do\n            1. Let _candidate_ be the substring of _S_ from _i_ to _i_ + _searchLen_.\n            1. If _candidate_ is _searchStr_, return 𝔽(_i_).\n          1. Return *-1*<sub>𝔽</sub>.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"localeCompare"}},"params":[{"name":"that","ty":"Unknown","kind":{"Normal":{}}},{"name":"reserved1","ty":"Unknown","kind":{"Optional":{}}},{"name":"reserved2","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? RequireObjectCoercible(*this* value).\n  1. Let _S_ be ? ToString(_O_).\n  1. Let _thatValue_ be ? ToString(_that_).","code":"\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _thatValue_ be ? ToString(_that_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"match"}},"params":[{"name":"regexp","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? RequireObjectCoercible(*this* value).\n  1. If _regexp_ is neither *undefined* nor *null*, then\n    1. Let _matcher_ be ? GetMethod(_regexp_, @@match).\n    1. If _matcher_ is not *undefined*, then\n      1. Return ? Call(_matcher_, _regexp_, « _O_ »).\n  1. Let _S_ be ? ToString(_O_).\n  1. Let _rx_ be ? RegExpCreate(_regexp_, *undefined*).\n  1. Return ? Invoke(_rx_, @@match, « _S_ »).","code":"\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. If _regexp_ is neither *undefined* nor *null*, then\n            1. Let _matcher_ be ? GetMethod(_regexp_, @@match).\n            1. If _matcher_ is not *undefined*, then\n              1. Return ? Call(_matcher_, _regexp_, « _O_ »).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _rx_ be ? RegExpCreate(_regexp_, *undefined*).\n          1. Return ? Invoke(_rx_, @@match, « _S_ »).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"matchAll"}},"params":[{"name":"regexp","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? RequireObjectCoercible(*this* value).\n  1. If _regexp_ is neither *undefined* nor *null*, then\n    1. Let _isRegExp_ be ? IsRegExp(_regexp_).\n    1. If _isRegExp_ is *true*, then\n      1. Let _flags_ be ? Get(_regexp_, *\"flags\"*).\n      1. Perform ? RequireObjectCoercible(_flags_).\n      1. If ? ToString(_flags_) does not contain *\"g\"*, throw a *TypeError* exception.\n    1. Let _matcher_ be ? GetMethod(_regexp_, @@matchAll).\n    1. If _matcher_ is not *undefined*, then\n      1. Return ? Call(_matcher_, _regexp_, « _O_ »).\n  1. Let _S_ be ? ToString(_O_).\n  1. Let _rx_ be ? RegExpCreate(_regexp_, *\"g\"*).\n  1. Return ? Invoke(_rx_, @@matchAll, « _S_ »).","code":"\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. If _regexp_ is neither *undefined* nor *null*, then\n            1. Let _isRegExp_ be ? IsRegExp(_regexp_).\n            1. If _isRegExp_ is *true*, then\n              1. Let _flags_ be ? Get(_regexp_, *\"flags\"*).\n              1. Perform ? RequireObjectCoercible(_flags_).\n              1. If ? ToString(_flags_) does not contain *\"g\"*, throw a *TypeError* exception.\n            1. Let _matcher_ be ? GetMethod(_regexp_, @@matchAll).\n            1. If _matcher_ is not *undefined*, then\n              1. Return ? Call(_matcher_, _regexp_, « _O_ »).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _rx_ be ? RegExpCreate(_regexp_, *\"g\"*).\n          1. Return ? Invoke(_rx_, @@matchAll, « _S_ »).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"normalize"}},"params":[{"name":"form","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? RequireObjectCoercible(*this* value).\n  1. Let _S_ be ? ToString(_O_).\n  1. If _form_ is *undefined*, let _f_ be *\"NFC\"*.\n  1. Else, let _f_ be ? ToString(_form_).\n  1. If _f_ is neither *\"NFC\"*, *\"NFD\"*, *\"NFKC\"*, nor *\"NFKD\"*, throw a *RangeError* exception.\n  1. Let _ns_ be the String value that is the result of normalizing _S_ into the normalization form named by _f_ as specified in <a href=\"https://www.unicode.org/versions/latest/ch03.pdf\">the latest Unicode Standard, Normalization Forms</a>.\n  1. Return _ns_.","code":"\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. If _form_ is *undefined*, let _f_ be *\"NFC\"*.\n          1. Else, let _f_ be ? ToString(_form_).\n          1. If _f_ is not one of *\"NFC\"*, *\"NFD\"*, *\"NFKC\"*, or *\"NFKD\"*, throw a *RangeError* exception.\n          1. Let _ns_ be the String value that is the result of normalizing _S_ into the normalization form named by _f_ as specified in <a href=\"https://www.unicode.org/versions/latest/ch03.pdf\">the latest Unicode Standard, Normalization Forms</a>.\n          1. Return _ns_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"padEnd"}},"params":[{"name":"maxLength","ty":"Unknown","kind":{"Normal":{}}},{"name":"fillString","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? RequireObjectCoercible(*this* value).\n  1. Return ? StringPaddingBuiltinsImpl(_O_, _maxLength_, _fillString_, ~end~).","code":"\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Return ? StringPaddingBuiltinsImpl(_O_, _maxLength_, _fillString_, ~end~).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"padStart"}},"params":[{"name":"maxLength","ty":"Unknown","kind":{"Normal":{}}},{"name":"fillString","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? RequireObjectCoercible(*this* value).\n  1. Return ? StringPaddingBuiltinsImpl(_O_, _maxLength_, _fillString_, ~start~).","code":"\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Return ? StringPaddingBuiltinsImpl(_O_, _maxLength_, _fillString_, ~start~).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"StringPaddingBuiltinsImpl","params":[{"name":"O","ty":"ESValue","kind":{"Normal":{}}},{"name":"maxLength","ty":"ESValue","kind":{"Normal":{}}},{"name":"fillString","ty":"ESValue","kind":{"Normal":{}}},{"name":"placement","ty":"Enum[~end~, ~start~]","kind":{"Normal":{}}}],"retTy":"Normal[String] | Throw"}},"body":"\n  1. Let _S_ be ? ToString(_O_).\n  1. Let _intMaxLength_ be ℝ(? ToLength(_maxLength_)).\n  1. Let _stringLength_ be the length of _S_.\n  1. If _intMaxLength_ ≤ _stringLength_, return _S_.\n  1. If _fillString_ is *undefined*, set _fillString_ to the String value consisting solely of the code unit 0x0020 (SPACE).\n  1. Else, set _fillString_ to ? ToString(_fillString_).\n  1. Return StringPad(_S_, _intMaxLength_, _fillString_, _placement_).","code":"\n            1. Let _S_ be ? ToString(_O_).\n            1. Let _intMaxLength_ be ℝ(? ToLength(_maxLength_)).\n            1. Let _stringLength_ be the length of _S_.\n            1. If _intMaxLength_ ≤ _stringLength_, return _S_.\n            1. If _fillString_ is *undefined*, set _fillString_ to the String value consisting solely of the code unit 0x0020 (SPACE).\n            1. Else, set _fillString_ to ? ToString(_fillString_).\n            1. Return StringPad(_S_, _intMaxLength_, _fillString_, _placement_).\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"StringPad","params":[{"name":"S","ty":"String","kind":{"Normal":{}}},{"name":"maxLength","ty":"NonNegInt","kind":{"Normal":{}}},{"name":"fillString","ty":"String","kind":{"Normal":{}}},{"name":"placement","ty":"Enum[~end~, ~start~]","kind":{"Normal":{}}}],"retTy":"String"}},"body":"\n  1. Let _stringLength_ be the length of _S_.\n  1. If _maxLength_ ≤ _stringLength_, return _S_.\n  1. If _fillString_ is *\"\"*, return _S_.\n  1. Let _fillLen_ be _maxLength_ - _stringLength_.\n  1. Let _truncatedStringFiller_ be the String value consisting of repeated concatenations of _fillString_ truncated to length _fillLen_.\n  1. If _placement_ is ~start~, return the string-concatenation of _truncatedStringFiller_ and _S_.\n  1. Else, return the string-concatenation of _S_ and _truncatedStringFiller_.","code":"\n            1. Let _stringLength_ be the length of _S_.\n            1. If _maxLength_ ≤ _stringLength_, return _S_.\n            1. If _fillString_ is the empty String, return _S_.\n            1. Let _fillLen_ be _maxLength_ - _stringLength_.\n            1. Let _truncatedStringFiller_ be the String value consisting of repeated concatenations of _fillString_ truncated to length _fillLen_.\n            1. If _placement_ is ~start~, return the string-concatenation of _truncatedStringFiller_ and _S_.\n            1. Else, return the string-concatenation of _S_ and _truncatedStringFiller_.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ToZeroPaddedDecimalString","params":[{"name":"n","ty":"NonNegInt","kind":{"Normal":{}}},{"name":"minLength","ty":"NonNegInt","kind":{"Normal":{}}}],"retTy":"String"}},"body":"\n  1. Let _S_ be the String representation of _n_, formatted as a decimal number.\n  1. Return StringPad(_S_, _minLength_, *\"0\"*, ~start~).","code":"\n            1. Let _S_ be the String representation of _n_, formatted as a decimal number.\n            1. Return StringPad(_S_, _minLength_, *\"0\"*, ~start~).\n          "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"repeat"}},"params":[{"name":"count","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? RequireObjectCoercible(*this* value).\n  1. Let _S_ be ? ToString(_O_).\n  1. Let _n_ be ? ToIntegerOrInfinity(_count_).\n  1. If _n_ < 0 or _n_ = +∞, throw a *RangeError* exception.\n  1. If _n_ = 0, return *\"\"*.\n  1. Return the String value that is made from _n_ copies of _S_ appended together.","code":"\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _n_ be ? ToIntegerOrInfinity(_count_).\n          1. If _n_ < 0 or _n_ = +∞, throw a *RangeError* exception.\n          1. If _n_ = 0, return the empty String.\n          1. Return the String value that is made from _n_ copies of _S_ appended together.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"replace"}},"params":[{"name":"searchValue","ty":"Unknown","kind":{"Normal":{}}},{"name":"replaceValue","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? RequireObjectCoercible(*this* value).\n  1. If _searchValue_ is neither *undefined* nor *null*, then\n    1. Let _replacer_ be ? GetMethod(_searchValue_, @@replace).\n    1. If _replacer_ is not *undefined*, then\n      1. Return ? Call(_replacer_, _searchValue_, « _O_, _replaceValue_ »).\n  1. Let _string_ be ? ToString(_O_).\n  1. Let _searchString_ be ? ToString(_searchValue_).\n  1. Let _functionalReplace_ be IsCallable(_replaceValue_).\n  1. If _functionalReplace_ is *false*, then\n    1. Set _replaceValue_ to ? ToString(_replaceValue_).\n  1. Let _searchLength_ be the length of _searchString_.\n  1. Let _position_ be StringIndexOf(_string_, _searchString_, 0).\n  1. If _position_ = -1, return _string_.\n  1. Let _preceding_ be the substring of _string_ from 0 to _position_.\n  1. Let _following_ be the substring of _string_ from _position_ + _searchLength_.\n  1. If _functionalReplace_ is *true*, then\n    1. Let _replacement_ be ? ToString(? Call(_replaceValue_, *undefined*, « _searchString_, 𝔽(_position_), _string_ »)).\n  1. Else,\n    1. Assert: _replaceValue_ is a String.\n    1. Let _captures_ be « ».\n    1. Let _replacement_ be ! GetSubstitution(_searchString_, _string_, _position_, _captures_, *undefined*, _replaceValue_).\n  1. Return the string-concatenation of _preceding_, _replacement_, and _following_.","code":"\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. If _searchValue_ is neither *undefined* nor *null*, then\n            1. Let _replacer_ be ? GetMethod(_searchValue_, @@replace).\n            1. If _replacer_ is not *undefined*, then\n              1. Return ? Call(_replacer_, _searchValue_, « _O_, _replaceValue_ »).\n          1. Let _string_ be ? ToString(_O_).\n          1. Let _searchString_ be ? ToString(_searchValue_).\n          1. Let _functionalReplace_ be IsCallable(_replaceValue_).\n          1. If _functionalReplace_ is *false*, then\n            1. Set _replaceValue_ to ? ToString(_replaceValue_).\n          1. Let _searchLength_ be the length of _searchString_.\n          1. Let _position_ be StringIndexOf(_string_, _searchString_, 0).\n          1. If _position_ = -1, return _string_.\n          1. Let _preceding_ be the substring of _string_ from 0 to _position_.\n          1. Let _following_ be the substring of _string_ from _position_ + _searchLength_.\n          1. If _functionalReplace_ is *true*, then\n            1. Let _replacement_ be ? ToString(? Call(_replaceValue_, *undefined*, « _searchString_, 𝔽(_position_), _string_ »)).\n          1. Else,\n            1. Assert: _replaceValue_ is a String.\n            1. Let _captures_ be a new empty List.\n            1. Let _replacement_ be ! GetSubstitution(_searchString_, _string_, _position_, _captures_, *undefined*, _replaceValue_).\n          1. Return the string-concatenation of _preceding_, _replacement_, and _following_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetSubstitution","params":[{"name":"matched","ty":"String","kind":{"Normal":{}}},{"name":"str","ty":"String","kind":{"Normal":{}}},{"name":"position","ty":"NonNegInt","kind":{"Normal":{}}},{"name":"captures","ty":"List[String | Undefined]","kind":{"Normal":{}}},{"name":"namedCaptures","ty":"Record[Object] | Undefined","kind":{"Normal":{}}},{"name":"replacementTemplate","ty":"String","kind":{"Normal":{}}}],"retTy":"Normal[String] | Throw"}},"body":"\n  1. Let _stringLength_ be the length of _str_.\n  1. Assert: _position_ ≤ _stringLength_.\n  1. Let _result_ be *\"\"*.\n  1. Let _templateRemainder_ be _replacementTemplate_.\n  1. Repeat, while _templateRemainder_ is not *\"\"*,\n    1. [declared=\"ref,refReplacement\"] NOTE: The following steps isolate _ref_ (a prefix of _templateRemainder_), determine _refReplacement_ (its replacement), and then append that replacement to _result_.\n    1. If _templateRemainder_ starts with *\"$$\"*, then\n      1. Let _ref_ be *\"$$\"*.\n      1. Let _refReplacement_ be *\"$\"*.\n    1. Else if _templateRemainder_ starts with *\"$`\"*, then\n      1. Let _ref_ be *\"$`\"*.\n      1. Let _refReplacement_ be the substring of _str_ from 0 to _position_.\n    1. Else if _templateRemainder_ starts with *\"$&\"*, then\n      1. Let _ref_ be *\"$&\"*.\n      1. Let _refReplacement_ be _matched_.\n    1. Else if _templateRemainder_ starts with *\"$'\"* (0x0024 (DOLLAR SIGN) followed by 0x0027 (APOSTROPHE)), then\n      1. Let _ref_ be *\"$'\"*.\n      1. Let _matchLength_ be the length of _matched_.\n      1. Let _tailPos_ be _position_ + _matchLength_.\n      1. Let _refReplacement_ be the substring of _str_ from min(_tailPos_, _stringLength_).\n      1. NOTE: _tailPos_ can exceed _stringLength_ only if this abstract operation was invoked by a call to the intrinsic @@replace method of %RegExp.prototype% on an object whose *\"exec\"* property is not the intrinsic %RegExp.prototype.exec%.\n    1. Else if _templateRemainder_ starts with *\"$\"* followed by 1 or more decimal digits, then\n      1. If _templateRemainder_ starts with *\"$\"* followed by 2 or more decimal digits, let _digitCount_ be 2. Otherwise, let _digitCount_ be 1.\n      1. Let _digits_ be the substring of _templateRemainder_ from 1 to 1 + _digitCount_.\n      1. Let _index_ be ℝ(StringToNumber(_digits_)).\n      1. Assert: 0 ≤ _index_ ≤ 99..\n      1. Let _captureLen_ be the number of elements in _captures_.\n      1. If _index_ > _captureLen_ and _digitCount_ = 2, then\n        1. NOTE: When a two-digit replacement pattern specifies an index exceeding the count of capturing groups, it is treated as a one-digit replacement pattern followed by a literal digit.\n        1. Set _digitCount_ to 1.\n        1. Set _digits_ to the substring of _digits_ from 0 to 1.\n        1. Set _index_ to ℝ(StringToNumber(_digits_)).\n      1. Let _ref_ be the substring of _templateRemainder_ from 0 to 1 + _digitCount_.\n      1. If 1 ≤ _index_ ≤ _captureLen_, then\n        1. Let _capture_ be _captures_[_index_ - 1].\n        1. If _capture_ is *undefined*, then\n          1. Let _refReplacement_ be *\"\"*.\n        1. Else,\n          1. Let _refReplacement_ be _capture_.\n      1. Else,\n        1. Let _refReplacement_ be _ref_.\n    1. Else if _templateRemainder_ starts with *\"$<\"*, then\n      1. Let _gtPos_ be StringIndexOf(_templateRemainder_, *\">\"*, 0).\n      1. If _gtPos_ = -1 or _namedCaptures_ is *undefined*, then\n        1. Let _ref_ be *\"$<\"*.\n        1. Let _refReplacement_ be _ref_.\n      1. Else,\n        1. Let _ref_ be the substring of _templateRemainder_ from 0 to _gtPos_ + 1.\n        1. Let _groupName_ be the substring of _templateRemainder_ from 2 to _gtPos_.\n        1. Assert: _namedCaptures_ is a Record[Object].\n        1. Let _capture_ be ? Get(_namedCaptures_, _groupName_).\n        1. If _capture_ is *undefined*, then\n          1. Let _refReplacement_ be *\"\"*.\n        1. Else,\n          1. Let _refReplacement_ be ? ToString(_capture_).\n    1. Else,\n      1. Let _ref_ be the substring of _templateRemainder_ from 0 to 1.\n      1. Let _refReplacement_ be _ref_.\n    1. Let _refLength_ be the length of _ref_.\n    1. Set _templateRemainder_ to the substring of _templateRemainder_ from _refLength_.\n    1. Set _result_ to the string-concatenation of _result_ and _refReplacement_.\n  1. Return _result_.","code":"\n            1. Let _stringLength_ be the length of _str_.\n            1. Assert: _position_ ≤ _stringLength_.\n            1. Let _result_ be the empty String.\n            1. Let _templateRemainder_ be _replacementTemplate_.\n            1. Repeat, while _templateRemainder_ is not the empty String,\n              1. [declared=\"ref,refReplacement\"] NOTE: The following steps isolate _ref_ (a prefix of _templateRemainder_), determine _refReplacement_ (its replacement), and then append that replacement to _result_.\n              1. If _templateRemainder_ starts with *\"$$\"*, then\n                1. Let _ref_ be *\"$$\"*.\n                1. Let _refReplacement_ be *\"$\"*.\n              1. Else if _templateRemainder_ starts with *\"$`\"*, then\n                1. Let _ref_ be *\"$`\"*.\n                1. Let _refReplacement_ be the substring of _str_ from 0 to _position_.\n              1. Else if _templateRemainder_ starts with *\"$&\"*, then\n                1. Let _ref_ be *\"$&\"*.\n                1. Let _refReplacement_ be _matched_.\n              1. Else if _templateRemainder_ starts with *\"$'\"* (0x0024 (DOLLAR SIGN) followed by 0x0027 (APOSTROPHE)), then\n                1. Let _ref_ be *\"$'\"*.\n                1. Let _matchLength_ be the length of _matched_.\n                1. Let _tailPos_ be _position_ + _matchLength_.\n                1. Let _refReplacement_ be the substring of _str_ from min(_tailPos_, _stringLength_).\n                1. NOTE: _tailPos_ can exceed _stringLength_ only if this abstract operation was invoked by a call to the intrinsic @@replace method of %RegExp.prototype% on an object whose *\"exec\"* property is not the intrinsic %RegExp.prototype.exec%.\n              1. Else if _templateRemainder_ starts with *\"$\"* followed by 1 or more decimal digits, then\n                1. If _templateRemainder_ starts with *\"$\"* followed by 2 or more decimal digits, let _digitCount_ be 2. Otherwise, let _digitCount_ be 1.\n                1. Let _digits_ be the substring of _templateRemainder_ from 1 to 1 + _digitCount_.\n                1. Let _index_ be ℝ(StringToNumber(_digits_)).\n                1. Assert: 0 ≤ _index_ ≤ 99.\n                1. Let _captureLen_ be the number of elements in _captures_.\n                1. If _index_ > _captureLen_ and _digitCount_ = 2, then\n                  1. NOTE: When a two-digit replacement pattern specifies an index exceeding the count of capturing groups, it is treated as a one-digit replacement pattern followed by a literal digit.\n                  1. Set _digitCount_ to 1.\n                  1. Set _digits_ to the substring of _digits_ from 0 to 1.\n                  1. Set _index_ to ℝ(StringToNumber(_digits_)).\n                1. Let _ref_ be the substring of _templateRemainder_ from 0 to 1 + _digitCount_.\n                1. If 1 ≤ _index_ ≤ _captureLen_, then\n                  1. Let _capture_ be _captures_[_index_ - 1].\n                  1. If _capture_ is *undefined*, then\n                    1. Let _refReplacement_ be the empty String.\n                  1. Else,\n                    1. Let _refReplacement_ be _capture_.\n                1. Else,\n                  1. Let _refReplacement_ be _ref_.\n              1. Else if _templateRemainder_ starts with *\"$<\"*, then\n                1. Let _gtPos_ be StringIndexOf(_templateRemainder_, *\">\"*, 0).\n                1. If _gtPos_ = -1 or _namedCaptures_ is *undefined*, then\n                  1. Let _ref_ be *\"$<\"*.\n                  1. Let _refReplacement_ be _ref_.\n                1. Else,\n                  1. Let _ref_ be the substring of _templateRemainder_ from 0 to _gtPos_ + 1.\n                  1. Let _groupName_ be the substring of _templateRemainder_ from 2 to _gtPos_.\n                  1. Assert: _namedCaptures_ is an Object.\n                  1. Let _capture_ be ? Get(_namedCaptures_, _groupName_).\n                  1. If _capture_ is *undefined*, then\n                    1. Let _refReplacement_ be the empty String.\n                  1. Else,\n                    1. Let _refReplacement_ be ? ToString(_capture_).\n              1. Else,\n                1. Let _ref_ be the substring of _templateRemainder_ from 0 to 1.\n                1. Let _refReplacement_ be _ref_.\n              1. Let _refLength_ be the length of _ref_.\n              1. Set _templateRemainder_ to the substring of _templateRemainder_ from _refLength_.\n              1. Set _result_ to the string-concatenation of _result_ and _refReplacement_.\n            1. Return _result_.\n          "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"replaceAll"}},"params":[{"name":"searchValue","ty":"Unknown","kind":{"Normal":{}}},{"name":"replaceValue","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? RequireObjectCoercible(*this* value).\n  1. If _searchValue_ is neither *undefined* nor *null*, then\n    1. Let _isRegExp_ be ? IsRegExp(_searchValue_).\n    1. If _isRegExp_ is *true*, then\n      1. Let _flags_ be ? Get(_searchValue_, *\"flags\"*).\n      1. Perform ? RequireObjectCoercible(_flags_).\n      1. If ? ToString(_flags_) does not contain *\"g\"*, throw a *TypeError* exception.\n    1. Let _replacer_ be ? GetMethod(_searchValue_, @@replace).\n    1. If _replacer_ is not *undefined*, then\n      1. Return ? Call(_replacer_, _searchValue_, « _O_, _replaceValue_ »).\n  1. Let _string_ be ? ToString(_O_).\n  1. Let _searchString_ be ? ToString(_searchValue_).\n  1. Let _functionalReplace_ be IsCallable(_replaceValue_).\n  1. If _functionalReplace_ is *false*, then\n    1. Set _replaceValue_ to ? ToString(_replaceValue_).\n  1. Let _searchLength_ be the length of _searchString_.\n  1. Let _advanceBy_ be max(1, _searchLength_).\n  1. Let _matchPositions_ be « ».\n  1. Let _position_ be StringIndexOf(_string_, _searchString_, 0).\n  1. Repeat, while _position_ ≠ -1,\n    1. Append _position_ to _matchPositions_.\n    1. Set _position_ to StringIndexOf(_string_, _searchString_, _position_ + _advanceBy_).\n  1. Let _endOfLastMatch_ be 0.\n  1. Let _result_ be *\"\"*.\n  1. For each _p_ of _matchPositions_, do\n    1. Let _preserved_ be the substring of _string_ from _endOfLastMatch_ to _p_.\n    1. If _functionalReplace_ is *true*, then\n      1. Let _replacement_ be ? ToString(? Call(_replaceValue_, *undefined*, « _searchString_, 𝔽(_p_), _string_ »)).\n    1. Else,\n      1. Assert: _replaceValue_ is a String.\n      1. Let _captures_ be « ».\n      1. Let _replacement_ be ! GetSubstitution(_searchString_, _string_, _p_, _captures_, *undefined*, _replaceValue_).\n    1. Set _result_ to the string-concatenation of _result_, _preserved_, and _replacement_.\n    1. Set _endOfLastMatch_ to _p_ + _searchLength_.\n  1. If _endOfLastMatch_ < the length of _string_, then\n    1. Set _result_ to the string-concatenation of _result_ and the substring of _string_ from _endOfLastMatch_.\n  1. Return _result_.","code":"\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. If _searchValue_ is neither *undefined* nor *null*, then\n            1. Let _isRegExp_ be ? IsRegExp(_searchValue_).\n            1. If _isRegExp_ is *true*, then\n              1. Let _flags_ be ? Get(_searchValue_, *\"flags\"*).\n              1. Perform ? RequireObjectCoercible(_flags_).\n              1. If ? ToString(_flags_) does not contain *\"g\"*, throw a *TypeError* exception.\n            1. Let _replacer_ be ? GetMethod(_searchValue_, @@replace).\n            1. If _replacer_ is not *undefined*, then\n              1. Return ? Call(_replacer_, _searchValue_, « _O_, _replaceValue_ »).\n          1. Let _string_ be ? ToString(_O_).\n          1. Let _searchString_ be ? ToString(_searchValue_).\n          1. Let _functionalReplace_ be IsCallable(_replaceValue_).\n          1. If _functionalReplace_ is *false*, then\n            1. Set _replaceValue_ to ? ToString(_replaceValue_).\n          1. Let _searchLength_ be the length of _searchString_.\n          1. Let _advanceBy_ be max(1, _searchLength_).\n          1. Let _matchPositions_ be a new empty List.\n          1. Let _position_ be StringIndexOf(_string_, _searchString_, 0).\n          1. Repeat, while _position_ ≠ -1,\n            1. Append _position_ to _matchPositions_.\n            1. Set _position_ to StringIndexOf(_string_, _searchString_, _position_ + _advanceBy_).\n          1. Let _endOfLastMatch_ be 0.\n          1. Let _result_ be the empty String.\n          1. For each element _p_ of _matchPositions_, do\n            1. Let _preserved_ be the substring of _string_ from _endOfLastMatch_ to _p_.\n            1. If _functionalReplace_ is *true*, then\n              1. Let _replacement_ be ? ToString(? Call(_replaceValue_, *undefined*, « _searchString_, 𝔽(_p_), _string_ »)).\n            1. Else,\n              1. Assert: _replaceValue_ is a String.\n              1. Let _captures_ be a new empty List.\n              1. Let _replacement_ be ! GetSubstitution(_searchString_, _string_, _p_, _captures_, *undefined*, _replaceValue_).\n            1. Set _result_ to the string-concatenation of _result_, _preserved_, and _replacement_.\n            1. Set _endOfLastMatch_ to _p_ + _searchLength_.\n          1. If _endOfLastMatch_ < the length of _string_, then\n            1. Set _result_ to the string-concatenation of _result_ and the substring of _string_ from _endOfLastMatch_.\n          1. Return _result_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"search"}},"params":[{"name":"regexp","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? RequireObjectCoercible(*this* value).\n  1. If _regexp_ is neither *undefined* nor *null*, then\n    1. Let _searcher_ be ? GetMethod(_regexp_, @@search).\n    1. If _searcher_ is not *undefined*, then\n      1. Return ? Call(_searcher_, _regexp_, « _O_ »).\n  1. Let _string_ be ? ToString(_O_).\n  1. Let _rx_ be ? RegExpCreate(_regexp_, *undefined*).\n  1. Return ? Invoke(_rx_, @@search, « _string_ »).","code":"\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. If _regexp_ is neither *undefined* nor *null*, then\n            1. Let _searcher_ be ? GetMethod(_regexp_, @@search).\n            1. If _searcher_ is not *undefined*, then\n              1. Return ? Call(_searcher_, _regexp_, « _O_ »).\n          1. Let _string_ be ? ToString(_O_).\n          1. Let _rx_ be ? RegExpCreate(_regexp_, *undefined*).\n          1. Return ? Invoke(_rx_, @@search, « _string_ »).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"slice"}},"params":[{"name":"start","ty":"Unknown","kind":{"Normal":{}}},{"name":"end","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? RequireObjectCoercible(*this* value).\n  1. Let _S_ be ? ToString(_O_).\n  1. Let _len_ be the length of _S_.\n  1. Let _intStart_ be ? ToIntegerOrInfinity(_start_).\n  1. If _intStart_ = -∞, let _from_ be 0.\n  1. Else if _intStart_ < 0, let _from_ be max(_len_ + _intStart_, 0).\n  1. Else, let _from_ be min(_intStart_, _len_).\n  1. If _end_ is *undefined*, let _intEnd_ be _len_.\n  1. Else, let _intEnd_ be ? ToIntegerOrInfinity(_end_).\n  1. If _intEnd_ = -∞, let _to_ be 0.\n  1. Else if _intEnd_ < 0, let _to_ be max(_len_ + _intEnd_, 0).\n  1. Else, let _to_ be min(_intEnd_, _len_).\n  1. If _from_ ≥ _to_, return *\"\"*.\n  1. Return the substring of _S_ from _from_ to _to_.","code":"\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _len_ be the length of _S_.\n          1. Let _intStart_ be ? ToIntegerOrInfinity(_start_).\n          1. If _intStart_ = -∞, let _from_ be 0.\n          1. Else if _intStart_ < 0, let _from_ be max(_len_ + _intStart_, 0).\n          1. Else, let _from_ be min(_intStart_, _len_).\n          1. If _end_ is *undefined*, let _intEnd_ be _len_; else let _intEnd_ be ? ToIntegerOrInfinity(_end_).\n          1. If _intEnd_ = -∞, let _to_ be 0.\n          1. Else if _intEnd_ < 0, let _to_ be max(_len_ + _intEnd_, 0).\n          1. Else, let _to_ be min(_intEnd_, _len_).\n          1. If _from_ ≥ _to_, return the empty String.\n          1. Return the substring of _S_ from _from_ to _to_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"split"}},"params":[{"name":"separator","ty":"Unknown","kind":{"Normal":{}}},{"name":"limit","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? RequireObjectCoercible(*this* value).\n  1. If _separator_ is neither *undefined* nor *null*, then\n    1. Let _splitter_ be ? GetMethod(_separator_, @@split).\n    1. If _splitter_ is not *undefined*, then\n      1. Return ? Call(_splitter_, _separator_, « _O_, _limit_ »).\n  1. Let _S_ be ? ToString(_O_).\n  1. If _limit_ is *undefined*, let _lim_ be 2<sup>32</sup> - 1.\n  1. Else, let _lim_ be ℝ(? ToUint32(_limit_)).\n  1. Let _R_ be ? ToString(_separator_).\n  1. If _lim_ = 0, then\n    1. Return CreateArrayFromList(« »).\n  1. If _separator_ is *undefined*, then\n    1. Return CreateArrayFromList(« _S_ »).\n  1. Let _separatorLength_ be the length of _R_.\n  1. If _separatorLength_ = 0, then\n    1. Let _head_ be the substring of _S_ from 0 to _lim_.\n    1. Let _codeUnits_ be a List consisting of the sequence of code units that are the elements of _head_.\n    1. Return CreateArrayFromList(_codeUnits_).\n  1. If _S_ is *\"\"*, return CreateArrayFromList(« _S_ »).\n  1. Let _substrings_ be « ».\n  1. Let _i_ be 0.\n  1. Let _j_ be StringIndexOf(_S_, _R_, 0).\n  1. Repeat, while _j_ ≠ -1,\n    1. Let _T_ be the substring of _S_ from _i_ to _j_.\n    1. Append _T_ to _substrings_.\n    1. If the number of elements in _substrings_ is _lim_, return CreateArrayFromList(_substrings_).\n    1. Set _i_ to _j_ + _separatorLength_.\n    1. Set _j_ to StringIndexOf(_S_, _R_, _i_).\n  1. Let _T_ be the substring of _S_ from _i_.\n  1. Append _T_ to _substrings_.\n  1. Return CreateArrayFromList(_substrings_).","code":"\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. If _separator_ is neither *undefined* nor *null*, then\n            1. Let _splitter_ be ? GetMethod(_separator_, @@split).\n            1. If _splitter_ is not *undefined*, then\n              1. Return ? Call(_splitter_, _separator_, « _O_, _limit_ »).\n          1. Let _S_ be ? ToString(_O_).\n          1. If _limit_ is *undefined*, let _lim_ be 2<sup>32</sup> - 1; else let _lim_ be ℝ(? ToUint32(_limit_)).\n          1. Let _R_ be ? ToString(_separator_).\n          1. If _lim_ = 0, then\n            1. Return CreateArrayFromList(« »).\n          1. If _separator_ is *undefined*, then\n            1. Return CreateArrayFromList(« _S_ »).\n          1. Let _separatorLength_ be the length of _R_.\n          1. If _separatorLength_ = 0, then\n            1. Let _head_ be the substring of _S_ from 0 to _lim_.\n            1. Let _codeUnits_ be a List consisting of the sequence of code units that are the elements of _head_.\n            1. Return CreateArrayFromList(_codeUnits_).\n          1. If _S_ is the empty String, return CreateArrayFromList(« _S_ »).\n          1. Let _substrings_ be a new empty List.\n          1. Let _i_ be 0.\n          1. Let _j_ be StringIndexOf(_S_, _R_, 0).\n          1. Repeat, while _j_ ≠ -1,\n            1. Let _T_ be the substring of _S_ from _i_ to _j_.\n            1. Append _T_ to _substrings_.\n            1. If the number of elements in _substrings_ is _lim_, return CreateArrayFromList(_substrings_).\n            1. Set _i_ to _j_ + _separatorLength_.\n            1. Set _j_ to StringIndexOf(_S_, _R_, _i_).\n          1. Let _T_ be the substring of _S_ from _i_.\n          1. Append _T_ to _substrings_.\n          1. Return CreateArrayFromList(_substrings_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"startsWith"}},"params":[{"name":"searchString","ty":"Unknown","kind":{"Normal":{}}},{"name":"position","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? RequireObjectCoercible(*this* value).\n  1. Let _S_ be ? ToString(_O_).\n  1. Let _isRegExp_ be ? IsRegExp(_searchString_).\n  1. If _isRegExp_ is *true*, throw a *TypeError* exception.\n  1. Let _searchStr_ be ? ToString(_searchString_).\n  1. Let _len_ be the length of _S_.\n  1. If _position_ is *undefined*, let _pos_ be 0.\n  1. Else, let _pos_ be ? ToIntegerOrInfinity(_position_).\n  1. Let _start_ be the result of clamping _pos_ between 0 and _len_.\n  1. Let _searchLength_ be the length of _searchStr_.\n  1. If _searchLength_ = 0, return *true*.\n  1. Let _end_ be _start_ + _searchLength_.\n  1. If _end_ > _len_, return *false*.\n  1. Let _substring_ be the substring of _S_ from _start_ to _end_.\n  1. If _substring_ is _searchStr_, return *true*.\n  1. Return *false*.","code":"\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _isRegExp_ be ? IsRegExp(_searchString_).\n          1. If _isRegExp_ is *true*, throw a *TypeError* exception.\n          1. Let _searchStr_ be ? ToString(_searchString_).\n          1. Let _len_ be the length of _S_.\n          1. If _position_ is *undefined*, let _pos_ be 0; else let _pos_ be ? ToIntegerOrInfinity(_position_).\n          1. Let _start_ be the result of clamping _pos_ between 0 and _len_.\n          1. Let _searchLength_ be the length of _searchStr_.\n          1. If _searchLength_ = 0, return *true*.\n          1. Let _end_ be _start_ + _searchLength_.\n          1. If _end_ > _len_, return *false*.\n          1. Let _substring_ be the substring of _S_ from _start_ to _end_.\n          1. If _substring_ is _searchStr_, return *true*.\n          1. Return *false*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"substring"}},"params":[{"name":"start","ty":"Unknown","kind":{"Normal":{}}},{"name":"end","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? RequireObjectCoercible(*this* value).\n  1. Let _S_ be ? ToString(_O_).\n  1. Let _len_ be the length of _S_.\n  1. Let _intStart_ be ? ToIntegerOrInfinity(_start_).\n  1. If _end_ is *undefined*, let _intEnd_ be _len_.\n  1. Else, let _intEnd_ be ? ToIntegerOrInfinity(_end_).\n  1. Let _finalStart_ be the result of clamping _intStart_ between 0 and _len_.\n  1. Let _finalEnd_ be the result of clamping _intEnd_ between 0 and _len_.\n  1. Let _from_ be min(_finalStart_, _finalEnd_).\n  1. Let _to_ be max(_finalStart_, _finalEnd_).\n  1. Return the substring of _S_ from _from_ to _to_.","code":"\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _len_ be the length of _S_.\n          1. Let _intStart_ be ? ToIntegerOrInfinity(_start_).\n          1. If _end_ is *undefined*, let _intEnd_ be _len_; else let _intEnd_ be ? ToIntegerOrInfinity(_end_).\n          1. Let _finalStart_ be the result of clamping _intStart_ between 0 and _len_.\n          1. Let _finalEnd_ be the result of clamping _intEnd_ between 0 and _len_.\n          1. Let _from_ be min(_finalStart_, _finalEnd_).\n          1. Let _to_ be max(_finalStart_, _finalEnd_).\n          1. Return the substring of _S_ from _from_ to _to_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"toLowerCase"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? RequireObjectCoercible(*this* value).\n  1. Let _S_ be ? ToString(_O_).\n  1. Let _sText_ be StringToCodePoints(_S_).\n  1. Let _lowerText_ be the result of toLowercase(_sText_), according to the Unicode Default Case Conversion algorithm.\n  1. Let _L_ be CodePointsToString(_lowerText_).\n  1. Return _L_.","code":"\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _sText_ be StringToCodePoints(_S_).\n          1. Let _lowerText_ be the result of toLowercase(_sText_), according to the Unicode Default Case Conversion algorithm.\n          1. Let _L_ be CodePointsToString(_lowerText_).\n          1. Return _L_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"toString"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Return ? ThisStringValue(*this* value).","code":"\n          1. Return ? ThisStringValue(*this* value).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"toWellFormed"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? RequireObjectCoercible(*this* value).\n  1. Let _S_ be ? ToString(_O_).\n  1. Let _strLen_ be the length of _S_.\n  1. Let _k_ be 0.\n  1. Let _result_ be *\"\"*.\n  1. Repeat, while _k_ < _strLen_,\n    1. Let _cp_ be CodePointAt(_S_, _k_).\n    1. If _cp_.[[IsUnpairedSurrogate]] is *true*, then\n      1. Set _result_ to the string-concatenation of _result_ and 0xfffd (REPLACEMENT CHARACTER).\n    1. Else,\n      1. Set _result_ to the string-concatenation of _result_ and UTF16EncodeCodePoint(_cp_.[[CodePoint]]).\n    1. Set _k_ to _k_ + _cp_.[[CodeUnitCount]].\n  1. Return _result_.","code":"\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _S_ be ? ToString(_O_).\n          1. Let _strLen_ be the length of _S_.\n          1. Let _k_ be 0.\n          1. Let _result_ be the empty String.\n          1. Repeat, while _k_ < _strLen_,\n            1. Let _cp_ be CodePointAt(_S_, _k_).\n            1. If _cp_.[[IsUnpairedSurrogate]] is *true*, then\n              1. Set _result_ to the string-concatenation of _result_ and 0xFFFD (REPLACEMENT CHARACTER).\n            1. Else,\n              1. Set _result_ to the string-concatenation of _result_ and UTF16EncodeCodePoint(_cp_.[[CodePoint]]).\n            1. Set _k_ to _k_ + _cp_.[[CodeUnitCount]].\n          1. Return _result_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"trim"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _S_ be *this* value.\n  1. Return ? TrimString(_S_, ~start+end~).","code":"\n          1. Let _S_ be the *this* value.\n          1. Return ? TrimString(_S_, ~start+end~).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"TrimString","params":[{"name":"string","ty":"ESValue","kind":{"Normal":{}}},{"name":"where","ty":"Enum[~end~, ~start+end~, ~start~]","kind":{"Normal":{}}}],"retTy":"Normal[String] | Throw"}},"body":"\n  1. Let _str_ be ? RequireObjectCoercible(_string_).\n  1. Let _S_ be ? ToString(_str_).\n  1. If _where_ is ~start~, then\n    1. Let _T_ be the String value that is a copy of _S_ with leading white space removed.\n  1. Else if _where_ is ~end~, then\n    1. Let _T_ be the String value that is a copy of _S_ with trailing white space removed.\n  1. Else,\n    1. Assert: _where_ is ~start+end~.\n    1. Let _T_ be the String value that is a copy of _S_ with both leading and trailing white space removed.\n  1. Return _T_.","code":"\n            1. Let _str_ be ? RequireObjectCoercible(_string_).\n            1. Let _S_ be ? ToString(_str_).\n            1. If _where_ is ~start~, then\n              1. Let _T_ be the String value that is a copy of _S_ with leading white space removed.\n            1. Else if _where_ is ~end~, then\n              1. Let _T_ be the String value that is a copy of _S_ with trailing white space removed.\n            1. Else,\n              1. Assert: _where_ is ~start+end~.\n              1. Let _T_ be the String value that is a copy of _S_ with both leading and trailing white space removed.\n            1. Return _T_.\n          "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"trimEnd"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _S_ be *this* value.\n  1. Return ? TrimString(_S_, ~end~).","code":"\n          1. Let _S_ be the *this* value.\n          1. Return ? TrimString(_S_, ~end~).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"trimStart"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _S_ be *this* value.\n  1. Return ? TrimString(_S_, ~start~).","code":"\n          1. Let _S_ be the *this* value.\n          1. Return ? TrimString(_S_, ~start~).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"name":"valueOf"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Return ? ThisStringValue(*this* value).","code":"\n          1. Return ? ThisStringValue(*this* value).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ThisStringValue","params":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[String] | Throw"}},"body":"\n  1. If _value_ is a String, return _value_.\n  1. If _value_ is a Record[Object] and _value_ has a [[StringData]] internal slot, then\n    1. Let _s_ be _value_.[[StringData]].\n    1. Assert: _s_ is a String.\n    1. Return _s_.\n  1. Throw a *TypeError* exception.","code":"\n            1. If _value_ is a String, return _value_.\n            1. If _value_ is an Object and _value_ has a [[StringData]] internal slot, then\n              1. Let _s_ be _value_.[[StringData]].\n              1. Assert: _s_ is a String.\n              1. Return _s_.\n            1. Throw a *TypeError* exception.\n          "},{"head":{"BuiltinHead":{"path":{"SymbolAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"String"}},"name":"prototype"}},"symbol":"iterator"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? RequireObjectCoercible(*this* value).\n  1. Let _s_ be ? ToString(_O_).\n  1. Let _closure_ be a new Abstract Closure with no parameters that captures _s_ and performs the following steps when called:\n    1. Let _len_ be the length of _s_.\n    1. Let _position_ be 0.\n    1. Repeat, while _position_ < _len_,\n      1. Let _cp_ be CodePointAt(_s_, _position_).\n      1. Let _nextIndex_ be _position_ + _cp_.[[CodeUnitCount]].\n      1. Let _resultString_ be the substring of _s_ from _position_ to _nextIndex_.\n      1. Set _position_ to _nextIndex_.\n      1. Perform ? GeneratorYield(CreateIterResultObject(_resultString_, *false*)).\n    1. Return *undefined*.\n  1. Return CreateIteratorFromClosure(_closure_, *\"%StringIteratorPrototype%\"*, %StringIteratorPrototype%).","code":"\n          1. Let _O_ be ? RequireObjectCoercible(*this* value).\n          1. Let _s_ be ? ToString(_O_).\n          1. Let _closure_ be a new Abstract Closure with no parameters that captures _s_ and performs the following steps when called:\n            1. Let _len_ be the length of _s_.\n            1. Let _position_ be 0.\n            1. Repeat, while _position_ < _len_,\n              1. Let _cp_ be CodePointAt(_s_, _position_).\n              1. Let _nextIndex_ be _position_ + _cp_.[[CodeUnitCount]].\n              1. Let _resultString_ be the substring of _s_ from _position_ to _nextIndex_.\n              1. Set _position_ to _nextIndex_.\n              1. Perform ? GeneratorYield(CreateIterResultObject(_resultString_, *false*)).\n            1. Return *undefined*.\n          1. Return CreateIteratorFromClosure(_closure_, *\"%StringIteratorPrototype%\"*, %StringIteratorPrototype%).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"StringIteratorPrototype"}},"name":"next"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Return ? GeneratorResume(*this* value, ~empty~, *\"%StringIteratorPrototype%\"*).","code":"\n            1. Return ? <emu-meta suppress-effects=\"user-code\">GeneratorResume(*this* value, ~empty~, *\"%StringIteratorPrototype%\"*)</emu-meta>.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CountLeftCapturingParensWithin","params":[{"name":"node","ty":"Ast","kind":{"Normal":{}}}],"retTy":"NonNegInt"}},"body":"\n  1. Assert: _node_ is an instance of a production in <emu-xref href=\"#sec-patterns\">the RegExp Pattern grammar</emu-xref>..\n  1. Return the number of <emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> Parse Nodes contained within _node_.","code":"\n          1. Assert: _node_ is an instance of a production in <emu-xref href=\"#sec-patterns\">the RegExp Pattern grammar</emu-xref>.\n          1. Return the number of <emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> Parse Nodes contained within _node_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CountLeftCapturingParensBefore","params":[{"name":"node","ty":"Ast","kind":{"Normal":{}}}],"retTy":"NonNegInt"}},"body":"\n  1. Assert: _node_ is an instance of a production in <emu-xref href=\"#sec-patterns\">the RegExp Pattern grammar</emu-xref>..\n  1. Let _pattern_ be the |Pattern| containing _node_.\n  1. Return the number of <emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> Parse Nodes contained within _pattern_ that either occur before _node_ or contain _node_.","code":"\n          1. Assert: _node_ is an instance of a production in <emu-xref href=\"#sec-patterns\">the RegExp Pattern grammar</emu-xref>.\n          1. Let _pattern_ be the |Pattern| containing _node_.\n          1. Return the number of <emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> Parse Nodes contained within _pattern_ that either occur before _node_ or contain _node_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DecimalEscape","idx":0,"subIdx":0,"rhsParams":[{"name":"NonZeroDigit","ty":"Ast[NonZeroDigit]","kind":{"Normal":{}}}]},"methodName":"CapturingGroupNumber","isStatic":true,"withParams":[],"retTy":"PosInt"}},"body":"\n  1. Return MV of |NonZeroDigit|.","code":"\n          1. Return the MV of |NonZeroDigit|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"DecimalEscape","idx":0,"subIdx":1,"rhsParams":[{"name":"NonZeroDigit","ty":"Ast[NonZeroDigit]","kind":{"Normal":{}}},{"name":"DecimalDigits","ty":"Ast[DecimalDigits]","kind":{"Normal":{}}}]},"methodName":"CapturingGroupNumber","isStatic":true,"withParams":[],"retTy":"PosInt"}},"body":"\n  1. Let _n_ be the number of code points in |DecimalDigits|.\n  1. Return (the MV of |NonZeroDigit| × 10<sup>_n_</sup> plus the MV of |DecimalDigits|).","code":"\n          1. Let _n_ be the number of code points in |DecimalDigits|.\n          1. Return (the MV of |NonZeroDigit| × 10<sup>_n_</sup> plus the MV of |DecimalDigits|).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassAtom","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"IsCharacterClass","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassAtomNoDash","idx":0,"subIdx":0,"rhsParams":[{"name":"SourceCharacter","ty":"Ast[SourceCharacter]","kind":{"Normal":{}}}]},"methodName":"IsCharacterClass","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassEscape","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"IsCharacterClass","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassEscape","idx":1,"subIdx":0,"rhsParams":[]},"methodName":"IsCharacterClass","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassEscape","idx":3,"subIdx":0,"rhsParams":[{"name":"CharacterEscape","ty":"Ast[CharacterEscape]","kind":{"Normal":{}}}]},"methodName":"IsCharacterClass","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassEscape","idx":2,"subIdx":0,"rhsParams":[{"name":"CharacterClassEscape","ty":"Ast[CharacterClassEscape]","kind":{"Normal":{}}}]},"methodName":"IsCharacterClass","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n          1. Return *true*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassAtom","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"CharacterValue","isStatic":true,"withParams":[],"retTy":"NonNegInt"}},"body":"\n  1. Return the numeric value of U+002D (HYPHEN-MINUS).","code":"\n          1. Return the numeric value of U+002D (HYPHEN-MINUS).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassAtomNoDash","idx":0,"subIdx":0,"rhsParams":[{"name":"SourceCharacter","ty":"Ast[SourceCharacter]","kind":{"Normal":{}}}]},"methodName":"CharacterValue","isStatic":true,"withParams":[],"retTy":"NonNegInt"}},"body":"\n  1. Let _ch_ be the code point matched by |SourceCharacter|.\n  1. Return ℝ(_ch_).","code":"\n          1. Let _ch_ be the code point matched by |SourceCharacter|.\n          1. Return the numeric value of _ch_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassEscape","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"CharacterValue","isStatic":true,"withParams":[],"retTy":"NonNegInt"}},"body":"\n  1. Return the numeric value of U+0008 (BACKSPACE).","code":"\n          1. Return the numeric value of U+0008 (BACKSPACE).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassEscape","idx":1,"subIdx":0,"rhsParams":[]},"methodName":"CharacterValue","isStatic":true,"withParams":[],"retTy":"NonNegInt"}},"body":"\n  1. Return the numeric value of U+002D (HYPHEN-MINUS).","code":"\n          1. Return the numeric value of U+002D (HYPHEN-MINUS).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CharacterEscape","idx":0,"subIdx":0,"rhsParams":[{"name":"ControlEscape","ty":"Ast[ControlEscape]","kind":{"Normal":{}}}]},"methodName":"CharacterValue","isStatic":true,"withParams":[],"retTy":"NonNegInt"}},"body":"\n  1. Return the numeric value according to <emu-xref href=\"#table-controlescape-code-point-values\"></emu-xref>.","code":"\n          1. Return the numeric value according to <emu-xref href=\"#table-controlescape-code-point-values\"></emu-xref>.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CharacterEscape","idx":1,"subIdx":0,"rhsParams":[{"name":"AsciiLetter","ty":"Ast[AsciiLetter]","kind":{"Normal":{}}}]},"methodName":"CharacterValue","isStatic":true,"withParams":[],"retTy":"NonNegInt"}},"body":"\n  1. Let _ch_ be the code point matched by |AsciiLetter|.\n  1. Let _i_ be ℝ(_ch_).\n  1. Return the remainder of dividing _i_ by 32.","code":"\n          1. Let _ch_ be the code point matched by |AsciiLetter|.\n          1. Let _i_ be the numeric value of _ch_.\n          1. Return the remainder of dividing _i_ by 32.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CharacterEscape","idx":2,"subIdx":0,"rhsParams":[]},"methodName":"CharacterValue","isStatic":true,"withParams":[],"retTy":"NonNegInt"}},"body":"\n  1. Return the numeric value of U+0000 (NULL).","code":"\n          1. Return the numeric value of U+0000 (NULL).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CharacterEscape","idx":3,"subIdx":0,"rhsParams":[{"name":"HexEscapeSequence","ty":"Ast[HexEscapeSequence]","kind":{"Normal":{}}}]},"methodName":"CharacterValue","isStatic":true,"withParams":[],"retTy":"NonNegInt"}},"body":"\n  1. Return MV of |HexEscapeSequence|.","code":"\n          1. Return the MV of |HexEscapeSequence|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RegExpUnicodeEscapeSequence","idx":0,"subIdx":0,"rhsParams":[{"name":"HexLeadSurrogate","ty":"Ast[HexLeadSurrogate]","kind":{"Normal":{}}},{"name":"HexTrailSurrogate","ty":"Ast[HexTrailSurrogate]","kind":{"Normal":{}}}]},"methodName":"CharacterValue","isStatic":true,"withParams":[],"retTy":"NonNegInt"}},"body":"\n  1. Let _lead_ be CharacterValue of |HexLeadSurrogate|.\n  1. Let _trail_ be CharacterValue of |HexTrailSurrogate|.\n  1. Let _cp_ be UTF16SurrogatePairToCodePoint(_lead_, _trail_).\n  1. Return ℝ(_cp_).","code":"\n          1. Let _lead_ be the CharacterValue of |HexLeadSurrogate|.\n          1. Let _trail_ be the CharacterValue of |HexTrailSurrogate|.\n          1. Let _cp_ be UTF16SurrogatePairToCodePoint(_lead_, _trail_).\n          1. Return the numeric value of _cp_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RegExpUnicodeEscapeSequence","idx":4,"subIdx":0,"rhsParams":[{"name":"Hex4Digits","ty":"Ast[Hex4Digits]","kind":{"Normal":{}}}]},"methodName":"CharacterValue","isStatic":true,"withParams":[],"retTy":"NonNegInt"}},"body":"\n  1. Return MV of |Hex4Digits|.","code":"\n          1. Return the MV of |Hex4Digits|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RegExpUnicodeEscapeSequence","idx":5,"subIdx":0,"rhsParams":[{"name":"CodePoint","ty":"Ast[CodePoint]","kind":{"Normal":{}}}]},"methodName":"CharacterValue","isStatic":true,"withParams":[],"retTy":"NonNegInt"}},"body":"\n  1. Return MV of |CodePoint|.","code":"\n          1. Return the MV of |CodePoint|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"HexLeadSurrogate","idx":0,"subIdx":0,"rhsParams":[{"name":"Hex4Digits","ty":"Ast[Hex4Digits]","kind":{"Normal":{}}}]},"methodName":"CharacterValue","isStatic":true,"withParams":[],"retTy":"NonNegInt"}},"body":"\n  1. Return MV of |Hex4Digits|.","code":"\n          1. Return the MV of |Hex4Digits|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"HexTrailSurrogate","idx":0,"subIdx":0,"rhsParams":[{"name":"Hex4Digits","ty":"Ast[Hex4Digits]","kind":{"Normal":{}}}]},"methodName":"CharacterValue","isStatic":true,"withParams":[],"retTy":"NonNegInt"}},"body":"\n  1. Return MV of |Hex4Digits|.","code":"\n          1. Return the MV of |Hex4Digits|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"HexNonSurrogate","idx":0,"subIdx":0,"rhsParams":[{"name":"Hex4Digits","ty":"Ast[Hex4Digits]","kind":{"Normal":{}}}]},"methodName":"CharacterValue","isStatic":true,"withParams":[],"retTy":"NonNegInt"}},"body":"\n  1. Return MV of |Hex4Digits|.","code":"\n          1. Return the MV of |Hex4Digits|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CharacterEscape","idx":5,"subIdx":0,"rhsParams":[{"name":"IdentityEscape","ty":"Ast[IdentityEscape]","kind":{"Normal":{}}}]},"methodName":"CharacterValue","isStatic":true,"withParams":[],"retTy":"NonNegInt"}},"body":"\n  1. Let _ch_ be the code point matched by |IdentityEscape|.\n  1. Return ℝ(_ch_).","code":"\n          1. Let _ch_ be the code point matched by |IdentityEscape|.\n          1. Return the numeric value of _ch_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassSetCharacter","idx":0,"subIdx":0,"rhsParams":[{"name":"SourceCharacter","ty":"Ast[SourceCharacter]","kind":{"Normal":{}}}]},"methodName":"CharacterValue","isStatic":true,"withParams":[],"retTy":"NonNegInt"}},"body":"\n  1. Let _ch_ be the code point matched by |SourceCharacter|.\n  1. Return ℝ(_ch_).","code":"\n          1. Let _ch_ be the code point matched by |SourceCharacter|.\n          1. Return the numeric value of _ch_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassSetCharacter","idx":2,"subIdx":0,"rhsParams":[{"name":"ClassSetReservedPunctuator","ty":"Ast[ClassSetReservedPunctuator]","kind":{"Normal":{}}}]},"methodName":"CharacterValue","isStatic":true,"withParams":[],"retTy":"NonNegInt"}},"body":"\n  1. Let _ch_ be the code point matched by |ClassSetReservedPunctuator|.\n  1. Return ℝ(_ch_).","code":"\n          1. Let _ch_ be the code point matched by |ClassSetReservedPunctuator|.\n          1. Return the numeric value of _ch_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassSetCharacter","idx":3,"subIdx":0,"rhsParams":[]},"methodName":"CharacterValue","isStatic":true,"withParams":[],"retTy":"NonNegInt"}},"body":"\n  1. Return the numeric value of U+0008 (BACKSPACE).","code":"\n          1. Return the numeric value of U+0008 (BACKSPACE).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CharacterClassEscape","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"MayContainStrings","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CharacterClassEscape","idx":1,"subIdx":0,"rhsParams":[]},"methodName":"MayContainStrings","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CharacterClassEscape","idx":2,"subIdx":0,"rhsParams":[]},"methodName":"MayContainStrings","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CharacterClassEscape","idx":3,"subIdx":0,"rhsParams":[]},"methodName":"MayContainStrings","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CharacterClassEscape","idx":4,"subIdx":0,"rhsParams":[]},"methodName":"MayContainStrings","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CharacterClassEscape","idx":5,"subIdx":0,"rhsParams":[]},"methodName":"MayContainStrings","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CharacterClassEscape","idx":7,"subIdx":0,"rhsParams":[{"name":"UnicodePropertyValueExpression","ty":"Ast[UnicodePropertyValueExpression]","kind":{"Normal":{}}}]},"methodName":"MayContainStrings","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnicodePropertyValueExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"UnicodePropertyName","ty":"Ast[UnicodePropertyName]","kind":{"Normal":{}}},{"name":"UnicodePropertyValue","ty":"Ast[UnicodePropertyValue]","kind":{"Normal":{}}}]},"methodName":"MayContainStrings","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NestedClass","idx":1,"subIdx":0,"rhsParams":[{"name":"ClassContents","ty":"Ast[ClassContents]","kind":{"Normal":{}}}]},"methodName":"MayContainStrings","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassContents","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"MayContainStrings","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassContents","idx":1,"subIdx":0,"rhsParams":[{"name":"NonemptyClassRanges","ty":"Ast[NonemptyClassRanges]","kind":{"Normal":{}}}]},"methodName":"MayContainStrings","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassSetOperand","idx":2,"subIdx":0,"rhsParams":[{"name":"ClassSetCharacter","ty":"Ast[ClassSetCharacter]","kind":{"Normal":{}}}]},"methodName":"MayContainStrings","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *false*.","code":"\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnicodePropertyValueExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"LoneUnicodePropertyNameOrValue","ty":"Ast[LoneUnicodePropertyNameOrValue]","kind":{"Normal":{}}}]},"methodName":"MayContainStrings","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. If the source text matched by |LoneUnicodePropertyNameOrValue| is a binary property of strings listed in the “Property name” column of <emu-xref href=\"#table-binary-unicode-properties-of-strings\"></emu-xref>, return *true*.\n  1. Return *false*.","code":"\n          1. If the source text matched by |LoneUnicodePropertyNameOrValue| is a binary property of strings listed in the “Property name” column of <emu-xref href=\"#table-binary-unicode-properties-of-strings\"></emu-xref>, return *true*.\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassUnion","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassSetRange","ty":"Ast[ClassSetRange]","kind":{"Normal":{}}},{"name":"ClassUnion","ty":"Ast[ClassUnion]","kind":{"Normal":{}}}]},"methodName":"MayContainStrings","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. If |ClassUnion| is present, return MayContainStrings of |ClassUnion|.\n  1. Return *false*.","code":"\n          1. If the |ClassUnion| is present, return MayContainStrings of the |ClassUnion|.\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassUnion","idx":0,"subIdx":1,"rhsParams":[{"name":"ClassSetRange","ty":"Ast[ClassSetRange]","kind":{"Normal":{}}},{"name":"ClassUnion","ty":"Ast[ClassUnion]","kind":{"Normal":{}}}]},"methodName":"MayContainStrings","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. If |ClassUnion| is present, return MayContainStrings of |ClassUnion|.\n  1. Return *false*.","code":"\n          1. If the |ClassUnion| is present, return MayContainStrings of the |ClassUnion|.\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassUnion","idx":1,"subIdx":0,"rhsParams":[{"name":"ClassSetOperand","ty":"Ast[ClassSetOperand]","kind":{"Normal":{}}},{"name":"ClassUnion","ty":"Ast[ClassUnion]","kind":{"Normal":{}}}]},"methodName":"MayContainStrings","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. If MayContainStrings of |ClassSetOperand| is *true*, return *true*.\n  1. If |ClassUnion| is present, return MayContainStrings of |ClassUnion|.\n  1. Return *false*.","code":"\n          1. If MayContainStrings of the |ClassSetOperand| is *true*, return *true*.\n          1. If |ClassUnion| is present, return MayContainStrings of the |ClassUnion|.\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassUnion","idx":1,"subIdx":1,"rhsParams":[{"name":"ClassSetOperand","ty":"Ast[ClassSetOperand]","kind":{"Normal":{}}},{"name":"ClassUnion","ty":"Ast[ClassUnion]","kind":{"Normal":{}}}]},"methodName":"MayContainStrings","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. If MayContainStrings of |ClassSetOperand| is *true*, return *true*.\n  1. If |ClassUnion| is present, return MayContainStrings of |ClassUnion|.\n  1. Return *false*.","code":"\n          1. If MayContainStrings of the |ClassSetOperand| is *true*, return *true*.\n          1. If |ClassUnion| is present, return MayContainStrings of the |ClassUnion|.\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassIntersection","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassSetOperand","ty":"Ast[ClassSetOperand]","kind":{"Normal":{}}},{"name":"ClassSetOperand","ty":"Ast[ClassSetOperand]","kind":{"Normal":{}}}]},"methodName":"MayContainStrings","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. If MayContainStrings of the first |ClassSetOperand| is *false*, return *false*.\n  1. If MayContainStrings of the second |ClassSetOperand| is *false*, return *false*.\n  1. Return *true*.","code":"\n          1. If MayContainStrings of the first |ClassSetOperand| is *false*, return *false*.\n          1. If MayContainStrings of the second |ClassSetOperand| is *false*, return *false*.\n          1. Return *true*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassIntersection","idx":1,"subIdx":0,"rhsParams":[{"name":"ClassIntersection","ty":"Ast[ClassIntersection]","kind":{"Normal":{}}},{"name":"ClassSetOperand","ty":"Ast[ClassSetOperand]","kind":{"Normal":{}}}]},"methodName":"MayContainStrings","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. If MayContainStrings of |ClassIntersection| is *false*, return *false*.\n  1. If MayContainStrings of |ClassSetOperand| is *false*, return *false*.\n  1. Return *true*.","code":"\n          1. If MayContainStrings of the |ClassIntersection| is *false*, return *false*.\n          1. If MayContainStrings of the |ClassSetOperand| is *false*, return *false*.\n          1. Return *true*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassSubtraction","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassSetOperand","ty":"Ast[ClassSetOperand]","kind":{"Normal":{}}},{"name":"ClassSetOperand","ty":"Ast[ClassSetOperand]","kind":{"Normal":{}}}]},"methodName":"MayContainStrings","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return MayContainStrings of the first |ClassSetOperand|.","code":"\n          1. Return MayContainStrings of the first |ClassSetOperand|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassSubtraction","idx":1,"subIdx":0,"rhsParams":[{"name":"ClassSubtraction","ty":"Ast[ClassSubtraction]","kind":{"Normal":{}}},{"name":"ClassSetOperand","ty":"Ast[ClassSetOperand]","kind":{"Normal":{}}}]},"methodName":"MayContainStrings","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return MayContainStrings of |ClassSubtraction|.","code":"\n          1. Return MayContainStrings of the |ClassSubtraction|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassStringDisjunctionContents","idx":1,"subIdx":0,"rhsParams":[{"name":"ClassString","ty":"Ast[ClassString]","kind":{"Normal":{}}},{"name":"ClassStringDisjunctionContents","ty":"Ast[ClassStringDisjunctionContents]","kind":{"Normal":{}}}]},"methodName":"MayContainStrings","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. If MayContainStrings of |ClassString| is *true*, return *true*.\n  1. Return MayContainStrings of |ClassStringDisjunctionContents|.","code":"\n          1. If MayContainStrings of the |ClassString| is *true*, return *true*.\n          1. Return MayContainStrings of the |ClassStringDisjunctionContents|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassString","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"MayContainStrings","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return *true*.","code":"\n          1. Return *true*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassString","idx":1,"subIdx":0,"rhsParams":[{"name":"NonEmptyClassString","ty":"Ast[NonEmptyClassString]","kind":{"Normal":{}}}]},"methodName":"MayContainStrings","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. Return MayContainStrings of |NonEmptyClassString|.","code":"\n          1. Return MayContainStrings of the |NonEmptyClassString|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NonEmptyClassString","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassSetCharacter","ty":"Ast[ClassSetCharacter]","kind":{"Normal":{}}},{"name":"NonEmptyClassString","ty":"Ast[NonEmptyClassString]","kind":{"Normal":{}}}]},"methodName":"MayContainStrings","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. If |NonEmptyClassString| is present, return *true*.\n  1. Return *false*.","code":"\n          1. If |NonEmptyClassString| is present, return *true*.\n          1. Return *false*.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NonEmptyClassString","idx":0,"subIdx":1,"rhsParams":[{"name":"ClassSetCharacter","ty":"Ast[ClassSetCharacter]","kind":{"Normal":{}}},{"name":"NonEmptyClassString","ty":"Ast[NonEmptyClassString]","kind":{"Normal":{}}}]},"methodName":"MayContainStrings","isStatic":true,"withParams":[],"retTy":"Boolean"}},"body":"\n  1. If |NonEmptyClassString| is present, return *true*.\n  1. Return *false*.","code":"\n          1. If |NonEmptyClassString| is present, return *true*.\n          1. Return *false*.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GroupSpecifiersThatMatch","params":[{"name":"thisGroupName","ty":"Unknown[\"a |GroupName| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Unknown[\"a List of |GroupSpecifier| Parse Nodes\"]"}},"body":"\n  1. Let _name_ be CapturingGroupName of _thisGroupName_.\n  1. Let _pattern_ be the |Pattern| containing _thisGroupName_.\n  1. Let _result_ be « ».\n  1. For each |GroupSpecifier| _gs_ that _pattern_ contains, do\n    1. If CapturingGroupName of _gs_ is _name_, then\n      1. Append _gs_ to _result_.\n  1. Return _result_.","code":"\n          1. Let _name_ be the CapturingGroupName of _thisGroupName_.\n          1. Let _pattern_ be the |Pattern| containing _thisGroupName_.\n          1. Let _result_ be a new empty List.\n          1. For each |GroupSpecifier| _gs_ that _pattern_ contains, do\n            1. If the CapturingGroupName of _gs_ is _name_, then\n              1. Append _gs_ to _result_.\n          1. Return _result_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"GroupName","idx":0,"subIdx":0,"rhsParams":[{"name":"RegExpIdentifierName","ty":"Ast[RegExpIdentifierName]","kind":{"Normal":{}}}]},"methodName":"CapturingGroupName","isStatic":true,"withParams":[],"retTy":"String"}},"body":"\n  1. Let _idTextUnescaped_ be RegExpIdentifierCodePoints of |RegExpIdentifierName|.\n  1. Return CodePointsToString(_idTextUnescaped_).","code":"\n          1. Let _idTextUnescaped_ be RegExpIdentifierCodePoints of |RegExpIdentifierName|.\n          1. Return CodePointsToString(_idTextUnescaped_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RegExpIdentifierName","idx":0,"subIdx":0,"rhsParams":[{"name":"RegExpIdentifierStart","ty":"Ast[RegExpIdentifierStart]","kind":{"Normal":{}}}]},"methodName":"RegExpIdentifierCodePoints","isStatic":true,"withParams":[],"retTy":"Unknown[\"a List of code points\"]"}},"body":"\n  1. Let _cp_ be RegExpIdentifierCodePoint of |RegExpIdentifierStart|.\n  1. Return « _cp_ ».","code":"\n          1. Let _cp_ be RegExpIdentifierCodePoint of |RegExpIdentifierStart|.\n          1. Return « _cp_ ».\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RegExpIdentifierName","idx":1,"subIdx":0,"rhsParams":[{"name":"RegExpIdentifierName","ty":"Ast[RegExpIdentifierName]","kind":{"Normal":{}}},{"name":"RegExpIdentifierPart","ty":"Ast[RegExpIdentifierPart]","kind":{"Normal":{}}}]},"methodName":"RegExpIdentifierCodePoints","isStatic":true,"withParams":[],"retTy":"Unknown[\"a List of code points\"]"}},"body":"\n  1. Let _cps_ be RegExpIdentifierCodePoints of the derived |RegExpIdentifierName|.\n  1. Let _cp_ be RegExpIdentifierCodePoint of |RegExpIdentifierPart|.\n  1. Return the list-concatenation of _cps_ and « _cp_ ».","code":"\n          1. Let _cps_ be RegExpIdentifierCodePoints of the derived |RegExpIdentifierName|.\n          1. Let _cp_ be RegExpIdentifierCodePoint of |RegExpIdentifierPart|.\n          1. Return the list-concatenation of _cps_ and « _cp_ ».\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RegExpIdentifierStart","idx":0,"subIdx":0,"rhsParams":[{"name":"IdentifierStartChar","ty":"Ast[IdentifierStartChar]","kind":{"Normal":{}}}]},"methodName":"RegExpIdentifierCodePoint","isStatic":true,"withParams":[],"retTy":"Unknown[\"a code point\"]"}},"body":"\n  1. Return the code point matched by |IdentifierStartChar|.","code":"\n          1. Return the code point matched by |IdentifierStartChar|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RegExpIdentifierPart","idx":0,"subIdx":0,"rhsParams":[{"name":"IdentifierPartChar","ty":"Ast[IdentifierPartChar]","kind":{"Normal":{}}}]},"methodName":"RegExpIdentifierCodePoint","isStatic":true,"withParams":[],"retTy":"Unknown[\"a code point\"]"}},"body":"\n  1. Return the code point matched by |IdentifierPartChar|.","code":"\n          1. Return the code point matched by |IdentifierPartChar|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RegExpIdentifierStart","idx":1,"subIdx":0,"rhsParams":[{"name":"RegExpUnicodeEscapeSequence","ty":"Ast[RegExpUnicodeEscapeSequence]","kind":{"Normal":{}}}]},"methodName":"RegExpIdentifierCodePoint","isStatic":true,"withParams":[],"retTy":"Unknown[\"a code point\"]"}},"body":"\n  1. Return the code point whose numeric value is the CharacterValue of |RegExpUnicodeEscapeSequence|.","code":"\n          1. Return the code point whose numeric value is the CharacterValue of |RegExpUnicodeEscapeSequence|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RegExpIdentifierPart","idx":1,"subIdx":0,"rhsParams":[{"name":"RegExpUnicodeEscapeSequence","ty":"Ast[RegExpUnicodeEscapeSequence]","kind":{"Normal":{}}}]},"methodName":"RegExpIdentifierCodePoint","isStatic":true,"withParams":[],"retTy":"Unknown[\"a code point\"]"}},"body":"\n  1. Return the code point whose numeric value is the CharacterValue of |RegExpUnicodeEscapeSequence|.","code":"\n          1. Return the code point whose numeric value is the CharacterValue of |RegExpUnicodeEscapeSequence|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RegExpIdentifierStart","idx":2,"subIdx":0,"rhsParams":[{"name":"UnicodeLeadSurrogate","ty":"Ast[UnicodeLeadSurrogate]","kind":{"Normal":{}}},{"name":"UnicodeTrailSurrogate","ty":"Ast[UnicodeTrailSurrogate]","kind":{"Normal":{}}}]},"methodName":"RegExpIdentifierCodePoint","isStatic":true,"withParams":[],"retTy":"Unknown[\"a code point\"]"}},"body":"\n  1. Let _lead_ be the code unit whose numeric value is the numeric value of the code point matched by |UnicodeLeadSurrogate|.\n  1. Let _trail_ be the code unit whose numeric value is the numeric value of the code point matched by |UnicodeTrailSurrogate|.\n  1. Return UTF16SurrogatePairToCodePoint(_lead_, _trail_).","code":"\n          1. Let _lead_ be the code unit whose numeric value is the numeric value of the code point matched by |UnicodeLeadSurrogate|.\n          1. Let _trail_ be the code unit whose numeric value is the numeric value of the code point matched by |UnicodeTrailSurrogate|.\n          1. Return UTF16SurrogatePairToCodePoint(_lead_, _trail_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"RegExpIdentifierPart","idx":2,"subIdx":0,"rhsParams":[{"name":"UnicodeLeadSurrogate","ty":"Ast[UnicodeLeadSurrogate]","kind":{"Normal":{}}},{"name":"UnicodeTrailSurrogate","ty":"Ast[UnicodeTrailSurrogate]","kind":{"Normal":{}}}]},"methodName":"RegExpIdentifierCodePoint","isStatic":true,"withParams":[],"retTy":"Unknown[\"a code point\"]"}},"body":"\n  1. Let _lead_ be the code unit whose numeric value is the numeric value of the code point matched by |UnicodeLeadSurrogate|.\n  1. Let _trail_ be the code unit whose numeric value is the numeric value of the code point matched by |UnicodeTrailSurrogate|.\n  1. Return UTF16SurrogatePairToCodePoint(_lead_, _trail_).","code":"\n          1. Let _lead_ be the code unit whose numeric value is the numeric value of the code point matched by |UnicodeLeadSurrogate|.\n          1. Let _trail_ be the code unit whose numeric value is the numeric value of the code point matched by |UnicodeTrailSurrogate|.\n          1. Return UTF16SurrogatePairToCodePoint(_lead_, _trail_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Pattern","idx":0,"subIdx":0,"rhsParams":[{"name":"Disjunction","ty":"Ast[Disjunction]","kind":{"Normal":{}}}]},"methodName":"CompilePattern","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Unknown[\"an Abstract Closure that takes a List of characters and a non-negative integer and returns a MatchResult\"]"}},"body":"\n  1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and ~forward~.\n  1. Return a new Abstract Closure with parameters (_Input_, _index_) that captures _rer_ and _m_ and performs the following steps when called:\n    1. Assert: _Input_ is a List of characters..\n    1. Assert: 0 ≤ _index_ ≤ the number of elements in _Input_..\n    1. Let _c_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:\n      1. Assert: _y_ is a Record[MatchState].\n      1. Return _y_.\n    1. Let _cap_ be a List of _rer_.[[CapturingGroupsCount]] *undefined* values, indexed 1 through _rer_.[[CapturingGroupsCount]].\n    1. Let _x_ be MatchState { [[Input]]: _Input_, [[EndIndex]]: _index_, [[Captures]]: _cap_ }.\n    1. Return _m_(_x_, _c_).","code":"\n          1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and ~forward~.\n          1. Return a new Abstract Closure with parameters (_Input_, _index_) that captures _rer_ and _m_ and performs the following steps when called:\n            1. Assert: _Input_ is a List of characters.\n            1. Assert: 0 ≤ _index_ ≤ the number of elements in _Input_.\n            1. Let _c_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:\n              1. Assert: _y_ is a MatchState.\n              1. Return _y_.\n            1. Let _cap_ be a List of _rer_.[[CapturingGroupsCount]] *undefined* values, indexed 1 through _rer_.[[CapturingGroupsCount]].\n            1. Let _x_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _index_, [[Captures]]: _cap_ }.\n            1. Return _m_(_x_, _c_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Disjunction","idx":1,"subIdx":0,"rhsParams":[{"name":"Alternative","ty":"Ast[Alternative]","kind":{"Normal":{}}},{"name":"Disjunction","ty":"Ast[Disjunction]","kind":{"Normal":{}}}]},"methodName":"CompileSubpattern","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}},{"name":"direction","ty":"Enum[~backward~, ~forward~]","kind":{"Normal":{}}}],"retTy":"Record[Matcher]"}},"body":"\n  1. Let _m1_ be CompileSubpattern of |Alternative| with arguments _rer_ and _direction_.\n  1. Let _m2_ be CompileSubpattern of |Disjunction| with arguments _rer_ and _direction_.\n  1. Return MatchTwoAlternatives(_m1_, _m2_).","code":"\n          1. Let _m1_ be CompileSubpattern of |Alternative| with arguments _rer_ and _direction_.\n          1. Let _m2_ be CompileSubpattern of |Disjunction| with arguments _rer_ and _direction_.\n          1. Return MatchTwoAlternatives(_m1_, _m2_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Alternative","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"CompileSubpattern","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}},{"name":"direction","ty":"Enum[~backward~, ~forward~]","kind":{"Normal":{}}}],"retTy":"Record[Matcher]"}},"body":"\n  1. Return EmptyMatcher().","code":"\n          1. Return EmptyMatcher().\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Alternative","idx":1,"subIdx":0,"rhsParams":[{"name":"Alternative","ty":"Ast[Alternative]","kind":{"Normal":{}}},{"name":"Term","ty":"Ast[Term]","kind":{"Normal":{}}}]},"methodName":"CompileSubpattern","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}},{"name":"direction","ty":"Enum[~backward~, ~forward~]","kind":{"Normal":{}}}],"retTy":"Record[Matcher]"}},"body":"\n  1. Let _m1_ be CompileSubpattern of |Alternative| with arguments _rer_ and _direction_.\n  1. Let _m2_ be CompileSubpattern of |Term| with arguments _rer_ and _direction_.\n  1. Return MatchSequence(_m1_, _m2_, _direction_).","code":"\n          1. Let _m1_ be CompileSubpattern of |Alternative| with arguments _rer_ and _direction_.\n          1. Let _m2_ be CompileSubpattern of |Term| with arguments _rer_ and _direction_.\n          1. Return MatchSequence(_m1_, _m2_, _direction_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Term","idx":0,"subIdx":0,"rhsParams":[{"name":"Assertion","ty":"Ast[Assertion]","kind":{"Normal":{}}}]},"methodName":"CompileSubpattern","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}},{"name":"direction","ty":"Enum[~backward~, ~forward~]","kind":{"Normal":{}}}],"retTy":"Record[Matcher]"}},"body":"\n  1. Return CompileAssertion of |Assertion| with argument _rer_.","code":"\n          1. Return CompileAssertion of |Assertion| with argument _rer_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Term","idx":1,"subIdx":0,"rhsParams":[{"name":"Atom","ty":"Ast[Atom]","kind":{"Normal":{}}}]},"methodName":"CompileSubpattern","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}},{"name":"direction","ty":"Enum[~backward~, ~forward~]","kind":{"Normal":{}}}],"retTy":"Record[Matcher]"}},"body":"\n  1. Return CompileAtom of |Atom| with arguments _rer_ and _direction_.","code":"\n          1. Return CompileAtom of |Atom| with arguments _rer_ and _direction_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Term","idx":2,"subIdx":0,"rhsParams":[{"name":"Atom","ty":"Ast[Atom]","kind":{"Normal":{}}},{"name":"Quantifier","ty":"Ast[Quantifier]","kind":{"Normal":{}}}]},"methodName":"CompileSubpattern","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}},{"name":"direction","ty":"Enum[~backward~, ~forward~]","kind":{"Normal":{}}}],"retTy":"Record[Matcher]"}},"body":"\n  1. Let _m_ be CompileAtom of |Atom| with arguments _rer_ and _direction_.\n  1. Let _q_ be CompileQuantifier of |Quantifier|.\n  1. Assert: _q_.[[Min]] ≤ _q_.[[Max]].\n  1. Let _parenIndex_ be CountLeftCapturingParensBefore(|Term|).\n  1. Let _parenCount_ be CountLeftCapturingParensWithin(|Atom|).\n  1. Return a new Matcher with parameters (_x_, _c_) that captures _m_, _q_, _parenIndex_, and _parenCount_ and performs the following steps when called:\n    1. Assert: _x_ is a Record[MatchState].\n    1. Assert: _c_ is a Record[MatcherContinuation].\n    1. Return RepeatMatcher(_m_, _q_.[[Min]], _q_.[[Max]], _q_.[[Greedy]], _x_, _c_, _parenIndex_, _parenCount_).","code":"\n          1. Let _m_ be CompileAtom of |Atom| with arguments _rer_ and _direction_.\n          1. Let _q_ be CompileQuantifier of |Quantifier|.\n          1. Assert: _q_.[[Min]] ≤ _q_.[[Max]].\n          1. Let _parenIndex_ be CountLeftCapturingParensBefore(|Term|).\n          1. Let _parenCount_ be CountLeftCapturingParensWithin(|Atom|).\n          1. Return a new Matcher with parameters (_x_, _c_) that captures _m_, _q_, _parenIndex_, and _parenCount_ and performs the following steps when called:\n            1. Assert: _x_ is a MatchState.\n            1. Assert: _c_ is a MatcherContinuation.\n            1. Return RepeatMatcher(_m_, _q_.[[Min]], _q_.[[Max]], _q_.[[Greedy]], _x_, _c_, _parenIndex_, _parenCount_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"RepeatMatcher","params":[{"name":"m","ty":"Record[Matcher]","kind":{"Normal":{}}},{"name":"min","ty":"NonNegInt","kind":{"Normal":{}}},{"name":"max","ty":"NonNegInt | +INF","kind":{"Normal":{}}},{"name":"greedy","ty":"Boolean","kind":{"Normal":{}}},{"name":"x","ty":"Record[MatchState]","kind":{"Normal":{}}},{"name":"c","ty":"Record[MatcherContinuation]","kind":{"Normal":{}}},{"name":"parenIndex","ty":"NonNegInt","kind":{"Normal":{}}},{"name":"parenCount","ty":"NonNegInt","kind":{"Normal":{}}}],"retTy":"Record[MatchResult]"}},"body":"\n  1. If _max_ = 0, return _c_(_x_).\n  1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures _m_, _min_, _max_, _greedy_, _x_, _c_, _parenIndex_, and _parenCount_ and performs the following steps when called:\n    1. Assert: _y_ is a Record[MatchState].\n    1. [id=\"step-repeatmatcher-done\"] If _min_ = 0 and _y_.[[EndIndex]] = _x_.[[EndIndex]], return ~failure~.\n    1. If _min_ = 0, let _min2_ be 0.\n    1. Else, let _min2_ be _min_ - 1.\n    1. If _max_ = +∞, let _max2_ be +∞.\n    1. Else, let _max2_ be _max_ - 1.\n    1. Return RepeatMatcher(_m_, _min2_, _max2_, _greedy_, _y_, _c_, _parenIndex_, _parenCount_).\n  1. Let _cap_ be a copy of _x_.[[Captures]].\n  1. [id=\"step-repeatmatcher-clear-captures\"] For each integer _k_ in the inclusive interval from _parenIndex_ + 1 to _parenIndex_ + _parenCount_, set _cap_[_k_] to *undefined*.\n  1. Let _Input_ be _x_.[[Input]].\n  1. Let _e_ be _x_.[[EndIndex]].\n  1. Let _xr_ be MatchState { [[Input]]: _Input_, [[EndIndex]]: _e_, [[Captures]]: _cap_ }.\n  1. If _min_ ≠ 0, return _m_(_xr_, _d_).\n  1. If _greedy_ is *false*, then\n    1. Let _z_ be _c_(_x_).\n    1. If _z_ is not ~failure~, return _z_.\n    1. Return _m_(_xr_, _d_).\n  1. Let _z_ be _m_(_xr_, _d_).\n  1. If _z_ is not ~failure~, return _z_.\n  1. Return _c_(_x_).","code":"\n            1. If _max_ = 0, return _c_(_x_).\n            1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures _m_, _min_, _max_, _greedy_, _x_, _c_, _parenIndex_, and _parenCount_ and performs the following steps when called:\n              1. Assert: _y_ is a MatchState.\n              1. [id=\"step-repeatmatcher-done\"] If _min_ = 0 and _y_.[[EndIndex]] = _x_.[[EndIndex]], return ~failure~.\n              1. If _min_ = 0, let _min2_ be 0; otherwise let _min2_ be _min_ - 1.\n              1. If _max_ = +∞, let _max2_ be +∞; otherwise let _max2_ be _max_ - 1.\n              1. Return RepeatMatcher(_m_, _min2_, _max2_, _greedy_, _y_, _c_, _parenIndex_, _parenCount_).\n            1. Let _cap_ be a copy of _x_.[[Captures]].\n            1. [id=\"step-repeatmatcher-clear-captures\"] For each integer _k_ in the inclusive interval from _parenIndex_ + 1 to _parenIndex_ + _parenCount_, set _cap_[_k_] to *undefined*.\n            1. Let _Input_ be _x_.[[Input]].\n            1. Let _e_ be _x_.[[EndIndex]].\n            1. Let _xr_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _e_, [[Captures]]: _cap_ }.\n            1. If _min_ ≠ 0, return _m_(_xr_, _d_).\n            1. If _greedy_ is *false*, then\n              1. Let _z_ be _c_(_x_).\n              1. If _z_ is not ~failure~, return _z_.\n              1. Return _m_(_xr_, _d_).\n            1. Let _z_ be _m_(_xr_, _d_).\n            1. If _z_ is not ~failure~, return _z_.\n            1. Return _c_(_x_).\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"EmptyMatcher","params":[],"retTy":"Record[Matcher]"}},"body":"\n  1. Return a new Matcher with parameters (_x_, _c_) that captures nothing and performs the following steps when called:\n    1. Assert: _x_ is a Record[MatchState].\n    1. Assert: _c_ is a Record[MatcherContinuation].\n    1. Return _c_(_x_).","code":"\n            1. Return a new Matcher with parameters (_x_, _c_) that captures nothing and performs the following steps when called:\n              1. Assert: _x_ is a MatchState.\n              1. Assert: _c_ is a MatcherContinuation.\n              1. Return _c_(_x_).\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"MatchTwoAlternatives","params":[{"name":"m1","ty":"Record[Matcher]","kind":{"Normal":{}}},{"name":"m2","ty":"Record[Matcher]","kind":{"Normal":{}}}],"retTy":"Record[Matcher]"}},"body":"\n  1. Return a new Matcher with parameters (_x_, _c_) that captures _m1_ and _m2_ and performs the following steps when called:\n    1. Assert: _x_ is a Record[MatchState].\n    1. Assert: _c_ is a Record[MatcherContinuation].\n    1. Let _r_ be _m1_(_x_, _c_).\n    1. If _r_ is not ~failure~, return _r_.\n    1. Return _m2_(_x_, _c_).","code":"\n            1. Return a new Matcher with parameters (_x_, _c_) that captures _m1_ and _m2_ and performs the following steps when called:\n              1. Assert: _x_ is a MatchState.\n              1. Assert: _c_ is a MatcherContinuation.\n              1. Let _r_ be _m1_(_x_, _c_).\n              1. If _r_ is not ~failure~, return _r_.\n              1. Return _m2_(_x_, _c_).\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"MatchSequence","params":[{"name":"m1","ty":"Record[Matcher]","kind":{"Normal":{}}},{"name":"m2","ty":"Record[Matcher]","kind":{"Normal":{}}},{"name":"direction","ty":"Enum[~backward~, ~forward~]","kind":{"Normal":{}}}],"retTy":"Record[Matcher]"}},"body":"\n  1. If _direction_ is ~forward~, then\n    1. Return a new Matcher with parameters (_x_, _c_) that captures _m1_ and _m2_ and performs the following steps when called:\n      1. Assert: _x_ is a Record[MatchState].\n      1. Assert: _c_ is a Record[MatcherContinuation].\n      1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures _c_ and _m2_ and performs the following steps when called:\n        1. Assert: _y_ is a Record[MatchState].\n        1. Return _m2_(_y_, _c_).\n      1. Return _m1_(_x_, _d_).\n  1. Else,\n    1. Assert: _direction_ is ~backward~.\n    1. Return a new Matcher with parameters (_x_, _c_) that captures _m1_ and _m2_ and performs the following steps when called:\n      1. Assert: _x_ is a Record[MatchState].\n      1. Assert: _c_ is a Record[MatcherContinuation].\n      1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures _c_ and _m1_ and performs the following steps when called:\n        1. Assert: _y_ is a Record[MatchState].\n        1. Return _m1_(_y_, _c_).\n      1. Return _m2_(_x_, _d_).","code":"\n            1. If _direction_ is ~forward~, then\n              1. Return a new Matcher with parameters (_x_, _c_) that captures _m1_ and _m2_ and performs the following steps when called:\n                1. Assert: _x_ is a MatchState.\n                1. Assert: _c_ is a MatcherContinuation.\n                1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures _c_ and _m2_ and performs the following steps when called:\n                  1. Assert: _y_ is a MatchState.\n                  1. Return _m2_(_y_, _c_).\n                1. Return _m1_(_x_, _d_).\n            1. Else,\n              1. Assert: _direction_ is ~backward~.\n              1. Return a new Matcher with parameters (_x_, _c_) that captures _m1_ and _m2_ and performs the following steps when called:\n                1. Assert: _x_ is a MatchState.\n                1. Assert: _c_ is a MatcherContinuation.\n                1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures _c_ and _m1_ and performs the following steps when called:\n                  1. Assert: _y_ is a MatchState.\n                  1. Return _m1_(_y_, _c_).\n                1. Return _m2_(_x_, _d_).\n          "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Assertion","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"CompileAssertion","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[Matcher]"}},"body":"\n  1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_ and performs the following steps when called:\n    1. Assert: _x_ is a Record[MatchState].\n    1. Assert: _c_ is a Record[MatcherContinuation].\n    1. Let _Input_ be _x_.[[Input]].\n    1. Let _e_ be _x_.[[EndIndex]].\n    1. If _e_ = 0, or if _rer_.[[Multiline]] is *true* and the character _Input_[_e_ - 1] is matched by |LineTerminator|, then\n      1. Return _c_(_x_).\n    1. Return ~failure~.","code":"\n          1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_ and performs the following steps when called:\n            1. Assert: _x_ is a MatchState.\n            1. Assert: _c_ is a MatcherContinuation.\n            1. Let _Input_ be _x_.[[Input]].\n            1. Let _e_ be _x_.[[EndIndex]].\n            1. If _e_ = 0, or if _rer_.[[Multiline]] is *true* and the character _Input_[_e_ - 1] is matched by |LineTerminator|, then\n              1. Return _c_(_x_).\n            1. Return ~failure~.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Assertion","idx":1,"subIdx":0,"rhsParams":[]},"methodName":"CompileAssertion","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[Matcher]"}},"body":"\n  1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_ and performs the following steps when called:\n    1. Assert: _x_ is a Record[MatchState].\n    1. Assert: _c_ is a Record[MatcherContinuation].\n    1. Let _Input_ be _x_.[[Input]].\n    1. Let _e_ be _x_.[[EndIndex]].\n    1. Let _InputLength_ be the number of elements in _Input_.\n    1. If _e_ = _InputLength_, or if _rer_.[[Multiline]] is *true* and the character _Input_[_e_] is matched by |LineTerminator|, then\n      1. Return _c_(_x_).\n    1. Return ~failure~.","code":"\n          1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_ and performs the following steps when called:\n            1. Assert: _x_ is a MatchState.\n            1. Assert: _c_ is a MatcherContinuation.\n            1. Let _Input_ be _x_.[[Input]].\n            1. Let _e_ be _x_.[[EndIndex]].\n            1. Let _InputLength_ be the number of elements in _Input_.\n            1. If _e_ = _InputLength_, or if _rer_.[[Multiline]] is *true* and the character _Input_[_e_] is matched by |LineTerminator|, then\n              1. Return _c_(_x_).\n            1. Return ~failure~.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Assertion","idx":2,"subIdx":0,"rhsParams":[]},"methodName":"CompileAssertion","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[Matcher]"}},"body":"\n  1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_ and performs the following steps when called:\n    1. Assert: _x_ is a Record[MatchState].\n    1. Assert: _c_ is a Record[MatcherContinuation].\n    1. Let _Input_ be _x_.[[Input]].\n    1. Let _e_ be _x_.[[EndIndex]].\n    1. Let _a_ be IsWordChar(_rer_, _Input_, _e_ - 1).\n    1. Let _b_ be IsWordChar(_rer_, _Input_, _e_).\n    1. If _a_ is *true* and _b_ is *false* or _a_ is *false* and _b_ is *true*, return _c_(_x_).\n    1. Return ~failure~.","code":"\n          1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_ and performs the following steps when called:\n            1. Assert: _x_ is a MatchState.\n            1. Assert: _c_ is a MatcherContinuation.\n            1. Let _Input_ be _x_.[[Input]].\n            1. Let _e_ be _x_.[[EndIndex]].\n            1. Let _a_ be IsWordChar(_rer_, _Input_, _e_ - 1).\n            1. Let _b_ be IsWordChar(_rer_, _Input_, _e_).\n            1. If _a_ is *true* and _b_ is *false*, or if _a_ is *false* and _b_ is *true*, return _c_(_x_).\n            1. Return ~failure~.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Assertion","idx":3,"subIdx":0,"rhsParams":[]},"methodName":"CompileAssertion","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[Matcher]"}},"body":"\n  1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_ and performs the following steps when called:\n    1. Assert: _x_ is a Record[MatchState].\n    1. Assert: _c_ is a Record[MatcherContinuation].\n    1. Let _Input_ be _x_.[[Input]].\n    1. Let _e_ be _x_.[[EndIndex]].\n    1. Let _a_ be IsWordChar(_rer_, _Input_, _e_ - 1).\n    1. Let _b_ be IsWordChar(_rer_, _Input_, _e_).\n    1. If _a_ is *true* and _b_ is *true* or _a_ is *false* and _b_ is *false*, return _c_(_x_).\n    1. Return ~failure~.","code":"\n          1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_ and performs the following steps when called:\n            1. Assert: _x_ is a MatchState.\n            1. Assert: _c_ is a MatcherContinuation.\n            1. Let _Input_ be _x_.[[Input]].\n            1. Let _e_ be _x_.[[EndIndex]].\n            1. Let _a_ be IsWordChar(_rer_, _Input_, _e_ - 1).\n            1. Let _b_ be IsWordChar(_rer_, _Input_, _e_).\n            1. If _a_ is *true* and _b_ is *true*, or if _a_ is *false* and _b_ is *false*, return _c_(_x_).\n            1. Return ~failure~.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Assertion","idx":4,"subIdx":0,"rhsParams":[{"name":"Disjunction","ty":"Ast[Disjunction]","kind":{"Normal":{}}}]},"methodName":"CompileAssertion","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[Matcher]"}},"body":"\n  1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and ~forward~.\n  1. Return a new Matcher with parameters (_x_, _c_) that captures _m_ and performs the following steps when called:\n    1. Assert: _x_ is a Record[MatchState].\n    1. Assert: _c_ is a Record[MatcherContinuation].\n    1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:\n      1. Assert: _y_ is a Record[MatchState].\n      1. Return _y_.\n    1. Let _r_ be _m_(_x_, _d_).\n    1. If _r_ is ~failure~, return ~failure~.\n    1. Assert: _r_ is a Record[MatchState].\n    1. Let _cap_ be _r_.[[Captures]].\n    1. Let _Input_ be _x_.[[Input]].\n    1. Let _xe_ be _x_.[[EndIndex]].\n    1. Let _z_ be MatchState { [[Input]]: _Input_, [[EndIndex]]: _xe_, [[Captures]]: _cap_ }.\n    1. Return _c_(_z_).","code":"\n          1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and ~forward~.\n          1. Return a new Matcher with parameters (_x_, _c_) that captures _m_ and performs the following steps when called:\n            1. Assert: _x_ is a MatchState.\n            1. Assert: _c_ is a MatcherContinuation.\n            1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:\n              1. Assert: _y_ is a MatchState.\n              1. Return _y_.\n            1. Let _r_ be _m_(_x_, _d_).\n            1. If _r_ is ~failure~, return ~failure~.\n            1. Assert: _r_ is a MatchState.\n            1. Let _cap_ be _r_.[[Captures]].\n            1. Let _Input_ be _x_.[[Input]].\n            1. Let _xe_ be _x_.[[EndIndex]].\n            1. Let _z_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _xe_, [[Captures]]: _cap_ }.\n            1. Return _c_(_z_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Assertion","idx":5,"subIdx":0,"rhsParams":[{"name":"Disjunction","ty":"Ast[Disjunction]","kind":{"Normal":{}}}]},"methodName":"CompileAssertion","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[Matcher]"}},"body":"\n  1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and ~forward~.\n  1. Return a new Matcher with parameters (_x_, _c_) that captures _m_ and performs the following steps when called:\n    1. Assert: _x_ is a Record[MatchState].\n    1. Assert: _c_ is a Record[MatcherContinuation].\n    1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:\n      1. Assert: _y_ is a Record[MatchState].\n      1. Return _y_.\n    1. Let _r_ be _m_(_x_, _d_).\n    1. If _r_ is not ~failure~, return ~failure~.\n    1. Return _c_(_x_).","code":"\n          1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and ~forward~.\n          1. Return a new Matcher with parameters (_x_, _c_) that captures _m_ and performs the following steps when called:\n            1. Assert: _x_ is a MatchState.\n            1. Assert: _c_ is a MatcherContinuation.\n            1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:\n              1. Assert: _y_ is a MatchState.\n              1. Return _y_.\n            1. Let _r_ be _m_(_x_, _d_).\n            1. If _r_ is not ~failure~, return ~failure~.\n            1. Return _c_(_x_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Assertion","idx":6,"subIdx":0,"rhsParams":[{"name":"Disjunction","ty":"Ast[Disjunction]","kind":{"Normal":{}}}]},"methodName":"CompileAssertion","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[Matcher]"}},"body":"\n  1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and ~backward~.\n  1. Return a new Matcher with parameters (_x_, _c_) that captures _m_ and performs the following steps when called:\n    1. Assert: _x_ is a Record[MatchState].\n    1. Assert: _c_ is a Record[MatcherContinuation].\n    1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:\n      1. Assert: _y_ is a Record[MatchState].\n      1. Return _y_.\n    1. Let _r_ be _m_(_x_, _d_).\n    1. If _r_ is ~failure~, return ~failure~.\n    1. Assert: _r_ is a Record[MatchState].\n    1. Let _cap_ be _r_.[[Captures]].\n    1. Let _Input_ be _x_.[[Input]].\n    1. Let _xe_ be _x_.[[EndIndex]].\n    1. Let _z_ be MatchState { [[Input]]: _Input_, [[EndIndex]]: _xe_, [[Captures]]: _cap_ }.\n    1. Return _c_(_z_).","code":"\n          1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and ~backward~.\n          1. Return a new Matcher with parameters (_x_, _c_) that captures _m_ and performs the following steps when called:\n            1. Assert: _x_ is a MatchState.\n            1. Assert: _c_ is a MatcherContinuation.\n            1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:\n              1. Assert: _y_ is a MatchState.\n              1. Return _y_.\n            1. Let _r_ be _m_(_x_, _d_).\n            1. If _r_ is ~failure~, return ~failure~.\n            1. Assert: _r_ is a MatchState.\n            1. Let _cap_ be _r_.[[Captures]].\n            1. Let _Input_ be _x_.[[Input]].\n            1. Let _xe_ be _x_.[[EndIndex]].\n            1. Let _z_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _xe_, [[Captures]]: _cap_ }.\n            1. Return _c_(_z_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Assertion","idx":7,"subIdx":0,"rhsParams":[{"name":"Disjunction","ty":"Ast[Disjunction]","kind":{"Normal":{}}}]},"methodName":"CompileAssertion","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[Matcher]"}},"body":"\n  1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and ~backward~.\n  1. Return a new Matcher with parameters (_x_, _c_) that captures _m_ and performs the following steps when called:\n    1. Assert: _x_ is a Record[MatchState].\n    1. Assert: _c_ is a Record[MatcherContinuation].\n    1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:\n      1. Assert: _y_ is a Record[MatchState].\n      1. Return _y_.\n    1. Let _r_ be _m_(_x_, _d_).\n    1. If _r_ is not ~failure~, return ~failure~.\n    1. Return _c_(_x_).","code":"\n          1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and ~backward~.\n          1. Return a new Matcher with parameters (_x_, _c_) that captures _m_ and performs the following steps when called:\n            1. Assert: _x_ is a MatchState.\n            1. Assert: _c_ is a MatcherContinuation.\n            1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:\n              1. Assert: _y_ is a MatchState.\n              1. Return _y_.\n            1. Let _r_ be _m_(_x_, _d_).\n            1. If _r_ is not ~failure~, return ~failure~.\n            1. Return _c_(_x_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsWordChar","params":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}},{"name":"Input","ty":"Unknown[\"a List of characters\"]","kind":{"Normal":{}}},{"name":"e","ty":"Int","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _InputLength_ be the number of elements in _Input_.\n  1. If _e_ = -1 or _e_ = _InputLength_, return *false*.\n  1. Let _c_ be the character _Input_[_e_].\n  1. If WordCharacters(_rer_) contains _c_, return *true*.\n  1. Return *false*.","code":"\n            1. Let _InputLength_ be the number of elements in _Input_.\n            1. If _e_ = -1 or _e_ = _InputLength_, return *false*.\n            1. Let _c_ be the character _Input_[_e_].\n            1. If WordCharacters(_rer_) contains _c_, return *true*.\n            1. Return *false*.\n          "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Quantifier","idx":0,"subIdx":0,"rhsParams":[{"name":"QuantifierPrefix","ty":"Ast[QuantifierPrefix]","kind":{"Normal":{}}}]},"methodName":"CompileQuantifier","isStatic":false,"withParams":[],"retTy":"Unknown[\"a Record with fields [[Min]] (a non-negative integer), [[Max]] (a non-negative integer or +∞), and [[Greedy]] (a Boolean)\"]"}},"body":"\n  1. Let _qp_ be CompileQuantifierPrefix of |QuantifierPrefix|.\n  1. Return Record { [[Min]]: _qp_.[[Min]], [[Max]]: _qp_.[[Max]], [[Greedy]]: *true* }.","code":"\n          1. Let _qp_ be CompileQuantifierPrefix of |QuantifierPrefix|.\n          1. Return the Record { [[Min]]: _qp_.[[Min]], [[Max]]: _qp_.[[Max]], [[Greedy]]: *true* }.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Quantifier","idx":1,"subIdx":0,"rhsParams":[{"name":"QuantifierPrefix","ty":"Ast[QuantifierPrefix]","kind":{"Normal":{}}}]},"methodName":"CompileQuantifier","isStatic":false,"withParams":[],"retTy":"Unknown[\"a Record with fields [[Min]] (a non-negative integer), [[Max]] (a non-negative integer or +∞), and [[Greedy]] (a Boolean)\"]"}},"body":"\n  1. Let _qp_ be CompileQuantifierPrefix of |QuantifierPrefix|.\n  1. Return Record { [[Min]]: _qp_.[[Min]], [[Max]]: _qp_.[[Max]], [[Greedy]]: *false* }.","code":"\n          1. Let _qp_ be CompileQuantifierPrefix of |QuantifierPrefix|.\n          1. Return the Record { [[Min]]: _qp_.[[Min]], [[Max]]: _qp_.[[Max]], [[Greedy]]: *false* }.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"QuantifierPrefix","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"CompileQuantifierPrefix","isStatic":false,"withParams":[],"retTy":"Unknown[\"a Record with fields [[Min]] (a non-negative integer) and [[Max]] (a non-negative integer or +∞)\"]"}},"body":"\n  1. Return Record { [[Min]]: 0, [[Max]]: +∞ }.","code":"\n          1. Return the Record { [[Min]]: 0, [[Max]]: +∞ }.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"QuantifierPrefix","idx":1,"subIdx":0,"rhsParams":[]},"methodName":"CompileQuantifierPrefix","isStatic":false,"withParams":[],"retTy":"Unknown[\"a Record with fields [[Min]] (a non-negative integer) and [[Max]] (a non-negative integer or +∞)\"]"}},"body":"\n  1. Return Record { [[Min]]: 1, [[Max]]: +∞ }.","code":"\n          1. Return the Record { [[Min]]: 1, [[Max]]: +∞ }.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"QuantifierPrefix","idx":2,"subIdx":0,"rhsParams":[]},"methodName":"CompileQuantifierPrefix","isStatic":false,"withParams":[],"retTy":"Unknown[\"a Record with fields [[Min]] (a non-negative integer) and [[Max]] (a non-negative integer or +∞)\"]"}},"body":"\n  1. Return Record { [[Min]]: 0, [[Max]]: 1 }.","code":"\n          1. Return the Record { [[Min]]: 0, [[Max]]: 1 }.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"QuantifierPrefix","idx":3,"subIdx":0,"rhsParams":[{"name":"DecimalDigits","ty":"Ast[DecimalDigits]","kind":{"Normal":{}}}]},"methodName":"CompileQuantifierPrefix","isStatic":false,"withParams":[],"retTy":"Unknown[\"a Record with fields [[Min]] (a non-negative integer) and [[Max]] (a non-negative integer or +∞)\"]"}},"body":"\n  1. Let _i_ be MV of |DecimalDigits|.\n  1. Return Record { [[Min]]: _i_, [[Max]]: _i_ }.","code":"\n          1. Let _i_ be the MV of |DecimalDigits| (see <emu-xref href=\"#sec-literals-numeric-literals\"></emu-xref>).\n          1. Return the Record { [[Min]]: _i_, [[Max]]: _i_ }.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"QuantifierPrefix","idx":4,"subIdx":0,"rhsParams":[{"name":"DecimalDigits","ty":"Ast[DecimalDigits]","kind":{"Normal":{}}}]},"methodName":"CompileQuantifierPrefix","isStatic":false,"withParams":[],"retTy":"Unknown[\"a Record with fields [[Min]] (a non-negative integer) and [[Max]] (a non-negative integer or +∞)\"]"}},"body":"\n  1. Let _i_ be MV of |DecimalDigits|.\n  1. Return Record { [[Min]]: _i_, [[Max]]: +∞ }.","code":"\n          1. Let _i_ be the MV of |DecimalDigits|.\n          1. Return the Record { [[Min]]: _i_, [[Max]]: +∞ }.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"QuantifierPrefix","idx":5,"subIdx":0,"rhsParams":[{"name":"DecimalDigits","ty":"Ast[DecimalDigits]","kind":{"Normal":{}}},{"name":"DecimalDigits","ty":"Ast[DecimalDigits]","kind":{"Normal":{}}}]},"methodName":"CompileQuantifierPrefix","isStatic":false,"withParams":[],"retTy":"Unknown[\"a Record with fields [[Min]] (a non-negative integer) and [[Max]] (a non-negative integer or +∞)\"]"}},"body":"\n  1. Let _i_ be MV of the first |DecimalDigits|.\n  1. Let _j_ be MV of the second |DecimalDigits|.\n  1. Return Record { [[Min]]: _i_, [[Max]]: _j_ }.","code":"\n          1. Let _i_ be the MV of the first |DecimalDigits|.\n          1. Let _j_ be the MV of the second |DecimalDigits|.\n          1. Return the Record { [[Min]]: _i_, [[Max]]: _j_ }.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Atom","idx":0,"subIdx":0,"rhsParams":[{"name":"PatternCharacter","ty":"Ast[PatternCharacter]","kind":{"Normal":{}}}]},"methodName":"CompileAtom","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}},{"name":"direction","ty":"Enum[~backward~, ~forward~]","kind":{"Normal":{}}}],"retTy":"Record[Matcher]"}},"body":"\n  1. Let _ch_ be the character matched by |PatternCharacter|.\n  1. Let _A_ be a one-element CharSet containing the character _ch_.\n  1. Return CharacterSetMatcher(_rer_, _A_, *false*, _direction_).","code":"\n          1. Let _ch_ be the character matched by |PatternCharacter|.\n          1. Let _A_ be a one-element CharSet containing the character _ch_.\n          1. Return CharacterSetMatcher(_rer_, _A_, *false*, _direction_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Atom","idx":1,"subIdx":0,"rhsParams":[]},"methodName":"CompileAtom","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}},{"name":"direction","ty":"Enum[~backward~, ~forward~]","kind":{"Normal":{}}}],"retTy":"Record[Matcher]"}},"body":"\n  1. Let _A_ be AllCharacters(_rer_).\n  1. If _rer_.[[DotAll]] is not *true*, then\n    1. Remove from _A_ all characters corresponding to a code point on the right-hand side of the |LineTerminator| production.\n  1. Return CharacterSetMatcher(_rer_, _A_, *false*, _direction_).","code":"\n          1. Let _A_ be AllCharacters(_rer_).\n          1. If _rer_.[[DotAll]] is not *true*, then\n            1. Remove from _A_ all characters corresponding to a code point on the right-hand side of the |LineTerminator| production.\n          1. Return CharacterSetMatcher(_rer_, _A_, *false*, _direction_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Atom","idx":3,"subIdx":0,"rhsParams":[{"name":"CharacterClass","ty":"Ast[CharacterClass]","kind":{"Normal":{}}}]},"methodName":"CompileAtom","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}},{"name":"direction","ty":"Enum[~backward~, ~forward~]","kind":{"Normal":{}}}],"retTy":"Record[Matcher]"}},"body":"\n  1. Let _cc_ be CompileCharacterClass of |CharacterClass| with argument _rer_.\n  1. Let _cs_ be _cc_.[[CharSet]].\n  1. If _rer_.[[UnicodeSets]] is *false*, or if every CharSetElement of _cs_ consists of a single character (including if _cs_ is empty), return CharacterSetMatcher(_rer_, _cs_, _cc_.[[Invert]], _direction_).\n  1. Assert: _cc_.[[Invert]] is *false*.\n  1. Let _lm_ be an empty List of Matchers.\n  1. For each CharSetElement _s_ in _cs_ containing more than 1 character, iterating in descending order of length, do\n    1. Let _cs2_ be a one-element CharSet containing the last code point of _s_.\n    1. Let _m2_ be CharacterSetMatcher(_rer_, _cs2_, *false*, _direction_).\n    1. For each code point _c1_ in _s_, iterating backwards from its second-to-last code point, do\n      1. Let _cs1_ be a one-element CharSet containing _c1_.\n      1. Let _m1_ be CharacterSetMatcher(_rer_, _cs1_, *false*, _direction_).\n      1. Set _m2_ to MatchSequence(_m1_, _m2_, _direction_).\n    1. Append _m2_ to _lm_.\n  1. Let _singles_ be the CharSet containing every CharSetElement of _cs_ that consists of a single character.\n  1. Append CharacterSetMatcher(_rer_, _singles_, *false*, _direction_) to _lm_.\n  1. If _cs_ contains the empty sequence of characters, append EmptyMatcher() to _lm_.\n  1. Let _m2_ be the last Matcher in _lm_.\n  1. For each Matcher _m1_ of _lm_, iterating backwards from its second-to-last element, do\n    1. Set _m2_ to MatchTwoAlternatives(_m1_, _m2_).\n  1. Return _m2_.","code":"\n          1. Let _cc_ be CompileCharacterClass of |CharacterClass| with argument _rer_.\n          1. Let _cs_ be _cc_.[[CharSet]].\n          1. If _rer_.[[UnicodeSets]] is *false*, or if every CharSetElement of _cs_ consists of a single character (including if _cs_ is empty), return CharacterSetMatcher(_rer_, _cs_, _cc_.[[Invert]], _direction_).\n          1. Assert: _cc_.[[Invert]] is *false*.\n          1. Let _lm_ be an empty List of Matchers.\n          1. For each CharSetElement _s_ in _cs_ containing more than 1 character, iterating in descending order of length, do\n            1. Let _cs2_ be a one-element CharSet containing the last code point of _s_.\n            1. Let _m2_ be CharacterSetMatcher(_rer_, _cs2_, *false*, _direction_).\n            1. For each code point _c1_ in _s_, iterating backwards from its second-to-last code point, do\n              1. Let _cs1_ be a one-element CharSet containing _c1_.\n              1. Let _m1_ be CharacterSetMatcher(_rer_, _cs1_, *false*, _direction_).\n              1. Set _m2_ to MatchSequence(_m1_, _m2_, _direction_).\n            1. Append _m2_ to _lm_.\n          1. Let _singles_ be the CharSet containing every CharSetElement of _cs_ that consists of a single character.\n          1. Append CharacterSetMatcher(_rer_, _singles_, *false*, _direction_) to _lm_.\n          1. If _cs_ contains the empty sequence of characters, append EmptyMatcher() to _lm_.\n          1. Let _m2_ be the last Matcher in _lm_.\n          1. For each Matcher _m1_ of _lm_, iterating backwards from its second-to-last element, do\n            1. Set _m2_ to MatchTwoAlternatives(_m1_, _m2_).\n          1. Return _m2_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Atom","idx":4,"subIdx":0,"rhsParams":[{"name":"GroupSpecifier","ty":"Ast[GroupSpecifier]","kind":{"Normal":{}}},{"name":"Disjunction","ty":"Ast[Disjunction]","kind":{"Normal":{}}}]},"methodName":"CompileAtom","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}},{"name":"direction","ty":"Enum[~backward~, ~forward~]","kind":{"Normal":{}}}],"retTy":"Record[Matcher]"}},"body":"\n  1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and _direction_.\n  1. Let _parenIndex_ be CountLeftCapturingParensBefore(|Atom|).\n  1. Return a new Matcher with parameters (_x_, _c_) that captures _direction_, _m_, and _parenIndex_ and performs the following steps when called:\n    1. Assert: _x_ is a Record[MatchState].\n    1. Assert: _c_ is a Record[MatcherContinuation].\n    1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures _x_, _c_, _direction_, and _parenIndex_ and performs the following steps when called:\n      1. Assert: _y_ is a Record[MatchState].\n      1. Let _cap_ be a copy of _y_.[[Captures]].\n      1. Let _Input_ be _x_.[[Input]].\n      1. Let _xe_ be _x_.[[EndIndex]].\n      1. Let _ye_ be _y_.[[EndIndex]].\n      1. If _direction_ is ~forward~, then\n        1. Assert: _xe_ ≤ _ye_.\n        1. Let _r_ be CaptureRange { [[StartIndex]]: _xe_, [[EndIndex]]: _ye_ }.\n      1. Else,\n        1. Assert: _direction_ is ~backward~.\n        1. Assert: _ye_ ≤ _xe_.\n        1. Let _r_ be CaptureRange { [[StartIndex]]: _ye_, [[EndIndex]]: _xe_ }.\n      1. Set _cap_[_parenIndex_ + 1] to _r_.\n      1. Let _z_ be MatchState { [[Input]]: _Input_, [[EndIndex]]: _ye_, [[Captures]]: _cap_ }.\n      1. Return _c_(_z_).\n    1. Return _m_(_x_, _d_).","code":"\n          1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and _direction_.\n          1. Let _parenIndex_ be CountLeftCapturingParensBefore(|Atom|).\n          1. Return a new Matcher with parameters (_x_, _c_) that captures _direction_, _m_, and _parenIndex_ and performs the following steps when called:\n            1. Assert: _x_ is a MatchState.\n            1. Assert: _c_ is a MatcherContinuation.\n            1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures _x_, _c_, _direction_, and _parenIndex_ and performs the following steps when called:\n              1. Assert: _y_ is a MatchState.\n              1. Let _cap_ be a copy of _y_.[[Captures]].\n              1. Let _Input_ be _x_.[[Input]].\n              1. Let _xe_ be _x_.[[EndIndex]].\n              1. Let _ye_ be _y_.[[EndIndex]].\n              1. If _direction_ is ~forward~, then\n                1. Assert: _xe_ ≤ _ye_.\n                1. Let _r_ be the CaptureRange { [[StartIndex]]: _xe_, [[EndIndex]]: _ye_ }.\n              1. Else,\n                1. Assert: _direction_ is ~backward~.\n                1. Assert: _ye_ ≤ _xe_.\n                1. Let _r_ be the CaptureRange { [[StartIndex]]: _ye_, [[EndIndex]]: _xe_ }.\n              1. Set _cap_[_parenIndex_ + 1] to _r_.\n              1. Let _z_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _ye_, [[Captures]]: _cap_ }.\n              1. Return _c_(_z_).\n            1. Return _m_(_x_, _d_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Atom","idx":4,"subIdx":1,"rhsParams":[{"name":"GroupSpecifier","ty":"Ast[GroupSpecifier]","kind":{"Normal":{}}},{"name":"Disjunction","ty":"Ast[Disjunction]","kind":{"Normal":{}}}]},"methodName":"CompileAtom","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}},{"name":"direction","ty":"Enum[~backward~, ~forward~]","kind":{"Normal":{}}}],"retTy":"Record[Matcher]"}},"body":"\n  1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and _direction_.\n  1. Let _parenIndex_ be CountLeftCapturingParensBefore(|Atom|).\n  1. Return a new Matcher with parameters (_x_, _c_) that captures _direction_, _m_, and _parenIndex_ and performs the following steps when called:\n    1. Assert: _x_ is a Record[MatchState].\n    1. Assert: _c_ is a Record[MatcherContinuation].\n    1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures _x_, _c_, _direction_, and _parenIndex_ and performs the following steps when called:\n      1. Assert: _y_ is a Record[MatchState].\n      1. Let _cap_ be a copy of _y_.[[Captures]].\n      1. Let _Input_ be _x_.[[Input]].\n      1. Let _xe_ be _x_.[[EndIndex]].\n      1. Let _ye_ be _y_.[[EndIndex]].\n      1. If _direction_ is ~forward~, then\n        1. Assert: _xe_ ≤ _ye_.\n        1. Let _r_ be CaptureRange { [[StartIndex]]: _xe_, [[EndIndex]]: _ye_ }.\n      1. Else,\n        1. Assert: _direction_ is ~backward~.\n        1. Assert: _ye_ ≤ _xe_.\n        1. Let _r_ be CaptureRange { [[StartIndex]]: _ye_, [[EndIndex]]: _xe_ }.\n      1. Set _cap_[_parenIndex_ + 1] to _r_.\n      1. Let _z_ be MatchState { [[Input]]: _Input_, [[EndIndex]]: _ye_, [[Captures]]: _cap_ }.\n      1. Return _c_(_z_).\n    1. Return _m_(_x_, _d_).","code":"\n          1. Let _m_ be CompileSubpattern of |Disjunction| with arguments _rer_ and _direction_.\n          1. Let _parenIndex_ be CountLeftCapturingParensBefore(|Atom|).\n          1. Return a new Matcher with parameters (_x_, _c_) that captures _direction_, _m_, and _parenIndex_ and performs the following steps when called:\n            1. Assert: _x_ is a MatchState.\n            1. Assert: _c_ is a MatcherContinuation.\n            1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures _x_, _c_, _direction_, and _parenIndex_ and performs the following steps when called:\n              1. Assert: _y_ is a MatchState.\n              1. Let _cap_ be a copy of _y_.[[Captures]].\n              1. Let _Input_ be _x_.[[Input]].\n              1. Let _xe_ be _x_.[[EndIndex]].\n              1. Let _ye_ be _y_.[[EndIndex]].\n              1. If _direction_ is ~forward~, then\n                1. Assert: _xe_ ≤ _ye_.\n                1. Let _r_ be the CaptureRange { [[StartIndex]]: _xe_, [[EndIndex]]: _ye_ }.\n              1. Else,\n                1. Assert: _direction_ is ~backward~.\n                1. Assert: _ye_ ≤ _xe_.\n                1. Let _r_ be the CaptureRange { [[StartIndex]]: _ye_, [[EndIndex]]: _xe_ }.\n              1. Set _cap_[_parenIndex_ + 1] to _r_.\n              1. Let _z_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _ye_, [[Captures]]: _cap_ }.\n              1. Return _c_(_z_).\n            1. Return _m_(_x_, _d_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"Atom","idx":5,"subIdx":0,"rhsParams":[{"name":"Disjunction","ty":"Ast[Disjunction]","kind":{"Normal":{}}}]},"methodName":"CompileAtom","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}},{"name":"direction","ty":"Enum[~backward~, ~forward~]","kind":{"Normal":{}}}],"retTy":"Record[Matcher]"}},"body":"\n  1. Return CompileSubpattern of |Disjunction| with arguments _rer_ and _direction_.","code":"\n          1. Return CompileSubpattern of |Disjunction| with arguments _rer_ and _direction_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AtomEscape","idx":0,"subIdx":0,"rhsParams":[{"name":"DecimalEscape","ty":"Ast[DecimalEscape]","kind":{"Normal":{}}}]},"methodName":"CompileAtom","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}},{"name":"direction","ty":"Enum[~backward~, ~forward~]","kind":{"Normal":{}}}],"retTy":"Record[Matcher]"}},"body":"\n  1. Let _n_ be CapturingGroupNumber of |DecimalEscape|.\n  1. Assert: _n_ ≤ _rer_.[[CapturingGroupsCount]].\n  1. Return BackreferenceMatcher(_rer_, _n_, _direction_).","code":"\n          1. Let _n_ be the CapturingGroupNumber of |DecimalEscape|.\n          1. Assert: _n_ ≤ _rer_.[[CapturingGroupsCount]].\n          1. Return BackreferenceMatcher(_rer_, _n_, _direction_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AtomEscape","idx":2,"subIdx":0,"rhsParams":[{"name":"CharacterEscape","ty":"Ast[CharacterEscape]","kind":{"Normal":{}}}]},"methodName":"CompileAtom","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}},{"name":"direction","ty":"Enum[~backward~, ~forward~]","kind":{"Normal":{}}}],"retTy":"Record[Matcher]"}},"body":"\n  1. Let _cv_ be CharacterValue of |CharacterEscape|.\n  1. Let _ch_ be the character whose character value is _cv_.\n  1. Let _A_ be a one-element CharSet containing the character _ch_.\n  1. Return CharacterSetMatcher(_rer_, _A_, *false*, _direction_).","code":"\n          1. Let _cv_ be the CharacterValue of |CharacterEscape|.\n          1. Let _ch_ be the character whose character value is _cv_.\n          1. Let _A_ be a one-element CharSet containing the character _ch_.\n          1. Return CharacterSetMatcher(_rer_, _A_, *false*, _direction_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AtomEscape","idx":1,"subIdx":0,"rhsParams":[{"name":"CharacterClassEscape","ty":"Ast[CharacterClassEscape]","kind":{"Normal":{}}}]},"methodName":"CompileAtom","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}},{"name":"direction","ty":"Enum[~backward~, ~forward~]","kind":{"Normal":{}}}],"retTy":"Record[Matcher]"}},"body":"\n  1. Let _cs_ be CompileToCharSet of |CharacterClassEscape| with argument _rer_.\n  1. If _rer_.[[UnicodeSets]] is *false*, or if every CharSetElement of _cs_ consists of a single character (including if _cs_ is empty), return CharacterSetMatcher(_rer_, _cs_, *false*, _direction_).\n  1. Let _lm_ be an empty List of Matchers.\n  1. For each CharSetElement _s_ in _cs_ containing more than 1 character, iterating in descending order of length, do\n    1. Let _cs2_ be a one-element CharSet containing the last code point of _s_.\n    1. Let _m2_ be CharacterSetMatcher(_rer_, _cs2_, *false*, _direction_).\n    1. For each code point _c1_ in _s_, iterating backwards from its second-to-last code point, do\n      1. Let _cs1_ be a one-element CharSet containing _c1_.\n      1. Let _m1_ be CharacterSetMatcher(_rer_, _cs1_, *false*, _direction_).\n      1. Set _m2_ to MatchSequence(_m1_, _m2_, _direction_).\n    1. Append _m2_ to _lm_.\n  1. Let _singles_ be the CharSet containing every CharSetElement of _cs_ that consists of a single character.\n  1. Append CharacterSetMatcher(_rer_, _singles_, *false*, _direction_) to _lm_.\n  1. If _cs_ contains the empty sequence of characters, append EmptyMatcher() to _lm_.\n  1. Let _m2_ be the last Matcher in _lm_.\n  1. For each Matcher _m1_ of _lm_, iterating backwards from its second-to-last element, do\n    1. Set _m2_ to MatchTwoAlternatives(_m1_, _m2_).\n  1. Return _m2_.","code":"\n          1. Let _cs_ be CompileToCharSet of |CharacterClassEscape| with argument _rer_.\n          1. If _rer_.[[UnicodeSets]] is *false*, or if every CharSetElement of _cs_ consists of a single character (including if _cs_ is empty), return CharacterSetMatcher(_rer_, _cs_, *false*, _direction_).\n          1. Let _lm_ be an empty List of Matchers.\n          1. For each CharSetElement _s_ in _cs_ containing more than 1 character, iterating in descending order of length, do\n            1. Let _cs2_ be a one-element CharSet containing the last code point of _s_.\n            1. Let _m2_ be CharacterSetMatcher(_rer_, _cs2_, *false*, _direction_).\n            1. For each code point _c1_ in _s_, iterating backwards from its second-to-last code point, do\n              1. Let _cs1_ be a one-element CharSet containing _c1_.\n              1. Let _m1_ be CharacterSetMatcher(_rer_, _cs1_, *false*, _direction_).\n              1. Set _m2_ to MatchSequence(_m1_, _m2_, _direction_).\n            1. Append _m2_ to _lm_.\n          1. Let _singles_ be the CharSet containing every CharSetElement of _cs_ that consists of a single character.\n          1. Append CharacterSetMatcher(_rer_, _singles_, *false*, _direction_) to _lm_.\n          1. If _cs_ contains the empty sequence of characters, append EmptyMatcher() to _lm_.\n          1. Let _m2_ be the last Matcher in _lm_.\n          1. For each Matcher _m1_ of _lm_, iterating backwards from its second-to-last element, do\n            1. Set _m2_ to MatchTwoAlternatives(_m1_, _m2_).\n          1. Return _m2_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"AtomEscape","idx":3,"subIdx":0,"rhsParams":[{"name":"GroupName","ty":"Ast[GroupName]","kind":{"Normal":{}}}]},"methodName":"CompileAtom","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}},{"name":"direction","ty":"Enum[~backward~, ~forward~]","kind":{"Normal":{}}}],"retTy":"Record[Matcher]"}},"body":"\n  1. Let _matchingGroupSpecifiers_ be GroupSpecifiersThatMatch(|GroupName|).\n  1. Assert: _matchingGroupSpecifiers_ contains a single |GroupSpecifier|..\n  1. Let _groupSpecifier_ be the sole element of _matchingGroupSpecifiers_.\n  1. Let _parenIndex_ be CountLeftCapturingParensBefore(_groupSpecifier_).\n  1. Return BackreferenceMatcher(_rer_, _parenIndex_, _direction_).","code":"\n          1. Let _matchingGroupSpecifiers_ be GroupSpecifiersThatMatch(|GroupName|).\n          1. Assert: _matchingGroupSpecifiers_ contains a single |GroupSpecifier|.\n          1. Let _groupSpecifier_ be the sole element of _matchingGroupSpecifiers_.\n          1. Let _parenIndex_ be CountLeftCapturingParensBefore(_groupSpecifier_).\n          1. Return BackreferenceMatcher(_rer_, _parenIndex_, _direction_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CharacterSetMatcher","params":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}},{"name":"A","ty":"Record[CharSet]","kind":{"Normal":{}}},{"name":"invert","ty":"Boolean","kind":{"Normal":{}}},{"name":"direction","ty":"Enum[~backward~, ~forward~]","kind":{"Normal":{}}}],"retTy":"Record[Matcher]"}},"body":"\n  1. If _rer_.[[UnicodeSets]] is *true*, then\n    1. Assert: _invert_ is *false*.\n    1. Assert: Every CharSetElement of _A_ consists of a single character..\n  1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_, _A_, _invert_, and _direction_ and performs the following steps when called:\n    1. Assert: _x_ is a Record[MatchState].\n    1. Assert: _c_ is a Record[MatcherContinuation].\n    1. Let _Input_ be _x_.[[Input]].\n    1. Let _e_ be _x_.[[EndIndex]].\n    1. If _direction_ is ~forward~, let _f_ be _e_ + 1.\n    1. Else, let _f_ be _e_ - 1.\n    1. Let _InputLength_ be the number of elements in _Input_.\n    1. If _f_ < 0 or _f_ > _InputLength_, return ~failure~.\n    1. Let _index_ be min(_e_, _f_).\n    1. Let _ch_ be the character _Input_[_index_].\n    1. Let _cc_ be Canonicalize(_rer_, _ch_).\n    1. If there exists a CharSetElement in _A_ containing exactly one character _a_ such that Canonicalize(_rer_, _a_) is _cc_, let _found_ be *true*. Otherwise, let _found_ be *false*.\n    1. If _invert_ is *false* and _found_ is *false*, return ~failure~.\n    1. If _invert_ is *true* and _found_ is *true*, return ~failure~.\n    1. Let _cap_ be _x_.[[Captures]].\n    1. Let _y_ be MatchState { [[Input]]: _Input_, [[EndIndex]]: _f_, [[Captures]]: _cap_ }.\n    1. Return _c_(_y_).","code":"\n            1. If _rer_.[[UnicodeSets]] is *true*, then\n              1. Assert: _invert_ is *false*.\n              1. Assert: Every CharSetElement of _A_ consists of a single character.\n            1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_, _A_, _invert_, and _direction_ and performs the following steps when called:\n              1. Assert: _x_ is a MatchState.\n              1. Assert: _c_ is a MatcherContinuation.\n              1. Let _Input_ be _x_.[[Input]].\n              1. Let _e_ be _x_.[[EndIndex]].\n              1. If _direction_ is ~forward~, let _f_ be _e_ + 1.\n              1. Else, let _f_ be _e_ - 1.\n              1. Let _InputLength_ be the number of elements in _Input_.\n              1. If _f_ < 0 or _f_ > _InputLength_, return ~failure~.\n              1. Let _index_ be min(_e_, _f_).\n              1. Let _ch_ be the character _Input_[_index_].\n              1. Let _cc_ be Canonicalize(_rer_, _ch_).\n              1. If there exists a CharSetElement in _A_ containing exactly one character _a_ such that Canonicalize(_rer_, _a_) is _cc_, let _found_ be *true*. Otherwise, let _found_ be *false*.\n              1. If _invert_ is *false* and _found_ is *false*, return ~failure~.\n              1. If _invert_ is *true* and _found_ is *true*, return ~failure~.\n              1. Let _cap_ be _x_.[[Captures]].\n              1. Let _y_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _f_, [[Captures]]: _cap_ }.\n              1. Return _c_(_y_).\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"BackreferenceMatcher","params":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}},{"name":"n","ty":"PosInt","kind":{"Normal":{}}},{"name":"direction","ty":"Enum[~backward~, ~forward~]","kind":{"Normal":{}}}],"retTy":"Record[Matcher]"}},"body":"\n  1. Assert: _n_ ≥ 1.\n  1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_, _n_, and _direction_ and performs the following steps when called:\n    1. Assert: _x_ is a Record[MatchState].\n    1. Assert: _c_ is a Record[MatcherContinuation].\n    1. Let _Input_ be _x_.[[Input]].\n    1. Let _cap_ be _x_.[[Captures]].\n    1. Let _r_ be _cap_[_n_].\n    1. If _r_ is *undefined*, return _c_(_x_).\n    1. Let _e_ be _x_.[[EndIndex]].\n    1. Let _rs_ be _r_.[[StartIndex]].\n    1. Let _re_ be _r_.[[EndIndex]].\n    1. Let _len_ be _re_ - _rs_.\n    1. If _direction_ is ~forward~, let _f_ be _e_ + _len_.\n    1. Else, let _f_ be _e_ - _len_.\n    1. Let _InputLength_ be the number of elements in _Input_.\n    1. If _f_ < 0 or _f_ > _InputLength_, return ~failure~.\n    1. Let _g_ be min(_e_, _f_).\n    1. If there exists an integer _i_ in the interval from 0 (inclusive) to _len_ (exclusive) such that Canonicalize(_rer_, _Input_[_rs_ + _i_]) is not Canonicalize(_rer_, _Input_[_g_ + _i_]), return ~failure~.\n    1. Let _y_ be MatchState { [[Input]]: _Input_, [[EndIndex]]: _f_, [[Captures]]: _cap_ }.\n    1. Return _c_(_y_).","code":"\n            1. Assert: _n_ ≥ 1.\n            1. Return a new Matcher with parameters (_x_, _c_) that captures _rer_, _n_, and _direction_ and performs the following steps when called:\n              1. Assert: _x_ is a MatchState.\n              1. Assert: _c_ is a MatcherContinuation.\n              1. Let _Input_ be _x_.[[Input]].\n              1. Let _cap_ be _x_.[[Captures]].\n              1. Let _r_ be _cap_[_n_].\n              1. If _r_ is *undefined*, return _c_(_x_).\n              1. Let _e_ be _x_.[[EndIndex]].\n              1. Let _rs_ be _r_.[[StartIndex]].\n              1. Let _re_ be _r_.[[EndIndex]].\n              1. Let _len_ be _re_ - _rs_.\n              1. If _direction_ is ~forward~, let _f_ be _e_ + _len_.\n              1. Else, let _f_ be _e_ - _len_.\n              1. Let _InputLength_ be the number of elements in _Input_.\n              1. If _f_ < 0 or _f_ > _InputLength_, return ~failure~.\n              1. Let _g_ be min(_e_, _f_).\n              1. If there exists an integer _i_ in the interval from 0 (inclusive) to _len_ (exclusive) such that Canonicalize(_rer_, _Input_[_rs_ + _i_]) is not Canonicalize(_rer_, _Input_[_g_ + _i_]), return ~failure~.\n              1. Let _y_ be the MatchState { [[Input]]: _Input_, [[EndIndex]]: _f_, [[Captures]]: _cap_ }.\n              1. Return _c_(_y_).\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"Canonicalize","params":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}},{"name":"ch","ty":"Unknown[\"a character\"]","kind":{"Normal":{}}}],"retTy":"Unknown[\"a character\"]"}},"body":"\n  1. If HasEitherUnicodeFlag(_rer_) is *true* and _rer_.[[IgnoreCase]] is *true*, then\n    1. If the file <a href=\"https://unicode.org/Public/UCD/latest/ucd/CaseFolding.txt\"><code>CaseFolding.txt</code></a> of the Unicode Character Database provides a simple or common case folding mapping for _ch_, return the result of applying that mapping to _ch_.\n    1. Return _ch_.\n  1. If _rer_.[[IgnoreCase]] is *false*, return _ch_.\n  1. Assert: _ch_ is a UTF-16 code unit..\n  1. Let _cp_ be the code point whose numeric value is the numeric value of _ch_.\n  1. Let _u_ be the result of toUppercase(« _cp_ »), according to the Unicode Default Case Conversion algorithm.\n  1. Let _uStr_ be CodePointsToString(_u_).\n  1. If the length of _uStr_ ≠ 1, return _ch_.\n  1. Let _cu_ be _uStr_'s single code unit element.\n  1. If ℝ(_ch_) ≥ 128 and ℝ(_cu_) < 128, return _ch_.\n  1. Return _cu_.","code":"\n            1. If HasEitherUnicodeFlag(_rer_) is *true* and _rer_.[[IgnoreCase]] is *true*, then\n              1. If the file <a href=\"https://unicode.org/Public/UCD/latest/ucd/CaseFolding.txt\"><code>CaseFolding.txt</code></a> of the Unicode Character Database provides a simple or common case folding mapping for _ch_, return the result of applying that mapping to _ch_.\n              1. Return _ch_.\n            1. If _rer_.[[IgnoreCase]] is *false*, return _ch_.\n            1. Assert: _ch_ is a UTF-16 code unit.\n            1. Let _cp_ be the code point whose numeric value is the numeric value of _ch_.\n            1. Let _u_ be the result of toUppercase(« _cp_ »), according to the Unicode Default Case Conversion algorithm.\n            1. Let _uStr_ be CodePointsToString(_u_).\n            1. If the length of _uStr_ ≠ 1, return _ch_.\n            1. Let _cu_ be _uStr_'s single code unit element.\n            1. If the numeric value of _ch_ ≥ 128 and the numeric value of _cu_ < 128, return _ch_.\n            1. Return _cu_.\n          "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CharacterClass","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassContents","ty":"Ast[ClassContents]","kind":{"Normal":{}}}]},"methodName":"CompileCharacterClass","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Unknown[\"a Record with fields [[CharSet]] (a CharSet) and [[Invert]] (a Boolean)\"]"}},"body":"\n  1. Let _A_ be CompileToCharSet of |ClassContents| with argument _rer_.\n  1. Return Record { [[CharSet]]: _A_, [[Invert]]: *false* }.","code":"\n          1. Let _A_ be CompileToCharSet of |ClassContents| with argument _rer_.\n          1. Return the Record { [[CharSet]]: _A_, [[Invert]]: *false* }.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CharacterClass","idx":1,"subIdx":0,"rhsParams":[{"name":"ClassContents","ty":"Ast[ClassContents]","kind":{"Normal":{}}}]},"methodName":"CompileCharacterClass","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Unknown[\"a Record with fields [[CharSet]] (a CharSet) and [[Invert]] (a Boolean)\"]"}},"body":"\n  1. Let _A_ be CompileToCharSet of |ClassContents| with argument _rer_.\n  1. If _rer_.[[UnicodeSets]] is *true*, then\n    1. Return Record { [[CharSet]]: CharacterComplement(_rer_, _A_), [[Invert]]: *false* }.\n  1. Return Record { [[CharSet]]: _A_, [[Invert]]: *true* }.","code":"\n          1. Let _A_ be CompileToCharSet of |ClassContents| with argument _rer_.\n          1. If _rer_.[[UnicodeSets]] is *true*, then\n            1. Return the Record { [[CharSet]]: CharacterComplement(_rer_, _A_), [[Invert]]: *false* }.\n          1. Return the Record { [[CharSet]]: _A_, [[Invert]]: *true* }.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassContents","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Return the empty CharSet.","code":"\n          1. Return the empty CharSet.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NonemptyClassRanges","idx":1,"subIdx":0,"rhsParams":[{"name":"ClassAtom","ty":"Ast[ClassAtom]","kind":{"Normal":{}}},{"name":"NonemptyClassRangesNoDash","ty":"Ast[NonemptyClassRangesNoDash]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _A_ be CompileToCharSet of |ClassAtom| with argument _rer_.\n  1. Let _B_ be CompileToCharSet of |NonemptyClassRangesNoDash| with argument _rer_.\n  1. Return the union of CharSets _A_ and _B_.","code":"\n          1. Let _A_ be CompileToCharSet of |ClassAtom| with argument _rer_.\n          1. Let _B_ be CompileToCharSet of |NonemptyClassRangesNoDash| with argument _rer_.\n          1. Return the union of CharSets _A_ and _B_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NonemptyClassRanges","idx":2,"subIdx":0,"rhsParams":[{"name":"ClassAtom","ty":"Ast[ClassAtom]","kind":{"Normal":{}}},{"name":"ClassAtom","ty":"Ast[ClassAtom]","kind":{"Normal":{}}},{"name":"ClassContents","ty":"Ast[ClassContents]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _A_ be CompileToCharSet of the first |ClassAtom| with argument _rer_.\n  1. Let _B_ be CompileToCharSet of the second |ClassAtom| with argument _rer_.\n  1. Let _C_ be CompileToCharSet of |ClassContents| with argument _rer_.\n  1. Let _D_ be CharacterRange(_A_, _B_).\n  1. Return the union of _D_ and _C_.","code":"\n          1. Let _A_ be CompileToCharSet of the first |ClassAtom| with argument _rer_.\n          1. Let _B_ be CompileToCharSet of the second |ClassAtom| with argument _rer_.\n          1. Let _C_ be CompileToCharSet of |ClassContents| with argument _rer_.\n          1. Let _D_ be CharacterRange(_A_, _B_).\n          1. Return the union of _D_ and _C_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NonemptyClassRangesNoDash","idx":1,"subIdx":0,"rhsParams":[{"name":"ClassAtomNoDash","ty":"Ast[ClassAtomNoDash]","kind":{"Normal":{}}},{"name":"NonemptyClassRangesNoDash","ty":"Ast[NonemptyClassRangesNoDash]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _A_ be CompileToCharSet of |ClassAtomNoDash| with argument _rer_.\n  1. Let _B_ be CompileToCharSet of |NonemptyClassRangesNoDash| with argument _rer_.\n  1. Return the union of CharSets _A_ and _B_.","code":"\n          1. Let _A_ be CompileToCharSet of |ClassAtomNoDash| with argument _rer_.\n          1. Let _B_ be CompileToCharSet of |NonemptyClassRangesNoDash| with argument _rer_.\n          1. Return the union of CharSets _A_ and _B_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NonemptyClassRangesNoDash","idx":2,"subIdx":0,"rhsParams":[{"name":"ClassAtomNoDash","ty":"Ast[ClassAtomNoDash]","kind":{"Normal":{}}},{"name":"ClassAtom","ty":"Ast[ClassAtom]","kind":{"Normal":{}}},{"name":"ClassContents","ty":"Ast[ClassContents]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _A_ be CompileToCharSet of |ClassAtomNoDash| with argument _rer_.\n  1. Let _B_ be CompileToCharSet of |ClassAtom| with argument _rer_.\n  1. Let _C_ be CompileToCharSet of |ClassContents| with argument _rer_.\n  1. Let _D_ be CharacterRange(_A_, _B_).\n  1. Return the union of _D_ and _C_.","code":"\n          1. Let _A_ be CompileToCharSet of |ClassAtomNoDash| with argument _rer_.\n          1. Let _B_ be CompileToCharSet of |ClassAtom| with argument _rer_.\n          1. Let _C_ be CompileToCharSet of |ClassContents| with argument _rer_.\n          1. Let _D_ be CharacterRange(_A_, _B_).\n          1. Return the union of _D_ and _C_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassAtom","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Return the CharSet containing the single character `-` U+002D (HYPHEN-MINUS).","code":"\n          1. Return the CharSet containing the single character `-` U+002D (HYPHEN-MINUS).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassAtomNoDash","idx":0,"subIdx":0,"rhsParams":[{"name":"SourceCharacter","ty":"Ast[SourceCharacter]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Return the CharSet containing the character matched by |SourceCharacter|.","code":"\n          1. Return the CharSet containing the character matched by |SourceCharacter|.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassEscape","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _cv_ be CharacterValue of *this* value.\n  1. Let _c_ be the character whose character value is _cv_.\n  1. Return the CharSet containing the single character _c_.","code":"\n          1. Let _cv_ be the CharacterValue of this |ClassEscape|.\n          1. Let _c_ be the character whose character value is _cv_.\n          1. Return the CharSet containing the single character _c_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassEscape","idx":1,"subIdx":0,"rhsParams":[]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _cv_ be CharacterValue of *this* value.\n  1. Let _c_ be the character whose character value is _cv_.\n  1. Return the CharSet containing the single character _c_.","code":"\n          1. Let _cv_ be the CharacterValue of this |ClassEscape|.\n          1. Let _c_ be the character whose character value is _cv_.\n          1. Return the CharSet containing the single character _c_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassEscape","idx":3,"subIdx":0,"rhsParams":[{"name":"CharacterEscape","ty":"Ast[CharacterEscape]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _cv_ be CharacterValue of *this* value.\n  1. Let _c_ be the character whose character value is _cv_.\n  1. Return the CharSet containing the single character _c_.","code":"\n          1. Let _cv_ be the CharacterValue of this |ClassEscape|.\n          1. Let _c_ be the character whose character value is _cv_.\n          1. Return the CharSet containing the single character _c_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CharacterClassEscape","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Return the ten-element CharSet containing the characters `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, and `9`.","code":"\n          1. Return the ten-element CharSet containing the characters `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, and `9`.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CharacterClassEscape","idx":1,"subIdx":0,"rhsParams":[]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _S_ be the CharSet returned by <emu-grammar>CharacterClassEscape :: `d`</emu-grammar>.\n  1. Return CharacterComplement(_rer_, _S_).","code":"\n          1. Let _S_ be the CharSet returned by <emu-grammar>CharacterClassEscape :: `d`</emu-grammar>.\n          1. Return CharacterComplement(_rer_, _S_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CharacterClassEscape","idx":2,"subIdx":0,"rhsParams":[]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Return the CharSet containing all characters corresponding to a code point on the right-hand side of the |WhiteSpace| or |LineTerminator| productions.","code":"\n          1. Return the CharSet containing all characters corresponding to a code point on the right-hand side of the |WhiteSpace| or |LineTerminator| productions.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CharacterClassEscape","idx":3,"subIdx":0,"rhsParams":[]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _S_ be the CharSet returned by <emu-grammar>CharacterClassEscape :: `s`</emu-grammar>.\n  1. Return CharacterComplement(_rer_, _S_).","code":"\n          1. Let _S_ be the CharSet returned by <emu-grammar>CharacterClassEscape :: `s`</emu-grammar>.\n          1. Return CharacterComplement(_rer_, _S_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CharacterClassEscape","idx":4,"subIdx":0,"rhsParams":[]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Return MaybeSimpleCaseFolding(_rer_, WordCharacters(_rer_)).","code":"\n          1. Return MaybeSimpleCaseFolding(_rer_, WordCharacters(_rer_)).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CharacterClassEscape","idx":5,"subIdx":0,"rhsParams":[]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _S_ be the CharSet returned by <emu-grammar>CharacterClassEscape :: `w`</emu-grammar>.\n  1. Return CharacterComplement(_rer_, _S_).","code":"\n          1. Let _S_ be the CharSet returned by <emu-grammar>CharacterClassEscape :: `w`</emu-grammar>.\n          1. Return CharacterComplement(_rer_, _S_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CharacterClassEscape","idx":6,"subIdx":0,"rhsParams":[{"name":"UnicodePropertyValueExpression","ty":"Ast[UnicodePropertyValueExpression]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Return CompileToCharSet of |UnicodePropertyValueExpression| with argument _rer_.","code":"\n          1. Return CompileToCharSet of |UnicodePropertyValueExpression| with argument _rer_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"CharacterClassEscape","idx":7,"subIdx":0,"rhsParams":[{"name":"UnicodePropertyValueExpression","ty":"Ast[UnicodePropertyValueExpression]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _S_ be CompileToCharSet of |UnicodePropertyValueExpression| with argument _rer_.\n  1. Assert: _S_ contains only single code points..\n  1. Return CharacterComplement(_rer_, _S_).","code":"\n          1. Let _S_ be CompileToCharSet of |UnicodePropertyValueExpression| with argument _rer_.\n          1. Assert: _S_ contains only single code points.\n          1. Return CharacterComplement(_rer_, _S_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnicodePropertyValueExpression","idx":0,"subIdx":0,"rhsParams":[{"name":"UnicodePropertyName","ty":"Ast[UnicodePropertyName]","kind":{"Normal":{}}},{"name":"UnicodePropertyValue","ty":"Ast[UnicodePropertyValue]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _ps_ be the source text matched by |UnicodePropertyName|.\n  1. Let _p_ be UnicodeMatchProperty(_rer_, _ps_).\n  1. Assert: _p_ is a Unicode property name or property alias listed in the “Property name and aliases” column of <emu-xref href=\"#table-nonbinary-unicode-properties\"></emu-xref>..\n  1. Let _vs_ be the source text matched by |UnicodePropertyValue|.\n  1. Let _v_ be UnicodeMatchPropertyValue(_p_, _vs_).\n  1. Let _A_ be the CharSet containing all Unicode code points whose character database definition includes the property _p_ with value _v_.\n  1. Return MaybeSimpleCaseFolding(_rer_, _A_).","code":"\n          1. Let _ps_ be the source text matched by |UnicodePropertyName|.\n          1. Let _p_ be UnicodeMatchProperty(_rer_, _ps_).\n          1. Assert: _p_ is a Unicode property name or property alias listed in the “Property name and aliases” column of <emu-xref href=\"#table-nonbinary-unicode-properties\"></emu-xref>.\n          1. Let _vs_ be the source text matched by |UnicodePropertyValue|.\n          1. Let _v_ be UnicodeMatchPropertyValue(_p_, _vs_).\n          1. Let _A_ be the CharSet containing all Unicode code points whose character database definition includes the property _p_ with value _v_.\n          1. Return MaybeSimpleCaseFolding(_rer_, _A_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"UnicodePropertyValueExpression","idx":1,"subIdx":0,"rhsParams":[{"name":"LoneUnicodePropertyNameOrValue","ty":"Ast[LoneUnicodePropertyNameOrValue]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _s_ be the source text matched by |LoneUnicodePropertyNameOrValue|.\n  1. If UnicodeMatchPropertyValue(`General_Category`, _s_) is a Unicode property value or property value alias for the General_Category (gc) property listed in <a href=\"https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt\"><code>PropertyValueAliases.txt</code></a>, then\n    1. Return the CharSet containing all Unicode code points whose character database definition includes the property “General_Category” with value _s_.\n  1. Let _p_ be UnicodeMatchProperty(_rer_, _s_).\n  1. Assert: _p_ is a binary Unicode property or binary property alias listed in the “<emu-not-ref>Property name</emu-not-ref> and aliases” column of <emu-xref href=\"#table-binary-unicode-properties\"></emu-xref>, or a binary Unicode property of strings listed in the “<emu-not-ref>Property name</emu-not-ref>” column of <emu-xref href=\"#table-binary-unicode-properties-of-strings\"></emu-xref>..\n  1. Let _A_ be the CharSet containing all CharSetElements whose character database definition includes the property _p_ with value “True”.\n  1. Return MaybeSimpleCaseFolding(_rer_, _A_).","code":"\n          1. Let _s_ be the source text matched by |LoneUnicodePropertyNameOrValue|.\n          1. If UnicodeMatchPropertyValue(`General_Category`, _s_) is a Unicode property value or property value alias for the General_Category (gc) property listed in <a href=\"https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt\"><code>PropertyValueAliases.txt</code></a>, then\n            1. Return the CharSet containing all Unicode code points whose character database definition includes the property “General_Category” with value _s_.\n          1. Let _p_ be UnicodeMatchProperty(_rer_, _s_).\n          1. Assert: _p_ is a binary Unicode property or binary property alias listed in the “<emu-not-ref>Property name</emu-not-ref> and aliases” column of <emu-xref href=\"#table-binary-unicode-properties\"></emu-xref>, or a binary Unicode property of strings listed in the “<emu-not-ref>Property name</emu-not-ref>” column of <emu-xref href=\"#table-binary-unicode-properties-of-strings\"></emu-xref>.\n          1. Let _A_ be the CharSet containing all CharSetElements whose character database definition includes the property _p_ with value “True”.\n          1. Return MaybeSimpleCaseFolding(_rer_, _A_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassUnion","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassSetRange","ty":"Ast[ClassSetRange]","kind":{"Normal":{}}},{"name":"ClassUnion","ty":"Ast[ClassUnion]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _A_ be CompileToCharSet of |ClassSetRange| with argument _rer_.\n  1. If |ClassUnion| is present, then\n    1. Let _B_ be CompileToCharSet of |ClassUnion| with argument _rer_.\n    1. Return the union of CharSets _A_ and _B_.\n  1. Return _A_.","code":"\n          1. Let _A_ be CompileToCharSet of |ClassSetRange| with argument _rer_.\n          1. If |ClassUnion| is present, then\n            1. Let _B_ be CompileToCharSet of |ClassUnion| with argument _rer_.\n            1. Return the union of CharSets _A_ and _B_.\n          1. Return _A_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassUnion","idx":0,"subIdx":1,"rhsParams":[{"name":"ClassSetRange","ty":"Ast[ClassSetRange]","kind":{"Normal":{}}},{"name":"ClassUnion","ty":"Ast[ClassUnion]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _A_ be CompileToCharSet of |ClassSetRange| with argument _rer_.\n  1. If |ClassUnion| is present, then\n    1. Let _B_ be CompileToCharSet of |ClassUnion| with argument _rer_.\n    1. Return the union of CharSets _A_ and _B_.\n  1. Return _A_.","code":"\n          1. Let _A_ be CompileToCharSet of |ClassSetRange| with argument _rer_.\n          1. If |ClassUnion| is present, then\n            1. Let _B_ be CompileToCharSet of |ClassUnion| with argument _rer_.\n            1. Return the union of CharSets _A_ and _B_.\n          1. Return _A_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassUnion","idx":1,"subIdx":0,"rhsParams":[{"name":"ClassSetOperand","ty":"Ast[ClassSetOperand]","kind":{"Normal":{}}},{"name":"ClassUnion","ty":"Ast[ClassUnion]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _A_ be CompileToCharSet of |ClassSetOperand| with argument _rer_.\n  1. If |ClassUnion| is present, then\n    1. Let _B_ be CompileToCharSet of |ClassUnion| with argument _rer_.\n    1. Return the union of CharSets _A_ and _B_.\n  1. Return _A_.","code":"\n          1. Let _A_ be CompileToCharSet of |ClassSetOperand| with argument _rer_.\n          1. If |ClassUnion| is present, then\n            1. Let _B_ be CompileToCharSet of |ClassUnion| with argument _rer_.\n            1. Return the union of CharSets _A_ and _B_.\n          1. Return _A_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassUnion","idx":1,"subIdx":1,"rhsParams":[{"name":"ClassSetOperand","ty":"Ast[ClassSetOperand]","kind":{"Normal":{}}},{"name":"ClassUnion","ty":"Ast[ClassUnion]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _A_ be CompileToCharSet of |ClassSetOperand| with argument _rer_.\n  1. If |ClassUnion| is present, then\n    1. Let _B_ be CompileToCharSet of |ClassUnion| with argument _rer_.\n    1. Return the union of CharSets _A_ and _B_.\n  1. Return _A_.","code":"\n          1. Let _A_ be CompileToCharSet of |ClassSetOperand| with argument _rer_.\n          1. If |ClassUnion| is present, then\n            1. Let _B_ be CompileToCharSet of |ClassUnion| with argument _rer_.\n            1. Return the union of CharSets _A_ and _B_.\n          1. Return _A_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassIntersection","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassSetOperand","ty":"Ast[ClassSetOperand]","kind":{"Normal":{}}},{"name":"ClassSetOperand","ty":"Ast[ClassSetOperand]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _A_ be CompileToCharSet of the first |ClassSetOperand| with argument _rer_.\n  1. Let _B_ be CompileToCharSet of the second |ClassSetOperand| with argument _rer_.\n  1. Return the intersection of CharSets _A_ and _B_.","code":"\n          1. Let _A_ be CompileToCharSet of the first |ClassSetOperand| with argument _rer_.\n          1. Let _B_ be CompileToCharSet of the second |ClassSetOperand| with argument _rer_.\n          1. Return the intersection of CharSets _A_ and _B_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassIntersection","idx":1,"subIdx":0,"rhsParams":[{"name":"ClassIntersection","ty":"Ast[ClassIntersection]","kind":{"Normal":{}}},{"name":"ClassSetOperand","ty":"Ast[ClassSetOperand]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _A_ be CompileToCharSet of |ClassIntersection| with argument _rer_.\n  1. Let _B_ be CompileToCharSet of |ClassSetOperand| with argument _rer_.\n  1. Return the intersection of CharSets _A_ and _B_.","code":"\n          1. Let _A_ be CompileToCharSet of the |ClassIntersection| with argument _rer_.\n          1. Let _B_ be CompileToCharSet of the |ClassSetOperand| with argument _rer_.\n          1. Return the intersection of CharSets _A_ and _B_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassSubtraction","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassSetOperand","ty":"Ast[ClassSetOperand]","kind":{"Normal":{}}},{"name":"ClassSetOperand","ty":"Ast[ClassSetOperand]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _A_ be CompileToCharSet of the first |ClassSetOperand| with argument _rer_.\n  1. Let _B_ be CompileToCharSet of the second |ClassSetOperand| with argument _rer_.\n  1. Return the CharSet containing the CharSetElements of _A_ which are not also CharSetElements of _B_.","code":"\n          1. Let _A_ be CompileToCharSet of the first |ClassSetOperand| with argument _rer_.\n          1. Let _B_ be CompileToCharSet of the second |ClassSetOperand| with argument _rer_.\n          1. Return the CharSet containing the CharSetElements of _A_ which are not also CharSetElements of _B_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassSubtraction","idx":1,"subIdx":0,"rhsParams":[{"name":"ClassSubtraction","ty":"Ast[ClassSubtraction]","kind":{"Normal":{}}},{"name":"ClassSetOperand","ty":"Ast[ClassSetOperand]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _A_ be CompileToCharSet of |ClassSubtraction| with argument _rer_.\n  1. Let _B_ be CompileToCharSet of |ClassSetOperand| with argument _rer_.\n  1. Return the CharSet containing the CharSetElements of _A_ which are not also CharSetElements of _B_.","code":"\n          1. Let _A_ be CompileToCharSet of the |ClassSubtraction| with argument _rer_.\n          1. Let _B_ be CompileToCharSet of the |ClassSetOperand| with argument _rer_.\n          1. Return the CharSet containing the CharSetElements of _A_ which are not also CharSetElements of _B_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassSetRange","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassSetCharacter","ty":"Ast[ClassSetCharacter]","kind":{"Normal":{}}},{"name":"ClassSetCharacter","ty":"Ast[ClassSetCharacter]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _A_ be CompileToCharSet of the first |ClassSetCharacter| with argument _rer_.\n  1. Let _B_ be CompileToCharSet of the second |ClassSetCharacter| with argument _rer_.\n  1. Return MaybeSimpleCaseFolding(_rer_, CharacterRange(_A_, _B_)).","code":"\n          1. Let _A_ be CompileToCharSet of the first |ClassSetCharacter| with argument _rer_.\n          1. Let _B_ be CompileToCharSet of the second |ClassSetCharacter| with argument _rer_.\n          1. Return MaybeSimpleCaseFolding(_rer_, CharacterRange(_A_, _B_)).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassSetOperand","idx":2,"subIdx":0,"rhsParams":[{"name":"ClassSetCharacter","ty":"Ast[ClassSetCharacter]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _A_ be CompileToCharSet of |ClassSetCharacter| with argument _rer_.\n  1. Return MaybeSimpleCaseFolding(_rer_, _A_).","code":"\n          1. Let _A_ be CompileToCharSet of |ClassSetCharacter| with argument _rer_.\n          1. Return MaybeSimpleCaseFolding(_rer_, _A_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassSetOperand","idx":1,"subIdx":0,"rhsParams":[{"name":"ClassStringDisjunction","ty":"Ast[ClassStringDisjunction]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _A_ be CompileToCharSet of |ClassStringDisjunction| with argument _rer_.\n  1. Return MaybeSimpleCaseFolding(_rer_, _A_).","code":"\n          1. Let _A_ be CompileToCharSet of |ClassStringDisjunction| with argument _rer_.\n          1. Return MaybeSimpleCaseFolding(_rer_, _A_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassSetOperand","idx":0,"subIdx":0,"rhsParams":[{"name":"NestedClass","ty":"Ast[NestedClass]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Return CompileToCharSet of |NestedClass| with argument _rer_.","code":"\n          1. Return CompileToCharSet of |NestedClass| with argument _rer_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NestedClass","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassContents","ty":"Ast[ClassContents]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Return CompileToCharSet of |ClassContents| with argument _rer_.","code":"\n          1. Return CompileToCharSet of |ClassContents| with argument _rer_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NestedClass","idx":1,"subIdx":0,"rhsParams":[{"name":"ClassContents","ty":"Ast[ClassContents]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _A_ be CompileToCharSet of |ClassContents| with argument _rer_.\n  1. Return CharacterComplement(_rer_, _A_).","code":"\n          1. Let _A_ be CompileToCharSet of |ClassContents| with argument _rer_.\n          1. Return CharacterComplement(_rer_, _A_).\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NestedClass","idx":2,"subIdx":0,"rhsParams":[{"name":"CharacterClassEscape","ty":"Ast[CharacterClassEscape]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Return CompileToCharSet of |CharacterClassEscape| with argument _rer_.","code":"\n          1. Return CompileToCharSet of |CharacterClassEscape| with argument _rer_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassStringDisjunction","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassStringDisjunctionContents","ty":"Ast[ClassStringDisjunctionContents]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Return CompileToCharSet of |ClassStringDisjunctionContents| with argument _rer_.","code":"\n          1. Return CompileToCharSet of |ClassStringDisjunctionContents| with argument _rer_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassStringDisjunctionContents","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassString","ty":"Ast[ClassString]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _s_ be CompileClassSetString of |ClassString| with argument _rer_.\n  1. Return the CharSet containing the one string _s_.","code":"\n          1. Let _s_ be CompileClassSetString of |ClassString| with argument _rer_.\n          1. Return the CharSet containing the one string _s_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassStringDisjunctionContents","idx":1,"subIdx":0,"rhsParams":[{"name":"ClassString","ty":"Ast[ClassString]","kind":{"Normal":{}}},{"name":"ClassStringDisjunctionContents","ty":"Ast[ClassStringDisjunctionContents]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _s_ be CompileClassSetString of |ClassString| with argument _rer_.\n  1. Let _A_ be the CharSet containing the one string _s_.\n  1. Let _B_ be CompileToCharSet of |ClassStringDisjunctionContents| with argument _rer_.\n  1. Return the union of CharSets _A_ and _B_.","code":"\n          1. Let _s_ be CompileClassSetString of |ClassString| with argument _rer_.\n          1. Let _A_ be the CharSet containing the one string _s_.\n          1. Let _B_ be CompileToCharSet of |ClassStringDisjunctionContents| with argument _rer_.\n          1. Return the union of CharSets _A_ and _B_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassSetCharacter","idx":0,"subIdx":0,"rhsParams":[{"name":"SourceCharacter","ty":"Ast[SourceCharacter]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _cv_ be CharacterValue of *this* value.\n  1. Let _c_ be the character whose character value is _cv_.\n  1. Return the CharSet containing the single character _c_.","code":"\n          1. Let _cv_ be the CharacterValue of this |ClassSetCharacter|.\n          1. Let _c_ be the character whose character value is _cv_.\n          1. Return the CharSet containing the single character _c_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassSetCharacter","idx":1,"subIdx":0,"rhsParams":[{"name":"CharacterEscape","ty":"Ast[CharacterEscape]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _cv_ be CharacterValue of *this* value.\n  1. Let _c_ be the character whose character value is _cv_.\n  1. Return the CharSet containing the single character _c_.","code":"\n          1. Let _cv_ be the CharacterValue of this |ClassSetCharacter|.\n          1. Let _c_ be the character whose character value is _cv_.\n          1. Return the CharSet containing the single character _c_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassSetCharacter","idx":2,"subIdx":0,"rhsParams":[{"name":"ClassSetReservedPunctuator","ty":"Ast[ClassSetReservedPunctuator]","kind":{"Normal":{}}}]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _cv_ be CharacterValue of *this* value.\n  1. Let _c_ be the character whose character value is _cv_.\n  1. Return the CharSet containing the single character _c_.","code":"\n          1. Let _cv_ be the CharacterValue of this |ClassSetCharacter|.\n          1. Let _c_ be the character whose character value is _cv_.\n          1. Return the CharSet containing the single character _c_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassSetCharacter","idx":3,"subIdx":0,"rhsParams":[]},"methodName":"CompileToCharSet","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Return the CharSet containing the single character U+0008 (BACKSPACE).","code":"\n          1. Return the CharSet containing the single character U+0008 (BACKSPACE).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CharacterRange","params":[{"name":"A","ty":"Record[CharSet]","kind":{"Normal":{}}},{"name":"B","ty":"Record[CharSet]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Assert: _A_ and _B_ each contain exactly one character..\n  1. Let _a_ be the one character in CharSet _A_.\n  1. Let _b_ be the one character in CharSet _B_.\n  1. Let _i_ be the character value of character _a_.\n  1. Let _j_ be the character value of character _b_.\n  1. Assert: _i_ ≤ _j_.\n  1. Return the CharSet containing all characters with a character value in the inclusive interval from _i_ to _j_.","code":"\n            1. Assert: _A_ and _B_ each contain exactly one character.\n            1. Let _a_ be the one character in CharSet _A_.\n            1. Let _b_ be the one character in CharSet _B_.\n            1. Let _i_ be the character value of character _a_.\n            1. Let _j_ be the character value of character _b_.\n            1. Assert: _i_ ≤ _j_.\n            1. Return the CharSet containing all characters with a character value in the inclusive interval from _i_ to _j_.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"HasEitherUnicodeFlag","params":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _rer_.[[Unicode]] is *true* or _rer_.[[UnicodeSets]] is *true*, then\n    1. Return *true*.\n  1. Return *false*.","code":"\n            1. If _rer_.[[Unicode]] is *true* or _rer_.[[UnicodeSets]] is *true*, then\n              1. Return *true*.\n            1. Return *false*.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"WordCharacters","params":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _basicWordChars_ be the CharSet containing every character in the ASCII word characters.\n  1. Let _extraWordChars_ be the CharSet containing all characters _c_ such that _c_ is not in _basicWordChars_ but Canonicalize(_rer_, _c_) is in _basicWordChars_.\n  1. Assert: _extraWordChars_ is empty unless HasEitherUnicodeFlag(_rer_) is *true* and _rer_.[[IgnoreCase]] is *true*..\n  1. Return the union of _basicWordChars_ and _extraWordChars_.","code":"\n            1. Let _basicWordChars_ be the CharSet containing every character in the ASCII word characters.\n            1. Let _extraWordChars_ be the CharSet containing all characters _c_ such that _c_ is not in _basicWordChars_ but Canonicalize(_rer_, _c_) is in _basicWordChars_.\n            1. Assert: _extraWordChars_ is empty unless HasEitherUnicodeFlag(_rer_) is *true* and _rer_.[[IgnoreCase]] is *true*.\n            1. Return the union of _basicWordChars_ and _extraWordChars_.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AllCharacters","params":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. If _rer_.[[UnicodeSets]] is *true* and _rer_.[[IgnoreCase]] is *true*, then\n    1. [declared=\"c\"] Return the CharSet containing all Unicode code points _c_ that do not have a <a href=\"https://www.unicode.org/reports/tr44/#Simple_Case_Folding\">Simple Case Folding</a> mapping (that is, scf(_c_)=_c_).\n  1. Else if HasEitherUnicodeFlag(_rer_) is *true*, then\n    1. Return the CharSet containing all code point values.\n  1. Else,\n    1. Return the CharSet containing all code unit values.","code":"\n            1. If _rer_.[[UnicodeSets]] is *true* and _rer_.[[IgnoreCase]] is *true*, then\n              1. [declared=\"c\"] Return the CharSet containing all Unicode code points _c_ that do not have a <a href=\"https://www.unicode.org/reports/tr44/#Simple_Case_Folding\">Simple Case Folding</a> mapping (that is, scf(_c_)=_c_).\n            1. Else if HasEitherUnicodeFlag(_rer_) is *true*, then\n              1. Return the CharSet containing all code point values.\n            1. Else,\n              1. Return the CharSet containing all code unit values.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"MaybeSimpleCaseFolding","params":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}},{"name":"A","ty":"Record[CharSet]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. If _rer_.[[UnicodeSets]] is *false* or _rer_.[[IgnoreCase]] is *false*, return _A_.\n  1. Let _B_ be a new empty CharSet.\n  1. For each Record[CharSetElement] _s_ of _A_, do\n    1. Let _t_ be an empty sequence of characters.\n    1. For each single code point _cp_ in _s_, do\n      1. Append scf(_cp_) to _t_.\n    1. Append _t_ to _B_.\n  1. Return _B_.","code":"\n            1. If _rer_.[[UnicodeSets]] is *false* or _rer_.[[IgnoreCase]] is *false*, return _A_.\n            1. Let _B_ be a new empty CharSet.\n            1. For each CharSetElement _s_ of _A_, do\n              1. Let _t_ be an empty sequence of characters.\n              1. For each single code point _cp_ in _s_, do\n                1. Append scf(_cp_) to _t_.\n              1. Add _t_ to _B_.\n            1. Return _B_.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CharacterComplement","params":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}},{"name":"S","ty":"Record[CharSet]","kind":{"Normal":{}}}],"retTy":"Record[CharSet]"}},"body":"\n  1. Let _A_ be AllCharacters(_rer_).\n  1. Return the CharSet containing the CharSetElements of _A_ which are not also CharSetElements of _S_.","code":"\n            1. Let _A_ be AllCharacters(_rer_).\n            1. Return the CharSet containing the CharSetElements of _A_ which are not also CharSetElements of _S_.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"UnicodeMatchProperty","params":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}},{"name":"p","ty":"Unknown[\"ECMAScript source text\"]","kind":{"Normal":{}}}],"retTy":"Unknown[\"a Unicode property name\"]"}},"body":"\n  1. If _rer_.[[UnicodeSets]] is *true* and _p_ is a Unicode <emu-not-ref>property name</emu-not-ref> listed in the “<emu-not-ref>Property name</emu-not-ref>” column of <emu-xref href=\"#table-binary-unicode-properties-of-strings\"></emu-xref>, then\n    1. Return the List of Unicode code points _p_.\n  1. Assert: _p_ is a Unicode <emu-not-ref>property name</emu-not-ref> or property alias listed in the “<emu-not-ref>Property name</emu-not-ref> and aliases” column of <emu-xref href=\"#table-nonbinary-unicode-properties\"></emu-xref> or <emu-xref href=\"#table-binary-unicode-properties\"></emu-xref>..\n  1. Let _c_ be the canonical <emu-not-ref>property name</emu-not-ref> of _p_ as given in the “Canonical <emu-not-ref>property name</emu-not-ref>” column of the corresponding row.\n  1. Return the List of Unicode code points _c_.","code":"\n            1. If _rer_.[[UnicodeSets]] is *true* and _p_ is a Unicode <emu-not-ref>property name</emu-not-ref> listed in the “<emu-not-ref>Property name</emu-not-ref>” column of <emu-xref href=\"#table-binary-unicode-properties-of-strings\"></emu-xref>, then\n              1. Return the List of Unicode code points _p_.\n            1. Assert: _p_ is a Unicode <emu-not-ref>property name</emu-not-ref> or property alias listed in the “<emu-not-ref>Property name</emu-not-ref> and aliases” column of <emu-xref href=\"#table-nonbinary-unicode-properties\"></emu-xref> or <emu-xref href=\"#table-binary-unicode-properties\"></emu-xref>.\n            1. Let _c_ be the canonical <emu-not-ref>property name</emu-not-ref> of _p_ as given in the “Canonical <emu-not-ref>property name</emu-not-ref>” column of the corresponding row.\n            1. Return the List of Unicode code points _c_.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"UnicodeMatchPropertyValue","params":[{"name":"p","ty":"Unknown[\"ECMAScript source text\"]","kind":{"Normal":{}}},{"name":"v","ty":"Unknown[\"ECMAScript source text\"]","kind":{"Normal":{}}}],"retTy":"Unknown[\"a Unicode property value\"]"}},"body":"\n  1. Assert: _p_ is a canonical, unaliased Unicode property name listed in the “Canonical property name” column of <emu-xref href=\"#table-nonbinary-unicode-properties\"></emu-xref>..\n  1. Assert: _v_ is a property value or property value alias for the Unicode property _p_ listed in <a href=\"https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt\"><code>PropertyValueAliases.txt</code></a>..\n  1. Let _value_ be the canonical property value of _v_ as given in the “Canonical property value” column of the corresponding row.\n  1. Return the List of Unicode code points _value_.","code":"\n            1. Assert: _p_ is a canonical, unaliased Unicode property name listed in the “Canonical property name” column of <emu-xref href=\"#table-nonbinary-unicode-properties\"></emu-xref>.\n            1. Assert: _v_ is a property value or property value alias for the Unicode property _p_ listed in <a href=\"https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt\"><code>PropertyValueAliases.txt</code></a>.\n            1. Let _value_ be the canonical property value of _v_ as given in the “Canonical property value” column of the corresponding row.\n            1. Return the List of Unicode code points _value_.\n          "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassString","idx":0,"subIdx":0,"rhsParams":[]},"methodName":"CompileClassSetString","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Unknown[\"a sequence of characters\"]"}},"body":"\n  1. Return an empty sequence of characters.","code":"\n          1. Return an empty sequence of characters.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"ClassString","idx":1,"subIdx":0,"rhsParams":[{"name":"NonEmptyClassString","ty":"Ast[NonEmptyClassString]","kind":{"Normal":{}}}]},"methodName":"CompileClassSetString","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Unknown[\"a sequence of characters\"]"}},"body":"\n  1. Return CompileClassSetString of |NonEmptyClassString| with argument _rer_.","code":"\n          1. Return CompileClassSetString of |NonEmptyClassString| with argument _rer_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NonEmptyClassString","idx":0,"subIdx":0,"rhsParams":[{"name":"ClassSetCharacter","ty":"Ast[ClassSetCharacter]","kind":{"Normal":{}}},{"name":"NonEmptyClassString","ty":"Ast[NonEmptyClassString]","kind":{"Normal":{}}}]},"methodName":"CompileClassSetString","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Unknown[\"a sequence of characters\"]"}},"body":"\n  1. Let _cs_ be CompileToCharSet of |ClassSetCharacter| with argument _rer_.\n  1. Let _s1_ be the sequence of characters that is the single CharSetElement of _cs_.\n  1. If |NonEmptyClassString| is present, then\n    1. Let _s2_ be CompileClassSetString of |NonEmptyClassString| with argument _rer_.\n    1. Return the concatenation of _s1_ and _s2_.\n  1. Return _s1_.","code":"\n          1. Let _cs_ be CompileToCharSet of |ClassSetCharacter| with argument _rer_.\n          1. Let _s1_ be the sequence of characters that is the single CharSetElement of _cs_.\n          1. If |NonEmptyClassString| is present, then\n            1. Let _s2_ be CompileClassSetString of |NonEmptyClassString| with argument _rer_.\n            1. Return the concatenation of _s1_ and _s2_.\n          1. Return _s1_.\n        "},{"head":{"SyntaxDirectedOperationHead":{"target":{"lhsName":"NonEmptyClassString","idx":0,"subIdx":1,"rhsParams":[{"name":"ClassSetCharacter","ty":"Ast[ClassSetCharacter]","kind":{"Normal":{}}},{"name":"NonEmptyClassString","ty":"Ast[NonEmptyClassString]","kind":{"Normal":{}}}]},"methodName":"CompileClassSetString","isStatic":false,"withParams":[{"name":"rer","ty":"Record[RegExpRecord]","kind":{"Normal":{}}}],"retTy":"Unknown[\"a sequence of characters\"]"}},"body":"\n  1. Let _cs_ be CompileToCharSet of |ClassSetCharacter| with argument _rer_.\n  1. Let _s1_ be the sequence of characters that is the single CharSetElement of _cs_.\n  1. If |NonEmptyClassString| is present, then\n    1. Let _s2_ be CompileClassSetString of |NonEmptyClassString| with argument _rer_.\n    1. Return the concatenation of _s1_ and _s2_.\n  1. Return _s1_.","code":"\n          1. Let _cs_ be CompileToCharSet of |ClassSetCharacter| with argument _rer_.\n          1. Let _s1_ be the sequence of characters that is the single CharSetElement of _cs_.\n          1. If |NonEmptyClassString| is present, then\n            1. Let _s2_ be CompileClassSetString of |NonEmptyClassString| with argument _rer_.\n            1. Return the concatenation of _s1_ and _s2_.\n          1. Return _s1_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"RegExpCreate","params":[{"name":"P","ty":"ESValue","kind":{"Normal":{}}},{"name":"F","ty":"String | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Record[Object]] | Throw"}},"body":"\n  1. Let _obj_ be ! RegExpAlloc(%RegExp%).\n  1. Return ? RegExpInitialize(_obj_, _P_, _F_).","code":"\n          1. Let _obj_ be ! RegExpAlloc(%RegExp%).\n          1. Return ? RegExpInitialize(_obj_, _P_, _F_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"RegExpAlloc","params":[{"name":"newTarget","ty":"Record[Constructor]","kind":{"Normal":{}}}],"retTy":"Normal[Record[Object]] | Throw"}},"body":"\n  1. Let _obj_ be ? OrdinaryCreateFromConstructor(_newTarget_, *\"%RegExp.prototype%\"*, « [[OriginalSource]], [[OriginalFlags]], [[RegExpRecord]], [[RegExpMatcher]] »).\n  1. Perform ! DefinePropertyOrThrow(_obj_, *\"lastIndex\"*, PropertyDescriptor { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n  1. Return _obj_.","code":"\n          1. Let _obj_ be ? OrdinaryCreateFromConstructor(_newTarget_, *\"%RegExp.prototype%\"*, « [[OriginalSource]], [[OriginalFlags]], [[RegExpRecord]], [[RegExpMatcher]] »).\n          1. Perform ! DefinePropertyOrThrow(_obj_, *\"lastIndex\"*, PropertyDescriptor { [[Writable]]: *true*, [[Enumerable]]: *false*, [[Configurable]]: *false* }).\n          1. Return _obj_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"RegExpInitialize","params":[{"name":"obj","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"pattern","ty":"ESValue","kind":{"Normal":{}}},{"name":"flags","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Record[Object]] | Throw"}},"body":"\n  1. If _pattern_ is *undefined*, let _P_ be *\"\"*.\n  1. Else, let _P_ be ? ToString(_pattern_).\n  1. If _flags_ is *undefined*, let _F_ be *\"\"*.\n  1. Else, let _F_ be ? ToString(_flags_).\n  1. If _F_ contains any code unit other than *\"d\"*, *\"g\"*, *\"i\"*, *\"m\"*, *\"s\"*, *\"u\"*, *\"v\"*, or *\"y\"*, or if _F_ contains any code unit more than once, throw a *SyntaxError* exception.\n  1. If _F_ contains *\"i\"*, let _i_ be *true*.\n  1. Else, let _i_ be *false*.\n  1. If _F_ contains *\"m\"*, let _m_ be *true*.\n  1. Else, let _m_ be *false*.\n  1. If _F_ contains *\"s\"*, let _s_ be *true*.\n  1. Else, let _s_ be *false*.\n  1. If _F_ contains *\"u\"*, let _u_ be *true*.\n  1. Else, let _u_ be *false*.\n  1. If _F_ contains *\"v\"*, let _v_ be *true*.\n  1. Else, let _v_ be *false*.\n  1. If _u_ is *true* or _v_ is *true*, then\n    1. Let _patternText_ be StringToCodePoints(_P_).\n  1. Else,\n    1. Let _patternText_ be the result of interpreting each of _P_'s 16-bit elements as a Unicode BMP code point. UTF-16 decoding is not applied to the elements.\n  1. Let _parseResult_ be ParsePattern(_patternText_, _u_, _v_).\n  1. If _parseResult_ is a non-empty List of *SyntaxError* objects, throw a *SyntaxError* exception.\n  1. Assert: _parseResult_ is a |Pattern| Parse Node..\n  1. Set _obj_.[[OriginalSource]] to _P_.\n  1. Set _obj_.[[OriginalFlags]] to _F_.\n  1. Let _capturingGroupsCount_ be CountLeftCapturingParensWithin(_parseResult_).\n  1. Let _rer_ be RegExp Record { [[IgnoreCase]]: _i_, [[Multiline]]: _m_, [[DotAll]]: _s_, [[Unicode]]: _u_, [[UnicodeSets]]: _v_, [[CapturingGroupsCount]]: _capturingGroupsCount_ }.\n  1. Set _obj_.[[RegExpRecord]] to _rer_.\n  1. Set _obj_.[[RegExpMatcher]] to CompilePattern of _parseResult_ with argument _rer_.\n  1. Perform ? Set(_obj_, *\"lastIndex\"*, *+0*<sub>𝔽</sub>, *true*).\n  1. Return _obj_.","code":"\n          1. If _pattern_ is *undefined*, let _P_ be the empty String.\n          1. Else, let _P_ be ? ToString(_pattern_).\n          1. If _flags_ is *undefined*, let _F_ be the empty String.\n          1. Else, let _F_ be ? ToString(_flags_).\n          1. If _F_ contains any code unit other than *\"d\"*, *\"g\"*, *\"i\"*, *\"m\"*, *\"s\"*, *\"u\"*, *\"v\"*, or *\"y\"*, or if _F_ contains any code unit more than once, throw a *SyntaxError* exception.\n          1. If _F_ contains *\"i\"*, let _i_ be *true*; else let _i_ be *false*.\n          1. If _F_ contains *\"m\"*, let _m_ be *true*; else let _m_ be *false*.\n          1. If _F_ contains *\"s\"*, let _s_ be *true*; else let _s_ be *false*.\n          1. If _F_ contains *\"u\"*, let _u_ be *true*; else let _u_ be *false*.\n          1. If _F_ contains *\"v\"*, let _v_ be *true*; else let _v_ be *false*.\n          1. If _u_ is *true* or _v_ is *true*, then\n            1. Let _patternText_ be StringToCodePoints(_P_).\n          1. Else,\n            1. Let _patternText_ be the result of interpreting each of _P_'s 16-bit elements as a Unicode BMP code point. UTF-16 decoding is not applied to the elements.\n          1. Let _parseResult_ be ParsePattern(_patternText_, _u_, _v_).\n          1. If _parseResult_ is a non-empty List of *SyntaxError* objects, throw a *SyntaxError* exception.\n          1. Assert: _parseResult_ is a |Pattern| Parse Node.\n          1. Set _obj_.[[OriginalSource]] to _P_.\n          1. Set _obj_.[[OriginalFlags]] to _F_.\n          1. Let _capturingGroupsCount_ be CountLeftCapturingParensWithin(_parseResult_).\n          1. Let _rer_ be the RegExp Record { [[IgnoreCase]]: _i_, [[Multiline]]: _m_, [[DotAll]]: _s_, [[Unicode]]: _u_, [[UnicodeSets]]: _v_, [[CapturingGroupsCount]]: _capturingGroupsCount_ }.\n          1. Set _obj_.[[RegExpRecord]] to _rer_.\n          1. Set _obj_.[[RegExpMatcher]] to CompilePattern of _parseResult_ with argument _rer_.\n          1. Perform ? Set(_obj_, *\"lastIndex\"*, *+0*<sub>𝔽</sub>, *true*).\n          1. Return _obj_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ParsePattern","params":[{"name":"patternText","ty":"Unknown[\"a sequence of Unicode code points\"]","kind":{"Normal":{}}},{"name":"u","ty":"Boolean","kind":{"Normal":{}}},{"name":"v","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Unknown[\"a Parse Node or a non-empty List of *SyntaxError* objects\"]"}},"body":"\n  1. If _v_ is *true* and _u_ is *true*, then\n    1. Let _parseResult_ be a List containing one or more *SyntaxError* objects.\n  1. Else if _v_ is *true*, then\n    1. Let _parseResult_ be ParseText(_patternText_, |Pattern[+UnicodeMode, +UnicodeSetsMode, +NamedCaptureGroups]|).\n  1. Else if _u_ is *true*, then\n    1. Let _parseResult_ be ParseText(_patternText_, |Pattern[+UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]|).\n  1. Else,\n    1. Let _parseResult_ be ParseText(_patternText_, |Pattern[~UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]|).\n  1. Return _parseResult_.","code":"\n          1. If _v_ is *true* and _u_ is *true*, then\n            1. Let _parseResult_ be a List containing one or more *SyntaxError* objects.\n          1. Else if _v_ is *true*, then\n            1. Let _parseResult_ be ParseText(_patternText_, |Pattern[+UnicodeMode, +UnicodeSetsMode, +NamedCaptureGroups]|).\n          1. Else if _u_ is *true*, then\n            1. Let _parseResult_ be ParseText(_patternText_, |Pattern[+UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]|).\n          1. Else,\n            1. Let _parseResult_ be ParseText(_patternText_, |Pattern[~UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]|).\n          1. Return _parseResult_.\n        "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"RegExp"}},"params":[{"name":"pattern","ty":"Unknown","kind":{"Normal":{}}},{"name":"flags","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _patternIsRegExp_ be ? IsRegExp(_pattern_).\n  1. If NewTarget is *undefined*, then\n    1. Let _newTarget_ be the active function object.\n    1. If _patternIsRegExp_ is *true* and _flags_ is *undefined*, then\n      1. Let _patternConstructor_ be ? Get(_pattern_, *\"constructor\"*).\n      1. If SameValue(_newTarget_, _patternConstructor_) is *true*, return _pattern_.\n  1. Else,\n    1. Let _newTarget_ be NewTarget.\n  1. If _pattern_ is a Record[Object] and _pattern_ has a [[RegExpMatcher]] internal slot, then\n    1. Let _P_ be _pattern_.[[OriginalSource]].\n    1. If _flags_ is *undefined*, let _F_ be _pattern_.[[OriginalFlags]].\n    1. Else, let _F_ be _flags_.\n  1. Else if _patternIsRegExp_ is *true*, then\n    1. Let _P_ be ? Get(_pattern_, *\"source\"*).\n    1. If _flags_ is *undefined*, then\n      1. Let _F_ be ? Get(_pattern_, *\"flags\"*).\n    1. Else,\n      1. Let _F_ be _flags_.\n  1. Else,\n    1. Let _P_ be _pattern_.\n    1. Let _F_ be _flags_.\n  1. Let _O_ be ? RegExpAlloc(_newTarget_).\n  1. Return ? RegExpInitialize(_O_, _P_, _F_).","code":"\n          1. Let _patternIsRegExp_ be ? IsRegExp(_pattern_).\n          1. If NewTarget is *undefined*, then\n            1. Let _newTarget_ be the active function object.\n            1. If _patternIsRegExp_ is *true* and _flags_ is *undefined*, then\n              1. Let _patternConstructor_ be ? Get(_pattern_, *\"constructor\"*).\n              1. If SameValue(_newTarget_, _patternConstructor_) is *true*, return _pattern_.\n          1. Else,\n            1. Let _newTarget_ be NewTarget.\n          1. If _pattern_ is an Object and _pattern_ has a [[RegExpMatcher]] internal slot, then\n            1. Let _P_ be _pattern_.[[OriginalSource]].\n            1. If _flags_ is *undefined*, let _F_ be _pattern_.[[OriginalFlags]].\n            1. Else, let _F_ be _flags_.\n          1. Else if _patternIsRegExp_ is *true*, then\n            1. Let _P_ be ? Get(_pattern_, *\"source\"*).\n            1. If _flags_ is *undefined*, then\n              1. Let _F_ be ? Get(_pattern_, *\"flags\"*).\n            1. Else,\n              1. Let _F_ be _flags_.\n          1. Else,\n            1. Let _P_ be _pattern_.\n            1. Let _F_ be _flags_.\n          1. Let _O_ be ? RegExpAlloc(_newTarget_).\n          1. Return ? RegExpInitialize(_O_, _P_, _F_).\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"SymbolAccess":{"base":{"Base":{"name":"RegExp"}},"symbol":"species"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Return *this* value.","code":"\n          1. Return the *this* value.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"RegExp"}},"name":"prototype"}},"name":"exec"}},"params":[{"name":"string","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _R_ be *this* value.\n  1. Perform ? RequireInternalSlot(_R_, [[RegExpMatcher]]).\n  1. Let _S_ be ? ToString(_string_).\n  1. Return ? RegExpBuiltinExec(_R_, _S_).","code":"\n          1. Let _R_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_R_, [[RegExpMatcher]]).\n          1. Let _S_ be ? ToString(_string_).\n          1. Return ? RegExpBuiltinExec(_R_, _S_).\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"RegExp"}},"name":"prototype"}},"name":"dotAll"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _R_ be *this* value.\n  1. Let _cu_ be 0x0073 (LATIN SMALL LETTER S).\n  1. Return ? RegExpHasFlag(_R_, _cu_).","code":"\n          1. Let _R_ be the *this* value.\n          1. Let _cu_ be the code unit 0x0073 (LATIN SMALL LETTER S).\n          1. Return ? RegExpHasFlag(_R_, _cu_).\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"RegExp"}},"name":"prototype"}},"name":"flags"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _R_ be *this* value.\n  1. If _R_ is not a Record[Object], throw a *TypeError* exception.\n  1. Let _codeUnits_ be « ».\n  1. Let _hasIndices_ be ToBoolean(? Get(_R_, *\"hasIndices\"*)).\n  1. If _hasIndices_ is *true*, append 0x0064 (LATIN SMALL LETTER D) to _codeUnits_.\n  1. Let _global_ be ToBoolean(? Get(_R_, *\"global\"*)).\n  1. If _global_ is *true*, append 0x0067 (LATIN SMALL LETTER G) to _codeUnits_.\n  1. Let _ignoreCase_ be ToBoolean(? Get(_R_, *\"ignoreCase\"*)).\n  1. If _ignoreCase_ is *true*, append 0x0069 (LATIN SMALL LETTER I) to _codeUnits_.\n  1. Let _multiline_ be ToBoolean(? Get(_R_, *\"multiline\"*)).\n  1. If _multiline_ is *true*, append 0x006d (LATIN SMALL LETTER M) to _codeUnits_.\n  1. Let _dotAll_ be ToBoolean(? Get(_R_, *\"dotAll\"*)).\n  1. If _dotAll_ is *true*, append 0x0073 (LATIN SMALL LETTER S) to _codeUnits_.\n  1. Let _unicode_ be ToBoolean(? Get(_R_, *\"unicode\"*)).\n  1. If _unicode_ is *true*, append 0x0075 (LATIN SMALL LETTER U) to _codeUnits_.\n  1. Let _unicodeSets_ be ToBoolean(? Get(_R_, *\"unicodeSets\"*)).\n  1. If _unicodeSets_ is *true*, append 0x0076 (LATIN SMALL LETTER V) to _codeUnits_.\n  1. Let _sticky_ be ToBoolean(? Get(_R_, *\"sticky\"*)).\n  1. If _sticky_ is *true*, append 0x0079 (LATIN SMALL LETTER Y) to _codeUnits_.\n  1. Return the String value whose code units are the elements of the List _codeUnits_. If _codeUnits_ has no elements, the empty String is returned.","code":"\n          1. Let _R_ be the *this* value.\n          1. If _R_ is not an Object, throw a *TypeError* exception.\n          1. Let _codeUnits_ be a new empty List.\n          1. Let _hasIndices_ be ToBoolean(? Get(_R_, *\"hasIndices\"*)).\n          1. If _hasIndices_ is *true*, append the code unit 0x0064 (LATIN SMALL LETTER D) to _codeUnits_.\n          1. Let _global_ be ToBoolean(? Get(_R_, *\"global\"*)).\n          1. If _global_ is *true*, append the code unit 0x0067 (LATIN SMALL LETTER G) to _codeUnits_.\n          1. Let _ignoreCase_ be ToBoolean(? Get(_R_, *\"ignoreCase\"*)).\n          1. If _ignoreCase_ is *true*, append the code unit 0x0069 (LATIN SMALL LETTER I) to _codeUnits_.\n          1. Let _multiline_ be ToBoolean(? Get(_R_, *\"multiline\"*)).\n          1. If _multiline_ is *true*, append the code unit 0x006D (LATIN SMALL LETTER M) to _codeUnits_.\n          1. Let _dotAll_ be ToBoolean(? Get(_R_, *\"dotAll\"*)).\n          1. If _dotAll_ is *true*, append the code unit 0x0073 (LATIN SMALL LETTER S) to _codeUnits_.\n          1. Let _unicode_ be ToBoolean(? Get(_R_, *\"unicode\"*)).\n          1. If _unicode_ is *true*, append the code unit 0x0075 (LATIN SMALL LETTER U) to _codeUnits_.\n          1. Let _unicodeSets_ be ToBoolean(? Get(_R_, *\"unicodeSets\"*)).\n          1. If _unicodeSets_ is *true*, append the code unit 0x0076 (LATIN SMALL LETTER V) to _codeUnits_.\n          1. Let _sticky_ be ToBoolean(? Get(_R_, *\"sticky\"*)).\n          1. If _sticky_ is *true*, append the code unit 0x0079 (LATIN SMALL LETTER Y) to _codeUnits_.\n          1. Return the String value whose code units are the elements of the List _codeUnits_. If _codeUnits_ has no elements, the empty String is returned.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"RegExpHasFlag","params":[{"name":"R","ty":"ESValue","kind":{"Normal":{}}},{"name":"codeUnit","ty":"Unknown[\"a code unit\"]","kind":{"Normal":{}}}],"retTy":"Normal[Boolean | Undefined] | Throw"}},"body":"\n  1. If _R_ is not a Record[Object], throw a *TypeError* exception.\n  1. If _R_ does not have a [[OriginalFlags]] internal slot, then\n    1. If SameValue(_R_, %RegExp.prototype%) is *true*, return *undefined*.\n    1. Else, throw a *TypeError* exception.\n  1. Let _flags_ be _R_.[[OriginalFlags]].\n  1. If _flags_ contains _codeUnit_, return *true*.\n  1. Return *false*.","code":"\n            1. If _R_ is not an Object, throw a *TypeError* exception.\n            1. If _R_ does not have an [[OriginalFlags]] internal slot, then\n              1. If SameValue(_R_, %RegExp.prototype%) is *true*, return *undefined*.\n              1. Otherwise, throw a *TypeError* exception.\n            1. Let _flags_ be _R_.[[OriginalFlags]].\n            1. If _flags_ contains _codeUnit_, return *true*.\n            1. Return *false*.\n          "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"RegExp"}},"name":"prototype"}},"name":"global"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _R_ be *this* value.\n  1. Let _cu_ be 0x0067 (LATIN SMALL LETTER G).\n  1. Return ? RegExpHasFlag(_R_, _cu_).","code":"\n          1. Let _R_ be the *this* value.\n          1. Let _cu_ be the code unit 0x0067 (LATIN SMALL LETTER G).\n          1. Return ? RegExpHasFlag(_R_, _cu_).\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"RegExp"}},"name":"prototype"}},"name":"hasIndices"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _R_ be *this* value.\n  1. Let _cu_ be 0x0064 (LATIN SMALL LETTER D).\n  1. Return ? RegExpHasFlag(_R_, _cu_).","code":"\n          1. Let _R_ be the *this* value.\n          1. Let _cu_ be the code unit 0x0064 (LATIN SMALL LETTER D).\n          1. Return ? RegExpHasFlag(_R_, _cu_).\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"RegExp"}},"name":"prototype"}},"name":"ignoreCase"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _R_ be *this* value.\n  1. Let _cu_ be 0x0069 (LATIN SMALL LETTER I).\n  1. Return ? RegExpHasFlag(_R_, _cu_).","code":"\n          1. Let _R_ be the *this* value.\n          1. Let _cu_ be the code unit 0x0069 (LATIN SMALL LETTER I).\n          1. Return ? RegExpHasFlag(_R_, _cu_).\n        "},{"head":{"BuiltinHead":{"path":{"SymbolAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"RegExp"}},"name":"prototype"}},"symbol":"match"}},"params":[{"name":"string","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _rx_ be *this* value.\n  1. If _rx_ is not a Record[Object], throw a *TypeError* exception.\n  1. Let _S_ be ? ToString(_string_).\n  1. Let _flags_ be ? ToString(? Get(_rx_, *\"flags\"*)).\n  1. If _flags_ does not contain *\"g\"*, then\n    1. Return ? RegExpExec(_rx_, _S_).\n  1. Else,\n    1. If _flags_ contains *\"u\"* or _flags_ contains *\"v\"*, let _fullUnicode_ be *true*.\n    1. Else, let _fullUnicode_ be *false*.\n    1. Perform ? Set(_rx_, *\"lastIndex\"*, *+0*<sub>𝔽</sub>, *true*).\n    1. Let _A_ be ! ArrayCreate(0).\n    1. Let _n_ be 0.\n    1. Repeat, \n      1. Let _result_ be ? RegExpExec(_rx_, _S_).\n      1. If _result_ is *null*, then\n        1. If _n_ = 0, return *null*.\n        1. Return _A_.\n      1. Else,\n        1. Let _matchStr_ be ? ToString(? Get(_result_, *\"0\"*)).\n        1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _matchStr_).\n        1. If _matchStr_ is *\"\"*, then\n          1. Let _thisIndex_ be ℝ(? ToLength(? Get(_rx_, *\"lastIndex\"*))).\n          1. Let _nextIndex_ be AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_).\n          1. Perform ? Set(_rx_, *\"lastIndex\"*, 𝔽(_nextIndex_), *true*).\n        1. Set _n_ to _n_ + 1.","code":"\n          1. Let _rx_ be the *this* value.\n          1. If _rx_ is not an Object, throw a *TypeError* exception.\n          1. Let _S_ be ? ToString(_string_).\n          1. Let _flags_ be ? ToString(? Get(_rx_, *\"flags\"*)).\n          1. If _flags_ does not contain *\"g\"*, then\n            1. Return ? RegExpExec(_rx_, _S_).\n          1. Else,\n            1. If _flags_ contains *\"u\"* or _flags_ contains *\"v\"*, let _fullUnicode_ be *true*. Otherwise, let _fullUnicode_ be *false*.\n            1. Perform ? Set(_rx_, *\"lastIndex\"*, *+0*<sub>𝔽</sub>, *true*).\n            1. Let _A_ be ! ArrayCreate(0).\n            1. Let _n_ be 0.\n            1. Repeat,\n              1. Let _result_ be ? RegExpExec(_rx_, _S_).\n              1. If _result_ is *null*, then\n                1. If _n_ = 0, return *null*.\n                1. Return _A_.\n              1. Else,\n                1. Let _matchStr_ be ? ToString(? Get(_result_, *\"0\"*)).\n                1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _matchStr_).\n                1. If _matchStr_ is the empty String, then\n                  1. Let _thisIndex_ be ℝ(? ToLength(? Get(_rx_, *\"lastIndex\"*))).\n                  1. Let _nextIndex_ be AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_).\n                  1. Perform ? Set(_rx_, *\"lastIndex\"*, 𝔽(_nextIndex_), *true*).\n                1. Set _n_ to _n_ + 1.\n        "},{"head":{"BuiltinHead":{"path":{"SymbolAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"RegExp"}},"name":"prototype"}},"symbol":"matchAll"}},"params":[{"name":"string","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _R_ be *this* value.\n  1. If _R_ is not a Record[Object], throw a *TypeError* exception.\n  1. Let _S_ be ? ToString(_string_).\n  1. Let _C_ be ? SpeciesConstructor(_R_, %RegExp%).\n  1. Let _flags_ be ? ToString(? Get(_R_, *\"flags\"*)).\n  1. Let _matcher_ be ? Construct(_C_, « _R_, _flags_ »).\n  1. Let _lastIndex_ be ? ToLength(? Get(_R_, *\"lastIndex\"*)).\n  1. Perform ? Set(_matcher_, *\"lastIndex\"*, _lastIndex_, *true*).\n  1. If _flags_ contains *\"g\"*, let _global_ be *true*.\n  1. Else, let _global_ be *false*.\n  1. If _flags_ contains *\"u\"* or _flags_ contains *\"v\"*, let _fullUnicode_ be *true*.\n  1. Else, let _fullUnicode_ be *false*.\n  1. Return CreateRegExpStringIterator(_matcher_, _S_, _global_, _fullUnicode_).","code":"\n          1. Let _R_ be the *this* value.\n          1. If _R_ is not an Object, throw a *TypeError* exception.\n          1. Let _S_ be ? ToString(_string_).\n          1. Let _C_ be ? SpeciesConstructor(_R_, %RegExp%).\n          1. Let _flags_ be ? ToString(? Get(_R_, *\"flags\"*)).\n          1. Let _matcher_ be ? Construct(_C_, « _R_, _flags_ »).\n          1. Let _lastIndex_ be ? ToLength(? Get(_R_, *\"lastIndex\"*)).\n          1. Perform ? Set(_matcher_, *\"lastIndex\"*, _lastIndex_, *true*).\n          1. If _flags_ contains *\"g\"*, let _global_ be *true*.\n          1. Else, let _global_ be *false*.\n          1. If _flags_ contains *\"u\"* or _flags_ contains *\"v\"*, let _fullUnicode_ be *true*.\n          1. Else, let _fullUnicode_ be *false*.\n          1. Return CreateRegExpStringIterator(_matcher_, _S_, _global_, _fullUnicode_).\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"RegExp"}},"name":"prototype"}},"name":"multiline"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _R_ be *this* value.\n  1. Let _cu_ be 0x006d (LATIN SMALL LETTER M).\n  1. Return ? RegExpHasFlag(_R_, _cu_).","code":"\n          1. Let _R_ be the *this* value.\n          1. Let _cu_ be the code unit 0x006D (LATIN SMALL LETTER M).\n          1. Return ? RegExpHasFlag(_R_, _cu_).\n        "},{"head":{"BuiltinHead":{"path":{"SymbolAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"RegExp"}},"name":"prototype"}},"symbol":"replace"}},"params":[{"name":"string","ty":"Unknown","kind":{"Normal":{}}},{"name":"replaceValue","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _rx_ be *this* value.\n  1. If _rx_ is not a Record[Object], throw a *TypeError* exception.\n  1. Let _S_ be ? ToString(_string_).\n  1. Let _lengthS_ be the length of _S_.\n  1. Let _functionalReplace_ be IsCallable(_replaceValue_).\n  1. If _functionalReplace_ is *false*, then\n    1. Set _replaceValue_ to ? ToString(_replaceValue_).\n  1. Let _flags_ be ? ToString(? Get(_rx_, *\"flags\"*)).\n  1. If _flags_ contains *\"g\"*, let _global_ be *true*.\n  1. Else, let _global_ be *false*.\n  1. If _global_ is *true*, then\n    1. Perform ? Set(_rx_, *\"lastIndex\"*, *+0*<sub>𝔽</sub>, *true*).\n  1. Let _results_ be « ».\n  1. Let _done_ be *false*.\n  1. Repeat, while _done_ is *false*,\n    1. Let _result_ be ? RegExpExec(_rx_, _S_).\n    1. If _result_ is *null*, then\n      1. Set _done_ to *true*.\n    1. Else,\n      1. Append _result_ to _results_.\n      1. If _global_ is *false*, then\n        1. Set _done_ to *true*.\n      1. Else,\n        1. Let _matchStr_ be ? ToString(? Get(_result_, *\"0\"*)).\n        1. If _matchStr_ is *\"\"*, then\n          1. Let _thisIndex_ be ℝ(? ToLength(? Get(_rx_, *\"lastIndex\"*))).\n          1. If _flags_ contains *\"u\"* or _flags_ contains *\"v\"*, let _fullUnicode_ be *true*.\n          1. Else, let _fullUnicode_ be *false*.\n          1. Let _nextIndex_ be AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_).\n          1. Perform ? Set(_rx_, *\"lastIndex\"*, 𝔽(_nextIndex_), *true*).\n  1. Let _accumulatedResult_ be *\"\"*.\n  1. Let _nextSourcePosition_ be 0.\n  1. For each _result_ of _results_, do\n    1. Let _resultLength_ be ? LengthOfArrayLike(_result_).\n    1. Let _nCaptures_ be max(_resultLength_ - 1, 0).\n    1. Let _matched_ be ? ToString(? Get(_result_, *\"0\"*)).\n    1. Let _matchLength_ be the length of _matched_.\n    1. Let _position_ be ? ToIntegerOrInfinity(? Get(_result_, *\"index\"*)).\n    1. Set _position_ to the result of clamping _position_ between 0 and _lengthS_.\n    1. Let _captures_ be « ».\n    1. Let _n_ be 1.\n    1. Repeat, while _n_ ≤ _nCaptures_,\n      1. Let _capN_ be ? Get(_result_, ! ToString(𝔽(_n_))).\n      1. If _capN_ is not *undefined*, then\n        1. Set _capN_ to ? ToString(_capN_).\n      1. Append _capN_ to _captures_.\n      1. NOTE: When _n_ = 1, the preceding step puts the first element into _captures_ (at index 0). More generally, the _n_<sup>th</sup> capture (the characters captured by the _n_<sup>th</sup> set of capturing parentheses) is at _captures_[_n_ - 1].\n      1. Set _n_ to _n_ + 1.\n    1. Let _namedCaptures_ be ? Get(_result_, *\"groups\"*).\n    1. If _functionalReplace_ is *true*, then\n      1. Let _replacerArgs_ be the list-concatenation of « _matched_ », _captures_, and « 𝔽(_position_), _S_ ».\n      1. If _namedCaptures_ is not *undefined*, then\n        1. Append _namedCaptures_ to _replacerArgs_.\n      1. Let _replValue_ be ? Call(_replaceValue_, *undefined*, _replacerArgs_).\n      1. Let _replacement_ be ? ToString(_replValue_).\n    1. Else,\n      1. If _namedCaptures_ is not *undefined*, then\n        1. Set _namedCaptures_ to ? ToObject(_namedCaptures_).\n      1. Let _replacement_ be ? GetSubstitution(_matched_, _S_, _position_, _captures_, _namedCaptures_, _replaceValue_).\n    1. If _position_ ≥ _nextSourcePosition_, then\n      1. NOTE: _position_ should not normally move backwards. If it does, it is an indication of an ill-behaving RegExp subclass or use of an access triggered side-effect to change the global flag or other characteristics of _rx_. In such cases, the corresponding substitution is ignored.\n      1. Set _accumulatedResult_ to the string-concatenation of _accumulatedResult_, the substring of _S_ from _nextSourcePosition_ to _position_, and _replacement_.\n      1. Set _nextSourcePosition_ to _position_ + _matchLength_.\n  1. If _nextSourcePosition_ ≥ _lengthS_, return _accumulatedResult_.\n  1. Return the string-concatenation of _accumulatedResult_ and the substring of _S_ from _nextSourcePosition_.","code":"\n          1. Let _rx_ be the *this* value.\n          1. If _rx_ is not an Object, throw a *TypeError* exception.\n          1. Let _S_ be ? ToString(_string_).\n          1. Let _lengthS_ be the length of _S_.\n          1. Let _functionalReplace_ be IsCallable(_replaceValue_).\n          1. If _functionalReplace_ is *false*, then\n            1. Set _replaceValue_ to ? ToString(_replaceValue_).\n          1. Let _flags_ be ? ToString(? Get(_rx_, *\"flags\"*)).\n          1. If _flags_ contains *\"g\"*, let _global_ be *true*. Otherwise, let _global_ be *false*.\n          1. If _global_ is *true*, then\n            1. Perform ? Set(_rx_, *\"lastIndex\"*, *+0*<sub>𝔽</sub>, *true*).\n          1. Let _results_ be a new empty List.\n          1. Let _done_ be *false*.\n          1. Repeat, while _done_ is *false*,\n            1. Let _result_ be ? RegExpExec(_rx_, _S_).\n            1. If _result_ is *null*, then\n              1. Set _done_ to *true*.\n            1. Else,\n              1. Append _result_ to _results_.\n              1. If _global_ is *false*, then\n                1. Set _done_ to *true*.\n              1. Else,\n                1. Let _matchStr_ be ? ToString(? Get(_result_, *\"0\"*)).\n                1. If _matchStr_ is the empty String, then\n                  1. Let _thisIndex_ be ℝ(? ToLength(? Get(_rx_, *\"lastIndex\"*))).\n                  1. If _flags_ contains *\"u\"* or _flags_ contains *\"v\"*, let _fullUnicode_ be *true*. Otherwise, let _fullUnicode_ be *false*.\n                  1. Let _nextIndex_ be AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_).\n                  1. Perform ? Set(_rx_, *\"lastIndex\"*, 𝔽(_nextIndex_), *true*).\n          1. Let _accumulatedResult_ be the empty String.\n          1. Let _nextSourcePosition_ be 0.\n          1. For each element _result_ of _results_, do\n            1. Let _resultLength_ be ? LengthOfArrayLike(_result_).\n            1. Let _nCaptures_ be max(_resultLength_ - 1, 0).\n            1. Let _matched_ be ? ToString(? Get(_result_, *\"0\"*)).\n            1. Let _matchLength_ be the length of _matched_.\n            1. Let _position_ be ? ToIntegerOrInfinity(? Get(_result_, *\"index\"*)).\n            1. Set _position_ to the result of clamping _position_ between 0 and _lengthS_.\n            1. Let _captures_ be a new empty List.\n            1. Let _n_ be 1.\n            1. Repeat, while _n_ ≤ _nCaptures_,\n              1. Let _capN_ be ? Get(_result_, ! ToString(𝔽(_n_))).\n              1. If _capN_ is not *undefined*, then\n                1. Set _capN_ to ? ToString(_capN_).\n              1. Append _capN_ to _captures_.\n              1. NOTE: When _n_ = 1, the preceding step puts the first element into _captures_ (at index 0). More generally, the _n_<sup>th</sup> capture (the characters captured by the _n_<sup>th</sup> set of capturing parentheses) is at _captures_[_n_ - 1].\n              1. Set _n_ to _n_ + 1.\n            1. Let _namedCaptures_ be ? Get(_result_, *\"groups\"*).\n            1. If _functionalReplace_ is *true*, then\n              1. Let _replacerArgs_ be the list-concatenation of « _matched_ », _captures_, and « 𝔽(_position_), _S_ ».\n              1. If _namedCaptures_ is not *undefined*, then\n                1. Append _namedCaptures_ to _replacerArgs_.\n              1. Let _replValue_ be ? Call(_replaceValue_, *undefined*, _replacerArgs_).\n              1. Let _replacement_ be ? ToString(_replValue_).\n            1. Else,\n              1. If _namedCaptures_ is not *undefined*, then\n                1. Set _namedCaptures_ to ? ToObject(_namedCaptures_).\n              1. Let _replacement_ be ? GetSubstitution(_matched_, _S_, _position_, _captures_, _namedCaptures_, _replaceValue_).\n            1. If _position_ ≥ _nextSourcePosition_, then\n              1. NOTE: _position_ should not normally move backwards. If it does, it is an indication of an ill-behaving RegExp subclass or use of an access triggered side-effect to change the global flag or other characteristics of _rx_. In such cases, the corresponding substitution is ignored.\n              1. Set _accumulatedResult_ to the string-concatenation of _accumulatedResult_, the substring of _S_ from _nextSourcePosition_ to _position_, and _replacement_.\n              1. Set _nextSourcePosition_ to _position_ + _matchLength_.\n          1. If _nextSourcePosition_ ≥ _lengthS_, return _accumulatedResult_.\n          1. Return the string-concatenation of _accumulatedResult_ and the substring of _S_ from _nextSourcePosition_.\n        "},{"head":{"BuiltinHead":{"path":{"SymbolAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"RegExp"}},"name":"prototype"}},"symbol":"search"}},"params":[{"name":"string","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _rx_ be *this* value.\n  1. If _rx_ is not a Record[Object], throw a *TypeError* exception.\n  1. Let _S_ be ? ToString(_string_).\n  1. Let _previousLastIndex_ be ? Get(_rx_, *\"lastIndex\"*).\n  1. If SameValue(_previousLastIndex_, *+0*<sub>𝔽</sub>) is *false*, then\n    1. Perform ? Set(_rx_, *\"lastIndex\"*, *+0*<sub>𝔽</sub>, *true*).\n  1. Let _result_ be ? RegExpExec(_rx_, _S_).\n  1. Let _currentLastIndex_ be ? Get(_rx_, *\"lastIndex\"*).\n  1. If SameValue(_currentLastIndex_, _previousLastIndex_) is *false*, then\n    1. Perform ? Set(_rx_, *\"lastIndex\"*, _previousLastIndex_, *true*).\n  1. If _result_ is *null*, return *-1*<sub>𝔽</sub>.\n  1. Return ? Get(_result_, *\"index\"*).","code":"\n          1. Let _rx_ be the *this* value.\n          1. If _rx_ is not an Object, throw a *TypeError* exception.\n          1. Let _S_ be ? ToString(_string_).\n          1. Let _previousLastIndex_ be ? Get(_rx_, *\"lastIndex\"*).\n          1. If SameValue(_previousLastIndex_, *+0*<sub>𝔽</sub>) is *false*, then\n            1. Perform ? Set(_rx_, *\"lastIndex\"*, *+0*<sub>𝔽</sub>, *true*).\n          1. Let _result_ be ? RegExpExec(_rx_, _S_).\n          1. Let _currentLastIndex_ be ? Get(_rx_, *\"lastIndex\"*).\n          1. If SameValue(_currentLastIndex_, _previousLastIndex_) is *false*, then\n            1. Perform ? Set(_rx_, *\"lastIndex\"*, _previousLastIndex_, *true*).\n          1. If _result_ is *null*, return *-1*<sub>𝔽</sub>.\n          1. Return ? Get(_result_, *\"index\"*).\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"RegExp"}},"name":"prototype"}},"name":"source"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _R_ be *this* value.\n  1. If _R_ is not a Record[Object], throw a *TypeError* exception.\n  1. If _R_ does not have a [[OriginalSource]] internal slot, then\n    1. If SameValue(_R_, %RegExp.prototype%) is *true*, return *\"(?:)\"*.\n    1. Else, throw a *TypeError* exception.\n  1. Assert: _R_ has a [[OriginalFlags]] internal slot.\n  1. Let _src_ be _R_.[[OriginalSource]].\n  1. Let _flags_ be _R_.[[OriginalFlags]].\n  1. Return EscapeRegExpPattern(_src_, _flags_).","code":"\n          1. Let _R_ be the *this* value.\n          1. If _R_ is not an Object, throw a *TypeError* exception.\n          1. If _R_ does not have an [[OriginalSource]] internal slot, then\n            1. If SameValue(_R_, %RegExp.prototype%) is *true*, return *\"(?:)\"*.\n            1. Otherwise, throw a *TypeError* exception.\n          1. Assert: _R_ has an [[OriginalFlags]] internal slot.\n          1. Let _src_ be _R_.[[OriginalSource]].\n          1. Let _flags_ be _R_.[[OriginalFlags]].\n          1. Return EscapeRegExpPattern(_src_, _flags_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"EscapeRegExpPattern","params":[{"name":"P","ty":"String","kind":{"Normal":{}}},{"name":"F","ty":"String","kind":{"Normal":{}}}],"retTy":"String"}},"body":"\n  1. If _F_ contains *\"v\"*, then\n    1. Let _patternSymbol_ be |Pattern[+UnicodeMode, +UnicodeSetsMode]|.\n  1. Else if _F_ contains *\"u\"*, then\n    1. Let _patternSymbol_ be |Pattern[+UnicodeMode, ~UnicodeSetsMode]|.\n  1. Else,\n    1. Let _patternSymbol_ be |Pattern[~UnicodeMode, ~UnicodeSetsMode]|.\n  1. Let _S_ be a String in the form of a _patternSymbol_ equivalent to _P_ interpreted as UTF-16 encoded Unicode code points (<emu-xref href=\"#sec-ecmascript-language-types-string-type\"></emu-xref>), in which certain code points are escaped as described below. _S_ may or may not differ from _P_; however, the Abstract Closure that would result from evaluating _S_ as a _patternSymbol_ must behave identically to the Abstract Closure given by the constructed object's [[RegExpMatcher]] internal slot. Multiple calls to this abstract operation using the same values for _P_ and _F_ must produce identical results.\n  1. The code points `/` or any |LineTerminator| occurring in the pattern shall be escaped in _S_ as necessary to ensure that the string-concatenation of *\"/\"*, _S_, *\"/\"*, and _F_ can be parsed (in an appropriate lexical context) as a |RegularExpressionLiteral| that behaves identically to the constructed regular expression. For example, if _P_ is *\"/\"*, then _S_ could be *\"\\\\/\"* or *\"\\\\u002F\"*, among other possibilities, but not *\"/\"*, because `///` followed by _F_ would be parsed as a |SingleLineComment| rather than a |RegularExpressionLiteral|. If _P_ is the empty String, this specification can be met by letting _S_ be *\"(?:)\"*.\n  1. Return _S_.","code":"\n            1. If _F_ contains *\"v\"*, then\n              1. Let _patternSymbol_ be |Pattern[+UnicodeMode, +UnicodeSetsMode]|.\n            1. Else if _F_ contains *\"u\"*, then\n              1. Let _patternSymbol_ be |Pattern[+UnicodeMode, ~UnicodeSetsMode]|.\n            1. Else,\n              1. Let _patternSymbol_ be |Pattern[~UnicodeMode, ~UnicodeSetsMode]|.\n            1. Let _S_ be a String in the form of a _patternSymbol_ equivalent to _P_ interpreted as UTF-16 encoded Unicode code points (<emu-xref href=\"#sec-ecmascript-language-types-string-type\"></emu-xref>), in which certain code points are escaped as described below. _S_ may or may not differ from _P_; however, the Abstract Closure that would result from evaluating _S_ as a _patternSymbol_ must behave identically to the Abstract Closure given by the constructed object's [[RegExpMatcher]] internal slot. Multiple calls to this abstract operation using the same values for _P_ and _F_ must produce identical results.\n            1. The code points `/` or any |LineTerminator| occurring in the pattern shall be escaped in _S_ as necessary to ensure that the string-concatenation of *\"/\"*, _S_, *\"/\"*, and _F_ can be parsed (in an appropriate lexical context) as a |RegularExpressionLiteral| that behaves identically to the constructed regular expression. For example, if _P_ is *\"/\"*, then _S_ could be *\"\\\\/\"* or *\"\\\\u002F\"*, among other possibilities, but not *\"/\"*, because `///` followed by _F_ would be parsed as a |SingleLineComment| rather than a |RegularExpressionLiteral|. If _P_ is the empty String, this specification can be met by letting _S_ be *\"(?:)\"*.\n            1. Return _S_.\n          "},{"head":{"BuiltinHead":{"path":{"SymbolAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"RegExp"}},"name":"prototype"}},"symbol":"split"}},"params":[{"name":"string","ty":"Unknown","kind":{"Normal":{}}},{"name":"limit","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _rx_ be *this* value.\n  1. If _rx_ is not a Record[Object], throw a *TypeError* exception.\n  1. Let _S_ be ? ToString(_string_).\n  1. Let _C_ be ? SpeciesConstructor(_rx_, %RegExp%).\n  1. Let _flags_ be ? ToString(? Get(_rx_, *\"flags\"*)).\n  1. If _flags_ contains *\"u\"* or _flags_ contains *\"v\"*, let _unicodeMatching_ be *true*.\n  1. Else, let _unicodeMatching_ be *false*.\n  1. If _flags_ contains *\"y\"*, let _newFlags_ be _flags_.\n  1. Else, let _newFlags_ be the string-concatenation of _flags_ and *\"y\"*.\n  1. Let _splitter_ be ? Construct(_C_, « _rx_, _newFlags_ »).\n  1. Let _A_ be ! ArrayCreate(0).\n  1. Let _lengthA_ be 0.\n  1. If _limit_ is *undefined*, let _lim_ be 2<sup>32</sup> - 1.\n  1. Else, let _lim_ be ℝ(? ToUint32(_limit_)).\n  1. If _lim_ = 0, return _A_.\n  1. If _S_ is *\"\"*, then\n    1. Let _z_ be ? RegExpExec(_splitter_, _S_).\n    1. If _z_ is not *null*, return _A_.\n    1. Perform ! CreateDataPropertyOrThrow(_A_, *\"0\"*, _S_).\n    1. Return _A_.\n  1. Let _size_ be the length of _S_.\n  1. Let _p_ be 0.\n  1. Let _q_ be _p_.\n  1. Repeat, while _q_ < _size_,\n    1. Perform ? Set(_splitter_, *\"lastIndex\"*, 𝔽(_q_), *true*).\n    1. Let _z_ be ? RegExpExec(_splitter_, _S_).\n    1. If _z_ is *null*, then\n      1. Set _q_ to AdvanceStringIndex(_S_, _q_, _unicodeMatching_).\n    1. Else,\n      1. Let _e_ be ℝ(? ToLength(? Get(_splitter_, *\"lastIndex\"*))).\n      1. Set _e_ to min(_e_, _size_).\n      1. If _e_ = _p_, then\n        1. Set _q_ to AdvanceStringIndex(_S_, _q_, _unicodeMatching_).\n      1. Else,\n        1. Let _T_ be the substring of _S_ from _p_ to _q_.\n        1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_lengthA_)), _T_).\n        1. Set _lengthA_ to _lengthA_ + 1.\n        1. If _lengthA_ = _lim_, return _A_.\n        1. Set _p_ to _e_.\n        1. Let _numberOfCaptures_ be ? LengthOfArrayLike(_z_).\n        1. Set _numberOfCaptures_ to max(_numberOfCaptures_ - 1, 0).\n        1. Let _i_ be 1.\n        1. Repeat, while _i_ ≤ _numberOfCaptures_,\n          1. Let _nextCapture_ be ? Get(_z_, ! ToString(𝔽(_i_))).\n          1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_lengthA_)), _nextCapture_).\n          1. Set _i_ to _i_ + 1.\n          1. Set _lengthA_ to _lengthA_ + 1.\n          1. If _lengthA_ = _lim_, return _A_.\n        1. Set _q_ to _p_.\n  1. Let _T_ be the substring of _S_ from _p_ to _size_.\n  1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_lengthA_)), _T_).\n  1. Return _A_.","code":"\n          1. Let _rx_ be the *this* value.\n          1. If _rx_ is not an Object, throw a *TypeError* exception.\n          1. Let _S_ be ? ToString(_string_).\n          1. Let _C_ be ? SpeciesConstructor(_rx_, %RegExp%).\n          1. Let _flags_ be ? ToString(? Get(_rx_, *\"flags\"*)).\n          1. If _flags_ contains *\"u\"* or _flags_ contains *\"v\"*, let _unicodeMatching_ be *true*.\n          1. Else, let _unicodeMatching_ be *false*.\n          1. If _flags_ contains *\"y\"*, let _newFlags_ be _flags_.\n          1. Else, let _newFlags_ be the string-concatenation of _flags_ and *\"y\"*.\n          1. Let _splitter_ be ? Construct(_C_, « _rx_, _newFlags_ »).\n          1. Let _A_ be ! ArrayCreate(0).\n          1. Let _lengthA_ be 0.\n          1. If _limit_ is *undefined*, let _lim_ be 2<sup>32</sup> - 1; else let _lim_ be ℝ(? ToUint32(_limit_)).\n          1. If _lim_ = 0, return _A_.\n          1. If _S_ is the empty String, then\n            1. Let _z_ be ? RegExpExec(_splitter_, _S_).\n            1. If _z_ is not *null*, return _A_.\n            1. Perform ! CreateDataPropertyOrThrow(_A_, *\"0\"*, _S_).\n            1. Return _A_.\n          1. Let _size_ be the length of _S_.\n          1. Let _p_ be 0.\n          1. Let _q_ be _p_.\n          1. Repeat, while _q_ < _size_,\n            1. Perform ? Set(_splitter_, *\"lastIndex\"*, 𝔽(_q_), *true*).\n            1. Let _z_ be ? RegExpExec(_splitter_, _S_).\n            1. If _z_ is *null*, then\n              1. Set _q_ to AdvanceStringIndex(_S_, _q_, _unicodeMatching_).\n            1. Else,\n              1. Let _e_ be ℝ(? ToLength(? Get(_splitter_, *\"lastIndex\"*))).\n              1. Set _e_ to min(_e_, _size_).\n              1. If _e_ = _p_, then\n                1. Set _q_ to AdvanceStringIndex(_S_, _q_, _unicodeMatching_).\n              1. Else,\n                1. Let _T_ be the substring of _S_ from _p_ to _q_.\n                1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_lengthA_)), _T_).\n                1. Set _lengthA_ to _lengthA_ + 1.\n                1. If _lengthA_ = _lim_, return _A_.\n                1. Set _p_ to _e_.\n                1. Let _numberOfCaptures_ be ? LengthOfArrayLike(_z_).\n                1. Set _numberOfCaptures_ to max(_numberOfCaptures_ - 1, 0).\n                1. Let _i_ be 1.\n                1. Repeat, while _i_ ≤ _numberOfCaptures_,\n                  1. Let _nextCapture_ be ? Get(_z_, ! ToString(𝔽(_i_))).\n                  1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_lengthA_)), _nextCapture_).\n                  1. Set _i_ to _i_ + 1.\n                  1. Set _lengthA_ to _lengthA_ + 1.\n                  1. If _lengthA_ = _lim_, return _A_.\n                1. Set _q_ to _p_.\n          1. Let _T_ be the substring of _S_ from _p_ to _size_.\n          1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_lengthA_)), _T_).\n          1. Return _A_.\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"RegExp"}},"name":"prototype"}},"name":"sticky"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _R_ be *this* value.\n  1. Let _cu_ be 0x0079 (LATIN SMALL LETTER Y).\n  1. Return ? RegExpHasFlag(_R_, _cu_).","code":"\n          1. Let _R_ be the *this* value.\n          1. Let _cu_ be the code unit 0x0079 (LATIN SMALL LETTER Y).\n          1. Return ? RegExpHasFlag(_R_, _cu_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"RegExp"}},"name":"prototype"}},"name":"test"}},"params":[{"name":"S","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _R_ be *this* value.\n  1. If _R_ is not a Record[Object], throw a *TypeError* exception.\n  1. Let _string_ be ? ToString(_S_).\n  1. Let _match_ be ? RegExpExec(_R_, _string_).\n  1. If _match_ is not *null*, return *true*.\n  1. Else, return *false*.","code":"\n          1. Let _R_ be the *this* value.\n          1. If _R_ is not an Object, throw a *TypeError* exception.\n          1. Let _string_ be ? ToString(_S_).\n          1. Let _match_ be ? RegExpExec(_R_, _string_).\n          1. If _match_ is not *null*, return *true*; else return *false*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"RegExp"}},"name":"prototype"}},"name":"toString"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _R_ be *this* value.\n  1. If _R_ is not a Record[Object], throw a *TypeError* exception.\n  1. Let _pattern_ be ? ToString(? Get(_R_, *\"source\"*)).\n  1. Let _flags_ be ? ToString(? Get(_R_, *\"flags\"*)).\n  1. Let _result_ be the string-concatenation of *\"/\"*, _pattern_, *\"/\"*, and _flags_.\n  1. Return _result_.","code":"\n          1. Let _R_ be the *this* value.\n          1. If _R_ is not an Object, throw a *TypeError* exception.\n          1. Let _pattern_ be ? ToString(? Get(_R_, *\"source\"*)).\n          1. Let _flags_ be ? ToString(? Get(_R_, *\"flags\"*)).\n          1. Let _result_ be the string-concatenation of *\"/\"*, _pattern_, *\"/\"*, and _flags_.\n          1. Return _result_.\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"RegExp"}},"name":"prototype"}},"name":"unicode"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _R_ be *this* value.\n  1. Let _cu_ be 0x0075 (LATIN SMALL LETTER U).\n  1. Return ? RegExpHasFlag(_R_, _cu_).","code":"\n          1. Let _R_ be the *this* value.\n          1. Let _cu_ be the code unit 0x0075 (LATIN SMALL LETTER U).\n          1. Return ? RegExpHasFlag(_R_, _cu_).\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"RegExp"}},"name":"prototype"}},"name":"unicodeSets"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _R_ be *this* value.\n  1. Let _cu_ be 0x0076 (LATIN SMALL LETTER V).\n  1. Return ? RegExpHasFlag(_R_, _cu_).","code":"\n          1. Let _R_ be the *this* value.\n          1. Let _cu_ be the code unit 0x0076 (LATIN SMALL LETTER V).\n          1. Return ? RegExpHasFlag(_R_, _cu_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"RegExpExec","params":[{"name":"R","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"S","ty":"String","kind":{"Normal":{}}}],"retTy":"Normal[Record[Object] | Null] | Throw"}},"body":"\n  1. Let _exec_ be ? Get(_R_, *\"exec\"*).\n  1. If IsCallable(_exec_) is *true*, then\n    1. Let _result_ be ? Call(_exec_, _R_, « _S_ »).\n    1. If _result_ is not a Record[Object] and _result_ is not *null*, throw a *TypeError* exception.\n    1. Return _result_.\n  1. Perform ? RequireInternalSlot(_R_, [[RegExpMatcher]]).\n  1. Return ? RegExpBuiltinExec(_R_, _S_).","code":"\n          1. Let _exec_ be ? Get(_R_, *\"exec\"*).\n          1. If IsCallable(_exec_) is *true*, then\n            1. Let _result_ be ? Call(_exec_, _R_, « _S_ »).\n            1. If _result_ is not an Object and _result_ is not *null*, throw a *TypeError* exception.\n            1. Return _result_.\n          1. Perform ? RequireInternalSlot(_R_, [[RegExpMatcher]]).\n          1. Return ? RegExpBuiltinExec(_R_, _S_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"RegExpBuiltinExec","params":[{"name":"R","ty":"Record[RegExp]","kind":{"Normal":{}}},{"name":"S","ty":"String","kind":{"Normal":{}}}],"retTy":"Normal[Record[Array] | Null] | Throw"}},"body":"\n  1. Let _length_ be the length of _S_.\n  1. Let _lastIndex_ be ℝ(? ToLength(? Get(_R_, *\"lastIndex\"*))).\n  1. Let _flags_ be _R_.[[OriginalFlags]].\n  1. If _flags_ contains *\"g\"*, let _global_ be *true*.\n  1. Else, let _global_ be *false*.\n  1. If _flags_ contains *\"y\"*, let _sticky_ be *true*.\n  1. Else, let _sticky_ be *false*.\n  1. If _flags_ contains *\"d\"*, let _hasIndices_ be *true*.\n  1. Else, let _hasIndices_ be *false*.\n  1. If _global_ is *false* and _sticky_ is *false*, set _lastIndex_ to 0.\n  1. Let _matcher_ be _R_.[[RegExpMatcher]].\n  1. If _flags_ contains *\"u\"* or _flags_ contains *\"v\"*, let _fullUnicode_ be *true*.\n  1. Else, let _fullUnicode_ be *false*.\n  1. Let _matchSucceeded_ be *false*.\n  1. If _fullUnicode_ is *true*, let _input_ be StringToCodePoints(_S_).\n  1. Else, let _input_ be a List whose elements are the code units that are the elements of _S_.\n  1. NOTE: Each element of _input_ is considered to be a character.\n  1. Repeat, while _matchSucceeded_ is *false*,\n    1. If _lastIndex_ > _length_, then\n      1. If _global_ is *true* or _sticky_ is *true*, then\n        1. Perform ? Set(_R_, *\"lastIndex\"*, *+0*<sub>𝔽</sub>, *true*).\n      1. Return *null*.\n    1. Let _inputIndex_ be the index into _input_ of the character that was obtained from element _lastIndex_ of _S_.\n    1. Let _r_ be _matcher_(_input_, _inputIndex_).\n    1. If _r_ is ~failure~, then\n      1. If _sticky_ is *true*, then\n        1. Perform ? Set(_R_, *\"lastIndex\"*, *+0*<sub>𝔽</sub>, *true*).\n        1. Return *null*.\n      1. Set _lastIndex_ to AdvanceStringIndex(_S_, _lastIndex_, _fullUnicode_).\n    1. Else,\n      1. Assert: _r_ is a Record[MatchState].\n      1. Set _matchSucceeded_ to *true*.\n  1. Let _e_ be _r_.[[EndIndex]].\n  1. If _fullUnicode_ is *true*, set _e_ to GetStringIndex(_S_, _e_).\n  1. If _global_ is *true* or _sticky_ is *true*, then\n    1. Perform ? Set(_R_, *\"lastIndex\"*, 𝔽(_e_), *true*).\n  1. Let _n_ be the number of elements in _r_.[[Captures]].\n  1. Assert: _n_ = _R_.[[RegExpRecord]].[[CapturingGroupsCount]].\n  1. Assert: _n_ < 2<sup>32</sup> - 1.\n  1. Let _A_ be ! ArrayCreate(_n_ + 1).\n  1. Assert: The mathematical value of _A_'s *\"length\"* property is _n_ + 1..\n  1. Perform ! CreateDataPropertyOrThrow(_A_, *\"index\"*, 𝔽(_lastIndex_)).\n  1. Perform ! CreateDataPropertyOrThrow(_A_, *\"input\"*, _S_).\n  1. Let _match_ be Match Record { [[StartIndex]]: _lastIndex_, [[EndIndex]]: _e_ }.\n  1. Let _indices_ be « ».\n  1. Let _groupNames_ be « ».\n  1. Append _match_ to _indices_.\n  1. Let _matchedSubstr_ be GetMatchString(_S_, _match_).\n  1. Perform ! CreateDataPropertyOrThrow(_A_, *\"0\"*, _matchedSubstr_).\n  1. If _R_ contains any |GroupName|, then\n    1. Let _groups_ be OrdinaryObjectCreate(*null*).\n    1. Let _hasGroups_ be *true*.\n  1. Else,\n    1. Let _groups_ be *undefined*.\n    1. Let _hasGroups_ be *false*.\n  1. Perform ! CreateDataPropertyOrThrow(_A_, *\"groups\"*, _groups_).\n  1. For each integer _i_ such that 1 ≤ _i_ ≤ _n_, in ascending order, do\n    1. Let _captureI_ be _i_<sup>th</sup> element of _r_.[[Captures]].\n    1. If _captureI_ is *undefined*, then\n      1. Let _capturedValue_ be *undefined*.\n      1. Append *undefined* to _indices_.\n    1. Else,\n      1. Let _captureStart_ be _captureI_.[[StartIndex]].\n      1. Let _captureEnd_ be _captureI_.[[EndIndex]].\n      1. If _fullUnicode_ is *true*, then\n        1. Set _captureStart_ to GetStringIndex(_S_, _captureStart_).\n        1. Set _captureEnd_ to GetStringIndex(_S_, _captureEnd_).\n      1. Let _capture_ be Match Record { [[StartIndex]]: _captureStart_, [[EndIndex]]: _captureEnd_ }.\n      1. Let _capturedValue_ be GetMatchString(_S_, _capture_).\n      1. Append _capture_ to _indices_.\n    1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_i_)), _capturedValue_).\n    1. If the _i_<sup>th</sup> capture of _R_ was defined with a |GroupName|, then\n      1. Let _s_ be the CapturingGroupName of that |GroupName|.\n      1. Perform ! CreateDataPropertyOrThrow(_groups_, _s_, _capturedValue_).\n      1. Append _s_ to _groupNames_.\n    1. Else,\n      1. Append *undefined* to _groupNames_.\n  1. If _hasIndices_ is *true*, then\n    1. Let _indicesArray_ be MakeMatchIndicesIndexPairArray(_S_, _indices_, _groupNames_, _hasGroups_).\n    1. Perform ! CreateDataPropertyOrThrow(_A_, *\"indices\"*, _indicesArray_).\n  1. Return _A_.","code":"\n          1. Let _length_ be the length of _S_.\n          1. Let _lastIndex_ be ℝ(? ToLength(? Get(_R_, *\"lastIndex\"*))).\n          1. Let _flags_ be _R_.[[OriginalFlags]].\n          1. If _flags_ contains *\"g\"*, let _global_ be *true*; else let _global_ be *false*.\n          1. If _flags_ contains *\"y\"*, let _sticky_ be *true*; else let _sticky_ be *false*.\n          1. If _flags_ contains *\"d\"*, let _hasIndices_ be *true*; else let _hasIndices_ be *false*.\n          1. If _global_ is *false* and _sticky_ is *false*, set _lastIndex_ to 0.\n          1. Let _matcher_ be _R_.[[RegExpMatcher]].\n          1. If _flags_ contains *\"u\"* or _flags_ contains *\"v\"*, let _fullUnicode_ be *true*; else let _fullUnicode_ be *false*.\n          1. Let _matchSucceeded_ be *false*.\n          1. If _fullUnicode_ is *true*, let _input_ be StringToCodePoints(_S_). Otherwise, let _input_ be a List whose elements are the code units that are the elements of _S_.\n          1. NOTE: Each element of _input_ is considered to be a character.\n          1. Repeat, while _matchSucceeded_ is *false*,\n            1. If _lastIndex_ > _length_, then\n              1. If _global_ is *true* or _sticky_ is *true*, then\n                1. Perform ? Set(_R_, *\"lastIndex\"*, *+0*<sub>𝔽</sub>, *true*).\n              1. Return *null*.\n            1. Let _inputIndex_ be the index into _input_ of the character that was obtained from element _lastIndex_ of _S_.\n            1. Let _r_ be _matcher_(_input_, _inputIndex_).\n            1. If _r_ is ~failure~, then\n              1. If _sticky_ is *true*, then\n                1. Perform ? Set(_R_, *\"lastIndex\"*, *+0*<sub>𝔽</sub>, *true*).\n                1. Return *null*.\n              1. Set _lastIndex_ to AdvanceStringIndex(_S_, _lastIndex_, _fullUnicode_).\n            1. Else,\n              1. Assert: _r_ is a MatchState.\n              1. Set _matchSucceeded_ to *true*.\n          1. Let _e_ be _r_.[[EndIndex]].\n          1. If _fullUnicode_ is *true*, set _e_ to GetStringIndex(_S_, _e_).\n          1. If _global_ is *true* or _sticky_ is *true*, then\n            1. Perform ? Set(_R_, *\"lastIndex\"*, 𝔽(_e_), *true*).\n          1. Let _n_ be the number of elements in _r_.[[Captures]].\n          1. Assert: _n_ = _R_.[[RegExpRecord]].[[CapturingGroupsCount]].\n          1. Assert: _n_ < 2<sup>32</sup> - 1.\n          1. Let _A_ be ! ArrayCreate(_n_ + 1).\n          1. Assert: The mathematical value of _A_'s *\"length\"* property is _n_ + 1.\n          1. Perform ! CreateDataPropertyOrThrow(_A_, *\"index\"*, 𝔽(_lastIndex_)).\n          1. Perform ! CreateDataPropertyOrThrow(_A_, *\"input\"*, _S_).\n          1. Let _match_ be the Match Record { [[StartIndex]]: _lastIndex_, [[EndIndex]]: _e_ }.\n          1. Let _indices_ be a new empty List.\n          1. Let _groupNames_ be a new empty List.\n          1. Append _match_ to _indices_.\n          1. Let _matchedSubstr_ be GetMatchString(_S_, _match_).\n          1. Perform ! CreateDataPropertyOrThrow(_A_, *\"0\"*, _matchedSubstr_).\n          1. If _R_ contains any |GroupName|, then\n            1. Let _groups_ be OrdinaryObjectCreate(*null*).\n            1. Let _hasGroups_ be *true*.\n          1. Else,\n            1. Let _groups_ be *undefined*.\n            1. Let _hasGroups_ be *false*.\n          1. Perform ! CreateDataPropertyOrThrow(_A_, *\"groups\"*, _groups_).\n          1. For each integer _i_ such that 1 ≤ _i_ ≤ _n_, in ascending order, do\n            1. Let _captureI_ be _i_<sup>th</sup> element of _r_.[[Captures]].\n            1. If _captureI_ is *undefined*, then\n              1. Let _capturedValue_ be *undefined*.\n              1. Append *undefined* to _indices_.\n            1. Else,\n              1. Let _captureStart_ be _captureI_.[[StartIndex]].\n              1. Let _captureEnd_ be _captureI_.[[EndIndex]].\n              1. If _fullUnicode_ is *true*, then\n                1. Set _captureStart_ to GetStringIndex(_S_, _captureStart_).\n                1. Set _captureEnd_ to GetStringIndex(_S_, _captureEnd_).\n              1. Let _capture_ be the Match Record { [[StartIndex]]: _captureStart_, [[EndIndex]]: _captureEnd_ }.\n              1. Let _capturedValue_ be GetMatchString(_S_, _capture_).\n              1. Append _capture_ to _indices_.\n            1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_i_)), _capturedValue_).\n            1. If the _i_<sup>th</sup> capture of _R_ was defined with a |GroupName|, then\n              1. Let _s_ be the CapturingGroupName of that |GroupName|.\n              1. Perform ! CreateDataPropertyOrThrow(_groups_, _s_, _capturedValue_).\n              1. Append _s_ to _groupNames_.\n            1. Else,\n              1. Append *undefined* to _groupNames_.\n          1. If _hasIndices_ is *true*, then\n            1. Let _indicesArray_ be MakeMatchIndicesIndexPairArray(_S_, _indices_, _groupNames_, _hasGroups_).\n            1. Perform ! CreateDataPropertyOrThrow(_A_, *\"indices\"*, _indicesArray_).\n          1. Return _A_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AdvanceStringIndex","params":[{"name":"S","ty":"String","kind":{"Normal":{}}},{"name":"index","ty":"NonNegInt","kind":{"Normal":{}}},{"name":"unicode","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Int"}},"body":"\n  1. Assert: _index_ ≤ 2<sup>53</sup> - 1.\n  1. If _unicode_ is *false*, return _index_ + 1.\n  1. Let _length_ be the length of _S_.\n  1. If _index_ + 1 ≥ _length_, return _index_ + 1.\n  1. Let _cp_ be CodePointAt(_S_, _index_).\n  1. Return _index_ + _cp_.[[CodeUnitCount]].","code":"\n          1. Assert: _index_ ≤ 2<sup>53</sup> - 1.\n          1. If _unicode_ is *false*, return _index_ + 1.\n          1. Let _length_ be the length of _S_.\n          1. If _index_ + 1 ≥ _length_, return _index_ + 1.\n          1. Let _cp_ be CodePointAt(_S_, _index_).\n          1. Return _index_ + _cp_.[[CodeUnitCount]].\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetStringIndex","params":[{"name":"S","ty":"String","kind":{"Normal":{}}},{"name":"codePointIndex","ty":"NonNegInt","kind":{"Normal":{}}}],"retTy":"NonNegInt"}},"body":"\n  1. If _S_ is *\"\"*, return 0.\n  1. Let _len_ be the length of _S_.\n  1. Let _codeUnitCount_ be 0.\n  1. Let _codePointCount_ be 0.\n  1. Repeat, while _codeUnitCount_ < _len_,\n    1. If _codePointCount_ = _codePointIndex_, return _codeUnitCount_.\n    1. Let _cp_ be CodePointAt(_S_, _codeUnitCount_).\n    1. Set _codeUnitCount_ to _codeUnitCount_ + _cp_.[[CodeUnitCount]].\n    1. Set _codePointCount_ to _codePointCount_ + 1.\n  1. Return _len_.","code":"\n          1. If _S_ is the empty String, return 0.\n          1. Let _len_ be the length of _S_.\n          1. Let _codeUnitCount_ be 0.\n          1. Let _codePointCount_ be 0.\n          1. Repeat, while _codeUnitCount_ < _len_,\n            1. If _codePointCount_ = _codePointIndex_, return _codeUnitCount_.\n            1. Let _cp_ be CodePointAt(_S_, _codeUnitCount_).\n            1. Set _codeUnitCount_ to _codeUnitCount_ + _cp_.[[CodeUnitCount]].\n            1. Set _codePointCount_ to _codePointCount_ + 1.\n          1. Return _len_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetMatchString","params":[{"name":"S","ty":"String","kind":{"Normal":{}}},{"name":"match","ty":"Record[MatchRecord]","kind":{"Normal":{}}}],"retTy":"String"}},"body":"\n  1. Assert: _match_.[[StartIndex]] ≤ _match_.[[EndIndex]] ≤ the length of _S_..\n  1. Return the substring of _S_ from _match_.[[StartIndex]] to _match_.[[EndIndex]].","code":"\n          1. Assert: _match_.[[StartIndex]] ≤ _match_.[[EndIndex]] ≤ the length of _S_.\n          1. Return the substring of _S_ from _match_.[[StartIndex]] to _match_.[[EndIndex]].\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetMatchIndexPair","params":[{"name":"S","ty":"String","kind":{"Normal":{}}},{"name":"match","ty":"Record[MatchRecord]","kind":{"Normal":{}}}],"retTy":"Record[Array]"}},"body":"\n  1. Assert: _match_.[[StartIndex]] ≤ _match_.[[EndIndex]] ≤ the length of _S_..\n  1. Return CreateArrayFromList(« 𝔽(_match_.[[StartIndex]]), 𝔽(_match_.[[EndIndex]]) »).","code":"\n          1. Assert: _match_.[[StartIndex]] ≤ _match_.[[EndIndex]] ≤ the length of _S_.\n          1. Return CreateArrayFromList(« 𝔽(_match_.[[StartIndex]]), 𝔽(_match_.[[EndIndex]]) »).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"MakeMatchIndicesIndexPairArray","params":[{"name":"S","ty":"String","kind":{"Normal":{}}},{"name":"indices","ty":"List[Record[MatchRecord] | Undefined]","kind":{"Normal":{}}},{"name":"groupNames","ty":"List[String | Undefined]","kind":{"Normal":{}}},{"name":"hasGroups","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Record[Array]"}},"body":"\n  1. Let _n_ be the number of elements in _indices_.\n  1. Assert: _n_ < 2<sup>32</sup> - 1.\n  1. Assert: _groupNames_ has _n_ - 1 elements..\n  1. NOTE: The _groupNames_ List contains elements aligned with the _indices_ List starting at _indices_[1].\n  1. Let _A_ be ! ArrayCreate(_n_).\n  1. If _hasGroups_ is *true*, then\n    1. Let _groups_ be OrdinaryObjectCreate(*null*).\n  1. Else,\n    1. Let _groups_ be *undefined*.\n  1. Perform ! CreateDataPropertyOrThrow(_A_, *\"groups\"*, _groups_).\n  1. For each integer _i_ such that 0 ≤ _i_ ≤ the difference _n_ minus 1, in ascending order, do\n    1. Let _matchIndices_ be _indices_[_i_].\n    1. If _matchIndices_ is not *undefined*, then\n      1. Let _matchIndexPair_ be GetMatchIndexPair(_S_, _matchIndices_).\n    1. Else,\n      1. Let _matchIndexPair_ be *undefined*.\n    1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_i_)), _matchIndexPair_).\n    1. If _i_ > 0 and _groupNames_[_i_ - 1] is not *undefined*, then\n      1. Assert: _groups_ is not *undefined*.\n      1. Perform ! CreateDataPropertyOrThrow(_groups_, _groupNames_[_i_ - 1], _matchIndexPair_).\n  1. Return _A_.","code":"\n          1. Let _n_ be the number of elements in _indices_.\n          1. Assert: _n_ < 2<sup>32</sup> - 1.\n          1. Assert: _groupNames_ has _n_ - 1 elements.\n          1. NOTE: The _groupNames_ List contains elements aligned with the _indices_ List starting at _indices_[1].\n          1. Let _A_ be ! ArrayCreate(_n_).\n          1. If _hasGroups_ is *true*, then\n            1. Let _groups_ be OrdinaryObjectCreate(*null*).\n          1. Else,\n            1. Let _groups_ be *undefined*.\n          1. Perform ! CreateDataPropertyOrThrow(_A_, *\"groups\"*, _groups_).\n          1. For each integer _i_ such that 0 ≤ _i_ < _n_, in ascending order, do\n            1. Let _matchIndices_ be _indices_[_i_].\n            1. If _matchIndices_ is not *undefined*, then\n              1. Let _matchIndexPair_ be GetMatchIndexPair(_S_, _matchIndices_).\n            1. Else,\n              1. Let _matchIndexPair_ be *undefined*.\n            1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_i_)), _matchIndexPair_).\n            1. If _i_ > 0 and _groupNames_[_i_ - 1] is not *undefined*, then\n              1. Assert: _groups_ is not *undefined*.\n              1. Perform ! CreateDataPropertyOrThrow(_groups_, _groupNames_[_i_ - 1], _matchIndexPair_).\n          1. Return _A_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CreateRegExpStringIterator","params":[{"name":"R","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"S","ty":"String","kind":{"Normal":{}}},{"name":"global","ty":"Boolean","kind":{"Normal":{}}},{"name":"fullUnicode","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Record[Generator]"}},"body":"\n  1. Let _closure_ be a new Abstract Closure with no parameters that captures _R_, _S_, _global_, and _fullUnicode_ and performs the following steps when called:\n    1. Repeat, \n      1. Let _match_ be ? RegExpExec(_R_, _S_).\n      1. If _match_ is *null*, return *undefined*.\n      1. If _global_ is *false*, then\n        1. Perform ? GeneratorYield(CreateIterResultObject(_match_, *false*)).\n        1. Return *undefined*.\n      1. Let _matchStr_ be ? ToString(? Get(_match_, *\"0\"*)).\n      1. If _matchStr_ is *\"\"*, then\n        1. Let _thisIndex_ be ℝ(? ToLength(? Get(_R_, *\"lastIndex\"*))).\n        1. Let _nextIndex_ be AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_).\n        1. Perform ? Set(_R_, *\"lastIndex\"*, 𝔽(_nextIndex_), *true*).\n      1. Perform ? GeneratorYield(CreateIterResultObject(_match_, *false*)).\n  1. Return CreateIteratorFromClosure(_closure_, *\"%RegExpStringIteratorPrototype%\"*, %RegExpStringIteratorPrototype%).","code":"\n          1. Let _closure_ be a new Abstract Closure with no parameters that captures _R_, _S_, _global_, and _fullUnicode_ and performs the following steps when called:\n            1. Repeat,\n              1. Let _match_ be ? RegExpExec(_R_, _S_).\n              1. If _match_ is *null*, return *undefined*.\n              1. If _global_ is *false*, then\n                1. Perform ? GeneratorYield(CreateIterResultObject(_match_, *false*)).\n                1. Return *undefined*.\n              1. Let _matchStr_ be ? ToString(? Get(_match_, *\"0\"*)).\n              1. If _matchStr_ is the empty String, then\n                1. Let _thisIndex_ be ℝ(? ToLength(? Get(_R_, *\"lastIndex\"*))).\n                1. Let _nextIndex_ be AdvanceStringIndex(_S_, _thisIndex_, _fullUnicode_).\n                1. Perform ? Set(_R_, *\"lastIndex\"*, 𝔽(_nextIndex_), *true*).\n              1. Perform ? GeneratorYield(CreateIterResultObject(_match_, *false*)).\n          1. Return CreateIteratorFromClosure(_closure_, *\"%RegExpStringIteratorPrototype%\"*, %RegExpStringIteratorPrototype%).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"RegExpStringIteratorPrototype"}},"name":"next"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Return ? GeneratorResume(*this* value, ~empty~, *\"%RegExpStringIteratorPrototype%\"*).","code":"\n            1. Return ? GeneratorResume(*this* value, ~empty~, *\"%RegExpStringIteratorPrototype%\"*).\n          "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"Array"}},"params":[{"name":"values","ty":"Unknown","kind":{"Variadic":{}}}],"retTy":"Unknown"}},"body":"\n  1. If NewTarget is *undefined*, let _newTarget_ be the active function object.\n  1. Else, let _newTarget_ be NewTarget.\n  1. Let _proto_ be ? GetPrototypeFromConstructor(_newTarget_, *\"%Array.prototype%\"*).\n  1. Let _numberOfArgs_ be the number of elements in _values_.\n  1. If _numberOfArgs_ = 0, then\n    1. Return ! ArrayCreate(0, _proto_).\n  1. Else if _numberOfArgs_ = 1, then\n    1. Let _len_ be _values_[0].\n    1. Let _array_ be ! ArrayCreate(0, _proto_).\n    1. If _len_ is not a Number, then\n      1. Perform ! CreateDataPropertyOrThrow(_array_, *\"0\"*, _len_).\n      1. Let _intLen_ be *1*<sub>𝔽</sub>.\n    1. Else,\n      1. Let _intLen_ be ! ToUint32(_len_).\n      1. If SameValueZero(_intLen_, _len_) is *false*, throw a *RangeError* exception.\n    1. Perform ! Set(_array_, *\"length\"*, _intLen_, *true*).\n    1. Return _array_.\n  1. Else,\n    1. Assert: _numberOfArgs_ ≥ 2.\n    1. Let _array_ be ? ArrayCreate(_numberOfArgs_, _proto_).\n    1. Let _k_ be 0.\n    1. Repeat, while _k_ < _numberOfArgs_,\n      1. Let _Pk_ be ! ToString(𝔽(_k_)).\n      1. Let _itemK_ be _values_[_k_].\n      1. Perform ! CreateDataPropertyOrThrow(_array_, _Pk_, _itemK_).\n      1. Set _k_ to _k_ + 1.\n    1. Assert: The mathematical value of _array_'s *\"length\"* property is _numberOfArgs_..\n    1. Return _array_.","code":"\n          1. If NewTarget is *undefined*, let _newTarget_ be the active function object; else let _newTarget_ be NewTarget.\n          1. Let _proto_ be ? GetPrototypeFromConstructor(_newTarget_, *\"%Array.prototype%\"*).\n          1. Let _numberOfArgs_ be the number of elements in _values_.\n          1. If _numberOfArgs_ = 0, then\n            1. Return ! ArrayCreate(0, _proto_).\n          1. Else if _numberOfArgs_ = 1, then\n            1. Let _len_ be _values_[0].\n            1. Let _array_ be ! ArrayCreate(0, _proto_).\n            1. If _len_ is not a Number, then\n              1. Perform ! CreateDataPropertyOrThrow(_array_, *\"0\"*, _len_).\n              1. Let _intLen_ be *1*<sub>𝔽</sub>.\n            1. Else,\n              1. Let _intLen_ be ! ToUint32(_len_).\n              1. If SameValueZero(_intLen_, _len_) is *false*, throw a *RangeError* exception.\n            1. Perform ! Set(_array_, *\"length\"*, _intLen_, *true*).\n            1. Return _array_.\n          1. Else,\n            1. Assert: _numberOfArgs_ ≥ 2.\n            1. Let _array_ be ? ArrayCreate(_numberOfArgs_, _proto_).\n            1. Let _k_ be 0.\n            1. Repeat, while _k_ < _numberOfArgs_,\n              1. Let _Pk_ be ! ToString(𝔽(_k_)).\n              1. Let _itemK_ be _values_[_k_].\n              1. Perform ! CreateDataPropertyOrThrow(_array_, _Pk_, _itemK_).\n              1. Set _k_ to _k_ + 1.\n            1. Assert: The mathematical value of _array_'s *\"length\"* property is _numberOfArgs_.\n            1. Return _array_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"from"}},"params":[{"name":"items","ty":"Unknown","kind":{"Normal":{}}},{"name":"mapfn","ty":"Unknown","kind":{"Optional":{}}},{"name":"thisArg","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _C_ be *this* value.\n  1. If _mapfn_ is *undefined*, then\n    1. Let _mapping_ be *false*.\n  1. Else,\n    1. If IsCallable(_mapfn_) is *false*, throw a *TypeError* exception.\n    1. Let _mapping_ be *true*.\n  1. Let _usingIterator_ be ? GetMethod(_items_, @@iterator).\n  1. If _usingIterator_ is not *undefined*, then\n    1. If IsConstructor(_C_) is *true*, then\n      1. Let _A_ be ? Construct(_C_).\n    1. Else,\n      1. Let _A_ be ! ArrayCreate(0).\n    1. Let _iteratorRecord_ be ? GetIteratorFromMethod(_items_, _usingIterator_).\n    1. Let _k_ be 0.\n    1. Repeat, \n      1. If _k_ ≥ 2<sup>53</sup> - 1, then\n        1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).\n        1. Return ? IteratorClose(_iteratorRecord_, _error_).\n      1. Let _Pk_ be ! ToString(𝔽(_k_)).\n      1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n      1. If _next_ is ~done~, then\n        1. Perform ? Set(_A_, *\"length\"*, 𝔽(_k_), *true*).\n        1. Return _A_.\n      1. If _mapping_ is *true*, then\n        1. Let _mappedValue_ be Completion(Call(_mapfn_, _thisArg_, « _next_, 𝔽(_k_) »)).\n        1. Perform IfAbruptCloseIterator(_mappedValue_, _iteratorRecord_).\n      1. Else,\n        1. Let _mappedValue_ be _next_.\n      1. Let _defineStatus_ be Completion(CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_)).\n      1. Perform IfAbruptCloseIterator(_defineStatus_, _iteratorRecord_).\n      1. Set _k_ to _k_ + 1.\n  1. NOTE: _items_ is not an Iterable so assume it is an array-like object.\n  1. Let _arrayLike_ be ! ToObject(_items_).\n  1. Let _len_ be ? LengthOfArrayLike(_arrayLike_).\n  1. If IsConstructor(_C_) is *true*, then\n    1. Let _A_ be ? Construct(_C_, « 𝔽(_len_) »).\n  1. Else,\n    1. Let _A_ be ? ArrayCreate(_len_).\n  1. Let _k_ be 0.\n  1. Repeat, while _k_ < _len_,\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. Let _kValue_ be ? Get(_arrayLike_, _Pk_).\n    1. If _mapping_ is *true*, then\n      1. Let _mappedValue_ be ? Call(_mapfn_, _thisArg_, « _kValue_, 𝔽(_k_) »).\n    1. Else,\n      1. Let _mappedValue_ be _kValue_.\n    1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_).\n    1. Set _k_ to _k_ + 1.\n  1. Perform ? Set(_A_, *\"length\"*, 𝔽(_len_), *true*).\n  1. Return _A_.","code":"\n          1. Let _C_ be the *this* value.\n          1. If _mapfn_ is *undefined*, then\n            1. Let _mapping_ be *false*.\n          1. Else,\n            1. If IsCallable(_mapfn_) is *false*, throw a *TypeError* exception.\n            1. Let _mapping_ be *true*.\n          1. Let _usingIterator_ be ? GetMethod(_items_, @@iterator).\n          1. If _usingIterator_ is not *undefined*, then\n            1. If IsConstructor(_C_) is *true*, then\n              1. Let _A_ be ? Construct(_C_).\n            1. Else,\n              1. Let _A_ be ! ArrayCreate(0).\n            1. Let _iteratorRecord_ be ? GetIteratorFromMethod(_items_, _usingIterator_).\n            1. Let _k_ be 0.\n            1. Repeat,\n              1. If _k_ ≥ 2<sup>53</sup> - 1, then\n                1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).\n                1. Return ? IteratorClose(_iteratorRecord_, _error_).\n              1. Let _Pk_ be ! ToString(𝔽(_k_)).\n              1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n              1. If _next_ is ~done~, then\n                1. Perform ? Set(_A_, *\"length\"*, 𝔽(_k_), *true*).\n                1. Return _A_.\n              1. If _mapping_ is *true*, then\n                1. Let _mappedValue_ be Completion(Call(_mapfn_, _thisArg_, « _next_, 𝔽(_k_) »)).\n                1. IfAbruptCloseIterator(_mappedValue_, _iteratorRecord_).\n              1. Else,\n                1. Let _mappedValue_ be _next_.\n              1. Let _defineStatus_ be Completion(CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_)).\n              1. IfAbruptCloseIterator(_defineStatus_, _iteratorRecord_).\n              1. Set _k_ to _k_ + 1.\n          1. NOTE: _items_ is not an Iterable so assume it is an array-like object.\n          1. Let _arrayLike_ be ! ToObject(_items_).\n          1. Let _len_ be ? LengthOfArrayLike(_arrayLike_).\n          1. If IsConstructor(_C_) is *true*, then\n            1. Let _A_ be ? Construct(_C_, « 𝔽(_len_) »).\n          1. Else,\n            1. Let _A_ be ? ArrayCreate(_len_).\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kValue_ be ? Get(_arrayLike_, _Pk_).\n            1. If _mapping_ is *true*, then\n              1. Let _mappedValue_ be ? Call(_mapfn_, _thisArg_, « _kValue_, 𝔽(_k_) »).\n            1. Else,\n              1. Let _mappedValue_ be _kValue_.\n            1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_).\n            1. Set _k_ to _k_ + 1.\n          1. Perform ? Set(_A_, *\"length\"*, 𝔽(_len_), *true*).\n          1. Return _A_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"isArray"}},"params":[{"name":"arg","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Return ? IsArray(_arg_).","code":"\n          1. Return ? IsArray(_arg_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"of"}},"params":[{"name":"items","ty":"Unknown","kind":{"Variadic":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _len_ be the number of elements in _items_.\n  1. Let _lenNumber_ be 𝔽(_len_).\n  1. Let _C_ be *this* value.\n  1. If IsConstructor(_C_) is *true*, then\n    1. Let _A_ be ? Construct(_C_, « _lenNumber_ »).\n  1. Else,\n    1. Let _A_ be ? ArrayCreate(_len_).\n  1. Let _k_ be 0.\n  1. Repeat, while _k_ < _len_,\n    1. Let _kValue_ be _items_[_k_].\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _kValue_).\n    1. Set _k_ to _k_ + 1.\n  1. Perform ? Set(_A_, *\"length\"*, _lenNumber_, *true*).\n  1. Return _A_.","code":"\n          1. Let _len_ be the number of elements in _items_.\n          1. Let _lenNumber_ be 𝔽(_len_).\n          1. Let _C_ be the *this* value.\n          1. If IsConstructor(_C_) is *true*, then\n            1. Let _A_ be ? Construct(_C_, « _lenNumber_ »).\n          1. Else,\n            1. Let _A_ be ? ArrayCreate(_len_).\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _kValue_ be _items_[_k_].\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _kValue_).\n            1. Set _k_ to _k_ + 1.\n          1. Perform ? Set(_A_, *\"length\"*, _lenNumber_, *true*).\n          1. Return _A_.\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"SymbolAccess":{"base":{"Base":{"name":"Array"}},"symbol":"species"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Return *this* value.","code":"\n          1. Return the *this* value.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"at"}},"params":[{"name":"index","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_O_).\n  1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).\n  1. If _relativeIndex_ ≥ 0, then\n    1. Let _k_ be _relativeIndex_.\n  1. Else,\n    1. Let _k_ be _len_ + _relativeIndex_.\n  1. If _k_ < 0 or _k_ ≥ _len_, return *undefined*.\n  1. Return ? Get(_O_, ! ToString(𝔽(_k_))).","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).\n          1. If _relativeIndex_ ≥ 0, then\n            1. Let _k_ be _relativeIndex_.\n          1. Else,\n            1. Let _k_ be _len_ + _relativeIndex_.\n          1. If _k_ < 0 or _k_ ≥ _len_, return *undefined*.\n          1. Return ? Get(_O_, ! ToString(𝔽(_k_))).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"concat"}},"params":[{"name":"items","ty":"Unknown","kind":{"Variadic":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _A_ be ? ArraySpeciesCreate(_O_, 0).\n  1. Let _n_ be 0.\n  1. Prepend _O_ to _items_.\n  1. For each _E_ of _items_, do\n    1. Let _spreadable_ be ? IsConcatSpreadable(_E_).\n    1. If _spreadable_ is *true*, then\n      1. Let _len_ be ? LengthOfArrayLike(_E_).\n      1. If _n_ + _len_ > 2<sup>53</sup> - 1, throw a *TypeError* exception.\n      1. Let _k_ be 0.\n      1. Repeat, while _k_ < _len_,\n        1. Let _Pk_ be ! ToString(𝔽(_k_)).\n        1. Let _exists_ be ? HasProperty(_E_, _Pk_).\n        1. If _exists_ is *true*, then\n          1. Let _subElement_ be ? Get(_E_, _Pk_).\n          1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _subElement_).\n        1. Set _n_ to _n_ + 1.\n        1. Set _k_ to _k_ + 1.\n    1. Else,\n      1. NOTE: _E_ is added as a single item rather than spread.\n      1. If _n_ ≥ 2<sup>53</sup> - 1, throw a *TypeError* exception.\n      1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _E_).\n      1. Set _n_ to _n_ + 1.\n  1. [id=\"step-array-proto-concat-set-length\"] Perform ? Set(_A_, *\"length\"*, 𝔽(_n_), *true*).\n  1. Return _A_.","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _A_ be ? ArraySpeciesCreate(_O_, 0).\n          1. Let _n_ be 0.\n          1. Prepend _O_ to _items_.\n          1. For each element _E_ of _items_, do\n            1. Let _spreadable_ be ? IsConcatSpreadable(_E_).\n            1. If _spreadable_ is *true*, then\n              1. Let _len_ be ? LengthOfArrayLike(_E_).\n              1. If _n_ + _len_ > 2<sup>53</sup> - 1, throw a *TypeError* exception.\n              1. Let _k_ be 0.\n              1. Repeat, while _k_ < _len_,\n                1. Let _Pk_ be ! ToString(𝔽(_k_)).\n                1. Let _exists_ be ? HasProperty(_E_, _Pk_).\n                1. If _exists_ is *true*, then\n                  1. Let _subElement_ be ? Get(_E_, _Pk_).\n                  1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _subElement_).\n                1. Set _n_ to _n_ + 1.\n                1. Set _k_ to _k_ + 1.\n            1. Else,\n              1. NOTE: _E_ is added as a single item rather than spread.\n              1. If _n_ ≥ 2<sup>53</sup> - 1, throw a *TypeError* exception.\n              1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _E_).\n              1. Set _n_ to _n_ + 1.\n          1. [id=\"step-array-proto-concat-set-length\"] Perform ? Set(_A_, *\"length\"*, 𝔽(_n_), *true*).\n          1. Return _A_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsConcatSpreadable","params":[{"name":"O","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Boolean] | Throw"}},"body":"\n  1. If _O_ is not a Record[Object], return *false*.\n  1. Let _spreadable_ be ? Get(_O_, @@isConcatSpreadable).\n  1. If _spreadable_ is not *undefined*, return ToBoolean(_spreadable_).\n  1. Return ? IsArray(_O_).","code":"\n            1. If _O_ is not an Object, return *false*.\n            1. Let _spreadable_ be ? Get(_O_, @@isConcatSpreadable).\n            1. If _spreadable_ is not *undefined*, return ToBoolean(_spreadable_).\n            1. Return ? IsArray(_O_).\n          "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"copyWithin"}},"params":[{"name":"target","ty":"Unknown","kind":{"Normal":{}}},{"name":"start","ty":"Unknown","kind":{"Normal":{}}},{"name":"end","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_O_).\n  1. Let _relativeTarget_ be ? ToIntegerOrInfinity(_target_).\n  1. If _relativeTarget_ = -∞, let _to_ be 0.\n  1. Else if _relativeTarget_ < 0, let _to_ be max(_len_ + _relativeTarget_, 0).\n  1. Else, let _to_ be min(_relativeTarget_, _len_).\n  1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n  1. If _relativeStart_ = -∞, let _from_ be 0.\n  1. Else if _relativeStart_ < 0, let _from_ be max(_len_ + _relativeStart_, 0).\n  1. Else, let _from_ be min(_relativeStart_, _len_).\n  1. If _end_ is *undefined*, let _relativeEnd_ be _len_.\n  1. Else, let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).\n  1. If _relativeEnd_ = -∞, let _final_ be 0.\n  1. Else if _relativeEnd_ < 0, let _final_ be max(_len_ + _relativeEnd_, 0).\n  1. Else, let _final_ be min(_relativeEnd_, _len_).\n  1. Let _count_ be min(_final_ - _from_, _len_ - _to_).\n  1. If _from_ < _to_ and _to_ < _from_ + _count_, then\n    1. Let _direction_ be -1.\n    1. Set _from_ to _from_ + _count_ - 1.\n    1. Set _to_ to _to_ + _count_ - 1.\n  1. Else,\n    1. Let _direction_ be 1.\n  1. Repeat, while _count_ > 0,\n    1. Let _fromKey_ be ! ToString(𝔽(_from_)).\n    1. Let _toKey_ be ! ToString(𝔽(_to_)).\n    1. Let _fromPresent_ be ? HasProperty(_O_, _fromKey_).\n    1. If _fromPresent_ is *true*, then\n      1. Let _fromVal_ be ? Get(_O_, _fromKey_).\n      1. Perform ? Set(_O_, _toKey_, _fromVal_, *true*).\n    1. Else,\n      1. Assert: _fromPresent_ is *false*.\n      1. Perform ? DeletePropertyOrThrow(_O_, _toKey_).\n    1. Set _from_ to _from_ + _direction_.\n    1. Set _to_ to _to_ + _direction_.\n    1. Set _count_ to _count_ - 1.\n  1. Return _O_.","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _relativeTarget_ be ? ToIntegerOrInfinity(_target_).\n          1. If _relativeTarget_ = -∞, let _to_ be 0.\n          1. Else if _relativeTarget_ < 0, let _to_ be max(_len_ + _relativeTarget_, 0).\n          1. Else, let _to_ be min(_relativeTarget_, _len_).\n          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n          1. If _relativeStart_ = -∞, let _from_ be 0.\n          1. Else if _relativeStart_ < 0, let _from_ be max(_len_ + _relativeStart_, 0).\n          1. Else, let _from_ be min(_relativeStart_, _len_).\n          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).\n          1. If _relativeEnd_ = -∞, let _final_ be 0.\n          1. Else if _relativeEnd_ < 0, let _final_ be max(_len_ + _relativeEnd_, 0).\n          1. Else, let _final_ be min(_relativeEnd_, _len_).\n          1. Let _count_ be min(_final_ - _from_, _len_ - _to_).\n          1. If _from_ < _to_ and _to_ < _from_ + _count_, then\n            1. Let _direction_ be -1.\n            1. Set _from_ to _from_ + _count_ - 1.\n            1. Set _to_ to _to_ + _count_ - 1.\n          1. Else,\n            1. Let _direction_ be 1.\n          1. Repeat, while _count_ > 0,\n            1. Let _fromKey_ be ! ToString(𝔽(_from_)).\n            1. Let _toKey_ be ! ToString(𝔽(_to_)).\n            1. Let _fromPresent_ be ? HasProperty(_O_, _fromKey_).\n            1. If _fromPresent_ is *true*, then\n              1. Let _fromVal_ be ? Get(_O_, _fromKey_).\n              1. Perform ? Set(_O_, _toKey_, _fromVal_, *true*).\n            1. Else,\n              1. Assert: _fromPresent_ is *false*.\n              1. Perform ? DeletePropertyOrThrow(_O_, _toKey_).\n            1. Set _from_ to _from_ + _direction_.\n            1. Set _to_ to _to_ + _direction_.\n            1. Set _count_ to _count_ - 1.\n          1. Return _O_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"entries"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Return CreateArrayIterator(_O_, ~key+value~).","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Return CreateArrayIterator(_O_, ~key+value~).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"every"}},"params":[{"name":"callbackfn","ty":"Unknown","kind":{"Normal":{}}},{"name":"thisArg","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_O_).\n  1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n  1. Let _k_ be 0.\n  1. Repeat, while _k_ < _len_,\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).\n    1. If _kPresent_ is *true*, then\n      1. Let _kValue_ be ? Get(_O_, _Pk_).\n      1. Let _testResult_ be ToBoolean(? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).\n      1. If _testResult_ is *false*, return *false*.\n    1. Set _k_ to _k_ + 1.\n  1. Return *true*.","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).\n            1. If _kPresent_ is *true*, then\n              1. Let _kValue_ be ? Get(_O_, _Pk_).\n              1. Let _testResult_ be ToBoolean(? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).\n              1. If _testResult_ is *false*, return *false*.\n            1. Set _k_ to _k_ + 1.\n          1. Return *true*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"fill"}},"params":[{"name":"value","ty":"Unknown","kind":{"Normal":{}}},{"name":"start","ty":"Unknown","kind":{"Optional":{}}},{"name":"end","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_O_).\n  1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n  1. If _relativeStart_ = -∞, let _k_ be 0.\n  1. Else if _relativeStart_ < 0, let _k_ be max(_len_ + _relativeStart_, 0).\n  1. Else, let _k_ be min(_relativeStart_, _len_).\n  1. If _end_ is *undefined*, let _relativeEnd_ be _len_.\n  1. Else, let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).\n  1. If _relativeEnd_ = -∞, let _final_ be 0.\n  1. Else if _relativeEnd_ < 0, let _final_ be max(_len_ + _relativeEnd_, 0).\n  1. Else, let _final_ be min(_relativeEnd_, _len_).\n  1. Repeat, while _k_ < _final_,\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. Perform ? Set(_O_, _Pk_, _value_, *true*).\n    1. Set _k_ to _k_ + 1.\n  1. Return _O_.","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n          1. If _relativeStart_ = -∞, let _k_ be 0.\n          1. Else if _relativeStart_ < 0, let _k_ be max(_len_ + _relativeStart_, 0).\n          1. Else, let _k_ be min(_relativeStart_, _len_).\n          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).\n          1. If _relativeEnd_ = -∞, let _final_ be 0.\n          1. Else if _relativeEnd_ < 0, let _final_ be max(_len_ + _relativeEnd_, 0).\n          1. Else, let _final_ be min(_relativeEnd_, _len_).\n          1. Repeat, while _k_ < _final_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Perform ? Set(_O_, _Pk_, _value_, *true*).\n            1. Set _k_ to _k_ + 1.\n          1. Return _O_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"filter"}},"params":[{"name":"callbackfn","ty":"Unknown","kind":{"Normal":{}}},{"name":"thisArg","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_O_).\n  1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n  1. Let _A_ be ? ArraySpeciesCreate(_O_, 0).\n  1. Let _k_ be 0.\n  1. Let _to_ be 0.\n  1. Repeat, while _k_ < _len_,\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).\n    1. If _kPresent_ is *true*, then\n      1. Let _kValue_ be ? Get(_O_, _Pk_).\n      1. Let _selected_ be ToBoolean(? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).\n      1. If _selected_ is *true*, then\n        1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_to_)), _kValue_).\n        1. Set _to_ to _to_ + 1.\n    1. Set _k_ to _k_ + 1.\n  1. Return _A_.","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. Let _A_ be ? ArraySpeciesCreate(_O_, 0).\n          1. Let _k_ be 0.\n          1. Let _to_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).\n            1. If _kPresent_ is *true*, then\n              1. Let _kValue_ be ? Get(_O_, _Pk_).\n              1. Let _selected_ be ToBoolean(? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).\n              1. If _selected_ is *true*, then\n                1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_to_)), _kValue_).\n                1. Set _to_ to _to_ + 1.\n            1. Set _k_ to _k_ + 1.\n          1. Return _A_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"find"}},"params":[{"name":"predicate","ty":"Unknown","kind":{"Normal":{}}},{"name":"thisArg","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_O_).\n  1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_).\n  1. Return _findRec_.[[Value]].","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_).\n          1. Return _findRec_.[[Value]].\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"findIndex"}},"params":[{"name":"predicate","ty":"Unknown","kind":{"Normal":{}}},{"name":"thisArg","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_O_).\n  1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_).\n  1. Return _findRec_.[[Index]].","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_).\n          1. Return _findRec_.[[Index]].\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"findLast"}},"params":[{"name":"predicate","ty":"Unknown","kind":{"Normal":{}}},{"name":"thisArg","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_O_).\n  1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_).\n  1. Return _findRec_.[[Value]].","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_).\n          1. Return _findRec_.[[Value]].\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"findLastIndex"}},"params":[{"name":"predicate","ty":"Unknown","kind":{"Normal":{}}},{"name":"thisArg","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_O_).\n  1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_).\n  1. Return _findRec_.[[Index]].","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_).\n          1. Return _findRec_.[[Index]].\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"FindViaPredicate","params":[{"name":"O","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"len","ty":"NonNegInt","kind":{"Normal":{}}},{"name":"direction","ty":"Enum[~ascending~, ~descending~]","kind":{"Normal":{}}},{"name":"predicate","ty":"ESValue","kind":{"Normal":{}}},{"name":"thisArg","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Unknown[\"either a normal completion containing a Record with fields [[Index]] (an integral Number) and [[Value]] (an ECMAScript language value) or a throw completion\"]"}},"body":"\n  1. If IsCallable(_predicate_) is *false*, throw a *TypeError* exception.\n  1. If _direction_ is ~ascending~, then\n    1. Let _indices_ be a List of the integers in the interval from 0 (inclusive) to _len_ (exclusive), in ascendingorder.\n  1. Else,\n    1. Let _indices_ be a List of the integers in the interval from 0 (inclusive) to _len_ (exclusive), in descendingorder.\n  1. For each Int _k_ of _indices_, do\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. NOTE: If _O_ is a TypedArray, the following invocation of Get will return a normal completion.\n    1. Let _kValue_ be ? Get(_O_, _Pk_).\n    1. Let _testResult_ be ? Call(_predicate_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).\n    1. If ToBoolean(_testResult_) is *true*, return Record { [[Index]]: 𝔽(_k_), [[Value]]: _kValue_ }.\n  1. Return Record { [[Index]]: *-1*<sub>𝔽</sub>, [[Value]]: *undefined* }.","code":"\n            1. If IsCallable(_predicate_) is *false*, throw a *TypeError* exception.\n            1. If _direction_ is ~ascending~, then\n              1. Let _indices_ be a List of the integers in the interval from 0 (inclusive) to _len_ (exclusive), in ascending order.\n            1. Else,\n              1. Let _indices_ be a List of the integers in the interval from 0 (inclusive) to _len_ (exclusive), in descending order.\n            1. For each integer _k_ of _indices_, do\n              1. Let _Pk_ be ! ToString(𝔽(_k_)).\n              1. NOTE: If _O_ is a TypedArray, the following invocation of Get will return a normal completion.\n              1. Let _kValue_ be ? Get(_O_, _Pk_).\n              1. Let _testResult_ be ? Call(_predicate_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).\n              1. If ToBoolean(_testResult_) is *true*, return the Record { [[Index]]: 𝔽(_k_), [[Value]]: _kValue_ }.\n            1. Return the Record { [[Index]]: *-1*<sub>𝔽</sub>, [[Value]]: *undefined* }.\n          "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"flat"}},"params":[{"name":"depth","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _sourceLen_ be ? LengthOfArrayLike(_O_).\n  1. Let _depthNum_ be 1.\n  1. If _depth_ is not *undefined*, then\n    1. Set _depthNum_ to ? ToIntegerOrInfinity(_depth_).\n    1. If _depthNum_ < 0, set _depthNum_ to 0.\n  1. Let _A_ be ? ArraySpeciesCreate(_O_, 0).\n  1. Perform ? FlattenIntoArray(_A_, _O_, _sourceLen_, 0, _depthNum_).\n  1. Return _A_.","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _sourceLen_ be ? LengthOfArrayLike(_O_).\n          1. Let _depthNum_ be 1.\n          1. If _depth_ is not *undefined*, then\n            1. Set _depthNum_ to ? ToIntegerOrInfinity(_depth_).\n            1. If _depthNum_ < 0, set _depthNum_ to 0.\n          1. Let _A_ be ? ArraySpeciesCreate(_O_, 0).\n          1. Perform ? FlattenIntoArray(_A_, _O_, _sourceLen_, 0, _depthNum_).\n          1. Return _A_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"FlattenIntoArray","params":[{"name":"target","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"source","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"sourceLen","ty":"NonNegInt","kind":{"Normal":{}}},{"name":"start","ty":"NonNegInt","kind":{"Normal":{}}},{"name":"depth","ty":"NonNegInt | +INF","kind":{"Normal":{}}},{"name":"mapperFunction","ty":"Record[FunctionObject]","kind":{"Optional":{}}},{"name":"thisArg","ty":"ESValue","kind":{"Optional":{}}}],"retTy":"Normal[NonNegInt] | Throw"}},"body":"\n  1. Assert: If _mapperFunction_ is present, then IsCallable(_mapperFunction_) is *true*, _thisArg_ is present, and _depth_ is 1..\n  1. Let _targetIndex_ be _start_.\n  1. Let _sourceIndex_ be *+0*<sub>𝔽</sub>.\n  1. Repeat, while ℝ(_sourceIndex_) < _sourceLen_,\n    1. Let _P_ be ! ToString(_sourceIndex_).\n    1. Let _exists_ be ? HasProperty(_source_, _P_).\n    1. If _exists_ is *true*, then\n      1. Let _element_ be ? Get(_source_, _P_).\n      1. If _mapperFunction_ is present, then\n        1. Set _element_ to ? Call(_mapperFunction_, _thisArg_, « _element_, _sourceIndex_, _source_ »).\n      1. Let _shouldFlatten_ be *false*.\n      1. If _depth_ > 0, then\n        1. Set _shouldFlatten_ to ? IsArray(_element_).\n      1. If _shouldFlatten_ is *true*, then\n        1. If _depth_ = +∞, let _newDepth_ be +∞.\n        1. Else, let _newDepth_ be _depth_ - 1.\n        1. Let _elementLen_ be ? LengthOfArrayLike(_element_).\n        1. Set _targetIndex_ to ? FlattenIntoArray(_target_, _element_, _elementLen_, _targetIndex_, _newDepth_).\n      1. Else,\n        1. If _targetIndex_ ≥ 2<sup>53</sup> - 1, throw a *TypeError* exception.\n        1. Perform ? CreateDataPropertyOrThrow(_target_, ! ToString(𝔽(_targetIndex_)), _element_).\n        1. Set _targetIndex_ to _targetIndex_ + 1.\n    1. Set _sourceIndex_ to _sourceIndex_ + *1*<sub>𝔽</sub>.\n  1. Return _targetIndex_.","code":"\n            1. Assert: If _mapperFunction_ is present, then IsCallable(_mapperFunction_) is *true*, _thisArg_ is present, and _depth_ is 1.\n            1. Let _targetIndex_ be _start_.\n            1. Let _sourceIndex_ be *+0*<sub>𝔽</sub>.\n            1. Repeat, while ℝ(_sourceIndex_) < _sourceLen_,\n              1. Let _P_ be ! ToString(_sourceIndex_).\n              1. Let _exists_ be ? HasProperty(_source_, _P_).\n              1. If _exists_ is *true*, then\n                1. Let _element_ be ? Get(_source_, _P_).\n                1. If _mapperFunction_ is present, then\n                  1. Set _element_ to ? Call(_mapperFunction_, _thisArg_, « _element_, _sourceIndex_, _source_ »).\n                1. Let _shouldFlatten_ be *false*.\n                1. If _depth_ > 0, then\n                  1. Set _shouldFlatten_ to ? IsArray(_element_).\n                1. If _shouldFlatten_ is *true*, then\n                  1. If _depth_ = +∞, let _newDepth_ be +∞.\n                  1. Else, let _newDepth_ be _depth_ - 1.\n                  1. Let _elementLen_ be ? LengthOfArrayLike(_element_).\n                  1. Set _targetIndex_ to ? FlattenIntoArray(_target_, _element_, _elementLen_, _targetIndex_, _newDepth_).\n                1. Else,\n                  1. If _targetIndex_ ≥ 2<sup>53</sup> - 1, throw a *TypeError* exception.\n                  1. Perform ? CreateDataPropertyOrThrow(_target_, ! ToString(𝔽(_targetIndex_)), _element_).\n                  1. Set _targetIndex_ to _targetIndex_ + 1.\n              1. Set _sourceIndex_ to _sourceIndex_ + *1*<sub>𝔽</sub>.\n            1. Return _targetIndex_.\n          "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"flatMap"}},"params":[{"name":"mapperFunction","ty":"Unknown","kind":{"Normal":{}}},{"name":"thisArg","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _sourceLen_ be ? LengthOfArrayLike(_O_).\n  1. If IsCallable(_mapperFunction_) is *false*, throw a *TypeError* exception.\n  1. Let _A_ be ? ArraySpeciesCreate(_O_, 0).\n  1. Perform ? FlattenIntoArray(_A_, _O_, _sourceLen_, 0, 1, _mapperFunction_, _thisArg_).\n  1. Return _A_.","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _sourceLen_ be ? LengthOfArrayLike(_O_).\n          1. If IsCallable(_mapperFunction_) is *false*, throw a *TypeError* exception.\n          1. Let _A_ be ? ArraySpeciesCreate(_O_, 0).\n          1. Perform ? FlattenIntoArray(_A_, _O_, _sourceLen_, 0, 1, _mapperFunction_, _thisArg_).\n          1. Return _A_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"forEach"}},"params":[{"name":"callbackfn","ty":"Unknown","kind":{"Normal":{}}},{"name":"thisArg","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_O_).\n  1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n  1. Let _k_ be 0.\n  1. Repeat, while _k_ < _len_,\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).\n    1. If _kPresent_ is *true*, then\n      1. Let _kValue_ be ? Get(_O_, _Pk_).\n      1. Perform ? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).\n    1. Set _k_ to _k_ + 1.\n  1. Return *undefined*.","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).\n            1. If _kPresent_ is *true*, then\n              1. Let _kValue_ be ? Get(_O_, _Pk_).\n              1. Perform ? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).\n            1. Set _k_ to _k_ + 1.\n          1. Return *undefined*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"includes"}},"params":[{"name":"searchElement","ty":"Unknown","kind":{"Normal":{}}},{"name":"fromIndex","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_O_).\n  1. If _len_ = 0, return *false*.\n  1. Let _n_ be ? ToIntegerOrInfinity(_fromIndex_).\n  1. Assert: If _fromIndex_ is *undefined*, then _n_ is 0.\n  1. If _n_ = +∞, return *false*.\n  1. Else if _n_ = -∞, set _n_ to 0.\n  1. If _n_ ≥ 0, then\n    1. Let _k_ be _n_.\n  1. Else,\n    1. Let _k_ be _len_ + _n_.\n    1. If _k_ < 0, set _k_ to 0.\n  1. Repeat, while _k_ < _len_,\n    1. Let _elementK_ be ? Get(_O_, ! ToString(𝔽(_k_))).\n    1. If SameValueZero(_searchElement_, _elementK_) is *true*, return *true*.\n    1. Set _k_ to _k_ + 1.\n  1. Return *false*.","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. If _len_ = 0, return *false*.\n          1. Let _n_ be ? ToIntegerOrInfinity(_fromIndex_).\n          1. Assert: If _fromIndex_ is *undefined*, then _n_ is 0.\n          1. If _n_ = +∞, return *false*.\n          1. Else if _n_ = -∞, set _n_ to 0.\n          1. If _n_ ≥ 0, then\n            1. Let _k_ be _n_.\n          1. Else,\n            1. Let _k_ be _len_ + _n_.\n            1. If _k_ < 0, set _k_ to 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _elementK_ be ? Get(_O_, ! ToString(𝔽(_k_))).\n            1. If SameValueZero(_searchElement_, _elementK_) is *true*, return *true*.\n            1. Set _k_ to _k_ + 1.\n          1. Return *false*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"indexOf"}},"params":[{"name":"searchElement","ty":"Unknown","kind":{"Normal":{}}},{"name":"fromIndex","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_O_).\n  1. If _len_ = 0, return *-1*<sub>𝔽</sub>.\n  1. Let _n_ be ? ToIntegerOrInfinity(_fromIndex_).\n  1. Assert: If _fromIndex_ is *undefined*, then _n_ is 0.\n  1. If _n_ = +∞, return *-1*<sub>𝔽</sub>.\n  1. Else if _n_ = -∞, set _n_ to 0.\n  1. If _n_ ≥ 0, then\n    1. Let _k_ be _n_.\n  1. Else,\n    1. Let _k_ be _len_ + _n_.\n    1. If _k_ < 0, set _k_ to 0.\n  1. Repeat, while _k_ < _len_,\n    1. Let _kPresent_ be ? HasProperty(_O_, ! ToString(𝔽(_k_))).\n    1. If _kPresent_ is *true*, then\n      1. Let _elementK_ be ? Get(_O_, ! ToString(𝔽(_k_))).\n      1. If IsStrictlyEqual(_searchElement_, _elementK_) is *true*, return 𝔽(_k_).\n    1. Set _k_ to _k_ + 1.\n  1. Return *-1*<sub>𝔽</sub>.","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. If _len_ = 0, return *-1*<sub>𝔽</sub>.\n          1. Let _n_ be ? ToIntegerOrInfinity(_fromIndex_).\n          1. Assert: If _fromIndex_ is *undefined*, then _n_ is 0.\n          1. If _n_ = +∞, return *-1*<sub>𝔽</sub>.\n          1. Else if _n_ = -∞, set _n_ to 0.\n          1. If _n_ ≥ 0, then\n            1. Let _k_ be _n_.\n          1. Else,\n            1. Let _k_ be _len_ + _n_.\n            1. If _k_ < 0, set _k_ to 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _kPresent_ be ? HasProperty(_O_, ! ToString(𝔽(_k_))).\n            1. If _kPresent_ is *true*, then\n              1. Let _elementK_ be ? Get(_O_, ! ToString(𝔽(_k_))).\n              1. If IsStrictlyEqual(_searchElement_, _elementK_) is *true*, return 𝔽(_k_).\n            1. Set _k_ to _k_ + 1.\n          1. Return *-1*<sub>𝔽</sub>.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"join"}},"params":[{"name":"separator","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_O_).\n  1. If _separator_ is *undefined*, let _sep_ be *\",\"*.\n  1. Else, let _sep_ be ? ToString(_separator_).\n  1. Let _R_ be *\"\"*.\n  1. Let _k_ be 0.\n  1. Repeat, while _k_ < _len_,\n    1. If _k_ > 0, set _R_ to the string-concatenation of _R_ and _sep_.\n    1. Let _element_ be ? Get(_O_, ! ToString(𝔽(_k_))).\n    1. If _element_ is either *undefined* or *null*, let _next_ be *\"\"*.\n    1. Else, let _next_ be ? ToString(_element_).\n    1. Set _R_ to the string-concatenation of _R_ and _next_.\n    1. Set _k_ to _k_ + 1.\n  1. Return _R_.","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. If _separator_ is *undefined*, let _sep_ be *\",\"*.\n          1. Else, let _sep_ be ? ToString(_separator_).\n          1. Let _R_ be the empty String.\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. If _k_ > 0, set _R_ to the string-concatenation of _R_ and _sep_.\n            1. Let _element_ be ? Get(_O_, ! ToString(𝔽(_k_))).\n            1. If _element_ is either *undefined* or *null*, let _next_ be the empty String; otherwise, let _next_ be ? ToString(_element_).\n            1. Set _R_ to the string-concatenation of _R_ and _next_.\n            1. Set _k_ to _k_ + 1.\n          1. Return _R_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"keys"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Return CreateArrayIterator(_O_, ~key~).","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Return CreateArrayIterator(_O_, ~key~).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"lastIndexOf"}},"params":[{"name":"searchElement","ty":"Unknown","kind":{"Normal":{}}},{"name":"fromIndex","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_O_).\n  1. If _len_ = 0, return *-1*<sub>𝔽</sub>.\n  1. If _fromIndex_ is present, let _n_ be ? ToIntegerOrInfinity(_fromIndex_).\n  1. Else, let _n_ be _len_ - 1.\n  1. If _n_ = -∞, return *-1*<sub>𝔽</sub>.\n  1. If _n_ ≥ 0, then\n    1. Let _k_ be min(_n_, _len_ - 1).\n  1. Else,\n    1. Let _k_ be _len_ + _n_.\n  1. Repeat, while _k_ ≥ 0,\n    1. Let _kPresent_ be ? HasProperty(_O_, ! ToString(𝔽(_k_))).\n    1. If _kPresent_ is *true*, then\n      1. Let _elementK_ be ? Get(_O_, ! ToString(𝔽(_k_))).\n      1. If IsStrictlyEqual(_searchElement_, _elementK_) is *true*, return 𝔽(_k_).\n    1. Set _k_ to _k_ - 1.\n  1. Return *-1*<sub>𝔽</sub>.","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. If _len_ = 0, return *-1*<sub>𝔽</sub>.\n          1. If _fromIndex_ is present, let _n_ be ? ToIntegerOrInfinity(_fromIndex_); else let _n_ be _len_ - 1.\n          1. If _n_ = -∞, return *-1*<sub>𝔽</sub>.\n          1. If _n_ ≥ 0, then\n            1. Let _k_ be min(_n_, _len_ - 1).\n          1. Else,\n            1. Let _k_ be _len_ + _n_.\n          1. Repeat, while _k_ ≥ 0,\n            1. Let _kPresent_ be ? HasProperty(_O_, ! ToString(𝔽(_k_))).\n            1. If _kPresent_ is *true*, then\n              1. Let _elementK_ be ? Get(_O_, ! ToString(𝔽(_k_))).\n              1. If IsStrictlyEqual(_searchElement_, _elementK_) is *true*, return 𝔽(_k_).\n            1. Set _k_ to _k_ - 1.\n          1. Return *-1*<sub>𝔽</sub>.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"map"}},"params":[{"name":"callbackfn","ty":"Unknown","kind":{"Normal":{}}},{"name":"thisArg","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_O_).\n  1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n  1. Let _A_ be ? ArraySpeciesCreate(_O_, _len_).\n  1. Let _k_ be 0.\n  1. Repeat, while _k_ < _len_,\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).\n    1. If _kPresent_ is *true*, then\n      1. Let _kValue_ be ? Get(_O_, _Pk_).\n      1. Let _mappedValue_ be ? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).\n      1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_).\n    1. Set _k_ to _k_ + 1.\n  1. Return _A_.","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. Let _A_ be ? ArraySpeciesCreate(_O_, _len_).\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).\n            1. If _kPresent_ is *true*, then\n              1. Let _kValue_ be ? Get(_O_, _Pk_).\n              1. Let _mappedValue_ be ? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).\n              1. Perform ? CreateDataPropertyOrThrow(_A_, _Pk_, _mappedValue_).\n            1. Set _k_ to _k_ + 1.\n          1. Return _A_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"pop"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_O_).\n  1. If _len_ = 0, then\n    1. Perform ? Set(_O_, *\"length\"*, *+0*<sub>𝔽</sub>, *true*).\n    1. Return *undefined*.\n  1. Else,\n    1. Assert: _len_ > 0.\n    1. Let _newLen_ be 𝔽(_len_ - 1).\n    1. Let _index_ be ! ToString(_newLen_).\n    1. Let _element_ be ? Get(_O_, _index_).\n    1. Perform ? DeletePropertyOrThrow(_O_, _index_).\n    1. Perform ? Set(_O_, *\"length\"*, _newLen_, *true*).\n    1. Return _element_.","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. If _len_ = 0, then\n            1. Perform ? Set(_O_, *\"length\"*, *+0*<sub>𝔽</sub>, *true*).\n            1. Return *undefined*.\n          1. Else,\n            1. Assert: _len_ > 0.\n            1. Let _newLen_ be 𝔽(_len_ - 1).\n            1. Let _index_ be ! ToString(_newLen_).\n            1. Let _element_ be ? Get(_O_, _index_).\n            1. Perform ? DeletePropertyOrThrow(_O_, _index_).\n            1. Perform ? Set(_O_, *\"length\"*, _newLen_, *true*).\n            1. Return _element_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"push"}},"params":[{"name":"items","ty":"Unknown","kind":{"Variadic":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_O_).\n  1. Let _argCount_ be the number of elements in _items_.\n  1. If _len_ + _argCount_ > 2<sup>53</sup> - 1, throw a *TypeError* exception.\n  1. For each _E_ of _items_, do\n    1. Perform ? Set(_O_, ! ToString(𝔽(_len_)), _E_, *true*).\n    1. Set _len_ to _len_ + 1.\n  1. Perform ? Set(_O_, *\"length\"*, 𝔽(_len_), *true*).\n  1. Return 𝔽(_len_).","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _argCount_ be the number of elements in _items_.\n          1. If _len_ + _argCount_ > 2<sup>53</sup> - 1, throw a *TypeError* exception.\n          1. For each element _E_ of _items_, do\n            1. Perform ? Set(_O_, ! ToString(𝔽(_len_)), _E_, *true*).\n            1. Set _len_ to _len_ + 1.\n          1. Perform ? Set(_O_, *\"length\"*, 𝔽(_len_), *true*).\n          1. Return 𝔽(_len_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"reduce"}},"params":[{"name":"callbackfn","ty":"Unknown","kind":{"Normal":{}}},{"name":"initialValue","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_O_).\n  1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n  1. If _len_ = 0 and _initialValue_ is not present, throw a *TypeError* exception.\n  1. Let _k_ be 0.\n  1. Let _accumulator_ be *undefined*.\n  1. If _initialValue_ is present, then\n    1. Set _accumulator_ to _initialValue_.\n  1. Else,\n    1. Let _kPresent_ be *false*.\n    1. Repeat, while _kPresent_ is *false* and _k_ < _len_,\n      1. Let _Pk_ be ! ToString(𝔽(_k_)).\n      1. Set _kPresent_ to ? HasProperty(_O_, _Pk_).\n      1. If _kPresent_ is *true*, then\n        1. Set _accumulator_ to ? Get(_O_, _Pk_).\n      1. Set _k_ to _k_ + 1.\n    1. If _kPresent_ is *false*, throw a *TypeError* exception.\n  1. Repeat, while _k_ < _len_,\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).\n    1. If _kPresent_ is *true*, then\n      1. Let _kValue_ be ? Get(_O_, _Pk_).\n      1. Set _accumulator_ to ? Call(_callbackfn_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »).\n    1. Set _k_ to _k_ + 1.\n  1. Return _accumulator_.","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. If _len_ = 0 and _initialValue_ is not present, throw a *TypeError* exception.\n          1. Let _k_ be 0.\n          1. Let _accumulator_ be *undefined*.\n          1. If _initialValue_ is present, then\n            1. Set _accumulator_ to _initialValue_.\n          1. Else,\n            1. Let _kPresent_ be *false*.\n            1. Repeat, while _kPresent_ is *false* and _k_ < _len_,\n              1. Let _Pk_ be ! ToString(𝔽(_k_)).\n              1. Set _kPresent_ to ? HasProperty(_O_, _Pk_).\n              1. If _kPresent_ is *true*, then\n                1. Set _accumulator_ to ? Get(_O_, _Pk_).\n              1. Set _k_ to _k_ + 1.\n            1. If _kPresent_ is *false*, throw a *TypeError* exception.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).\n            1. If _kPresent_ is *true*, then\n              1. Let _kValue_ be ? Get(_O_, _Pk_).\n              1. Set _accumulator_ to ? Call(_callbackfn_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »).\n            1. Set _k_ to _k_ + 1.\n          1. Return _accumulator_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"reduceRight"}},"params":[{"name":"callbackfn","ty":"Unknown","kind":{"Normal":{}}},{"name":"initialValue","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_O_).\n  1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n  1. If _len_ = 0 and _initialValue_ is not present, throw a *TypeError* exception.\n  1. Let _k_ be _len_ - 1.\n  1. Let _accumulator_ be *undefined*.\n  1. If _initialValue_ is present, then\n    1. Set _accumulator_ to _initialValue_.\n  1. Else,\n    1. Let _kPresent_ be *false*.\n    1. Repeat, while _kPresent_ is *false* and _k_ ≥ 0,\n      1. Let _Pk_ be ! ToString(𝔽(_k_)).\n      1. Set _kPresent_ to ? HasProperty(_O_, _Pk_).\n      1. If _kPresent_ is *true*, then\n        1. Set _accumulator_ to ? Get(_O_, _Pk_).\n      1. Set _k_ to _k_ - 1.\n    1. If _kPresent_ is *false*, throw a *TypeError* exception.\n  1. Repeat, while _k_ ≥ 0,\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).\n    1. If _kPresent_ is *true*, then\n      1. Let _kValue_ be ? Get(_O_, _Pk_).\n      1. Set _accumulator_ to ? Call(_callbackfn_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »).\n    1. Set _k_ to _k_ - 1.\n  1. Return _accumulator_.","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. If _len_ = 0 and _initialValue_ is not present, throw a *TypeError* exception.\n          1. Let _k_ be _len_ - 1.\n          1. Let _accumulator_ be *undefined*.\n          1. If _initialValue_ is present, then\n            1. Set _accumulator_ to _initialValue_.\n          1. Else,\n            1. Let _kPresent_ be *false*.\n            1. Repeat, while _kPresent_ is *false* and _k_ ≥ 0,\n              1. Let _Pk_ be ! ToString(𝔽(_k_)).\n              1. Set _kPresent_ to ? HasProperty(_O_, _Pk_).\n              1. If _kPresent_ is *true*, then\n                1. Set _accumulator_ to ? Get(_O_, _Pk_).\n              1. Set _k_ to _k_ - 1.\n            1. If _kPresent_ is *false*, throw a *TypeError* exception.\n          1. Repeat, while _k_ ≥ 0,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).\n            1. If _kPresent_ is *true*, then\n              1. Let _kValue_ be ? Get(_O_, _Pk_).\n              1. Set _accumulator_ to ? Call(_callbackfn_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »).\n            1. Set _k_ to _k_ - 1.\n          1. Return _accumulator_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"reverse"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_O_).\n  1. Let _middle_ be floor(_len_ / 2).\n  1. Let _lower_ be 0.\n  1. Repeat, while _lower_ ≠ _middle_,\n    1. Let _upper_ be _len_ - _lower_ - 1.\n    1. Let _upperP_ be ! ToString(𝔽(_upper_)).\n    1. Let _lowerP_ be ! ToString(𝔽(_lower_)).\n    1. Let _lowerExists_ be ? HasProperty(_O_, _lowerP_).\n    1. If _lowerExists_ is *true*, then\n      1. Let _lowerValue_ be ? Get(_O_, _lowerP_).\n    1. Let _upperExists_ be ? HasProperty(_O_, _upperP_).\n    1. If _upperExists_ is *true*, then\n      1. Let _upperValue_ be ? Get(_O_, _upperP_).\n    1. If _lowerExists_ is *true* and _upperExists_ is *true*, then\n      1. Perform ? Set(_O_, _lowerP_, _upperValue_, *true*).\n      1. Perform ? Set(_O_, _upperP_, _lowerValue_, *true*).\n    1. Else if _lowerExists_ is *false* and _upperExists_ is *true*, then\n      1. Perform ? Set(_O_, _lowerP_, _upperValue_, *true*).\n      1. Perform ? DeletePropertyOrThrow(_O_, _upperP_).\n    1. Else if _lowerExists_ is *true* and _upperExists_ is *false*, then\n      1. Perform ? DeletePropertyOrThrow(_O_, _lowerP_).\n      1. Perform ? Set(_O_, _upperP_, _lowerValue_, *true*).\n    1. Else,\n      1. Assert: both _lowerExists_ and _upperExists_ are *false*.\n      1. NOTE: No action is required.\n    1. Set _lower_ to _lower_ + 1.\n  1. Return _O_.","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _middle_ be floor(_len_ / 2).\n          1. Let _lower_ be 0.\n          1. Repeat, while _lower_ ≠ _middle_,\n            1. Let _upper_ be _len_ - _lower_ - 1.\n            1. Let _upperP_ be ! ToString(𝔽(_upper_)).\n            1. Let _lowerP_ be ! ToString(𝔽(_lower_)).\n            1. Let _lowerExists_ be ? HasProperty(_O_, _lowerP_).\n            1. If _lowerExists_ is *true*, then\n              1. Let _lowerValue_ be ? Get(_O_, _lowerP_).\n            1. Let _upperExists_ be ? HasProperty(_O_, _upperP_).\n            1. If _upperExists_ is *true*, then\n              1. Let _upperValue_ be ? Get(_O_, _upperP_).\n            1. If _lowerExists_ is *true* and _upperExists_ is *true*, then\n              1. Perform ? Set(_O_, _lowerP_, _upperValue_, *true*).\n              1. Perform ? Set(_O_, _upperP_, _lowerValue_, *true*).\n            1. Else if _lowerExists_ is *false* and _upperExists_ is *true*, then\n              1. Perform ? Set(_O_, _lowerP_, _upperValue_, *true*).\n              1. Perform ? DeletePropertyOrThrow(_O_, _upperP_).\n            1. Else if _lowerExists_ is *true* and _upperExists_ is *false*, then\n              1. Perform ? DeletePropertyOrThrow(_O_, _lowerP_).\n              1. Perform ? Set(_O_, _upperP_, _lowerValue_, *true*).\n            1. Else,\n              1. Assert: _lowerExists_ and _upperExists_ are both *false*.\n              1. NOTE: No action is required.\n            1. Set _lower_ to _lower_ + 1.\n          1. Return _O_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"shift"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_O_).\n  1. If _len_ = 0, then\n    1. Perform ? Set(_O_, *\"length\"*, *+0*<sub>𝔽</sub>, *true*).\n    1. Return *undefined*.\n  1. Let _first_ be ? Get(_O_, *\"0\"*).\n  1. Let _k_ be 1.\n  1. Repeat, while _k_ < _len_,\n    1. Let _from_ be ! ToString(𝔽(_k_)).\n    1. Let _to_ be ! ToString(𝔽(_k_ - 1)).\n    1. Let _fromPresent_ be ? HasProperty(_O_, _from_).\n    1. If _fromPresent_ is *true*, then\n      1. Let _fromVal_ be ? Get(_O_, _from_).\n      1. Perform ? Set(_O_, _to_, _fromVal_, *true*).\n    1. Else,\n      1. Assert: _fromPresent_ is *false*.\n      1. Perform ? DeletePropertyOrThrow(_O_, _to_).\n    1. Set _k_ to _k_ + 1.\n  1. Perform ? DeletePropertyOrThrow(_O_, ! ToString(𝔽(_len_ - 1))).\n  1. Perform ? Set(_O_, *\"length\"*, 𝔽(_len_ - 1), *true*).\n  1. Return _first_.","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. If _len_ = 0, then\n            1. Perform ? Set(_O_, *\"length\"*, *+0*<sub>𝔽</sub>, *true*).\n            1. Return *undefined*.\n          1. Let _first_ be ? Get(_O_, *\"0\"*).\n          1. Let _k_ be 1.\n          1. Repeat, while _k_ < _len_,\n            1. Let _from_ be ! ToString(𝔽(_k_)).\n            1. Let _to_ be ! ToString(𝔽(_k_ - 1)).\n            1. Let _fromPresent_ be ? HasProperty(_O_, _from_).\n            1. If _fromPresent_ is *true*, then\n              1. Let _fromVal_ be ? Get(_O_, _from_).\n              1. Perform ? Set(_O_, _to_, _fromVal_, *true*).\n            1. Else,\n              1. Assert: _fromPresent_ is *false*.\n              1. Perform ? DeletePropertyOrThrow(_O_, _to_).\n            1. Set _k_ to _k_ + 1.\n          1. Perform ? DeletePropertyOrThrow(_O_, ! ToString(𝔽(_len_ - 1))).\n          1. Perform ? Set(_O_, *\"length\"*, 𝔽(_len_ - 1), *true*).\n          1. Return _first_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"slice"}},"params":[{"name":"start","ty":"Unknown","kind":{"Normal":{}}},{"name":"end","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_O_).\n  1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n  1. If _relativeStart_ = -∞, let _k_ be 0.\n  1. Else if _relativeStart_ < 0, let _k_ be max(_len_ + _relativeStart_, 0).\n  1. Else, let _k_ be min(_relativeStart_, _len_).\n  1. If _end_ is *undefined*, let _relativeEnd_ be _len_.\n  1. Else, let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).\n  1. If _relativeEnd_ = -∞, let _final_ be 0.\n  1. Else if _relativeEnd_ < 0, let _final_ be max(_len_ + _relativeEnd_, 0).\n  1. Else, let _final_ be min(_relativeEnd_, _len_).\n  1. Let _count_ be max(_final_ - _k_, 0).\n  1. Let _A_ be ? ArraySpeciesCreate(_O_, _count_).\n  1. Let _n_ be 0.\n  1. Repeat, while _k_ < _final_,\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).\n    1. If _kPresent_ is *true*, then\n      1. Let _kValue_ be ? Get(_O_, _Pk_).\n      1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _kValue_).\n    1. Set _k_ to _k_ + 1.\n    1. Set _n_ to _n_ + 1.\n  1. [id=\"step-array-proto-slice-set-length\"] Perform ? Set(_A_, *\"length\"*, 𝔽(_n_), *true*).\n  1. Return _A_.","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n          1. If _relativeStart_ = -∞, let _k_ be 0.\n          1. Else if _relativeStart_ < 0, let _k_ be max(_len_ + _relativeStart_, 0).\n          1. Else, let _k_ be min(_relativeStart_, _len_).\n          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).\n          1. If _relativeEnd_ = -∞, let _final_ be 0.\n          1. Else if _relativeEnd_ < 0, let _final_ be max(_len_ + _relativeEnd_, 0).\n          1. Else, let _final_ be min(_relativeEnd_, _len_).\n          1. Let _count_ be max(_final_ - _k_, 0).\n          1. Let _A_ be ? ArraySpeciesCreate(_O_, _count_).\n          1. Let _n_ be 0.\n          1. Repeat, while _k_ < _final_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).\n            1. If _kPresent_ is *true*, then\n              1. Let _kValue_ be ? Get(_O_, _Pk_).\n              1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_n_)), _kValue_).\n            1. Set _k_ to _k_ + 1.\n            1. Set _n_ to _n_ + 1.\n          1. [id=\"step-array-proto-slice-set-length\"] Perform ? Set(_A_, *\"length\"*, 𝔽(_n_), *true*).\n          1. Return _A_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"some"}},"params":[{"name":"callbackfn","ty":"Unknown","kind":{"Normal":{}}},{"name":"thisArg","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_O_).\n  1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n  1. Let _k_ be 0.\n  1. Repeat, while _k_ < _len_,\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).\n    1. If _kPresent_ is *true*, then\n      1. Let _kValue_ be ? Get(_O_, _Pk_).\n      1. Let _testResult_ be ToBoolean(? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).\n      1. If _testResult_ is *true*, return *true*.\n    1. Set _k_ to _k_ + 1.\n  1. Return *false*.","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kPresent_ be ? HasProperty(_O_, _Pk_).\n            1. If _kPresent_ is *true*, then\n              1. Let _kValue_ be ? Get(_O_, _Pk_).\n              1. Let _testResult_ be ToBoolean(? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).\n              1. If _testResult_ is *true*, return *true*.\n            1. Set _k_ to _k_ + 1.\n          1. Return *false*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"sort"}},"params":[{"name":"comparefn","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. [id=\"step-array-sort-comparefn\"] If _comparefn_ is not *undefined* and IsCallable(_comparefn_) is *false*, throw a *TypeError* exception.\n  1. Let _obj_ be ? ToObject(*this* value).\n  1. [id=\"step-array-sort-len\"] Let _len_ be ? LengthOfArrayLike(_obj_).\n  1. Let _SortCompare_ be a new Abstract Closure with parameters (_x_, _y_) that captures _comparefn_ and performs the following steps when called:\n    1. Return ? CompareArrayElements(_x_, _y_, _comparefn_).\n  1. [id=\"step-array-sortindexedproperties\"] Let _sortedList_ be ? SortIndexedProperties(_obj_, _len_, _SortCompare_, ~skip-holes~).\n  1. Let _itemCount_ be the number of elements in _sortedList_.\n  1. Let _j_ be 0.\n  1. Repeat, while _j_ < _itemCount_,\n    1. Perform ? Set(_obj_, ! ToString(𝔽(_j_)), _sortedList_[_j_], *true*).\n    1. Set _j_ to _j_ + 1.\n  1. NOTE: The call to SortIndexedProperties in step <emu-xref href=\"#step-array-sortindexedproperties\"></emu-xref> uses ~skip-holes~. The remaining indices are deleted to preserve the number of holes that were detected and excluded from the sort.\n  1. Repeat, while _j_ < _len_,\n    1. Perform ? DeletePropertyOrThrow(_obj_, ! ToString(𝔽(_j_))).\n    1. Set _j_ to _j_ + 1.\n  1. Return _obj_.","code":"\n          1. [id=\"step-array-sort-comparefn\"] If _comparefn_ is not *undefined* and IsCallable(_comparefn_) is *false*, throw a *TypeError* exception.\n          1. Let _obj_ be ? ToObject(*this* value).\n          1. [id=\"step-array-sort-len\"] Let _len_ be ? LengthOfArrayLike(_obj_).\n          1. Let _SortCompare_ be a new Abstract Closure with parameters (_x_, _y_) that captures _comparefn_ and performs the following steps when called:\n            1. Return ? CompareArrayElements(_x_, _y_, _comparefn_).\n          1. [id=\"step-array-sortindexedproperties\"] Let _sortedList_ be ? SortIndexedProperties(_obj_, _len_, _SortCompare_, ~skip-holes~).\n          1. Let _itemCount_ be the number of elements in _sortedList_.\n          1. Let _j_ be 0.\n          1. Repeat, while _j_ < _itemCount_,\n            1. Perform ? Set(_obj_, ! ToString(𝔽(_j_)), _sortedList_[_j_], *true*).\n            1. Set _j_ to _j_ + 1.\n          1. NOTE: The call to SortIndexedProperties in step <emu-xref href=\"#step-array-sortindexedproperties\"></emu-xref> uses ~skip-holes~. The remaining indices are deleted to preserve the number of holes that were detected and excluded from the sort.\n          1. Repeat, while _j_ < _len_,\n            1. Perform ? DeletePropertyOrThrow(_obj_, ! ToString(𝔽(_j_))).\n            1. Set _j_ to _j_ + 1.\n          1. Return _obj_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"SortIndexedProperties","params":[{"name":"obj","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"len","ty":"NonNegInt","kind":{"Normal":{}}},{"name":"SortCompare","ty":"Unknown[\"an Abstract Closure with two parameters\"]","kind":{"Normal":{}}},{"name":"holes","ty":"Enum[~read-through-holes~, ~skip-holes~]","kind":{"Normal":{}}}],"retTy":"Normal[List[ESValue]] | Throw"}},"body":"\n  1. Let _items_ be « ».\n  1. Let _k_ be 0.\n  1. Repeat, while _k_ < _len_,\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. If _holes_ is ~skip-holes~, then\n      1. Let _kRead_ be ? HasProperty(_obj_, _Pk_).\n    1. Else,\n      1. Assert: _holes_ is ~read-through-holes~.\n      1. Let _kRead_ be *true*.\n    1. If _kRead_ is *true*, then\n      1. Let _kValue_ be ? Get(_obj_, _Pk_).\n      1. Append _kValue_ to _items_.\n    1. Set _k_ to _k_ + 1.\n  1. [id=\"step-array-sort\"] Sort _items_ using an implementation-defined sequence of <emu-meta effects=\"user-code\">calls to _SortCompare_</emu-meta>. If any such call returns an abrupt completion, stop before performing any further calls to _SortCompare_ and return that Completion Record.\n  1. Return _items_.","code":"\n            1. Let _items_ be a new empty List.\n            1. Let _k_ be 0.\n            1. Repeat, while _k_ < _len_,\n              1. Let _Pk_ be ! ToString(𝔽(_k_)).\n              1. If _holes_ is ~skip-holes~, then\n                1. Let _kRead_ be ? HasProperty(_obj_, _Pk_).\n              1. Else,\n                1. Assert: _holes_ is ~read-through-holes~.\n                1. Let _kRead_ be *true*.\n              1. If _kRead_ is *true*, then\n                1. Let _kValue_ be ? Get(_obj_, _Pk_).\n                1. Append _kValue_ to _items_.\n              1. Set _k_ to _k_ + 1.\n            1. [id=\"step-array-sort\"] Sort _items_ using an implementation-defined sequence of <emu-meta effects=\"user-code\">calls to _SortCompare_</emu-meta>. If any such call returns an abrupt completion, stop before performing any further calls to _SortCompare_ and return that Completion Record.\n            1. Return _items_.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CompareArrayElements","params":[{"name":"x","ty":"ESValue","kind":{"Normal":{}}},{"name":"y","ty":"ESValue","kind":{"Normal":{}}},{"name":"comparefn","ty":"Record[FunctionObject] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Number] | Abrupt"}},"body":"\n  1. If both _x_ and _y_ are *undefined*, return *+0*<sub>𝔽</sub>.\n  1. If _x_ is *undefined*, return *1*<sub>𝔽</sub>.\n  1. If _y_ is *undefined*, return *-1*<sub>𝔽</sub>.\n  1. If _comparefn_ is not *undefined*, then\n    1. Let _v_ be ? ToNumber(? Call(_comparefn_, *undefined*, « _x_, _y_ »)).\n    1. If _v_ is *NaN*, return *+0*<sub>𝔽</sub>.\n    1. Return _v_.\n  1. [id=\"step-sortcompare-tostring-x\"] Let _xString_ be ? ToString(_x_).\n  1. [id=\"step-sortcompare-tostring-y\"] Let _yString_ be ? ToString(_y_).\n  1. Let _xSmaller_ be ! IsLessThan(_xString_, _yString_, *true*).\n  1. If _xSmaller_ is *true*, return *-1*<sub>𝔽</sub>.\n  1. Let _ySmaller_ be ! IsLessThan(_yString_, _xString_, *true*).\n  1. If _ySmaller_ is *true*, return *1*<sub>𝔽</sub>.\n  1. Return *+0*<sub>𝔽</sub>.","code":"\n            1. If _x_ and _y_ are both *undefined*, return *+0*<sub>𝔽</sub>.\n            1. If _x_ is *undefined*, return *1*<sub>𝔽</sub>.\n            1. If _y_ is *undefined*, return *-1*<sub>𝔽</sub>.\n            1. If _comparefn_ is not *undefined*, then\n              1. Let _v_ be ? ToNumber(? Call(_comparefn_, *undefined*, « _x_, _y_ »)).\n              1. If _v_ is *NaN*, return *+0*<sub>𝔽</sub>.\n              1. Return _v_.\n            1. [id=\"step-sortcompare-tostring-x\"] Let _xString_ be ? ToString(_x_).\n            1. [id=\"step-sortcompare-tostring-y\"] Let _yString_ be ? ToString(_y_).\n            1. Let _xSmaller_ be ! IsLessThan(_xString_, _yString_, *true*).\n            1. If _xSmaller_ is *true*, return *-1*<sub>𝔽</sub>.\n            1. Let _ySmaller_ be ! IsLessThan(_yString_, _xString_, *true*).\n            1. If _ySmaller_ is *true*, return *1*<sub>𝔽</sub>.\n            1. Return *+0*<sub>𝔽</sub>.\n          "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"splice"}},"params":[{"name":"start","ty":"Unknown","kind":{"Normal":{}}},{"name":"deleteCount","ty":"Unknown","kind":{"Normal":{}}},{"name":"items","ty":"Unknown","kind":{"Variadic":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_O_).\n  1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n  1. If _relativeStart_ = -∞, let _actualStart_ be 0.\n  1. Else if _relativeStart_ < 0, let _actualStart_ be max(_len_ + _relativeStart_, 0).\n  1. Else, let _actualStart_ be min(_relativeStart_, _len_).\n  1. Let _itemCount_ be the number of elements in _items_.\n  1. If _start_ is not present, then\n    1. Let _actualDeleteCount_ be 0.\n  1. Else if _deleteCount_ is not present, then\n    1. Let _actualDeleteCount_ be _len_ - _actualStart_.\n  1. Else,\n    1. Let _dc_ be ? ToIntegerOrInfinity(_deleteCount_).\n    1. Let _actualDeleteCount_ be the result of clamping _dc_ between 0 and _len_ - _actualStart_.\n  1. If _len_ + _itemCount_ - _actualDeleteCount_ > 2<sup>53</sup> - 1, throw a *TypeError* exception.\n  1. Let _A_ be ? ArraySpeciesCreate(_O_, _actualDeleteCount_).\n  1. Let _k_ be 0.\n  1. Repeat, while _k_ < _actualDeleteCount_,\n    1. Let _from_ be ! ToString(𝔽(_actualStart_ + _k_)).\n    1. If ? HasProperty(_O_, _from_) is *true*, then\n      1. Let _fromValue_ be ? Get(_O_, _from_).\n      1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_k_)), _fromValue_).\n    1. Set _k_ to _k_ + 1.\n  1. [id=\"step-array-proto-splice-set-length\"] Perform ? Set(_A_, *\"length\"*, 𝔽(_actualDeleteCount_), *true*).\n  1. If _itemCount_ < _actualDeleteCount_, then\n    1. Set _k_ to _actualStart_.\n    1. Repeat, while _k_ < _len_ - _actualDeleteCount_,\n      1. Let _from_ be ! ToString(𝔽(_k_ + _actualDeleteCount_)).\n      1. Let _to_ be ! ToString(𝔽(_k_ + _itemCount_)).\n      1. If ? HasProperty(_O_, _from_) is *true*, then\n        1. Let _fromValue_ be ? Get(_O_, _from_).\n        1. Perform ? Set(_O_, _to_, _fromValue_, *true*).\n      1. Else,\n        1. Perform ? DeletePropertyOrThrow(_O_, _to_).\n      1. Set _k_ to _k_ + 1.\n    1. Set _k_ to _len_.\n    1. Repeat, while _k_ > _len_ - _actualDeleteCount_ + _itemCount_,\n      1. Perform ? DeletePropertyOrThrow(_O_, ! ToString(𝔽(_k_ - 1))).\n      1. Set _k_ to _k_ - 1.\n  1. Else if _itemCount_ > _actualDeleteCount_, then\n    1. Set _k_ to _len_ - _actualDeleteCount_.\n    1. Repeat, while _k_ > _actualStart_,\n      1. Let _from_ be ! ToString(𝔽(_k_ + _actualDeleteCount_ - 1)).\n      1. Let _to_ be ! ToString(𝔽(_k_ + _itemCount_ - 1)).\n      1. If ? HasProperty(_O_, _from_) is *true*, then\n        1. Let _fromValue_ be ? Get(_O_, _from_).\n        1. Perform ? Set(_O_, _to_, _fromValue_, *true*).\n      1. Else,\n        1. Perform ? DeletePropertyOrThrow(_O_, _to_).\n      1. Set _k_ to _k_ - 1.\n  1. Set _k_ to _actualStart_.\n  1. For each _E_ of _items_, do\n    1. Perform ? Set(_O_, ! ToString(𝔽(_k_)), _E_, *true*).\n    1. Set _k_ to _k_ + 1.\n  1. [id=\"step-array-proto-splice-set-length-2\"] Perform ? Set(_O_, *\"length\"*, 𝔽(_len_ - _actualDeleteCount_ + _itemCount_), *true*).\n  1. Return _A_.","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n          1. If _relativeStart_ = -∞, let _actualStart_ be 0.\n          1. Else if _relativeStart_ < 0, let _actualStart_ be max(_len_ + _relativeStart_, 0).\n          1. Else, let _actualStart_ be min(_relativeStart_, _len_).\n          1. Let _itemCount_ be the number of elements in _items_.\n          1. If _start_ is not present, then\n            1. Let _actualDeleteCount_ be 0.\n          1. Else if _deleteCount_ is not present, then\n            1. Let _actualDeleteCount_ be _len_ - _actualStart_.\n          1. Else,\n            1. Let _dc_ be ? ToIntegerOrInfinity(_deleteCount_).\n            1. Let _actualDeleteCount_ be the result of clamping _dc_ between 0 and _len_ - _actualStart_.\n          1. If _len_ + _itemCount_ - _actualDeleteCount_ > 2<sup>53</sup> - 1, throw a *TypeError* exception.\n          1. Let _A_ be ? ArraySpeciesCreate(_O_, _actualDeleteCount_).\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _actualDeleteCount_,\n            1. Let _from_ be ! ToString(𝔽(_actualStart_ + _k_)).\n            1. If ? HasProperty(_O_, _from_) is *true*, then\n              1. Let _fromValue_ be ? Get(_O_, _from_).\n              1. Perform ? CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_k_)), _fromValue_).\n            1. Set _k_ to _k_ + 1.\n          1. [id=\"step-array-proto-splice-set-length\"] Perform ? Set(_A_, *\"length\"*, 𝔽(_actualDeleteCount_), *true*).\n          1. If _itemCount_ < _actualDeleteCount_, then\n            1. Set _k_ to _actualStart_.\n            1. Repeat, while _k_ < (_len_ - _actualDeleteCount_),\n              1. Let _from_ be ! ToString(𝔽(_k_ + _actualDeleteCount_)).\n              1. Let _to_ be ! ToString(𝔽(_k_ + _itemCount_)).\n              1. If ? HasProperty(_O_, _from_) is *true*, then\n                1. Let _fromValue_ be ? Get(_O_, _from_).\n                1. Perform ? Set(_O_, _to_, _fromValue_, *true*).\n              1. Else,\n                1. Perform ? DeletePropertyOrThrow(_O_, _to_).\n              1. Set _k_ to _k_ + 1.\n            1. Set _k_ to _len_.\n            1. Repeat, while _k_ > (_len_ - _actualDeleteCount_ + _itemCount_),\n              1. Perform ? DeletePropertyOrThrow(_O_, ! ToString(𝔽(_k_ - 1))).\n              1. Set _k_ to _k_ - 1.\n          1. Else if _itemCount_ > _actualDeleteCount_, then\n            1. Set _k_ to (_len_ - _actualDeleteCount_).\n            1. Repeat, while _k_ > _actualStart_,\n              1. Let _from_ be ! ToString(𝔽(_k_ + _actualDeleteCount_ - 1)).\n              1. Let _to_ be ! ToString(𝔽(_k_ + _itemCount_ - 1)).\n              1. If ? HasProperty(_O_, _from_) is *true*, then\n                1. Let _fromValue_ be ? Get(_O_, _from_).\n                1. Perform ? Set(_O_, _to_, _fromValue_, *true*).\n              1. Else,\n                1. Perform ? DeletePropertyOrThrow(_O_, _to_).\n              1. Set _k_ to _k_ - 1.\n          1. Set _k_ to _actualStart_.\n          1. For each element _E_ of _items_, do\n            1. Perform ? Set(_O_, ! ToString(𝔽(_k_)), _E_, *true*).\n            1. Set _k_ to _k_ + 1.\n          1. [id=\"step-array-proto-splice-set-length-2\"] Perform ? Set(_O_, *\"length\"*, 𝔽(_len_ - _actualDeleteCount_ + _itemCount_), *true*).\n          1. Return _A_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"toLocaleString"}},"params":[{"name":"reserved1","ty":"Unknown","kind":{"Optional":{}}},{"name":"reserved2","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _array_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_array_).\n  1. Let _separator_ be the implementation-defined list-separator String value appropriate for the host environment's current locale (such as *\", \"*).\n  1. Let _R_ be *\"\"*.\n  1. Let _k_ be 0.\n  1. Repeat, while _k_ < _len_,\n    1. If _k_ > 0, then\n      1. Set _R_ to the string-concatenation of _R_ and _separator_.\n    1. Let _nextElement_ be ? Get(_array_, ! ToString(𝔽(_k_))).\n    1. If _nextElement_ is neither *undefined* nor *null*, then\n      1. Let _S_ be ? ToString(? Invoke(_nextElement_, *\"toLocaleString\"*)).\n      1. Set _R_ to the string-concatenation of _R_ and _S_.\n    1. Set _k_ to _k_ + 1.\n  1. Return _R_.","code":"\n          1. Let _array_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_array_).\n          1. Let _separator_ be the implementation-defined list-separator String value appropriate for the host environment's current locale (such as *\", \"*).\n          1. Let _R_ be the empty String.\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. If _k_ > 0, then\n              1. Set _R_ to the string-concatenation of _R_ and _separator_.\n            1. Let _nextElement_ be ? Get(_array_, ! ToString(𝔽(_k_))).\n            1. If _nextElement_ is neither *undefined* nor *null*, then\n              1. Let _S_ be ? ToString(? Invoke(_nextElement_, *\"toLocaleString\"*)).\n              1. Set _R_ to the string-concatenation of _R_ and _S_.\n            1. Set _k_ to _k_ + 1.\n          1. Return _R_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"toReversed"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_O_).\n  1. Let _A_ be ? ArrayCreate(_len_).\n  1. Let _k_ be 0.\n  1. Repeat, while _k_ < _len_,\n    1. Let _from_ be ! ToString(𝔽(_len_ - _k_ - 1)).\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. Let _fromValue_ be ? Get(_O_, _from_).\n    1. Perform ! CreateDataPropertyOrThrow(_A_, _Pk_, _fromValue_).\n    1. Set _k_ to _k_ + 1.\n  1. Return _A_.","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _A_ be ? ArrayCreate(_len_).\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _from_ be ! ToString(𝔽(_len_ - _k_ - 1)).\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _fromValue_ be ? Get(_O_, _from_).\n            1. Perform ! CreateDataPropertyOrThrow(_A_, _Pk_, _fromValue_).\n            1. Set _k_ to _k_ + 1.\n          1. Return _A_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"toSorted"}},"params":[{"name":"comparefn","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If _comparefn_ is not *undefined* and IsCallable(_comparefn_) is *false*, throw a *TypeError* exception.\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_O_).\n  1. Let _A_ be ? ArrayCreate(_len_).\n  1. Let _SortCompare_ be a new Abstract Closure with parameters (_x_, _y_) that captures _comparefn_ and performs the following steps when called:\n    1. Return ? CompareArrayElements(_x_, _y_, _comparefn_).\n  1. Let _sortedList_ be ? SortIndexedProperties(_O_, _len_, _SortCompare_, ~read-through-holes~).\n  1. Let _j_ be 0.\n  1. Repeat, while _j_ < _len_,\n    1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_j_)), _sortedList_[_j_]).\n    1. Set _j_ to _j_ + 1.\n  1. Return _A_.","code":"\n          1. If _comparefn_ is not *undefined* and IsCallable(_comparefn_) is *false*, throw a *TypeError* exception.\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _A_ be ? ArrayCreate(_len_).\n          1. Let _SortCompare_ be a new Abstract Closure with parameters (_x_, _y_) that captures _comparefn_ and performs the following steps when called:\n            1. Return ? CompareArrayElements(_x_, _y_, _comparefn_).\n          1. Let _sortedList_ be ? SortIndexedProperties(_O_, _len_, _SortCompare_, ~read-through-holes~).\n          1. Let _j_ be 0.\n          1. Repeat, while _j_ < _len_,\n            1. Perform ! CreateDataPropertyOrThrow(_A_, ! ToString(𝔽(_j_)), _sortedList_[_j_]).\n            1. Set _j_ to _j_ + 1.\n          1. Return _A_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"toSpliced"}},"params":[{"name":"start","ty":"Unknown","kind":{"Normal":{}}},{"name":"skipCount","ty":"Unknown","kind":{"Normal":{}}},{"name":"items","ty":"Unknown","kind":{"Variadic":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_O_).\n  1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n  1. If _relativeStart_ is -∞, let _actualStart_ be 0.\n  1. Else if _relativeStart_ < 0, let _actualStart_ be max(_len_ + _relativeStart_, 0).\n  1. Else, let _actualStart_ be min(_relativeStart_, _len_).\n  1. Let _insertCount_ be the number of elements in _items_.\n  1. If _start_ is not present, then\n    1. Let _actualSkipCount_ be 0.\n  1. Else if _skipCount_ is not present, then\n    1. Let _actualSkipCount_ be _len_ - _actualStart_.\n  1. Else,\n    1. Let _sc_ be ? ToIntegerOrInfinity(_skipCount_).\n    1. Let _actualSkipCount_ be the result of clamping _sc_ between 0 and _len_ - _actualStart_.\n  1. Let _newLen_ be _len_ + _insertCount_ - _actualSkipCount_.\n  1. If _newLen_ > 2<sup>53</sup> - 1, throw a *TypeError* exception.\n  1. Let _A_ be ? ArrayCreate(_newLen_).\n  1. Let _i_ be 0.\n  1. Let _r_ be _actualStart_ + _actualSkipCount_.\n  1. Repeat, while _i_ < _actualStart_,\n    1. Let _Pi_ be ! ToString(𝔽(_i_)).\n    1. Let _iValue_ be ? Get(_O_, _Pi_).\n    1. Perform ! CreateDataPropertyOrThrow(_A_, _Pi_, _iValue_).\n    1. Set _i_ to _i_ + 1.\n  1. For each _E_ of _items_, do\n    1. Let _Pi_ be ! ToString(𝔽(_i_)).\n    1. Perform ! CreateDataPropertyOrThrow(_A_, _Pi_, _E_).\n    1. Set _i_ to _i_ + 1.\n  1. Repeat, while _i_ < _newLen_,\n    1. Let _Pi_ be ! ToString(𝔽(_i_)).\n    1. Let _from_ be ! ToString(𝔽(_r_)).\n    1. Let _fromValue_ be ? Get(_O_, _from_).\n    1. Perform ! CreateDataPropertyOrThrow(_A_, _Pi_, _fromValue_).\n    1. Set _i_ to _i_ + 1.\n    1. Set _r_ to _r_ + 1.\n  1. Return _A_.","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n          1. If _relativeStart_ is -∞, let _actualStart_ be 0.\n          1. Else if _relativeStart_ < 0, let _actualStart_ be max(_len_ + _relativeStart_, 0).\n          1. Else, let _actualStart_ be min(_relativeStart_, _len_).\n          1. Let _insertCount_ be the number of elements in _items_.\n          1. If _start_ is not present, then\n            1. Let _actualSkipCount_ be 0.\n          1. Else if _skipCount_ is not present, then\n            1. Let _actualSkipCount_ be _len_ - _actualStart_.\n          1. Else,\n            1. Let _sc_ be ? ToIntegerOrInfinity(_skipCount_).\n            1. Let _actualSkipCount_ be the result of clamping _sc_ between 0 and _len_ - _actualStart_.\n          1. Let _newLen_ be _len_ + _insertCount_ - _actualSkipCount_.\n          1. If _newLen_ > 2<sup>53</sup> - 1, throw a *TypeError* exception.\n          1. Let _A_ be ? ArrayCreate(_newLen_).\n          1. Let _i_ be 0.\n          1. Let _r_ be _actualStart_ + _actualSkipCount_.\n          1. Repeat, while _i_ < _actualStart_,\n            1. Let _Pi_ be ! ToString(𝔽(_i_)).\n            1. Let _iValue_ be ? Get(_O_, _Pi_).\n            1. Perform ! CreateDataPropertyOrThrow(_A_, _Pi_, _iValue_).\n            1. Set _i_ to _i_ + 1.\n          1. For each element _E_ of _items_, do\n            1. Let _Pi_ be ! ToString(𝔽(_i_)).\n            1. Perform ! CreateDataPropertyOrThrow(_A_, _Pi_, _E_).\n            1. Set _i_ to _i_ + 1.\n          1. Repeat, while _i_ < _newLen_,\n            1. Let _Pi_ be ! ToString(𝔽(_i_)).\n            1. Let _from_ be ! ToString(𝔽(_r_)).\n            1. Let _fromValue_ be ? Get(_O_, _from_).\n            1. Perform ! CreateDataPropertyOrThrow(_A_, _Pi_, _fromValue_).\n            1. Set _i_ to _i_ + 1.\n            1. Set _r_ to _r_ + 1.\n          1. Return _A_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"toString"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _array_ be ? ToObject(*this* value).\n  1. Let _func_ be ? Get(_array_, *\"join\"*).\n  1. If IsCallable(_func_) is *false*, set _func_ to %Object.prototype.toString%.\n  1. Return ? Call(_func_, _array_).","code":"\n          1. Let _array_ be ? ToObject(*this* value).\n          1. Let _func_ be ? Get(_array_, *\"join\"*).\n          1. If IsCallable(_func_) is *false*, set _func_ to the intrinsic function %Object.prototype.toString%.\n          1. Return ? Call(_func_, _array_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"unshift"}},"params":[{"name":"items","ty":"Unknown","kind":{"Variadic":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_O_).\n  1. Let _argCount_ be the number of elements in _items_.\n  1. If _argCount_ > 0, then\n    1. If _len_ + _argCount_ > 2<sup>53</sup> - 1, throw a *TypeError* exception.\n    1. Let _k_ be _len_.\n    1. Repeat, while _k_ > 0,\n      1. Let _from_ be ! ToString(𝔽(_k_ - 1)).\n      1. Let _to_ be ! ToString(𝔽(_k_ + _argCount_ - 1)).\n      1. Let _fromPresent_ be ? HasProperty(_O_, _from_).\n      1. If _fromPresent_ is *true*, then\n        1. Let _fromValue_ be ? Get(_O_, _from_).\n        1. Perform ? Set(_O_, _to_, _fromValue_, *true*).\n      1. Else,\n        1. Assert: _fromPresent_ is *false*.\n        1. Perform ? DeletePropertyOrThrow(_O_, _to_).\n      1. Set _k_ to _k_ - 1.\n    1. Let _j_ be *+0*<sub>𝔽</sub>.\n    1. For each _E_ of _items_, do\n      1. Perform ? Set(_O_, ! ToString(_j_), _E_, *true*).\n      1. Set _j_ to _j_ + *1*<sub>𝔽</sub>.\n  1. Perform ? Set(_O_, *\"length\"*, 𝔽(_len_ + _argCount_), *true*).\n  1. Return 𝔽(_len_ + _argCount_).","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _argCount_ be the number of elements in _items_.\n          1. If _argCount_ > 0, then\n            1. If _len_ + _argCount_ > 2<sup>53</sup> - 1, throw a *TypeError* exception.\n            1. Let _k_ be _len_.\n            1. Repeat, while _k_ > 0,\n              1. Let _from_ be ! ToString(𝔽(_k_ - 1)).\n              1. Let _to_ be ! ToString(𝔽(_k_ + _argCount_ - 1)).\n              1. Let _fromPresent_ be ? HasProperty(_O_, _from_).\n              1. If _fromPresent_ is *true*, then\n                1. Let _fromValue_ be ? Get(_O_, _from_).\n                1. Perform ? Set(_O_, _to_, _fromValue_, *true*).\n              1. Else,\n                1. Assert: _fromPresent_ is *false*.\n                1. Perform ? DeletePropertyOrThrow(_O_, _to_).\n              1. Set _k_ to _k_ - 1.\n            1. Let _j_ be *+0*<sub>𝔽</sub>.\n            1. For each element _E_ of _items_, do\n              1. Perform ? Set(_O_, ! ToString(_j_), _E_, *true*).\n              1. Set _j_ to _j_ + *1*<sub>𝔽</sub>.\n          1. Perform ? Set(_O_, *\"length\"*, 𝔽(_len_ + _argCount_), *true*).\n          1. Return 𝔽(_len_ + _argCount_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"values"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Return CreateArrayIterator(_O_, ~value~).","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Return CreateArrayIterator(_O_, ~value~).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"name":"with"}},"params":[{"name":"index","ty":"Unknown","kind":{"Normal":{}}},{"name":"value","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be ? ToObject(*this* value).\n  1. Let _len_ be ? LengthOfArrayLike(_O_).\n  1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).\n  1. If _relativeIndex_ ≥ 0, let _actualIndex_ be _relativeIndex_.\n  1. Else, let _actualIndex_ be _len_ + _relativeIndex_.\n  1. If _actualIndex_ ≥ _len_ or _actualIndex_ < 0, throw a *RangeError* exception.\n  1. Let _A_ be ? ArrayCreate(_len_).\n  1. Let _k_ be 0.\n  1. Repeat, while _k_ < _len_,\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. If _k_ is _actualIndex_, let _fromValue_ be _value_.\n    1. Else, let _fromValue_ be ? Get(_O_, _Pk_).\n    1. Perform ! CreateDataPropertyOrThrow(_A_, _Pk_, _fromValue_).\n    1. Set _k_ to _k_ + 1.\n  1. Return _A_.","code":"\n          1. Let _O_ be ? ToObject(*this* value).\n          1. Let _len_ be ? LengthOfArrayLike(_O_).\n          1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).\n          1. If _relativeIndex_ ≥ 0, let _actualIndex_ be _relativeIndex_.\n          1. Else, let _actualIndex_ be _len_ + _relativeIndex_.\n          1. If _actualIndex_ ≥ _len_ or _actualIndex_ < 0, throw a *RangeError* exception.\n          1. Let _A_ be ? ArrayCreate(_len_).\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. If _k_ is _actualIndex_, let _fromValue_ be _value_.\n            1. Else, let _fromValue_ be ? Get(_O_, _Pk_).\n            1. Perform ! CreateDataPropertyOrThrow(_A_, _Pk_, _fromValue_).\n            1. Set _k_ to _k_ + 1.\n          1. Return _A_.\n        "},{"head":{"BuiltinHead":{"path":{"SymbolAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Array"}},"name":"prototype"}},"symbol":"unscopables"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _unscopableList_ be OrdinaryObjectCreate(*null*).\n  1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"at\"*, *true*).\n  1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"copyWithin\"*, *true*).\n  1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"entries\"*, *true*).\n  1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"fill\"*, *true*).\n  1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"find\"*, *true*).\n  1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"findIndex\"*, *true*).\n  1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"findLast\"*, *true*).\n  1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"findLastIndex\"*, *true*).\n  1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"flat\"*, *true*).\n  1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"flatMap\"*, *true*).\n  1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"includes\"*, *true*).\n  1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"keys\"*, *true*).\n  1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"toReversed\"*, *true*).\n  1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"toSorted\"*, *true*).\n  1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"toSpliced\"*, *true*).\n  1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"values\"*, *true*).\n  1. Return _unscopableList_.","code":"\n          1. Let _unscopableList_ be OrdinaryObjectCreate(*null*).\n          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"at\"*, *true*).\n          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"copyWithin\"*, *true*).\n          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"entries\"*, *true*).\n          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"fill\"*, *true*).\n          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"find\"*, *true*).\n          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"findIndex\"*, *true*).\n          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"findLast\"*, *true*).\n          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"findLastIndex\"*, *true*).\n          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"flat\"*, *true*).\n          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"flatMap\"*, *true*).\n          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"includes\"*, *true*).\n          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"keys\"*, *true*).\n          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"toReversed\"*, *true*).\n          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"toSorted\"*, *true*).\n          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"toSpliced\"*, *true*).\n          1. Perform ! CreateDataPropertyOrThrow(_unscopableList_, *\"values\"*, *true*).\n          1. Return _unscopableList_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CreateArrayIterator","params":[{"name":"array","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"kind","ty":"Enum[~key+value~, ~key~, ~value~]","kind":{"Normal":{}}}],"retTy":"Record[Generator]"}},"body":"\n  1. Let _closure_ be a new Abstract Closure with no parameters that captures _kind_ and _array_ and performs the following steps when called:\n    1. Let _index_ be 0.\n    1. Repeat, \n      1. If _array_ has a [[TypedArrayName]] internal slot, then\n        1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_array_, ~seq-cst~).\n        1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.\n        1. Let _len_ be TypedArrayLength(_taRecord_).\n      1. Else,\n        1. Let _len_ be ? LengthOfArrayLike(_array_).\n      1. If _index_ ≥ _len_, return NormalCompletion(*undefined*).\n      1. Let _indexNumber_ be 𝔽(_index_).\n      1. If _kind_ is ~key~, then\n        1. Let _result_ be _indexNumber_.\n      1. Else,\n        1. Let _elementKey_ be ! ToString(_indexNumber_).\n        1. Let _elementValue_ be ? Get(_array_, _elementKey_).\n        1. If _kind_ is ~value~, then\n          1. Let _result_ be _elementValue_.\n        1. Else,\n          1. Assert: _kind_ is ~key+value~.\n          1. Let _result_ be CreateArrayFromList(« _indexNumber_, _elementValue_ »).\n      1. Perform ? GeneratorYield(CreateIterResultObject(_result_, *false*)).\n      1. Set _index_ to _index_ + 1.\n  1. Return CreateIteratorFromClosure(_closure_, *\"%ArrayIteratorPrototype%\"*, %ArrayIteratorPrototype%).","code":"\n          1. Let _closure_ be a new Abstract Closure with no parameters that captures _kind_ and _array_ and performs the following steps when called:\n            1. Let _index_ be 0.\n            1. Repeat,\n              1. If _array_ has a [[TypedArrayName]] internal slot, then\n                1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_array_, ~seq-cst~).\n                1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.\n                1. Let _len_ be TypedArrayLength(_taRecord_).\n              1. Else,\n                1. Let _len_ be ? LengthOfArrayLike(_array_).\n              1. If _index_ ≥ _len_, return NormalCompletion(*undefined*).\n              1. Let _indexNumber_ be 𝔽(_index_).\n              1. If _kind_ is ~key~, then\n                1. Let _result_ be _indexNumber_.\n              1. Else,\n                1. Let _elementKey_ be ! ToString(_indexNumber_).\n                1. Let _elementValue_ be ? Get(_array_, _elementKey_).\n                1. If _kind_ is ~value~, then\n                  1. Let _result_ be _elementValue_.\n                1. Else,\n                  1. Assert: _kind_ is ~key+value~.\n                  1. Let _result_ be CreateArrayFromList(« _indexNumber_, _elementValue_ »).\n              1. Perform ? GeneratorYield(CreateIterResultObject(_result_, *false*)).\n              1. Set _index_ to _index_ + 1.\n          1. Return CreateIteratorFromClosure(_closure_, *\"%ArrayIteratorPrototype%\"*, %ArrayIteratorPrototype%).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"ArrayIteratorPrototype"}},"name":"next"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Return ? GeneratorResume(*this* value, ~empty~, *\"%ArrayIteratorPrototype%\"*).","code":"\n            1. Return ? GeneratorResume(*this* value, ~empty~, *\"%ArrayIteratorPrototype%\"*).\n          "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"TypedArray"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Throw a *TypeError* exception.","code":"\n          1. Throw a *TypeError* exception.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"from"}},"params":[{"name":"source","ty":"Unknown","kind":{"Normal":{}}},{"name":"mapfn","ty":"Unknown","kind":{"Optional":{}}},{"name":"thisArg","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _C_ be *this* value.\n  1. If IsConstructor(_C_) is *false*, throw a *TypeError* exception.\n  1. If _mapfn_ is *undefined*, then\n    1. Let _mapping_ be *false*.\n  1. Else,\n    1. If IsCallable(_mapfn_) is *false*, throw a *TypeError* exception.\n    1. Let _mapping_ be *true*.\n  1. Let _usingIterator_ be ? GetMethod(_source_, @@iterator).\n  1. If _usingIterator_ is not *undefined*, then\n    1. Let _values_ be ? IteratorToList(? GetIteratorFromMethod(_source_, _usingIterator_)).\n    1. Let _len_ be the number of elements in _values_.\n    1. Let _targetObj_ be ? TypedArrayCreateFromConstructor(_C_, « 𝔽(_len_) »).\n    1. Let _k_ be 0.\n    1. Repeat, while _k_ < _len_,\n      1. Let _Pk_ be ! ToString(𝔽(_k_)).\n      1. Let _kValue_ be _values_[0].\n      1. Remove the first element from _values_.\n      1. If _mapping_ is *true*, then\n        1. Let _mappedValue_ be ? Call(_mapfn_, _thisArg_, « _kValue_, 𝔽(_k_) »).\n      1. Else,\n        1. Let _mappedValue_ be _kValue_.\n      1. Perform ? Set(_targetObj_, _Pk_, _mappedValue_, *true*).\n      1. Set _k_ to _k_ + 1.\n    1. Assert: _values_ is now an empty List..\n    1. Return _targetObj_.\n  1. NOTE: _source_ is not an Iterable so assume it is already an array-like object.\n  1. Let _arrayLike_ be ! ToObject(_source_).\n  1. Let _len_ be ? LengthOfArrayLike(_arrayLike_).\n  1. Let _targetObj_ be ? TypedArrayCreateFromConstructor(_C_, « 𝔽(_len_) »).\n  1. Let _k_ be 0.\n  1. Repeat, while _k_ < _len_,\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. Let _kValue_ be ? Get(_arrayLike_, _Pk_).\n    1. If _mapping_ is *true*, then\n      1. Let _mappedValue_ be ? Call(_mapfn_, _thisArg_, « _kValue_, 𝔽(_k_) »).\n    1. Else,\n      1. Let _mappedValue_ be _kValue_.\n    1. Perform ? Set(_targetObj_, _Pk_, _mappedValue_, *true*).\n    1. Set _k_ to _k_ + 1.\n  1. Return _targetObj_.","code":"\n          1. Let _C_ be the *this* value.\n          1. If IsConstructor(_C_) is *false*, throw a *TypeError* exception.\n          1. If _mapfn_ is *undefined*, then\n            1. Let _mapping_ be *false*.\n          1. Else,\n            1. If IsCallable(_mapfn_) is *false*, throw a *TypeError* exception.\n            1. Let _mapping_ be *true*.\n          1. Let _usingIterator_ be ? GetMethod(_source_, @@iterator).\n          1. If _usingIterator_ is not *undefined*, then\n            1. Let _values_ be ? IteratorToList(? GetIteratorFromMethod(_source_, _usingIterator_)).\n            1. Let _len_ be the number of elements in _values_.\n            1. Let _targetObj_ be ? TypedArrayCreateFromConstructor(_C_, « 𝔽(_len_) »).\n            1. Let _k_ be 0.\n            1. Repeat, while _k_ < _len_,\n              1. Let _Pk_ be ! ToString(𝔽(_k_)).\n              1. Let _kValue_ be the first element of _values_.\n              1. Remove the first element from _values_.\n              1. If _mapping_ is *true*, then\n                1. Let _mappedValue_ be ? Call(_mapfn_, _thisArg_, « _kValue_, 𝔽(_k_) »).\n              1. Else,\n                1. Let _mappedValue_ be _kValue_.\n              1. Perform ? Set(_targetObj_, _Pk_, _mappedValue_, *true*).\n              1. Set _k_ to _k_ + 1.\n            1. Assert: _values_ is now an empty List.\n            1. Return _targetObj_.\n          1. NOTE: _source_ is not an Iterable so assume it is already an array-like object.\n          1. Let _arrayLike_ be ! ToObject(_source_).\n          1. Let _len_ be ? LengthOfArrayLike(_arrayLike_).\n          1. Let _targetObj_ be ? TypedArrayCreateFromConstructor(_C_, « 𝔽(_len_) »).\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kValue_ be ? Get(_arrayLike_, _Pk_).\n            1. If _mapping_ is *true*, then\n              1. Let _mappedValue_ be ? Call(_mapfn_, _thisArg_, « _kValue_, 𝔽(_k_) »).\n            1. Else,\n              1. Let _mappedValue_ be _kValue_.\n            1. Perform ? Set(_targetObj_, _Pk_, _mappedValue_, *true*).\n            1. Set _k_ to _k_ + 1.\n          1. Return _targetObj_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"of"}},"params":[{"name":"items","ty":"Unknown","kind":{"Variadic":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _len_ be the number of elements in _items_.\n  1. Let _C_ be *this* value.\n  1. If IsConstructor(_C_) is *false*, throw a *TypeError* exception.\n  1. Let _newObj_ be ? TypedArrayCreateFromConstructor(_C_, « 𝔽(_len_) »).\n  1. Let _k_ be 0.\n  1. Repeat, while _k_ < _len_,\n    1. Let _kValue_ be _items_[_k_].\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. Perform ? Set(_newObj_, _Pk_, _kValue_, *true*).\n    1. Set _k_ to _k_ + 1.\n  1. Return _newObj_.","code":"\n          1. Let _len_ be the number of elements in _items_.\n          1. Let _C_ be the *this* value.\n          1. If IsConstructor(_C_) is *false*, throw a *TypeError* exception.\n          1. Let _newObj_ be ? TypedArrayCreateFromConstructor(_C_, « 𝔽(_len_) »).\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _kValue_ be _items_[_k_].\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Perform ? Set(_newObj_, _Pk_, _kValue_, *true*).\n            1. Set _k_ to _k_ + 1.\n          1. Return _newObj_.\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"SymbolAccess":{"base":{"Base":{"name":"TypedArray"}},"symbol":"species"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Return *this* value.","code":"\n          1. Return the *this* value.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"at"}},"params":[{"name":"index","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n  1. Let _len_ be TypedArrayLength(_taRecord_).\n  1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).\n  1. If _relativeIndex_ ≥ 0, then\n    1. Let _k_ be _relativeIndex_.\n  1. Else,\n    1. Let _k_ be _len_ + _relativeIndex_.\n  1. If _k_ < 0 or _k_ ≥ _len_, return *undefined*.\n  1. Return ! Get(_O_, ! ToString(𝔽(_k_))).","code":"\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).\n          1. If _relativeIndex_ ≥ 0, then\n            1. Let _k_ be _relativeIndex_.\n          1. Else,\n            1. Let _k_ be _len_ + _relativeIndex_.\n          1. If _k_ < 0 or _k_ ≥ _len_, return *undefined*.\n          1. Return ! Get(_O_, ! ToString(𝔽(_k_))).\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"buffer"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).\n  1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.\n  1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].\n  1. Return _buffer_.","code":"\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).\n          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.\n          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].\n          1. Return _buffer_.\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"byteLength"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).\n  1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.\n  1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).\n  1. Let _size_ be TypedArrayByteLength(_taRecord_).\n  1. Return 𝔽(_size_).","code":"\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).\n          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.\n          1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).\n          1. Let _size_ be TypedArrayByteLength(_taRecord_).\n          1. Return 𝔽(_size_).\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"byteOffset"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).\n  1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.\n  1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).\n  1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, return *+0*<sub>𝔽</sub>.\n  1. Let _offset_ be _O_.[[ByteOffset]].\n  1. Return 𝔽(_offset_).","code":"\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).\n          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.\n          1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).\n          1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, return *+0*<sub>𝔽</sub>.\n          1. Let _offset_ be _O_.[[ByteOffset]].\n          1. Return 𝔽(_offset_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"copyWithin"}},"params":[{"name":"target","ty":"Unknown","kind":{"Normal":{}}},{"name":"start","ty":"Unknown","kind":{"Normal":{}}},{"name":"end","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n  1. Let _len_ be TypedArrayLength(_taRecord_).\n  1. Let _relativeTarget_ be ? ToIntegerOrInfinity(_target_).\n  1. If _relativeTarget_ = -∞, let _targetIndex_ be 0.\n  1. Else if _relativeTarget_ < 0, let _targetIndex_ be max(_len_ + _relativeTarget_, 0).\n  1. Else, let _targetIndex_ be min(_relativeTarget_, _len_).\n  1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n  1. If _relativeStart_ = -∞, let _startIndex_ be 0.\n  1. Else if _relativeStart_ < 0, let _startIndex_ be max(_len_ + _relativeStart_, 0).\n  1. Else, let _startIndex_ be min(_relativeStart_, _len_).\n  1. If _end_ is *undefined*, let _relativeEnd_ be _len_.\n  1. Else, let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).\n  1. If _relativeEnd_ = -∞, let _endIndex_ be 0.\n  1. Else if _relativeEnd_ < 0, let _endIndex_ be max(_len_ + _relativeEnd_, 0).\n  1. Else, let _endIndex_ be min(_relativeEnd_, _len_).\n  1. Let _count_ be min(_endIndex_ - _startIndex_, _len_ - _targetIndex_).\n  1. If _count_ > 0, then\n    1. NOTE: The copying must be performed in a manner that preserves the bit-level encoding of the source data.\n    1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].\n    1. Set _taRecord_ to MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).\n    1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.\n    1. Set _len_ to TypedArrayLength(_taRecord_).\n    1. Let _elementSize_ be TypedArrayElementSize(_O_).\n    1. Let _byteOffset_ be _O_.[[ByteOffset]].\n    1. Let _bufferByteLimit_ be _len_ × _elementSize_ + _byteOffset_.\n    1. Let _toByteIndex_ be _targetIndex_ × _elementSize_ + _byteOffset_.\n    1. Let _fromByteIndex_ be _startIndex_ × _elementSize_ + _byteOffset_.\n    1. Let _countBytes_ be _count_ × _elementSize_.\n    1. If _fromByteIndex_ < _toByteIndex_ and _toByteIndex_ < _fromByteIndex_ + _countBytes_, then\n      1. Let _direction_ be -1.\n      1. Set _fromByteIndex_ to _fromByteIndex_ + _countBytes_ - 1.\n      1. Set _toByteIndex_ to _toByteIndex_ + _countBytes_ - 1.\n    1. Else,\n      1. Let _direction_ be 1.\n    1. Repeat, while _countBytes_ > 0,\n      1. If _fromByteIndex_ < _bufferByteLimit_ and _toByteIndex_ < _bufferByteLimit_, then\n        1. Let _value_ be GetValueFromBuffer(_buffer_, _fromByteIndex_, ~uint8~, *true*, ~unordered~).\n        1. Perform SetValueInBuffer(_buffer_, _toByteIndex_, ~uint8~, _value_, *true*, ~unordered~).\n        1. Set _fromByteIndex_ to _fromByteIndex_ + _direction_.\n        1. Set _toByteIndex_ to _toByteIndex_ + _direction_.\n        1. Set _countBytes_ to _countBytes_ - 1.\n      1. Else,\n        1. Set _countBytes_ to 0.\n  1. Return _O_.","code":"\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. Let _relativeTarget_ be ? ToIntegerOrInfinity(_target_).\n          1. If _relativeTarget_ = -∞, let _targetIndex_ be 0.\n          1. Else if _relativeTarget_ < 0, let _targetIndex_ be max(_len_ + _relativeTarget_, 0).\n          1. Else, let _targetIndex_ be min(_relativeTarget_, _len_).\n          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n          1. If _relativeStart_ = -∞, let _startIndex_ be 0.\n          1. Else if _relativeStart_ < 0, let _startIndex_ be max(_len_ + _relativeStart_, 0).\n          1. Else, let _startIndex_ be min(_relativeStart_, _len_).\n          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).\n          1. If _relativeEnd_ = -∞, let _endIndex_ be 0.\n          1. Else if _relativeEnd_ < 0, let _endIndex_ be max(_len_ + _relativeEnd_, 0).\n          1. Else, let _endIndex_ be min(_relativeEnd_, _len_).\n          1. Let _count_ be min(_endIndex_ - _startIndex_, _len_ - _targetIndex_).\n          1. If _count_ > 0, then\n            1. NOTE: The copying must be performed in a manner that preserves the bit-level encoding of the source data.\n            1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].\n            1. Set _taRecord_ to MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).\n            1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.\n            1. Set _len_ to TypedArrayLength(_taRecord_).\n            1. Let _elementSize_ be TypedArrayElementSize(_O_).\n            1. Let _byteOffset_ be _O_.[[ByteOffset]].\n            1. Let _bufferByteLimit_ be (_len_ × _elementSize_) + _byteOffset_.\n            1. Let _toByteIndex_ be (_targetIndex_ × _elementSize_) + _byteOffset_.\n            1. Let _fromByteIndex_ be (_startIndex_ × _elementSize_) + _byteOffset_.\n            1. Let _countBytes_ be _count_ × _elementSize_.\n            1. If _fromByteIndex_ < _toByteIndex_ and _toByteIndex_ < _fromByteIndex_ + _countBytes_, then\n              1. Let _direction_ be -1.\n              1. Set _fromByteIndex_ to _fromByteIndex_ + _countBytes_ - 1.\n              1. Set _toByteIndex_ to _toByteIndex_ + _countBytes_ - 1.\n            1. Else,\n              1. Let _direction_ be 1.\n            1. Repeat, while _countBytes_ > 0,\n              1. If _fromByteIndex_ < _bufferByteLimit_ and _toByteIndex_ < _bufferByteLimit_, then\n                1. Let _value_ be GetValueFromBuffer(_buffer_, _fromByteIndex_, ~uint8~, *true*, ~unordered~).\n                1. Perform SetValueInBuffer(_buffer_, _toByteIndex_, ~uint8~, _value_, *true*, ~unordered~).\n                1. Set _fromByteIndex_ to _fromByteIndex_ + _direction_.\n                1. Set _toByteIndex_ to _toByteIndex_ + _direction_.\n                1. Set _countBytes_ to _countBytes_ - 1.\n              1. Else,\n                1. Set _countBytes_ to 0.\n          1. Return _O_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"entries"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Perform ? ValidateTypedArray(_O_, ~seq-cst~).\n  1. Return CreateArrayIterator(_O_, ~key+value~).","code":"\n          1. Let _O_ be the *this* value.\n          1. Perform ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Return CreateArrayIterator(_O_, ~key+value~).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"every"}},"params":[{"name":"callbackfn","ty":"Unknown","kind":{"Normal":{}}},{"name":"thisArg","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n  1. Let _len_ be TypedArrayLength(_taRecord_).\n  1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n  1. Let _k_ be 0.\n  1. Repeat, while _k_ < _len_,\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. Let _kValue_ be ! Get(_O_, _Pk_).\n    1. Let _testResult_ be ToBoolean(? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).\n    1. If _testResult_ is *false*, return *false*.\n    1. Set _k_ to _k_ + 1.\n  1. Return *true*.","code":"\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kValue_ be ! Get(_O_, _Pk_).\n            1. Let _testResult_ be ToBoolean(? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).\n            1. If _testResult_ is *false*, return *false*.\n            1. Set _k_ to _k_ + 1.\n          1. Return *true*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"fill"}},"params":[{"name":"value","ty":"Unknown","kind":{"Normal":{}}},{"name":"start","ty":"Unknown","kind":{"Optional":{}}},{"name":"end","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n  1. Let _len_ be TypedArrayLength(_taRecord_).\n  1. If _O_.[[ContentType]] is ~bigint~, set _value_ to ? ToBigInt(_value_).\n  1. Else, set _value_ to ? ToNumber(_value_).\n  1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n  1. If _relativeStart_ = -∞, let _startIndex_ be 0.\n  1. Else if _relativeStart_ < 0, let _startIndex_ be max(_len_ + _relativeStart_, 0).\n  1. Else, let _startIndex_ be min(_relativeStart_, _len_).\n  1. If _end_ is *undefined*, let _relativeEnd_ be _len_.\n  1. Else, let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).\n  1. If _relativeEnd_ = -∞, let _endIndex_ be 0.\n  1. Else if _relativeEnd_ < 0, let _endIndex_ be max(_len_ + _relativeEnd_, 0).\n  1. Else, let _endIndex_ be min(_relativeEnd_, _len_).\n  1. Set _taRecord_ to MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).\n  1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.\n  1. Set _len_ to TypedArrayLength(_taRecord_).\n  1. Set _endIndex_ to min(_endIndex_, _len_).\n  1. Let _k_ be _startIndex_.\n  1. Repeat, while _k_ < _endIndex_,\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. Perform ! Set(_O_, _Pk_, _value_, *true*).\n    1. Set _k_ to _k_ + 1.\n  1. Return _O_.","code":"\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. If _O_.[[ContentType]] is ~bigint~, set _value_ to ? ToBigInt(_value_).\n          1. Otherwise, set _value_ to ? ToNumber(_value_).\n          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n          1. If _relativeStart_ = -∞, let _startIndex_ be 0.\n          1. Else if _relativeStart_ < 0, let _startIndex_ be max(_len_ + _relativeStart_, 0).\n          1. Else, let _startIndex_ be min(_relativeStart_, _len_).\n          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).\n          1. If _relativeEnd_ = -∞, let _endIndex_ be 0.\n          1. Else if _relativeEnd_ < 0, let _endIndex_ be max(_len_ + _relativeEnd_, 0).\n          1. Else, let _endIndex_ be min(_relativeEnd_, _len_).\n          1. Set _taRecord_ to MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).\n          1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.\n          1. Set _len_ to TypedArrayLength(_taRecord_).\n          1. Set _endIndex_ to min(_endIndex_, _len_).\n          1. Let _k_ be _startIndex_.\n          1. Repeat, while _k_ < _endIndex_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Perform ! Set(_O_, _Pk_, _value_, *true*).\n            1. Set _k_ to _k_ + 1.\n          1. Return _O_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"filter"}},"params":[{"name":"callbackfn","ty":"Unknown","kind":{"Normal":{}}},{"name":"thisArg","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n  1. Let _len_ be TypedArrayLength(_taRecord_).\n  1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n  1. Let _kept_ be « ».\n  1. Let _captured_ be 0.\n  1. Let _k_ be 0.\n  1. Repeat, while _k_ < _len_,\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. Let _kValue_ be ! Get(_O_, _Pk_).\n    1. Let _selected_ be ToBoolean(? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).\n    1. If _selected_ is *true*, then\n      1. Append _kValue_ to _kept_.\n      1. Set _captured_ to _captured_ + 1.\n    1. Set _k_ to _k_ + 1.\n  1. Let _A_ be ? TypedArraySpeciesCreate(_O_, « 𝔽(_captured_) »).\n  1. Let _n_ be 0.\n  1. For each _e_ of _kept_, do\n    1. Perform ! Set(_A_, ! ToString(𝔽(_n_)), _e_, *true*).\n    1. Set _n_ to _n_ + 1.\n  1. Return _A_.","code":"\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. Let _kept_ be a new empty List.\n          1. Let _captured_ be 0.\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kValue_ be ! Get(_O_, _Pk_).\n            1. Let _selected_ be ToBoolean(? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).\n            1. If _selected_ is *true*, then\n              1. Append _kValue_ to _kept_.\n              1. Set _captured_ to _captured_ + 1.\n            1. Set _k_ to _k_ + 1.\n          1. Let _A_ be ? TypedArraySpeciesCreate(_O_, « 𝔽(_captured_) »).\n          1. Let _n_ be 0.\n          1. For each element _e_ of _kept_, do\n            1. Perform ! Set(_A_, ! ToString(𝔽(_n_)), _e_, *true*).\n            1. Set _n_ to _n_ + 1.\n          1. Return _A_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"find"}},"params":[{"name":"predicate","ty":"Unknown","kind":{"Normal":{}}},{"name":"thisArg","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n  1. Let _len_ be TypedArrayLength(_taRecord_).\n  1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_).\n  1. Return _findRec_.[[Value]].","code":"\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_).\n          1. Return _findRec_.[[Value]].\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"findIndex"}},"params":[{"name":"predicate","ty":"Unknown","kind":{"Normal":{}}},{"name":"thisArg","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n  1. Let _len_ be TypedArrayLength(_taRecord_).\n  1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_).\n  1. Return _findRec_.[[Index]].","code":"\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~ascending~, _predicate_, _thisArg_).\n          1. Return _findRec_.[[Index]].\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"findLast"}},"params":[{"name":"predicate","ty":"Unknown","kind":{"Normal":{}}},{"name":"thisArg","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n  1. Let _len_ be TypedArrayLength(_taRecord_).\n  1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_).\n  1. Return _findRec_.[[Value]].","code":"\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_).\n          1. Return _findRec_.[[Value]].\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"findLastIndex"}},"params":[{"name":"predicate","ty":"Unknown","kind":{"Normal":{}}},{"name":"thisArg","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n  1. Let _len_ be TypedArrayLength(_taRecord_).\n  1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_).\n  1. Return _findRec_.[[Index]].","code":"\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. Let _findRec_ be ? FindViaPredicate(_O_, _len_, ~descending~, _predicate_, _thisArg_).\n          1. Return _findRec_.[[Index]].\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"forEach"}},"params":[{"name":"callbackfn","ty":"Unknown","kind":{"Normal":{}}},{"name":"thisArg","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n  1. Let _len_ be TypedArrayLength(_taRecord_).\n  1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n  1. Let _k_ be 0.\n  1. Repeat, while _k_ < _len_,\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. Let _kValue_ be ! Get(_O_, _Pk_).\n    1. Perform ? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).\n    1. Set _k_ to _k_ + 1.\n  1. Return *undefined*.","code":"\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kValue_ be ! Get(_O_, _Pk_).\n            1. Perform ? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).\n            1. Set _k_ to _k_ + 1.\n          1. Return *undefined*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"includes"}},"params":[{"name":"searchElement","ty":"Unknown","kind":{"Normal":{}}},{"name":"fromIndex","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n  1. Let _len_ be TypedArrayLength(_taRecord_).\n  1. If _len_ = 0, return *false*.\n  1. Let _n_ be ? ToIntegerOrInfinity(_fromIndex_).\n  1. Assert: If _fromIndex_ is *undefined*, then _n_ is 0.\n  1. If _n_ = +∞, return *false*.\n  1. Else if _n_ = -∞, set _n_ to 0.\n  1. If _n_ ≥ 0, then\n    1. Let _k_ be _n_.\n  1. Else,\n    1. Let _k_ be _len_ + _n_.\n    1. If _k_ < 0, set _k_ to 0.\n  1. Repeat, while _k_ < _len_,\n    1. Let _elementK_ be ! Get(_O_, ! ToString(𝔽(_k_))).\n    1. If SameValueZero(_searchElement_, _elementK_) is *true*, return *true*.\n    1. Set _k_ to _k_ + 1.\n  1. Return *false*.","code":"\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. If _len_ = 0, return *false*.\n          1. Let _n_ be ? ToIntegerOrInfinity(_fromIndex_).\n          1. Assert: If _fromIndex_ is *undefined*, then _n_ is 0.\n          1. If _n_ = +∞, return *false*.\n          1. Else if _n_ = -∞, set _n_ to 0.\n          1. If _n_ ≥ 0, then\n            1. Let _k_ be _n_.\n          1. Else,\n            1. Let _k_ be _len_ + _n_.\n            1. If _k_ < 0, set _k_ to 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _elementK_ be ! Get(_O_, ! ToString(𝔽(_k_))).\n            1. If SameValueZero(_searchElement_, _elementK_) is *true*, return *true*.\n            1. Set _k_ to _k_ + 1.\n          1. Return *false*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"indexOf"}},"params":[{"name":"searchElement","ty":"Unknown","kind":{"Normal":{}}},{"name":"fromIndex","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n  1. Let _len_ be TypedArrayLength(_taRecord_).\n  1. If _len_ = 0, return *-1*<sub>𝔽</sub>.\n  1. Let _n_ be ? ToIntegerOrInfinity(_fromIndex_).\n  1. Assert: If _fromIndex_ is *undefined*, then _n_ is 0.\n  1. If _n_ = +∞, return *-1*<sub>𝔽</sub>.\n  1. Else if _n_ = -∞, set _n_ to 0.\n  1. If _n_ ≥ 0, then\n    1. Let _k_ be _n_.\n  1. Else,\n    1. Let _k_ be _len_ + _n_.\n    1. If _k_ < 0, set _k_ to 0.\n  1. Repeat, while _k_ < _len_,\n    1. Let _kPresent_ be ! HasProperty(_O_, ! ToString(𝔽(_k_))).\n    1. If _kPresent_ is *true*, then\n      1. Let _elementK_ be ! Get(_O_, ! ToString(𝔽(_k_))).\n      1. If IsStrictlyEqual(_searchElement_, _elementK_) is *true*, return 𝔽(_k_).\n    1. Set _k_ to _k_ + 1.\n  1. Return *-1*<sub>𝔽</sub>.","code":"\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. If _len_ = 0, return *-1*<sub>𝔽</sub>.\n          1. Let _n_ be ? ToIntegerOrInfinity(_fromIndex_).\n          1. Assert: If _fromIndex_ is *undefined*, then _n_ is 0.\n          1. If _n_ = +∞, return *-1*<sub>𝔽</sub>.\n          1. Else if _n_ = -∞, set _n_ to 0.\n          1. If _n_ ≥ 0, then\n            1. Let _k_ be _n_.\n          1. Else,\n            1. Let _k_ be _len_ + _n_.\n            1. If _k_ < 0, set _k_ to 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _kPresent_ be ! HasProperty(_O_, ! ToString(𝔽(_k_))).\n            1. If _kPresent_ is *true*, then\n              1. Let _elementK_ be ! Get(_O_, ! ToString(𝔽(_k_))).\n              1. If IsStrictlyEqual(_searchElement_, _elementK_) is *true*, return 𝔽(_k_).\n            1. Set _k_ to _k_ + 1.\n          1. Return *-1*<sub>𝔽</sub>.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"join"}},"params":[{"name":"separator","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n  1. Let _len_ be TypedArrayLength(_taRecord_).\n  1. If _separator_ is *undefined*, let _sep_ be *\",\"*.\n  1. Else, let _sep_ be ? ToString(_separator_).\n  1. Let _R_ be *\"\"*.\n  1. Let _k_ be 0.\n  1. Repeat, while _k_ < _len_,\n    1. If _k_ > 0, set _R_ to the string-concatenation of _R_ and _sep_.\n    1. Let _element_ be ! Get(_O_, ! ToString(𝔽(_k_))).\n    1. If _element_ is *undefined*, let _next_ be *\"\"*.\n    1. Else, let _next_ be ! ToString(_element_).\n    1. Set _R_ to the string-concatenation of _R_ and _next_.\n    1. Set _k_ to _k_ + 1.\n  1. Return _R_.","code":"\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. If _separator_ is *undefined*, let _sep_ be *\",\"*.\n          1. Else, let _sep_ be ? ToString(_separator_).\n          1. Let _R_ be the empty String.\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. If _k_ > 0, set _R_ to the string-concatenation of _R_ and _sep_.\n            1. Let _element_ be ! Get(_O_, ! ToString(𝔽(_k_))).\n            1. If _element_ is *undefined*, let _next_ be the empty String; otherwise, let _next_ be ! ToString(_element_).\n            1. Set _R_ to the string-concatenation of _R_ and _next_.\n            1. Set _k_ to _k_ + 1.\n          1. Return _R_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"keys"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Perform ? ValidateTypedArray(_O_, ~seq-cst~).\n  1. Return CreateArrayIterator(_O_, ~key~).","code":"\n          1. Let _O_ be the *this* value.\n          1. Perform ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Return CreateArrayIterator(_O_, ~key~).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"lastIndexOf"}},"params":[{"name":"searchElement","ty":"Unknown","kind":{"Normal":{}}},{"name":"fromIndex","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n  1. Let _len_ be TypedArrayLength(_taRecord_).\n  1. If _len_ = 0, return *-1*<sub>𝔽</sub>.\n  1. If _fromIndex_ is present, let _n_ be ? ToIntegerOrInfinity(_fromIndex_).\n  1. Else, let _n_ be _len_ - 1.\n  1. If _n_ = -∞, return *-1*<sub>𝔽</sub>.\n  1. If _n_ ≥ 0, then\n    1. Let _k_ be min(_n_, _len_ - 1).\n  1. Else,\n    1. Let _k_ be _len_ + _n_.\n  1. Repeat, while _k_ ≥ 0,\n    1. Let _kPresent_ be ! HasProperty(_O_, ! ToString(𝔽(_k_))).\n    1. If _kPresent_ is *true*, then\n      1. Let _elementK_ be ! Get(_O_, ! ToString(𝔽(_k_))).\n      1. If IsStrictlyEqual(_searchElement_, _elementK_) is *true*, return 𝔽(_k_).\n    1. Set _k_ to _k_ - 1.\n  1. Return *-1*<sub>𝔽</sub>.","code":"\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. If _len_ = 0, return *-1*<sub>𝔽</sub>.\n          1. If _fromIndex_ is present, let _n_ be ? ToIntegerOrInfinity(_fromIndex_); else let _n_ be _len_ - 1.\n          1. If _n_ = -∞, return *-1*<sub>𝔽</sub>.\n          1. If _n_ ≥ 0, then\n            1. Let _k_ be min(_n_, _len_ - 1).\n          1. Else,\n            1. Let _k_ be _len_ + _n_.\n          1. Repeat, while _k_ ≥ 0,\n            1. Let _kPresent_ be ! HasProperty(_O_, ! ToString(𝔽(_k_))).\n            1. If _kPresent_ is *true*, then\n              1. Let _elementK_ be ! Get(_O_, ! ToString(𝔽(_k_))).\n              1. If IsStrictlyEqual(_searchElement_, _elementK_) is *true*, return 𝔽(_k_).\n            1. Set _k_ to _k_ - 1.\n          1. Return *-1*<sub>𝔽</sub>.\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"length"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).\n  1. Assert: _O_ has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots..\n  1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).\n  1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, return *+0*<sub>𝔽</sub>.\n  1. Let _length_ be TypedArrayLength(_taRecord_).\n  1. Return 𝔽(_length_).","code":"\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).\n          1. Assert: _O_ has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.\n          1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).\n          1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, return *+0*<sub>𝔽</sub>.\n          1. Let _length_ be TypedArrayLength(_taRecord_).\n          1. Return 𝔽(_length_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"map"}},"params":[{"name":"callbackfn","ty":"Unknown","kind":{"Normal":{}}},{"name":"thisArg","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n  1. Let _len_ be TypedArrayLength(_taRecord_).\n  1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n  1. Let _A_ be ? TypedArraySpeciesCreate(_O_, « 𝔽(_len_) »).\n  1. Let _k_ be 0.\n  1. Repeat, while _k_ < _len_,\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. Let _kValue_ be ! Get(_O_, _Pk_).\n    1. Let _mappedValue_ be ? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).\n    1. Perform ? Set(_A_, _Pk_, _mappedValue_, *true*).\n    1. Set _k_ to _k_ + 1.\n  1. Return _A_.","code":"\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. Let _A_ be ? TypedArraySpeciesCreate(_O_, « 𝔽(_len_) »).\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kValue_ be ! Get(_O_, _Pk_).\n            1. Let _mappedValue_ be ? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »).\n            1. Perform ? Set(_A_, _Pk_, _mappedValue_, *true*).\n            1. Set _k_ to _k_ + 1.\n          1. Return _A_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"reduce"}},"params":[{"name":"callbackfn","ty":"Unknown","kind":{"Normal":{}}},{"name":"initialValue","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n  1. Let _len_ be TypedArrayLength(_taRecord_).\n  1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n  1. If _len_ = 0 and _initialValue_ is not present, throw a *TypeError* exception.\n  1. Let _k_ be 0.\n  1. Let _accumulator_ be *undefined*.\n  1. If _initialValue_ is present, then\n    1. Set _accumulator_ to _initialValue_.\n  1. Else,\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. Set _accumulator_ to ! Get(_O_, _Pk_).\n    1. Set _k_ to _k_ + 1.\n  1. Repeat, while _k_ < _len_,\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. Let _kValue_ be ! Get(_O_, _Pk_).\n    1. Set _accumulator_ to ? Call(_callbackfn_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »).\n    1. Set _k_ to _k_ + 1.\n  1. Return _accumulator_.","code":"\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. If _len_ = 0 and _initialValue_ is not present, throw a *TypeError* exception.\n          1. Let _k_ be 0.\n          1. Let _accumulator_ be *undefined*.\n          1. If _initialValue_ is present, then\n            1. Set _accumulator_ to _initialValue_.\n          1. Else,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Set _accumulator_ to ! Get(_O_, _Pk_).\n            1. Set _k_ to _k_ + 1.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kValue_ be ! Get(_O_, _Pk_).\n            1. Set _accumulator_ to ? Call(_callbackfn_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »).\n            1. Set _k_ to _k_ + 1.\n          1. Return _accumulator_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"reduceRight"}},"params":[{"name":"callbackfn","ty":"Unknown","kind":{"Normal":{}}},{"name":"initialValue","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n  1. Let _len_ be TypedArrayLength(_taRecord_).\n  1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n  1. If _len_ = 0 and _initialValue_ is not present, throw a *TypeError* exception.\n  1. Let _k_ be _len_ - 1.\n  1. Let _accumulator_ be *undefined*.\n  1. If _initialValue_ is present, then\n    1. Set _accumulator_ to _initialValue_.\n  1. Else,\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. Set _accumulator_ to ! Get(_O_, _Pk_).\n    1. Set _k_ to _k_ - 1.\n  1. Repeat, while _k_ ≥ 0,\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. Let _kValue_ be ! Get(_O_, _Pk_).\n    1. Set _accumulator_ to ? Call(_callbackfn_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »).\n    1. Set _k_ to _k_ - 1.\n  1. Return _accumulator_.","code":"\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. If _len_ = 0 and _initialValue_ is not present, throw a *TypeError* exception.\n          1. Let _k_ be _len_ - 1.\n          1. Let _accumulator_ be *undefined*.\n          1. If _initialValue_ is present, then\n            1. Set _accumulator_ to _initialValue_.\n          1. Else,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Set _accumulator_ to ! Get(_O_, _Pk_).\n            1. Set _k_ to _k_ - 1.\n          1. Repeat, while _k_ ≥ 0,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kValue_ be ! Get(_O_, _Pk_).\n            1. Set _accumulator_ to ? Call(_callbackfn_, *undefined*, « _accumulator_, _kValue_, 𝔽(_k_), _O_ »).\n            1. Set _k_ to _k_ - 1.\n          1. Return _accumulator_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"reverse"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n  1. Let _len_ be TypedArrayLength(_taRecord_).\n  1. Let _middle_ be floor(_len_ / 2).\n  1. Let _lower_ be 0.\n  1. Repeat, while _lower_ ≠ _middle_,\n    1. Let _upper_ be _len_ - _lower_ - 1.\n    1. Let _upperP_ be ! ToString(𝔽(_upper_)).\n    1. Let _lowerP_ be ! ToString(𝔽(_lower_)).\n    1. Let _lowerValue_ be ! Get(_O_, _lowerP_).\n    1. Let _upperValue_ be ! Get(_O_, _upperP_).\n    1. Perform ! Set(_O_, _lowerP_, _upperValue_, *true*).\n    1. Perform ! Set(_O_, _upperP_, _lowerValue_, *true*).\n    1. Set _lower_ to _lower_ + 1.\n  1. Return _O_.","code":"\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. Let _middle_ be floor(_len_ / 2).\n          1. Let _lower_ be 0.\n          1. Repeat, while _lower_ ≠ _middle_,\n            1. Let _upper_ be _len_ - _lower_ - 1.\n            1. Let _upperP_ be ! ToString(𝔽(_upper_)).\n            1. Let _lowerP_ be ! ToString(𝔽(_lower_)).\n            1. Let _lowerValue_ be ! Get(_O_, _lowerP_).\n            1. Let _upperValue_ be ! Get(_O_, _upperP_).\n            1. Perform ! Set(_O_, _lowerP_, _upperValue_, *true*).\n            1. Perform ! Set(_O_, _upperP_, _lowerValue_, *true*).\n            1. Set _lower_ to _lower_ + 1.\n          1. Return _O_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"set"}},"params":[{"name":"source","ty":"Unknown","kind":{"Normal":{}}},{"name":"offset","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _target_ be *this* value.\n  1. Perform ? RequireInternalSlot(_target_, [[TypedArrayName]]).\n  1. Assert: _target_ has a [[ViewedArrayBuffer]] internal slot.\n  1. Let _targetOffset_ be ? ToIntegerOrInfinity(_offset_).\n  1. If _targetOffset_ < 0, throw a *RangeError* exception.\n  1. If _source_ is an Object that has a [[TypedArrayName]] internal slot, then\n    1. Perform ? SetTypedArrayFromTypedArray(_target_, _targetOffset_, _source_).\n  1. Else,\n    1. Perform ? SetTypedArrayFromArrayLike(_target_, _targetOffset_, _source_).\n  1. Return *undefined*.","code":"\n          1. Let _target_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_target_, [[TypedArrayName]]).\n          1. Assert: _target_ has a [[ViewedArrayBuffer]] internal slot.\n          1. Let _targetOffset_ be ? ToIntegerOrInfinity(_offset_).\n          1. If _targetOffset_ < 0, throw a *RangeError* exception.\n          1. If _source_ is an Object that has a [[TypedArrayName]] internal slot, then\n            1. Perform ? SetTypedArrayFromTypedArray(_target_, _targetOffset_, _source_).\n          1. Else,\n            1. Perform ? SetTypedArrayFromArrayLike(_target_, _targetOffset_, _source_).\n          1. Return *undefined*.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"SetTypedArrayFromTypedArray","params":[{"name":"target","ty":"Record[TypedArray]","kind":{"Normal":{}}},{"name":"targetOffset","ty":"NonNegInt | +INF","kind":{"Normal":{}}},{"name":"source","ty":"Record[TypedArray]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Let _targetBuffer_ be _target_.[[ViewedArrayBuffer]].\n  1. Let _targetRecord_ be MakeTypedArrayWithBufferWitnessRecord(_target_, ~seq-cst~).\n  1. If IsTypedArrayOutOfBounds(_targetRecord_) is *true*, throw a *TypeError* exception.\n  1. Let _targetLength_ be TypedArrayLength(_targetRecord_).\n  1. Let _srcBuffer_ be _source_.[[ViewedArrayBuffer]].\n  1. Let _srcRecord_ be MakeTypedArrayWithBufferWitnessRecord(_source_, ~seq-cst~).\n  1. If IsTypedArrayOutOfBounds(_srcRecord_) is *true*, throw a *TypeError* exception.\n  1. Let _srcLength_ be TypedArrayLength(_srcRecord_).\n  1. Let _targetType_ be TypedArrayElementType(_target_).\n  1. Let _targetElementSize_ be TypedArrayElementSize(_target_).\n  1. Let _targetByteOffset_ be _target_.[[ByteOffset]].\n  1. Let _srcType_ be TypedArrayElementType(_source_).\n  1. Let _srcElementSize_ be TypedArrayElementSize(_source_).\n  1. Let _srcByteOffset_ be _source_.[[ByteOffset]].\n  1. If _targetOffset_ = +∞, throw a *RangeError* exception.\n  1. If _srcLength_ + _targetOffset_ > _targetLength_, throw a *RangeError* exception.\n  1. If _target_.[[ContentType]] is not _source_.[[ContentType]], throw a *TypeError* exception.\n  1. If IsSharedArrayBuffer(_srcBuffer_) is *true* and IsSharedArrayBuffer(_targetBuffer_) is *true* and _srcBuffer_.[[ArrayBufferData]] is _targetBuffer_.[[ArrayBufferData]], let _sameSharedArrayBuffer_ be *true*.\n  1. Else, let _sameSharedArrayBuffer_ be *false*.\n  1. If SameValue(_srcBuffer_, _targetBuffer_) is *true* or _sameSharedArrayBuffer_ is *true*, then\n    1. Let _srcByteLength_ be TypedArrayByteLength(_srcRecord_).\n    1. Set _srcBuffer_ to ? CloneArrayBuffer(_srcBuffer_, _srcByteOffset_, _srcByteLength_).\n    1. Let _srcByteIndex_ be 0.\n  1. Else,\n    1. Let _srcByteIndex_ be _srcByteOffset_.\n  1. Let _targetByteIndex_ be _targetOffset_ × _targetElementSize_ + _targetByteOffset_.\n  1. Let _limit_ be _targetByteIndex_ + _targetElementSize_ × _srcLength_.\n  1. If _srcType_ is _targetType_, then\n    1. NOTE: The transfer must be performed in a manner that preserves the bit-level encoding of the source data.\n    1. Repeat, while _targetByteIndex_ < _limit_,\n      1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, ~uint8~, *true*, ~unordered~).\n      1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, ~uint8~, _value_, *true*, ~unordered~).\n      1. Set _srcByteIndex_ to _srcByteIndex_ + 1.\n      1. Set _targetByteIndex_ to _targetByteIndex_ + 1.\n  1. Else,\n    1. Repeat, while _targetByteIndex_ < _limit_,\n      1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, _srcType_, *true*, ~unordered~).\n      1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, _targetType_, _value_, *true*, ~unordered~).\n      1. Set _srcByteIndex_ to _srcByteIndex_ + _srcElementSize_.\n      1. Set _targetByteIndex_ to _targetByteIndex_ + _targetElementSize_.\n  1. Return ~unused~.","code":"\n            1. Let _targetBuffer_ be _target_.[[ViewedArrayBuffer]].\n            1. Let _targetRecord_ be MakeTypedArrayWithBufferWitnessRecord(_target_, ~seq-cst~).\n            1. If IsTypedArrayOutOfBounds(_targetRecord_) is *true*, throw a *TypeError* exception.\n            1. Let _targetLength_ be TypedArrayLength(_targetRecord_).\n            1. Let _srcBuffer_ be _source_.[[ViewedArrayBuffer]].\n            1. Let _srcRecord_ be MakeTypedArrayWithBufferWitnessRecord(_source_, ~seq-cst~).\n            1. If IsTypedArrayOutOfBounds(_srcRecord_) is *true*, throw a *TypeError* exception.\n            1. Let _srcLength_ be TypedArrayLength(_srcRecord_).\n            1. Let _targetType_ be TypedArrayElementType(_target_).\n            1. Let _targetElementSize_ be TypedArrayElementSize(_target_).\n            1. Let _targetByteOffset_ be _target_.[[ByteOffset]].\n            1. Let _srcType_ be TypedArrayElementType(_source_).\n            1. Let _srcElementSize_ be TypedArrayElementSize(_source_).\n            1. Let _srcByteOffset_ be _source_.[[ByteOffset]].\n            1. If _targetOffset_ = +∞, throw a *RangeError* exception.\n            1. If _srcLength_ + _targetOffset_ > _targetLength_, throw a *RangeError* exception.\n            1. If _target_.[[ContentType]] is not _source_.[[ContentType]], throw a *TypeError* exception.\n            1. If IsSharedArrayBuffer(_srcBuffer_) is *true*, IsSharedArrayBuffer(_targetBuffer_) is *true*, and _srcBuffer_.[[ArrayBufferData]] is _targetBuffer_.[[ArrayBufferData]], let _sameSharedArrayBuffer_ be *true*; otherwise, let _sameSharedArrayBuffer_ be *false*.\n            1. If SameValue(_srcBuffer_, _targetBuffer_) is *true* or _sameSharedArrayBuffer_ is *true*, then\n              1. Let _srcByteLength_ be TypedArrayByteLength(_srcRecord_).\n              1. Set _srcBuffer_ to ? CloneArrayBuffer(_srcBuffer_, _srcByteOffset_, _srcByteLength_).\n              1. Let _srcByteIndex_ be 0.\n            1. Else,\n              1. Let _srcByteIndex_ be _srcByteOffset_.\n            1. Let _targetByteIndex_ be (_targetOffset_ × _targetElementSize_) + _targetByteOffset_.\n            1. Let _limit_ be _targetByteIndex_ + (_targetElementSize_ × _srcLength_).\n            1. If _srcType_ is _targetType_, then\n              1. NOTE: The transfer must be performed in a manner that preserves the bit-level encoding of the source data.\n              1. Repeat, while _targetByteIndex_ < _limit_,\n                1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, ~uint8~, *true*, ~unordered~).\n                1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, ~uint8~, _value_, *true*, ~unordered~).\n                1. Set _srcByteIndex_ to _srcByteIndex_ + 1.\n                1. Set _targetByteIndex_ to _targetByteIndex_ + 1.\n            1. Else,\n              1. Repeat, while _targetByteIndex_ < _limit_,\n                1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, _srcType_, *true*, ~unordered~).\n                1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, _targetType_, _value_, *true*, ~unordered~).\n                1. Set _srcByteIndex_ to _srcByteIndex_ + _srcElementSize_.\n                1. Set _targetByteIndex_ to _targetByteIndex_ + _targetElementSize_.\n            1. Return ~unused~.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"SetTypedArrayFromArrayLike","params":[{"name":"target","ty":"Record[TypedArray]","kind":{"Normal":{}}},{"name":"targetOffset","ty":"NonNegInt | +INF","kind":{"Normal":{}}},{"name":"source","ty":"Unknown[\"an ECMAScript language value, but not a TypedArray\"]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Let _targetRecord_ be MakeTypedArrayWithBufferWitnessRecord(_target_, ~seq-cst~).\n  1. If IsTypedArrayOutOfBounds(_targetRecord_) is *true*, throw a *TypeError* exception.\n  1. Let _targetLength_ be TypedArrayLength(_targetRecord_).\n  1. Let _src_ be ? ToObject(_source_).\n  1. Let _srcLength_ be ? LengthOfArrayLike(_src_).\n  1. If _targetOffset_ = +∞, throw a *RangeError* exception.\n  1. If _srcLength_ + _targetOffset_ > _targetLength_, throw a *RangeError* exception.\n  1. Let _k_ be 0.\n  1. Repeat, while _k_ < _srcLength_,\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. Let _value_ be ? Get(_src_, _Pk_).\n    1. Let _targetIndex_ be 𝔽(_targetOffset_ + _k_).\n    1. Perform ? TypedArraySetElement(_target_, _targetIndex_, _value_).\n    1. Set _k_ to _k_ + 1.\n  1. Return ~unused~.","code":"\n            1. Let _targetRecord_ be MakeTypedArrayWithBufferWitnessRecord(_target_, ~seq-cst~).\n            1. If IsTypedArrayOutOfBounds(_targetRecord_) is *true*, throw a *TypeError* exception.\n            1. Let _targetLength_ be TypedArrayLength(_targetRecord_).\n            1. Let _src_ be ? ToObject(_source_).\n            1. Let _srcLength_ be ? LengthOfArrayLike(_src_).\n            1. If _targetOffset_ = +∞, throw a *RangeError* exception.\n            1. If _srcLength_ + _targetOffset_ > _targetLength_, throw a *RangeError* exception.\n            1. Let _k_ be 0.\n            1. Repeat, while _k_ < _srcLength_,\n              1. Let _Pk_ be ! ToString(𝔽(_k_)).\n              1. Let _value_ be ? Get(_src_, _Pk_).\n              1. Let _targetIndex_ be 𝔽(_targetOffset_ + _k_).\n              1. Perform ? TypedArraySetElement(_target_, _targetIndex_, _value_).\n              1. Set _k_ to _k_ + 1.\n            1. Return ~unused~.\n          "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"slice"}},"params":[{"name":"start","ty":"Unknown","kind":{"Normal":{}}},{"name":"end","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n  1. Let _srcArrayLength_ be TypedArrayLength(_taRecord_).\n  1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n  1. If _relativeStart_ = -∞, let _startIndex_ be 0.\n  1. Else if _relativeStart_ < 0, let _startIndex_ be max(_srcArrayLength_ + _relativeStart_, 0).\n  1. Else, let _startIndex_ be min(_relativeStart_, _srcArrayLength_).\n  1. If _end_ is *undefined*, let _relativeEnd_ be _srcArrayLength_.\n  1. Else, let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).\n  1. If _relativeEnd_ = -∞, let _endIndex_ be 0.\n  1. Else if _relativeEnd_ < 0, let _endIndex_ be max(_srcArrayLength_ + _relativeEnd_, 0).\n  1. Else, let _endIndex_ be min(_relativeEnd_, _srcArrayLength_).\n  1. Let _countBytes_ be max(_endIndex_ - _startIndex_, 0).\n  1. Let _A_ be ? TypedArraySpeciesCreate(_O_, « 𝔽(_countBytes_) »).\n  1. If _countBytes_ > 0, then\n    1. Set _taRecord_ to MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).\n    1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.\n    1. Set _endIndex_ to min(_endIndex_, TypedArrayLength(_taRecord_)).\n    1. Set _countBytes_ to max(_endIndex_ - _startIndex_, 0).\n    1. Let _srcType_ be TypedArrayElementType(_O_).\n    1. Let _targetType_ be TypedArrayElementType(_A_).\n    1. If _srcType_ is _targetType_, then\n      1. NOTE: The transfer must be performed in a manner that preserves the bit-level encoding of the source data.\n      1. Let _srcBuffer_ be _O_.[[ViewedArrayBuffer]].\n      1. Let _targetBuffer_ be _A_.[[ViewedArrayBuffer]].\n      1. Let _elementSize_ be TypedArrayElementSize(_O_).\n      1. Let _srcByteOffset_ be _O_.[[ByteOffset]].\n      1. Let _srcByteIndex_ be _startIndex_ × _elementSize_ + _srcByteOffset_.\n      1. Let _targetByteIndex_ be _A_.[[ByteOffset]].\n      1. Let _endByteIndex_ be _targetByteIndex_ + _countBytes_ × _elementSize_.\n      1. Repeat, while _targetByteIndex_ < _endByteIndex_,\n        1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, ~uint8~, *true*, ~unordered~).\n        1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, ~uint8~, _value_, *true*, ~unordered~).\n        1. Set _srcByteIndex_ to _srcByteIndex_ + 1.\n        1. Set _targetByteIndex_ to _targetByteIndex_ + 1.\n    1. Else,\n      1. Let _n_ be 0.\n      1. Let _k_ be _startIndex_.\n      1. Repeat, while _k_ < _endIndex_,\n        1. Let _Pk_ be ! ToString(𝔽(_k_)).\n        1. Let _kValue_ be ! Get(_O_, _Pk_).\n        1. Perform ! Set(_A_, ! ToString(𝔽(_n_)), _kValue_, *true*).\n        1. Set _k_ to _k_ + 1.\n        1. Set _n_ to _n_ + 1.\n  1. Return _A_.","code":"\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _srcArrayLength_ be TypedArrayLength(_taRecord_).\n          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n          1. If _relativeStart_ = -∞, let _startIndex_ be 0.\n          1. Else if _relativeStart_ < 0, let _startIndex_ be max(_srcArrayLength_ + _relativeStart_, 0).\n          1. Else, let _startIndex_ be min(_relativeStart_, _srcArrayLength_).\n          1. If _end_ is *undefined*, let _relativeEnd_ be _srcArrayLength_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).\n          1. If _relativeEnd_ = -∞, let _endIndex_ be 0.\n          1. Else if _relativeEnd_ < 0, let _endIndex_ be max(_srcArrayLength_ + _relativeEnd_, 0).\n          1. Else, let _endIndex_ be min(_relativeEnd_, _srcArrayLength_).\n          1. Let _countBytes_ be max(_endIndex_ - _startIndex_, 0).\n          1. Let _A_ be ? TypedArraySpeciesCreate(_O_, « 𝔽(_countBytes_) »).\n          1. If _countBytes_ > 0, then\n            1. Set _taRecord_ to MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).\n            1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.\n            1. Set _endIndex_ to min(_endIndex_, TypedArrayLength(_taRecord_)).\n            1. Set _countBytes_ to max(_endIndex_ - _startIndex_, 0).\n            1. Let _srcType_ be TypedArrayElementType(_O_).\n            1. Let _targetType_ be TypedArrayElementType(_A_).\n            1. If _srcType_ is _targetType_, then\n              1. NOTE: The transfer must be performed in a manner that preserves the bit-level encoding of the source data.\n              1. Let _srcBuffer_ be _O_.[[ViewedArrayBuffer]].\n              1. Let _targetBuffer_ be _A_.[[ViewedArrayBuffer]].\n              1. Let _elementSize_ be TypedArrayElementSize(_O_).\n              1. Let _srcByteOffset_ be _O_.[[ByteOffset]].\n              1. Let _srcByteIndex_ be (_startIndex_ × _elementSize_) + _srcByteOffset_.\n              1. Let _targetByteIndex_ be _A_.[[ByteOffset]].\n              1. Let _endByteIndex_ be _targetByteIndex_ + (_countBytes_ × _elementSize_).\n              1. Repeat, while _targetByteIndex_ < _endByteIndex_,\n                1. Let _value_ be GetValueFromBuffer(_srcBuffer_, _srcByteIndex_, ~uint8~, *true*, ~unordered~).\n                1. Perform SetValueInBuffer(_targetBuffer_, _targetByteIndex_, ~uint8~, _value_, *true*, ~unordered~).\n                1. Set _srcByteIndex_ to _srcByteIndex_ + 1.\n                1. Set _targetByteIndex_ to _targetByteIndex_ + 1.\n            1. Else,\n              1. Let _n_ be 0.\n              1. Let _k_ be _startIndex_.\n              1. Repeat, while _k_ < _endIndex_,\n                1. Let _Pk_ be ! ToString(𝔽(_k_)).\n                1. Let _kValue_ be ! Get(_O_, _Pk_).\n                1. Perform ! Set(_A_, ! ToString(𝔽(_n_)), _kValue_, *true*).\n                1. Set _k_ to _k_ + 1.\n                1. Set _n_ to _n_ + 1.\n          1. Return _A_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"some"}},"params":[{"name":"callbackfn","ty":"Unknown","kind":{"Normal":{}}},{"name":"thisArg","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n  1. Let _len_ be TypedArrayLength(_taRecord_).\n  1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n  1. Let _k_ be 0.\n  1. Repeat, while _k_ < _len_,\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. Let _kValue_ be ! Get(_O_, _Pk_).\n    1. Let _testResult_ be ToBoolean(? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).\n    1. If _testResult_ is *true*, return *true*.\n    1. Set _k_ to _k_ + 1.\n  1. Return *false*.","code":"\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _kValue_ be ! Get(_O_, _Pk_).\n            1. Let _testResult_ be ToBoolean(? Call(_callbackfn_, _thisArg_, « _kValue_, 𝔽(_k_), _O_ »)).\n            1. If _testResult_ is *true*, return *true*.\n            1. Set _k_ to _k_ + 1.\n          1. Return *false*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"sort"}},"params":[{"name":"comparefn","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If _comparefn_ is not *undefined* and IsCallable(_comparefn_) is *false*, throw a *TypeError* exception.\n  1. Let _obj_ be *this* value.\n  1. Let _taRecord_ be ? ValidateTypedArray(_obj_, ~seq-cst~).\n  1. Let _len_ be TypedArrayLength(_taRecord_).\n  1. NOTE: The following closure performs a numeric comparison rather than the string comparison used in <emu-xref href=\"#sec-array.prototype.sort\"></emu-xref>.\n  1. Let _SortCompare_ be a new Abstract Closure with parameters (_x_, _y_) that captures _comparefn_ and performs the following steps when called:\n    1. Return ? CompareTypedArrayElements(_x_, _y_, _comparefn_).\n  1. Let _sortedList_ be ? SortIndexedProperties(_obj_, _len_, _SortCompare_, ~read-through-holes~).\n  1. Let _j_ be 0.\n  1. Repeat, while _j_ < _len_,\n    1. Perform ! Set(_obj_, ! ToString(𝔽(_j_)), _sortedList_[_j_], *true*).\n    1. Set _j_ to _j_ + 1.\n  1. Return _obj_.","code":"\n          1. If _comparefn_ is not *undefined* and IsCallable(_comparefn_) is *false*, throw a *TypeError* exception.\n          1. Let _obj_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_obj_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. NOTE: The following closure performs a numeric comparison rather than the string comparison used in <emu-xref href=\"#sec-array.prototype.sort\"></emu-xref>.\n          1. Let _SortCompare_ be a new Abstract Closure with parameters (_x_, _y_) that captures _comparefn_ and performs the following steps when called:\n            1. Return ? CompareTypedArrayElements(_x_, _y_, _comparefn_).\n          1. Let _sortedList_ be ? SortIndexedProperties(_obj_, _len_, _SortCompare_, ~read-through-holes~).\n          1. Let _j_ be 0.\n          1. Repeat, while _j_ < _len_,\n            1. Perform ! Set(_obj_, ! ToString(𝔽(_j_)), _sortedList_[_j_], *true*).\n            1. Set _j_ to _j_ + 1.\n          1. Return _obj_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"subarray"}},"params":[{"name":"start","ty":"Unknown","kind":{"Normal":{}}},{"name":"end","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).\n  1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.\n  1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].\n  1. Let _srcRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).\n  1. If IsTypedArrayOutOfBounds(_srcRecord_) is *true*, then\n    1. Let _srcLength_ be 0.\n  1. Else,\n    1. Let _srcLength_ be TypedArrayLength(_srcRecord_).\n  1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n  1. If _relativeStart_ = -∞, let _startIndex_ be 0.\n  1. Else if _relativeStart_ < 0, let _startIndex_ be max(_srcLength_ + _relativeStart_, 0).\n  1. Else, let _startIndex_ be min(_relativeStart_, _srcLength_).\n  1. Let _elementSize_ be TypedArrayElementSize(_O_).\n  1. Let _srcByteOffset_ be _O_.[[ByteOffset]].\n  1. Let _beginByteOffset_ be _srcByteOffset_ + _startIndex_ × _elementSize_.\n  1. If _O_.[[ArrayLength]] is ~auto~ and _end_ is *undefined*, then\n    1. Let _argumentsList_ be « _buffer_, 𝔽(_beginByteOffset_) ».\n  1. Else,\n    1. If _end_ is *undefined*, let _relativeEnd_ be _srcLength_.\n    1. Else, let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).\n    1. If _relativeEnd_ = -∞, let _endIndex_ be 0.\n    1. Else if _relativeEnd_ < 0, let _endIndex_ be max(_srcLength_ + _relativeEnd_, 0).\n    1. Else, let _endIndex_ be min(_relativeEnd_, _srcLength_).\n    1. Let _newLength_ be max(_endIndex_ - _startIndex_, 0).\n    1. Let _argumentsList_ be « _buffer_, 𝔽(_beginByteOffset_), 𝔽(_newLength_) ».\n  1. Return ? TypedArraySpeciesCreate(_O_, _argumentsList_).","code":"\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).\n          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.\n          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].\n          1. Let _srcRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, ~seq-cst~).\n          1. If IsTypedArrayOutOfBounds(_srcRecord_) is *true*, then\n            1. Let _srcLength_ be 0.\n          1. Else,\n            1. Let _srcLength_ be TypedArrayLength(_srcRecord_).\n          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n          1. If _relativeStart_ = -∞, let _startIndex_ be 0.\n          1. Else if _relativeStart_ < 0, let _startIndex_ be max(_srcLength_ + _relativeStart_, 0).\n          1. Else, let _startIndex_ be min(_relativeStart_, _srcLength_).\n          1. Let _elementSize_ be TypedArrayElementSize(_O_).\n          1. Let _srcByteOffset_ be _O_.[[ByteOffset]].\n          1. Let _beginByteOffset_ be _srcByteOffset_ + (_startIndex_ × _elementSize_).\n          1. If _O_.[[ArrayLength]] is ~auto~ and _end_ is *undefined*, then\n            1. Let _argumentsList_ be « _buffer_, 𝔽(_beginByteOffset_) ».\n          1. Else,\n            1. If _end_ is *undefined*, let _relativeEnd_ be _srcLength_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).\n            1. If _relativeEnd_ = -∞, let _endIndex_ be 0.\n            1. Else if _relativeEnd_ < 0, let _endIndex_ be max(_srcLength_ + _relativeEnd_, 0).\n            1. Else, let _endIndex_ be min(_relativeEnd_, _srcLength_).\n            1. Let _newLength_ be max(_endIndex_ - _startIndex_, 0).\n            1. Let _argumentsList_ be « _buffer_, 𝔽(_beginByteOffset_), 𝔽(_newLength_) ».\n          1. Return ? TypedArraySpeciesCreate(_O_, _argumentsList_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"toReversed"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n  1. Let _length_ be TypedArrayLength(_taRecord_).\n  1. Let _A_ be ? TypedArrayCreateSameType(_O_, « 𝔽(_length_) »).\n  1. Let _k_ be 0.\n  1. Repeat, while _k_ < _length_,\n    1. Let _from_ be ! ToString(𝔽(_length_ - _k_ - 1)).\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. Let _fromValue_ be ! Get(_O_, _from_).\n    1. Perform ! Set(_A_, _Pk_, _fromValue_, *true*).\n    1. Set _k_ to _k_ + 1.\n  1. Return _A_.","code":"\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _length_ be TypedArrayLength(_taRecord_).\n          1. Let _A_ be ? TypedArrayCreateSameType(_O_, « 𝔽(_length_) »).\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _length_,\n            1. Let _from_ be ! ToString(𝔽(_length_ - _k_ - 1)).\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. Let _fromValue_ be ! Get(_O_, _from_).\n            1. Perform ! Set(_A_, _Pk_, _fromValue_, *true*).\n            1. Set _k_ to _k_ + 1.\n          1. Return _A_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"toSorted"}},"params":[{"name":"comparefn","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If _comparefn_ is not *undefined* and IsCallable(_comparefn_) is *false*, throw a *TypeError* exception.\n  1. Let _O_ be *this* value.\n  1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n  1. Let _len_ be TypedArrayLength(_taRecord_).\n  1. Let _A_ be ? TypedArrayCreateSameType(_O_, « 𝔽(_len_) »).\n  1. NOTE: The following closure performs a numeric comparison rather than the string comparison used in <emu-xref href=\"#sec-array.prototype.tosorted\"></emu-xref>.\n  1. Let _SortCompare_ be a new Abstract Closure with parameters (_x_, _y_) that captures _comparefn_ and performs the following steps when called:\n    1. Return ? CompareTypedArrayElements(_x_, _y_, _comparefn_).\n  1. Let _sortedList_ be ? SortIndexedProperties(_O_, _len_, _SortCompare_, ~read-through-holes~).\n  1. Let _j_ be 0.\n  1. Repeat, while _j_ < _len_,\n    1. Perform ! Set(_A_, ! ToString(𝔽(_j_)), _sortedList_[_j_], *true*).\n    1. Set _j_ to _j_ + 1.\n  1. Return _A_.","code":"\n          1. If _comparefn_ is not *undefined* and IsCallable(_comparefn_) is *false*, throw a *TypeError* exception.\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. Let _A_ be ? TypedArrayCreateSameType(_O_, « 𝔽(_len_) »).\n          1. NOTE: The following closure performs a numeric comparison rather than the string comparison used in <emu-xref href=\"#sec-array.prototype.tosorted\"></emu-xref>.\n          1. Let _SortCompare_ be a new Abstract Closure with parameters (_x_, _y_) that captures _comparefn_ and performs the following steps when called:\n            1. Return ? CompareTypedArrayElements(_x_, _y_, _comparefn_).\n          1. Let _sortedList_ be ? SortIndexedProperties(_O_, _len_, _SortCompare_, ~read-through-holes~).\n          1. Let _j_ be 0.\n          1. Repeat, while _j_ < _len_,\n            1. Perform ! Set(_A_, ! ToString(𝔽(_j_)), _sortedList_[_j_], *true*).\n            1. Set _j_ to _j_ + 1.\n          1. Return _A_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"values"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Perform ? ValidateTypedArray(_O_, ~seq-cst~).\n  1. Return CreateArrayIterator(_O_, ~value~).","code":"\n          1. Let _O_ be the *this* value.\n          1. Perform ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Return CreateArrayIterator(_O_, ~value~).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"name":"with"}},"params":[{"name":"index","ty":"Unknown","kind":{"Normal":{}}},{"name":"value","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n  1. Let _len_ be TypedArrayLength(_taRecord_).\n  1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).\n  1. If _relativeIndex_ ≥ 0, let _actualIndex_ be _relativeIndex_.\n  1. Else, let _actualIndex_ be _len_ + _relativeIndex_.\n  1. If _O_.[[ContentType]] is ~bigint~, let _numericValue_ be ? ToBigInt(_value_).\n  1. Else, let _numericValue_ be ? ToNumber(_value_).\n  1. If IsValidIntegerIndex(_O_, 𝔽(_actualIndex_)) is *false*, throw a *RangeError* exception.\n  1. Let _A_ be ? TypedArrayCreateSameType(_O_, « 𝔽(_len_) »).\n  1. Let _k_ be 0.\n  1. Repeat, while _k_ < _len_,\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. If _k_ is _actualIndex_, let _fromValue_ be _numericValue_.\n    1. Else, let _fromValue_ be ! Get(_O_, _Pk_).\n    1. Perform ! Set(_A_, _Pk_, _fromValue_, *true*).\n    1. Set _k_ to _k_ + 1.\n  1. Return _A_.","code":"\n          1. Let _O_ be the *this* value.\n          1. Let _taRecord_ be ? ValidateTypedArray(_O_, ~seq-cst~).\n          1. Let _len_ be TypedArrayLength(_taRecord_).\n          1. Let _relativeIndex_ be ? ToIntegerOrInfinity(_index_).\n          1. If _relativeIndex_ ≥ 0, let _actualIndex_ be _relativeIndex_.\n          1. Else, let _actualIndex_ be _len_ + _relativeIndex_.\n          1. If _O_.[[ContentType]] is ~bigint~, let _numericValue_ be ? ToBigInt(_value_).\n          1. Else, let _numericValue_ be ? ToNumber(_value_).\n          1. If IsValidIntegerIndex(_O_, 𝔽(_actualIndex_)) is *false*, throw a *RangeError* exception.\n          1. Let _A_ be ? TypedArrayCreateSameType(_O_, « 𝔽(_len_) »).\n          1. Let _k_ be 0.\n          1. Repeat, while _k_ < _len_,\n            1. Let _Pk_ be ! ToString(𝔽(_k_)).\n            1. If _k_ is _actualIndex_, let _fromValue_ be _numericValue_.\n            1. Else, let _fromValue_ be ! Get(_O_, _Pk_).\n            1. Perform ! Set(_A_, _Pk_, _fromValue_, *true*).\n            1. Set _k_ to _k_ + 1.\n          1. Return _A_.\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"SymbolAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"TypedArray"}},"name":"prototype"}},"symbol":"toStringTag"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. If _O_ is not a Record[Object], return *undefined*.\n  1. If _O_ does not have a [[TypedArrayName]] internal slot, return *undefined*.\n  1. Let _name_ be _O_.[[TypedArrayName]].\n  1. Assert: _name_ is a String.\n  1. Return _name_.","code":"\n          1. Let _O_ be the *this* value.\n          1. If _O_ is not an Object, return *undefined*.\n          1. If _O_ does not have a [[TypedArrayName]] internal slot, return *undefined*.\n          1. Let _name_ be _O_.[[TypedArrayName]].\n          1. Assert: _name_ is a String.\n          1. Return _name_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"TypedArraySpeciesCreate","params":[{"name":"exemplar","ty":"Record[TypedArray]","kind":{"Normal":{}}},{"name":"argumentList","ty":"List[ESValue]","kind":{"Normal":{}}}],"retTy":"Normal[Record[TypedArray]] | Throw"}},"body":"\n  1. Let _defaultConstructor_ be the intrinsic object associated with the constructor name _exemplar_.[[TypedArrayName]] in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref>.\n  1. Let _constructor_ be ? SpeciesConstructor(_exemplar_, _defaultConstructor_).\n  1. Let _result_ be ? TypedArrayCreateFromConstructor(_constructor_, _argumentList_).\n  1. Assert: _result_ has [[TypedArrayName]] and [[ContentType]] internal slots..\n  1. If _result_.[[ContentType]] is not _exemplar_.[[ContentType]], throw a *TypeError* exception.\n  1. Return _result_.","code":"\n          1. Let _defaultConstructor_ be the intrinsic object associated with the constructor name _exemplar_.[[TypedArrayName]] in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref>.\n          1. Let _constructor_ be ? SpeciesConstructor(_exemplar_, _defaultConstructor_).\n          1. Let _result_ be ? TypedArrayCreateFromConstructor(_constructor_, _argumentList_).\n          1. Assert: _result_ has [[TypedArrayName]] and [[ContentType]] internal slots.\n          1. If _result_.[[ContentType]] is not _exemplar_.[[ContentType]], throw a *TypeError* exception.\n          1. Return _result_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"TypedArrayCreateFromConstructor","params":[{"name":"constructor","ty":"Record[Constructor]","kind":{"Normal":{}}},{"name":"argumentList","ty":"List[ESValue]","kind":{"Normal":{}}}],"retTy":"Normal[Record[TypedArray]] | Throw"}},"body":"\n  1. Let _newTypedArray_ be ? Construct(_constructor_, _argumentList_).\n  1. Let _taRecord_ be ? ValidateTypedArray(_newTypedArray_, ~seq-cst~).\n  1. If the number of elements in _argumentList_ is 1 and _argumentList_[0] is a Number, then\n    1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.\n    1. Let _length_ be TypedArrayLength(_taRecord_).\n    1. If _length_ < ℝ(_argumentList_[0]), throw a *TypeError* exception.\n  1. Return _newTypedArray_.","code":"\n          1. Let _newTypedArray_ be ? Construct(_constructor_, _argumentList_).\n          1. Let _taRecord_ be ? ValidateTypedArray(_newTypedArray_, ~seq-cst~).\n          1. If the number of elements in _argumentList_ is 1 and _argumentList_[0] is a Number, then\n            1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.\n            1. Let _length_ be TypedArrayLength(_taRecord_).\n            1. If _length_ < ℝ(_argumentList_[0]), throw a *TypeError* exception.\n          1. Return _newTypedArray_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"TypedArrayCreateSameType","params":[{"name":"exemplar","ty":"Record[TypedArray]","kind":{"Normal":{}}},{"name":"argumentList","ty":"List[ESValue]","kind":{"Normal":{}}}],"retTy":"Normal[Record[TypedArray]] | Throw"}},"body":"\n  1. Let _constructor_ be the intrinsic object associated with the constructor name _exemplar_.[[TypedArrayName]] in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref>.\n  1. Let _result_ be ? TypedArrayCreateFromConstructor(_constructor_, _argumentList_).\n  1. Assert: _result_ has [[TypedArrayName]] and [[ContentType]] internal slots..\n  1. Assert: _result_.[[ContentType]] is _exemplar_.[[ContentType]].\n  1. Return _result_.","code":"\n          1. Let _constructor_ be the intrinsic object associated with the constructor name _exemplar_.[[TypedArrayName]] in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref>.\n          1. Let _result_ be ? TypedArrayCreateFromConstructor(_constructor_, _argumentList_).\n          1. Assert: _result_ has [[TypedArrayName]] and [[ContentType]] internal slots.\n          1. Assert: _result_.[[ContentType]] is _exemplar_.[[ContentType]].\n          1. Return _result_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ValidateTypedArray","params":[{"name":"O","ty":"ESValue","kind":{"Normal":{}}},{"name":"order","ty":"Enum[~seq-cst~, ~unordered~]","kind":{"Normal":{}}}],"retTy":"Normal[Record[TypedArrayWithBufferWitnessRecord]] | Throw"}},"body":"\n  1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).\n  1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.\n  1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, _order_).\n  1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.\n  1. Return _taRecord_.","code":"\n          1. Perform ? RequireInternalSlot(_O_, [[TypedArrayName]]).\n          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.\n          1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_O_, _order_).\n          1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.\n          1. Return _taRecord_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"TypedArrayElementSize","params":[{"name":"O","ty":"Record[TypedArray]","kind":{"Normal":{}}}],"retTy":"NonNegInt"}},"body":"\n  1. Return the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _O_.[[TypedArrayName]].","code":"\n          1. Return the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _O_.[[TypedArrayName]].\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"TypedArrayElementType","params":[{"name":"O","ty":"Record[TypedArray]","kind":{"Normal":{}}}],"retTy":"Unknown[\"a TypedArray element type\"]"}},"body":"\n  1. Return the Element Type value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _O_.[[TypedArrayName]].","code":"\n          1. Return the Element Type value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for _O_.[[TypedArrayName]].\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CompareTypedArrayElements","params":[{"name":"x","ty":"Number | BigInt","kind":{"Normal":{}}},{"name":"y","ty":"Number | BigInt","kind":{"Normal":{}}},{"name":"comparefn","ty":"Record[FunctionObject] | Undefined","kind":{"Normal":{}}}],"retTy":"Normal[Number] | Abrupt"}},"body":"\n  1. Assert: _x_ is a Number and _y_ is a Number or _x_ is a BigInt and _y_ is a BigInt.\n  1. If _comparefn_ is not *undefined*, then\n    1. Let _v_ be ? ToNumber(? Call(_comparefn_, *undefined*, « _x_, _y_ »)).\n    1. If _v_ is *NaN*, return *+0*<sub>𝔽</sub>.\n    1. Return _v_.\n  1. If both _x_ and _y_ are *NaN*, return *+0*<sub>𝔽</sub>.\n  1. If _x_ is *NaN*, return *1*<sub>𝔽</sub>.\n  1. If _y_ is *NaN*, return *-1*<sub>𝔽</sub>.\n  1. If _x_ < _y_, return *-1*<sub>𝔽</sub>.\n  1. If _x_ > _y_, return *1*<sub>𝔽</sub>.\n  1. If _x_ is *-0*<sub>𝔽</sub> and _y_ is *+0*<sub>𝔽</sub>, return *-1*<sub>𝔽</sub>.\n  1. If _x_ is *+0*<sub>𝔽</sub> and _y_ is *-0*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.\n  1. Return *+0*<sub>𝔽</sub>.","code":"\n          1. Assert: _x_ is a Number and _y_ is a Number, or _x_ is a BigInt and _y_ is a BigInt.\n          1. If _comparefn_ is not *undefined*, then\n            1. Let _v_ be ? ToNumber(? Call(_comparefn_, *undefined*, « _x_, _y_ »)).\n            1. If _v_ is *NaN*, return *+0*<sub>𝔽</sub>.\n            1. Return _v_.\n          1. If _x_ and _y_ are both *NaN*, return *+0*<sub>𝔽</sub>.\n          1. If _x_ is *NaN*, return *1*<sub>𝔽</sub>.\n          1. If _y_ is *NaN*, return *-1*<sub>𝔽</sub>.\n          1. If _x_ < _y_, return *-1*<sub>𝔽</sub>.\n          1. If _x_ > _y_, return *1*<sub>𝔽</sub>.\n          1. If _x_ is *-0*<sub>𝔽</sub> and _y_ is *+0*<sub>𝔽</sub>, return *-1*<sub>𝔽</sub>.\n          1. If _x_ is *+0*<sub>𝔽</sub> and _y_ is *-0*<sub>𝔽</sub>, return *1*<sub>𝔽</sub>.\n          1. Return *+0*<sub>𝔽</sub>.\n        "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"_TypedArray_"}},"params":[{"name":"args","ty":"Unknown","kind":{"Variadic":{}}}],"retTy":"Unknown"}},"body":"\n  1. If NewTarget is *undefined*, throw a *TypeError* exception.\n  1. Let _constructorName_ be the String value of the Constructor Name value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for this <var>TypedArray</var> constructor.\n  1. Let _proto_ be <code>\"%<var>TypedArray</var>.prototype%\"</code>.\n  1. Let _numberOfArgs_ be the number of elements in _args_.\n  1. If _numberOfArgs_ = 0, then\n    1. Return ? AllocateTypedArray(_constructorName_, NewTarget, _proto_, 0).\n  1. Else,\n    1. Let _firstArgument_ be _args_[0].\n    1. If _firstArgument_ is a Record[Object], then\n      1. Let _O_ be ? AllocateTypedArray(_constructorName_, NewTarget, _proto_).\n      1. If _firstArgument_ has a [[TypedArrayName]] internal slot, then\n        1. Perform ? InitializeTypedArrayFromTypedArray(_O_, _firstArgument_).\n      1. Else if _firstArgument_ has a [[ArrayBufferData]] internal slot, then\n        1. If _numberOfArgs_ > 1, let _byteOffset_ be _args_[1].\n        1. Else, let _byteOffset_ be *undefined*.\n        1. If _numberOfArgs_ > 2, let _length_ be _args_[2].\n        1. Else, let _length_ be *undefined*.\n        1. Perform ? InitializeTypedArrayFromArrayBuffer(_O_, _firstArgument_, _byteOffset_, _length_).\n      1. Else,\n        1. Assert: _firstArgument_ is an Object and _firstArgument_ does not have either a [[TypedArrayName]] or an [[ArrayBufferData]] internal slot..\n        1. Let _usingIterator_ be ? GetMethod(_firstArgument_, @@iterator).\n        1. If _usingIterator_ is not *undefined*, then\n          1. Let _values_ be ? IteratorToList(? GetIteratorFromMethod(_firstArgument_, _usingIterator_)).\n          1. Perform ? InitializeTypedArrayFromList(_O_, _values_).\n        1. Else,\n          1. NOTE: _firstArgument_ is not an Iterable so assume it is already an array-like object.\n          1. Perform ? InitializeTypedArrayFromArrayLike(_O_, _firstArgument_).\n      1. Return _O_.\n    1. Else,\n      1. Assert: _firstArgument_ is not a Record[Object].\n      1. Let _elementLength_ be ? ToIndex(_firstArgument_).\n      1. Return ? AllocateTypedArray(_constructorName_, NewTarget, _proto_, _elementLength_).","code":"\n          1. If NewTarget is *undefined*, throw a *TypeError* exception.\n          1. Let _constructorName_ be the String value of the Constructor Name value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for this <var>TypedArray</var> constructor.\n          1. Let _proto_ be <code>\"%<var>TypedArray</var>.prototype%\"</code>.\n          1. Let _numberOfArgs_ be the number of elements in _args_.\n          1. If _numberOfArgs_ = 0, then\n            1. Return ? AllocateTypedArray(_constructorName_, NewTarget, _proto_, 0).\n          1. Else,\n            1. Let _firstArgument_ be _args_[0].\n            1. If _firstArgument_ is an Object, then\n              1. Let _O_ be ? AllocateTypedArray(_constructorName_, NewTarget, _proto_).\n              1. If _firstArgument_ has a [[TypedArrayName]] internal slot, then\n                1. Perform ? InitializeTypedArrayFromTypedArray(_O_, _firstArgument_).\n              1. Else if _firstArgument_ has an [[ArrayBufferData]] internal slot, then\n                1. If _numberOfArgs_ > 1, let _byteOffset_ be _args_[1]; else let _byteOffset_ be *undefined*.\n                1. If _numberOfArgs_ > 2, let _length_ be _args_[2]; else let _length_ be *undefined*.\n                1. Perform ? InitializeTypedArrayFromArrayBuffer(_O_, _firstArgument_, _byteOffset_, _length_).\n              1. Else,\n                1. Assert: _firstArgument_ is an Object and _firstArgument_ does not have either a [[TypedArrayName]] or an [[ArrayBufferData]] internal slot.\n                1. Let _usingIterator_ be ? GetMethod(_firstArgument_, @@iterator).\n                1. If _usingIterator_ is not *undefined*, then\n                  1. Let _values_ be ? IteratorToList(? GetIteratorFromMethod(_firstArgument_, _usingIterator_)).\n                  1. Perform ? InitializeTypedArrayFromList(_O_, _values_).\n                1. Else,\n                  1. NOTE: _firstArgument_ is not an Iterable so assume it is already an array-like object.\n                  1. Perform ? InitializeTypedArrayFromArrayLike(_O_, _firstArgument_).\n              1. Return _O_.\n            1. Else,\n              1. Assert: _firstArgument_ is not an Object.\n              1. Let _elementLength_ be ? ToIndex(_firstArgument_).\n              1. Return ? AllocateTypedArray(_constructorName_, NewTarget, _proto_, _elementLength_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AllocateTypedArray","params":[{"name":"constructorName","ty":"String","kind":{"Normal":{}}},{"name":"newTarget","ty":"Record[Constructor]","kind":{"Normal":{}}},{"name":"defaultProto","ty":"String","kind":{"Normal":{}}},{"name":"length","ty":"NonNegInt","kind":{"Optional":{}}}],"retTy":"Normal[Record[TypedArray]] | Throw"}},"body":"\n  1. Let _proto_ be ? GetPrototypeFromConstructor(_newTarget_, _defaultProto_).\n  1. Let _obj_ be TypedArrayCreate(_proto_).\n  1. Assert: _obj_.[[ViewedArrayBuffer]] is *undefined*.\n  1. Set _obj_.[[TypedArrayName]] to _constructorName_.\n  1. If _constructorName_ is either *\"BigInt64Array\"* or *\"BigUint64Array\"*, set _obj_.[[ContentType]] to ~bigint~.\n  1. Else, set _obj_.[[ContentType]] to ~number~.\n  1. If _length_ is not present, then\n    1. Set _obj_.[[ByteLength]] to 0.\n    1. Set _obj_.[[ByteOffset]] to 0.\n    1. Set _obj_.[[ArrayLength]] to 0.\n  1. Else,\n    1. Perform ? AllocateTypedArrayBuffer(_obj_, _length_).\n  1. Return _obj_.","code":"\n            1. Let _proto_ be ? GetPrototypeFromConstructor(_newTarget_, _defaultProto_).\n            1. Let _obj_ be TypedArrayCreate(_proto_).\n            1. Assert: _obj_.[[ViewedArrayBuffer]] is *undefined*.\n            1. Set _obj_.[[TypedArrayName]] to _constructorName_.\n            1. If _constructorName_ is either *\"BigInt64Array\"* or *\"BigUint64Array\"*, set _obj_.[[ContentType]] to ~bigint~.\n            1. Otherwise, set _obj_.[[ContentType]] to ~number~.\n            1. If _length_ is not present, then\n              1. Set _obj_.[[ByteLength]] to 0.\n              1. Set _obj_.[[ByteOffset]] to 0.\n              1. Set _obj_.[[ArrayLength]] to 0.\n            1. Else,\n              1. Perform ? AllocateTypedArrayBuffer(_obj_, _length_).\n            1. Return _obj_.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"InitializeTypedArrayFromTypedArray","params":[{"name":"O","ty":"Record[TypedArray]","kind":{"Normal":{}}},{"name":"srcArray","ty":"Record[TypedArray]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Let _srcData_ be _srcArray_.[[ViewedArrayBuffer]].\n  1. Let _elementType_ be TypedArrayElementType(_O_).\n  1. Let _elementSize_ be TypedArrayElementSize(_O_).\n  1. Let _srcType_ be TypedArrayElementType(_srcArray_).\n  1. Let _srcElementSize_ be TypedArrayElementSize(_srcArray_).\n  1. Let _srcByteOffset_ be _srcArray_.[[ByteOffset]].\n  1. Let _srcRecord_ be MakeTypedArrayWithBufferWitnessRecord(_srcArray_, ~seq-cst~).\n  1. If IsTypedArrayOutOfBounds(_srcRecord_) is *true*, throw a *TypeError* exception.\n  1. Let _elementLength_ be TypedArrayLength(_srcRecord_).\n  1. Let _byteLength_ be _elementSize_ × _elementLength_.\n  1. If _elementType_ is _srcType_, then\n    1. Let _data_ be ? CloneArrayBuffer(_srcData_, _srcByteOffset_, _byteLength_).\n  1. Else,\n    1. Let _data_ be ? AllocateArrayBuffer(%ArrayBuffer%, _byteLength_).\n    1. If _srcArray_.[[ContentType]] is not _O_.[[ContentType]], throw a *TypeError* exception.\n    1. Let _srcByteIndex_ be _srcByteOffset_.\n    1. Let _targetByteIndex_ be 0.\n    1. Let _count_ be _elementLength_.\n    1. Repeat, while _count_ > 0,\n      1. Let _value_ be GetValueFromBuffer(_srcData_, _srcByteIndex_, _srcType_, *true*, ~unordered~).\n      1. Perform SetValueInBuffer(_data_, _targetByteIndex_, _elementType_, _value_, *true*, ~unordered~).\n      1. Set _srcByteIndex_ to _srcByteIndex_ + _srcElementSize_.\n      1. Set _targetByteIndex_ to _targetByteIndex_ + _elementSize_.\n      1. Set _count_ to _count_ - 1.\n  1. Set _O_.[[ViewedArrayBuffer]] to _data_.\n  1. Set _O_.[[ByteLength]] to _byteLength_.\n  1. Set _O_.[[ByteOffset]] to 0.\n  1. Set _O_.[[ArrayLength]] to _elementLength_.\n  1. Return ~unused~.","code":"\n            1. Let _srcData_ be _srcArray_.[[ViewedArrayBuffer]].\n            1. Let _elementType_ be TypedArrayElementType(_O_).\n            1. Let _elementSize_ be TypedArrayElementSize(_O_).\n            1. Let _srcType_ be TypedArrayElementType(_srcArray_).\n            1. Let _srcElementSize_ be TypedArrayElementSize(_srcArray_).\n            1. Let _srcByteOffset_ be _srcArray_.[[ByteOffset]].\n            1. Let _srcRecord_ be MakeTypedArrayWithBufferWitnessRecord(_srcArray_, ~seq-cst~).\n            1. If IsTypedArrayOutOfBounds(_srcRecord_) is *true*, throw a *TypeError* exception.\n            1. Let _elementLength_ be TypedArrayLength(_srcRecord_).\n            1. Let _byteLength_ be _elementSize_ × _elementLength_.\n            1. If _elementType_ is _srcType_, then\n              1. Let _data_ be ? CloneArrayBuffer(_srcData_, _srcByteOffset_, _byteLength_).\n            1. Else,\n              1. Let _data_ be ? <emu-meta suppress-effects=\"user-code\">AllocateArrayBuffer(%ArrayBuffer%, _byteLength_)</emu-meta>.\n              1. If _srcArray_.[[ContentType]] is not _O_.[[ContentType]], throw a *TypeError* exception.\n              1. Let _srcByteIndex_ be _srcByteOffset_.\n              1. Let _targetByteIndex_ be 0.\n              1. Let _count_ be _elementLength_.\n              1. Repeat, while _count_ > 0,\n                1. Let _value_ be GetValueFromBuffer(_srcData_, _srcByteIndex_, _srcType_, *true*, ~unordered~).\n                1. Perform SetValueInBuffer(_data_, _targetByteIndex_, _elementType_, _value_, *true*, ~unordered~).\n                1. Set _srcByteIndex_ to _srcByteIndex_ + _srcElementSize_.\n                1. Set _targetByteIndex_ to _targetByteIndex_ + _elementSize_.\n                1. Set _count_ to _count_ - 1.\n            1. Set _O_.[[ViewedArrayBuffer]] to _data_.\n            1. Set _O_.[[ByteLength]] to _byteLength_.\n            1. Set _O_.[[ByteOffset]] to 0.\n            1. Set _O_.[[ArrayLength]] to _elementLength_.\n            1. Return ~unused~.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"InitializeTypedArrayFromArrayBuffer","params":[{"name":"O","ty":"Record[TypedArray]","kind":{"Normal":{}}},{"name":"buffer","ty":"Record[ArrayBuffer | SharedArrayBuffer]","kind":{"Normal":{}}},{"name":"byteOffset","ty":"ESValue","kind":{"Normal":{}}},{"name":"length","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Let _elementSize_ be TypedArrayElementSize(_O_).\n  1. Let _offset_ be ? ToIndex(_byteOffset_).\n  1. If _offset_ modulo _elementSize_ ≠ 0, throw a *RangeError* exception.\n  1. Let _bufferIsFixedLength_ be IsFixedLengthArrayBuffer(_buffer_).\n  1. If _length_ is not *undefined*, then\n    1. Let _newLength_ be ? ToIndex(_length_).\n  1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.\n  1. Let _bufferByteLength_ be ArrayBufferByteLength(_buffer_, ~seq-cst~).\n  1. If _length_ is *undefined* and _bufferIsFixedLength_ is *false*, then\n    1. If _offset_ > _bufferByteLength_, throw a *RangeError* exception.\n    1. Set _O_.[[ByteLength]] to ~auto~.\n    1. Set _O_.[[ArrayLength]] to ~auto~.\n  1. Else,\n    1. If _length_ is *undefined*, then\n      1. If _bufferByteLength_ modulo _elementSize_ ≠ 0, throw a *RangeError* exception.\n      1. Let _newByteLength_ be _bufferByteLength_ - _offset_.\n      1. If _newByteLength_ < 0, throw a *RangeError* exception.\n    1. Else,\n      1. Let _newByteLength_ be _newLength_ × _elementSize_.\n      1. If _offset_ + _newByteLength_ > _bufferByteLength_, throw a *RangeError* exception.\n    1. Set _O_.[[ByteLength]] to _newByteLength_.\n    1. Set _O_.[[ArrayLength]] to _newByteLength_ / _elementSize_.\n  1. Set _O_.[[ViewedArrayBuffer]] to _buffer_.\n  1. Set _O_.[[ByteOffset]] to _offset_.\n  1. Return ~unused~.","code":"\n            1. Let _elementSize_ be TypedArrayElementSize(_O_).\n            1. Let _offset_ be ? ToIndex(_byteOffset_).\n            1. If _offset_ modulo _elementSize_ ≠ 0, throw a *RangeError* exception.\n            1. Let _bufferIsFixedLength_ be IsFixedLengthArrayBuffer(_buffer_).\n            1. If _length_ is not *undefined*, then\n              1. Let _newLength_ be ? ToIndex(_length_).\n            1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.\n            1. Let _bufferByteLength_ be ArrayBufferByteLength(_buffer_, ~seq-cst~).\n            1. If _length_ is *undefined* and _bufferIsFixedLength_ is *false*, then\n              1. If _offset_ > _bufferByteLength_, throw a *RangeError* exception.\n              1. Set _O_.[[ByteLength]] to ~auto~.\n              1. Set _O_.[[ArrayLength]] to ~auto~.\n            1. Else,\n              1. If _length_ is *undefined*, then\n                1. If _bufferByteLength_ modulo _elementSize_ ≠ 0, throw a *RangeError* exception.\n                1. Let _newByteLength_ be _bufferByteLength_ - _offset_.\n                1. If _newByteLength_ < 0, throw a *RangeError* exception.\n              1. Else,\n                1. Let _newByteLength_ be _newLength_ × _elementSize_.\n                1. If _offset_ + _newByteLength_ > _bufferByteLength_, throw a *RangeError* exception.\n              1. Set _O_.[[ByteLength]] to _newByteLength_.\n              1. Set _O_.[[ArrayLength]] to _newByteLength_ / _elementSize_.\n            1. Set _O_.[[ViewedArrayBuffer]] to _buffer_.\n            1. Set _O_.[[ByteOffset]] to _offset_.\n            1. Return ~unused~.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"InitializeTypedArrayFromList","params":[{"name":"O","ty":"Record[TypedArray]","kind":{"Normal":{}}},{"name":"values","ty":"List[ESValue]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Let _len_ be the number of elements in _values_.\n  1. Perform ? AllocateTypedArrayBuffer(_O_, _len_).\n  1. Let _k_ be 0.\n  1. Repeat, while _k_ < _len_,\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. Let _kValue_ be _values_[0].\n    1. Remove the first element from _values_.\n    1. Perform ? Set(_O_, _Pk_, _kValue_, *true*).\n    1. Set _k_ to _k_ + 1.\n  1. Assert: _values_ is now an empty List..\n  1. Return ~unused~.","code":"\n            1. Let _len_ be the number of elements in _values_.\n            1. Perform ? AllocateTypedArrayBuffer(_O_, _len_).\n            1. Let _k_ be 0.\n            1. Repeat, while _k_ < _len_,\n              1. Let _Pk_ be ! ToString(𝔽(_k_)).\n              1. Let _kValue_ be the first element of _values_.\n              1. Remove the first element from _values_.\n              1. Perform ? Set(_O_, _Pk_, _kValue_, *true*).\n              1. Set _k_ to _k_ + 1.\n            1. Assert: _values_ is now an empty List.\n            1. Return ~unused~.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"InitializeTypedArrayFromArrayLike","params":[{"name":"O","ty":"Record[TypedArray]","kind":{"Normal":{}}},{"name":"arrayLike","ty":"Unknown[\"an Object, but not a TypedArray or an ArrayBuffer\"]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Let _len_ be ? LengthOfArrayLike(_arrayLike_).\n  1. Perform ? AllocateTypedArrayBuffer(_O_, _len_).\n  1. Let _k_ be 0.\n  1. Repeat, while _k_ < _len_,\n    1. Let _Pk_ be ! ToString(𝔽(_k_)).\n    1. Let _kValue_ be ? Get(_arrayLike_, _Pk_).\n    1. Perform ? Set(_O_, _Pk_, _kValue_, *true*).\n    1. Set _k_ to _k_ + 1.\n  1. Return ~unused~.","code":"\n            1. Let _len_ be ? LengthOfArrayLike(_arrayLike_).\n            1. Perform ? AllocateTypedArrayBuffer(_O_, _len_).\n            1. Let _k_ be 0.\n            1. Repeat, while _k_ < _len_,\n              1. Let _Pk_ be ! ToString(𝔽(_k_)).\n              1. Let _kValue_ be ? Get(_arrayLike_, _Pk_).\n              1. Perform ? Set(_O_, _Pk_, _kValue_, *true*).\n              1. Set _k_ to _k_ + 1.\n            1. Return ~unused~.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AllocateTypedArrayBuffer","params":[{"name":"O","ty":"Record[TypedArray]","kind":{"Normal":{}}},{"name":"length","ty":"NonNegInt","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Assert: _O_.[[ViewedArrayBuffer]] is *undefined*.\n  1. Let _elementSize_ be TypedArrayElementSize(_O_).\n  1. Let _byteLength_ be _elementSize_ × _length_.\n  1. Let _data_ be ? AllocateArrayBuffer(%ArrayBuffer%, _byteLength_).\n  1. Set _O_.[[ViewedArrayBuffer]] to _data_.\n  1. Set _O_.[[ByteLength]] to _byteLength_.\n  1. Set _O_.[[ByteOffset]] to 0.\n  1. Set _O_.[[ArrayLength]] to _length_.\n  1. Return ~unused~.","code":"\n            1. Assert: _O_.[[ViewedArrayBuffer]] is *undefined*.\n            1. Let _elementSize_ be TypedArrayElementSize(_O_).\n            1. Let _byteLength_ be _elementSize_ × _length_.\n            1. Let _data_ be ? <emu-meta suppress-effects=\"user-code\">AllocateArrayBuffer(%ArrayBuffer%, _byteLength_)</emu-meta>.\n            1. Set _O_.[[ViewedArrayBuffer]] to _data_.\n            1. Set _O_.[[ByteLength]] to _byteLength_.\n            1. Set _O_.[[ByteOffset]] to 0.\n            1. Set _O_.[[ArrayLength]] to _length_.\n            1. Return ~unused~.\n          "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"Map"}},"params":[{"name":"iterable","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. If NewTarget is *undefined*, throw a *TypeError* exception.\n  1. Let _map_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Map.prototype%\"*, « [[MapData]] »).\n  1. Set _map_.[[MapData]] to « ».\n  1. If _iterable_ is either *undefined* or *null*, return _map_.\n  1. Let _adder_ be ? Get(_map_, *\"set\"*).\n  1. If IsCallable(_adder_) is *false*, throw a *TypeError* exception.\n  1. Return ? AddEntriesFromIterable(_map_, _iterable_, _adder_).","code":"\n          1. If NewTarget is *undefined*, throw a *TypeError* exception.\n          1. Let _map_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Map.prototype%\"*, « [[MapData]] »).\n          1. Set _map_.[[MapData]] to a new empty List.\n          1. If _iterable_ is either *undefined* or *null*, return _map_.\n          1. Let _adder_ be ? Get(_map_, *\"set\"*).\n          1. If IsCallable(_adder_) is *false*, throw a *TypeError* exception.\n          1. Return ? AddEntriesFromIterable(_map_, _iterable_, _adder_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AddEntriesFromIterable","params":[{"name":"target","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"iterable","ty":"Unknown[\"an ECMAScript language value, but not *undefined* or *null*\"]","kind":{"Normal":{}}},{"name":"adder","ty":"Record[FunctionObject]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Let _iteratorRecord_ be ? GetIterator(_iterable_, ~sync~).\n  1. Repeat, \n    1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n    1. If _next_ is ~done~, return _target_.\n    1. If _next_ is not a Record[Object], then\n      1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).\n      1. Return ? IteratorClose(_iteratorRecord_, _error_).\n    1. Let _k_ be Completion(Get(_next_, *\"0\"*)).\n    1. Perform IfAbruptCloseIterator(_k_, _iteratorRecord_).\n    1. Let _v_ be Completion(Get(_next_, *\"1\"*)).\n    1. Perform IfAbruptCloseIterator(_v_, _iteratorRecord_).\n    1. Let _status_ be Completion(Call(_adder_, _target_, « _k_, _v_ »)).\n    1. Perform IfAbruptCloseIterator(_status_, _iteratorRecord_).","code":"\n          1. Let _iteratorRecord_ be ? GetIterator(_iterable_, ~sync~).\n          1. Repeat,\n            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n            1. If _next_ is ~done~, return _target_.\n            1. If _next_ is not an Object, then\n              1. Let _error_ be ThrowCompletion(a newly created *TypeError* object).\n              1. Return ? IteratorClose(_iteratorRecord_, _error_).\n            1. Let _k_ be Completion(Get(_next_, *\"0\"*)).\n            1. IfAbruptCloseIterator(_k_, _iteratorRecord_).\n            1. Let _v_ be Completion(Get(_next_, *\"1\"*)).\n            1. IfAbruptCloseIterator(_v_, _iteratorRecord_).\n            1. Let _status_ be Completion(Call(_adder_, _target_, « _k_, _v_ »)).\n            1. IfAbruptCloseIterator(_status_, _iteratorRecord_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Map"}},"name":"groupBy"}},"params":[{"name":"items","ty":"Unknown","kind":{"Normal":{}}},{"name":"callbackfn","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _groups_ be ? GroupBy(_items_, _callbackfn_, ~zero~).\n  1. Let _map_ be ! Construct(%Map%).\n  1. For each Record[{ Elements, Key }] _g_ of _groups_, do\n    1. Let _elements_ be CreateArrayFromList(_g_.[[Elements]]).\n    1. Let _entry_ be Record { [[Key]]: _g_.[[Key]], [[Value]]: _elements_ }.\n    1. Append _entry_ to _map_.[[MapData]].\n  1. Return _map_.","code":"\n          1. Let _groups_ be ? GroupBy(_items_, _callbackfn_, ~zero~).\n          1. Let _map_ be ! Construct(%Map%).\n          1. For each Record { [[Key]], [[Elements]] } _g_ of _groups_, do\n            1. Let _elements_ be CreateArrayFromList(_g_.[[Elements]]).\n            1. Let _entry_ be the Record { [[Key]]: _g_.[[Key]], [[Value]]: _elements_ }.\n            1. Append _entry_ to _map_.[[MapData]].\n          1. Return _map_.\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"SymbolAccess":{"base":{"Base":{"name":"Map"}},"symbol":"species"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Return *this* value.","code":"\n          1. Return the *this* value.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Map"}},"name":"prototype"}},"name":"clear"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _M_ be *this* value.\n  1. Perform ? RequireInternalSlot(_M_, [[MapData]]).\n  1. For each Record[{ Key, Value }] _p_ of _M_.[[MapData]], do\n    1. Set _p_.[[Key]] to ~empty~.\n    1. Set _p_.[[Value]] to ~empty~.\n  1. Return *undefined*.","code":"\n          1. Let _M_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).\n          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[MapData]], do\n            1. Set _p_.[[Key]] to ~empty~.\n            1. Set _p_.[[Value]] to ~empty~.\n          1. Return *undefined*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Map"}},"name":"prototype"}},"name":"delete"}},"params":[{"name":"key","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _M_ be *this* value.\n  1. Perform ? RequireInternalSlot(_M_, [[MapData]]).\n  1. For each Record[{ Key, Value }] _p_ of _M_.[[MapData]], do\n    1. If _p_.[[Key]] is not ~empty~ and SameValueZero(_p_.[[Key]], _key_) is *true*, then\n      1. Set _p_.[[Key]] to ~empty~.\n      1. Set _p_.[[Value]] to ~empty~.\n      1. Return *true*.\n  1. Return *false*.","code":"\n          1. Let _M_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).\n          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[MapData]], do\n            1. If _p_.[[Key]] is not ~empty~ and SameValueZero(_p_.[[Key]], _key_) is *true*, then\n              1. Set _p_.[[Key]] to ~empty~.\n              1. Set _p_.[[Value]] to ~empty~.\n              1. Return *true*.\n          1. Return *false*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Map"}},"name":"prototype"}},"name":"entries"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _M_ be *this* value.\n  1. Return ? CreateMapIterator(_M_, ~key+value~).","code":"\n          1. Let _M_ be the *this* value.\n          1. Return ? CreateMapIterator(_M_, ~key+value~).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Map"}},"name":"prototype"}},"name":"forEach"}},"params":[{"name":"callbackfn","ty":"Unknown","kind":{"Normal":{}}},{"name":"thisArg","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _M_ be *this* value.\n  1. Perform ? RequireInternalSlot(_M_, [[MapData]]).\n  1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n  1. Let _entries_ be _M_.[[MapData]].\n  1. Let _numEntries_ be the number of elements in _entries_.\n  1. Let _index_ be 0.\n  1. Repeat, while _index_ < _numEntries_,\n    1. Let _e_ be _entries_[_index_].\n    1. Set _index_ to _index_ + 1.\n    1. If _e_.[[Key]] is not ~empty~, then\n      1. Perform ? Call(_callbackfn_, _thisArg_, « _e_.[[Value]], _e_.[[Key]], _M_ »).\n      1. NOTE: The number of elements in _entries_ may have increased during execution of _callbackfn_.\n      1. Set _numEntries_ to the number of elements in _entries_.\n  1. Return *undefined*.","code":"\n          1. Let _M_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. Let _entries_ be _M_.[[MapData]].\n          1. Let _numEntries_ be the number of elements in _entries_.\n          1. Let _index_ be 0.\n          1. Repeat, while _index_ < _numEntries_,\n            1. Let _e_ be _entries_[_index_].\n            1. Set _index_ to _index_ + 1.\n            1. If _e_.[[Key]] is not ~empty~, then\n              1. Perform ? Call(_callbackfn_, _thisArg_, « _e_.[[Value]], _e_.[[Key]], _M_ »).\n              1. NOTE: The number of elements in _entries_ may have increased during execution of _callbackfn_.\n              1. Set _numEntries_ to the number of elements in _entries_.\n          1. Return *undefined*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Map"}},"name":"prototype"}},"name":"get"}},"params":[{"name":"key","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _M_ be *this* value.\n  1. Perform ? RequireInternalSlot(_M_, [[MapData]]).\n  1. For each Record[{ Key, Value }] _p_ of _M_.[[MapData]], do\n    1. If _p_.[[Key]] is not ~empty~ and SameValueZero(_p_.[[Key]], _key_) is *true*, return _p_.[[Value]].\n  1. Return *undefined*.","code":"\n          1. Let _M_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).\n          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[MapData]], do\n            1. If _p_.[[Key]] is not ~empty~ and SameValueZero(_p_.[[Key]], _key_) is *true*, return _p_.[[Value]].\n          1. Return *undefined*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Map"}},"name":"prototype"}},"name":"has"}},"params":[{"name":"key","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _M_ be *this* value.\n  1. Perform ? RequireInternalSlot(_M_, [[MapData]]).\n  1. For each Record[{ Key, Value }] _p_ of _M_.[[MapData]], do\n    1. If _p_.[[Key]] is not ~empty~ and SameValueZero(_p_.[[Key]], _key_) is *true*, return *true*.\n  1. Return *false*.","code":"\n          1. Let _M_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).\n          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[MapData]], do\n            1. If _p_.[[Key]] is not ~empty~ and SameValueZero(_p_.[[Key]], _key_) is *true*, return *true*.\n          1. Return *false*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Map"}},"name":"prototype"}},"name":"keys"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _M_ be *this* value.\n  1. Return ? CreateMapIterator(_M_, ~key~).","code":"\n          1. Let _M_ be the *this* value.\n          1. Return ? CreateMapIterator(_M_, ~key~).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Map"}},"name":"prototype"}},"name":"set"}},"params":[{"name":"key","ty":"Unknown","kind":{"Normal":{}}},{"name":"value","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _M_ be *this* value.\n  1. Perform ? RequireInternalSlot(_M_, [[MapData]]).\n  1. For each Record[{ Key, Value }] _p_ of _M_.[[MapData]], do\n    1. If _p_.[[Key]] is not ~empty~ and SameValueZero(_p_.[[Key]], _key_) is *true*, then\n      1. Set _p_.[[Value]] to _value_.\n      1. Return _M_.\n  1. If _key_ is *-0*<sub>𝔽</sub>, set _key_ to *+0*<sub>𝔽</sub>.\n  1. Let _p_ be Record { [[Key]]: _key_, [[Value]]: _value_ }.\n  1. Append _p_ to _M_.[[MapData]].\n  1. Return _M_.","code":"\n          1. Let _M_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).\n          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[MapData]], do\n            1. If _p_.[[Key]] is not ~empty~ and SameValueZero(_p_.[[Key]], _key_) is *true*, then\n              1. Set _p_.[[Value]] to _value_.\n              1. Return _M_.\n          1. If _key_ is *-0*<sub>𝔽</sub>, set _key_ to *+0*<sub>𝔽</sub>.\n          1. Let _p_ be the Record { [[Key]]: _key_, [[Value]]: _value_ }.\n          1. Append _p_ to _M_.[[MapData]].\n          1. Return _M_.\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Map"}},"name":"prototype"}},"name":"size"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _M_ be *this* value.\n  1. Perform ? RequireInternalSlot(_M_, [[MapData]]).\n  1. Let _count_ be 0.\n  1. For each Record[{ Key, Value }] _p_ of _M_.[[MapData]], do\n    1. If _p_.[[Key]] is not ~empty~, set _count_ to _count_ + 1.\n  1. Return 𝔽(_count_).","code":"\n          1. Let _M_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_M_, [[MapData]]).\n          1. Let _count_ be 0.\n          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[MapData]], do\n            1. If _p_.[[Key]] is not ~empty~, set _count_ to _count_ + 1.\n          1. Return 𝔽(_count_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Map"}},"name":"prototype"}},"name":"values"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _M_ be *this* value.\n  1. Return ? CreateMapIterator(_M_, ~value~).","code":"\n          1. Let _M_ be the *this* value.\n          1. Return ? CreateMapIterator(_M_, ~value~).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CreateMapIterator","params":[{"name":"map","ty":"ESValue","kind":{"Normal":{}}},{"name":"kind","ty":"Enum[~key+value~, ~key~, ~value~]","kind":{"Normal":{}}}],"retTy":"Normal[Record[Generator]] | Throw"}},"body":"\n  1. Perform ? RequireInternalSlot(_map_, [[MapData]]).\n  1. Let _closure_ be a new Abstract Closure with no parameters that captures _map_ and _kind_ and performs the following steps when called:\n    1. Let _entries_ be _map_.[[MapData]].\n    1. Let _index_ be 0.\n    1. Let _numEntries_ be the number of elements in _entries_.\n    1. Repeat, while _index_ < _numEntries_,\n      1. Let _e_ be _entries_[_index_].\n      1. Set _index_ to _index_ + 1.\n      1. If _e_.[[Key]] is not ~empty~, then\n        1. If _kind_ is ~key~, then\n          1. Let _result_ be _e_.[[Key]].\n        1. Else if _kind_ is ~value~, then\n          1. Let _result_ be _e_.[[Value]].\n        1. Else,\n          1. Assert: _kind_ is ~key+value~.\n          1. Let _result_ be CreateArrayFromList(« _e_.[[Key]], _e_.[[Value]] »).\n        1. Perform ? GeneratorYield(CreateIterResultObject(_result_, *false*)).\n        1. NOTE: The number of elements in _entries_ may have increased while execution of this abstract operation was paused by Yield.\n        1. Set _numEntries_ to the number of elements in _entries_.\n    1. Return NormalCompletion(*undefined*).\n  1. Return CreateIteratorFromClosure(_closure_, *\"%MapIteratorPrototype%\"*, %MapIteratorPrototype%).","code":"\n          1. Perform ? RequireInternalSlot(_map_, [[MapData]]).\n          1. Let _closure_ be a new Abstract Closure with no parameters that captures _map_ and _kind_ and performs the following steps when called:\n            1. Let _entries_ be _map_.[[MapData]].\n            1. Let _index_ be 0.\n            1. Let _numEntries_ be the number of elements in _entries_.\n            1. Repeat, while _index_ < _numEntries_,\n              1. Let _e_ be _entries_[_index_].\n              1. Set _index_ to _index_ + 1.\n              1. If _e_.[[Key]] is not ~empty~, then\n                1. If _kind_ is ~key~, then\n                  1. Let _result_ be _e_.[[Key]].\n                1. Else if _kind_ is ~value~, then\n                  1. Let _result_ be _e_.[[Value]].\n                1. Else,\n                  1. Assert: _kind_ is ~key+value~.\n                  1. Let _result_ be CreateArrayFromList(« _e_.[[Key]], _e_.[[Value]] »).\n                1. Perform ? GeneratorYield(CreateIterResultObject(_result_, *false*)).\n                1. NOTE: The number of elements in _entries_ may have increased while execution of this abstract operation was paused by Yield.\n                1. Set _numEntries_ to the number of elements in _entries_.\n            1. Return NormalCompletion(*undefined*).\n          1. Return CreateIteratorFromClosure(_closure_, *\"%MapIteratorPrototype%\"*, %MapIteratorPrototype%).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"MapIteratorPrototype"}},"name":"next"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Return ? GeneratorResume(*this* value, ~empty~, *\"%MapIteratorPrototype%\"*).","code":"\n            1. Return ? <emu-meta suppress-effects=\"user-code\">GeneratorResume(*this* value, ~empty~, *\"%MapIteratorPrototype%\"*)</emu-meta>.\n          "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"Set"}},"params":[{"name":"iterable","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. If NewTarget is *undefined*, throw a *TypeError* exception.\n  1. Let _set_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Set.prototype%\"*, « [[SetData]] »).\n  1. Set _set_.[[SetData]] to « ».\n  1. If _iterable_ is either *undefined* or *null*, return _set_.\n  1. Let _adder_ be ? Get(_set_, *\"add\"*).\n  1. If IsCallable(_adder_) is *false*, throw a *TypeError* exception.\n  1. Let _iteratorRecord_ be ? GetIterator(_iterable_, ~sync~).\n  1. Repeat, \n    1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n    1. If _next_ is ~done~, return _set_.\n    1. Let _status_ be Completion(Call(_adder_, _set_, « _next_ »)).\n    1. Perform IfAbruptCloseIterator(_status_, _iteratorRecord_).","code":"\n          1. If NewTarget is *undefined*, throw a *TypeError* exception.\n          1. Let _set_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Set.prototype%\"*, « [[SetData]] »).\n          1. Set _set_.[[SetData]] to a new empty List.\n          1. If _iterable_ is either *undefined* or *null*, return _set_.\n          1. Let _adder_ be ? Get(_set_, *\"add\"*).\n          1. If IsCallable(_adder_) is *false*, throw a *TypeError* exception.\n          1. Let _iteratorRecord_ be ? GetIterator(_iterable_, ~sync~).\n          1. Repeat,\n            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n            1. If _next_ is ~done~, return _set_.\n            1. Let _status_ be Completion(Call(_adder_, _set_, « _next_ »)).\n            1. IfAbruptCloseIterator(_status_, _iteratorRecord_).\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"SymbolAccess":{"base":{"Base":{"name":"Set"}},"symbol":"species"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Return *this* value.","code":"\n          1. Return the *this* value.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Set"}},"name":"prototype"}},"name":"add"}},"params":[{"name":"value","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _S_ be *this* value.\n  1. Perform ? RequireInternalSlot(_S_, [[SetData]]).\n  1. For each _e_ of _S_.[[SetData]], do\n    1. If _e_ is not ~empty~ and SameValueZero(_e_, _value_) is *true*, then\n      1. Return _S_.\n  1. If _value_ is *-0*<sub>𝔽</sub>, set _value_ to *+0*<sub>𝔽</sub>.\n  1. Append _value_ to _S_.[[SetData]].\n  1. Return _S_.","code":"\n          1. Let _S_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).\n          1. For each element _e_ of _S_.[[SetData]], do\n            1. If _e_ is not ~empty~ and SameValueZero(_e_, _value_) is *true*, then\n              1. Return _S_.\n          1. If _value_ is *-0*<sub>𝔽</sub>, set _value_ to *+0*<sub>𝔽</sub>.\n          1. Append _value_ to _S_.[[SetData]].\n          1. Return _S_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Set"}},"name":"prototype"}},"name":"clear"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _S_ be *this* value.\n  1. Perform ? RequireInternalSlot(_S_, [[SetData]]).\n  1. For each _e_ of _S_.[[SetData]], do\n    1. Replace the element of _S_.[[SetData]] whose value is _e_ with an element whose value is ~empty~.\n  1. Return *undefined*.","code":"\n          1. Let _S_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).\n          1. For each element _e_ of _S_.[[SetData]], do\n            1. Replace the element of _S_.[[SetData]] whose value is _e_ with an element whose value is ~empty~.\n          1. Return *undefined*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Set"}},"name":"prototype"}},"name":"delete"}},"params":[{"name":"value","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _S_ be *this* value.\n  1. Perform ? RequireInternalSlot(_S_, [[SetData]]).\n  1. For each _e_ of _S_.[[SetData]], do\n    1. If _e_ is not ~empty~ and SameValueZero(_e_, _value_) is *true*, then\n      1. Replace the element of _S_.[[SetData]] whose value is _e_ with an element whose value is ~empty~.\n      1. Return *true*.\n  1. Return *false*.","code":"\n          1. Let _S_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).\n          1. For each element _e_ of _S_.[[SetData]], do\n            1. If _e_ is not ~empty~ and SameValueZero(_e_, _value_) is *true*, then\n              1. Replace the element of _S_.[[SetData]] whose value is _e_ with an element whose value is ~empty~.\n              1. Return *true*.\n          1. Return *false*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Set"}},"name":"prototype"}},"name":"entries"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _S_ be *this* value.\n  1. Return ? CreateSetIterator(_S_, ~key+value~).","code":"\n          1. Let _S_ be the *this* value.\n          1. Return ? CreateSetIterator(_S_, ~key+value~).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Set"}},"name":"prototype"}},"name":"forEach"}},"params":[{"name":"callbackfn","ty":"Unknown","kind":{"Normal":{}}},{"name":"thisArg","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _S_ be *this* value.\n  1. Perform ? RequireInternalSlot(_S_, [[SetData]]).\n  1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n  1. Let _entries_ be _S_.[[SetData]].\n  1. Let _numEntries_ be the number of elements in _entries_.\n  1. Let _index_ be 0.\n  1. Repeat, while _index_ < _numEntries_,\n    1. Let _e_ be _entries_[_index_].\n    1. Set _index_ to _index_ + 1.\n    1. If _e_ is not ~empty~, then\n      1. Perform ? Call(_callbackfn_, _thisArg_, « _e_, _e_, _S_ »).\n      1. NOTE: The number of elements in _entries_ may have increased during execution of _callbackfn_.\n      1. Set _numEntries_ to the number of elements in _entries_.\n  1. Return *undefined*.","code":"\n          1. Let _S_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).\n          1. If IsCallable(_callbackfn_) is *false*, throw a *TypeError* exception.\n          1. Let _entries_ be _S_.[[SetData]].\n          1. Let _numEntries_ be the number of elements in _entries_.\n          1. Let _index_ be 0.\n          1. Repeat, while _index_ < _numEntries_,\n            1. Let _e_ be _entries_[_index_].\n            1. Set _index_ to _index_ + 1.\n            1. If _e_ is not ~empty~, then\n              1. Perform ? Call(_callbackfn_, _thisArg_, « _e_, _e_, _S_ »).\n              1. NOTE: The number of elements in _entries_ may have increased during execution of _callbackfn_.\n              1. Set _numEntries_ to the number of elements in _entries_.\n          1. Return *undefined*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Set"}},"name":"prototype"}},"name":"has"}},"params":[{"name":"value","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _S_ be *this* value.\n  1. Perform ? RequireInternalSlot(_S_, [[SetData]]).\n  1. For each _e_ of _S_.[[SetData]], do\n    1. If _e_ is not ~empty~ and SameValueZero(_e_, _value_) is *true*, return *true*.\n  1. Return *false*.","code":"\n          1. Let _S_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).\n          1. For each element _e_ of _S_.[[SetData]], do\n            1. If _e_ is not ~empty~ and SameValueZero(_e_, _value_) is *true*, return *true*.\n          1. Return *false*.\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Set"}},"name":"prototype"}},"name":"size"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _S_ be *this* value.\n  1. Perform ? RequireInternalSlot(_S_, [[SetData]]).\n  1. Let _count_ be 0.\n  1. For each _e_ of _S_.[[SetData]], do\n    1. If _e_ is not ~empty~, set _count_ to _count_ + 1.\n  1. Return 𝔽(_count_).","code":"\n          1. Let _S_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_S_, [[SetData]]).\n          1. Let _count_ be 0.\n          1. For each element _e_ of _S_.[[SetData]], do\n            1. If _e_ is not ~empty~, set _count_ to _count_ + 1.\n          1. Return 𝔽(_count_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Set"}},"name":"prototype"}},"name":"values"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _S_ be *this* value.\n  1. Return ? CreateSetIterator(_S_, ~value~).","code":"\n          1. Let _S_ be the *this* value.\n          1. Return ? CreateSetIterator(_S_, ~value~).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CreateSetIterator","params":[{"name":"set","ty":"ESValue","kind":{"Normal":{}}},{"name":"kind","ty":"Enum[~key+value~, ~value~]","kind":{"Normal":{}}}],"retTy":"Normal[Record[Generator]] | Throw"}},"body":"\n  1. Perform ? RequireInternalSlot(_set_, [[SetData]]).\n  1. Let _closure_ be a new Abstract Closure with no parameters that captures _set_ and _kind_ and performs the following steps when called:\n    1. Let _index_ be 0.\n    1. Let _entries_ be _set_.[[SetData]].\n    1. Let _numEntries_ be the number of elements in _entries_.\n    1. Repeat, while _index_ < _numEntries_,\n      1. Let _e_ be _entries_[_index_].\n      1. Set _index_ to _index_ + 1.\n      1. If _e_ is not ~empty~, then\n        1. If _kind_ is ~key+value~, then\n          1. Let _result_ be CreateArrayFromList(« _e_, _e_ »).\n          1. Perform ? GeneratorYield(CreateIterResultObject(_result_, *false*)).\n        1. Else,\n          1. Assert: _kind_ is ~value~.\n          1. Perform ? GeneratorYield(CreateIterResultObject(_e_, *false*)).\n        1. NOTE: The number of elements in _entries_ may have increased while execution of this abstract operation was paused by Yield.\n        1. Set _numEntries_ to the number of elements in _entries_.\n    1. Return NormalCompletion(*undefined*).\n  1. Return CreateIteratorFromClosure(_closure_, *\"%SetIteratorPrototype%\"*, %SetIteratorPrototype%).","code":"\n          1. Perform ? RequireInternalSlot(_set_, [[SetData]]).\n          1. Let _closure_ be a new Abstract Closure with no parameters that captures _set_ and _kind_ and performs the following steps when called:\n            1. Let _index_ be 0.\n            1. Let _entries_ be _set_.[[SetData]].\n            1. Let _numEntries_ be the number of elements in _entries_.\n            1. Repeat, while _index_ < _numEntries_,\n              1. Let _e_ be _entries_[_index_].\n              1. Set _index_ to _index_ + 1.\n              1. If _e_ is not ~empty~, then\n                1. If _kind_ is ~key+value~, then\n                  1. Let _result_ be CreateArrayFromList(« _e_, _e_ »).\n                  1. Perform ? GeneratorYield(CreateIterResultObject(_result_, *false*)).\n                1. Else,\n                  1. Assert: _kind_ is ~value~.\n                  1. Perform ? GeneratorYield(CreateIterResultObject(_e_, *false*)).\n                1. NOTE: The number of elements in _entries_ may have increased while execution of this abstract operation was paused by Yield.\n                1. Set _numEntries_ to the number of elements in _entries_.\n            1. Return NormalCompletion(*undefined*).\n          1. Return CreateIteratorFromClosure(_closure_, *\"%SetIteratorPrototype%\"*, %SetIteratorPrototype%).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"SetIteratorPrototype"}},"name":"next"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Return ? GeneratorResume(*this* value, ~empty~, *\"%SetIteratorPrototype%\"*).","code":"\n            1. Return ? <emu-meta suppress-effects=\"user-code\">GeneratorResume(*this* value, ~empty~, *\"%SetIteratorPrototype%\"*)</emu-meta>.\n          "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"WeakMap"}},"params":[{"name":"iterable","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. If NewTarget is *undefined*, throw a *TypeError* exception.\n  1. Let _map_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%WeakMap.prototype%\"*, « [[WeakMapData]] »).\n  1. Set _map_.[[WeakMapData]] to « ».\n  1. If _iterable_ is either *undefined* or *null*, return _map_.\n  1. Let _adder_ be ? Get(_map_, *\"set\"*).\n  1. If IsCallable(_adder_) is *false*, throw a *TypeError* exception.\n  1. Return ? AddEntriesFromIterable(_map_, _iterable_, _adder_).","code":"\n          1. If NewTarget is *undefined*, throw a *TypeError* exception.\n          1. Let _map_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%WeakMap.prototype%\"*, « [[WeakMapData]] »).\n          1. Set _map_.[[WeakMapData]] to a new empty List.\n          1. If _iterable_ is either *undefined* or *null*, return _map_.\n          1. Let _adder_ be ? Get(_map_, *\"set\"*).\n          1. If IsCallable(_adder_) is *false*, throw a *TypeError* exception.\n          1. Return ? AddEntriesFromIterable(_map_, _iterable_, _adder_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"WeakMap"}},"name":"prototype"}},"name":"delete"}},"params":[{"name":"key","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _M_ be *this* value.\n  1. Perform ? RequireInternalSlot(_M_, [[WeakMapData]]).\n  1. If CanBeHeldWeakly(_key_) is *false*, return *false*.\n  1. For each Record[{ Key, Value }] _p_ of _M_.[[WeakMapData]], do\n    1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, then\n      1. Set _p_.[[Key]] to ~empty~.\n      1. Set _p_.[[Value]] to ~empty~.\n      1. Return *true*.\n  1. Return *false*.","code":"\n          1. Let _M_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_M_, [[WeakMapData]]).\n          1. If CanBeHeldWeakly(_key_) is *false*, return *false*.\n          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[WeakMapData]], do\n            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, then\n              1. Set _p_.[[Key]] to ~empty~.\n              1. Set _p_.[[Value]] to ~empty~.\n              1. Return *true*.\n          1. Return *false*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"WeakMap"}},"name":"prototype"}},"name":"get"}},"params":[{"name":"key","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _M_ be *this* value.\n  1. Perform ? RequireInternalSlot(_M_, [[WeakMapData]]).\n  1. If CanBeHeldWeakly(_key_) is *false*, return *undefined*.\n  1. For each Record[{ Key, Value }] _p_ of _M_.[[WeakMapData]], do\n    1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, return _p_.[[Value]].\n  1. Return *undefined*.","code":"\n          1. Let _M_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_M_, [[WeakMapData]]).\n          1. If CanBeHeldWeakly(_key_) is *false*, return *undefined*.\n          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[WeakMapData]], do\n            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, return _p_.[[Value]].\n          1. Return *undefined*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"WeakMap"}},"name":"prototype"}},"name":"has"}},"params":[{"name":"key","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _M_ be *this* value.\n  1. Perform ? RequireInternalSlot(_M_, [[WeakMapData]]).\n  1. If CanBeHeldWeakly(_key_) is *false*, return *false*.\n  1. For each Record[{ Key, Value }] _p_ of _M_.[[WeakMapData]], do\n    1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, return *true*.\n  1. Return *false*.","code":"\n          1. Let _M_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_M_, [[WeakMapData]]).\n          1. If CanBeHeldWeakly(_key_) is *false*, return *false*.\n          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[WeakMapData]], do\n            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, return *true*.\n          1. Return *false*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"WeakMap"}},"name":"prototype"}},"name":"set"}},"params":[{"name":"key","ty":"Unknown","kind":{"Normal":{}}},{"name":"value","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _M_ be *this* value.\n  1. Perform ? RequireInternalSlot(_M_, [[WeakMapData]]).\n  1. If CanBeHeldWeakly(_key_) is *false*, throw a *TypeError* exception.\n  1. For each Record[{ Key, Value }] _p_ of _M_.[[WeakMapData]], do\n    1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, then\n      1. Set _p_.[[Value]] to _value_.\n      1. Return _M_.\n  1. Let _p_ be Record { [[Key]]: _key_, [[Value]]: _value_ }.\n  1. Append _p_ to _M_.[[WeakMapData]].\n  1. Return _M_.","code":"\n          1. Let _M_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_M_, [[WeakMapData]]).\n          1. If CanBeHeldWeakly(_key_) is *false*, throw a *TypeError* exception.\n          1. For each Record { [[Key]], [[Value]] } _p_ of _M_.[[WeakMapData]], do\n            1. If _p_.[[Key]] is not ~empty~ and SameValue(_p_.[[Key]], _key_) is *true*, then\n              1. Set _p_.[[Value]] to _value_.\n              1. Return _M_.\n          1. Let _p_ be the Record { [[Key]]: _key_, [[Value]]: _value_ }.\n          1. Append _p_ to _M_.[[WeakMapData]].\n          1. Return _M_.\n        "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"WeakSet"}},"params":[{"name":"iterable","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. If NewTarget is *undefined*, throw a *TypeError* exception.\n  1. Let _set_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%WeakSet.prototype%\"*, « [[WeakSetData]] »).\n  1. Set _set_.[[WeakSetData]] to « ».\n  1. If _iterable_ is either *undefined* or *null*, return _set_.\n  1. Let _adder_ be ? Get(_set_, *\"add\"*).\n  1. If IsCallable(_adder_) is *false*, throw a *TypeError* exception.\n  1. Let _iteratorRecord_ be ? GetIterator(_iterable_, ~sync~).\n  1. Repeat, \n    1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n    1. If _next_ is ~done~, return _set_.\n    1. Let _status_ be Completion(Call(_adder_, _set_, « _next_ »)).\n    1. Perform IfAbruptCloseIterator(_status_, _iteratorRecord_).","code":"\n          1. If NewTarget is *undefined*, throw a *TypeError* exception.\n          1. Let _set_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%WeakSet.prototype%\"*, « [[WeakSetData]] »).\n          1. Set _set_.[[WeakSetData]] to a new empty List.\n          1. If _iterable_ is either *undefined* or *null*, return _set_.\n          1. Let _adder_ be ? Get(_set_, *\"add\"*).\n          1. If IsCallable(_adder_) is *false*, throw a *TypeError* exception.\n          1. Let _iteratorRecord_ be ? GetIterator(_iterable_, ~sync~).\n          1. Repeat,\n            1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n            1. If _next_ is ~done~, return _set_.\n            1. Let _status_ be Completion(Call(_adder_, _set_, « _next_ »)).\n            1. IfAbruptCloseIterator(_status_, _iteratorRecord_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"WeakSet"}},"name":"prototype"}},"name":"add"}},"params":[{"name":"value","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _S_ be *this* value.\n  1. Perform ? RequireInternalSlot(_S_, [[WeakSetData]]).\n  1. If CanBeHeldWeakly(_value_) is *false*, throw a *TypeError* exception.\n  1. For each _e_ of _S_.[[WeakSetData]], do\n    1. If _e_ is not ~empty~ and SameValue(_e_, _value_) is *true*, then\n      1. Return _S_.\n  1. Append _value_ to _S_.[[WeakSetData]].\n  1. Return _S_.","code":"\n          1. Let _S_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_S_, [[WeakSetData]]).\n          1. If CanBeHeldWeakly(_value_) is *false*, throw a *TypeError* exception.\n          1. For each element _e_ of _S_.[[WeakSetData]], do\n            1. If _e_ is not ~empty~ and SameValue(_e_, _value_) is *true*, then\n              1. Return _S_.\n          1. Append _value_ to _S_.[[WeakSetData]].\n          1. Return _S_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"WeakSet"}},"name":"prototype"}},"name":"delete"}},"params":[{"name":"value","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _S_ be *this* value.\n  1. Perform ? RequireInternalSlot(_S_, [[WeakSetData]]).\n  1. If CanBeHeldWeakly(_value_) is *false*, return *false*.\n  1. For each _e_ of _S_.[[WeakSetData]], do\n    1. If _e_ is not ~empty~ and SameValue(_e_, _value_) is *true*, then\n      1. Replace the element of _S_.[[WeakSetData]] whose value is _e_ with an element whose value is ~empty~.\n      1. Return *true*.\n  1. Return *false*.","code":"\n          1. Let _S_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_S_, [[WeakSetData]]).\n          1. If CanBeHeldWeakly(_value_) is *false*, return *false*.\n          1. For each element _e_ of _S_.[[WeakSetData]], do\n            1. If _e_ is not ~empty~ and SameValue(_e_, _value_) is *true*, then\n              1. Replace the element of _S_.[[WeakSetData]] whose value is _e_ with an element whose value is ~empty~.\n              1. Return *true*.\n          1. Return *false*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"WeakSet"}},"name":"prototype"}},"name":"has"}},"params":[{"name":"value","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _S_ be *this* value.\n  1. Perform ? RequireInternalSlot(_S_, [[WeakSetData]]).\n  1. If CanBeHeldWeakly(_value_) is *false*, return *false*.\n  1. For each _e_ of _S_.[[WeakSetData]], do\n    1. If _e_ is not ~empty~ and SameValue(_e_, _value_) is *true*, return *true*.\n  1. Return *false*.","code":"\n          1. Let _S_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_S_, [[WeakSetData]]).\n          1. If CanBeHeldWeakly(_value_) is *false*, return *false*.\n          1. For each element _e_ of _S_.[[WeakSetData]], do\n            1. If _e_ is not ~empty~ and SameValue(_e_, _value_) is *true*, return *true*.\n          1. Return *false*.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AllocateArrayBuffer","params":[{"name":"constructor","ty":"Record[Constructor]","kind":{"Normal":{}}},{"name":"byteLength","ty":"NonNegInt","kind":{"Normal":{}}},{"name":"maxByteLength","ty":"Enum[~empty~] | NonNegInt","kind":{"Optional":{}}}],"retTy":"Normal[Record[ArrayBuffer]] | Throw"}},"body":"\n  1. Let _slots_ be « [[ArrayBufferData]], [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]] ».\n  1. If _maxByteLength_ is present and _maxByteLength_ is not ~empty~, let _allocatingResizableBuffer_ be *true*.\n  1. Else, let _allocatingResizableBuffer_ be *false*.\n  1. If _allocatingResizableBuffer_ is *true*, then\n    1. If _byteLength_ > _maxByteLength_, throw a *RangeError* exception.\n    1. Append [[ArrayBufferMaxByteLength]] to _slots_.\n  1. Let _obj_ be ? OrdinaryCreateFromConstructor(_constructor_, *\"%ArrayBuffer.prototype%\"*, _slots_).\n  1. Let _block_ be ? CreateByteDataBlock(_byteLength_).\n  1. Set _obj_.[[ArrayBufferData]] to _block_.\n  1. Set _obj_.[[ArrayBufferByteLength]] to _byteLength_.\n  1. If _allocatingResizableBuffer_ is *true*, then\n    1. If it is not possible to create a Data Block _block_ consisting of _maxByteLength_ bytes, throw a *RangeError* exception.\n    1. NOTE: Resizable ArrayBuffers are designed to be implementable with in-place growth. Implementations may throw if, for example, virtual memory cannot be reserved up front.\n    1. Set _obj_.[[ArrayBufferMaxByteLength]] to _maxByteLength_.\n  1. Return _obj_.","code":"\n          1. Let _slots_ be « [[ArrayBufferData]], [[ArrayBufferByteLength]], [[ArrayBufferDetachKey]] ».\n          1. If _maxByteLength_ is present and _maxByteLength_ is not ~empty~, let _allocatingResizableBuffer_ be *true*; otherwise let _allocatingResizableBuffer_ be *false*.\n          1. If _allocatingResizableBuffer_ is *true*, then\n            1. If _byteLength_ > _maxByteLength_, throw a *RangeError* exception.\n            1. Append [[ArrayBufferMaxByteLength]] to _slots_.\n          1. Let _obj_ be ? OrdinaryCreateFromConstructor(_constructor_, *\"%ArrayBuffer.prototype%\"*, _slots_).\n          1. Let _block_ be ? CreateByteDataBlock(_byteLength_).\n          1. Set _obj_.[[ArrayBufferData]] to _block_.\n          1. Set _obj_.[[ArrayBufferByteLength]] to _byteLength_.\n          1. If _allocatingResizableBuffer_ is *true*, then\n            1. If it is not possible to create a Data Block _block_ consisting of _maxByteLength_ bytes, throw a *RangeError* exception.\n            1. NOTE: Resizable ArrayBuffers are designed to be implementable with in-place growth. Implementations may throw if, for example, virtual memory cannot be reserved up front.\n            1. Set _obj_.[[ArrayBufferMaxByteLength]] to _maxByteLength_.\n          1. Return _obj_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ArrayBufferByteLength","params":[{"name":"arrayBuffer","ty":"Record[ArrayBuffer | SharedArrayBuffer]","kind":{"Normal":{}}},{"name":"order","ty":"Enum[~seq-cst~, ~unordered~]","kind":{"Normal":{}}}],"retTy":"NonNegInt"}},"body":"\n  1. If IsSharedArrayBuffer(_arrayBuffer_) is *true* and _arrayBuffer_ has a [[ArrayBufferByteLengthData]] internal slot, then\n    1. Let _bufferByteLengthBlock_ be _arrayBuffer_.[[ArrayBufferByteLengthData]].\n    1. Let _rawLength_ be GetRawBytesFromSharedBlock(_bufferByteLengthBlock_, 0, ~biguint64~, *true*, _order_).\n    1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\n    1. Return ℝ(RawBytesToNumeric(~biguint64~, _rawLength_, _isLittleEndian_)).\n  1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.\n  1. Return _arrayBuffer_.[[ArrayBufferByteLength]].","code":"\n          1. If IsSharedArrayBuffer(_arrayBuffer_) is *true* and _arrayBuffer_ has an [[ArrayBufferByteLengthData]] internal slot, then\n            1. Let _bufferByteLengthBlock_ be _arrayBuffer_.[[ArrayBufferByteLengthData]].\n            1. Let _rawLength_ be GetRawBytesFromSharedBlock(_bufferByteLengthBlock_, 0, ~biguint64~, *true*, _order_).\n            1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\n            1. Return ℝ(RawBytesToNumeric(~biguint64~, _rawLength_, _isLittleEndian_)).\n          1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.\n          1. Return _arrayBuffer_.[[ArrayBufferByteLength]].\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ArrayBufferCopyAndDetach","params":[{"name":"arrayBuffer","ty":"ESValue","kind":{"Normal":{}}},{"name":"newLength","ty":"ESValue","kind":{"Normal":{}}},{"name":"preserveResizability","ty":"Enum[~fixed-length~, ~preserve-resizability~]","kind":{"Normal":{}}}],"retTy":"Normal[Record[ArrayBuffer]] | Throw"}},"body":"\n  1. Perform ? RequireInternalSlot(_arrayBuffer_, [[ArrayBufferData]]).\n  1. If IsSharedArrayBuffer(_arrayBuffer_) is *true*, throw a *TypeError* exception.\n  1. If _newLength_ is *undefined*, then\n    1. Let _newByteLength_ be _arrayBuffer_.[[ArrayBufferByteLength]].\n  1. Else,\n    1. Let _newByteLength_ be ? ToIndex(_newLength_).\n  1. If IsDetachedBuffer(_arrayBuffer_) is *true*, throw a *TypeError* exception.\n  1. If _preserveResizability_ is ~preserve-resizability~ and IsFixedLengthArrayBuffer(_arrayBuffer_) is *false*, then\n    1. Let _newMaxByteLength_ be _arrayBuffer_.[[ArrayBufferMaxByteLength]].\n  1. Else,\n    1. Let _newMaxByteLength_ be ~empty~.\n  1. If _arrayBuffer_.[[ArrayBufferDetachKey]] is not *undefined*, throw a *TypeError* exception.\n  1. Let _newBuffer_ be ? AllocateArrayBuffer(%ArrayBuffer%, _newByteLength_, _newMaxByteLength_).\n  1. Let _copyLength_ be min(_newByteLength_, _arrayBuffer_.[[ArrayBufferByteLength]]).\n  1. Let _fromBlock_ be _arrayBuffer_.[[ArrayBufferData]].\n  1. Let _toBlock_ be _newBuffer_.[[ArrayBufferData]].\n  1. Perform CopyDataBlockBytes(_toBlock_, 0, _fromBlock_, 0, _copyLength_).\n  1. NOTE: Neither creation of the new Data Block nor copying from the old Data Block are observable. Implementations may implement this method as a zero-copy move or a `realloc`.\n  1. Perform ! DetachArrayBuffer(_arrayBuffer_).\n  1. Return _newBuffer_.","code":"\n          1. Perform ? RequireInternalSlot(_arrayBuffer_, [[ArrayBufferData]]).\n          1. If IsSharedArrayBuffer(_arrayBuffer_) is *true*, throw a *TypeError* exception.\n          1. If _newLength_ is *undefined*, then\n            1. Let _newByteLength_ be _arrayBuffer_.[[ArrayBufferByteLength]].\n          1. Else,\n            1. Let _newByteLength_ be ? ToIndex(_newLength_).\n          1. If IsDetachedBuffer(_arrayBuffer_) is *true*, throw a *TypeError* exception.\n          1. If _preserveResizability_ is ~preserve-resizability~ and IsFixedLengthArrayBuffer(_arrayBuffer_) is *false*, then\n            1. Let _newMaxByteLength_ be _arrayBuffer_.[[ArrayBufferMaxByteLength]].\n          1. Else,\n            1. Let _newMaxByteLength_ be ~empty~.\n          1. If _arrayBuffer_.[[ArrayBufferDetachKey]] is not *undefined*, throw a *TypeError* exception.\n          1. Let _newBuffer_ be ? <emu-meta suppress-effects=\"user-code\">AllocateArrayBuffer(%ArrayBuffer%, _newByteLength_, _newMaxByteLength_)</emu-meta>.\n          1. Let _copyLength_ be min(_newByteLength_, _arrayBuffer_.[[ArrayBufferByteLength]]).\n          1. Let _fromBlock_ be _arrayBuffer_.[[ArrayBufferData]].\n          1. Let _toBlock_ be _newBuffer_.[[ArrayBufferData]].\n          1. Perform CopyDataBlockBytes(_toBlock_, 0, _fromBlock_, 0, _copyLength_).\n          1. NOTE: Neither creation of the new Data Block nor copying from the old Data Block are observable. Implementations may implement this method as a zero-copy move or a `realloc`.\n          1. Perform ! DetachArrayBuffer(_arrayBuffer_).\n          1. Return _newBuffer_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsDetachedBuffer","params":[{"name":"arrayBuffer","ty":"Record[ArrayBuffer | SharedArrayBuffer]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _arrayBuffer_.[[ArrayBufferData]] is *null*, return *true*.\n  1. Return *false*.","code":"\n          1. If _arrayBuffer_.[[ArrayBufferData]] is *null*, return *true*.\n          1. Return *false*.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"DetachArrayBuffer","params":[{"name":"arrayBuffer","ty":"Record[ArrayBuffer]","kind":{"Normal":{}}},{"name":"key","ty":"Unknown[\"anything\"]","kind":{"Optional":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Assert: IsSharedArrayBuffer(_arrayBuffer_) is *false*.\n  1. If _key_ is not present, set _key_ to *undefined*.\n  1. If _arrayBuffer_.[[ArrayBufferDetachKey]] is not _key_, throw a *TypeError* exception.\n  1. Set _arrayBuffer_.[[ArrayBufferData]] to *null*.\n  1. Set _arrayBuffer_.[[ArrayBufferByteLength]] to 0.\n  1. Return ~unused~.","code":"\n          1. Assert: IsSharedArrayBuffer(_arrayBuffer_) is *false*.\n          1. If _key_ is not present, set _key_ to *undefined*.\n          1. If _arrayBuffer_.[[ArrayBufferDetachKey]] is not _key_, throw a *TypeError* exception.\n          1. Set _arrayBuffer_.[[ArrayBufferData]] to *null*.\n          1. Set _arrayBuffer_.[[ArrayBufferByteLength]] to 0.\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CloneArrayBuffer","params":[{"name":"srcBuffer","ty":"Record[ArrayBuffer | SharedArrayBuffer]","kind":{"Normal":{}}},{"name":"srcByteOffset","ty":"NonNegInt","kind":{"Normal":{}}},{"name":"srcLength","ty":"NonNegInt","kind":{"Normal":{}}}],"retTy":"Normal[Record[ArrayBuffer]] | Throw"}},"body":"\n  1. Assert: IsDetachedBuffer(_srcBuffer_) is *false*.\n  1. Let _targetBuffer_ be ? AllocateArrayBuffer(%ArrayBuffer%, _srcLength_).\n  1. Let _srcBlock_ be _srcBuffer_.[[ArrayBufferData]].\n  1. Let _targetBlock_ be _targetBuffer_.[[ArrayBufferData]].\n  1. Perform CopyDataBlockBytes(_targetBlock_, 0, _srcBlock_, _srcByteOffset_, _srcLength_).\n  1. Return _targetBuffer_.","code":"\n          1. Assert: IsDetachedBuffer(_srcBuffer_) is *false*.\n          1. Let _targetBuffer_ be ? <emu-meta suppress-effects=\"user-code\">AllocateArrayBuffer(%ArrayBuffer%, _srcLength_)</emu-meta>.\n          1. Let _srcBlock_ be _srcBuffer_.[[ArrayBufferData]].\n          1. Let _targetBlock_ be _targetBuffer_.[[ArrayBufferData]].\n          1. Perform CopyDataBlockBytes(_targetBlock_, 0, _srcBlock_, _srcByteOffset_, _srcLength_).\n          1. Return _targetBuffer_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetArrayBufferMaxByteLengthOption","params":[{"name":"options","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~empty~] | NonNegInt] | Throw"}},"body":"\n  1. If _options_ is not a Record[Object], return ~empty~.\n  1. Let _maxByteLength_ be ? Get(_options_, *\"maxByteLength\"*).\n  1. If _maxByteLength_ is *undefined*, return ~empty~.\n  1. Return ? ToIndex(_maxByteLength_).","code":"\n          1. If _options_ is not an Object, return ~empty~.\n          1. Let _maxByteLength_ be ? Get(_options_, *\"maxByteLength\"*).\n          1. If _maxByteLength_ is *undefined*, return ~empty~.\n          1. Return ? ToIndex(_maxByteLength_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsFixedLengthArrayBuffer","params":[{"name":"arrayBuffer","ty":"Record[ArrayBuffer | SharedArrayBuffer]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _arrayBuffer_ has a [[ArrayBufferMaxByteLength]] internal slot, return *false*.\n  1. Return *true*.","code":"\n          1. If _arrayBuffer_ has an [[ArrayBufferMaxByteLength]] internal slot, return *false*.\n          1. Return *true*.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsUnsignedElementType","params":[{"name":"type","ty":"Unknown[\"a TypedArray element type\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _type_ is either ~uint8~, ~uint8clamped~, ~uint16~, ~uint32~, or ~biguint64~, return *true*.\n  1. Return *false*.","code":"\n          1. If _type_ is one of ~uint8~, ~uint8clamped~, ~uint16~, ~uint32~, or ~biguint64~, return *true*.\n          1. Return *false*.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsUnclampedIntegerElementType","params":[{"name":"type","ty":"Unknown[\"a TypedArray element type\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _type_ is either ~int8~, ~uint8~, ~int16~, ~uint16~, ~int32~, or ~uint32~, return *true*.\n  1. Return *false*.","code":"\n          1. If _type_ is one of ~int8~, ~uint8~, ~int16~, ~uint16~, ~int32~, or ~uint32~, return *true*.\n          1. Return *false*.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsBigIntElementType","params":[{"name":"type","ty":"Unknown[\"a TypedArray element type\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _type_ is either ~biguint64~ or ~bigint64~, return *true*.\n  1. Return *false*.","code":"\n          1. If _type_ is either ~biguint64~ or ~bigint64~, return *true*.\n          1. Return *false*.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsNoTearConfiguration","params":[{"name":"type","ty":"Unknown[\"a TypedArray element type\"]","kind":{"Normal":{}}},{"name":"order","ty":"Enum[~init~, ~seq-cst~, ~unordered~]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If IsUnclampedIntegerElementType(_type_) is *true*, return *true*.\n  1. If IsBigIntElementType(_type_) is *true* and _order_ is neither ~init~ nor ~unordered~, return *true*.\n  1. Return *false*.","code":"\n          1. If IsUnclampedIntegerElementType(_type_) is *true*, return *true*.\n          1. If IsBigIntElementType(_type_) is *true* and _order_ is neither ~init~ nor ~unordered~, return *true*.\n          1. Return *false*.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"RawBytesToNumeric","params":[{"name":"type","ty":"Unknown[\"a TypedArray element type\"]","kind":{"Normal":{}}},{"name":"rawBytes","ty":"Unknown[\"a List of byte values\"]","kind":{"Normal":{}}},{"name":"isLittleEndian","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Number | BigInt"}},"body":"\n  1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.\n  1. If _isLittleEndian_ is *false*, reverse the order of the elements of _rawBytes_.\n  1. If _type_ is ~float32~, then\n    1. Let _value_ be the byte elements of _rawBytes_ concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2019 binary32 value.\n    1. If _value_ is an IEEE 754-2019 binary32 NaN value, return the *NaN* Number value.\n    1. Return the Number value that corresponds to _value_.\n  1. If _type_ is ~float64~, then\n    1. Let _value_ be the byte elements of _rawBytes_ concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2019 binary64 value.\n    1. If _value_ is an IEEE 754-2019 binary64 NaN value, return the *NaN* Number value.\n    1. Return the Number value that corresponds to _value_.\n  1. If IsUnsignedElementType(_type_) is *true*, then\n    1. Let _intValue_ be the byte elements of _rawBytes_ concatenated and interpreted as a bit string encoding of an unsigned little-endian binary number.\n  1. Else,\n    1. Let _intValue_ be the byte elements of _rawBytes_ concatenated and interpreted as a bit string encoding of a binary little-endian two's complement number of bit length _elementSize_ × 8.\n  1. If IsBigIntElementType(_type_) is *true*, return the BigInt value that corresponds to _intValue_.\n  1. Else, return the Number value that corresponds to _intValue_.","code":"\n          1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.\n          1. If _isLittleEndian_ is *false*, reverse the order of the elements of _rawBytes_.\n          1. If _type_ is ~float32~, then\n            1. Let _value_ be the byte elements of _rawBytes_ concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2019 binary32 value.\n            1. If _value_ is an IEEE 754-2019 binary32 NaN value, return the *NaN* Number value.\n            1. Return the Number value that corresponds to _value_.\n          1. If _type_ is ~float64~, then\n            1. Let _value_ be the byte elements of _rawBytes_ concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2019 binary64 value.\n            1. If _value_ is an IEEE 754-2019 binary64 NaN value, return the *NaN* Number value.\n            1. Return the Number value that corresponds to _value_.\n          1. If IsUnsignedElementType(_type_) is *true*, then\n            1. Let _intValue_ be the byte elements of _rawBytes_ concatenated and interpreted as a bit string encoding of an unsigned little-endian binary number.\n          1. Else,\n            1. Let _intValue_ be the byte elements of _rawBytes_ concatenated and interpreted as a bit string encoding of a binary little-endian two's complement number of bit length _elementSize_ × 8.\n          1. If IsBigIntElementType(_type_) is *true*, return the BigInt value that corresponds to _intValue_.\n          1. Otherwise, return the Number value that corresponds to _intValue_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetRawBytesFromSharedBlock","params":[{"name":"block","ty":"Record[SharedDataBlock]","kind":{"Normal":{}}},{"name":"byteIndex","ty":"NonNegInt","kind":{"Normal":{}}},{"name":"type","ty":"Unknown[\"a TypedArray element type\"]","kind":{"Normal":{}}},{"name":"isTypedArray","ty":"Boolean","kind":{"Normal":{}}},{"name":"order","ty":"Enum[~seq-cst~, ~unordered~]","kind":{"Normal":{}}}],"retTy":"Unknown[\"a List of byte values\"]"}},"body":"\n  1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.\n  1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\n  1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\n  1. If _isTypedArray_ is *true* and IsNoTearConfiguration(_type_, _order_) is *true*, let _noTear_ be *true*.\n  1. Else, let _noTear_ be *false*.\n  1. Let _rawValue_ be a List of length _elementSize_ whose elements are nondeterministically chosen byte values.\n  1. NOTE: In implementations, _rawValue_ is the result of a non-atomic or atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.\n  1. Let _readEvent_ be ReadSharedMemory { [[Order]]: _order_, [[NoTear]]: _noTear_, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_ }.\n  1. Append _readEvent_ to _eventsRecord_.[[EventList]].\n  1. Append Chosen Value Record { [[Event]]: _readEvent_, [[ChosenValue]]: _rawValue_ } to _execution_.[[ChosenValues]].\n  1. Return _rawValue_.","code":"\n          1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.\n          1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\n          1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\n          1. If _isTypedArray_ is *true* and IsNoTearConfiguration(_type_, _order_) is *true*, let _noTear_ be *true*; otherwise let _noTear_ be *false*.\n          1. Let _rawValue_ be a List of length _elementSize_ whose elements are nondeterministically chosen byte values.\n          1. NOTE: In implementations, _rawValue_ is the result of a non-atomic or atomic read instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.\n          1. Let _readEvent_ be ReadSharedMemory { [[Order]]: _order_, [[NoTear]]: _noTear_, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_ }.\n          1. Append _readEvent_ to _eventsRecord_.[[EventList]].\n          1. Append Chosen Value Record { [[Event]]: _readEvent_, [[ChosenValue]]: _rawValue_ } to _execution_.[[ChosenValues]].\n          1. Return _rawValue_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetValueFromBuffer","params":[{"name":"arrayBuffer","ty":"Record[ArrayBuffer | SharedArrayBuffer]","kind":{"Normal":{}}},{"name":"byteIndex","ty":"NonNegInt","kind":{"Normal":{}}},{"name":"type","ty":"Unknown[\"a TypedArray element type\"]","kind":{"Normal":{}}},{"name":"isTypedArray","ty":"Boolean","kind":{"Normal":{}}},{"name":"order","ty":"Enum[~seq-cst~, ~unordered~]","kind":{"Normal":{}}},{"name":"isLittleEndian","ty":"Boolean","kind":{"Optional":{}}}],"retTy":"Number | BigInt"}},"body":"\n  1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.\n  1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_..\n  1. Let _block_ be _arrayBuffer_.[[ArrayBufferData]].\n  1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.\n  1. If IsSharedArrayBuffer(_arrayBuffer_) is *true*, then\n    1. Assert: _block_ is a Record[SharedDataBlock].\n    1. Let _rawValue_ be GetRawBytesFromSharedBlock(_block_, _byteIndex_, _type_, _isTypedArray_, _order_).\n  1. Else,\n    1. Let _rawValue_ be a List whose elements are bytes from _block_ at indices in the interval from _byteIndex_ (inclusive) to _byteIndex_ + _elementSize_ (exclusive).\n  1. Assert: the number of elements in _rawValue_ is _elementSize_.\n  1. If _isLittleEndian_ is not present, set _isLittleEndian_ to the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\n  1. Return RawBytesToNumeric(_type_, _rawValue_, _isLittleEndian_).","code":"\n          1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.\n          1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.\n          1. Let _block_ be _arrayBuffer_.[[ArrayBufferData]].\n          1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.\n          1. If IsSharedArrayBuffer(_arrayBuffer_) is *true*, then\n            1. Assert: _block_ is a Shared Data Block.\n            1. Let _rawValue_ be GetRawBytesFromSharedBlock(_block_, _byteIndex_, _type_, _isTypedArray_, _order_).\n          1. Else,\n            1. Let _rawValue_ be a List whose elements are bytes from _block_ at indices in the interval from _byteIndex_ (inclusive) to _byteIndex_ + _elementSize_ (exclusive).\n          1. Assert: The number of elements in _rawValue_ is _elementSize_.\n          1. If _isLittleEndian_ is not present, set _isLittleEndian_ to the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\n          1. Return RawBytesToNumeric(_type_, _rawValue_, _isLittleEndian_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"NumericToRawBytes","params":[{"name":"type","ty":"Unknown[\"a TypedArray element type\"]","kind":{"Normal":{}}},{"name":"value","ty":"Number | BigInt","kind":{"Normal":{}}},{"name":"isLittleEndian","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Unknown[\"a List of byte values\"]"}},"body":"\n  1. If _type_ is ~float32~, then\n    1. Let _rawBytes_ be a List whose elements are the 4 bytes that are the result of converting _value_ to IEEE 754-2019 binary32 format using roundTiesToEven mode. The bytes are arranged in little endian order. If _value_ is *NaN*, _rawBytes_ may be set to any implementation chosen IEEE 754-2019 binary32 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable *NaN* value.\n  1. Else if _type_ is ~float64~, then\n    1. Let _rawBytes_ be a List whose elements are the 8 bytes that are the IEEE 754-2019 binary64 format encoding of _value_. The bytes are arranged in little endian order. If _value_ is *NaN*, _rawBytes_ may be set to any implementation chosen IEEE 754-2019 binary64 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable *NaN* value.\n  1. Else,\n    1. Let _n_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.\n    1. Let _convOp_ be the abstract operation named in the Conversion Operation column in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.\n    1. Let _intValue_ be ℝ(_convOp_(_value_)).\n    1. If _intValue_ ≥ 0, then\n      1. Let _rawBytes_ be a List whose elements are the _n_-byte binary encoding of _intValue_. The bytes are ordered in little endian order.\n    1. Else,\n      1. Let _rawBytes_ be a List whose elements are the _n_-byte binary two's complement encoding of _intValue_. The bytes are ordered in little endian order.\n  1. If _isLittleEndian_ is *false*, reverse the order of the elements of _rawBytes_.\n  1. Return _rawBytes_.","code":"\n          1. If _type_ is ~float32~, then\n            1. Let _rawBytes_ be a List whose elements are the 4 bytes that are the result of converting _value_ to IEEE 754-2019 binary32 format using roundTiesToEven mode. The bytes are arranged in little endian order. If _value_ is *NaN*, _rawBytes_ may be set to any implementation chosen IEEE 754-2019 binary32 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable *NaN* value.\n          1. Else if _type_ is ~float64~, then\n            1. Let _rawBytes_ be a List whose elements are the 8 bytes that are the IEEE 754-2019 binary64 format encoding of _value_. The bytes are arranged in little endian order. If _value_ is *NaN*, _rawBytes_ may be set to any implementation chosen IEEE 754-2019 binary64 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable *NaN* value.\n          1. Else,\n            1. Let _n_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.\n            1. Let _convOp_ be the abstract operation named in the Conversion Operation column in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.\n            1. Let _intValue_ be ℝ(_convOp_(_value_)).\n            1. If _intValue_ ≥ 0, then\n              1. Let _rawBytes_ be a List whose elements are the _n_-byte binary encoding of _intValue_. The bytes are ordered in little endian order.\n            1. Else,\n              1. Let _rawBytes_ be a List whose elements are the _n_-byte binary two's complement encoding of _intValue_. The bytes are ordered in little endian order.\n          1. If _isLittleEndian_ is *false*, reverse the order of the elements of _rawBytes_.\n          1. Return _rawBytes_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"SetValueInBuffer","params":[{"name":"arrayBuffer","ty":"Record[ArrayBuffer | SharedArrayBuffer]","kind":{"Normal":{}}},{"name":"byteIndex","ty":"NonNegInt","kind":{"Normal":{}}},{"name":"type","ty":"Unknown[\"a TypedArray element type\"]","kind":{"Normal":{}}},{"name":"value","ty":"Number | BigInt","kind":{"Normal":{}}},{"name":"isTypedArray","ty":"Boolean","kind":{"Normal":{}}},{"name":"order","ty":"Enum[~init~, ~seq-cst~, ~unordered~]","kind":{"Normal":{}}},{"name":"isLittleEndian","ty":"Boolean","kind":{"Optional":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.\n  1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_..\n  1. Assert: _value_ is a BigInt if IsBigIntElementType(_type_) is *true*; otherwise, _value_ is a Number..\n  1. Let _block_ be _arrayBuffer_.[[ArrayBufferData]].\n  1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.\n  1. If _isLittleEndian_ is not present, set _isLittleEndian_ to the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\n  1. Let _rawBytes_ be NumericToRawBytes(_type_, _value_, _isLittleEndian_).\n  1. If IsSharedArrayBuffer(_arrayBuffer_) is *true*, then\n    1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\n    1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\n    1. If _isTypedArray_ is *true* and IsNoTearConfiguration(_type_, _order_) is *true*, let _noTear_ be *true*.\n    1. Else, let _noTear_ be *false*.\n    1. Append WriteSharedMemory { [[Order]]: _order_, [[NoTear]]: _noTear_, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_, [[Payload]]: _rawBytes_ } to _eventsRecord_.[[EventList]].\n  1. Else,\n    1. Store the individual bytes of _rawBytes_ into _block_, starting at _block_[_byteIndex_].\n  1. Return ~unused~.","code":"\n          1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.\n          1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.\n          1. Assert: _value_ is a BigInt if IsBigIntElementType(_type_) is *true*; otherwise, _value_ is a Number.\n          1. Let _block_ be _arrayBuffer_.[[ArrayBufferData]].\n          1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.\n          1. If _isLittleEndian_ is not present, set _isLittleEndian_ to the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\n          1. Let _rawBytes_ be NumericToRawBytes(_type_, _value_, _isLittleEndian_).\n          1. If IsSharedArrayBuffer(_arrayBuffer_) is *true*, then\n            1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\n            1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\n            1. If _isTypedArray_ is *true* and IsNoTearConfiguration(_type_, _order_) is *true*, let _noTear_ be *true*; otherwise let _noTear_ be *false*.\n            1. Append WriteSharedMemory { [[Order]]: _order_, [[NoTear]]: _noTear_, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_, [[Payload]]: _rawBytes_ } to _eventsRecord_.[[EventList]].\n          1. Else,\n            1. Store the individual bytes of _rawBytes_ into _block_, starting at _block_[_byteIndex_].\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetModifySetValueInBuffer","params":[{"name":"arrayBuffer","ty":"Record[ArrayBuffer | SharedArrayBuffer]","kind":{"Normal":{}}},{"name":"byteIndex","ty":"NonNegInt","kind":{"Normal":{}}},{"name":"type","ty":"Unknown[\"a TypedArray element type\"]","kind":{"Normal":{}}},{"name":"value","ty":"Number | BigInt","kind":{"Normal":{}}},{"name":"op","ty":"Unknown[\"a read-modify-write modification function\"]","kind":{"Normal":{}}}],"retTy":"Number | BigInt"}},"body":"\n  1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.\n  1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_..\n  1. Assert: _value_ is a BigInt if IsBigIntElementType(_type_) is *true*; otherwise, _value_ is a Number..\n  1. Let _block_ be _arrayBuffer_.[[ArrayBufferData]].\n  1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.\n  1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\n  1. Let _rawBytes_ be NumericToRawBytes(_type_, _value_, _isLittleEndian_).\n  1. If IsSharedArrayBuffer(_arrayBuffer_) is *true*, then\n    1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\n    1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\n    1. Let _rawBytesRead_ be a List of length _elementSize_ whose elements are nondeterministically chosen byte values.\n    1. NOTE: In implementations, _rawBytesRead_ is the result of a load-link, of a load-exclusive, or of an operand of a read-modify-write instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.\n    1. Let _rmwEvent_ be ReadModifyWriteSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_, [[Payload]]: _rawBytes_, [[ModifyOp]]: _op_ }.\n    1. Append _rmwEvent_ to _eventsRecord_.[[EventList]].\n    1. Append Chosen Value Record { [[Event]]: _rmwEvent_, [[ChosenValue]]: _rawBytesRead_ } to _execution_.[[ChosenValues]].\n  1. Else,\n    1. Let _rawBytesRead_ be a List of length _elementSize_ whose elements are the sequence of _elementSize_ bytes starting with _block_[_byteIndex_].\n    1. Let _rawBytesModified_ be _op_(_rawBytesRead_, _rawBytes_).\n    1. Store the individual bytes of _rawBytesModified_ into _block_, starting at _block_[_byteIndex_].\n  1. Return RawBytesToNumeric(_type_, _rawBytesRead_, _isLittleEndian_).","code":"\n          1. Assert: IsDetachedBuffer(_arrayBuffer_) is *false*.\n          1. Assert: There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.\n          1. Assert: _value_ is a BigInt if IsBigIntElementType(_type_) is *true*; otherwise, _value_ is a Number.\n          1. Let _block_ be _arrayBuffer_.[[ArrayBufferData]].\n          1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.\n          1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\n          1. Let _rawBytes_ be NumericToRawBytes(_type_, _value_, _isLittleEndian_).\n          1. If IsSharedArrayBuffer(_arrayBuffer_) is *true*, then\n            1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\n            1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\n            1. Let _rawBytesRead_ be a List of length _elementSize_ whose elements are nondeterministically chosen byte values.\n            1. NOTE: In implementations, _rawBytesRead_ is the result of a load-link, of a load-exclusive, or of an operand of a read-modify-write instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.\n            1. Let _rmwEvent_ be ReadModifyWriteSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _byteIndex_, [[ElementSize]]: _elementSize_, [[Payload]]: _rawBytes_, [[ModifyOp]]: _op_ }.\n            1. Append _rmwEvent_ to _eventsRecord_.[[EventList]].\n            1. Append Chosen Value Record { [[Event]]: _rmwEvent_, [[ChosenValue]]: _rawBytesRead_ } to _execution_.[[ChosenValues]].\n          1. Else,\n            1. Let _rawBytesRead_ be a List of length _elementSize_ whose elements are the sequence of _elementSize_ bytes starting with _block_[_byteIndex_].\n            1. Let _rawBytesModified_ be _op_(_rawBytesRead_, _rawBytes_).\n            1. Store the individual bytes of _rawBytesModified_ into _block_, starting at _block_[_byteIndex_].\n          1. Return RawBytesToNumeric(_type_, _rawBytesRead_, _isLittleEndian_).\n        "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"ArrayBuffer"}},"params":[{"name":"length","ty":"Unknown","kind":{"Normal":{}}},{"name":"options","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. If NewTarget is *undefined*, throw a *TypeError* exception.\n  1. Let _byteLength_ be ? ToIndex(_length_).\n  1. Let _requestedMaxByteLength_ be ? GetArrayBufferMaxByteLengthOption(_options_).\n  1. Return ? AllocateArrayBuffer(NewTarget, _byteLength_, _requestedMaxByteLength_).","code":"\n          1. If NewTarget is *undefined*, throw a *TypeError* exception.\n          1. Let _byteLength_ be ? ToIndex(_length_).\n          1. Let _requestedMaxByteLength_ be ? GetArrayBufferMaxByteLengthOption(_options_).\n          1. Return ? AllocateArrayBuffer(NewTarget, _byteLength_, _requestedMaxByteLength_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"ArrayBuffer"}},"name":"isView"}},"params":[{"name":"arg","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If _arg_ is not a Record[Object], return *false*.\n  1. If _arg_ has a [[ViewedArrayBuffer]] internal slot, return *true*.\n  1. Return *false*.","code":"\n          1. If _arg_ is not an Object, return *false*.\n          1. If _arg_ has a [[ViewedArrayBuffer]] internal slot, return *true*.\n          1. Return *false*.\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"SymbolAccess":{"base":{"Base":{"name":"ArrayBuffer"}},"symbol":"species"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Return *this* value.","code":"\n          1. Return the *this* value.\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"ArrayBuffer"}},"name":"prototype"}},"name":"byteLength"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).\n  1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.\n  1. If IsDetachedBuffer(_O_) is *true*, return *+0*<sub>𝔽</sub>.\n  1. Let _length_ be _O_.[[ArrayBufferByteLength]].\n  1. Return 𝔽(_length_).","code":"\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).\n          1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.\n          1. If IsDetachedBuffer(_O_) is *true*, return *+0*<sub>𝔽</sub>.\n          1. Let _length_ be _O_.[[ArrayBufferByteLength]].\n          1. Return 𝔽(_length_).\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"ArrayBuffer"}},"name":"prototype"}},"name":"detached"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).\n  1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.\n  1. Return IsDetachedBuffer(_O_).","code":"\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).\n          1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.\n          1. Return IsDetachedBuffer(_O_).\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"ArrayBuffer"}},"name":"prototype"}},"name":"maxByteLength"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).\n  1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.\n  1. If IsDetachedBuffer(_O_) is *true*, return *+0*<sub>𝔽</sub>.\n  1. If IsFixedLengthArrayBuffer(_O_) is *true*, then\n    1. Let _length_ be _O_.[[ArrayBufferByteLength]].\n  1. Else,\n    1. Let _length_ be _O_.[[ArrayBufferMaxByteLength]].\n  1. Return 𝔽(_length_).","code":"\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).\n          1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.\n          1. If IsDetachedBuffer(_O_) is *true*, return *+0*<sub>𝔽</sub>.\n          1. If IsFixedLengthArrayBuffer(_O_) is *true*, then\n            1. Let _length_ be _O_.[[ArrayBufferByteLength]].\n          1. Else,\n            1. Let _length_ be _O_.[[ArrayBufferMaxByteLength]].\n          1. Return 𝔽(_length_).\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"ArrayBuffer"}},"name":"prototype"}},"name":"resizable"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).\n  1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.\n  1. If IsFixedLengthArrayBuffer(_O_) is *false*, return *true*.\n  1. Else, return *false*.","code":"\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).\n          1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.\n          1. If IsFixedLengthArrayBuffer(_O_) is *false*, return *true*; otherwise return *false*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"ArrayBuffer"}},"name":"prototype"}},"name":"resize"}},"params":[{"name":"newLength","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferMaxByteLength]]).\n  1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.\n  1. Let _newByteLength_ be ? ToIndex(_newLength_).\n  1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.\n  1. If _newByteLength_ > _O_.[[ArrayBufferMaxByteLength]], throw a *RangeError* exception.\n  1. Let _hostHandled_ be ? HostResizeArrayBuffer(_O_, _newByteLength_).\n  1. If _hostHandled_ is ~handled~, return *undefined*.\n  1. Let _oldBlock_ be _O_.[[ArrayBufferData]].\n  1. Let _newBlock_ be ? CreateByteDataBlock(_newByteLength_).\n  1. Let _copyLength_ be min(_newByteLength_, _O_.[[ArrayBufferByteLength]]).\n  1. Perform CopyDataBlockBytes(_newBlock_, 0, _oldBlock_, 0, _copyLength_).\n  1. NOTE: Neither creation of the new Data Block nor copying from the old Data Block are observable. Implementations may implement this method as in-place growth or shrinkage.\n  1. Set _O_.[[ArrayBufferData]] to _newBlock_.\n  1. Set _O_.[[ArrayBufferByteLength]] to _newByteLength_.\n  1. Return *undefined*.","code":"\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferMaxByteLength]]).\n          1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.\n          1. Let _newByteLength_ be ? ToIndex(_newLength_).\n          1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.\n          1. If _newByteLength_ > _O_.[[ArrayBufferMaxByteLength]], throw a *RangeError* exception.\n          1. Let _hostHandled_ be ? HostResizeArrayBuffer(_O_, _newByteLength_).\n          1. If _hostHandled_ is ~handled~, return *undefined*.\n          1. Let _oldBlock_ be _O_.[[ArrayBufferData]].\n          1. Let _newBlock_ be ? CreateByteDataBlock(_newByteLength_).\n          1. Let _copyLength_ be min(_newByteLength_, _O_.[[ArrayBufferByteLength]]).\n          1. Perform CopyDataBlockBytes(_newBlock_, 0, _oldBlock_, 0, _copyLength_).\n          1. NOTE: Neither creation of the new Data Block nor copying from the old Data Block are observable. Implementations may implement this method as in-place growth or shrinkage.\n          1. Set _O_.[[ArrayBufferData]] to _newBlock_.\n          1. Set _O_.[[ArrayBufferByteLength]] to _newByteLength_.\n          1. Return *undefined*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"ArrayBuffer"}},"name":"prototype"}},"name":"slice"}},"params":[{"name":"start","ty":"Unknown","kind":{"Normal":{}}},{"name":"end","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).\n  1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.\n  1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.\n  1. Let _len_ be _O_.[[ArrayBufferByteLength]].\n  1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n  1. If _relativeStart_ = -∞, let _first_ be 0.\n  1. Else if _relativeStart_ < 0, let _first_ be max(_len_ + _relativeStart_, 0).\n  1. Else, let _first_ be min(_relativeStart_, _len_).\n  1. If _end_ is *undefined*, let _relativeEnd_ be _len_.\n  1. Else, let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).\n  1. If _relativeEnd_ = -∞, let _final_ be 0.\n  1. Else if _relativeEnd_ < 0, let _final_ be max(_len_ + _relativeEnd_, 0).\n  1. Else, let _final_ be min(_relativeEnd_, _len_).\n  1. Let _newLen_ be max(_final_ - _first_, 0).\n  1. Let _ctor_ be ? SpeciesConstructor(_O_, %ArrayBuffer%).\n  1. Let _new_ be ? Construct(_ctor_, « 𝔽(_newLen_) »).\n  1. Perform ? RequireInternalSlot(_new_, [[ArrayBufferData]]).\n  1. If IsSharedArrayBuffer(_new_) is *true*, throw a *TypeError* exception.\n  1. If IsDetachedBuffer(_new_) is *true*, throw a *TypeError* exception.\n  1. If SameValue(_new_, _O_) is *true*, throw a *TypeError* exception.\n  1. If _new_.[[ArrayBufferByteLength]] < _newLen_, throw a *TypeError* exception.\n  1. NOTE: Side-effects of the above steps may have detached or resized _O_.\n  1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.\n  1. Let _fromBuf_ be _O_.[[ArrayBufferData]].\n  1. Let _toBuf_ be _new_.[[ArrayBufferData]].\n  1. Let _currentLen_ be _O_.[[ArrayBufferByteLength]].\n  1. If _first_ < _currentLen_, then\n    1. Let _count_ be min(_newLen_, _currentLen_ - _first_).\n    1. Perform CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_, _count_).\n  1. Return _new_.","code":"\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).\n          1. If IsSharedArrayBuffer(_O_) is *true*, throw a *TypeError* exception.\n          1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.\n          1. Let _len_ be _O_.[[ArrayBufferByteLength]].\n          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n          1. If _relativeStart_ = -∞, let _first_ be 0.\n          1. Else if _relativeStart_ < 0, let _first_ be max(_len_ + _relativeStart_, 0).\n          1. Else, let _first_ be min(_relativeStart_, _len_).\n          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).\n          1. If _relativeEnd_ = -∞, let _final_ be 0.\n          1. Else if _relativeEnd_ < 0, let _final_ be max(_len_ + _relativeEnd_, 0).\n          1. Else, let _final_ be min(_relativeEnd_, _len_).\n          1. Let _newLen_ be max(_final_ - _first_, 0).\n          1. Let _ctor_ be ? SpeciesConstructor(_O_, %ArrayBuffer%).\n          1. Let _new_ be ? Construct(_ctor_, « 𝔽(_newLen_) »).\n          1. Perform ? RequireInternalSlot(_new_, [[ArrayBufferData]]).\n          1. If IsSharedArrayBuffer(_new_) is *true*, throw a *TypeError* exception.\n          1. If IsDetachedBuffer(_new_) is *true*, throw a *TypeError* exception.\n          1. If SameValue(_new_, _O_) is *true*, throw a *TypeError* exception.\n          1. If _new_.[[ArrayBufferByteLength]] < _newLen_, throw a *TypeError* exception.\n          1. NOTE: Side-effects of the above steps may have detached or resized _O_.\n          1. If IsDetachedBuffer(_O_) is *true*, throw a *TypeError* exception.\n          1. Let _fromBuf_ be _O_.[[ArrayBufferData]].\n          1. Let _toBuf_ be _new_.[[ArrayBufferData]].\n          1. Let _currentLen_ be _O_.[[ArrayBufferByteLength]].\n          1. If _first_ < _currentLen_, then\n            1. Let _count_ be min(_newLen_, _currentLen_ - _first_).\n            1. Perform CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_, _count_).\n          1. Return _new_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"ArrayBuffer"}},"name":"prototype"}},"name":"transfer"}},"params":[{"name":"newLength","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Return ? ArrayBufferCopyAndDetach(_O_, _newLength_, ~preserve-resizability~).","code":"\n          1. Let _O_ be the *this* value.\n          1. Return ? ArrayBufferCopyAndDetach(_O_, _newLength_, ~preserve-resizability~).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"ArrayBuffer"}},"name":"prototype"}},"name":"transferToFixedLength"}},"params":[{"name":"newLength","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Return ? ArrayBufferCopyAndDetach(_O_, _newLength_, ~fixed-length~).","code":"\n          1. Let _O_ be the *this* value.\n          1. Return ? ArrayBufferCopyAndDetach(_O_, _newLength_, ~fixed-length~).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AllocateSharedArrayBuffer","params":[{"name":"constructor","ty":"Record[Constructor]","kind":{"Normal":{}}},{"name":"byteLength","ty":"NonNegInt","kind":{"Normal":{}}},{"name":"maxByteLength","ty":"Enum[~empty~] | NonNegInt","kind":{"Optional":{}}}],"retTy":"Normal[Record[SharedArrayBuffer]] | Throw"}},"body":"\n  1. Let _slots_ be « [[ArrayBufferData]] ».\n  1. If _maxByteLength_ is present and _maxByteLength_ is not ~empty~, let _allocatingGrowableBuffer_ be *true*.\n  1. Else, let _allocatingGrowableBuffer_ be *false*.\n  1. If _allocatingGrowableBuffer_ is *true*, then\n    1. If _byteLength_ > _maxByteLength_, throw a *RangeError* exception.\n    1. Append [[ArrayBufferByteLengthData]] and [[ArrayBufferMaxByteLength]] to _slots_.\n  1. Else,\n    1. Append [[ArrayBufferByteLength]] to _slots_.\n  1. Let _obj_ be ? OrdinaryCreateFromConstructor(_constructor_, *\"%SharedArrayBuffer.prototype%\"*, _slots_).\n  1. If _allocatingGrowableBuffer_ is *true*, let _allocLength_ be _maxByteLength_.\n  1. Else, let _allocLength_ be _byteLength_.\n  1. Let _block_ be ? CreateSharedByteDataBlock(_allocLength_).\n  1. Set _obj_.[[ArrayBufferData]] to _block_.\n  1. If _allocatingGrowableBuffer_ is *true*, then\n    1. Assert: _byteLength_ ≤ _maxByteLength_.\n    1. Let _byteLengthBlock_ be ? CreateSharedByteDataBlock(8).\n    1. Perform SetValueInBuffer(_byteLengthBlock_, 0, ~biguint64~, ℤ(_byteLength_), *true*, ~seq-cst~).\n    1. Set _obj_.[[ArrayBufferByteLengthData]] to _byteLengthBlock_.\n    1. Set _obj_.[[ArrayBufferMaxByteLength]] to _maxByteLength_.\n  1. Else,\n    1. Set _obj_.[[ArrayBufferByteLength]] to _byteLength_.\n  1. Return _obj_.","code":"\n          1. Let _slots_ be « [[ArrayBufferData]] ».\n          1. If _maxByteLength_ is present and _maxByteLength_ is not ~empty~, let _allocatingGrowableBuffer_ be *true*; otherwise let _allocatingGrowableBuffer_ be *false*.\n          1. If _allocatingGrowableBuffer_ is *true*, then\n            1. If _byteLength_ > _maxByteLength_, throw a *RangeError* exception.\n            1. Append [[ArrayBufferByteLengthData]] and [[ArrayBufferMaxByteLength]] to _slots_.\n          1. Else,\n            1. Append [[ArrayBufferByteLength]] to _slots_.\n          1. Let _obj_ be ? OrdinaryCreateFromConstructor(_constructor_, *\"%SharedArrayBuffer.prototype%\"*, _slots_).\n          1. If _allocatingGrowableBuffer_ is *true*, let _allocLength_ be _maxByteLength_; otherwise let _allocLength_ be _byteLength_.\n          1. Let _block_ be ? CreateSharedByteDataBlock(_allocLength_).\n          1. Set _obj_.[[ArrayBufferData]] to _block_.\n          1. If _allocatingGrowableBuffer_ is *true*, then\n            1. Assert: _byteLength_ ≤ _maxByteLength_.\n            1. Let _byteLengthBlock_ be ? CreateSharedByteDataBlock(8).\n            1. Perform SetValueInBuffer(_byteLengthBlock_, 0, ~biguint64~, ℤ(_byteLength_), *true*, ~seq-cst~).\n            1. Set _obj_.[[ArrayBufferByteLengthData]] to _byteLengthBlock_.\n            1. Set _obj_.[[ArrayBufferMaxByteLength]] to _maxByteLength_.\n          1. Else,\n            1. Set _obj_.[[ArrayBufferByteLength]] to _byteLength_.\n          1. Return _obj_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsSharedArrayBuffer","params":[{"name":"obj","ty":"Record[ArrayBuffer | SharedArrayBuffer]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _bufferData_ be _obj_.[[ArrayBufferData]].\n  1. If _bufferData_ is *null*, return *false*.\n  1. If _bufferData_ is a Record[DataBlock], return *false*.\n  1. Assert: _bufferData_ is a Record[SharedDataBlock].\n  1. Return *true*.","code":"\n          1. Let _bufferData_ be _obj_.[[ArrayBufferData]].\n          1. If _bufferData_ is *null*, return *false*.\n          1. If _bufferData_ is a Data Block, return *false*.\n          1. Assert: _bufferData_ is a Shared Data Block.\n          1. Return *true*.\n        "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"SharedArrayBuffer"}},"params":[{"name":"length","ty":"Unknown","kind":{"Normal":{}}},{"name":"options","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. If NewTarget is *undefined*, throw a *TypeError* exception.\n  1. Let _byteLength_ be ? ToIndex(_length_).\n  1. Let _requestedMaxByteLength_ be ? GetArrayBufferMaxByteLengthOption(_options_).\n  1. Return ? AllocateSharedArrayBuffer(NewTarget, _byteLength_, _requestedMaxByteLength_).","code":"\n          1. If NewTarget is *undefined*, throw a *TypeError* exception.\n          1. Let _byteLength_ be ? ToIndex(_length_).\n          1. Let _requestedMaxByteLength_ be ? GetArrayBufferMaxByteLengthOption(_options_).\n          1. Return ? AllocateSharedArrayBuffer(NewTarget, _byteLength_, _requestedMaxByteLength_).\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"SymbolAccess":{"base":{"Base":{"name":"SharedArrayBuffer"}},"symbol":"species"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Return *this* value.","code":"\n          1. Return the *this* value.\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"SharedArrayBuffer"}},"name":"prototype"}},"name":"byteLength"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).\n  1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.\n  1. Let _length_ be ArrayBufferByteLength(_O_, ~seq-cst~).\n  1. Return 𝔽(_length_).","code":"\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).\n          1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.\n          1. Let _length_ be ArrayBufferByteLength(_O_, ~seq-cst~).\n          1. Return 𝔽(_length_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"SharedArrayBuffer"}},"name":"prototype"}},"name":"grow"}},"params":[{"name":"newLength","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferMaxByteLength]]).\n  1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.\n  1. Let _newByteLength_ be ? ToIndex(_newLength_).\n  1. Let _hostHandled_ be ? HostGrowSharedArrayBuffer(_O_, _newByteLength_).\n  1. If _hostHandled_ is ~handled~, return *undefined*.\n  1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\n  1. Let _byteLengthBlock_ be _O_.[[ArrayBufferByteLengthData]].\n  1. Let _currentByteLengthRawBytes_ be GetRawBytesFromSharedBlock(_byteLengthBlock_, 0, ~biguint64~, *true*, ~seq-cst~).\n  1. Let _newByteLengthRawBytes_ be NumericToRawBytes(~biguint64~, ℤ(_newByteLength_), _isLittleEndian_).\n  1. Repeat, \n    1. NOTE: This is a compare-and-exchange loop to ensure that parallel, racing grows of the same buffer are totally ordered, are not lost, and do not silently do nothing. The loop exits if it was able to attempt to grow uncontended.\n    1. Let _currentByteLength_ be ℝ(RawBytesToNumeric(~biguint64~, _currentByteLengthRawBytes_, _isLittleEndian_)).\n    1. If _newByteLength_ = _currentByteLength_, return *undefined*.\n    1. If _newByteLength_ < _currentByteLength_ or _newByteLength_ > _O_.[[ArrayBufferMaxByteLength]], throw a *RangeError* exception.\n    1. Let _byteLengthDelta_ be _newByteLength_ - _currentByteLength_.\n    1. If it is impossible to create a new Shared Data Block value consisting of _byteLengthDelta_ bytes, throw a *RangeError* exception.\n    1. NOTE: No new Shared Data Block is constructed and used here. The observable behaviour of growable SharedArrayBuffers is specified by allocating a max-sized Shared Data Block at construction time, and this step captures the requirement that implementations that run out of memory must throw a *RangeError*.\n    1. Let _readByteLengthRawBytes_ be AtomicCompareExchangeInSharedBlock(_byteLengthBlock_, 0, 8, _currentByteLengthRawBytes_, _newByteLengthRawBytes_).\n    1. If ByteListEqual(_readByteLengthRawBytes_, _currentByteLengthRawBytes_) is *true*, return *undefined*.\n    1. Set _currentByteLengthRawBytes_ to _readByteLengthRawBytes_.","code":"\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferMaxByteLength]]).\n          1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.\n          1. Let _newByteLength_ be ? ToIndex(_newLength_).\n          1. Let _hostHandled_ be ? HostGrowSharedArrayBuffer(_O_, _newByteLength_).\n          1. If _hostHandled_ is ~handled~, return *undefined*.\n          1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\n          1. Let _byteLengthBlock_ be _O_.[[ArrayBufferByteLengthData]].\n          1. Let _currentByteLengthRawBytes_ be GetRawBytesFromSharedBlock(_byteLengthBlock_, 0, ~biguint64~, *true*, ~seq-cst~).\n          1. Let _newByteLengthRawBytes_ be NumericToRawBytes(~biguint64~, ℤ(_newByteLength_), _isLittleEndian_).\n          1. Repeat,\n            1. NOTE: This is a compare-and-exchange loop to ensure that parallel, racing grows of the same buffer are totally ordered, are not lost, and do not silently do nothing. The loop exits if it was able to attempt to grow uncontended.\n            1. Let _currentByteLength_ be ℝ(RawBytesToNumeric(~biguint64~, _currentByteLengthRawBytes_, _isLittleEndian_)).\n            1. If _newByteLength_ = _currentByteLength_, return *undefined*.\n            1. If _newByteLength_ < _currentByteLength_ or _newByteLength_ > _O_.[[ArrayBufferMaxByteLength]], throw a *RangeError* exception.\n            1. Let _byteLengthDelta_ be _newByteLength_ - _currentByteLength_.\n            1. If it is impossible to create a new Shared Data Block value consisting of _byteLengthDelta_ bytes, throw a *RangeError* exception.\n            1. NOTE: No new Shared Data Block is constructed and used here. The observable behaviour of growable SharedArrayBuffers is specified by allocating a max-sized Shared Data Block at construction time, and this step captures the requirement that implementations that run out of memory must throw a *RangeError*.\n            1. Let _readByteLengthRawBytes_ be AtomicCompareExchangeInSharedBlock(_byteLengthBlock_, 0, 8, _currentByteLengthRawBytes_, _newByteLengthRawBytes_).\n            1. If ByteListEqual(_readByteLengthRawBytes_, _currentByteLengthRawBytes_) is *true*, return *undefined*.\n            1. Set _currentByteLengthRawBytes_ to _readByteLengthRawBytes_.\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"SharedArrayBuffer"}},"name":"prototype"}},"name":"growable"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).\n  1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.\n  1. If IsFixedLengthArrayBuffer(_O_) is *false*, return *true*.\n  1. Else, return *false*.","code":"\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).\n          1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.\n          1. If IsFixedLengthArrayBuffer(_O_) is *false*, return *true*; otherwise return *false*.\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"SharedArrayBuffer"}},"name":"prototype"}},"name":"maxByteLength"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).\n  1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.\n  1. If IsFixedLengthArrayBuffer(_O_) is *true*, then\n    1. Let _length_ be _O_.[[ArrayBufferByteLength]].\n  1. Else,\n    1. Let _length_ be _O_.[[ArrayBufferMaxByteLength]].\n  1. Return 𝔽(_length_).","code":"\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).\n          1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.\n          1. If IsFixedLengthArrayBuffer(_O_) is *true*, then\n            1. Let _length_ be _O_.[[ArrayBufferByteLength]].\n          1. Else,\n            1. Let _length_ be _O_.[[ArrayBufferMaxByteLength]].\n          1. Return 𝔽(_length_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"SharedArrayBuffer"}},"name":"prototype"}},"name":"slice"}},"params":[{"name":"start","ty":"Unknown","kind":{"Normal":{}}},{"name":"end","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).\n  1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.\n  1. Let _len_ be ArrayBufferByteLength(_O_, ~seq-cst~).\n  1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n  1. If _relativeStart_ = -∞, let _first_ be 0.\n  1. Else if _relativeStart_ < 0, let _first_ be max(_len_ + _relativeStart_, 0).\n  1. Else, let _first_ be min(_relativeStart_, _len_).\n  1. If _end_ is *undefined*, let _relativeEnd_ be _len_.\n  1. Else, let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).\n  1. If _relativeEnd_ = -∞, let _final_ be 0.\n  1. Else if _relativeEnd_ < 0, let _final_ be max(_len_ + _relativeEnd_, 0).\n  1. Else, let _final_ be min(_relativeEnd_, _len_).\n  1. Let _newLen_ be max(_final_ - _first_, 0).\n  1. Let _ctor_ be ? SpeciesConstructor(_O_, %SharedArrayBuffer%).\n  1. Let _new_ be ? Construct(_ctor_, « 𝔽(_newLen_) »).\n  1. Perform ? RequireInternalSlot(_new_, [[ArrayBufferData]]).\n  1. If IsSharedArrayBuffer(_new_) is *false*, throw a *TypeError* exception.\n  1. If _new_.[[ArrayBufferData]] is _O_.[[ArrayBufferData]], throw a *TypeError* exception.\n  1. If ArrayBufferByteLength(_new_, ~seq-cst~) < _newLen_, throw a *TypeError* exception.\n  1. Let _fromBuf_ be _O_.[[ArrayBufferData]].\n  1. Let _toBuf_ be _new_.[[ArrayBufferData]].\n  1. Perform CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_, _newLen_).\n  1. Return _new_.","code":"\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[ArrayBufferData]]).\n          1. If IsSharedArrayBuffer(_O_) is *false*, throw a *TypeError* exception.\n          1. Let _len_ be ArrayBufferByteLength(_O_, ~seq-cst~).\n          1. Let _relativeStart_ be ? ToIntegerOrInfinity(_start_).\n          1. If _relativeStart_ = -∞, let _first_ be 0.\n          1. Else if _relativeStart_ < 0, let _first_ be max(_len_ + _relativeStart_, 0).\n          1. Else, let _first_ be min(_relativeStart_, _len_).\n          1. If _end_ is *undefined*, let _relativeEnd_ be _len_; else let _relativeEnd_ be ? ToIntegerOrInfinity(_end_).\n          1. If _relativeEnd_ = -∞, let _final_ be 0.\n          1. Else if _relativeEnd_ < 0, let _final_ be max(_len_ + _relativeEnd_, 0).\n          1. Else, let _final_ be min(_relativeEnd_, _len_).\n          1. Let _newLen_ be max(_final_ - _first_, 0).\n          1. Let _ctor_ be ? SpeciesConstructor(_O_, %SharedArrayBuffer%).\n          1. Let _new_ be ? Construct(_ctor_, « 𝔽(_newLen_) »).\n          1. Perform ? RequireInternalSlot(_new_, [[ArrayBufferData]]).\n          1. If IsSharedArrayBuffer(_new_) is *false*, throw a *TypeError* exception.\n          1. If _new_.[[ArrayBufferData]] is _O_.[[ArrayBufferData]], throw a *TypeError* exception.\n          1. If ArrayBufferByteLength(_new_, ~seq-cst~) < _newLen_, throw a *TypeError* exception.\n          1. Let _fromBuf_ be _O_.[[ArrayBufferData]].\n          1. Let _toBuf_ be _new_.[[ArrayBufferData]].\n          1. Perform CopyDataBlockBytes(_toBuf_, 0, _fromBuf_, _first_, _newLen_).\n          1. Return _new_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"MakeDataViewWithBufferWitnessRecord","params":[{"name":"obj","ty":"Record[DataView]","kind":{"Normal":{}}},{"name":"order","ty":"Enum[~seq-cst~, ~unordered~]","kind":{"Normal":{}}}],"retTy":"Record[DataViewWithBufferWitnessRecord]"}},"body":"\n  1. Let _buffer_ be _obj_.[[ViewedArrayBuffer]].\n  1. If IsDetachedBuffer(_buffer_) is *true*, then\n    1. Let _byteLength_ be ~detached~.\n  1. Else,\n    1. Let _byteLength_ be ArrayBufferByteLength(_buffer_, _order_).\n  1. Return DataView With Buffer Witness Record { [[Object]]: _obj_, [[CachedBufferByteLength]]: _byteLength_ }.","code":"\n          1. Let _buffer_ be _obj_.[[ViewedArrayBuffer]].\n          1. If IsDetachedBuffer(_buffer_) is *true*, then\n            1. Let _byteLength_ be ~detached~.\n          1. Else,\n            1. Let _byteLength_ be ArrayBufferByteLength(_buffer_, _order_).\n          1. Return the DataView With Buffer Witness Record { [[Object]]: _obj_, [[CachedBufferByteLength]]: _byteLength_ }.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetViewByteLength","params":[{"name":"viewRecord","ty":"Record[DataViewWithBufferWitnessRecord]","kind":{"Normal":{}}}],"retTy":"NonNegInt"}},"body":"\n  1. Assert: IsViewOutOfBounds(_viewRecord_) is *false*.\n  1. Let _view_ be _viewRecord_.[[Object]].\n  1. If _view_.[[ByteLength]] is not ~auto~, return _view_.[[ByteLength]].\n  1. Assert: IsFixedLengthArrayBuffer(_view_.[[ViewedArrayBuffer]]) is *false*.\n  1. Let _byteOffset_ be _view_.[[ByteOffset]].\n  1. Let _byteLength_ be _viewRecord_.[[CachedBufferByteLength]].\n  1. Assert: _byteLength_ is not ~detached~.\n  1. Return _byteLength_ - _byteOffset_.","code":"\n          1. Assert: IsViewOutOfBounds(_viewRecord_) is *false*.\n          1. Let _view_ be _viewRecord_.[[Object]].\n          1. If _view_.[[ByteLength]] is not ~auto~, return _view_.[[ByteLength]].\n          1. Assert: IsFixedLengthArrayBuffer(_view_.[[ViewedArrayBuffer]]) is *false*.\n          1. Let _byteOffset_ be _view_.[[ByteOffset]].\n          1. Let _byteLength_ be _viewRecord_.[[CachedBufferByteLength]].\n          1. Assert: _byteLength_ is not ~detached~.\n          1. Return _byteLength_ - _byteOffset_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsViewOutOfBounds","params":[{"name":"viewRecord","ty":"Record[DataViewWithBufferWitnessRecord]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. Let _view_ be _viewRecord_.[[Object]].\n  1. Let _bufferByteLength_ be _viewRecord_.[[CachedBufferByteLength]].\n  1. Assert: IsDetachedBuffer(_view_.[[ViewedArrayBuffer]]) is *true* if and only if _bufferByteLength_ is ~detached~..\n  1. If _bufferByteLength_ is ~detached~, return *true*.\n  1. Let _byteOffsetStart_ be _view_.[[ByteOffset]].\n  1. If _view_.[[ByteLength]] is ~auto~, then\n    1. Let _byteOffsetEnd_ be _bufferByteLength_.\n  1. Else,\n    1. Let _byteOffsetEnd_ be _byteOffsetStart_ + _view_.[[ByteLength]].\n  1. If _byteOffsetStart_ > _bufferByteLength_ or _byteOffsetEnd_ > _bufferByteLength_, return *true*.\n  1. NOTE: 0-length DataViews are not considered out-of-bounds.\n  1. Return *false*.","code":"\n          1. Let _view_ be _viewRecord_.[[Object]].\n          1. Let _bufferByteLength_ be _viewRecord_.[[CachedBufferByteLength]].\n          1. Assert: IsDetachedBuffer(_view_.[[ViewedArrayBuffer]]) is *true* if and only if _bufferByteLength_ is ~detached~.\n          1. If _bufferByteLength_ is ~detached~, return *true*.\n          1. Let _byteOffsetStart_ be _view_.[[ByteOffset]].\n          1. If _view_.[[ByteLength]] is ~auto~, then\n            1. Let _byteOffsetEnd_ be _bufferByteLength_.\n          1. Else,\n            1. Let _byteOffsetEnd_ be _byteOffsetStart_ + _view_.[[ByteLength]].\n          1. If _byteOffsetStart_ > _bufferByteLength_ or _byteOffsetEnd_ > _bufferByteLength_, return *true*.\n          1. NOTE: 0-length DataViews are not considered out-of-bounds.\n          1. Return *false*.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetViewValue","params":[{"name":"view","ty":"ESValue","kind":{"Normal":{}}},{"name":"requestIndex","ty":"ESValue","kind":{"Normal":{}}},{"name":"isLittleEndian","ty":"ESValue","kind":{"Normal":{}}},{"name":"type","ty":"Unknown[\"a TypedArray element type\"]","kind":{"Normal":{}}}],"retTy":"Normal[Number | BigInt] | Throw"}},"body":"\n  1. Perform ? RequireInternalSlot(_view_, [[DataView]]).\n  1. Assert: _view_ has a [[ViewedArrayBuffer]] internal slot.\n  1. Let _getIndex_ be ? ToIndex(_requestIndex_).\n  1. Set _isLittleEndian_ to ToBoolean(_isLittleEndian_).\n  1. Let _viewOffset_ be _view_.[[ByteOffset]].\n  1. Let _viewRecord_ be MakeDataViewWithBufferWitnessRecord(_view_, ~unordered~).\n  1. NOTE: Bounds checking is not a synchronizing operation when _view_'s backing buffer is a growable SharedArrayBuffer.\n  1. If IsViewOutOfBounds(_viewRecord_) is *true*, throw a *TypeError* exception.\n  1. Let _viewSize_ be GetViewByteLength(_viewRecord_).\n  1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.\n  1. If _getIndex_ + _elementSize_ > _viewSize_, throw a *RangeError* exception.\n  1. Let _bufferIndex_ be _getIndex_ + _viewOffset_.\n  1. Return GetValueFromBuffer(_view_.[[ViewedArrayBuffer]], _bufferIndex_, _type_, *false*, ~unordered~, _isLittleEndian_).","code":"\n          1. Perform ? RequireInternalSlot(_view_, [[DataView]]).\n          1. Assert: _view_ has a [[ViewedArrayBuffer]] internal slot.\n          1. Let _getIndex_ be ? ToIndex(_requestIndex_).\n          1. Set _isLittleEndian_ to ToBoolean(_isLittleEndian_).\n          1. Let _viewOffset_ be _view_.[[ByteOffset]].\n          1. Let _viewRecord_ be MakeDataViewWithBufferWitnessRecord(_view_, ~unordered~).\n          1. NOTE: Bounds checking is not a synchronizing operation when _view_'s backing buffer is a growable SharedArrayBuffer.\n          1. If IsViewOutOfBounds(_viewRecord_) is *true*, throw a *TypeError* exception.\n          1. Let _viewSize_ be GetViewByteLength(_viewRecord_).\n          1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.\n          1. If _getIndex_ + _elementSize_ > _viewSize_, throw a *RangeError* exception.\n          1. Let _bufferIndex_ be _getIndex_ + _viewOffset_.\n          1. Return GetValueFromBuffer(_view_.[[ViewedArrayBuffer]], _bufferIndex_, _type_, *false*, ~unordered~, _isLittleEndian_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"SetViewValue","params":[{"name":"view","ty":"ESValue","kind":{"Normal":{}}},{"name":"requestIndex","ty":"ESValue","kind":{"Normal":{}}},{"name":"isLittleEndian","ty":"ESValue","kind":{"Normal":{}}},{"name":"type","ty":"Unknown[\"a TypedArray element type\"]","kind":{"Normal":{}}},{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Undefined] | Throw"}},"body":"\n  1. Perform ? RequireInternalSlot(_view_, [[DataView]]).\n  1. Assert: _view_ has a [[ViewedArrayBuffer]] internal slot.\n  1. Let _getIndex_ be ? ToIndex(_requestIndex_).\n  1. If IsBigIntElementType(_type_) is *true*, let _numberValue_ be ? ToBigInt(_value_).\n  1. Else, let _numberValue_ be ? ToNumber(_value_).\n  1. Set _isLittleEndian_ to ToBoolean(_isLittleEndian_).\n  1. Let _viewOffset_ be _view_.[[ByteOffset]].\n  1. Let _viewRecord_ be MakeDataViewWithBufferWitnessRecord(_view_, ~unordered~).\n  1. NOTE: Bounds checking is not a synchronizing operation when _view_'s backing buffer is a growable SharedArrayBuffer.\n  1. If IsViewOutOfBounds(_viewRecord_) is *true*, throw a *TypeError* exception.\n  1. Let _viewSize_ be GetViewByteLength(_viewRecord_).\n  1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.\n  1. If _getIndex_ + _elementSize_ > _viewSize_, throw a *RangeError* exception.\n  1. Let _bufferIndex_ be _getIndex_ + _viewOffset_.\n  1. Perform SetValueInBuffer(_view_.[[ViewedArrayBuffer]], _bufferIndex_, _type_, _numberValue_, *false*, ~unordered~, _isLittleEndian_).\n  1. Return *undefined*.","code":"\n          1. Perform ? RequireInternalSlot(_view_, [[DataView]]).\n          1. Assert: _view_ has a [[ViewedArrayBuffer]] internal slot.\n          1. Let _getIndex_ be ? ToIndex(_requestIndex_).\n          1. If IsBigIntElementType(_type_) is *true*, let _numberValue_ be ? ToBigInt(_value_).\n          1. Otherwise, let _numberValue_ be ? ToNumber(_value_).\n          1. Set _isLittleEndian_ to ToBoolean(_isLittleEndian_).\n          1. Let _viewOffset_ be _view_.[[ByteOffset]].\n          1. Let _viewRecord_ be MakeDataViewWithBufferWitnessRecord(_view_, ~unordered~).\n          1. NOTE: Bounds checking is not a synchronizing operation when _view_'s backing buffer is a growable SharedArrayBuffer.\n          1. If IsViewOutOfBounds(_viewRecord_) is *true*, throw a *TypeError* exception.\n          1. Let _viewSize_ be GetViewByteLength(_viewRecord_).\n          1. Let _elementSize_ be the Element Size value specified in <emu-xref href=\"#table-the-typedarray-constructors\"></emu-xref> for Element Type _type_.\n          1. If _getIndex_ + _elementSize_ > _viewSize_, throw a *RangeError* exception.\n          1. Let _bufferIndex_ be _getIndex_ + _viewOffset_.\n          1. Perform SetValueInBuffer(_view_.[[ViewedArrayBuffer]], _bufferIndex_, _type_, _numberValue_, *false*, ~unordered~, _isLittleEndian_).\n          1. Return *undefined*.\n        "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"DataView"}},"params":[{"name":"buffer","ty":"Unknown","kind":{"Normal":{}}},{"name":"byteOffset","ty":"Unknown","kind":{"Optional":{}}},{"name":"byteLength","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. If NewTarget is *undefined*, throw a *TypeError* exception.\n  1. Perform ? RequireInternalSlot(_buffer_, [[ArrayBufferData]]).\n  1. Let _offset_ be ? ToIndex(_byteOffset_).\n  1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.\n  1. Let _bufferByteLength_ be ArrayBufferByteLength(_buffer_, ~seq-cst~).\n  1. If _offset_ > _bufferByteLength_, throw a *RangeError* exception.\n  1. Let _bufferIsFixedLength_ be IsFixedLengthArrayBuffer(_buffer_).\n  1. If _byteLength_ is *undefined*, then\n    1. If _bufferIsFixedLength_ is *true*, then\n      1. Let _viewByteLength_ be _bufferByteLength_ - _offset_.\n    1. Else,\n      1. Let _viewByteLength_ be ~auto~.\n  1. Else,\n    1. Let _viewByteLength_ be ? ToIndex(_byteLength_).\n    1. If _offset_ + _viewByteLength_ > _bufferByteLength_, throw a *RangeError* exception.\n  1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%DataView.prototype%\"*, « [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]] »).\n  1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.\n  1. Set _bufferByteLength_ to ArrayBufferByteLength(_buffer_, ~seq-cst~).\n  1. If _offset_ > _bufferByteLength_, throw a *RangeError* exception.\n  1. If _byteLength_ is not *undefined*, then\n    1. If _offset_ + _viewByteLength_ > _bufferByteLength_, throw a *RangeError* exception.\n  1. Set _O_.[[ViewedArrayBuffer]] to _buffer_.\n  1. Set _O_.[[ByteLength]] to _viewByteLength_.\n  1. Set _O_.[[ByteOffset]] to _offset_.\n  1. Return _O_.","code":"\n          1. If NewTarget is *undefined*, throw a *TypeError* exception.\n          1. Perform ? RequireInternalSlot(_buffer_, [[ArrayBufferData]]).\n          1. Let _offset_ be ? ToIndex(_byteOffset_).\n          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.\n          1. Let _bufferByteLength_ be ArrayBufferByteLength(_buffer_, ~seq-cst~).\n          1. If _offset_ > _bufferByteLength_, throw a *RangeError* exception.\n          1. Let _bufferIsFixedLength_ be IsFixedLengthArrayBuffer(_buffer_).\n          1. If _byteLength_ is *undefined*, then\n            1. If _bufferIsFixedLength_ is *true*, then\n              1. Let _viewByteLength_ be _bufferByteLength_ - _offset_.\n            1. Else,\n              1. Let _viewByteLength_ be ~auto~.\n          1. Else,\n            1. Let _viewByteLength_ be ? ToIndex(_byteLength_).\n            1. If _offset_ + _viewByteLength_ > _bufferByteLength_, throw a *RangeError* exception.\n          1. Let _O_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%DataView.prototype%\"*, « [[DataView]], [[ViewedArrayBuffer]], [[ByteLength]], [[ByteOffset]] »).\n          1. If IsDetachedBuffer(_buffer_) is *true*, throw a *TypeError* exception.\n          1. Set _bufferByteLength_ to ArrayBufferByteLength(_buffer_, ~seq-cst~).\n          1. If _offset_ > _bufferByteLength_, throw a *RangeError* exception.\n          1. If _byteLength_ is not *undefined*, then\n            1. If _offset_ + _viewByteLength_ > _bufferByteLength_, throw a *RangeError* exception.\n          1. Set _O_.[[ViewedArrayBuffer]] to _buffer_.\n          1. Set _O_.[[ByteLength]] to _viewByteLength_.\n          1. Set _O_.[[ByteOffset]] to _offset_.\n          1. Return _O_.\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"DataView"}},"name":"prototype"}},"name":"buffer"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Perform ? RequireInternalSlot(_O_, [[DataView]]).\n  1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.\n  1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].\n  1. Return _buffer_.","code":"\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[DataView]]).\n          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.\n          1. Let _buffer_ be _O_.[[ViewedArrayBuffer]].\n          1. Return _buffer_.\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"DataView"}},"name":"prototype"}},"name":"byteLength"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Perform ? RequireInternalSlot(_O_, [[DataView]]).\n  1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.\n  1. Let _viewRecord_ be MakeDataViewWithBufferWitnessRecord(_O_, ~seq-cst~).\n  1. If IsViewOutOfBounds(_viewRecord_) is *true*, throw a *TypeError* exception.\n  1. Let _size_ be GetViewByteLength(_viewRecord_).\n  1. Return 𝔽(_size_).","code":"\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[DataView]]).\n          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.\n          1. Let _viewRecord_ be MakeDataViewWithBufferWitnessRecord(_O_, ~seq-cst~).\n          1. If IsViewOutOfBounds(_viewRecord_) is *true*, throw a *TypeError* exception.\n          1. Let _size_ be GetViewByteLength(_viewRecord_).\n          1. Return 𝔽(_size_).\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"DataView"}},"name":"prototype"}},"name":"byteOffset"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Perform ? RequireInternalSlot(_O_, [[DataView]]).\n  1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.\n  1. Let _viewRecord_ be MakeDataViewWithBufferWitnessRecord(_O_, ~seq-cst~).\n  1. If IsViewOutOfBounds(_viewRecord_) is *true*, throw a *TypeError* exception.\n  1. Let _offset_ be _O_.[[ByteOffset]].\n  1. Return 𝔽(_offset_).","code":"\n          1. Let _O_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_O_, [[DataView]]).\n          1. Assert: _O_ has a [[ViewedArrayBuffer]] internal slot.\n          1. Let _viewRecord_ be MakeDataViewWithBufferWitnessRecord(_O_, ~seq-cst~).\n          1. If IsViewOutOfBounds(_viewRecord_) is *true*, throw a *TypeError* exception.\n          1. Let _offset_ be _O_.[[ByteOffset]].\n          1. Return 𝔽(_offset_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"DataView"}},"name":"prototype"}},"name":"getBigInt64"}},"params":[{"name":"byteOffset","ty":"Unknown","kind":{"Normal":{}}},{"name":"littleEndian","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _v_ be *this* value.\n  1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, ~bigint64~).","code":"\n          1. Let _v_ be the *this* value.\n          1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, ~bigint64~).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"DataView"}},"name":"prototype"}},"name":"getBigUint64"}},"params":[{"name":"byteOffset","ty":"Unknown","kind":{"Normal":{}}},{"name":"littleEndian","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _v_ be *this* value.\n  1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, ~biguint64~).","code":"\n          1. Let _v_ be the *this* value.\n          1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, ~biguint64~).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"DataView"}},"name":"prototype"}},"name":"getFloat32"}},"params":[{"name":"byteOffset","ty":"Unknown","kind":{"Normal":{}}},{"name":"littleEndian","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _v_ be *this* value.\n  1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n  1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, ~float32~).","code":"\n          1. Let _v_ be the *this* value.\n          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n          1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, ~float32~).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"DataView"}},"name":"prototype"}},"name":"getFloat64"}},"params":[{"name":"byteOffset","ty":"Unknown","kind":{"Normal":{}}},{"name":"littleEndian","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _v_ be *this* value.\n  1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n  1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, ~float64~).","code":"\n          1. Let _v_ be the *this* value.\n          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n          1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, ~float64~).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"DataView"}},"name":"prototype"}},"name":"getInt8"}},"params":[{"name":"byteOffset","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _v_ be *this* value.\n  1. Return ? GetViewValue(_v_, _byteOffset_, *true*, ~int8~).","code":"\n          1. Let _v_ be the *this* value.\n          1. Return ? GetViewValue(_v_, _byteOffset_, *true*, ~int8~).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"DataView"}},"name":"prototype"}},"name":"getInt16"}},"params":[{"name":"byteOffset","ty":"Unknown","kind":{"Normal":{}}},{"name":"littleEndian","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _v_ be *this* value.\n  1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n  1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, ~int16~).","code":"\n          1. Let _v_ be the *this* value.\n          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n          1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, ~int16~).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"DataView"}},"name":"prototype"}},"name":"getInt32"}},"params":[{"name":"byteOffset","ty":"Unknown","kind":{"Normal":{}}},{"name":"littleEndian","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _v_ be *this* value.\n  1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n  1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, ~int32~).","code":"\n          1. Let _v_ be the *this* value.\n          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n          1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, ~int32~).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"DataView"}},"name":"prototype"}},"name":"getUint8"}},"params":[{"name":"byteOffset","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _v_ be *this* value.\n  1. Return ? GetViewValue(_v_, _byteOffset_, *true*, ~uint8~).","code":"\n          1. Let _v_ be the *this* value.\n          1. Return ? GetViewValue(_v_, _byteOffset_, *true*, ~uint8~).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"DataView"}},"name":"prototype"}},"name":"getUint16"}},"params":[{"name":"byteOffset","ty":"Unknown","kind":{"Normal":{}}},{"name":"littleEndian","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _v_ be *this* value.\n  1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n  1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, ~uint16~).","code":"\n          1. Let _v_ be the *this* value.\n          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n          1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, ~uint16~).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"DataView"}},"name":"prototype"}},"name":"getUint32"}},"params":[{"name":"byteOffset","ty":"Unknown","kind":{"Normal":{}}},{"name":"littleEndian","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _v_ be *this* value.\n  1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n  1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, ~uint32~).","code":"\n          1. Let _v_ be the *this* value.\n          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n          1. Return ? GetViewValue(_v_, _byteOffset_, _littleEndian_, ~uint32~).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"DataView"}},"name":"prototype"}},"name":"setBigInt64"}},"params":[{"name":"byteOffset","ty":"Unknown","kind":{"Normal":{}}},{"name":"value","ty":"Unknown","kind":{"Normal":{}}},{"name":"littleEndian","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _v_ be *this* value.\n  1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, ~bigint64~, _value_).","code":"\n          1. Let _v_ be the *this* value.\n          1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, ~bigint64~, _value_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"DataView"}},"name":"prototype"}},"name":"setBigUint64"}},"params":[{"name":"byteOffset","ty":"Unknown","kind":{"Normal":{}}},{"name":"value","ty":"Unknown","kind":{"Normal":{}}},{"name":"littleEndian","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _v_ be *this* value.\n  1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, ~biguint64~, _value_).","code":"\n          1. Let _v_ be the *this* value.\n          1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, ~biguint64~, _value_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"DataView"}},"name":"prototype"}},"name":"setFloat32"}},"params":[{"name":"byteOffset","ty":"Unknown","kind":{"Normal":{}}},{"name":"value","ty":"Unknown","kind":{"Normal":{}}},{"name":"littleEndian","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _v_ be *this* value.\n  1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n  1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, ~float32~, _value_).","code":"\n          1. Let _v_ be the *this* value.\n          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n          1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, ~float32~, _value_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"DataView"}},"name":"prototype"}},"name":"setFloat64"}},"params":[{"name":"byteOffset","ty":"Unknown","kind":{"Normal":{}}},{"name":"value","ty":"Unknown","kind":{"Normal":{}}},{"name":"littleEndian","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _v_ be *this* value.\n  1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n  1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, ~float64~, _value_).","code":"\n          1. Let _v_ be the *this* value.\n          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n          1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, ~float64~, _value_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"DataView"}},"name":"prototype"}},"name":"setInt8"}},"params":[{"name":"byteOffset","ty":"Unknown","kind":{"Normal":{}}},{"name":"value","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _v_ be *this* value.\n  1. Return ? SetViewValue(_v_, _byteOffset_, *true*, ~int8~, _value_).","code":"\n          1. Let _v_ be the *this* value.\n          1. Return ? SetViewValue(_v_, _byteOffset_, *true*, ~int8~, _value_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"DataView"}},"name":"prototype"}},"name":"setInt16"}},"params":[{"name":"byteOffset","ty":"Unknown","kind":{"Normal":{}}},{"name":"value","ty":"Unknown","kind":{"Normal":{}}},{"name":"littleEndian","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _v_ be *this* value.\n  1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n  1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, ~int16~, _value_).","code":"\n          1. Let _v_ be the *this* value.\n          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n          1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, ~int16~, _value_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"DataView"}},"name":"prototype"}},"name":"setInt32"}},"params":[{"name":"byteOffset","ty":"Unknown","kind":{"Normal":{}}},{"name":"value","ty":"Unknown","kind":{"Normal":{}}},{"name":"littleEndian","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _v_ be *this* value.\n  1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n  1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, ~int32~, _value_).","code":"\n          1. Let _v_ be the *this* value.\n          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n          1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, ~int32~, _value_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"DataView"}},"name":"prototype"}},"name":"setUint8"}},"params":[{"name":"byteOffset","ty":"Unknown","kind":{"Normal":{}}},{"name":"value","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _v_ be *this* value.\n  1. Return ? SetViewValue(_v_, _byteOffset_, *true*, ~uint8~, _value_).","code":"\n          1. Let _v_ be the *this* value.\n          1. Return ? SetViewValue(_v_, _byteOffset_, *true*, ~uint8~, _value_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"DataView"}},"name":"prototype"}},"name":"setUint16"}},"params":[{"name":"byteOffset","ty":"Unknown","kind":{"Normal":{}}},{"name":"value","ty":"Unknown","kind":{"Normal":{}}},{"name":"littleEndian","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _v_ be *this* value.\n  1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n  1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, ~uint16~, _value_).","code":"\n          1. Let _v_ be the *this* value.\n          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n          1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, ~uint16~, _value_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"DataView"}},"name":"prototype"}},"name":"setUint32"}},"params":[{"name":"byteOffset","ty":"Unknown","kind":{"Normal":{}}},{"name":"value","ty":"Unknown","kind":{"Normal":{}}},{"name":"littleEndian","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _v_ be *this* value.\n  1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n  1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, ~uint32~, _value_).","code":"\n          1. Let _v_ be the *this* value.\n          1. If _littleEndian_ is not present, set _littleEndian_ to *false*.\n          1. Return ? SetViewValue(_v_, _byteOffset_, _littleEndian_, ~uint32~, _value_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ValidateIntegerTypedArray","params":[{"name":"typedArray","ty":"ESValue","kind":{"Normal":{}}},{"name":"waitable","ty":"Boolean","kind":{"Normal":{}}}],"retTy":"Normal[Record[TypedArrayWithBufferWitnessRecord]] | Throw"}},"body":"\n  1. Let _taRecord_ be ? ValidateTypedArray(_typedArray_, ~unordered~).\n  1. NOTE: Bounds checking is not a synchronizing operation when _typedArray_'s backing buffer is a growable SharedArrayBuffer.\n  1. If _waitable_ is *true*, then\n    1. If _typedArray_.[[TypedArrayName]] is neither *\"Int32Array\"* nor *\"BigInt64Array\"*, throw a *TypeError* exception.\n  1. Else,\n    1. Let _type_ be TypedArrayElementType(_typedArray_).\n    1. If IsUnclampedIntegerElementType(_type_) is *false* and IsBigIntElementType(_type_) is *false*, throw a *TypeError* exception.\n  1. Return _taRecord_.","code":"\n          1. Let _taRecord_ be ? ValidateTypedArray(_typedArray_, ~unordered~).\n          1. NOTE: Bounds checking is not a synchronizing operation when _typedArray_'s backing buffer is a growable SharedArrayBuffer.\n          1. If _waitable_ is *true*, then\n            1. If _typedArray_.[[TypedArrayName]] is neither *\"Int32Array\"* nor *\"BigInt64Array\"*, throw a *TypeError* exception.\n          1. Else,\n            1. Let _type_ be TypedArrayElementType(_typedArray_).\n            1. If IsUnclampedIntegerElementType(_type_) is *false* and IsBigIntElementType(_type_) is *false*, throw a *TypeError* exception.\n          1. Return _taRecord_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ValidateAtomicAccess","params":[{"name":"taRecord","ty":"Record[TypedArrayWithBufferWitnessRecord]","kind":{"Normal":{}}},{"name":"requestIndex","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Int] | Throw"}},"body":"\n  1. Let _length_ be TypedArrayLength(_taRecord_).\n  1. Let _accessIndex_ be ? ToIndex(_requestIndex_).\n  1. Assert: _accessIndex_ ≥ 0.\n  1. If _accessIndex_ ≥ _length_, throw a *RangeError* exception.\n  1. Let _typedArray_ be _taRecord_.[[Object]].\n  1. Let _elementSize_ be TypedArrayElementSize(_typedArray_).\n  1. Let _offset_ be _typedArray_.[[ByteOffset]].\n  1. Return _accessIndex_ × _elementSize_ + _offset_.","code":"\n          1. Let _length_ be TypedArrayLength(_taRecord_).\n          1. Let _accessIndex_ be ? ToIndex(_requestIndex_).\n          1. Assert: _accessIndex_ ≥ 0.\n          1. If _accessIndex_ ≥ _length_, throw a *RangeError* exception.\n          1. Let _typedArray_ be _taRecord_.[[Object]].\n          1. Let _elementSize_ be TypedArrayElementSize(_typedArray_).\n          1. Let _offset_ be _typedArray_.[[ByteOffset]].\n          1. Return (_accessIndex_ × _elementSize_) + _offset_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ValidateAtomicAccessOnIntegerTypedArray","params":[{"name":"typedArray","ty":"ESValue","kind":{"Normal":{}}},{"name":"requestIndex","ty":"ESValue","kind":{"Normal":{}}},{"name":"waitable","ty":"Boolean","kind":{"Optional":{}}}],"retTy":"Normal[Int] | Throw"}},"body":"\n  1. If _waitable_ is not present, set _waitable_ to *false*.\n  1. Let _taRecord_ be ? ValidateIntegerTypedArray(_typedArray_, _waitable_).\n  1. Return ? ValidateAtomicAccess(_taRecord_, _requestIndex_).","code":"\n          1. If _waitable_ is not present, set _waitable_ to *false*.\n          1. Let _taRecord_ be ? ValidateIntegerTypedArray(_typedArray_, _waitable_).\n          1. Return ? ValidateAtomicAccess(_taRecord_, _requestIndex_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"RevalidateAtomicAccess","params":[{"name":"typedArray","ty":"Record[TypedArray]","kind":{"Normal":{}}},{"name":"byteIndexInBuffer","ty":"Int","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_typedArray_, ~unordered~).\n  1. NOTE: Bounds checking is not a synchronizing operation when _typedArray_'s backing buffer is a growable SharedArrayBuffer.\n  1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.\n  1. Assert: _byteIndexInBuffer_ ≥ _typedArray_.[[ByteOffset]].\n  1. If _byteIndexInBuffer_ ≥ _taRecord_.[[CachedBufferByteLength]], throw a *RangeError* exception.\n  1. Return ~unused~.","code":"\n          1. Let _taRecord_ be MakeTypedArrayWithBufferWitnessRecord(_typedArray_, ~unordered~).\n          1. NOTE: Bounds checking is not a synchronizing operation when _typedArray_'s backing buffer is a growable SharedArrayBuffer.\n          1. If IsTypedArrayOutOfBounds(_taRecord_) is *true*, throw a *TypeError* exception.\n          1. Assert: _byteIndexInBuffer_ ≥ _typedArray_.[[ByteOffset]].\n          1. If _byteIndexInBuffer_ ≥ _taRecord_.[[CachedBufferByteLength]], throw a *RangeError* exception.\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetWaiterList","params":[{"name":"block","ty":"Record[SharedDataBlock]","kind":{"Normal":{}}},{"name":"i","ty":"Unknown[\"a non-negative integer that is evenly divisible by 4\"]","kind":{"Normal":{}}}],"retTy":"Record[WaiterListRecord]"}},"body":"\n  1. Assert: _i_ and _i_ + 3 are valid byte offsets within the memory of _block_..\n  1. Return the WaiterList Record that is referenced by the pair (_block_, _i_).","code":"\n          1. Assert: _i_ and _i_ + 3 are valid byte offsets within the memory of _block_.\n          1. Return the WaiterList Record that is referenced by the pair (_block_, _i_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"EnterCriticalSection","params":[{"name":"WL","ty":"Record[WaiterListRecord]","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Assert: The surrounding agent is not in the critical section for any WaiterList Record..\n  1. Wait until no agent is in the critical section for _WL_, then enter the critical section for _WL_ (without allowing any other agent to enter).\n  1. If _WL_.[[MostRecentLeaveEvent]] is not ~empty~, then\n    1. NOTE: A _WL_ whose critical section has been entered at least once has a Synchronize event set by LeaveCriticalSection.\n    1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\n    1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\n    1. Let _enterEvent_ be a new Synchronize event.\n    1. Append _enterEvent_ to _eventsRecord_.[[EventList]].\n    1. Append (_WL_.[[MostRecentLeaveEvent]], _enterEvent_) to _eventsRecord_.[[AgentSynchronizesWith]].\n  1. Return ~unused~.","code":"\n          1. Assert: The surrounding agent is not in the critical section for any WaiterList Record.\n          1. Wait until no agent is in the critical section for _WL_, then enter the critical section for _WL_ (without allowing any other agent to enter).\n          1. If _WL_.[[MostRecentLeaveEvent]] is not ~empty~, then\n            1. NOTE: A _WL_ whose critical section has been entered at least once has a Synchronize event set by LeaveCriticalSection.\n            1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\n            1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\n            1. Let _enterEvent_ be a new Synchronize event.\n            1. Append _enterEvent_ to _eventsRecord_.[[EventList]].\n            1. Append (_WL_.[[MostRecentLeaveEvent]], _enterEvent_) to _eventsRecord_.[[AgentSynchronizesWith]].\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"LeaveCriticalSection","params":[{"name":"WL","ty":"Record[WaiterListRecord]","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Assert: The surrounding agent is in the critical section for _WL_..\n  1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\n  1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\n  1. Let _leaveEvent_ be a new Synchronize event.\n  1. Append _leaveEvent_ to _eventsRecord_.[[EventList]].\n  1. Set _WL_.[[MostRecentLeaveEvent]] to _leaveEvent_.\n  1. Leave the critical section for _WL_.\n  1. Return ~unused~.","code":"\n          1. Assert: The surrounding agent is in the critical section for _WL_.\n          1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\n          1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\n          1. Let _leaveEvent_ be a new Synchronize event.\n          1. Append _leaveEvent_ to _eventsRecord_.[[EventList]].\n          1. Set _WL_.[[MostRecentLeaveEvent]] to _leaveEvent_.\n          1. Leave the critical section for _WL_.\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AddWaiter","params":[{"name":"WL","ty":"Record[WaiterListRecord]","kind":{"Normal":{}}},{"name":"waiterRecord","ty":"Record[WaiterRecord]","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Assert: The surrounding agent is in the critical section for _WL_..\n  1. Assert: There is no Waiter Record in _WL_.[[Waiters]] whose [[PromiseCapability]] field is _waiterRecord_.[[PromiseCapability]] and whose [[AgentSignifier]] field is _waiterRecord_.[[AgentSignifier]]..\n  1. Append _waiterRecord_ to _WL_.[[Waiters]].\n  1. Return ~unused~.","code":"\n          1. Assert: The surrounding agent is in the critical section for _WL_.\n          1. Assert: There is no Waiter Record in _WL_.[[Waiters]] whose [[PromiseCapability]] field is _waiterRecord_.[[PromiseCapability]] and whose [[AgentSignifier]] field is _waiterRecord_.[[AgentSignifier]].\n          1. Append _waiterRecord_ to _WL_.[[Waiters]].\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"RemoveWaiter","params":[{"name":"WL","ty":"Record[WaiterListRecord]","kind":{"Normal":{}}},{"name":"waiterRecord","ty":"Record[WaiterRecord]","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Assert: The surrounding agent is in the critical section for _WL_..\n  1. Assert: _WL_.[[Waiters]] contains _waiterRecord_.\n  1. Remove _waiterRecord_ from _WL_.[[Waiters]].\n  1. Return ~unused~.","code":"\n          1. Assert: The surrounding agent is in the critical section for _WL_.\n          1. Assert: _WL_.[[Waiters]] contains _waiterRecord_.\n          1. Remove _waiterRecord_ from _WL_.[[Waiters]].\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"RemoveWaiters","params":[{"name":"WL","ty":"Record[WaiterListRecord]","kind":{"Normal":{}}},{"name":"c","ty":"NonNegInt | +INF","kind":{"Normal":{}}}],"retTy":"List[Record[WaiterRecord]]"}},"body":"\n  1. Assert: The surrounding agent is in the critical section for _WL_..\n  1. Let _len_ be the number of elements in _WL_.[[Waiters]].\n  1. Let _n_ be min(_c_, _len_).\n  1. Let _L_ be a List whose elements are the first _n_ elements of _WL_.[[Waiters]].\n  1. Remove the first _n_ elements of _WL_.[[Waiters]].\n  1. Return _L_.","code":"\n          1. Assert: The surrounding agent is in the critical section for _WL_.\n          1. Let _len_ be the number of elements in _WL_.[[Waiters]].\n          1. Let _n_ be min(_c_, _len_).\n          1. Let _L_ be a List whose elements are the first _n_ elements of _WL_.[[Waiters]].\n          1. Remove the first _n_ elements of _WL_.[[Waiters]].\n          1. Return _L_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"SuspendThisAgent","params":[{"name":"WL","ty":"Record[WaiterListRecord]","kind":{"Normal":{}}},{"name":"waiterRecord","ty":"Record[WaiterRecord]","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Assert: The surrounding agent is in the critical section for _WL_..\n  1. Assert: _WL_.[[Waiters]] contains _waiterRecord_.\n  1. Let _thisAgent_ be AgentSignifier().\n  1. Assert: _waiterRecord_.[[AgentSignifier]] is _thisAgent_.\n  1. Assert: _waiterRecord_.[[PromiseCapability]] is ~blocking~.\n  1. Assert: AgentCanSuspend() is *true*.\n  1. Perform LeaveCriticalSection(_WL_) and suspend the surrounding agent until the time is _waiterRecord_.[[TimeoutTime]], performing the combined operation in such a way that a notification that arrives after the critical section is exited but before the suspension takes effect is not lost. The surrounding agent can only wake from suspension due to a timeout or due to another agent calling NotifyWaiter with arguments _WL_ and _thisAgent_ (i.e. via a call to `Atomics.notify`).\n  1. Perform EnterCriticalSection(_WL_).\n  1. Return ~unused~.","code":"\n          1. Assert: The surrounding agent is in the critical section for _WL_.\n          1. Assert: _WL_.[[Waiters]] contains _waiterRecord_.\n          1. Let _thisAgent_ be AgentSignifier().\n          1. Assert: _waiterRecord_.[[AgentSignifier]] is _thisAgent_.\n          1. Assert: _waiterRecord_.[[PromiseCapability]] is ~blocking~.\n          1. Assert: AgentCanSuspend() is *true*.\n          1. Perform LeaveCriticalSection(_WL_) and suspend the surrounding agent until the time is _waiterRecord_.[[TimeoutTime]], performing the combined operation in such a way that a notification that arrives after the critical section is exited but before the suspension takes effect is not lost. The surrounding agent can only wake from suspension due to a timeout or due to another agent calling NotifyWaiter with arguments _WL_ and _thisAgent_ (i.e. via a call to `Atomics.notify`).\n          1. Perform EnterCriticalSection(_WL_).\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"NotifyWaiter","params":[{"name":"WL","ty":"Record[WaiterListRecord]","kind":{"Normal":{}}},{"name":"waiterRecord","ty":"Record[WaiterRecord]","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Assert: The surrounding agent is in the critical section for _WL_..\n  1. If _waiterRecord_.[[PromiseCapability]] is ~blocking~, then\n    1. Wake the agent whose signifier is _waiterRecord_.[[AgentSignifier]] from suspension.\n    1. NOTE: This causes the agent to resume execution in SuspendThisAgent.\n  1. Else if AgentSignifier() is _waiterRecord_.[[AgentSignifier]], then\n    1. Let _promiseCapability_ be _waiterRecord_.[[PromiseCapability]].\n    1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _waiterRecord_.[[Result]] »).\n  1. Else,\n    1. Perform EnqueueResolveInAgentJob(_waiterRecord_.[[AgentSignifier]], _waiterRecord_.[[PromiseCapability]], _waiterRecord_.[[Result]]).\n  1. Return ~unused~.","code":"\n          1. Assert: The surrounding agent is in the critical section for _WL_.\n          1. If _waiterRecord_.[[PromiseCapability]] is ~blocking~, then\n            1. Wake the agent whose signifier is _waiterRecord_.[[AgentSignifier]] from suspension.\n            1. NOTE: This causes the agent to resume execution in SuspendThisAgent.\n          1. Else if AgentSignifier() is _waiterRecord_.[[AgentSignifier]], then\n            1. Let _promiseCapability_ be _waiterRecord_.[[PromiseCapability]].\n            1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _waiterRecord_.[[Result]] »).\n          1. Else,\n            1. Perform EnqueueResolveInAgentJob(_waiterRecord_.[[AgentSignifier]], _waiterRecord_.[[PromiseCapability]], _waiterRecord_.[[Result]]).\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"EnqueueResolveInAgentJob","params":[{"name":"agentSignifier","ty":"Unknown[\"an agent signifier\"]","kind":{"Normal":{}}},{"name":"promiseCapability","ty":"Record[PromiseCapabilityRecord]","kind":{"Normal":{}}},{"name":"resolution","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Let _resolveJob_ be a new Abstract Closure with no parameters that captures _agentSignifier_, _promiseCapability_, and _resolution_ and performs the following steps when called:\n    1. Assert: AgentSignifier() is _agentSignifier_.\n    1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _resolution_ »).\n    1. Return ~unused~.\n  1. Let _realmInTargetAgent_ be ! GetFunctionRealm(_promiseCapability_.[[Resolve]]).\n  1. Assert: _agentSignifier_ is _realmInTargetAgent_.[[AgentSignifier]].\n  1. Perform HostEnqueueGenericJob(_resolveJob_, _realmInTargetAgent_).\n  1. Return ~unused~.","code":"\n          1. Let _resolveJob_ be a new Job Abstract Closure with no parameters that captures _agentSignifier_, _promiseCapability_, and _resolution_ and performs the following steps when called:\n            1. Assert: AgentSignifier() is _agentSignifier_.\n            1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _resolution_ »).\n            1. Return ~unused~.\n          1. Let _realmInTargetAgent_ be ! GetFunctionRealm(_promiseCapability_.[[Resolve]]).\n          1. Assert: _agentSignifier_ is _realmInTargetAgent_.[[AgentSignifier]].\n          1. Perform HostEnqueueGenericJob(_resolveJob_, _realmInTargetAgent_).\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"DoWait","params":[{"name":"mode","ty":"Enum[~async~, ~sync~]","kind":{"Normal":{}}},{"name":"typedArray","ty":"ESValue","kind":{"Normal":{}}},{"name":"index","ty":"ESValue","kind":{"Normal":{}}},{"name":"value","ty":"ESValue","kind":{"Normal":{}}},{"name":"timeout","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Unknown[\"either a normal completion containing either an Object, *\\\"not-equal\\\"*, *\\\"timed-out\\\"*, or *\\\"ok\\\"*, or a throw completion\"]"}},"body":"\n  1. Let _taRecord_ be ? ValidateIntegerTypedArray(_typedArray_, *true*).\n  1. Let _buffer_ be _taRecord_.[[Object]].[[ViewedArrayBuffer]].\n  1. If IsSharedArrayBuffer(_buffer_) is *false*, throw a *TypeError* exception.\n  1. Let _i_ be ? ValidateAtomicAccess(_taRecord_, _index_).\n  1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].\n  1. If _arrayTypeName_ is *\"BigInt64Array\"*, let _v_ be ? ToBigInt64(_value_).\n  1. Else, let _v_ be ? ToInt32(_value_).\n  1. Let _q_ be ? ToNumber(_timeout_).\n  1. If _q_ is either *NaN* or *+∞*<sub>𝔽</sub>, let _t_ be +∞.\n  1. Else if _q_ is *-∞*<sub>𝔽</sub>, let _t_ be 0.\n  1. Else, let _t_ be max(ℝ(_q_), 0).\n  1. If _mode_ is ~sync~ and AgentCanSuspend() is *false*, throw a *TypeError* exception.\n  1. Let _block_ be _buffer_.[[ArrayBufferData]].\n  1. Let _offset_ be _typedArray_.[[ByteOffset]].\n  1. Let _byteIndexInBuffer_ be _i_ × 4 + _offset_.\n  1. Let _WL_ be GetWaiterList(_block_, _byteIndexInBuffer_).\n  1. If _mode_ is ~sync~, then\n    1. Let _promiseCapability_ be ~blocking~.\n    1. Let _resultObject_ be *undefined*.\n  1. Else,\n    1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n    1. Let _resultObject_ be OrdinaryObjectCreate(%Object.prototype%).\n  1. Perform EnterCriticalSection(_WL_).\n  1. Let _elementType_ be TypedArrayElementType(_typedArray_).\n  1. Let _w_ be GetValueFromBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, *true*, ~seq-cst~).\n  1. If _v_ ≠ _w_, then\n    1. Perform LeaveCriticalSection(_WL_).\n    1. If _mode_ is ~sync~, return *\"not-equal\"*.\n    1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *\"async\"*, *false*).\n    1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *\"value\"*, *\"not-equal\"*).\n    1. Return _resultObject_.\n  1. If _t_ is 0 and _mode_ is ~async~, then\n    1. NOTE: There is no special handling of synchronous immediate timeouts. Asynchronous immediate timeouts have special handling in order to fail fast and avoid unnecessary Promise jobs.\n    1. Perform LeaveCriticalSection(_WL_).\n    1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *\"async\"*, *false*).\n    1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *\"value\"*, *\"timed-out\"*).\n    1. Return _resultObject_.\n  1. Let _thisAgent_ be AgentSignifier().\n  1. Let _now_ be the time value (UTC) identifying the current time.\n  1. Let _additionalTimeout_ be an implementation-defined non-negative mathematical value.\n  1. Let _timeoutTime_ be ℝ(_now_) + _t_ + _additionalTimeout_.\n  1. NOTE: When _t_ is +∞, _timeoutTime_ is also +∞.\n  1. Let _waiterRecord_ be a new Waiter Record { [[AgentSignifier]]: _thisAgent_, [[PromiseCapability]]: _promiseCapability_, [[TimeoutTime]]: _timeoutTime_, [[Result]]: *\"ok\"* }.\n  1. Perform AddWaiter(_WL_, _waiterRecord_).\n  1. If _mode_ is ~sync~, then\n    1. Perform SuspendThisAgent(_WL_, _waiterRecord_).\n  1. Else if _timeoutTime_ is finite, then\n    1. Perform EnqueueAtomicsWaitAsyncTimeoutJob(_WL_, _waiterRecord_).\n  1. Perform LeaveCriticalSection(_WL_).\n  1. If _mode_ is ~sync~, return _waiterRecord_.[[Result]].\n  1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *\"async\"*, *true*).\n  1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *\"value\"*, _promiseCapability_.[[Promise]]).\n  1. Return _resultObject_.","code":"\n          1. Let _taRecord_ be ? ValidateIntegerTypedArray(_typedArray_, *true*).\n          1. Let _buffer_ be _taRecord_.[[Object]].[[ViewedArrayBuffer]].\n          1. If IsSharedArrayBuffer(_buffer_) is *false*, throw a *TypeError* exception.\n          1. Let _i_ be ? ValidateAtomicAccess(_taRecord_, _index_).\n          1. Let _arrayTypeName_ be _typedArray_.[[TypedArrayName]].\n          1. If _arrayTypeName_ is *\"BigInt64Array\"*, let _v_ be ? ToBigInt64(_value_).\n          1. Else, let _v_ be ? ToInt32(_value_).\n          1. Let _q_ be ? ToNumber(_timeout_).\n          1. If _q_ is either *NaN* or *+∞*<sub>𝔽</sub>, let _t_ be +∞; else if _q_ is *-∞*<sub>𝔽</sub>, let _t_ be 0; else let _t_ be max(ℝ(_q_), 0).\n          1. If _mode_ is ~sync~ and AgentCanSuspend() is *false*, throw a *TypeError* exception.\n          1. Let _block_ be _buffer_.[[ArrayBufferData]].\n          1. Let _offset_ be _typedArray_.[[ByteOffset]].\n          1. Let _byteIndexInBuffer_ be (_i_ × 4) + _offset_.\n          1. Let _WL_ be GetWaiterList(_block_, _byteIndexInBuffer_).\n          1. If _mode_ is ~sync~, then\n            1. Let _promiseCapability_ be ~blocking~.\n            1. Let _resultObject_ be *undefined*.\n          1. Else,\n            1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n            1. Let _resultObject_ be OrdinaryObjectCreate(%Object.prototype%).\n          1. Perform EnterCriticalSection(_WL_).\n          1. Let _elementType_ be TypedArrayElementType(_typedArray_).\n          1. Let _w_ be GetValueFromBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, *true*, ~seq-cst~).\n          1. If _v_ ≠ _w_, then\n            1. Perform LeaveCriticalSection(_WL_).\n            1. If _mode_ is ~sync~, return *\"not-equal\"*.\n            1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *\"async\"*, *false*).\n            1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *\"value\"*, *\"not-equal\"*).\n            1. Return _resultObject_.\n          1. If _t_ is 0 and _mode_ is ~async~, then\n            1. NOTE: There is no special handling of synchronous immediate timeouts. Asynchronous immediate timeouts have special handling in order to fail fast and avoid unnecessary Promise jobs.\n            1. Perform LeaveCriticalSection(_WL_).\n            1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *\"async\"*, *false*).\n            1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *\"value\"*, *\"timed-out\"*).\n            1. Return _resultObject_.\n          1. Let _thisAgent_ be AgentSignifier().\n          1. Let _now_ be the time value (UTC) identifying the current time.\n          1. Let _additionalTimeout_ be an implementation-defined non-negative mathematical value.\n          1. Let _timeoutTime_ be ℝ(_now_) + _t_ + _additionalTimeout_.\n          1. NOTE: When _t_ is +∞, _timeoutTime_ is also +∞.\n          1. Let _waiterRecord_ be a new Waiter Record { [[AgentSignifier]]: _thisAgent_, [[PromiseCapability]]: _promiseCapability_, [[TimeoutTime]]: _timeoutTime_, [[Result]]: *\"ok\"* }.\n          1. Perform AddWaiter(_WL_, _waiterRecord_).\n          1. If _mode_ is ~sync~, then\n            1. Perform SuspendThisAgent(_WL_, _waiterRecord_).\n          1. Else if _timeoutTime_ is finite, then\n            1. Perform EnqueueAtomicsWaitAsyncTimeoutJob(_WL_, _waiterRecord_).\n          1. Perform LeaveCriticalSection(_WL_).\n          1. If _mode_ is ~sync~, return _waiterRecord_.[[Result]].\n          1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *\"async\"*, *true*).\n          1. Perform ! CreateDataPropertyOrThrow(_resultObject_, *\"value\"*, _promiseCapability_.[[Promise]]).\n          1. Return _resultObject_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"EnqueueAtomicsWaitAsyncTimeoutJob","params":[{"name":"WL","ty":"Record[WaiterListRecord]","kind":{"Normal":{}}},{"name":"waiterRecord","ty":"Record[WaiterRecord]","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Let _timeoutJob_ be a new Abstract Closure with no parameters that captures _WL_ and _waiterRecord_ and performs the following steps when called:\n    1. Perform EnterCriticalSection(_WL_).\n    1. If _WL_.[[Waiters]] contains _waiterRecord_, then\n      1. Let _timeOfJobExecution_ be the time value (UTC) identifying the current time.\n      1. Assert: ℝ(_timeOfJobExecution_) ≥ _waiterRecord_.[[TimeoutTime]] (ignoring potential non-monotonicity of time values)..\n      1. Set _waiterRecord_.[[Result]] to *\"timed-out\"*.\n      1. Perform RemoveWaiter(_WL_, _waiterRecord_).\n      1. Perform NotifyWaiter(_WL_, _waiterRecord_).\n    1. Perform LeaveCriticalSection(_WL_).\n    1. Return ~unused~.\n  1. Let _now_ be the time value (UTC) identifying the current time.\n  1. Let _currentRealm_ be the current Realm Record.\n  1. Perform HostEnqueueTimeoutJob(_timeoutJob_, _currentRealm_, 𝔽(_waiterRecord_.[[TimeoutTime]]) - _now_).\n  1. Return ~unused~.","code":"\n          1. Let _timeoutJob_ be a new Job Abstract Closure with no parameters that captures _WL_ and _waiterRecord_ and performs the following steps when called:\n            1. Perform EnterCriticalSection(_WL_).\n            1. If _WL_.[[Waiters]] contains _waiterRecord_, then\n              1. Let _timeOfJobExecution_ be the time value (UTC) identifying the current time.\n              1. Assert: ℝ(_timeOfJobExecution_) ≥ _waiterRecord_.[[TimeoutTime]] (ignoring potential non-monotonicity of time values).\n              1. Set _waiterRecord_.[[Result]] to *\"timed-out\"*.\n              1. Perform RemoveWaiter(_WL_, _waiterRecord_).\n              1. Perform NotifyWaiter(_WL_, _waiterRecord_).\n            1. Perform LeaveCriticalSection(_WL_).\n            1. Return ~unused~.\n          1. Let _now_ be the time value (UTC) identifying the current time.\n          1. Let _currentRealm_ be the current Realm Record.\n          1. Perform HostEnqueueTimeoutJob(_timeoutJob_, _currentRealm_, 𝔽(_waiterRecord_.[[TimeoutTime]]) - _now_).\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AtomicCompareExchangeInSharedBlock","params":[{"name":"block","ty":"Record[SharedDataBlock]","kind":{"Normal":{}}},{"name":"byteIndexInBuffer","ty":"Int","kind":{"Normal":{}}},{"name":"elementSize","ty":"NonNegInt","kind":{"Normal":{}}},{"name":"expectedBytes","ty":"Unknown[\"a List of byte values\"]","kind":{"Normal":{}}},{"name":"replacementBytes","ty":"Unknown[\"a List of byte values\"]","kind":{"Normal":{}}}],"retTy":"Unknown[\"a List of byte values\"]"}},"body":"\n  1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\n  1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\n  1. Let _rawBytesRead_ be a List of length _elementSize_ whose elements are nondeterministically chosen byte values.\n  1. NOTE: In implementations, _rawBytesRead_ is the result of a load-link, of a load-exclusive, or of an operand of a read-modify-write instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.\n  1. NOTE: The comparison of the expected value and the read value is performed outside of the read-modify-write modification function to avoid needlessly strong synchronization when the expected value is not equal to the read value.\n  1. If ByteListEqual(_rawBytesRead_, _expectedBytes_) is *true*, then\n    1. Let _second_ be a new read-modify-write modification function with parameters (_oldBytes_, _newBytes_) that captures nothing and performs the following steps atomically when called:\n      1. Return _newBytes_.\n    1. Let _event_ be ReadModifyWriteSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _byteIndexInBuffer_, [[ElementSize]]: _elementSize_, [[Payload]]: _replacementBytes_, [[ModifyOp]]: _second_ }.\n  1. Else,\n    1. Let _event_ be ReadSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _byteIndexInBuffer_, [[ElementSize]]: _elementSize_ }.\n  1. Append _event_ to _eventsRecord_.[[EventList]].\n  1. Append Chosen Value Record { [[Event]]: _event_, [[ChosenValue]]: _rawBytesRead_ } to _execution_.[[ChosenValues]].\n  1. Return _rawBytesRead_.","code":"\n          1. Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\n          1. Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\n          1. Let _rawBytesRead_ be a List of length _elementSize_ whose elements are nondeterministically chosen byte values.\n          1. NOTE: In implementations, _rawBytesRead_ is the result of a load-link, of a load-exclusive, or of an operand of a read-modify-write instruction on the underlying hardware. The nondeterminism is a semantic prescription of the memory model to describe observable behaviour of hardware with weak consistency.\n          1. NOTE: The comparison of the expected value and the read value is performed outside of the read-modify-write modification function to avoid needlessly strong synchronization when the expected value is not equal to the read value.\n          1. If ByteListEqual(_rawBytesRead_, _expectedBytes_) is *true*, then\n            1. Let _second_ be a new read-modify-write modification function with parameters (_oldBytes_, _newBytes_) that captures nothing and performs the following steps atomically when called:\n              1. Return _newBytes_.\n            1. Let _event_ be ReadModifyWriteSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _byteIndexInBuffer_, [[ElementSize]]: _elementSize_, [[Payload]]: _replacementBytes_, [[ModifyOp]]: _second_ }.\n          1. Else,\n            1. Let _event_ be ReadSharedMemory { [[Order]]: ~seq-cst~, [[NoTear]]: *true*, [[Block]]: _block_, [[ByteIndex]]: _byteIndexInBuffer_, [[ElementSize]]: _elementSize_ }.\n          1. Append _event_ to _eventsRecord_.[[EventList]].\n          1. Append Chosen Value Record { [[Event]]: _event_, [[ChosenValue]]: _rawBytesRead_ } to _execution_.[[ChosenValues]].\n          1. Return _rawBytesRead_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AtomicReadModifyWrite","params":[{"name":"typedArray","ty":"ESValue","kind":{"Normal":{}}},{"name":"index","ty":"ESValue","kind":{"Normal":{}}},{"name":"value","ty":"ESValue","kind":{"Normal":{}}},{"name":"op","ty":"Unknown[\"a read-modify-write modification function\"]","kind":{"Normal":{}}}],"retTy":"Normal[Number | BigInt] | Throw"}},"body":"\n  1. Let _byteIndexInBuffer_ be ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_).\n  1. If _typedArray_.[[ContentType]] is ~bigint~, let _v_ be ? ToBigInt(_value_).\n  1. Else, let _v_ be 𝔽(? ToIntegerOrInfinity(_value_)).\n  1. Perform ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_).\n  1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].\n  1. Let _elementType_ be TypedArrayElementType(_typedArray_).\n  1. Return GetModifySetValueInBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, _v_, _op_).","code":"\n          1. Let _byteIndexInBuffer_ be ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_).\n          1. If _typedArray_.[[ContentType]] is ~bigint~, let _v_ be ? ToBigInt(_value_).\n          1. Otherwise, let _v_ be 𝔽(? ToIntegerOrInfinity(_value_)).\n          1. Perform ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_).\n          1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].\n          1. Let _elementType_ be TypedArrayElementType(_typedArray_).\n          1. Return GetModifySetValueInBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, _v_, _op_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ByteListBitwiseOp","params":[{"name":"op","ty":"Unknown[\"`&`, `^`, or `|`\"]","kind":{"Normal":{}}},{"name":"xBytes","ty":"Unknown[\"a List of byte values\"]","kind":{"Normal":{}}},{"name":"yBytes","ty":"Unknown[\"a List of byte values\"]","kind":{"Normal":{}}}],"retTy":"Unknown[\"a List of byte values\"]"}},"body":"\n  1. Assert: _xBytes_ and _yBytes_ have the same number of elements..\n  1. Let _result_ be « ».\n  1. Let _i_ be 0.\n  1. For each _xByte_ of _xBytes_, do\n    1. Let _yByte_ be _yBytes_[_i_].\n    1. If _op_ is `&`, then\n      1. Let _resultByte_ be the result of applying the bitwise AND operation to _xByte_ and _yByte_.\n    1. Else if _op_ is `^`, then\n      1. Let _resultByte_ be the result of applying the bitwise exclusive OR (XOR) operation to _xByte_ and _yByte_.\n    1. Else,\n      1. Assert: _op_ is `|`.\n      1. Let _resultByte_ be the result of applying the bitwise inclusive OR operation to _xByte_ and _yByte_.\n    1. Set _i_ to _i_ + 1.\n    1. Append _resultByte_ to _result_.\n  1. Return _result_.","code":"\n          1. Assert: _xBytes_ and _yBytes_ have the same number of elements.\n          1. Let _result_ be a new empty List.\n          1. Let _i_ be 0.\n          1. For each element _xByte_ of _xBytes_, do\n            1. Let _yByte_ be _yBytes_[_i_].\n            1. If _op_ is `&`, then\n              1. Let _resultByte_ be the result of applying the bitwise AND operation to _xByte_ and _yByte_.\n            1. Else if _op_ is `^`, then\n              1. Let _resultByte_ be the result of applying the bitwise exclusive OR (XOR) operation to _xByte_ and _yByte_.\n            1. Else,\n              1. Assert: _op_ is `|`.\n              1. Let _resultByte_ be the result of applying the bitwise inclusive OR operation to _xByte_ and _yByte_.\n            1. Set _i_ to _i_ + 1.\n            1. Append _resultByte_ to _result_.\n          1. Return _result_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ByteListEqual","params":[{"name":"xBytes","ty":"Unknown[\"a List of byte values\"]","kind":{"Normal":{}}},{"name":"yBytes","ty":"Unknown[\"a List of byte values\"]","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _xBytes_ and _yBytes_ do not have the same number of elements, return *false*.\n  1. Let _i_ be 0.\n  1. For each _xByte_ of _xBytes_, do\n    1. Let _yByte_ be _yBytes_[_i_].\n    1. If _xByte_ ≠ _yByte_, return *false*.\n    1. Set _i_ to _i_ + 1.\n  1. Return *true*.","code":"\n          1. If _xBytes_ and _yBytes_ do not have the same number of elements, return *false*.\n          1. Let _i_ be 0.\n          1. For each element _xByte_ of _xBytes_, do\n            1. Let _yByte_ be _yBytes_[_i_].\n            1. If _xByte_ ≠ _yByte_, return *false*.\n            1. Set _i_ to _i_ + 1.\n          1. Return *true*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Atomics"}},"name":"add"}},"params":[{"name":"typedArray","ty":"Unknown","kind":{"Normal":{}}},{"name":"index","ty":"Unknown","kind":{"Normal":{}}},{"name":"value","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _type_ be TypedArrayElementType(_typedArray_).\n  1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\n  1. Let _add_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures _type_ and _isLittleEndian_ and performs the following steps atomically when called:\n    1. Let _x_ be RawBytesToNumeric(_type_, _xBytes_, _isLittleEndian_).\n    1. Let _y_ be RawBytesToNumeric(_type_, _yBytes_, _isLittleEndian_).\n    1. If _x_ is a Number, then\n      1. Let _sum_ be Number::add(_x_, _y_).\n    1. Else,\n      1. Assert: _x_ is a BigInt.\n      1. Let _sum_ be BigInt::add(_x_, _y_).\n    1. Let _sumBytes_ be NumericToRawBytes(_type_, _sum_, _isLittleEndian_).\n    1. Assert: _sumBytes_, _xBytes_, and _yBytes_ have the same number of elements..\n    1. Return _sumBytes_.\n  1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _add_).","code":"\n        1. Let _type_ be TypedArrayElementType(_typedArray_).\n        1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\n        1. Let _add_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures _type_ and _isLittleEndian_ and performs the following steps atomically when called:\n          1. Let _x_ be RawBytesToNumeric(_type_, _xBytes_, _isLittleEndian_).\n          1. Let _y_ be RawBytesToNumeric(_type_, _yBytes_, _isLittleEndian_).\n          1. If _x_ is a Number, then\n            1. Let _sum_ be Number::add(_x_, _y_).\n          1. Else,\n            1. Assert: _x_ is a BigInt.\n            1. Let _sum_ be BigInt::add(_x_, _y_).\n          1. Let _sumBytes_ be NumericToRawBytes(_type_, _sum_, _isLittleEndian_).\n          1. Assert: _sumBytes_, _xBytes_, and _yBytes_ have the same number of elements.\n          1. Return _sumBytes_.\n        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _add_).\n      "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Atomics"}},"name":"and"}},"params":[{"name":"typedArray","ty":"Unknown","kind":{"Normal":{}}},{"name":"index","ty":"Unknown","kind":{"Normal":{}}},{"name":"value","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _and_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures nothing and performs the following steps atomically when called:\n    1. Return ByteListBitwiseOp(`&`, _xBytes_, _yBytes_).\n  1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _and_).","code":"\n        1. Let _and_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures nothing and performs the following steps atomically when called:\n          1. Return ByteListBitwiseOp(`&`, _xBytes_, _yBytes_).\n        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _and_).\n      "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Atomics"}},"name":"compareExchange"}},"params":[{"name":"typedArray","ty":"Unknown","kind":{"Normal":{}}},{"name":"index","ty":"Unknown","kind":{"Normal":{}}},{"name":"expectedValue","ty":"Unknown","kind":{"Normal":{}}},{"name":"replacementValue","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _byteIndexInBuffer_ be ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_).\n  1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].\n  1. Let _block_ be _buffer_.[[ArrayBufferData]].\n  1. If _typedArray_.[[ContentType]] is ~bigint~, then\n    1. Let _expected_ be ? ToBigInt(_expectedValue_).\n    1. Let _replacement_ be ? ToBigInt(_replacementValue_).\n  1. Else,\n    1. Let _expected_ be 𝔽(? ToIntegerOrInfinity(_expectedValue_)).\n    1. Let _replacement_ be 𝔽(? ToIntegerOrInfinity(_replacementValue_)).\n  1. Perform ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_).\n  1. Let _elementType_ be TypedArrayElementType(_typedArray_).\n  1. Let _elementSize_ be TypedArrayElementSize(_typedArray_).\n  1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\n  1. Let _expectedBytes_ be NumericToRawBytes(_elementType_, _expected_, _isLittleEndian_).\n  1. Let _replacementBytes_ be NumericToRawBytes(_elementType_, _replacement_, _isLittleEndian_).\n  1. If IsSharedArrayBuffer(_buffer_) is *true*, then\n    1. Let _rawBytesRead_ be AtomicCompareExchangeInSharedBlock(_block_, _byteIndexInBuffer_, _elementSize_, _expectedBytes_, _replacementBytes_).\n  1. Else,\n    1. Let _rawBytesRead_ be a List of length _elementSize_ whose elements are the sequence of _elementSize_ bytes starting with _block_[_byteIndexInBuffer_].\n    1. If ByteListEqual(_rawBytesRead_, _expectedBytes_) is *true*, then\n      1. Store the individual bytes of _replacementBytes_ into _block_, starting at _block_[_byteIndexInBuffer_].\n  1. Return RawBytesToNumeric(_elementType_, _rawBytesRead_, _isLittleEndian_).","code":"\n        1. Let _byteIndexInBuffer_ be ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_).\n        1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].\n        1. Let _block_ be _buffer_.[[ArrayBufferData]].\n        1. If _typedArray_.[[ContentType]] is ~bigint~, then\n          1. Let _expected_ be ? ToBigInt(_expectedValue_).\n          1. Let _replacement_ be ? ToBigInt(_replacementValue_).\n        1. Else,\n          1. Let _expected_ be 𝔽(? ToIntegerOrInfinity(_expectedValue_)).\n          1. Let _replacement_ be 𝔽(? ToIntegerOrInfinity(_replacementValue_)).\n        1. Perform ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_).\n        1. Let _elementType_ be TypedArrayElementType(_typedArray_).\n        1. Let _elementSize_ be TypedArrayElementSize(_typedArray_).\n        1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\n        1. Let _expectedBytes_ be NumericToRawBytes(_elementType_, _expected_, _isLittleEndian_).\n        1. Let _replacementBytes_ be NumericToRawBytes(_elementType_, _replacement_, _isLittleEndian_).\n        1. If IsSharedArrayBuffer(_buffer_) is *true*, then\n          1. Let _rawBytesRead_ be AtomicCompareExchangeInSharedBlock(_block_, _byteIndexInBuffer_, _elementSize_, _expectedBytes_, _replacementBytes_).\n        1. Else,\n          1. Let _rawBytesRead_ be a List of length _elementSize_ whose elements are the sequence of _elementSize_ bytes starting with _block_[_byteIndexInBuffer_].\n          1. If ByteListEqual(_rawBytesRead_, _expectedBytes_) is *true*, then\n            1. Store the individual bytes of _replacementBytes_ into _block_, starting at _block_[_byteIndexInBuffer_].\n        1. Return RawBytesToNumeric(_elementType_, _rawBytesRead_, _isLittleEndian_).\n      "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Atomics"}},"name":"exchange"}},"params":[{"name":"typedArray","ty":"Unknown","kind":{"Normal":{}}},{"name":"index","ty":"Unknown","kind":{"Normal":{}}},{"name":"value","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _second_ be a new read-modify-write modification function with parameters (_oldBytes_, _newBytes_) that captures nothing and performs the following steps atomically when called:\n    1. Return _newBytes_.\n  1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _second_).","code":"\n        1. Let _second_ be a new read-modify-write modification function with parameters (_oldBytes_, _newBytes_) that captures nothing and performs the following steps atomically when called:\n          1. Return _newBytes_.\n        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _second_).\n      "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Atomics"}},"name":"isLockFree"}},"params":[{"name":"size","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _n_ be ? ToIntegerOrInfinity(_size_).\n  1. Let _AR_ be the Agent Record of the surrounding agent.\n  1. If _n_ = 1, return _AR_.[[IsLockFree1]].\n  1. If _n_ = 2, return _AR_.[[IsLockFree2]].\n  1. If _n_ = 4, return *true*.\n  1. If _n_ = 8, return _AR_.[[IsLockFree8]].\n  1. Return *false*.","code":"\n        1. Let _n_ be ? ToIntegerOrInfinity(_size_).\n        1. Let _AR_ be the Agent Record of the surrounding agent.\n        1. If _n_ = 1, return _AR_.[[IsLockFree1]].\n        1. If _n_ = 2, return _AR_.[[IsLockFree2]].\n        1. If _n_ = 4, return *true*.\n        1. If _n_ = 8, return _AR_.[[IsLockFree8]].\n        1. Return *false*.\n      "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Atomics"}},"name":"load"}},"params":[{"name":"typedArray","ty":"Unknown","kind":{"Normal":{}}},{"name":"index","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _byteIndexInBuffer_ be ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_).\n  1. Perform ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_).\n  1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].\n  1. Let _elementType_ be TypedArrayElementType(_typedArray_).\n  1. Return GetValueFromBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, *true*, ~seq-cst~).","code":"\n        1. Let _byteIndexInBuffer_ be ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_).\n        1. Perform ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_).\n        1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].\n        1. Let _elementType_ be TypedArrayElementType(_typedArray_).\n        1. Return GetValueFromBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, *true*, ~seq-cst~).\n      "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Atomics"}},"name":"or"}},"params":[{"name":"typedArray","ty":"Unknown","kind":{"Normal":{}}},{"name":"index","ty":"Unknown","kind":{"Normal":{}}},{"name":"value","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _or_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures nothing and performs the following steps atomically when called:\n    1. Return ByteListBitwiseOp(`|`, _xBytes_, _yBytes_).\n  1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _or_).","code":"\n        1. Let _or_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures nothing and performs the following steps atomically when called:\n          1. Return ByteListBitwiseOp(`|`, _xBytes_, _yBytes_).\n        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _or_).\n      "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Atomics"}},"name":"store"}},"params":[{"name":"typedArray","ty":"Unknown","kind":{"Normal":{}}},{"name":"index","ty":"Unknown","kind":{"Normal":{}}},{"name":"value","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _byteIndexInBuffer_ be ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_).\n  1. If _typedArray_.[[ContentType]] is ~bigint~, let _v_ be ? ToBigInt(_value_).\n  1. Else, let _v_ be 𝔽(? ToIntegerOrInfinity(_value_)).\n  1. Perform ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_).\n  1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].\n  1. Let _elementType_ be TypedArrayElementType(_typedArray_).\n  1. Perform SetValueInBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, _v_, *true*, ~seq-cst~).\n  1. Return _v_.","code":"\n        1. Let _byteIndexInBuffer_ be ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_).\n        1. If _typedArray_.[[ContentType]] is ~bigint~, let _v_ be ? ToBigInt(_value_).\n        1. Otherwise, let _v_ be 𝔽(? ToIntegerOrInfinity(_value_)).\n        1. Perform ? RevalidateAtomicAccess(_typedArray_, _byteIndexInBuffer_).\n        1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].\n        1. Let _elementType_ be TypedArrayElementType(_typedArray_).\n        1. Perform SetValueInBuffer(_buffer_, _byteIndexInBuffer_, _elementType_, _v_, *true*, ~seq-cst~).\n        1. Return _v_.\n      "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Atomics"}},"name":"sub"}},"params":[{"name":"typedArray","ty":"Unknown","kind":{"Normal":{}}},{"name":"index","ty":"Unknown","kind":{"Normal":{}}},{"name":"value","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _type_ be TypedArrayElementType(_typedArray_).\n  1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\n  1. Let _subtract_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures _type_ and _isLittleEndian_ and performs the following steps atomically when called:\n    1. Let _x_ be RawBytesToNumeric(_type_, _xBytes_, _isLittleEndian_).\n    1. Let _y_ be RawBytesToNumeric(_type_, _yBytes_, _isLittleEndian_).\n    1. If _x_ is a Number, then\n      1. Let _difference_ be Number::subtract(_x_, _y_).\n    1. Else,\n      1. Assert: _x_ is a BigInt.\n      1. Let _difference_ be BigInt::subtract(_x_, _y_).\n    1. Let _differenceBytes_ be NumericToRawBytes(_type_, _difference_, _isLittleEndian_).\n    1. Assert: _differenceBytes_, _xBytes_, and _yBytes_ have the same number of elements..\n    1. Return _differenceBytes_.\n  1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _subtract_).","code":"\n        1. Let _type_ be TypedArrayElementType(_typedArray_).\n        1. Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\n        1. Let _subtract_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures _type_ and _isLittleEndian_ and performs the following steps atomically when called:\n          1. Let _x_ be RawBytesToNumeric(_type_, _xBytes_, _isLittleEndian_).\n          1. Let _y_ be RawBytesToNumeric(_type_, _yBytes_, _isLittleEndian_).\n          1. If _x_ is a Number, then\n            1. Let _difference_ be Number::subtract(_x_, _y_).\n          1. Else,\n            1. Assert: _x_ is a BigInt.\n            1. Let _difference_ be BigInt::subtract(_x_, _y_).\n          1. Let _differenceBytes_ be NumericToRawBytes(_type_, _difference_, _isLittleEndian_).\n          1. Assert: _differenceBytes_, _xBytes_, and _yBytes_ have the same number of elements.\n          1. Return _differenceBytes_.\n        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _subtract_).\n      "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Atomics"}},"name":"wait"}},"params":[{"name":"typedArray","ty":"Unknown","kind":{"Normal":{}}},{"name":"index","ty":"Unknown","kind":{"Normal":{}}},{"name":"value","ty":"Unknown","kind":{"Normal":{}}},{"name":"timeout","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Return ? DoWait(~sync~, _typedArray_, _index_, _value_, _timeout_).","code":"\n        1. Return ? DoWait(~sync~, _typedArray_, _index_, _value_, _timeout_).\n      "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Atomics"}},"name":"waitAsync"}},"params":[{"name":"typedArray","ty":"Unknown","kind":{"Normal":{}}},{"name":"index","ty":"Unknown","kind":{"Normal":{}}},{"name":"value","ty":"Unknown","kind":{"Normal":{}}},{"name":"timeout","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Return ? DoWait(~async~, _typedArray_, _index_, _value_, _timeout_).","code":"\n        1. Return ? DoWait(~async~, _typedArray_, _index_, _value_, _timeout_).\n      "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Atomics"}},"name":"notify"}},"params":[{"name":"typedArray","ty":"Unknown","kind":{"Normal":{}}},{"name":"index","ty":"Unknown","kind":{"Normal":{}}},{"name":"count","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _byteIndexInBuffer_ be ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_, *true*).\n  1. If _count_ is *undefined*, then\n    1. Let _c_ be +∞.\n  1. Else,\n    1. Let _intCount_ be ? ToIntegerOrInfinity(_count_).\n    1. Let _c_ be max(_intCount_, 0).\n  1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].\n  1. Let _block_ be _buffer_.[[ArrayBufferData]].\n  1. If IsSharedArrayBuffer(_buffer_) is *false*, return *+0*<sub>𝔽</sub>.\n  1. Let _WL_ be GetWaiterList(_block_, _byteIndexInBuffer_).\n  1. Perform EnterCriticalSection(_WL_).\n  1. Let _S_ be RemoveWaiters(_WL_, _c_).\n  1. For each _W_ of _S_, do\n    1. Perform NotifyWaiter(_WL_, _W_).\n  1. Perform LeaveCriticalSection(_WL_).\n  1. Let _n_ be the number of elements in _S_.\n  1. Return 𝔽(_n_).","code":"\n        1. Let _byteIndexInBuffer_ be ? ValidateAtomicAccessOnIntegerTypedArray(_typedArray_, _index_, *true*).\n        1. If _count_ is *undefined*, then\n          1. Let _c_ be +∞.\n        1. Else,\n          1. Let _intCount_ be ? ToIntegerOrInfinity(_count_).\n          1. Let _c_ be max(_intCount_, 0).\n        1. Let _buffer_ be _typedArray_.[[ViewedArrayBuffer]].\n        1. Let _block_ be _buffer_.[[ArrayBufferData]].\n        1. If IsSharedArrayBuffer(_buffer_) is *false*, return *+0*<sub>𝔽</sub>.\n        1. Let _WL_ be GetWaiterList(_block_, _byteIndexInBuffer_).\n        1. Perform EnterCriticalSection(_WL_).\n        1. Let _S_ be RemoveWaiters(_WL_, _c_).\n        1. For each element _W_ of _S_, do\n          1. Perform NotifyWaiter(_WL_, _W_).\n        1. Perform LeaveCriticalSection(_WL_).\n        1. Let _n_ be the number of elements in _S_.\n        1. Return 𝔽(_n_).\n      "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Atomics"}},"name":"xor"}},"params":[{"name":"typedArray","ty":"Unknown","kind":{"Normal":{}}},{"name":"index","ty":"Unknown","kind":{"Normal":{}}},{"name":"value","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _xor_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures nothing and performs the following steps atomically when called:\n    1. Return ByteListBitwiseOp(`^`, _xBytes_, _yBytes_).\n  1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _xor_).","code":"\n        1. Let _xor_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures nothing and performs the following steps atomically when called:\n          1. Return ByteListBitwiseOp(`^`, _xBytes_, _yBytes_).\n        1. Return ? AtomicReadModifyWrite(_typedArray_, _index_, _value_, _xor_).\n      "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"JSON"}},"name":"parse"}},"params":[{"name":"text","ty":"Unknown","kind":{"Normal":{}}},{"name":"reviver","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _jsonString_ be ? ToString(_text_).\n  1. [id=\"step-json-parse-validate\"] Parse StringToCodePoints(_jsonString_) as a JSON text as specified in ECMA-404. Throw a *SyntaxError* exception if it is not a valid JSON text as defined in that specification.\n  1. Let _scriptString_ be the string-concatenation of *\"(\"*, _jsonString_, and *\");\"*.\n  1. [id=\"step-json-parse-parse\"] Let _script_ be ParseText(StringToCodePoints(_scriptString_), |Script|).\n  1. NOTE: The early error rules defined in <emu-xref href=\"#sec-object-initializer-static-semantics-early-errors\"></emu-xref> have special handling for the above invocation of ParseText.\n  1. Assert: _script_ is a Ast.\n  1. [id=\"step-json-parse-eval\"] Let _completion_ be Completion(the result of evaluating _script_).\n  1. NOTE: The PropertyDefinitionEvaluation semantics defined in <emu-xref href=\"#sec-runtime-semantics-propertydefinitionevaluation\"></emu-xref> have special handling for the above evaluation.\n  1. Let _unfiltered_ be _completion_.[[Value]].\n  1. [id=\"step-json-parse-assert-type\"] Assert: _unfiltered_ is either a String, a Number, a Boolean, an Object that is defined by either an |ArrayLiteral| or an |ObjectLiteral|, or *null*..\n  1. If IsCallable(_reviver_) is *true*, then\n    1. Let _root_ be OrdinaryObjectCreate(%Object.prototype%).\n    1. Let _rootName_ be *\"\"*.\n    1. Perform ! CreateDataPropertyOrThrow(_root_, _rootName_, _unfiltered_).\n    1. Return ? InternalizeJSONProperty(_root_, _rootName_, _reviver_).\n  1. Else,\n    1. Return _unfiltered_.","code":"\n        1. Let _jsonString_ be ? ToString(_text_).\n        1. [id=\"step-json-parse-validate\"] Parse StringToCodePoints(_jsonString_) as a JSON text as specified in ECMA-404. Throw a *SyntaxError* exception if it is not a valid JSON text as defined in that specification.\n        1. Let _scriptString_ be the string-concatenation of *\"(\"*, _jsonString_, and *\");\"*.\n        1. [id=\"step-json-parse-parse\"] Let _script_ be ParseText(StringToCodePoints(_scriptString_), |Script|).\n        1. NOTE: The early error rules defined in <emu-xref href=\"#sec-object-initializer-static-semantics-early-errors\"></emu-xref> have special handling for the above invocation of ParseText.\n        1. Assert: _script_ is a Parse Node.\n        1. [id=\"step-json-parse-eval\"] Let _completion_ be Completion(<emu-meta suppress-effects=\"user-code\">Evaluation of _script_</emu-meta>).\n        1. NOTE: The PropertyDefinitionEvaluation semantics defined in <emu-xref href=\"#sec-runtime-semantics-propertydefinitionevaluation\"></emu-xref> have special handling for the above evaluation.\n        1. Let _unfiltered_ be _completion_.[[Value]].\n        1. [id=\"step-json-parse-assert-type\"] Assert: _unfiltered_ is either a String, a Number, a Boolean, an Object that is defined by either an |ArrayLiteral| or an |ObjectLiteral|, or *null*.\n        1. If IsCallable(_reviver_) is *true*, then\n          1. Let _root_ be OrdinaryObjectCreate(%Object.prototype%).\n          1. Let _rootName_ be the empty String.\n          1. Perform ! CreateDataPropertyOrThrow(_root_, _rootName_, _unfiltered_).\n          1. Return ? InternalizeJSONProperty(_root_, _rootName_, _reviver_).\n        1. Else,\n          1. Return _unfiltered_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"InternalizeJSONProperty","params":[{"name":"holder","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"name","ty":"String","kind":{"Normal":{}}},{"name":"reviver","ty":"Record[FunctionObject]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Let _val_ be ? Get(_holder_, _name_).\n  1. If _val_ is a Record[Object], then\n    1. Let _isArray_ be ? IsArray(_val_).\n    1. If _isArray_ is *true*, then\n      1. Let _len_ be ? LengthOfArrayLike(_val_).\n      1. Let _I_ be 0.\n      1. Repeat, while _I_ < _len_,\n        1. Let _prop_ be ! ToString(𝔽(_I_)).\n        1. Let _newElement_ be ? InternalizeJSONProperty(_val_, _prop_, _reviver_).\n        1. If _newElement_ is *undefined*, then\n          1. Perform ? _val_.[[Delete]](_prop_).\n        1. Else,\n          1. Perform ? CreateDataProperty(_val_, _prop_, _newElement_).\n        1. Set _I_ to _I_ + 1.\n    1. Else,\n      1. Let _keys_ be ? EnumerableOwnProperties(_val_, ~key~).\n      1. For each String _P_ of _keys_, do\n        1. Let _newElement_ be ? InternalizeJSONProperty(_val_, _P_, _reviver_).\n        1. If _newElement_ is *undefined*, then\n          1. Perform ? _val_.[[Delete]](_P_).\n        1. Else,\n          1. Perform ? CreateDataProperty(_val_, _P_, _newElement_).\n  1. Return ? Call(_reviver_, _holder_, « _name_, _val_ »).","code":"\n          1. Let _val_ be ? Get(_holder_, _name_).\n          1. If _val_ is an Object, then\n            1. Let _isArray_ be ? IsArray(_val_).\n            1. If _isArray_ is *true*, then\n              1. Let _len_ be ? LengthOfArrayLike(_val_).\n              1. Let _I_ be 0.\n              1. Repeat, while _I_ < _len_,\n                1. Let _prop_ be ! ToString(𝔽(_I_)).\n                1. Let _newElement_ be ? InternalizeJSONProperty(_val_, _prop_, _reviver_).\n                1. If _newElement_ is *undefined*, then\n                  1. Perform ? <emu-meta effects=\"user-code\">_val_.[[Delete]]</emu-meta>(_prop_).\n                1. Else,\n                  1. Perform ? CreateDataProperty(_val_, _prop_, _newElement_).\n                1. Set _I_ to _I_ + 1.\n            1. Else,\n              1. Let _keys_ be ? EnumerableOwnProperties(_val_, ~key~).\n              1. For each String _P_ of _keys_, do\n                1. Let _newElement_ be ? InternalizeJSONProperty(_val_, _P_, _reviver_).\n                1. If _newElement_ is *undefined*, then\n                  1. Perform ? <emu-meta effects=\"user-code\">_val_.[[Delete]]</emu-meta>(_P_).\n                1. Else,\n                  1. Perform ? CreateDataProperty(_val_, _P_, _newElement_).\n          1. Return ? Call(_reviver_, _holder_, « _name_, _val_ »).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"JSON"}},"name":"stringify"}},"params":[{"name":"value","ty":"Unknown","kind":{"Normal":{}}},{"name":"replacer","ty":"Unknown","kind":{"Optional":{}}},{"name":"space","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _stack_ be « ».\n  1. Let _indent_ be *\"\"*.\n  1. Let _PropertyList_ be *undefined*.\n  1. Let _ReplacerFunction_ be *undefined*.\n  1. If _replacer_ is a Record[Object], then\n    1. If IsCallable(_replacer_) is *true*, then\n      1. Set _ReplacerFunction_ to _replacer_.\n    1. Else,\n      1. Let _isArray_ be ? IsArray(_replacer_).\n      1. If _isArray_ is *true*, then\n        1. Set _PropertyList_ to « ».\n        1. Let _len_ be ? LengthOfArrayLike(_replacer_).\n        1. Let _k_ be 0.\n        1. Repeat, while _k_ < _len_,\n          1. Let _prop_ be ! ToString(𝔽(_k_)).\n          1. Let _v_ be ? Get(_replacer_, _prop_).\n          1. Let _item_ be *undefined*.\n          1. If _v_ is a String, then\n            1. Set _item_ to _v_.\n          1. Else if _v_ is a Number, then\n            1. Set _item_ to ! ToString(_v_).\n          1. Else if _v_ is a Record[Object], then\n            1. If _v_ has a [[StringData]] or [[NumberData]] internal slot, set _item_ to ? ToString(_v_).\n          1. If _item_ is not *undefined* and _PropertyList_ does not contain _item_, then\n            1. Append _item_ to _PropertyList_.\n          1. Set _k_ to _k_ + 1.\n  1. If _space_ is a Record[Object], then\n    1. If _space_ has a [[NumberData]] internal slot, then\n      1. Set _space_ to ? ToNumber(_space_).\n    1. Else if _space_ has a [[StringData]] internal slot, then\n      1. Set _space_ to ? ToString(_space_).\n  1. If _space_ is a Number, then\n    1. Let _spaceMV_ be ! ToIntegerOrInfinity(_space_).\n    1. Set _spaceMV_ to min(10, _spaceMV_).\n    1. If _spaceMV_ < 1, let _gap_ be *\"\"*.\n    1. Else, let _gap_ be the String value containing _spaceMV_ occurrences of the code unit 0x0020 (SPACE).\n  1. Else if _space_ is a String, then\n    1. If the length of _space_ ≤ 10, let _gap_ be _space_.\n    1. Else, let _gap_ be the substring of _space_ from 0 to 10.\n  1. Else,\n    1. Let _gap_ be *\"\"*.\n  1. Let _wrapper_ be OrdinaryObjectCreate(%Object.prototype%).\n  1. Perform ! CreateDataPropertyOrThrow(_wrapper_, *\"\"*, _value_).\n  1. Let _state_ be JSON Serialization Record { [[ReplacerFunction]]: _ReplacerFunction_, [[Stack]]: _stack_, [[Indent]]: _indent_, [[Gap]]: _gap_, [[PropertyList]]: _PropertyList_ }.\n  1. Return ? SerializeJSONProperty(_state_, *\"\"*, _wrapper_).","code":"\n        1. Let _stack_ be a new empty List.\n        1. Let _indent_ be the empty String.\n        1. Let _PropertyList_ be *undefined*.\n        1. Let _ReplacerFunction_ be *undefined*.\n        1. If _replacer_ is an Object, then\n          1. If IsCallable(_replacer_) is *true*, then\n            1. Set _ReplacerFunction_ to _replacer_.\n          1. Else,\n            1. Let _isArray_ be ? IsArray(_replacer_).\n            1. If _isArray_ is *true*, then\n              1. Set _PropertyList_ to a new empty List.\n              1. Let _len_ be ? LengthOfArrayLike(_replacer_).\n              1. Let _k_ be 0.\n              1. Repeat, while _k_ < _len_,\n                1. Let _prop_ be ! ToString(𝔽(_k_)).\n                1. Let _v_ be ? Get(_replacer_, _prop_).\n                1. Let _item_ be *undefined*.\n                1. If _v_ is a String, then\n                  1. Set _item_ to _v_.\n                1. Else if _v_ is a Number, then\n                  1. Set _item_ to ! ToString(_v_).\n                1. Else if _v_ is an Object, then\n                  1. If _v_ has a [[StringData]] or [[NumberData]] internal slot, set _item_ to ? ToString(_v_).\n                1. If _item_ is not *undefined* and _PropertyList_ does not contain _item_, then\n                  1. Append _item_ to _PropertyList_.\n                1. Set _k_ to _k_ + 1.\n        1. If _space_ is an Object, then\n          1. If _space_ has a [[NumberData]] internal slot, then\n            1. Set _space_ to ? ToNumber(_space_).\n          1. Else if _space_ has a [[StringData]] internal slot, then\n            1. Set _space_ to ? ToString(_space_).\n        1. If _space_ is a Number, then\n          1. Let _spaceMV_ be ! ToIntegerOrInfinity(_space_).\n          1. Set _spaceMV_ to min(10, _spaceMV_).\n          1. If _spaceMV_ < 1, let _gap_ be the empty String; otherwise let _gap_ be the String value containing _spaceMV_ occurrences of the code unit 0x0020 (SPACE).\n        1. Else if _space_ is a String, then\n          1. If the length of _space_ ≤ 10, let _gap_ be _space_; otherwise let _gap_ be the substring of _space_ from 0 to 10.\n        1. Else,\n          1. Let _gap_ be the empty String.\n        1. Let _wrapper_ be OrdinaryObjectCreate(%Object.prototype%).\n        1. Perform ! CreateDataPropertyOrThrow(_wrapper_, the empty String, _value_).\n        1. Let _state_ be the JSON Serialization Record { [[ReplacerFunction]]: _ReplacerFunction_, [[Stack]]: _stack_, [[Indent]]: _indent_, [[Gap]]: _gap_, [[PropertyList]]: _PropertyList_ }.\n        1. Return ? SerializeJSONProperty(_state_, the empty String, _wrapper_).\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"SerializeJSONProperty","params":[{"name":"state","ty":"Record[JSONSerializationRecord]","kind":{"Normal":{}}},{"name":"key","ty":"String","kind":{"Normal":{}}},{"name":"holder","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Normal[String | Undefined] | Throw"}},"body":"\n  1. Let _value_ be ? Get(_holder_, _key_).\n  1. If _value_ is a Record[Object] or _value_ is a BigInt, then\n    1. Let _toJSON_ be ? GetV(_value_, *\"toJSON\"*).\n    1. If IsCallable(_toJSON_) is *true*, then\n      1. Set _value_ to ? Call(_toJSON_, _value_, « _key_ »).\n  1. If _state_.[[ReplacerFunction]] is not *undefined*, then\n    1. Set _value_ to ? Call(_state_.[[ReplacerFunction]], _holder_, « _key_, _value_ »).\n  1. If _value_ is a Record[Object], then\n    1. If _value_ has a [[NumberData]] internal slot, then\n      1. Set _value_ to ? ToNumber(_value_).\n    1. Else if _value_ has a [[StringData]] internal slot, then\n      1. Set _value_ to ? ToString(_value_).\n    1. Else if _value_ has a [[BooleanData]] internal slot, then\n      1. Set _value_ to _value_.[[BooleanData]].\n    1. Else if _value_ has a [[BigIntData]] internal slot, then\n      1. Set _value_ to _value_.[[BigIntData]].\n  1. If _value_ is *null*, return *\"null\"*.\n  1. If _value_ is *true*, return *\"true\"*.\n  1. If _value_ is *false*, return *\"false\"*.\n  1. If _value_ is a String, return QuoteJSONString(_value_).\n  1. If _value_ is a Number, then\n    1. If _value_ is finite, return ! ToString(_value_).\n    1. Return *\"null\"*.\n  1. If _value_ is a BigInt, throw a *TypeError* exception.\n  1. If _value_ is a Record[Object] and IsCallable(_value_) is *false*, then\n    1. Let _isArray_ be ? IsArray(_value_).\n    1. If _isArray_ is *true*, return ? SerializeJSONArray(_state_, _value_).\n    1. Return ? SerializeJSONObject(_state_, _value_).\n  1. Return *undefined*.","code":"\n          1. Let _value_ be ? Get(_holder_, _key_).\n          1. If _value_ is an Object or _value_ is a BigInt, then\n            1. Let _toJSON_ be ? GetV(_value_, *\"toJSON\"*).\n            1. If IsCallable(_toJSON_) is *true*, then\n              1. Set _value_ to ? Call(_toJSON_, _value_, « _key_ »).\n          1. If _state_.[[ReplacerFunction]] is not *undefined*, then\n            1. Set _value_ to ? Call(_state_.[[ReplacerFunction]], _holder_, « _key_, _value_ »).\n          1. If _value_ is an Object, then\n            1. If _value_ has a [[NumberData]] internal slot, then\n              1. Set _value_ to ? ToNumber(_value_).\n            1. Else if _value_ has a [[StringData]] internal slot, then\n              1. Set _value_ to ? ToString(_value_).\n            1. Else if _value_ has a [[BooleanData]] internal slot, then\n              1. Set _value_ to _value_.[[BooleanData]].\n            1. Else if _value_ has a [[BigIntData]] internal slot, then\n              1. Set _value_ to _value_.[[BigIntData]].\n          1. If _value_ is *null*, return *\"null\"*.\n          1. If _value_ is *true*, return *\"true\"*.\n          1. If _value_ is *false*, return *\"false\"*.\n          1. If _value_ is a String, return QuoteJSONString(_value_).\n          1. If _value_ is a Number, then\n            1. If _value_ is finite, return ! ToString(_value_).\n            1. Return *\"null\"*.\n          1. If _value_ is a BigInt, throw a *TypeError* exception.\n          1. If _value_ is an Object and IsCallable(_value_) is *false*, then\n            1. Let _isArray_ be ? IsArray(_value_).\n            1. If _isArray_ is *true*, return ? SerializeJSONArray(_state_, _value_).\n            1. Return ? SerializeJSONObject(_state_, _value_).\n          1. Return *undefined*.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"QuoteJSONString","params":[{"name":"value","ty":"String","kind":{"Normal":{}}}],"retTy":"String"}},"body":"\n  1. Let _product_ be the String value consisting solely of the code unit 0x0022 (QUOTATION MARK).\n  1. For each code point _C_ of StringToCodePoints(_value_), do\n    1. If _C_ is listed in the “Code Point” column of <emu-xref href=\"#table-json-single-character-escapes\"></emu-xref>, then\n      1. Set _product_ to the string-concatenation of _product_ and the escape sequence for _C_ as specified in the “Escape Sequence” column of the corresponding row.\n    1. Else if _C_ has a numeric value less than 0x0020 (SPACE) or _C_ has the same numeric value as a leading surrogate or trailing surrogate, then\n      1. Let _unit_ be the code unit whose numeric value is the numeric value of _C_.\n      1. Set _product_ to the string-concatenation of _product_ and UnicodeEscape(_unit_).\n    1. Else,\n      1. Set _product_ to the string-concatenation of _product_ and UTF16EncodeCodePoint(_C_).\n  1. Set _product_ to the string-concatenation of _product_ and 0x0022 (QUOTATION MARK).\n  1. Return _product_.","code":"\n          1. Let _product_ be the String value consisting solely of the code unit 0x0022 (QUOTATION MARK).\n          1. For each code point _C_ of StringToCodePoints(_value_), do\n            1. If _C_ is listed in the “Code Point” column of <emu-xref href=\"#table-json-single-character-escapes\"></emu-xref>, then\n              1. Set _product_ to the string-concatenation of _product_ and the escape sequence for _C_ as specified in the “Escape Sequence” column of the corresponding row.\n            1. Else if _C_ has a numeric value less than 0x0020 (SPACE) or _C_ has the same numeric value as a leading surrogate or trailing surrogate, then\n              1. Let _unit_ be the code unit whose numeric value is the numeric value of _C_.\n              1. Set _product_ to the string-concatenation of _product_ and UnicodeEscape(_unit_).\n            1. Else,\n              1. Set _product_ to the string-concatenation of _product_ and UTF16EncodeCodePoint(_C_).\n          1. Set _product_ to the string-concatenation of _product_ and the code unit 0x0022 (QUOTATION MARK).\n          1. Return _product_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"UnicodeEscape","params":[{"name":"C","ty":"Unknown[\"a code unit\"]","kind":{"Normal":{}}}],"retTy":"String"}},"body":"\n  1. Let _n_ be ℝ(_C_).\n  1. Assert: _n_ ≤ 0xffff.\n  1. Let _hex_ be the String representation of _n_, formatted as a lowercase hexadecimal number.\n  1. Return the string-concatenation of 0x005c (REVERSE SOLIDUS), *\"u\"*, and StringPad(_hex_, 4, *\"0\"*, ~start~).","code":"\n          1. Let _n_ be the numeric value of _C_.\n          1. Assert: _n_ ≤ 0xFFFF.\n          1. Let _hex_ be the String representation of _n_, formatted as a lowercase hexadecimal number.\n          1. Return the string-concatenation of the code unit 0x005C (REVERSE SOLIDUS), *\"u\"*, and StringPad(_hex_, 4, *\"0\"*, ~start~).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"SerializeJSONObject","params":[{"name":"state","ty":"Record[JSONSerializationRecord]","kind":{"Normal":{}}},{"name":"value","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Normal[String] | Throw"}},"body":"\n  1. If _state_.[[Stack]] contains _value_, throw a *TypeError* exception because the structure is cyclical.\n  1. Append _value_ to _state_.[[Stack]].\n  1. Let _stepback_ be _state_.[[Indent]].\n  1. Set _state_.[[Indent]] to the string-concatenation of _state_.[[Indent]] and _state_.[[Gap]].\n  1. If _state_.[[PropertyList]] is not *undefined*, then\n    1. Let _K_ be _state_.[[PropertyList]].\n  1. Else,\n    1. Let _K_ be ? EnumerableOwnProperties(_value_, ~key~).\n  1. Let _partial_ be « ».\n  1. For each _P_ of _K_, do\n    1. Let _strP_ be ? SerializeJSONProperty(_state_, _P_, _value_).\n    1. If _strP_ is not *undefined*, then\n      1. Let _member_ be QuoteJSONString(_P_).\n      1. Set _member_ to the string-concatenation of _member_ and *\":\"*.\n      1. If _state_.[[Gap]] is not *\"\"*, then\n        1. Set _member_ to the string-concatenation of _member_ and 0x0020 (SPACE).\n      1. Set _member_ to the string-concatenation of _member_ and _strP_.\n      1. Append _member_ to _partial_.\n  1. If _partial_ is empty, then\n    1. Let _final_ be *\"{}\"*.\n  1. Else,\n    1. If _state_.[[Gap]] is *\"\"*, then\n      1. Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with the code unit 0x002C (COMMA). A comma is not inserted either before the first String or after the last String.\n      1. Let _final_ be the string-concatenation of *\"{\"*, _properties_, and *\"}\"*.\n    1. Else,\n      1. Let _separator_ be the string-concatenation of 0x002c (COMMA), 0x000a (LINE FEED), and _state_.[[Indent]].\n      1. Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with _separator_. The _separator_ String is not inserted either before the first String or after the last String.\n      1. Let _final_ be the string-concatenation of *\"{\"*, 0x000a (LINE FEED), _state_.[[Indent]], _properties_, 0x000a (LINE FEED), _stepback_, and *\"}\"*.\n  1. Remove the last element of _state_.[[Stack]].\n  1. Set _state_.[[Indent]] to _stepback_.\n  1. Return _final_.","code":"\n          1. If _state_.[[Stack]] contains _value_, throw a *TypeError* exception because the structure is cyclical.\n          1. Append _value_ to _state_.[[Stack]].\n          1. Let _stepback_ be _state_.[[Indent]].\n          1. Set _state_.[[Indent]] to the string-concatenation of _state_.[[Indent]] and _state_.[[Gap]].\n          1. If _state_.[[PropertyList]] is not *undefined*, then\n            1. Let _K_ be _state_.[[PropertyList]].\n          1. Else,\n            1. Let _K_ be ? EnumerableOwnProperties(_value_, ~key~).\n          1. Let _partial_ be a new empty List.\n          1. For each element _P_ of _K_, do\n            1. Let _strP_ be ? SerializeJSONProperty(_state_, _P_, _value_).\n            1. If _strP_ is not *undefined*, then\n              1. Let _member_ be QuoteJSONString(_P_).\n              1. Set _member_ to the string-concatenation of _member_ and *\":\"*.\n              1. If _state_.[[Gap]] is not the empty String, then\n                1. Set _member_ to the string-concatenation of _member_ and the code unit 0x0020 (SPACE).\n              1. Set _member_ to the string-concatenation of _member_ and _strP_.\n              1. Append _member_ to _partial_.\n          1. If _partial_ is empty, then\n            1. Let _final_ be *\"{}\"*.\n          1. Else,\n            1. If _state_.[[Gap]] is the empty String, then\n              1. Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with the code unit 0x002C (COMMA). A comma is not inserted either before the first String or after the last String.\n              1. Let _final_ be the string-concatenation of *\"{\"*, _properties_, and *\"}\"*.\n            1. Else,\n              1. Let _separator_ be the string-concatenation of the code unit 0x002C (COMMA), the code unit 0x000A (LINE FEED), and _state_.[[Indent]].\n              1. Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with _separator_. The _separator_ String is not inserted either before the first String or after the last String.\n              1. Let _final_ be the string-concatenation of *\"{\"*, the code unit 0x000A (LINE FEED), _state_.[[Indent]], _properties_, the code unit 0x000A (LINE FEED), _stepback_, and *\"}\"*.\n          1. Remove the last element of _state_.[[Stack]].\n          1. Set _state_.[[Indent]] to _stepback_.\n          1. Return _final_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"SerializeJSONArray","params":[{"name":"state","ty":"Record[JSONSerializationRecord]","kind":{"Normal":{}}},{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[String] | Throw"}},"body":"\n  1. If _state_.[[Stack]] contains _value_, throw a *TypeError* exception because the structure is cyclical.\n  1. Append _value_ to _state_.[[Stack]].\n  1. Let _stepback_ be _state_.[[Indent]].\n  1. Set _state_.[[Indent]] to the string-concatenation of _state_.[[Indent]] and _state_.[[Gap]].\n  1. Let _partial_ be « ».\n  1. Let _len_ be ? LengthOfArrayLike(_value_).\n  1. Let _index_ be 0.\n  1. Repeat, while _index_ < _len_,\n    1. Let _strP_ be ? SerializeJSONProperty(_state_, ! ToString(𝔽(_index_)), _value_).\n    1. If _strP_ is *undefined*, then\n      1. Append *\"null\"* to _partial_.\n    1. Else,\n      1. Append _strP_ to _partial_.\n    1. Set _index_ to _index_ + 1.\n  1. If _partial_ is empty, then\n    1. Let _final_ be *\"[]\"*.\n  1. Else,\n    1. If _state_.[[Gap]] is *\"\"*, then\n      1. Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with the code unit 0x002C (COMMA). A comma is not inserted either before the first String or after the last String.\n      1. Let _final_ be the string-concatenation of *\"[\"*, _properties_, and *\"]\"*.\n    1. Else,\n      1. Let _separator_ be the string-concatenation of 0x002c (COMMA), 0x000a (LINE FEED), and _state_.[[Indent]].\n      1. Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with _separator_. The _separator_ String is not inserted either before the first String or after the last String.\n      1. Let _final_ be the string-concatenation of *\"[\"*, 0x000a (LINE FEED), _state_.[[Indent]], _properties_, 0x000a (LINE FEED), _stepback_, and *\"]\"*.\n  1. Remove the last element of _state_.[[Stack]].\n  1. Set _state_.[[Indent]] to _stepback_.\n  1. Return _final_.","code":"\n          1. If _state_.[[Stack]] contains _value_, throw a *TypeError* exception because the structure is cyclical.\n          1. Append _value_ to _state_.[[Stack]].\n          1. Let _stepback_ be _state_.[[Indent]].\n          1. Set _state_.[[Indent]] to the string-concatenation of _state_.[[Indent]] and _state_.[[Gap]].\n          1. Let _partial_ be a new empty List.\n          1. Let _len_ be ? LengthOfArrayLike(_value_).\n          1. Let _index_ be 0.\n          1. Repeat, while _index_ < _len_,\n            1. Let _strP_ be ? SerializeJSONProperty(_state_, ! ToString(𝔽(_index_)), _value_).\n            1. If _strP_ is *undefined*, then\n              1. Append *\"null\"* to _partial_.\n            1. Else,\n              1. Append _strP_ to _partial_.\n            1. Set _index_ to _index_ + 1.\n          1. If _partial_ is empty, then\n            1. Let _final_ be *\"[]\"*.\n          1. Else,\n            1. If _state_.[[Gap]] is the empty String, then\n              1. Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with the code unit 0x002C (COMMA). A comma is not inserted either before the first String or after the last String.\n              1. Let _final_ be the string-concatenation of *\"[\"*, _properties_, and *\"]\"*.\n            1. Else,\n              1. Let _separator_ be the string-concatenation of the code unit 0x002C (COMMA), the code unit 0x000A (LINE FEED), and _state_.[[Indent]].\n              1. Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with _separator_. The _separator_ String is not inserted either before the first String or after the last String.\n              1. Let _final_ be the string-concatenation of *\"[\"*, the code unit 0x000A (LINE FEED), _state_.[[Indent]], _properties_, the code unit 0x000A (LINE FEED), _stepback_, and *\"]\"*.\n          1. Remove the last element of _state_.[[Stack]].\n          1. Set _state_.[[Indent]] to _stepback_.\n          1. Return _final_.\n        "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"WeakRef"}},"params":[{"name":"target","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If NewTarget is *undefined*, throw a *TypeError* exception.\n  1. If CanBeHeldWeakly(_target_) is *false*, throw a *TypeError* exception.\n  1. Let _weakRef_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%WeakRef.prototype%\"*, « [[WeakRefTarget]] »).\n  1. Perform AddToKeptObjects(_target_).\n  1. Set _weakRef_.[[WeakRefTarget]] to _target_.\n  1. Return _weakRef_.","code":"\n          1. If NewTarget is *undefined*, throw a *TypeError* exception.\n          1. If CanBeHeldWeakly(_target_) is *false*, throw a *TypeError* exception.\n          1. Let _weakRef_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%WeakRef.prototype%\"*, « [[WeakRefTarget]] »).\n          1. Perform AddToKeptObjects(_target_).\n          1. Set _weakRef_.[[WeakRefTarget]] to _target_.\n          1. Return _weakRef_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"WeakRef"}},"name":"prototype"}},"name":"deref"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _weakRef_ be *this* value.\n  1. Perform ? RequireInternalSlot(_weakRef_, [[WeakRefTarget]]).\n  1. Return WeakRefDeref(_weakRef_).","code":"\n          1. Let _weakRef_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_weakRef_, [[WeakRefTarget]]).\n          1. Return WeakRefDeref(_weakRef_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"WeakRefDeref","params":[{"name":"weakRef","ty":"Record[WeakRef]","kind":{"Normal":{}}}],"retTy":"ESValue"}},"body":"\n  1. Let _target_ be _weakRef_.[[WeakRefTarget]].\n  1. If _target_ is not ~empty~, then\n    1. Perform AddToKeptObjects(_target_).\n    1. Return _target_.\n  1. Return *undefined*.","code":"\n          1. Let _target_ be _weakRef_.[[WeakRefTarget]].\n          1. If _target_ is not ~empty~, then\n            1. Perform AddToKeptObjects(_target_).\n            1. Return _target_.\n          1. Return *undefined*.\n        "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"FinalizationRegistry"}},"params":[{"name":"cleanupCallback","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If NewTarget is *undefined*, throw a *TypeError* exception.\n  1. If IsCallable(_cleanupCallback_) is *false*, throw a *TypeError* exception.\n  1. Let _finalizationRegistry_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%FinalizationRegistry.prototype%\"*, « [[Realm]], [[CleanupCallback]], [[Cells]] »).\n  1. Let _fn_ be the active function object.\n  1. Set _finalizationRegistry_.[[Realm]] to _fn_.[[Realm]].\n  1. Set _finalizationRegistry_.[[CleanupCallback]] to HostMakeJobCallback(_cleanupCallback_).\n  1. Set _finalizationRegistry_.[[Cells]] to « ».\n  1. Return _finalizationRegistry_.","code":"\n          1. If NewTarget is *undefined*, throw a *TypeError* exception.\n          1. If IsCallable(_cleanupCallback_) is *false*, throw a *TypeError* exception.\n          1. Let _finalizationRegistry_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%FinalizationRegistry.prototype%\"*, « [[Realm]], [[CleanupCallback]], [[Cells]] »).\n          1. Let _fn_ be the active function object.\n          1. Set _finalizationRegistry_.[[Realm]] to _fn_.[[Realm]].\n          1. Set _finalizationRegistry_.[[CleanupCallback]] to HostMakeJobCallback(_cleanupCallback_).\n          1. Set _finalizationRegistry_.[[Cells]] to a new empty List.\n          1. Return _finalizationRegistry_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"FinalizationRegistry"}},"name":"prototype"}},"name":"register"}},"params":[{"name":"target","ty":"Unknown","kind":{"Normal":{}}},{"name":"heldValue","ty":"Unknown","kind":{"Normal":{}}},{"name":"unregisterToken","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _finalizationRegistry_ be *this* value.\n  1. Perform ? RequireInternalSlot(_finalizationRegistry_, [[Cells]]).\n  1. If CanBeHeldWeakly(_target_) is *false*, throw a *TypeError* exception.\n  1. If SameValue(_target_, _heldValue_) is *true*, throw a *TypeError* exception.\n  1. If CanBeHeldWeakly(_unregisterToken_) is *false*, then\n    1. If _unregisterToken_ is not *undefined*, throw a *TypeError* exception.\n    1. Set _unregisterToken_ to ~empty~.\n  1. Let _cell_ be Record { [[WeakRefTarget]]: _target_, [[HeldValue]]: _heldValue_, [[UnregisterToken]]: _unregisterToken_ }.\n  1. Append _cell_ to _finalizationRegistry_.[[Cells]].\n  1. Return *undefined*.","code":"\n          1. Let _finalizationRegistry_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_finalizationRegistry_, [[Cells]]).\n          1. If CanBeHeldWeakly(_target_) is *false*, throw a *TypeError* exception.\n          1. If SameValue(_target_, _heldValue_) is *true*, throw a *TypeError* exception.\n          1. If CanBeHeldWeakly(_unregisterToken_) is *false*, then\n            1. If _unregisterToken_ is not *undefined*, throw a *TypeError* exception.\n            1. Set _unregisterToken_ to ~empty~.\n          1. Let _cell_ be the Record { [[WeakRefTarget]]: _target_, [[HeldValue]]: _heldValue_, [[UnregisterToken]]: _unregisterToken_ }.\n          1. Append _cell_ to _finalizationRegistry_.[[Cells]].\n          1. Return *undefined*.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"FinalizationRegistry"}},"name":"prototype"}},"name":"unregister"}},"params":[{"name":"unregisterToken","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _finalizationRegistry_ be *this* value.\n  1. Perform ? RequireInternalSlot(_finalizationRegistry_, [[Cells]]).\n  1. If CanBeHeldWeakly(_unregisterToken_) is *false*, throw a *TypeError* exception.\n  1. Let _removed_ be *false*.\n  1. For each Record[{ HeldValue, UnregisterToken, WeakRefTarget }] _cell_ of _finalizationRegistry_.[[Cells]], do\n    1. If _cell_.[[UnregisterToken]] is not ~empty~ and SameValue(_cell_.[[UnregisterToken]], _unregisterToken_) is *true*, then\n      1. Remove _cell_ from _finalizationRegistry_.[[Cells]].\n      1. Set _removed_ to *true*.\n  1. Return _removed_.","code":"\n          1. Let _finalizationRegistry_ be the *this* value.\n          1. Perform ? RequireInternalSlot(_finalizationRegistry_, [[Cells]]).\n          1. If CanBeHeldWeakly(_unregisterToken_) is *false*, throw a *TypeError* exception.\n          1. Let _removed_ be *false*.\n          1. For each Record { [[WeakRefTarget]], [[HeldValue]], [[UnregisterToken]] } _cell_ of _finalizationRegistry_.[[Cells]], do\n            1. If _cell_.[[UnregisterToken]] is not ~empty~ and SameValue(_cell_.[[UnregisterToken]], _unregisterToken_) is *true*, then\n              1. Remove _cell_ from _finalizationRegistry_.[[Cells]].\n              1. Set _removed_ to *true*.\n          1. Return _removed_.\n        "},{"head":{"BuiltinHead":{"path":{"SymbolAccess":{"base":{"Base":{"name":"IteratorPrototype"}},"symbol":"iterator"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Return *this* value.","code":"\n          1. Return the *this* value.\n        "},{"head":{"BuiltinHead":{"path":{"SymbolAccess":{"base":{"Base":{"name":"AsyncIteratorPrototype"}},"symbol":"asyncIterator"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Return *this* value.","code":"\n          1. Return the *this* value.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CreateAsyncFromSyncIterator","params":[{"name":"syncIteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}}],"retTy":"Record[IteratorRecord]"}},"body":"\n  1. Let _asyncIterator_ be OrdinaryObjectCreate(%AsyncFromSyncIteratorPrototype%, « [[SyncIteratorRecord]] »).\n  1. Set _asyncIterator_.[[SyncIteratorRecord]] to _syncIteratorRecord_.\n  1. Let _nextMethod_ be ! Get(_asyncIterator_, *\"next\"*).\n  1. Let _iteratorRecord_ be Iterator Record { [[Iterator]]: _asyncIterator_, [[NextMethod]]: _nextMethod_, [[Done]]: *false* }.\n  1. Return _iteratorRecord_.","code":"\n          1. Let _asyncIterator_ be OrdinaryObjectCreate(%AsyncFromSyncIteratorPrototype%, « [[SyncIteratorRecord]] »).\n          1. Set _asyncIterator_.[[SyncIteratorRecord]] to _syncIteratorRecord_.\n          1. Let _nextMethod_ be ! Get(_asyncIterator_, *\"next\"*).\n          1. Let _iteratorRecord_ be the Iterator Record { [[Iterator]]: _asyncIterator_, [[NextMethod]]: _nextMethod_, [[Done]]: *false* }.\n          1. Return _iteratorRecord_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"AsyncFromSyncIteratorPrototype"}},"name":"next"}},"params":[{"name":"value","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Assert: _O_ is an Object that has a [[SyncIteratorRecord]] internal slot..\n  1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n  1. Let _syncIteratorRecord_ be _O_.[[SyncIteratorRecord]].\n  1. If _value_ is present, then\n    1. Let _result_ be Completion(IteratorNext(_syncIteratorRecord_, _value_)).\n  1. Else,\n    1. Let _result_ be Completion(IteratorNext(_syncIteratorRecord_)).\n  1. Perform IfAbruptRejectPromise(_result_, _promiseCapability_).\n  1. Return AsyncFromSyncIteratorContinuation(_result_, _promiseCapability_).","code":"\n            1. Let _O_ be the *this* value.\n            1. Assert: _O_ is an Object that has a [[SyncIteratorRecord]] internal slot.\n            1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n            1. Let _syncIteratorRecord_ be _O_.[[SyncIteratorRecord]].\n            1. If _value_ is present, then\n              1. Let _result_ be Completion(IteratorNext(_syncIteratorRecord_, _value_)).\n            1. Else,\n              1. Let _result_ be Completion(IteratorNext(_syncIteratorRecord_)).\n            1. IfAbruptRejectPromise(_result_, _promiseCapability_).\n            1. Return AsyncFromSyncIteratorContinuation(_result_, _promiseCapability_).\n          "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"AsyncFromSyncIteratorPrototype"}},"name":"return"}},"params":[{"name":"value","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Assert: _O_ is an Object that has a [[SyncIteratorRecord]] internal slot..\n  1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n  1. Let _syncIterator_ be _O_.[[SyncIteratorRecord]].[[Iterator]].\n  1. Let _return_ be Completion(GetMethod(_syncIterator_, *\"return\"*)).\n  1. Perform IfAbruptRejectPromise(_return_, _promiseCapability_).\n  1. If _return_ is *undefined*, then\n    1. Let _iterResult_ be CreateIterResultObject(_value_, *true*).\n    1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _iterResult_ »).\n    1. Return _promiseCapability_.[[Promise]].\n  1. If _value_ is present, then\n    1. Let _result_ be Completion(Call(_return_, _syncIterator_, « _value_ »)).\n  1. Else,\n    1. Let _result_ be Completion(Call(_return_, _syncIterator_)).\n  1. Perform IfAbruptRejectPromise(_result_, _promiseCapability_).\n  1. If _result_ is not a Record[Object], then\n    1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « a newly created *TypeError* object »).\n    1. Return _promiseCapability_.[[Promise]].\n  1. Return AsyncFromSyncIteratorContinuation(_result_, _promiseCapability_).","code":"\n            1. Let _O_ be the *this* value.\n            1. Assert: _O_ is an Object that has a [[SyncIteratorRecord]] internal slot.\n            1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n            1. Let _syncIterator_ be _O_.[[SyncIteratorRecord]].[[Iterator]].\n            1. Let _return_ be Completion(GetMethod(_syncIterator_, *\"return\"*)).\n            1. IfAbruptRejectPromise(_return_, _promiseCapability_).\n            1. If _return_ is *undefined*, then\n              1. Let _iterResult_ be CreateIterResultObject(_value_, *true*).\n              1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _iterResult_ »).\n              1. Return _promiseCapability_.[[Promise]].\n            1. If _value_ is present, then\n              1. Let _result_ be Completion(Call(_return_, _syncIterator_, « _value_ »)).\n            1. Else,\n              1. Let _result_ be Completion(Call(_return_, _syncIterator_)).\n            1. IfAbruptRejectPromise(_result_, _promiseCapability_).\n            1. If _result_ is not an Object, then\n              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « a newly created *TypeError* object »).\n              1. Return _promiseCapability_.[[Promise]].\n            1. Return AsyncFromSyncIteratorContinuation(_result_, _promiseCapability_).\n          "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"AsyncFromSyncIteratorPrototype"}},"name":"throw"}},"params":[{"name":"value","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _O_ be *this* value.\n  1. Assert: _O_ is an Object that has a [[SyncIteratorRecord]] internal slot..\n  1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n  1. Let _syncIterator_ be _O_.[[SyncIteratorRecord]].[[Iterator]].\n  1. Let _throw_ be Completion(GetMethod(_syncIterator_, *\"throw\"*)).\n  1. Perform IfAbruptRejectPromise(_throw_, _promiseCapability_).\n  1. If _throw_ is *undefined*, then\n    1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _value_ »).\n    1. Return _promiseCapability_.[[Promise]].\n  1. If _value_ is present, then\n    1. Let _result_ be Completion(Call(_throw_, _syncIterator_, « _value_ »)).\n  1. Else,\n    1. Let _result_ be Completion(Call(_throw_, _syncIterator_)).\n  1. Perform IfAbruptRejectPromise(_result_, _promiseCapability_).\n  1. If _result_ is not a Record[Object], then\n    1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « a newly created *TypeError* object »).\n    1. Return _promiseCapability_.[[Promise]].\n  1. Return AsyncFromSyncIteratorContinuation(_result_, _promiseCapability_).","code":"\n            1. Let _O_ be the *this* value.\n            1. Assert: _O_ is an Object that has a [[SyncIteratorRecord]] internal slot.\n            1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n            1. Let _syncIterator_ be _O_.[[SyncIteratorRecord]].[[Iterator]].\n            1. Let _throw_ be Completion(GetMethod(_syncIterator_, *\"throw\"*)).\n            1. IfAbruptRejectPromise(_throw_, _promiseCapability_).\n            1. If _throw_ is *undefined*, then\n              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _value_ »).\n              1. Return _promiseCapability_.[[Promise]].\n            1. If _value_ is present, then\n              1. Let _result_ be Completion(Call(_throw_, _syncIterator_, « _value_ »)).\n            1. Else,\n              1. Let _result_ be Completion(Call(_throw_, _syncIterator_)).\n            1. IfAbruptRejectPromise(_result_, _promiseCapability_).\n            1. If _result_ is not an Object, then\n              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « a newly created *TypeError* object »).\n              1. Return _promiseCapability_.[[Promise]].\n            1. Return AsyncFromSyncIteratorContinuation(_result_, _promiseCapability_).\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AsyncFromSyncIteratorContinuation","params":[{"name":"result","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"promiseCapability","ty":"Unknown[\"a PromiseCapability Record for an intrinsic %Promise%\"]","kind":{"Normal":{}}}],"retTy":"Record[Promise]"}},"body":"\n  1. NOTE: Because _promiseCapability_ is derived from the intrinsic %Promise%, the calls to _promiseCapability_.[[Reject]] entailed by the use IfAbruptRejectPromise below are guaranteed not to throw.\n  1. Let _done_ be Completion(IteratorComplete(_result_)).\n  1. Perform IfAbruptRejectPromise(_done_, _promiseCapability_).\n  1. Let _value_ be Completion(IteratorValue(_result_)).\n  1. Perform IfAbruptRejectPromise(_value_, _promiseCapability_).\n  1. Let _valueWrapper_ be Completion(PromiseResolve(%Promise%, _value_)).\n  1. Perform IfAbruptRejectPromise(_valueWrapper_, _promiseCapability_).\n  1. Let _unwrap_ be a new Abstract Closure with parameters (_v_) that captures _done_ and performs the following steps when called:\n    1. Return CreateIterResultObject(_v_, _done_).\n  1. Let _onFulfilled_ be CreateBuiltinFunction(_unwrap_, 1, *\"\"*, « »).\n  1. NOTE: _onFulfilled_ is used when processing the *\"value\"* property of an IteratorResult object in order to wait for its value if it is a promise and re-package the result in a new \"unwrapped\" IteratorResult object.\n  1. Perform PerformPromiseThen(_valueWrapper_, _onFulfilled_, *undefined*, _promiseCapability_).\n  1. Return _promiseCapability_.[[Promise]].","code":"\n          1. NOTE: Because _promiseCapability_ is derived from the intrinsic %Promise%, the calls to _promiseCapability_.[[Reject]] entailed by the use IfAbruptRejectPromise below are guaranteed not to throw.\n          1. Let _done_ be Completion(IteratorComplete(_result_)).\n          1. IfAbruptRejectPromise(_done_, _promiseCapability_).\n          1. Let _value_ be Completion(IteratorValue(_result_)).\n          1. IfAbruptRejectPromise(_value_, _promiseCapability_).\n          1. Let _valueWrapper_ be Completion(PromiseResolve(%Promise%, _value_)).\n          1. IfAbruptRejectPromise(_valueWrapper_, _promiseCapability_).\n          1. Let _unwrap_ be a new Abstract Closure with parameters (_v_) that captures _done_ and performs the following steps when called:\n            1. Return CreateIterResultObject(_v_, _done_).\n          1. Let _onFulfilled_ be CreateBuiltinFunction(_unwrap_, 1, *\"\"*, « »).\n          1. NOTE: _onFulfilled_ is used when processing the *\"value\"* property of an IteratorResult object in order to wait for its value if it is a promise and re-package the result in a new \"unwrapped\" IteratorResult object.\n          1. Perform PerformPromiseThen(_valueWrapper_, _onFulfilled_, *undefined*, _promiseCapability_).\n          1. Return _promiseCapability_.[[Promise]].\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IfAbruptRejectPromise","params":[{"name":"value","ty":"Unknown","kind":{"Normal":{}}},{"name":"capability","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Assert: _value_ is a Completion.\n  1. If _value_ is an abrupt completion, then\n    1. Perform ? Call(_capability_.[[Reject]], *undefined*, « _value_.[[Value]] »).\n    1. Return _capability_.[[Promise]].\n  1. Else,\n    1. Set _value_ to ! _value_.","code":"\n            1. Assert: _value_ is a Completion Record.\n            1. If _value_ is an abrupt completion, then\n              1. Perform ? Call(_capability_.[[Reject]], *undefined*, « _value_.[[Value]] »).\n              1. Return _capability_.[[Promise]].\n            1. Else,\n              1. Set _value_ to ! _value_.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CreateResolvingFunctions","params":[{"name":"promise","ty":"Record[Promise]","kind":{"Normal":{}}}],"retTy":"Unknown[\"a Record with fields [[Resolve]] (a function object) and [[Reject]] (a function object)\"]"}},"body":"\n  1. Let _alreadyResolved_ be Record { [[Value]]: *false* }.\n  1. Let _stepsResolve_ be the definition specified in <emu-xref href=\"#sec-promise-resolve-functions\"></emu-xref>.\n  1. Let _lengthResolve_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-promise-resolve-functions\"></emu-xref>.\n  1. Let _resolve_ be CreateBuiltinFunction(_stepsResolve_, _lengthResolve_, *\"\"*, « [[Promise]], [[AlreadyResolved]] »).\n  1. Set _resolve_.[[Promise]] to _promise_.\n  1. Set _resolve_.[[AlreadyResolved]] to _alreadyResolved_.\n  1. Let _stepsReject_ be the definition specified in <emu-xref href=\"#sec-promise-reject-functions\"></emu-xref>.\n  1. Let _lengthReject_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-promise-reject-functions\"></emu-xref>.\n  1. Let _reject_ be CreateBuiltinFunction(_stepsReject_, _lengthReject_, *\"\"*, « [[Promise]], [[AlreadyResolved]] »).\n  1. Set _reject_.[[Promise]] to _promise_.\n  1. Set _reject_.[[AlreadyResolved]] to _alreadyResolved_.\n  1. Return Record { [[Resolve]]: _resolve_, [[Reject]]: _reject_ }.","code":"\n          1. Let _alreadyResolved_ be the Record { [[Value]]: *false* }.\n          1. Let _stepsResolve_ be the algorithm steps defined in <emu-xref href=\"#sec-promise-resolve-functions\" title></emu-xref>.\n          1. Let _lengthResolve_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-promise-resolve-functions\" title></emu-xref>.\n          1. Let _resolve_ be CreateBuiltinFunction(_stepsResolve_, _lengthResolve_, *\"\"*, « [[Promise]], [[AlreadyResolved]] »).\n          1. Set _resolve_.[[Promise]] to _promise_.\n          1. Set _resolve_.[[AlreadyResolved]] to _alreadyResolved_.\n          1. Let _stepsReject_ be the algorithm steps defined in <emu-xref href=\"#sec-promise-reject-functions\" title></emu-xref>.\n          1. Let _lengthReject_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-promise-reject-functions\" title></emu-xref>.\n          1. Let _reject_ be CreateBuiltinFunction(_stepsReject_, _lengthReject_, *\"\"*, « [[Promise]], [[AlreadyResolved]] »).\n          1. Set _reject_.[[Promise]] to _promise_.\n          1. Set _reject_.[[AlreadyResolved]] to _alreadyResolved_.\n          1. Return the Record { [[Resolve]]: _resolve_, [[Reject]]: _reject_ }.\n        "},{"head":{"BuiltinHead":{"path":{"YetPath":{"name":"PromiseRejectFunction"}},"params":[{"name":"reason","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _F_ be the active function object.\n  1. Assert: _F_ has a [[Promise]] internal slot whose value is an Object..\n  1. Let _promise_ be _F_.[[Promise]].\n  1. Let _alreadyResolved_ be _F_.[[AlreadyResolved]].\n  1. If _alreadyResolved_.[[Value]] is *true*, return *undefined*.\n  1. Set _alreadyResolved_.[[Value]] to *true*.\n  1. Perform RejectPromise(_promise_, _reason_).\n  1. Return *undefined*.","code":"\n            1. Let _F_ be the active function object.\n            1. Assert: _F_ has a [[Promise]] internal slot whose value is an Object.\n            1. Let _promise_ be _F_.[[Promise]].\n            1. Let _alreadyResolved_ be _F_.[[AlreadyResolved]].\n            1. If _alreadyResolved_.[[Value]] is *true*, return *undefined*.\n            1. Set _alreadyResolved_.[[Value]] to *true*.\n            1. Perform RejectPromise(_promise_, _reason_).\n            1. Return *undefined*.\n          "},{"head":{"BuiltinHead":{"path":{"YetPath":{"name":"PromiseResolveFunction"}},"params":[{"name":"resolution","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _F_ be the active function object.\n  1. Assert: _F_ has a [[Promise]] internal slot whose value is an Object..\n  1. Let _promise_ be _F_.[[Promise]].\n  1. Let _alreadyResolved_ be _F_.[[AlreadyResolved]].\n  1. If _alreadyResolved_.[[Value]] is *true*, return *undefined*.\n  1. Set _alreadyResolved_.[[Value]] to *true*.\n  1. If SameValue(_resolution_, _promise_) is *true*, then\n    1. Let _selfResolutionError_ be a newly created *TypeError* object.\n    1. Perform RejectPromise(_promise_, _selfResolutionError_).\n    1. Return *undefined*.\n  1. If _resolution_ is not a Record[Object], then\n    1. Perform FulfillPromise(_promise_, _resolution_).\n    1. Return *undefined*.\n  1. Let _then_ be Completion(Get(_resolution_, *\"then\"*)).\n  1. If _then_ is an abrupt completion, then\n    1. Perform RejectPromise(_promise_, _then_.[[Value]]).\n    1. Return *undefined*.\n  1. Let _thenAction_ be _then_.[[Value]].\n  1. If IsCallable(_thenAction_) is *false*, then\n    1. Perform FulfillPromise(_promise_, _resolution_).\n    1. Return *undefined*.\n  1. Let _thenJobCallback_ be HostMakeJobCallback(_thenAction_).\n  1. Let _job_ be NewPromiseResolveThenableJob(_promise_, _resolution_, _thenJobCallback_).\n  1. Perform HostEnqueuePromiseJob(_job_.[[Job]], _job_.[[Realm]]).\n  1. Return *undefined*.","code":"\n            1. Let _F_ be the active function object.\n            1. Assert: _F_ has a [[Promise]] internal slot whose value is an Object.\n            1. Let _promise_ be _F_.[[Promise]].\n            1. Let _alreadyResolved_ be _F_.[[AlreadyResolved]].\n            1. If _alreadyResolved_.[[Value]] is *true*, return *undefined*.\n            1. Set _alreadyResolved_.[[Value]] to *true*.\n            1. If SameValue(_resolution_, _promise_) is *true*, then\n              1. Let _selfResolutionError_ be a newly created *TypeError* object.\n              1. Perform RejectPromise(_promise_, _selfResolutionError_).\n              1. Return *undefined*.\n            1. If _resolution_ is not an Object, then\n              1. Perform FulfillPromise(_promise_, _resolution_).\n              1. Return *undefined*.\n            1. Let _then_ be Completion(Get(_resolution_, *\"then\"*)).\n            1. If _then_ is an abrupt completion, then\n              1. Perform RejectPromise(_promise_, _then_.[[Value]]).\n              1. Return *undefined*.\n            1. Let _thenAction_ be _then_.[[Value]].\n            1. If IsCallable(_thenAction_) is *false*, then\n              1. Perform FulfillPromise(_promise_, _resolution_).\n              1. Return *undefined*.\n            1. Let _thenJobCallback_ be HostMakeJobCallback(_thenAction_).\n            1. Let _job_ be NewPromiseResolveThenableJob(_promise_, _resolution_, _thenJobCallback_).\n            1. Perform HostEnqueuePromiseJob(_job_.[[Job]], _job_.[[Realm]]).\n            1. Return *undefined*.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"FulfillPromise","params":[{"name":"promise","ty":"Record[Promise]","kind":{"Normal":{}}},{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Assert: _promise_.[[PromiseState]] is ~pending~.\n  1. Let _reactions_ be _promise_.[[PromiseFulfillReactions]].\n  1. Set _promise_.[[PromiseResult]] to _value_.\n  1. Set _promise_.[[PromiseFulfillReactions]] to *undefined*.\n  1. Set _promise_.[[PromiseRejectReactions]] to *undefined*.\n  1. Set _promise_.[[PromiseState]] to ~fulfilled~.\n  1. Perform TriggerPromiseReactions(_reactions_, _value_).\n  1. Return ~unused~.","code":"\n          1. Assert: The value of _promise_.[[PromiseState]] is ~pending~.\n          1. Let _reactions_ be _promise_.[[PromiseFulfillReactions]].\n          1. Set _promise_.[[PromiseResult]] to _value_.\n          1. Set _promise_.[[PromiseFulfillReactions]] to *undefined*.\n          1. Set _promise_.[[PromiseRejectReactions]] to *undefined*.\n          1. Set _promise_.[[PromiseState]] to ~fulfilled~.\n          1. Perform TriggerPromiseReactions(_reactions_, _value_).\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"NewPromiseCapability","params":[{"name":"C","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[Record[PromiseCapabilityRecord]] | Throw"}},"body":"\n  1. If IsConstructor(_C_) is *false*, throw a *TypeError* exception.\n  1. NOTE: _C_ is assumed to be a constructor function that supports the parameter conventions of the Promise constructor (see <emu-xref href=\"#sec-promise-executor\"></emu-xref>).\n  1. Let _resolvingFunctions_ be Record { [[Resolve]]: *undefined*, [[Reject]]: *undefined* }.\n  1. Let _executorClosure_ be a new Abstract Closure with parameters (_resolve_, _reject_) that captures _resolvingFunctions_ and performs the following steps when called:\n    1. If _resolvingFunctions_.[[Resolve]] is not *undefined*, throw a *TypeError* exception.\n    1. If _resolvingFunctions_.[[Reject]] is not *undefined*, throw a *TypeError* exception.\n    1. Set _resolvingFunctions_.[[Resolve]] to _resolve_.\n    1. Set _resolvingFunctions_.[[Reject]] to _reject_.\n    1. Return *undefined*.\n  1. Let _executor_ be CreateBuiltinFunction(_executorClosure_, 2, *\"\"*, « »).\n  1. Let _promise_ be ? Construct(_C_, « _executor_ »).\n  1. If IsCallable(_resolvingFunctions_.[[Resolve]]) is *false*, throw a *TypeError* exception.\n  1. If IsCallable(_resolvingFunctions_.[[Reject]]) is *false*, throw a *TypeError* exception.\n  1. Return PromiseCapability Record { [[Promise]]: _promise_, [[Resolve]]: _resolvingFunctions_.[[Resolve]], [[Reject]]: _resolvingFunctions_.[[Reject]] }.","code":"\n          1. If IsConstructor(_C_) is *false*, throw a *TypeError* exception.\n          1. NOTE: _C_ is assumed to be a constructor function that supports the parameter conventions of the Promise constructor (see <emu-xref href=\"#sec-promise-executor\"></emu-xref>).\n          1. Let _resolvingFunctions_ be the Record { [[Resolve]]: *undefined*, [[Reject]]: *undefined* }.\n          1. Let _executorClosure_ be a new Abstract Closure with parameters (_resolve_, _reject_) that captures _resolvingFunctions_ and performs the following steps when called:\n            1. If _resolvingFunctions_.[[Resolve]] is not *undefined*, throw a *TypeError* exception.\n            1. If _resolvingFunctions_.[[Reject]] is not *undefined*, throw a *TypeError* exception.\n            1. Set _resolvingFunctions_.[[Resolve]] to _resolve_.\n            1. Set _resolvingFunctions_.[[Reject]] to _reject_.\n            1. Return *undefined*.\n          1. Let _executor_ be CreateBuiltinFunction(_executorClosure_, 2, *\"\"*, « »).\n          1. Let _promise_ be ? Construct(_C_, « _executor_ »).\n          1. If IsCallable(_resolvingFunctions_.[[Resolve]]) is *false*, throw a *TypeError* exception.\n          1. If IsCallable(_resolvingFunctions_.[[Reject]]) is *false*, throw a *TypeError* exception.\n          1. Return the PromiseCapability Record { [[Promise]]: _promise_, [[Resolve]]: _resolvingFunctions_.[[Resolve]], [[Reject]]: _resolvingFunctions_.[[Reject]] }.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"IsPromise","params":[{"name":"x","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Boolean"}},"body":"\n  1. If _x_ is not a Record[Object], return *false*.\n  1. If _x_ does not have a [[PromiseState]] internal slot, return *false*.\n  1. Return *true*.","code":"\n          1. If _x_ is not an Object, return *false*.\n          1. If _x_ does not have a [[PromiseState]] internal slot, return *false*.\n          1. Return *true*.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"RejectPromise","params":[{"name":"promise","ty":"Record[Promise]","kind":{"Normal":{}}},{"name":"reason","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Assert: _promise_.[[PromiseState]] is ~pending~.\n  1. Let _reactions_ be _promise_.[[PromiseRejectReactions]].\n  1. Set _promise_.[[PromiseResult]] to _reason_.\n  1. Set _promise_.[[PromiseFulfillReactions]] to *undefined*.\n  1. Set _promise_.[[PromiseRejectReactions]] to *undefined*.\n  1. Set _promise_.[[PromiseState]] to ~rejected~.\n  1. If _promise_.[[PromiseIsHandled]] is *false*, perform HostPromiseRejectionTracker(_promise_, *\"reject\"*).\n  1. Perform TriggerPromiseReactions(_reactions_, _reason_).\n  1. Return ~unused~.","code":"\n          1. Assert: The value of _promise_.[[PromiseState]] is ~pending~.\n          1. Let _reactions_ be _promise_.[[PromiseRejectReactions]].\n          1. Set _promise_.[[PromiseResult]] to _reason_.\n          1. Set _promise_.[[PromiseFulfillReactions]] to *undefined*.\n          1. Set _promise_.[[PromiseRejectReactions]] to *undefined*.\n          1. Set _promise_.[[PromiseState]] to ~rejected~.\n          1. If _promise_.[[PromiseIsHandled]] is *false*, perform HostPromiseRejectionTracker(_promise_, *\"reject\"*).\n          1. Perform TriggerPromiseReactions(_reactions_, _reason_).\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"TriggerPromiseReactions","params":[{"name":"reactions","ty":"List[Record[PromiseReactionRecord]]","kind":{"Normal":{}}},{"name":"argument","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. For each _reaction_ of _reactions_, do\n    1. Let _job_ be NewPromiseReactionJob(_reaction_, _argument_).\n    1. Perform HostEnqueuePromiseJob(_job_.[[Job]], _job_.[[Realm]]).\n  1. Return ~unused~.","code":"\n          1. For each element _reaction_ of _reactions_, do\n            1. Let _job_ be NewPromiseReactionJob(_reaction_, _argument_).\n            1. Perform HostEnqueuePromiseJob(_job_.[[Job]], _job_.[[Realm]]).\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"NewPromiseReactionJob","params":[{"name":"reaction","ty":"Record[PromiseReactionRecord]","kind":{"Normal":{}}},{"name":"argument","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Unknown[\"a Record with fields [[Job]] (a Job Abstract Closure) and [[Realm]] (a Realm Record or *null*)\"]"}},"body":"\n  1. Let _job_ be a new Abstract Closure with no parameters that captures _reaction_ and _argument_ and performs the following steps when called:\n    1. Let _promiseCapability_ be _reaction_.[[Capability]].\n    1. Let _type_ be _reaction_.[[Type]].\n    1. Let _handler_ be _reaction_.[[Handler]].\n    1. If _handler_ is ~empty~, then\n      1. If _type_ is ~fulfill~, then\n        1. Let _handlerResult_ be NormalCompletion(_argument_).\n      1. Else,\n        1. Assert: _type_ is ~reject~.\n        1. Let _handlerResult_ be ThrowCompletion(_argument_).\n    1. Else,\n      1. Let _handlerResult_ be Completion(HostCallJobCallback(_handler_, *undefined*, « _argument_ »)).\n    1. If _promiseCapability_ is *undefined*, then\n      1. Assert: _handlerResult_ is not an abrupt completion.\n      1. Return ~empty~.\n    1. Assert: _promiseCapability_ is a Record[PromiseCapabilityRecord].\n    1. If _handlerResult_ is an abrupt completion, then\n      1. Return ? Call(_promiseCapability_.[[Reject]], *undefined*, « _handlerResult_.[[Value]] »).\n    1. Else,\n      1. Return ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _handlerResult_.[[Value]] »).\n  1. Let _handlerRealm_ be *null*.\n  1. If _reaction_.[[Handler]] is not ~empty~, then\n    1. Let _getHandlerRealmResult_ be Completion(GetFunctionRealm(_reaction_.[[Handler]].[[Callback]])).\n    1. If _getHandlerRealmResult_ is a normal completion, set _handlerRealm_ to _getHandlerRealmResult_.[[Value]].\n    1. Else, set _handlerRealm_ to the current Realm Record.\n    1. NOTE: _handlerRealm_ is never *null* unless the handler is *undefined*. When the handler is a revoked Proxy and no ECMAScript code runs, _handlerRealm_ is used to create error objects.\n  1. Return Record { [[Job]]: _job_, [[Realm]]: _handlerRealm_ }.","code":"\n          1. Let _job_ be a new Job Abstract Closure with no parameters that captures _reaction_ and _argument_ and performs the following steps when called:\n            1. Let _promiseCapability_ be _reaction_.[[Capability]].\n            1. Let _type_ be _reaction_.[[Type]].\n            1. Let _handler_ be _reaction_.[[Handler]].\n            1. If _handler_ is ~empty~, then\n              1. If _type_ is ~fulfill~, then\n                1. Let _handlerResult_ be NormalCompletion(_argument_).\n              1. Else,\n                1. Assert: _type_ is ~reject~.\n                1. Let _handlerResult_ be ThrowCompletion(_argument_).\n            1. Else,\n              1. Let _handlerResult_ be Completion(HostCallJobCallback(_handler_, *undefined*, « _argument_ »)).\n            1. If _promiseCapability_ is *undefined*, then\n              1. Assert: _handlerResult_ is not an abrupt completion.\n              1. Return ~empty~.\n            1. Assert: _promiseCapability_ is a PromiseCapability Record.\n            1. If _handlerResult_ is an abrupt completion, then\n              1. Return ? Call(_promiseCapability_.[[Reject]], *undefined*, « _handlerResult_.[[Value]] »).\n            1. Else,\n              1. Return ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _handlerResult_.[[Value]] »).\n          1. Let _handlerRealm_ be *null*.\n          1. If _reaction_.[[Handler]] is not ~empty~, then\n            1. Let _getHandlerRealmResult_ be Completion(GetFunctionRealm(_reaction_.[[Handler]].[[Callback]])).\n            1. If _getHandlerRealmResult_ is a normal completion, set _handlerRealm_ to _getHandlerRealmResult_.[[Value]].\n            1. Else, set _handlerRealm_ to the current Realm Record.\n            1. NOTE: _handlerRealm_ is never *null* unless the handler is *undefined*. When the handler is a revoked Proxy and no ECMAScript code runs, _handlerRealm_ is used to create error objects.\n          1. Return the Record { [[Job]]: _job_, [[Realm]]: _handlerRealm_ }.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"NewPromiseResolveThenableJob","params":[{"name":"promiseToResolve","ty":"Record[Promise]","kind":{"Normal":{}}},{"name":"thenable","ty":"Record[Object]","kind":{"Normal":{}}},{"name":"then","ty":"Record[JobCallbackRecord]","kind":{"Normal":{}}}],"retTy":"Unknown[\"a Record with fields [[Job]] (a Job Abstract Closure) and [[Realm]] (a Realm Record)\"]"}},"body":"\n  1. Let _job_ be a new Abstract Closure with no parameters that captures _promiseToResolve_, _thenable_, and _then_ and performs the following steps when called:\n    1. Let _resolvingFunctions_ be CreateResolvingFunctions(_promiseToResolve_).\n    1. Let _thenCallResult_ be Completion(HostCallJobCallback(_then_, _thenable_, « _resolvingFunctions_.[[Resolve]], _resolvingFunctions_.[[Reject]] »)).\n    1. If _thenCallResult_ is an abrupt completion, then\n      1. Return ? Call(_resolvingFunctions_.[[Reject]], *undefined*, « _thenCallResult_.[[Value]] »).\n    1. Return ? _thenCallResult_.\n  1. Let _getThenRealmResult_ be Completion(GetFunctionRealm(_then_.[[Callback]])).\n  1. If _getThenRealmResult_ is a normal completion, let _thenRealm_ be _getThenRealmResult_.[[Value]].\n  1. Else, let _thenRealm_ be the current Realm Record.\n  1. NOTE: _thenRealm_ is never *null*. When _then_.[[Callback]] is a revoked Proxy and no code runs, _thenRealm_ is used to create error objects.\n  1. Return Record { [[Job]]: _job_, [[Realm]]: _thenRealm_ }.","code":"\n          1. Let _job_ be a new Job Abstract Closure with no parameters that captures _promiseToResolve_, _thenable_, and _then_ and performs the following steps when called:\n            1. Let _resolvingFunctions_ be CreateResolvingFunctions(_promiseToResolve_).\n            1. Let _thenCallResult_ be Completion(HostCallJobCallback(_then_, _thenable_, « _resolvingFunctions_.[[Resolve]], _resolvingFunctions_.[[Reject]] »)).\n            1. If _thenCallResult_ is an abrupt completion, then\n              1. Return ? Call(_resolvingFunctions_.[[Reject]], *undefined*, « _thenCallResult_.[[Value]] »).\n            1. Return ? _thenCallResult_.\n          1. Let _getThenRealmResult_ be Completion(GetFunctionRealm(_then_.[[Callback]])).\n          1. If _getThenRealmResult_ is a normal completion, let _thenRealm_ be _getThenRealmResult_.[[Value]].\n          1. Else, let _thenRealm_ be the current Realm Record.\n          1. NOTE: _thenRealm_ is never *null*. When _then_.[[Callback]] is a revoked Proxy and no code runs, _thenRealm_ is used to create error objects.\n          1. Return the Record { [[Job]]: _job_, [[Realm]]: _thenRealm_ }.\n        "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"Promise"}},"params":[{"name":"executor","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If NewTarget is *undefined*, throw a *TypeError* exception.\n  1. If IsCallable(_executor_) is *false*, throw a *TypeError* exception.\n  1. Let _promise_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Promise.prototype%\"*, « [[PromiseState]], [[PromiseResult]], [[PromiseFulfillReactions]], [[PromiseRejectReactions]], [[PromiseIsHandled]] »).\n  1. Set _promise_.[[PromiseState]] to ~pending~.\n  1. Set _promise_.[[PromiseFulfillReactions]] to « ».\n  1. Set _promise_.[[PromiseRejectReactions]] to « ».\n  1. Set _promise_.[[PromiseIsHandled]] to *false*.\n  1. Let _resolvingFunctions_ be CreateResolvingFunctions(_promise_).\n  1. Let _completion_ be Completion(Call(_executor_, *undefined*, « _resolvingFunctions_.[[Resolve]], _resolvingFunctions_.[[Reject]] »)).\n  1. If _completion_ is an abrupt completion, then\n    1. Perform ? Call(_resolvingFunctions_.[[Reject]], *undefined*, « _completion_.[[Value]] »).\n  1. Return _promise_.","code":"\n          1. If NewTarget is *undefined*, throw a *TypeError* exception.\n          1. If IsCallable(_executor_) is *false*, throw a *TypeError* exception.\n          1. Let _promise_ be ? OrdinaryCreateFromConstructor(NewTarget, *\"%Promise.prototype%\"*, « [[PromiseState]], [[PromiseResult]], [[PromiseFulfillReactions]], [[PromiseRejectReactions]], [[PromiseIsHandled]] »).\n          1. Set _promise_.[[PromiseState]] to ~pending~.\n          1. Set _promise_.[[PromiseFulfillReactions]] to a new empty List.\n          1. Set _promise_.[[PromiseRejectReactions]] to a new empty List.\n          1. Set _promise_.[[PromiseIsHandled]] to *false*.\n          1. Let _resolvingFunctions_ be CreateResolvingFunctions(_promise_).\n          1. Let _completion_ be Completion(Call(_executor_, *undefined*, « _resolvingFunctions_.[[Resolve]], _resolvingFunctions_.[[Reject]] »)).\n          1. If _completion_ is an abrupt completion, then\n            1. Perform ? Call(_resolvingFunctions_.[[Reject]], *undefined*, « _completion_.[[Value]] »).\n          1. Return _promise_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Promise"}},"name":"all"}},"params":[{"name":"iterable","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _C_ be *this* value.\n  1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).\n  1. Let _promiseResolve_ be Completion(GetPromiseResolve(_C_)).\n  1. Perform IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_).\n  1. Let _iteratorRecord_ be Completion(GetIterator(_iterable_, ~sync~)).\n  1. Perform IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).\n  1. Let _result_ be Completion(PerformPromiseAll(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_)).\n  1. If _result_ is an abrupt completion, then\n    1. If _iteratorRecord_.[[Done]] is *false*, set _result_ to Completion(IteratorClose(_iteratorRecord_, _result_)).\n    1. Perform IfAbruptRejectPromise(_result_, _promiseCapability_).\n  1. Return ? _result_.","code":"\n          1. Let _C_ be the *this* value.\n          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).\n          1. Let _promiseResolve_ be Completion(GetPromiseResolve(_C_)).\n          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_).\n          1. Let _iteratorRecord_ be Completion(GetIterator(_iterable_, ~sync~)).\n          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).\n          1. Let _result_ be Completion(PerformPromiseAll(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_)).\n          1. If _result_ is an abrupt completion, then\n            1. If _iteratorRecord_.[[Done]] is *false*, set _result_ to Completion(IteratorClose(_iteratorRecord_, _result_)).\n            1. IfAbruptRejectPromise(_result_, _promiseCapability_).\n          1. Return ? _result_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetPromiseResolve","params":[{"name":"promiseConstructor","ty":"Record[Constructor]","kind":{"Normal":{}}}],"retTy":"Normal[Record[FunctionObject]] | Throw"}},"body":"\n  1. Let _promiseResolve_ be ? Get(_promiseConstructor_, *\"resolve\"*).\n  1. If IsCallable(_promiseResolve_) is *false*, throw a *TypeError* exception.\n  1. Return _promiseResolve_.","code":"\n            1. Let _promiseResolve_ be ? Get(_promiseConstructor_, *\"resolve\"*).\n            1. If IsCallable(_promiseResolve_) is *false*, throw a *TypeError* exception.\n            1. Return _promiseResolve_.\n          "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"PerformPromiseAll","params":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}},{"name":"constructor","ty":"Record[Constructor]","kind":{"Normal":{}}},{"name":"resultCapability","ty":"Record[PromiseCapabilityRecord]","kind":{"Normal":{}}},{"name":"promiseResolve","ty":"Record[FunctionObject]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Let _values_ be « ».\n  1. Let _remainingElementsCount_ be Record { [[Value]]: 1 }.\n  1. Let _index_ be 0.\n  1. Repeat, \n    1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n    1. If _next_ is ~done~, then\n      1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.\n      1. If _remainingElementsCount_.[[Value]] = 0, then\n        1. Let _valuesArray_ be CreateArrayFromList(_values_).\n        1. Perform ? Call(_resultCapability_.[[Resolve]], *undefined*, « _valuesArray_ »).\n      1. Return _resultCapability_.[[Promise]].\n    1. Append *undefined* to _values_.\n    1. Let _nextPromise_ be ? Call(_promiseResolve_, _constructor_, « _next_ »).\n    1. Let _steps_ be the definition specified in <emu-xref href=\"#sec-promise.all-resolve-element-functions\"></emu-xref>.\n    1. Let _length_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-promise.all-resolve-element-functions\"></emu-xref>.\n    1. Let _onFulfilled_ be CreateBuiltinFunction(_steps_, _length_, *\"\"*, « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »).\n    1. Set _onFulfilled_.[[AlreadyCalled]] to *false*.\n    1. Set _onFulfilled_.[[Index]] to _index_.\n    1. Set _onFulfilled_.[[Values]] to _values_.\n    1. Set _onFulfilled_.[[Capability]] to _resultCapability_.\n    1. Set _onFulfilled_.[[RemainingElements]] to _remainingElementsCount_.\n    1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] + 1.\n    1. Perform ? Invoke(_nextPromise_, *\"then\"*, « _onFulfilled_, _resultCapability_.[[Reject]] »).\n    1. Set _index_ to _index_ + 1.","code":"\n            1. Let _values_ be a new empty List.\n            1. Let _remainingElementsCount_ be the Record { [[Value]]: 1 }.\n            1. Let _index_ be 0.\n            1. Repeat,\n              1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n              1. If _next_ is ~done~, then\n                1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.\n                1. If _remainingElementsCount_.[[Value]] = 0, then\n                  1. Let _valuesArray_ be CreateArrayFromList(_values_).\n                  1. Perform ? Call(_resultCapability_.[[Resolve]], *undefined*, « _valuesArray_ »).\n                1. Return _resultCapability_.[[Promise]].\n              1. Append *undefined* to _values_.\n              1. Let _nextPromise_ be ? Call(_promiseResolve_, _constructor_, « _next_ »).\n              1. Let _steps_ be the algorithm steps defined in <emu-xref href=\"#sec-promise.all-resolve-element-functions\" title></emu-xref>.\n              1. Let _length_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-promise.all-resolve-element-functions\" title></emu-xref>.\n              1. Let _onFulfilled_ be CreateBuiltinFunction(_steps_, _length_, *\"\"*, « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »).\n              1. Set _onFulfilled_.[[AlreadyCalled]] to *false*.\n              1. Set _onFulfilled_.[[Index]] to _index_.\n              1. Set _onFulfilled_.[[Values]] to _values_.\n              1. Set _onFulfilled_.[[Capability]] to _resultCapability_.\n              1. Set _onFulfilled_.[[RemainingElements]] to _remainingElementsCount_.\n              1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] + 1.\n              1. Perform ? Invoke(_nextPromise_, *\"then\"*, « _onFulfilled_, _resultCapability_.[[Reject]] »).\n              1. Set _index_ to _index_ + 1.\n          "},{"head":{"BuiltinHead":{"path":{"YetPath":{"name":"`Promise.all`ResolveElementFunction"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _F_ be the active function object.\n  1. If _F_.[[AlreadyCalled]] is *true*, return *undefined*.\n  1. Set _F_.[[AlreadyCalled]] to *true*.\n  1. Let _index_ be _F_.[[Index]].\n  1. Let _values_ be _F_.[[Values]].\n  1. Let _promiseCapability_ be _F_.[[Capability]].\n  1. Let _remainingElementsCount_ be _F_.[[RemainingElements]].\n  1. Set _values_[_index_] to _x_.\n  1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.\n  1. If _remainingElementsCount_.[[Value]] = 0, then\n    1. Let _valuesArray_ be CreateArrayFromList(_values_).\n    1. Return ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _valuesArray_ »).\n  1. Return *undefined*.","code":"\n            1. Let _F_ be the active function object.\n            1. If _F_.[[AlreadyCalled]] is *true*, return *undefined*.\n            1. Set _F_.[[AlreadyCalled]] to *true*.\n            1. Let _index_ be _F_.[[Index]].\n            1. Let _values_ be _F_.[[Values]].\n            1. Let _promiseCapability_ be _F_.[[Capability]].\n            1. Let _remainingElementsCount_ be _F_.[[RemainingElements]].\n            1. Set _values_[_index_] to _x_.\n            1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.\n            1. If _remainingElementsCount_.[[Value]] = 0, then\n              1. Let _valuesArray_ be CreateArrayFromList(_values_).\n              1. Return ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _valuesArray_ »).\n            1. Return *undefined*.\n          "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Promise"}},"name":"allSettled"}},"params":[{"name":"iterable","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _C_ be *this* value.\n  1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).\n  1. Let _promiseResolve_ be Completion(GetPromiseResolve(_C_)).\n  1. Perform IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_).\n  1. Let _iteratorRecord_ be Completion(GetIterator(_iterable_, ~sync~)).\n  1. Perform IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).\n  1. Let _result_ be Completion(PerformPromiseAllSettled(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_)).\n  1. If _result_ is an abrupt completion, then\n    1. If _iteratorRecord_.[[Done]] is *false*, set _result_ to Completion(IteratorClose(_iteratorRecord_, _result_)).\n    1. Perform IfAbruptRejectPromise(_result_, _promiseCapability_).\n  1. Return ? _result_.","code":"\n          1. Let _C_ be the *this* value.\n          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).\n          1. Let _promiseResolve_ be Completion(GetPromiseResolve(_C_)).\n          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_).\n          1. Let _iteratorRecord_ be Completion(GetIterator(_iterable_, ~sync~)).\n          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).\n          1. Let _result_ be Completion(PerformPromiseAllSettled(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_)).\n          1. If _result_ is an abrupt completion, then\n            1. If _iteratorRecord_.[[Done]] is *false*, set _result_ to Completion(IteratorClose(_iteratorRecord_, _result_)).\n            1. IfAbruptRejectPromise(_result_, _promiseCapability_).\n          1. Return ? _result_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"PerformPromiseAllSettled","params":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}},{"name":"constructor","ty":"Record[Constructor]","kind":{"Normal":{}}},{"name":"resultCapability","ty":"Record[PromiseCapabilityRecord]","kind":{"Normal":{}}},{"name":"promiseResolve","ty":"Record[FunctionObject]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Let _values_ be « ».\n  1. Let _remainingElementsCount_ be Record { [[Value]]: 1 }.\n  1. Let _index_ be 0.\n  1. Repeat, \n    1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n    1. If _next_ is ~done~, then\n      1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.\n      1. If _remainingElementsCount_.[[Value]] = 0, then\n        1. Let _valuesArray_ be CreateArrayFromList(_values_).\n        1. Perform ? Call(_resultCapability_.[[Resolve]], *undefined*, « _valuesArray_ »).\n      1. Return _resultCapability_.[[Promise]].\n    1. Append *undefined* to _values_.\n    1. Let _nextPromise_ be ? Call(_promiseResolve_, _constructor_, « _next_ »).\n    1. Let _stepsFulfilled_ be the definition specified in <emu-xref href=\"#sec-promise.allsettled-resolve-element-functions\"></emu-xref>.\n    1. Let _lengthFulfilled_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-promise.allsettled-resolve-element-functions\"></emu-xref>.\n    1. Let _onFulfilled_ be CreateBuiltinFunction(_stepsFulfilled_, _lengthFulfilled_, *\"\"*, « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »).\n    1. Let _alreadyCalled_ be Record { [[Value]]: *false* }.\n    1. Set _onFulfilled_.[[AlreadyCalled]] to _alreadyCalled_.\n    1. Set _onFulfilled_.[[Index]] to _index_.\n    1. Set _onFulfilled_.[[Values]] to _values_.\n    1. Set _onFulfilled_.[[Capability]] to _resultCapability_.\n    1. Set _onFulfilled_.[[RemainingElements]] to _remainingElementsCount_.\n    1. Let _stepsRejected_ be the definition specified in <emu-xref href=\"#sec-promise.allsettled-reject-element-functions\"></emu-xref>.\n    1. Let _lengthRejected_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-promise.allsettled-reject-element-functions\"></emu-xref>.\n    1. Let _onRejected_ be CreateBuiltinFunction(_stepsRejected_, _lengthRejected_, *\"\"*, « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »).\n    1. Set _onRejected_.[[AlreadyCalled]] to _alreadyCalled_.\n    1. Set _onRejected_.[[Index]] to _index_.\n    1. Set _onRejected_.[[Values]] to _values_.\n    1. Set _onRejected_.[[Capability]] to _resultCapability_.\n    1. Set _onRejected_.[[RemainingElements]] to _remainingElementsCount_.\n    1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] + 1.\n    1. Perform ? Invoke(_nextPromise_, *\"then\"*, « _onFulfilled_, _onRejected_ »).\n    1. Set _index_ to _index_ + 1.","code":"\n            1. Let _values_ be a new empty List.\n            1. Let _remainingElementsCount_ be the Record { [[Value]]: 1 }.\n            1. Let _index_ be 0.\n            1. Repeat,\n              1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n              1. If _next_ is ~done~, then\n                1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.\n                1. If _remainingElementsCount_.[[Value]] = 0, then\n                  1. Let _valuesArray_ be CreateArrayFromList(_values_).\n                  1. Perform ? Call(_resultCapability_.[[Resolve]], *undefined*, « _valuesArray_ »).\n                1. Return _resultCapability_.[[Promise]].\n              1. Append *undefined* to _values_.\n              1. Let _nextPromise_ be ? Call(_promiseResolve_, _constructor_, « _next_ »).\n              1. Let _stepsFulfilled_ be the algorithm steps defined in <emu-xref href=\"#sec-promise.allsettled-resolve-element-functions\" title></emu-xref>.\n              1. Let _lengthFulfilled_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-promise.allsettled-resolve-element-functions\" title></emu-xref>.\n              1. Let _onFulfilled_ be CreateBuiltinFunction(_stepsFulfilled_, _lengthFulfilled_, *\"\"*, « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »).\n              1. Let _alreadyCalled_ be the Record { [[Value]]: *false* }.\n              1. Set _onFulfilled_.[[AlreadyCalled]] to _alreadyCalled_.\n              1. Set _onFulfilled_.[[Index]] to _index_.\n              1. Set _onFulfilled_.[[Values]] to _values_.\n              1. Set _onFulfilled_.[[Capability]] to _resultCapability_.\n              1. Set _onFulfilled_.[[RemainingElements]] to _remainingElementsCount_.\n              1. Let _stepsRejected_ be the algorithm steps defined in <emu-xref href=\"#sec-promise.allsettled-reject-element-functions\" title></emu-xref>.\n              1. Let _lengthRejected_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-promise.allsettled-reject-element-functions\" title></emu-xref>.\n              1. Let _onRejected_ be CreateBuiltinFunction(_stepsRejected_, _lengthRejected_, *\"\"*, « [[AlreadyCalled]], [[Index]], [[Values]], [[Capability]], [[RemainingElements]] »).\n              1. Set _onRejected_.[[AlreadyCalled]] to _alreadyCalled_.\n              1. Set _onRejected_.[[Index]] to _index_.\n              1. Set _onRejected_.[[Values]] to _values_.\n              1. Set _onRejected_.[[Capability]] to _resultCapability_.\n              1. Set _onRejected_.[[RemainingElements]] to _remainingElementsCount_.\n              1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] + 1.\n              1. Perform ? Invoke(_nextPromise_, *\"then\"*, « _onFulfilled_, _onRejected_ »).\n              1. Set _index_ to _index_ + 1.\n          "},{"head":{"BuiltinHead":{"path":{"YetPath":{"name":"`Promise.allSettled`ResolveElementFunction"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _F_ be the active function object.\n  1. Let _alreadyCalled_ be _F_.[[AlreadyCalled]].\n  1. If _alreadyCalled_.[[Value]] is *true*, return *undefined*.\n  1. Set _alreadyCalled_.[[Value]] to *true*.\n  1. Let _index_ be _F_.[[Index]].\n  1. Let _values_ be _F_.[[Values]].\n  1. Let _promiseCapability_ be _F_.[[Capability]].\n  1. Let _remainingElementsCount_ be _F_.[[RemainingElements]].\n  1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).\n  1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"status\"*, *\"fulfilled\"*).\n  1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"value\"*, _x_).\n  1. Set _values_[_index_] to _obj_.\n  1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.\n  1. If _remainingElementsCount_.[[Value]] = 0, then\n    1. Let _valuesArray_ be CreateArrayFromList(_values_).\n    1. Return ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _valuesArray_ »).\n  1. Return *undefined*.","code":"\n            1. Let _F_ be the active function object.\n            1. Let _alreadyCalled_ be _F_.[[AlreadyCalled]].\n            1. If _alreadyCalled_.[[Value]] is *true*, return *undefined*.\n            1. Set _alreadyCalled_.[[Value]] to *true*.\n            1. Let _index_ be _F_.[[Index]].\n            1. Let _values_ be _F_.[[Values]].\n            1. Let _promiseCapability_ be _F_.[[Capability]].\n            1. Let _remainingElementsCount_ be _F_.[[RemainingElements]].\n            1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).\n            1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"status\"*, *\"fulfilled\"*).\n            1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"value\"*, _x_).\n            1. Set _values_[_index_] to _obj_.\n            1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.\n            1. If _remainingElementsCount_.[[Value]] = 0, then\n              1. Let _valuesArray_ be CreateArrayFromList(_values_).\n              1. Return ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _valuesArray_ »).\n            1. Return *undefined*.\n          "},{"head":{"BuiltinHead":{"path":{"YetPath":{"name":"`Promise.allSettled`RejectElementFunction"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _F_ be the active function object.\n  1. Let _alreadyCalled_ be _F_.[[AlreadyCalled]].\n  1. If _alreadyCalled_.[[Value]] is *true*, return *undefined*.\n  1. Set _alreadyCalled_.[[Value]] to *true*.\n  1. Let _index_ be _F_.[[Index]].\n  1. Let _values_ be _F_.[[Values]].\n  1. Let _promiseCapability_ be _F_.[[Capability]].\n  1. Let _remainingElementsCount_ be _F_.[[RemainingElements]].\n  1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).\n  1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"status\"*, *\"rejected\"*).\n  1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"reason\"*, _x_).\n  1. Set _values_[_index_] to _obj_.\n  1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.\n  1. If _remainingElementsCount_.[[Value]] = 0, then\n    1. Let _valuesArray_ be CreateArrayFromList(_values_).\n    1. Return ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _valuesArray_ »).\n  1. Return *undefined*.","code":"\n            1. Let _F_ be the active function object.\n            1. Let _alreadyCalled_ be _F_.[[AlreadyCalled]].\n            1. If _alreadyCalled_.[[Value]] is *true*, return *undefined*.\n            1. Set _alreadyCalled_.[[Value]] to *true*.\n            1. Let _index_ be _F_.[[Index]].\n            1. Let _values_ be _F_.[[Values]].\n            1. Let _promiseCapability_ be _F_.[[Capability]].\n            1. Let _remainingElementsCount_ be _F_.[[RemainingElements]].\n            1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).\n            1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"status\"*, *\"rejected\"*).\n            1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"reason\"*, _x_).\n            1. Set _values_[_index_] to _obj_.\n            1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.\n            1. If _remainingElementsCount_.[[Value]] = 0, then\n              1. Let _valuesArray_ be CreateArrayFromList(_values_).\n              1. Return ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _valuesArray_ »).\n            1. Return *undefined*.\n          "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Promise"}},"name":"any"}},"params":[{"name":"iterable","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _C_ be *this* value.\n  1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).\n  1. Let _promiseResolve_ be Completion(GetPromiseResolve(_C_)).\n  1. Perform IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_).\n  1. Let _iteratorRecord_ be Completion(GetIterator(_iterable_, ~sync~)).\n  1. Perform IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).\n  1. Let _result_ be Completion(PerformPromiseAny(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_)).\n  1. If _result_ is an abrupt completion, then\n    1. If _iteratorRecord_.[[Done]] is *false*, set _result_ to Completion(IteratorClose(_iteratorRecord_, _result_)).\n    1. Perform IfAbruptRejectPromise(_result_, _promiseCapability_).\n  1. Return ? _result_.","code":"\n          1. Let _C_ be the *this* value.\n          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).\n          1. Let _promiseResolve_ be Completion(GetPromiseResolve(_C_)).\n          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_).\n          1. Let _iteratorRecord_ be Completion(GetIterator(_iterable_, ~sync~)).\n          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).\n          1. Let _result_ be Completion(PerformPromiseAny(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_)).\n          1. If _result_ is an abrupt completion, then\n            1. If _iteratorRecord_.[[Done]] is *false*, set _result_ to Completion(IteratorClose(_iteratorRecord_, _result_)).\n            1. IfAbruptRejectPromise(_result_, _promiseCapability_).\n          1. Return ? _result_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"PerformPromiseAny","params":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}},{"name":"constructor","ty":"Record[Constructor]","kind":{"Normal":{}}},{"name":"resultCapability","ty":"Record[PromiseCapabilityRecord]","kind":{"Normal":{}}},{"name":"promiseResolve","ty":"Record[FunctionObject]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Let _errors_ be « ».\n  1. Let _remainingElementsCount_ be Record { [[Value]]: 1 }.\n  1. Let _index_ be 0.\n  1. Repeat, \n    1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n    1. If _next_ is ~done~, then\n      1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.\n      1. If _remainingElementsCount_.[[Value]] = 0, then\n        1. Let _error_ be a newly created *AggregateError* object.\n        1. Perform ! DefinePropertyOrThrow(_error_, *\"errors\"*, PropertyDescriptor { [[Configurable]]: *true*, [[Enumerable]]: *false*, [[Writable]]: *true*, [[Value]]: CreateArrayFromList(_errors_) }).\n        1. Return ThrowCompletion(_error_).\n      1. Return _resultCapability_.[[Promise]].\n    1. Append *undefined* to _errors_.\n    1. Let _nextPromise_ be ? Call(_promiseResolve_, _constructor_, « _next_ »).\n    1. Let _stepsRejected_ be the definition specified in <emu-xref href=\"#sec-promise.any-reject-element-functions\"></emu-xref>.\n    1. Let _lengthRejected_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-promise.any-reject-element-functions\"></emu-xref>.\n    1. Let _onRejected_ be CreateBuiltinFunction(_stepsRejected_, _lengthRejected_, *\"\"*, « [[AlreadyCalled]], [[Index]], [[Errors]], [[Capability]], [[RemainingElements]] »).\n    1. Set _onRejected_.[[AlreadyCalled]] to *false*.\n    1. Set _onRejected_.[[Index]] to _index_.\n    1. Set _onRejected_.[[Errors]] to _errors_.\n    1. Set _onRejected_.[[Capability]] to _resultCapability_.\n    1. Set _onRejected_.[[RemainingElements]] to _remainingElementsCount_.\n    1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] + 1.\n    1. Perform ? Invoke(_nextPromise_, *\"then\"*, « _resultCapability_.[[Resolve]], _onRejected_ »).\n    1. Set _index_ to _index_ + 1.","code":"\n            1. Let _errors_ be a new empty List.\n            1. Let _remainingElementsCount_ be the Record { [[Value]]: 1 }.\n            1. Let _index_ be 0.\n            1. Repeat,\n              1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n              1. If _next_ is ~done~, then\n                1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.\n                1. If _remainingElementsCount_.[[Value]] = 0, then\n                  1. Let _error_ be a newly created *AggregateError* object.\n                  1. Perform ! DefinePropertyOrThrow(_error_, *\"errors\"*, PropertyDescriptor { [[Configurable]]: *true*, [[Enumerable]]: *false*, [[Writable]]: *true*, [[Value]]: CreateArrayFromList(_errors_) }).\n                  1. Return ThrowCompletion(_error_).\n                1. Return _resultCapability_.[[Promise]].\n              1. Append *undefined* to _errors_.\n              1. Let _nextPromise_ be ? Call(_promiseResolve_, _constructor_, « _next_ »).\n              1. Let _stepsRejected_ be the algorithm steps defined in <emu-xref href=\"#sec-promise.any-reject-element-functions\" title></emu-xref>.\n              1. Let _lengthRejected_ be the number of non-optional parameters of the function definition in <emu-xref href=\"#sec-promise.any-reject-element-functions\" title></emu-xref>.\n              1. Let _onRejected_ be CreateBuiltinFunction(_stepsRejected_, _lengthRejected_, *\"\"*, « [[AlreadyCalled]], [[Index]], [[Errors]], [[Capability]], [[RemainingElements]] »).\n              1. Set _onRejected_.[[AlreadyCalled]] to *false*.\n              1. Set _onRejected_.[[Index]] to _index_.\n              1. Set _onRejected_.[[Errors]] to _errors_.\n              1. Set _onRejected_.[[Capability]] to _resultCapability_.\n              1. Set _onRejected_.[[RemainingElements]] to _remainingElementsCount_.\n              1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] + 1.\n              1. Perform ? Invoke(_nextPromise_, *\"then\"*, « _resultCapability_.[[Resolve]], _onRejected_ »).\n              1. Set _index_ to _index_ + 1.\n          "},{"head":{"BuiltinHead":{"path":{"YetPath":{"name":"`Promise.any`RejectElementFunction"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _F_ be the active function object.\n  1. If _F_.[[AlreadyCalled]] is *true*, return *undefined*.\n  1. Set _F_.[[AlreadyCalled]] to *true*.\n  1. Let _index_ be _F_.[[Index]].\n  1. Let _errors_ be _F_.[[Errors]].\n  1. Let _promiseCapability_ be _F_.[[Capability]].\n  1. Let _remainingElementsCount_ be _F_.[[RemainingElements]].\n  1. Set _errors_[_index_] to _x_.\n  1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.\n  1. If _remainingElementsCount_.[[Value]] = 0, then\n    1. Let _error_ be a newly created *AggregateError* object.\n    1. Perform ! DefinePropertyOrThrow(_error_, *\"errors\"*, PropertyDescriptor { [[Configurable]]: *true*, [[Enumerable]]: *false*, [[Writable]]: *true*, [[Value]]: CreateArrayFromList(_errors_) }).\n    1. Return ? Call(_promiseCapability_.[[Reject]], *undefined*, « _error_ »).\n  1. Return *undefined*.","code":"\n            1. Let _F_ be the active function object.\n            1. If _F_.[[AlreadyCalled]] is *true*, return *undefined*.\n            1. Set _F_.[[AlreadyCalled]] to *true*.\n            1. Let _index_ be _F_.[[Index]].\n            1. Let _errors_ be _F_.[[Errors]].\n            1. Let _promiseCapability_ be _F_.[[Capability]].\n            1. Let _remainingElementsCount_ be _F_.[[RemainingElements]].\n            1. Set _errors_[_index_] to _x_.\n            1. Set _remainingElementsCount_.[[Value]] to _remainingElementsCount_.[[Value]] - 1.\n            1. If _remainingElementsCount_.[[Value]] = 0, then\n              1. Let _error_ be a newly created *AggregateError* object.\n              1. Perform ! DefinePropertyOrThrow(_error_, *\"errors\"*, PropertyDescriptor { [[Configurable]]: *true*, [[Enumerable]]: *false*, [[Writable]]: *true*, [[Value]]: CreateArrayFromList(_errors_) }).\n              1. Return ? Call(_promiseCapability_.[[Reject]], *undefined*, « _error_ »).\n            1. Return *undefined*.\n          "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Promise"}},"name":"race"}},"params":[{"name":"iterable","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _C_ be *this* value.\n  1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).\n  1. Let _promiseResolve_ be Completion(GetPromiseResolve(_C_)).\n  1. Perform IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_).\n  1. Let _iteratorRecord_ be Completion(GetIterator(_iterable_, ~sync~)).\n  1. Perform IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).\n  1. Let _result_ be Completion(PerformPromiseRace(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_)).\n  1. If _result_ is an abrupt completion, then\n    1. If _iteratorRecord_.[[Done]] is *false*, set _result_ to Completion(IteratorClose(_iteratorRecord_, _result_)).\n    1. Perform IfAbruptRejectPromise(_result_, _promiseCapability_).\n  1. Return ? _result_.","code":"\n          1. Let _C_ be the *this* value.\n          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).\n          1. Let _promiseResolve_ be Completion(GetPromiseResolve(_C_)).\n          1. IfAbruptRejectPromise(_promiseResolve_, _promiseCapability_).\n          1. Let _iteratorRecord_ be Completion(GetIterator(_iterable_, ~sync~)).\n          1. IfAbruptRejectPromise(_iteratorRecord_, _promiseCapability_).\n          1. Let _result_ be Completion(PerformPromiseRace(_iteratorRecord_, _C_, _promiseCapability_, _promiseResolve_)).\n          1. If _result_ is an abrupt completion, then\n            1. If _iteratorRecord_.[[Done]] is *false*, set _result_ to Completion(IteratorClose(_iteratorRecord_, _result_)).\n            1. IfAbruptRejectPromise(_result_, _promiseCapability_).\n          1. Return ? _result_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"PerformPromiseRace","params":[{"name":"iteratorRecord","ty":"Record[IteratorRecord]","kind":{"Normal":{}}},{"name":"constructor","ty":"Record[Constructor]","kind":{"Normal":{}}},{"name":"resultCapability","ty":"Record[PromiseCapabilityRecord]","kind":{"Normal":{}}},{"name":"promiseResolve","ty":"Record[FunctionObject]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Repeat, \n    1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n    1. If _next_ is ~done~, then\n      1. Return _resultCapability_.[[Promise]].\n    1. Let _nextPromise_ be ? Call(_promiseResolve_, _constructor_, « _next_ »).\n    1. Perform ? Invoke(_nextPromise_, *\"then\"*, « _resultCapability_.[[Resolve]], _resultCapability_.[[Reject]] »).","code":"\n            1. Repeat,\n              1. Let _next_ be ? IteratorStepValue(_iteratorRecord_).\n              1. If _next_ is ~done~, then\n                1. Return _resultCapability_.[[Promise]].\n              1. Let _nextPromise_ be ? Call(_promiseResolve_, _constructor_, « _next_ »).\n              1. Perform ? Invoke(_nextPromise_, *\"then\"*, « _resultCapability_.[[Resolve]], _resultCapability_.[[Reject]] »).\n          "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Promise"}},"name":"reject"}},"params":[{"name":"r","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _C_ be *this* value.\n  1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).\n  1. Perform ? Call(_promiseCapability_.[[Reject]], *undefined*, « _r_ »).\n  1. Return _promiseCapability_.[[Promise]].","code":"\n          1. Let _C_ be the *this* value.\n          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).\n          1. Perform ? Call(_promiseCapability_.[[Reject]], *undefined*, « _r_ »).\n          1. Return _promiseCapability_.[[Promise]].\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Promise"}},"name":"resolve"}},"params":[{"name":"x","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _C_ be *this* value.\n  1. If _C_ is not a Record[Object], throw a *TypeError* exception.\n  1. Return ? PromiseResolve(_C_, _x_).","code":"\n          1. Let _C_ be the *this* value.\n          1. If _C_ is not an Object, throw a *TypeError* exception.\n          1. Return ? PromiseResolve(_C_, _x_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"PromiseResolve","params":[{"name":"C","ty":"Record[Constructor]","kind":{"Normal":{}}},{"name":"x","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. If IsPromise(_x_) is *true*, then\n    1. Let _xConstructor_ be ? Get(_x_, *\"constructor\"*).\n    1. If SameValue(_xConstructor_, _C_) is *true*, return _x_.\n  1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).\n  1. Perform ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _x_ »).\n  1. Return _promiseCapability_.[[Promise]].","code":"\n            1. If IsPromise(_x_) is *true*, then\n              1. Let _xConstructor_ be ? Get(_x_, *\"constructor\"*).\n              1. If SameValue(_xConstructor_, _C_) is *true*, return _x_.\n            1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).\n            1. Perform ? Call(_promiseCapability_.[[Resolve]], *undefined*, « _x_ »).\n            1. Return _promiseCapability_.[[Promise]].\n          "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Promise"}},"name":"withResolvers"}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Let _C_ be *this* value.\n  1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).\n  1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).\n  1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"promise\"*, _promiseCapability_.[[Promise]]).\n  1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"resolve\"*, _promiseCapability_.[[Resolve]]).\n  1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"reject\"*, _promiseCapability_.[[Reject]]).\n  1. Return _obj_.","code":"\n          1. Let _C_ be the *this* value.\n          1. Let _promiseCapability_ be ? NewPromiseCapability(_C_).\n          1. Let _obj_ be OrdinaryObjectCreate(%Object.prototype%).\n          1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"promise\"*, _promiseCapability_.[[Promise]]).\n          1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"resolve\"*, _promiseCapability_.[[Resolve]]).\n          1. Perform ! CreateDataPropertyOrThrow(_obj_, *\"reject\"*, _promiseCapability_.[[Reject]]).\n          1. Return _obj_.\n        "},{"head":{"BuiltinHead":{"path":{"Getter":{"base":{"SymbolAccess":{"base":{"Base":{"name":"Promise"}},"symbol":"species"}}}},"params":[],"retTy":"Unknown"}},"body":"\n  1. Return *this* value.","code":"\n          1. Return the *this* value.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Promise"}},"name":"prototype"}},"name":"catch"}},"params":[{"name":"onRejected","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _promise_ be *this* value.\n  1. Return ? Invoke(_promise_, *\"then\"*, « *undefined*, _onRejected_ »).","code":"\n          1. Let _promise_ be the *this* value.\n          1. Return ? Invoke(_promise_, *\"then\"*, « *undefined*, _onRejected_ »).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Promise"}},"name":"prototype"}},"name":"finally"}},"params":[{"name":"onFinally","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _promise_ be *this* value.\n  1. If _promise_ is not a Record[Object], throw a *TypeError* exception.\n  1. Let _C_ be ? SpeciesConstructor(_promise_, %Promise%).\n  1. Assert: IsConstructor(_C_) is *true*.\n  1. If IsCallable(_onFinally_) is *false*, then\n    1. Let _thenFinally_ be _onFinally_.\n    1. Let _catchFinally_ be _onFinally_.\n  1. Else,\n    1. Let _thenFinallyClosure_ be a new Abstract Closure with parameters (_value_) that captures _onFinally_ and _C_ and performs the following steps when called:\n      1. Let _result_ be ? Call(_onFinally_, *undefined*).\n      1. Let _p_ be ? PromiseResolve(_C_, _result_).\n      1. Let _returnValue_ be a new Abstract Closure with no parameters that captures _value_ and performs the following steps when called:\n        1. Return _value_.\n      1. Let _valueThunk_ be CreateBuiltinFunction(_returnValue_, 0, *\"\"*, « »).\n      1. Return ? Invoke(_p_, *\"then\"*, « _valueThunk_ »).\n    1. Let _thenFinally_ be CreateBuiltinFunction(_thenFinallyClosure_, 1, *\"\"*, « »).\n    1. Let _catchFinallyClosure_ be a new Abstract Closure with parameters (_reason_) that captures _onFinally_ and _C_ and performs the following steps when called:\n      1. Let _result_ be ? Call(_onFinally_, *undefined*).\n      1. Let _p_ be ? PromiseResolve(_C_, _result_).\n      1. Let _throwReason_ be a new Abstract Closure with no parameters that captures _reason_ and performs the following steps when called:\n        1. Return ThrowCompletion(_reason_).\n      1. Let _thrower_ be CreateBuiltinFunction(_throwReason_, 0, *\"\"*, « »).\n      1. Return ? Invoke(_p_, *\"then\"*, « _thrower_ »).\n    1. Let _catchFinally_ be CreateBuiltinFunction(_catchFinallyClosure_, 1, *\"\"*, « »).\n  1. Return ? Invoke(_promise_, *\"then\"*, « _thenFinally_, _catchFinally_ »).","code":"\n          1. Let _promise_ be the *this* value.\n          1. If _promise_ is not an Object, throw a *TypeError* exception.\n          1. Let _C_ be ? SpeciesConstructor(_promise_, %Promise%).\n          1. Assert: IsConstructor(_C_) is *true*.\n          1. If IsCallable(_onFinally_) is *false*, then\n            1. Let _thenFinally_ be _onFinally_.\n            1. Let _catchFinally_ be _onFinally_.\n          1. Else,\n            1. Let _thenFinallyClosure_ be a new Abstract Closure with parameters (_value_) that captures _onFinally_ and _C_ and performs the following steps when called:\n              1. Let _result_ be ? Call(_onFinally_, *undefined*).\n              1. Let _p_ be ? PromiseResolve(_C_, _result_).\n              1. Let _returnValue_ be a new Abstract Closure with no parameters that captures _value_ and performs the following steps when called:\n                1. Return _value_.\n              1. Let _valueThunk_ be CreateBuiltinFunction(_returnValue_, 0, *\"\"*, « »).\n              1. Return ? Invoke(_p_, *\"then\"*, « _valueThunk_ »).\n            1. Let _thenFinally_ be CreateBuiltinFunction(_thenFinallyClosure_, 1, *\"\"*, « »).\n            1. Let _catchFinallyClosure_ be a new Abstract Closure with parameters (_reason_) that captures _onFinally_ and _C_ and performs the following steps when called:\n              1. Let _result_ be ? Call(_onFinally_, *undefined*).\n              1. Let _p_ be ? PromiseResolve(_C_, _result_).\n              1. Let _throwReason_ be a new Abstract Closure with no parameters that captures _reason_ and performs the following steps when called:\n                1. Return ThrowCompletion(_reason_).\n              1. Let _thrower_ be CreateBuiltinFunction(_throwReason_, 0, *\"\"*, « »).\n              1. Return ? Invoke(_p_, *\"then\"*, « _thrower_ »).\n            1. Let _catchFinally_ be CreateBuiltinFunction(_catchFinallyClosure_, 1, *\"\"*, « »).\n          1. Return ? Invoke(_promise_, *\"then\"*, « _thenFinally_, _catchFinally_ »).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Promise"}},"name":"prototype"}},"name":"then"}},"params":[{"name":"onFulfilled","ty":"Unknown","kind":{"Normal":{}}},{"name":"onRejected","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _promise_ be *this* value.\n  1. If IsPromise(_promise_) is *false*, throw a *TypeError* exception.\n  1. Let _C_ be ? SpeciesConstructor(_promise_, %Promise%).\n  1. Let _resultCapability_ be ? NewPromiseCapability(_C_).\n  1. Return PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_, _resultCapability_).","code":"\n          1. Let _promise_ be the *this* value.\n          1. If IsPromise(_promise_) is *false*, throw a *TypeError* exception.\n          1. Let _C_ be ? SpeciesConstructor(_promise_, %Promise%).\n          1. Let _resultCapability_ be ? NewPromiseCapability(_C_).\n          1. Return PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_, _resultCapability_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"PerformPromiseThen","params":[{"name":"promise","ty":"Record[Promise]","kind":{"Normal":{}}},{"name":"onFulfilled","ty":"ESValue","kind":{"Normal":{}}},{"name":"onRejected","ty":"ESValue","kind":{"Normal":{}}},{"name":"resultCapability","ty":"Record[PromiseCapabilityRecord]","kind":{"Optional":{}}}],"retTy":"ESValue"}},"body":"\n  1. Assert: IsPromise(_promise_) is *true*.\n  1. If _resultCapability_ is not present, then\n    1. Set _resultCapability_ to *undefined*.\n  1. If IsCallable(_onFulfilled_) is *false*, then\n    1. Let _onFulfilledJobCallback_ be ~empty~.\n  1. Else,\n    1. Let _onFulfilledJobCallback_ be HostMakeJobCallback(_onFulfilled_).\n  1. If IsCallable(_onRejected_) is *false*, then\n    1. Let _onRejectedJobCallback_ be ~empty~.\n  1. Else,\n    1. Let _onRejectedJobCallback_ be HostMakeJobCallback(_onRejected_).\n  1. Let _fulfillReaction_ be PromiseReaction Record { [[Capability]]: _resultCapability_, [[Type]]: ~fulfill~, [[Handler]]: _onFulfilledJobCallback_ }.\n  1. Let _rejectReaction_ be PromiseReaction Record { [[Capability]]: _resultCapability_, [[Type]]: ~reject~, [[Handler]]: _onRejectedJobCallback_ }.\n  1. If _promise_.[[PromiseState]] is ~pending~, then\n    1. Append _fulfillReaction_ to _promise_.[[PromiseFulfillReactions]].\n    1. Append _rejectReaction_ to _promise_.[[PromiseRejectReactions]].\n  1. Else if _promise_.[[PromiseState]] is ~fulfilled~, then\n    1. Let _value_ be _promise_.[[PromiseResult]].\n    1. Let _fulfillJob_ be NewPromiseReactionJob(_fulfillReaction_, _value_).\n    1. Perform HostEnqueuePromiseJob(_fulfillJob_.[[Job]], _fulfillJob_.[[Realm]]).\n  1. Else,\n    1. Assert: _promise_.[[PromiseState]] is ~rejected~.\n    1. Let _reason_ be _promise_.[[PromiseResult]].\n    1. If _promise_.[[PromiseIsHandled]] is *false*, perform HostPromiseRejectionTracker(_promise_, *\"handle\"*).\n    1. Let _rejectJob_ be NewPromiseReactionJob(_rejectReaction_, _reason_).\n    1. Perform HostEnqueuePromiseJob(_rejectJob_.[[Job]], _rejectJob_.[[Realm]]).\n  1. Set _promise_.[[PromiseIsHandled]] to *true*.\n  1. If _resultCapability_ is *undefined*, then\n    1. Return *undefined*.\n  1. Else,\n    1. Return _resultCapability_.[[Promise]].","code":"\n            1. Assert: IsPromise(_promise_) is *true*.\n            1. If _resultCapability_ is not present, then\n              1. Set _resultCapability_ to *undefined*.\n            1. If IsCallable(_onFulfilled_) is *false*, then\n              1. Let _onFulfilledJobCallback_ be ~empty~.\n            1. Else,\n              1. Let _onFulfilledJobCallback_ be HostMakeJobCallback(_onFulfilled_).\n            1. If IsCallable(_onRejected_) is *false*, then\n              1. Let _onRejectedJobCallback_ be ~empty~.\n            1. Else,\n              1. Let _onRejectedJobCallback_ be HostMakeJobCallback(_onRejected_).\n            1. Let _fulfillReaction_ be the PromiseReaction Record { [[Capability]]: _resultCapability_, [[Type]]: ~fulfill~, [[Handler]]: _onFulfilledJobCallback_ }.\n            1. Let _rejectReaction_ be the PromiseReaction Record { [[Capability]]: _resultCapability_, [[Type]]: ~reject~, [[Handler]]: _onRejectedJobCallback_ }.\n            1. If _promise_.[[PromiseState]] is ~pending~, then\n              1. Append _fulfillReaction_ to _promise_.[[PromiseFulfillReactions]].\n              1. Append _rejectReaction_ to _promise_.[[PromiseRejectReactions]].\n            1. Else if _promise_.[[PromiseState]] is ~fulfilled~, then\n              1. Let _value_ be _promise_.[[PromiseResult]].\n              1. Let _fulfillJob_ be NewPromiseReactionJob(_fulfillReaction_, _value_).\n              1. Perform HostEnqueuePromiseJob(_fulfillJob_.[[Job]], _fulfillJob_.[[Realm]]).\n            1. Else,\n              1. Assert: The value of _promise_.[[PromiseState]] is ~rejected~.\n              1. Let _reason_ be _promise_.[[PromiseResult]].\n              1. If _promise_.[[PromiseIsHandled]] is *false*, perform HostPromiseRejectionTracker(_promise_, *\"handle\"*).\n              1. Let _rejectJob_ be NewPromiseReactionJob(_rejectReaction_, _reason_).\n              1. Perform HostEnqueuePromiseJob(_rejectJob_.[[Job]], _rejectJob_.[[Realm]]).\n            1. Set _promise_.[[PromiseIsHandled]] to *true*.\n            1. If _resultCapability_ is *undefined*, then\n              1. Return *undefined*.\n            1. Else,\n              1. Return _resultCapability_.[[Promise]].\n          "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"GeneratorFunction"}},"params":[{"name":"parameterArgs","ty":"Unknown","kind":{"Variadic":{}}},{"name":"bodyArg","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _C_ be the active function object.\n  1. If _bodyArg_ is not present, set _bodyArg_ to *\"\"*.\n  1. Return ? CreateDynamicFunction(_C_, NewTarget, ~generator~, _parameterArgs_, _bodyArg_).","code":"\n          1. Let _C_ be the active function object.\n          1. If _bodyArg_ is not present, set _bodyArg_ to the empty String.\n          1. Return ? CreateDynamicFunction(_C_, NewTarget, ~generator~, _parameterArgs_, _bodyArg_).\n        "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"AsyncGeneratorFunction"}},"params":[{"name":"parameterArgs","ty":"Unknown","kind":{"Variadic":{}}},{"name":"bodyArg","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _C_ be the active function object.\n  1. If _bodyArg_ is not present, set _bodyArg_ to *\"\"*.\n  1. Return ? CreateDynamicFunction(_C_, NewTarget, ~async-generator~, _parameterArgs_, _bodyArg_).","code":"\n          1. Let _C_ be the active function object.\n          1. If _bodyArg_ is not present, set _bodyArg_ to the empty String.\n          1. Return ? CreateDynamicFunction(_C_, NewTarget, ~async-generator~, _parameterArgs_, _bodyArg_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Generator"}},"name":"prototype"}},"name":"next"}},"params":[{"name":"value","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Return ? GeneratorResume(*this* value, _value_, ~empty~).","code":"\n          1. Return ? GeneratorResume(*this* value, _value_, ~empty~).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Generator"}},"name":"prototype"}},"name":"return"}},"params":[{"name":"value","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _g_ be *this* value.\n  1. Let _C_ be Completion Record { [[Type]]: ~return~, [[Value]]: _value_, [[Target]]: ~empty~ }.\n  1. Return ? GeneratorResumeAbrupt(_g_, _C_, ~empty~).","code":"\n          1. Let _g_ be the *this* value.\n          1. Let _C_ be Completion Record { [[Type]]: ~return~, [[Value]]: _value_, [[Target]]: ~empty~ }.\n          1. Return ? GeneratorResumeAbrupt(_g_, _C_, ~empty~).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"Generator"}},"name":"prototype"}},"name":"throw"}},"params":[{"name":"exception","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _g_ be *this* value.\n  1. Let _C_ be ThrowCompletion(_exception_).\n  1. Return ? GeneratorResumeAbrupt(_g_, _C_, ~empty~).","code":"\n          1. Let _g_ be the *this* value.\n          1. Let _C_ be ThrowCompletion(_exception_).\n          1. Return ? GeneratorResumeAbrupt(_g_, _C_, ~empty~).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GeneratorStart","params":[{"name":"generator","ty":"Record[Generator]","kind":{"Normal":{}}},{"name":"generatorBody","ty":"Unknown[\"a |FunctionBody| Parse Node or an Abstract Closure with no parameters\"]","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Assert: _generator_.[[GeneratorState]] is *undefined*.\n  1. Let _genContext_ be the running execution context.\n  1. Set _genContext_.Generator to _generator_.\n  1. Let _closure_ be a new Abstract Closure with no parameters that captures _generatorBody_ and performs the following steps when called:\n    1. Let _acGenContext_ be the running execution context.\n    1. Let _acGenerator_ be _acGenContext_.Generator.\n    1. If _generatorBody_ is a Ast, then\n      1. Let _result_ be Completion(the result of evaluating _generatorBody_).\n    1. Else,\n      1. Assert: _generatorBody_ is a Clo.\n      1. Let _result_ be _generatorBody_().\n    1. Assert: If we return here, the generator either threw an exception or performed either an implicit or explicit return..\n    1. Remove _acGenContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n    1. Set _acGenerator_.[[GeneratorState]] to ~completed~.\n    1. NOTE: Once a generator enters the ~completed~ state it never leaves it and its associated execution context is never resumed. Any execution state associated with _acGenerator_ can be discarded at this point.\n    1. If _result_ is a normal completion, then\n      1. Let _resultValue_ be *undefined*.\n    1. Else if _result_ is a return completion, then\n      1. Let _resultValue_ be _result_.[[Value]].\n    1. Else,\n      1. Assert: _result_ is a throw completion.\n      1. Return ? _result_.\n    1. Return CreateIterResultObject(_resultValue_, *true*).\n  1. Set the code evaluation state of _genContext_ such that when evaluation is resumed for that execution context the following steps will be performed:return _closure_().\n  1. Set _generator_.[[GeneratorContext]] to _genContext_.\n  1. Set _generator_.[[GeneratorState]] to ~suspended-start~.\n  1. Return ~unused~.","code":"\n          1. Assert: The value of _generator_.[[GeneratorState]] is *undefined*.\n          1. Let _genContext_ be the running execution context.\n          1. Set the Generator component of _genContext_ to _generator_.\n          1. Let _closure_ be a new Abstract Closure with no parameters that captures _generatorBody_ and performs the following steps when called:\n            1. Let _acGenContext_ be the running execution context.\n            1. Let _acGenerator_ be the Generator component of _acGenContext_.\n            1. If _generatorBody_ is a Parse Node, then\n              1. Let _result_ be Completion(Evaluation of _generatorBody_).\n            1. Else,\n              1. Assert: _generatorBody_ is an Abstract Closure with no parameters.\n              1. Let _result_ be _generatorBody_().\n            1. Assert: If we return here, the generator either threw an exception or performed either an implicit or explicit return.\n            1. Remove _acGenContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n            1. Set _acGenerator_.[[GeneratorState]] to ~completed~.\n            1. NOTE: Once a generator enters the ~completed~ state it never leaves it and its associated execution context is never resumed. Any execution state associated with _acGenerator_ can be discarded at this point.\n            1. If _result_ is a normal completion, then\n              1. Let _resultValue_ be *undefined*.\n            1. Else if _result_ is a return completion, then\n              1. Let _resultValue_ be _result_.[[Value]].\n            1. Else,\n              1. Assert: _result_ is a throw completion.\n              1. Return ? _result_.\n            1. Return CreateIterResultObject(_resultValue_, *true*).\n          1. Set the code evaluation state of _genContext_ such that when evaluation is resumed for that execution context, _closure_ will be called with no arguments.\n          1. Set _generator_.[[GeneratorContext]] to _genContext_.\n          1. Set _generator_.[[GeneratorState]] to ~suspended-start~.\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GeneratorValidate","params":[{"name":"generator","ty":"ESValue","kind":{"Normal":{}}},{"name":"generatorBrand","ty":"Enum[~empty~] | String","kind":{"Normal":{}}}],"retTy":"Unknown[\"either a normal completion containing one of ~suspended-start~, ~suspended-yield~, or ~completed~, or a throw completion\"]"}},"body":"\n  1. Perform ? RequireInternalSlot(_generator_, [[GeneratorState]]).\n  1. Perform ? RequireInternalSlot(_generator_, [[GeneratorBrand]]).\n  1. If _generator_.[[GeneratorBrand]] is not _generatorBrand_, throw a *TypeError* exception.\n  1. Assert: _generator_ has a [[GeneratorContext]] internal slot.\n  1. Let _state_ be _generator_.[[GeneratorState]].\n  1. If _state_ is ~executing~, throw a *TypeError* exception.\n  1. Return _state_.","code":"\n          1. Perform ? RequireInternalSlot(_generator_, [[GeneratorState]]).\n          1. Perform ? RequireInternalSlot(_generator_, [[GeneratorBrand]]).\n          1. If _generator_.[[GeneratorBrand]] is not _generatorBrand_, throw a *TypeError* exception.\n          1. Assert: _generator_ also has a [[GeneratorContext]] internal slot.\n          1. Let _state_ be _generator_.[[GeneratorState]].\n          1. If _state_ is ~executing~, throw a *TypeError* exception.\n          1. Return _state_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GeneratorResume","params":[{"name":"generator","ty":"ESValue","kind":{"Normal":{}}},{"name":"value","ty":"ESValue | Enum[~empty~]","kind":{"Normal":{}}},{"name":"generatorBrand","ty":"Enum[~empty~] | String","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Let _state_ be ? GeneratorValidate(_generator_, _generatorBrand_).\n  1. If _state_ is ~completed~, return CreateIterResultObject(*undefined*, *true*).\n  1. Assert: _state_ is either ~suspended-start~ or ~suspended-yield~.\n  1. Let _genContext_ be _generator_.[[GeneratorContext]].\n  1. Let _methodContext_ be the running execution context.\n  1. Suspend _methodContext_.\n  1. Set _generator_.[[GeneratorState]] to ~executing~.\n  1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.\n  1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _genContext_</emu-meta> using NormalCompletion(_value_) as the result of the operation that suspended it. Let _result_ be the value returned by the resumed computation.\n  1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _methodContext_ is the currently running execution context..\n  1. Return ? _result_.","code":"\n          1. Let _state_ be ? GeneratorValidate(_generator_, _generatorBrand_).\n          1. If _state_ is ~completed~, return CreateIterResultObject(*undefined*, *true*).\n          1. Assert: _state_ is either ~suspended-start~ or ~suspended-yield~.\n          1. Let _genContext_ be _generator_.[[GeneratorContext]].\n          1. Let _methodContext_ be the running execution context.\n          1. Suspend _methodContext_.\n          1. Set _generator_.[[GeneratorState]] to ~executing~.\n          1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.\n          1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _genContext_</emu-meta> using NormalCompletion(_value_) as the result of the operation that suspended it. Let _result_ be the value returned by the resumed computation.\n          1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _methodContext_ is the currently running execution context.\n          1. Return ? _result_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GeneratorResumeAbrupt","params":[{"name":"generator","ty":"ESValue","kind":{"Normal":{}}},{"name":"abruptCompletion","ty":"Return | Throw","kind":{"Normal":{}}},{"name":"generatorBrand","ty":"Enum[~empty~] | String","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Throw"}},"body":"\n  1. Let _state_ be ? GeneratorValidate(_generator_, _generatorBrand_).\n  1. If _state_ is ~suspended-start~, then\n    1. Set _generator_.[[GeneratorState]] to ~completed~.\n    1. NOTE: Once a generator enters the ~completed~ state it never leaves it and its associated execution context is never resumed. Any execution state associated with _generator_ can be discarded at this point.\n    1. Set _state_ to ~completed~.\n  1. If _state_ is ~completed~, then\n    1. If _abruptCompletion_ is a return completion, then\n      1. Return CreateIterResultObject(_abruptCompletion_.[[Value]], *true*).\n    1. Return ? _abruptCompletion_.\n  1. Assert: _state_ is ~suspended-yield~.\n  1. Let _genContext_ be _generator_.[[GeneratorContext]].\n  1. Let _methodContext_ be the running execution context.\n  1. Suspend _methodContext_.\n  1. Set _generator_.[[GeneratorState]] to ~executing~.\n  1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.\n  1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _genContext_</emu-meta> using _abruptCompletion_ as the result of the operation that suspended it. Let _result_ be the value returned by the resumed computation.\n  1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _methodContext_ is the currently running execution context..\n  1. Return ? _result_.","code":"\n          1. Let _state_ be ? GeneratorValidate(_generator_, _generatorBrand_).\n          1. If _state_ is ~suspended-start~, then\n            1. Set _generator_.[[GeneratorState]] to ~completed~.\n            1. NOTE: Once a generator enters the ~completed~ state it never leaves it and its associated execution context is never resumed. Any execution state associated with _generator_ can be discarded at this point.\n            1. Set _state_ to ~completed~.\n          1. If _state_ is ~completed~, then\n            1. If _abruptCompletion_ is a return completion, then\n              1. Return CreateIterResultObject(_abruptCompletion_.[[Value]], *true*).\n            1. Return ? _abruptCompletion_.\n          1. Assert: _state_ is ~suspended-yield~.\n          1. Let _genContext_ be _generator_.[[GeneratorContext]].\n          1. Let _methodContext_ be the running execution context.\n          1. Suspend _methodContext_.\n          1. Set _generator_.[[GeneratorState]] to ~executing~.\n          1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.\n          1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _genContext_</emu-meta> using _abruptCompletion_ as the result of the operation that suspended it. Let _result_ be the Completion Record returned by the resumed computation.\n          1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _methodContext_ is the currently running execution context.\n          1. Return ? _result_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GetGeneratorKind","params":[],"retTy":"Enum[~async~, ~non-generator~, ~sync~]"}},"body":"\n  1. Let _genContext_ be the running execution context.\n  1. If _genContext_ does not have a Generator component, return ~non-generator~.\n  1. Let _generator_ be _genContext_.Generator.\n  1. If _generator_ has a [[AsyncGeneratorState]] internal slot, return ~async~.\n  1. Else, return ~sync~.","code":"\n          1. Let _genContext_ be the running execution context.\n          1. If _genContext_ does not have a Generator component, return ~non-generator~.\n          1. Let _generator_ be the Generator component of _genContext_.\n          1. If _generator_ has an [[AsyncGeneratorState]] internal slot, return ~async~.\n          1. Else, return ~sync~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"GeneratorYield","params":[{"name":"iterNextObj","ty":"Unknown[\"an Object that conforms to the <i>IteratorResult</i> interface\"]","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _genContext_ be the running execution context.\n  1. Assert: _genContext_ is the execution context of a generator..\n  1. Let _generator_ be _genContext_.Generator.\n  1. Assert: GetGeneratorKind() is ~sync~.\n  1. Set _generator_.[[GeneratorState]] to ~suspended-yield~.\n  1. Remove _genContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n  1. Let _callerContext_ be the running execution context.\n  1. Resume _callerContext_ passing NormalCompletion(_iterNextObj_). If _genContext_ is ever resumed again, let _resumptionValue_ be the Completion Record with which it is resumed.\n  1. Assert: If control reaches here, then _genContext_ is the running execution context again..\n  1. Return _resumptionValue_.","code":"\n          1. Let _genContext_ be the running execution context.\n          1. Assert: _genContext_ is the execution context of a generator.\n          1. Let _generator_ be the value of the Generator component of _genContext_.\n          1. Assert: GetGeneratorKind() is ~sync~.\n          1. Set _generator_.[[GeneratorState]] to ~suspended-yield~.\n          1. Remove _genContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n          1. Let _callerContext_ be the running execution context.\n          1. Resume _callerContext_ passing NormalCompletion(_iterNextObj_). If _genContext_ is ever resumed again, let _resumptionValue_ be the Completion Record with which it is resumed.\n          1. Assert: If control reaches here, then _genContext_ is the running execution context again.\n          1. Return _resumptionValue_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"Yield","params":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _generatorKind_ be GetGeneratorKind().\n  1. If _generatorKind_ is ~async~, return ? AsyncGeneratorYield(? Await(_value_)).\n  1. Else, return ? GeneratorYield(CreateIterResultObject(_value_, *false*)).","code":"\n          1. Let _generatorKind_ be GetGeneratorKind().\n          1. If _generatorKind_ is ~async~, return ? AsyncGeneratorYield(? Await(_value_)).\n          1. Otherwise, return ? GeneratorYield(CreateIterResultObject(_value_, *false*)).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CreateIteratorFromClosure","params":[{"name":"closure","ty":"Clo","kind":{"Normal":{}}},{"name":"generatorBrand","ty":"Enum[~empty~] | String","kind":{"Normal":{}}},{"name":"generatorPrototype","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Record[Generator]"}},"body":"\n  1. NOTE: _closure_ can contain uses of the Yield operation to yield an IteratorResult object.\n  1. Let _internalSlotsList_ be « [[GeneratorState]], [[GeneratorContext]], [[GeneratorBrand]] ».\n  1. Let _generator_ be OrdinaryObjectCreate(_generatorPrototype_, _internalSlotsList_).\n  1. Set _generator_.[[GeneratorBrand]] to _generatorBrand_.\n  1. Set _generator_.[[GeneratorState]] to *undefined*.\n  1. Let _callerContext_ be the running execution context.\n  1. Let _calleeContext_ be ExecutionContext { }.\n  1. Set _calleeContext_.Function to *null*.\n  1. Set _calleeContext_.Realm to the current Realm Record.\n  1. Set _calleeContext_.ScriptOrModule to _callerContext_.ScriptOrModule.\n  1. If _callerContext_ is not already suspended, suspend _callerContext_.\n  1. Push _calleeContext_ onto the execution context stack; _calleeContext_ is now the running execution context.\n  1. Perform GeneratorStart(_generator_, _closure_).\n  1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.\n  1. Return _generator_.","code":"\n          1. NOTE: _closure_ can contain uses of the Yield operation to yield an IteratorResult object.\n          1. Let _internalSlotsList_ be « [[GeneratorState]], [[GeneratorContext]], [[GeneratorBrand]] ».\n          1. Let _generator_ be OrdinaryObjectCreate(_generatorPrototype_, _internalSlotsList_).\n          1. Set _generator_.[[GeneratorBrand]] to _generatorBrand_.\n          1. Set _generator_.[[GeneratorState]] to *undefined*.\n          1. Let _callerContext_ be the running execution context.\n          1. Let _calleeContext_ be a new execution context.\n          1. Set the Function of _calleeContext_ to *null*.\n          1. Set the Realm of _calleeContext_ to the current Realm Record.\n          1. Set the ScriptOrModule of _calleeContext_ to _callerContext_'s ScriptOrModule.\n          1. If _callerContext_ is not already suspended, suspend _callerContext_.\n          1. Push _calleeContext_ onto the execution context stack; _calleeContext_ is now the running execution context.\n          1. Perform GeneratorStart(_generator_, _closure_).\n          1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.\n          1. Return _generator_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"AsyncGenerator"}},"name":"prototype"}},"name":"next"}},"params":[{"name":"value","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _generator_ be *this* value.\n  1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n  1. Let _result_ be Completion(AsyncGeneratorValidate(_generator_, ~empty~)).\n  1. Perform IfAbruptRejectPromise(_result_, _promiseCapability_).\n  1. Let _state_ be _generator_.[[AsyncGeneratorState]].\n  1. If _state_ is ~completed~, then\n    1. Let _iteratorResult_ be CreateIterResultObject(*undefined*, *true*).\n    1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _iteratorResult_ »).\n    1. Return _promiseCapability_.[[Promise]].\n  1. Let _completion_ be NormalCompletion(_value_).\n  1. Perform AsyncGeneratorEnqueue(_generator_, _completion_, _promiseCapability_).\n  1. If _state_ is either ~suspended-start~ or ~suspended-yield~, then\n    1. Perform AsyncGeneratorResume(_generator_, _completion_).\n  1. Else,\n    1. Assert: _state_ is either ~executing~ or ~awaiting-return~.\n  1. Return _promiseCapability_.[[Promise]].","code":"\n          1. Let _generator_ be the *this* value.\n          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n          1. Let _result_ be Completion(AsyncGeneratorValidate(_generator_, ~empty~)).\n          1. IfAbruptRejectPromise(_result_, _promiseCapability_).\n          1. Let _state_ be _generator_.[[AsyncGeneratorState]].\n          1. If _state_ is ~completed~, then\n            1. Let _iteratorResult_ be CreateIterResultObject(*undefined*, *true*).\n            1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _iteratorResult_ »).\n            1. Return _promiseCapability_.[[Promise]].\n          1. Let _completion_ be NormalCompletion(_value_).\n          1. Perform AsyncGeneratorEnqueue(_generator_, _completion_, _promiseCapability_).\n          1. If _state_ is either ~suspended-start~ or ~suspended-yield~, then\n            1. Perform AsyncGeneratorResume(_generator_, _completion_).\n          1. Else,\n            1. Assert: _state_ is either ~executing~ or ~awaiting-return~.\n          1. Return _promiseCapability_.[[Promise]].\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"AsyncGenerator"}},"name":"prototype"}},"name":"return"}},"params":[{"name":"value","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _generator_ be *this* value.\n  1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n  1. Let _result_ be Completion(AsyncGeneratorValidate(_generator_, ~empty~)).\n  1. Perform IfAbruptRejectPromise(_result_, _promiseCapability_).\n  1. Let _completion_ be Completion Record { [[Type]]: ~return~, [[Value]]: _value_, [[Target]]: ~empty~ }.\n  1. Perform AsyncGeneratorEnqueue(_generator_, _completion_, _promiseCapability_).\n  1. Let _state_ be _generator_.[[AsyncGeneratorState]].\n  1. If _state_ is either ~suspended-start~ or ~completed~, then\n    1. Set _generator_.[[AsyncGeneratorState]] to ~awaiting-return~.\n    1. Perform ! AsyncGeneratorAwaitReturn(_generator_).\n  1. Else if _state_ is ~suspended-yield~, then\n    1. Perform AsyncGeneratorResume(_generator_, _completion_).\n  1. Else,\n    1. Assert: _state_ is either ~executing~ or ~awaiting-return~.\n  1. Return _promiseCapability_.[[Promise]].","code":"\n          1. Let _generator_ be the *this* value.\n          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n          1. Let _result_ be Completion(AsyncGeneratorValidate(_generator_, ~empty~)).\n          1. IfAbruptRejectPromise(_result_, _promiseCapability_).\n          1. Let _completion_ be Completion Record { [[Type]]: ~return~, [[Value]]: _value_, [[Target]]: ~empty~ }.\n          1. Perform AsyncGeneratorEnqueue(_generator_, _completion_, _promiseCapability_).\n          1. Let _state_ be _generator_.[[AsyncGeneratorState]].\n          1. If _state_ is either ~suspended-start~ or ~completed~, then\n            1. Set _generator_.[[AsyncGeneratorState]] to ~awaiting-return~.\n            1. Perform ! AsyncGeneratorAwaitReturn(_generator_).\n          1. Else if _state_ is ~suspended-yield~, then\n            1. Perform AsyncGeneratorResume(_generator_, _completion_).\n          1. Else,\n            1. Assert: _state_ is either ~executing~ or ~awaiting-return~.\n          1. Return _promiseCapability_.[[Promise]].\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"NormalAccess":{"base":{"Base":{"name":"AsyncGenerator"}},"name":"prototype"}},"name":"throw"}},"params":[{"name":"exception","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _generator_ be *this* value.\n  1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n  1. Let _result_ be Completion(AsyncGeneratorValidate(_generator_, ~empty~)).\n  1. Perform IfAbruptRejectPromise(_result_, _promiseCapability_).\n  1. Let _state_ be _generator_.[[AsyncGeneratorState]].\n  1. If _state_ is ~suspended-start~, then\n    1. Set _generator_.[[AsyncGeneratorState]] to ~completed~.\n    1. Set _state_ to ~completed~.\n  1. If _state_ is ~completed~, then\n    1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _exception_ »).\n    1. Return _promiseCapability_.[[Promise]].\n  1. Let _completion_ be ThrowCompletion(_exception_).\n  1. Perform AsyncGeneratorEnqueue(_generator_, _completion_, _promiseCapability_).\n  1. If _state_ is ~suspended-yield~, then\n    1. Perform AsyncGeneratorResume(_generator_, _completion_).\n  1. Else,\n    1. Assert: _state_ is either ~executing~ or ~awaiting-return~.\n  1. Return _promiseCapability_.[[Promise]].","code":"\n          1. Let _generator_ be the *this* value.\n          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).\n          1. Let _result_ be Completion(AsyncGeneratorValidate(_generator_, ~empty~)).\n          1. IfAbruptRejectPromise(_result_, _promiseCapability_).\n          1. Let _state_ be _generator_.[[AsyncGeneratorState]].\n          1. If _state_ is ~suspended-start~, then\n            1. Set _generator_.[[AsyncGeneratorState]] to ~completed~.\n            1. Set _state_ to ~completed~.\n          1. If _state_ is ~completed~, then\n            1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _exception_ »).\n            1. Return _promiseCapability_.[[Promise]].\n          1. Let _completion_ be ThrowCompletion(_exception_).\n          1. Perform AsyncGeneratorEnqueue(_generator_, _completion_, _promiseCapability_).\n          1. If _state_ is ~suspended-yield~, then\n            1. Perform AsyncGeneratorResume(_generator_, _completion_).\n          1. Else,\n            1. Assert: _state_ is either ~executing~ or ~awaiting-return~.\n          1. Return _promiseCapability_.[[Promise]].\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AsyncGeneratorStart","params":[{"name":"generator","ty":"Record[AsyncGenerator]","kind":{"Normal":{}}},{"name":"generatorBody","ty":"Unknown[\"a |FunctionBody| Parse Node or an Abstract Closure with no parameters\"]","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Assert: _generator_.[[AsyncGeneratorState]] is *undefined*.\n  1. Let _genContext_ be the running execution context.\n  1. Set _genContext_.Generator to _generator_.\n  1. Let _closure_ be a new Abstract Closure with no parameters that captures _generatorBody_ and performs the following steps when called:\n    1. Let _acGenContext_ be the running execution context.\n    1. Let _acGenerator_ be _acGenContext_.Generator.\n    1. If _generatorBody_ is a Ast, then\n      1. Let _result_ be Completion(the result of evaluating _generatorBody_).\n    1. Else,\n      1. Assert: _generatorBody_ is a Clo.\n      1. Let _result_ be Completion(_generatorBody_()).\n    1. Assert: If we return here, the async generator either threw an exception or performed either an implicit or explicit return..\n    1. Remove _acGenContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n    1. Set _acGenerator_.[[AsyncGeneratorState]] to ~completed~.\n    1. If _result_ is a normal completion, set _result_ to NormalCompletion(*undefined*).\n    1. If _result_ is a return completion, set _result_ to NormalCompletion(_result_.[[Value]]).\n    1. Perform AsyncGeneratorCompleteStep(_acGenerator_, _result_, *true*).\n    1. Perform AsyncGeneratorDrainQueue(_acGenerator_).\n    1. Return *undefined*.\n  1. Set the code evaluation state of _genContext_ such that when evaluation is resumed for that execution context the following steps will be performed:return _closure_().\n  1. Set _generator_.[[AsyncGeneratorContext]] to _genContext_.\n  1. Set _generator_.[[AsyncGeneratorState]] to ~suspended-start~.\n  1. Set _generator_.[[AsyncGeneratorQueue]] to « ».\n  1. Return ~unused~.","code":"\n          1. Assert: _generator_.[[AsyncGeneratorState]] is *undefined*.\n          1. Let _genContext_ be the running execution context.\n          1. Set the Generator component of _genContext_ to _generator_.\n          1. Let _closure_ be a new Abstract Closure with no parameters that captures _generatorBody_ and performs the following steps when called:\n            1. Let _acGenContext_ be the running execution context.\n            1. Let _acGenerator_ be the Generator component of _acGenContext_.\n            1. If _generatorBody_ is a Parse Node, then\n              1. Let _result_ be Completion(Evaluation of _generatorBody_).\n            1. Else,\n              1. Assert: _generatorBody_ is an Abstract Closure with no parameters.\n              1. Let _result_ be Completion(_generatorBody_()).\n            1. Assert: If we return here, the async generator either threw an exception or performed either an implicit or explicit return.\n            1. Remove _acGenContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n            1. Set _acGenerator_.[[AsyncGeneratorState]] to ~completed~.\n            1. If _result_ is a normal completion, set _result_ to NormalCompletion(*undefined*).\n            1. If _result_ is a return completion, set _result_ to NormalCompletion(_result_.[[Value]]).\n            1. Perform AsyncGeneratorCompleteStep(_acGenerator_, _result_, *true*).\n            1. Perform AsyncGeneratorDrainQueue(_acGenerator_).\n            1. Return *undefined*.\n          1. Set the code evaluation state of _genContext_ such that when evaluation is resumed for that execution context, _closure_ will be called with no arguments.\n          1. Set _generator_.[[AsyncGeneratorContext]] to _genContext_.\n          1. Set _generator_.[[AsyncGeneratorState]] to ~suspended-start~.\n          1. Set _generator_.[[AsyncGeneratorQueue]] to a new empty List.\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AsyncGeneratorValidate","params":[{"name":"generator","ty":"ESValue","kind":{"Normal":{}}},{"name":"generatorBrand","ty":"Enum[~empty~] | String","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Perform ? RequireInternalSlot(_generator_, [[AsyncGeneratorContext]]).\n  1. Perform ? RequireInternalSlot(_generator_, [[AsyncGeneratorState]]).\n  1. Perform ? RequireInternalSlot(_generator_, [[AsyncGeneratorQueue]]).\n  1. If _generator_.[[GeneratorBrand]] is not _generatorBrand_, throw a *TypeError* exception.\n  1. Return ~unused~.","code":"\n          1. Perform ? RequireInternalSlot(_generator_, [[AsyncGeneratorContext]]).\n          1. Perform ? RequireInternalSlot(_generator_, [[AsyncGeneratorState]]).\n          1. Perform ? RequireInternalSlot(_generator_, [[AsyncGeneratorQueue]]).\n          1. If _generator_.[[GeneratorBrand]] is not _generatorBrand_, throw a *TypeError* exception.\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AsyncGeneratorEnqueue","params":[{"name":"generator","ty":"Record[AsyncGenerator]","kind":{"Normal":{}}},{"name":"completion","ty":"Completion","kind":{"Normal":{}}},{"name":"promiseCapability","ty":"Record[PromiseCapabilityRecord]","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Let _request_ be AsyncGeneratorRequest { [[Completion]]: _completion_, [[Capability]]: _promiseCapability_ }.\n  1. Append _request_ to _generator_.[[AsyncGeneratorQueue]].\n  1. Return ~unused~.","code":"\n          1. Let _request_ be AsyncGeneratorRequest { [[Completion]]: _completion_, [[Capability]]: _promiseCapability_ }.\n          1. Append _request_ to _generator_.[[AsyncGeneratorQueue]].\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AsyncGeneratorCompleteStep","params":[{"name":"generator","ty":"Record[AsyncGenerator]","kind":{"Normal":{}}},{"name":"completion","ty":"Completion","kind":{"Normal":{}}},{"name":"done","ty":"Boolean","kind":{"Normal":{}}},{"name":"realm","ty":"Record[RealmRecord]","kind":{"Optional":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Assert: _generator_.[[AsyncGeneratorQueue]] is not empty.\n  1. Let _next_ be _generator_.[[AsyncGeneratorQueue]][0].\n  1. Remove the first element from _generator_.[[AsyncGeneratorQueue]].\n  1. Let _promiseCapability_ be _next_.[[Capability]].\n  1. Let _value_ be _completion_.[[Value]].\n  1. If _completion_ is a throw completion, then\n    1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _value_ »).\n  1. Else,\n    1. Assert: _completion_ is a normal completion.\n    1. If _realm_ is present, then\n      1. Let _oldRealm_ be the running execution context.Realm.\n      1. Set the running execution context.Realm to _realm_.\n      1. Let _iteratorResult_ be CreateIterResultObject(_value_, _done_).\n      1. Set the running execution context.Realm to _oldRealm_.\n    1. Else,\n      1. Let _iteratorResult_ be CreateIterResultObject(_value_, _done_).\n    1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _iteratorResult_ »).\n  1. Return ~unused~.","code":"\n          1. Assert: _generator_.[[AsyncGeneratorQueue]] is not empty.\n          1. Let _next_ be the first element of _generator_.[[AsyncGeneratorQueue]].\n          1. Remove the first element from _generator_.[[AsyncGeneratorQueue]].\n          1. Let _promiseCapability_ be _next_.[[Capability]].\n          1. Let _value_ be _completion_.[[Value]].\n          1. If _completion_ is a throw completion, then\n            1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _value_ »).\n          1. Else,\n            1. Assert: _completion_ is a normal completion.\n            1. If _realm_ is present, then\n              1. Let _oldRealm_ be the running execution context's Realm.\n              1. Set the running execution context's Realm to _realm_.\n              1. Let _iteratorResult_ be CreateIterResultObject(_value_, _done_).\n              1. Set the running execution context's Realm to _oldRealm_.\n            1. Else,\n              1. Let _iteratorResult_ be CreateIterResultObject(_value_, _done_).\n            1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _iteratorResult_ »).\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AsyncGeneratorResume","params":[{"name":"generator","ty":"Record[AsyncGenerator]","kind":{"Normal":{}}},{"name":"completion","ty":"Completion","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Assert: _generator_.[[AsyncGeneratorState]] is either ~suspended-start~ or ~suspended-yield~.\n  1. Let _genContext_ be _generator_.[[AsyncGeneratorContext]].\n  1. Let _callerContext_ be the running execution context.\n  1. Suspend _callerContext_.\n  1. Set _generator_.[[AsyncGeneratorState]] to ~executing~.\n  1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.\n  1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _genContext_</emu-meta> using _completion_ as the result of the operation that suspended it. Let _result_ be the value returned by the resumed computation.\n  1. Assert: _result_ is never an abrupt completion.\n  1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _callerContext_ is the currently running execution context..\n  1. Return ~unused~.","code":"\n          1. Assert: _generator_.[[AsyncGeneratorState]] is either ~suspended-start~ or ~suspended-yield~.\n          1. Let _genContext_ be _generator_.[[AsyncGeneratorContext]].\n          1. Let _callerContext_ be the running execution context.\n          1. Suspend _callerContext_.\n          1. Set _generator_.[[AsyncGeneratorState]] to ~executing~.\n          1. Push _genContext_ onto the execution context stack; _genContext_ is now the running execution context.\n          1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _genContext_</emu-meta> using _completion_ as the result of the operation that suspended it. Let _result_ be the Completion Record returned by the resumed computation.\n          1. Assert: _result_ is never an abrupt completion.\n          1. Assert: When we return here, _genContext_ has already been removed from the execution context stack and _callerContext_ is the currently running execution context.\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AsyncGeneratorUnwrapYieldResumption","params":[{"name":"resumptionValue","ty":"Completion","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. If _resumptionValue_ is not a return completion, return ? _resumptionValue_.\n  1. Let _awaited_ be Completion(Await(_resumptionValue_.[[Value]])).\n  1. If _awaited_ is a throw completion, return ? _awaited_.\n  1. Assert: _awaited_ is a normal completion.\n  1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _awaited_.[[Value]], [[Target]]: ~empty~ }.","code":"\n          1. If _resumptionValue_ is not a return completion, return ? _resumptionValue_.\n          1. Let _awaited_ be Completion(Await(_resumptionValue_.[[Value]])).\n          1. If _awaited_ is a throw completion, return ? _awaited_.\n          1. Assert: _awaited_ is a normal completion.\n          1. Return Completion Record { [[Type]]: ~return~, [[Value]]: _awaited_.[[Value]], [[Target]]: ~empty~ }.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AsyncGeneratorYield","params":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[ESValue] | Abrupt"}},"body":"\n  1. Let _genContext_ be the running execution context.\n  1. Assert: _genContext_ is the execution context of a generator..\n  1. Let _generator_ be _genContext_.Generator.\n  1. Assert: GetGeneratorKind() is ~async~.\n  1. Let _completion_ be NormalCompletion(_value_).\n  1. Assert: The execution context stack has at least two elements..\n  1. Let _previousContext_ be the second to top element of the execution context stack.\n  1. Let _previousRealm_ be _previousContext_.Realm.\n  1. Perform AsyncGeneratorCompleteStep(_generator_, _completion_, *false*, _previousRealm_).\n  1. Let _queue_ be _generator_.[[AsyncGeneratorQueue]].\n  1. If _queue_ is not empty, then\n    1. NOTE: Execution continues without suspending the generator.\n    1. Let _toYield_ be _queue_[0].\n    1. Let _resumptionValue_ be Completion(_toYield_.[[Completion]]).\n    1. Return ? AsyncGeneratorUnwrapYieldResumption(_resumptionValue_).\n  1. Else,\n    1. Set _generator_.[[AsyncGeneratorState]] to ~suspended-yield~.\n    1. Remove _genContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n    1. Let _callerContext_ be the running execution context.\n    1. Resume _callerContext_ passing *undefined*. If _genContext_ is ever resumed again, let _resumptionValue_ be the Completion Record with which it is resumed.\n    1. Assert: If control reaches here, then _genContext_ is the running execution context again..\n    1. Return ? AsyncGeneratorUnwrapYieldResumption(_resumptionValue_).","code":"\n          1. Let _genContext_ be the running execution context.\n          1. Assert: _genContext_ is the execution context of a generator.\n          1. Let _generator_ be the value of the Generator component of _genContext_.\n          1. Assert: GetGeneratorKind() is ~async~.\n          1. Let _completion_ be NormalCompletion(_value_).\n          1. Assert: The execution context stack has at least two elements.\n          1. Let _previousContext_ be the second to top element of the execution context stack.\n          1. Let _previousRealm_ be _previousContext_'s Realm.\n          1. Perform AsyncGeneratorCompleteStep(_generator_, _completion_, *false*, _previousRealm_).\n          1. Let _queue_ be _generator_.[[AsyncGeneratorQueue]].\n          1. If _queue_ is not empty, then\n            1. NOTE: Execution continues without suspending the generator.\n            1. Let _toYield_ be the first element of _queue_.\n            1. Let _resumptionValue_ be Completion(_toYield_.[[Completion]]).\n            1. Return ? AsyncGeneratorUnwrapYieldResumption(_resumptionValue_).\n          1. Else,\n            1. Set _generator_.[[AsyncGeneratorState]] to ~suspended-yield~.\n            1. Remove _genContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n            1. Let _callerContext_ be the running execution context.\n            1. Resume _callerContext_ passing *undefined*. If _genContext_ is ever resumed again, let _resumptionValue_ be the Completion Record with which it is resumed.\n            1. Assert: If control reaches here, then _genContext_ is the running execution context again.\n            1. Return ? AsyncGeneratorUnwrapYieldResumption(_resumptionValue_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AsyncGeneratorAwaitReturn","params":[{"name":"generator","ty":"Record[AsyncGenerator]","kind":{"Normal":{}}}],"retTy":"Normal[Enum[~unused~]] | Throw"}},"body":"\n  1. Let _queue_ be _generator_.[[AsyncGeneratorQueue]].\n  1. Assert: _queue_ is not empty.\n  1. Let _next_ be _queue_[0].\n  1. Let _completion_ be Completion(_next_.[[Completion]]).\n  1. Assert: _completion_ is a return completion.\n  1. Let _promise_ be ? PromiseResolve(%Promise%, _completion_.[[Value]]).\n  1. Let _fulfilledClosure_ be a new Abstract Closure with parameters (_value_) that captures _generator_ and performs the following steps when called:\n    1. Set _generator_.[[AsyncGeneratorState]] to ~completed~.\n    1. Let _result_ be NormalCompletion(_value_).\n    1. Perform AsyncGeneratorCompleteStep(_generator_, _result_, *true*).\n    1. Perform AsyncGeneratorDrainQueue(_generator_).\n    1. Return *undefined*.\n  1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 1, *\"\"*, « »).\n  1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _generator_ and performs the following steps when called:\n    1. Set _generator_.[[AsyncGeneratorState]] to ~completed~.\n    1. Let _result_ be ThrowCompletion(_reason_).\n    1. Perform AsyncGeneratorCompleteStep(_generator_, _result_, *true*).\n    1. Perform AsyncGeneratorDrainQueue(_generator_).\n    1. Return *undefined*.\n  1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *\"\"*, « »).\n  1. Perform PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_).\n  1. Return ~unused~.","code":"\n          1. Let _queue_ be _generator_.[[AsyncGeneratorQueue]].\n          1. Assert: _queue_ is not empty.\n          1. Let _next_ be the first element of _queue_.\n          1. Let _completion_ be Completion(_next_.[[Completion]]).\n          1. Assert: _completion_ is a return completion.\n          1. Let _promise_ be ? PromiseResolve(%Promise%, _completion_.[[Value]]).\n          1. Let _fulfilledClosure_ be a new Abstract Closure with parameters (_value_) that captures _generator_ and performs the following steps when called:\n            1. Set _generator_.[[AsyncGeneratorState]] to ~completed~.\n            1. Let _result_ be NormalCompletion(_value_).\n            1. Perform AsyncGeneratorCompleteStep(_generator_, _result_, *true*).\n            1. Perform AsyncGeneratorDrainQueue(_generator_).\n            1. Return *undefined*.\n          1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 1, *\"\"*, « »).\n          1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _generator_ and performs the following steps when called:\n            1. Set _generator_.[[AsyncGeneratorState]] to ~completed~.\n            1. Let _result_ be ThrowCompletion(_reason_).\n            1. Perform AsyncGeneratorCompleteStep(_generator_, _result_, *true*).\n            1. Perform AsyncGeneratorDrainQueue(_generator_).\n            1. Return *undefined*.\n          1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *\"\"*, « »).\n          1. Perform PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_).\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AsyncGeneratorDrainQueue","params":[{"name":"generator","ty":"Record[AsyncGenerator]","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Assert: _generator_.[[AsyncGeneratorState]] is ~completed~.\n  1. Let _queue_ be _generator_.[[AsyncGeneratorQueue]].\n  1. If _queue_ is empty, return ~unused~.\n  1. Let _done_ be *false*.\n  1. Repeat, while _done_ is *false*,\n    1. Let _next_ be _queue_[0].\n    1. Let _completion_ be Completion(_next_.[[Completion]]).\n    1. If _completion_ is a return completion, then\n      1. Set _generator_.[[AsyncGeneratorState]] to ~awaiting-return~.\n      1. Perform ! AsyncGeneratorAwaitReturn(_generator_).\n      1. Set _done_ to *true*.\n    1. Else,\n      1. If _completion_ is a normal completion, then\n        1. Set _completion_ to NormalCompletion(*undefined*).\n      1. Perform AsyncGeneratorCompleteStep(_generator_, _completion_, *true*).\n      1. If _queue_ is empty, set _done_ to *true*.\n  1. Return ~unused~.","code":"\n          1. Assert: _generator_.[[AsyncGeneratorState]] is ~completed~.\n          1. Let _queue_ be _generator_.[[AsyncGeneratorQueue]].\n          1. If _queue_ is empty, return ~unused~.\n          1. Let _done_ be *false*.\n          1. Repeat, while _done_ is *false*,\n            1. Let _next_ be the first element of _queue_.\n            1. Let _completion_ be Completion(_next_.[[Completion]]).\n            1. If _completion_ is a return completion, then\n              1. Set _generator_.[[AsyncGeneratorState]] to ~awaiting-return~.\n              1. Perform ! AsyncGeneratorAwaitReturn(_generator_).\n              1. Set _done_ to *true*.\n            1. Else,\n              1. If _completion_ is a normal completion, then\n                1. Set _completion_ to NormalCompletion(*undefined*).\n              1. Perform AsyncGeneratorCompleteStep(_generator_, _completion_, *true*).\n              1. If _queue_ is empty, set _done_ to *true*.\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"CreateAsyncIteratorFromClosure","params":[{"name":"closure","ty":"Clo","kind":{"Normal":{}}},{"name":"generatorBrand","ty":"Enum[~empty~] | String","kind":{"Normal":{}}},{"name":"generatorPrototype","ty":"Record[Object]","kind":{"Normal":{}}}],"retTy":"Record[AsyncGenerator]"}},"body":"\n  1. NOTE: _closure_ can contain uses of the Await operation and uses of the Yield operation to yield an IteratorResult object.\n  1. Let _internalSlotsList_ be « [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]], [[GeneratorBrand]] ».\n  1. Let _generator_ be OrdinaryObjectCreate(_generatorPrototype_, _internalSlotsList_).\n  1. Set _generator_.[[GeneratorBrand]] to _generatorBrand_.\n  1. Set _generator_.[[AsyncGeneratorState]] to *undefined*.\n  1. Let _callerContext_ be the running execution context.\n  1. Let _calleeContext_ be ExecutionContext { }.\n  1. Set _calleeContext_.Function to *null*.\n  1. Set _calleeContext_.Realm to the current Realm Record.\n  1. Set _calleeContext_.ScriptOrModule to _callerContext_.ScriptOrModule.\n  1. If _callerContext_ is not already suspended, suspend _callerContext_.\n  1. Push _calleeContext_ onto the execution context stack; _calleeContext_ is now the running execution context.\n  1. Perform AsyncGeneratorStart(_generator_, _closure_).\n  1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.\n  1. Return _generator_.","code":"\n          1. NOTE: _closure_ can contain uses of the Await operation and uses of the Yield operation to yield an IteratorResult object.\n          1. Let _internalSlotsList_ be « [[AsyncGeneratorState]], [[AsyncGeneratorContext]], [[AsyncGeneratorQueue]], [[GeneratorBrand]] ».\n          1. Let _generator_ be OrdinaryObjectCreate(_generatorPrototype_, _internalSlotsList_).\n          1. Set _generator_.[[GeneratorBrand]] to _generatorBrand_.\n          1. Set _generator_.[[AsyncGeneratorState]] to *undefined*.\n          1. Let _callerContext_ be the running execution context.\n          1. Let _calleeContext_ be a new execution context.\n          1. Set the Function of _calleeContext_ to *null*.\n          1. Set the Realm of _calleeContext_ to the current Realm Record.\n          1. Set the ScriptOrModule of _calleeContext_ to _callerContext_'s ScriptOrModule.\n          1. If _callerContext_ is not already suspended, suspend _callerContext_.\n          1. Push _calleeContext_ onto the execution context stack; _calleeContext_ is now the running execution context.\n          1. Perform AsyncGeneratorStart(_generator_, _closure_).\n          1. Remove _calleeContext_ from the execution context stack and restore _callerContext_ as the running execution context.\n          1. Return _generator_.\n        "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"AsyncFunction"}},"params":[{"name":"parameterArgs","ty":"Unknown","kind":{"Variadic":{}}},{"name":"bodyArg","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _C_ be the active function object.\n  1. If _bodyArg_ is not present, set _bodyArg_ to *\"\"*.\n  1. Return ? CreateDynamicFunction(_C_, NewTarget, ~async~, _parameterArgs_, _bodyArg_).","code":"\n          1. Let _C_ be the active function object.\n          1. If _bodyArg_ is not present, set _bodyArg_ to the empty String.\n          1. Return ? CreateDynamicFunction(_C_, NewTarget, ~async~, _parameterArgs_, _bodyArg_).\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AsyncFunctionStart","params":[{"name":"promiseCapability","ty":"Record[PromiseCapabilityRecord]","kind":{"Normal":{}}},{"name":"asyncFunctionBody","ty":"Unknown[\"a |FunctionBody| Parse Node or an |ExpressionBody| Parse Node\"]","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Let _runningContext_ be the running execution context.\n  1. Let _asyncContext_ be a copy of _runningContext_.\n  1. NOTE: Copying the execution state is required for AsyncBlockStart to resume its execution. It is ill-defined to resume a currently executing context.\n  1. Perform AsyncBlockStart(_promiseCapability_, _asyncFunctionBody_, _asyncContext_).\n  1. Return ~unused~.","code":"\n          1. Let _runningContext_ be the running execution context.\n          1. Let _asyncContext_ be a copy of _runningContext_.\n          1. NOTE: Copying the execution state is required for AsyncBlockStart to resume its execution. It is ill-defined to resume a currently executing context.\n          1. Perform AsyncBlockStart(_promiseCapability_, _asyncFunctionBody_, _asyncContext_).\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"AsyncBlockStart","params":[{"name":"promiseCapability","ty":"Record[PromiseCapabilityRecord]","kind":{"Normal":{}}},{"name":"asyncBody","ty":"Ast","kind":{"Normal":{}}},{"name":"asyncContext","ty":"Record[ExecutionContext]","kind":{"Normal":{}}}],"retTy":"Enum[~unused~]"}},"body":"\n  1. Assert: _promiseCapability_ is a Record[PromiseCapabilityRecord].\n  1. Let _runningContext_ be the running execution context.\n  1. Let _closure_ be a new Abstract Closure with no parameters that captures _promiseCapability_ and _asyncBody_ and performs the following steps when called:\n    1. Let _acAsyncContext_ be the running execution context.\n    1. Let _result_ be Completion(the result of evaluating _asyncBody_).\n    1. Assert: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done..\n    1. Remove _acAsyncContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n    1. If _result_ is a normal completion, then\n      1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « *undefined* »).\n    1. Else if _result_ is a return completion, then\n      1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _result_.[[Value]] »).\n    1. Else,\n      1. Assert: _result_ is a throw completion.\n      1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _result_.[[Value]] »).\n    1. [id=\"step-asyncblockstart-return-undefined\"] Return ~unused~.\n  1. Set the code evaluation state of _asyncContext_ such that when evaluation is resumed for that execution context the following steps will be performed:return _closure_().\n  1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.\n  1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _asyncContext_</emu-meta>. Let _result_ be the value returned by the resumed computation.\n  1. Assert: When we return here, _asyncContext_ has already been removed from the execution context stack and _runningContext_ is the currently running execution context..\n  1. Assert: _result_ is a normal completion with a value of ~unused~. The possible sources of this value are Await or, if the async function doesn't await anything, step <emu-xref href=\"#step-asyncblockstart-return-undefined\"></emu-xref> above..\n  1. Return ~unused~.","code":"\n          1. Assert: _promiseCapability_ is a PromiseCapability Record.\n          1. Let _runningContext_ be the running execution context.\n          1. Let _closure_ be a new Abstract Closure with no parameters that captures _promiseCapability_ and _asyncBody_ and performs the following steps when called:\n            1. Let _acAsyncContext_ be the running execution context.\n            1. Let _result_ be Completion(Evaluation of _asyncBody_).\n            1. Assert: If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.\n            1. Remove _acAsyncContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n            1. If _result_ is a normal completion, then\n              1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « *undefined* »).\n            1. Else if _result_ is a return completion, then\n              1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, « _result_.[[Value]] »).\n            1. Else,\n              1. Assert: _result_ is a throw completion.\n              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, « _result_.[[Value]] »).\n            1. [id=\"step-asyncblockstart-return-undefined\"] Return ~unused~.\n          1. Set the code evaluation state of _asyncContext_ such that when evaluation is resumed for that execution context, _closure_ will be called with no arguments.\n          1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.\n          1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _asyncContext_</emu-meta>. Let _result_ be the value returned by the resumed computation.\n          1. Assert: When we return here, _asyncContext_ has already been removed from the execution context stack and _runningContext_ is the currently running execution context.\n          1. Assert: _result_ is a normal completion with a value of ~unused~. The possible sources of this value are Await or, if the async function doesn't await anything, step <emu-xref href=\"#step-asyncblockstart-return-undefined\"></emu-xref> above.\n          1. Return ~unused~.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"Await","params":[{"name":"value","ty":"ESValue","kind":{"Normal":{}}}],"retTy":"Normal[ESValue | Enum[~empty~]] | Throw"}},"body":"\n  1. Let _asyncContext_ be the running execution context.\n  1. Let _promise_ be ? PromiseResolve(%Promise%, _value_).\n  1. Let _fulfilledClosure_ be a new Abstract Closure with parameters (_v_) that captures _asyncContext_ and performs the following steps when called:\n    1. Let _prevContext_ be the running execution context.\n    1. Suspend _prevContext_.\n    1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.\n    1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _asyncContext_</emu-meta> using NormalCompletion(_v_) as the result of the operation that suspended it.\n    1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context..\n    1. Return *undefined*.\n  1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 1, *\"\"*, « »).\n  1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _asyncContext_ and performs the following steps when called:\n    1. Let _prevContext_ be the running execution context.\n    1. Suspend _prevContext_.\n    1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.\n    1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _asyncContext_</emu-meta> using ThrowCompletion(_reason_) as the result of the operation that suspended it.\n    1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context..\n    1. Return *undefined*.\n  1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *\"\"*, « »).\n  1. Perform PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_).\n  1. Remove _asyncContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n  1. Let _callerContext_ be the running execution context.\n  1. Resume _callerContext_ passing ~empty~. If _asyncContext_ is ever resumed again, let _completion_ be the Completion Record with which it is resumed.\n  1. Assert: If control reaches here, then _asyncContext_ is the running execution context again..\n  1. Return _completion_.","code":"\n          1. Let _asyncContext_ be the running execution context.\n          1. Let _promise_ be ? PromiseResolve(%Promise%, _value_).\n          1. Let _fulfilledClosure_ be a new Abstract Closure with parameters (_v_) that captures _asyncContext_ and performs the following steps when called:\n            1. Let _prevContext_ be the running execution context.\n            1. Suspend _prevContext_.\n            1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.\n            1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _asyncContext_</emu-meta> using NormalCompletion(_v_) as the result of the operation that suspended it.\n            1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context.\n            1. Return *undefined*.\n          1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 1, *\"\"*, « »).\n          1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _asyncContext_ and performs the following steps when called:\n            1. Let _prevContext_ be the running execution context.\n            1. Suspend _prevContext_.\n            1. Push _asyncContext_ onto the execution context stack; _asyncContext_ is now the running execution context.\n            1. <emu-meta effects=\"user-code\">Resume the suspended evaluation of _asyncContext_</emu-meta> using ThrowCompletion(_reason_) as the result of the operation that suspended it.\n            1. Assert: When we reach this step, _asyncContext_ has already been removed from the execution context stack and _prevContext_ is the currently running execution context.\n            1. Return *undefined*.\n          1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *\"\"*, « »).\n          1. Perform PerformPromiseThen(_promise_, _onFulfilled_, _onRejected_).\n          1. Remove _asyncContext_ from the execution context stack and restore the execution context that is at the top of the execution context stack as the running execution context.\n          1. Let _callerContext_ be the running execution context.\n          1. Resume _callerContext_ passing ~empty~. If _asyncContext_ is ever resumed again, let _completion_ be the Completion Record with which it is resumed.\n          1. Assert: If control reaches here, then _asyncContext_ is the running execution context again.\n          1. Return _completion_.\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Reflect"}},"name":"apply"}},"params":[{"name":"target","ty":"Unknown","kind":{"Normal":{}}},{"name":"thisArgument","ty":"Unknown","kind":{"Normal":{}}},{"name":"argumentsList","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If IsCallable(_target_) is *false*, throw a *TypeError* exception.\n  1. Let _args_ be ? CreateListFromArrayLike(_argumentsList_).\n  1. Perform PrepareForTailCall().\n  1. Return ? Call(_target_, _thisArgument_, _args_).","code":"\n        1. If IsCallable(_target_) is *false*, throw a *TypeError* exception.\n        1. Let _args_ be ? CreateListFromArrayLike(_argumentsList_).\n        1. Perform PrepareForTailCall().\n        1. Return ? Call(_target_, _thisArgument_, _args_).\n      "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Reflect"}},"name":"construct"}},"params":[{"name":"target","ty":"Unknown","kind":{"Normal":{}}},{"name":"argumentsList","ty":"Unknown","kind":{"Normal":{}}},{"name":"newTarget","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. If IsConstructor(_target_) is *false*, throw a *TypeError* exception.\n  1. If _newTarget_ is not present, set _newTarget_ to _target_.\n  1. Else if IsConstructor(_newTarget_) is *false*, throw a *TypeError* exception.\n  1. Let _args_ be ? CreateListFromArrayLike(_argumentsList_).\n  1. Return ? Construct(_target_, _args_, _newTarget_).","code":"\n        1. If IsConstructor(_target_) is *false*, throw a *TypeError* exception.\n        1. If _newTarget_ is not present, set _newTarget_ to _target_.\n        1. Else if IsConstructor(_newTarget_) is *false*, throw a *TypeError* exception.\n        1. Let _args_ be ? CreateListFromArrayLike(_argumentsList_).\n        1. Return ? Construct(_target_, _args_, _newTarget_).\n      "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Reflect"}},"name":"defineProperty"}},"params":[{"name":"target","ty":"Unknown","kind":{"Normal":{}}},{"name":"propertyKey","ty":"Unknown","kind":{"Normal":{}}},{"name":"attributes","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If _target_ is not a Record[Object], throw a *TypeError* exception.\n  1. Let _key_ be ? ToPropertyKey(_propertyKey_).\n  1. Let _desc_ be ? ToPropertyDescriptor(_attributes_).\n  1. Return ? _target_.[[DefineOwnProperty]](_key_, _desc_).","code":"\n        1. If _target_ is not an Object, throw a *TypeError* exception.\n        1. Let _key_ be ? ToPropertyKey(_propertyKey_).\n        1. Let _desc_ be ? ToPropertyDescriptor(_attributes_).\n        1. Return ? <emu-meta effects=\"user-code\">_target_.[[DefineOwnProperty]]</emu-meta>(_key_, _desc_).\n      "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Reflect"}},"name":"deleteProperty"}},"params":[{"name":"target","ty":"Unknown","kind":{"Normal":{}}},{"name":"propertyKey","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If _target_ is not a Record[Object], throw a *TypeError* exception.\n  1. Let _key_ be ? ToPropertyKey(_propertyKey_).\n  1. Return ? _target_.[[Delete]](_key_).","code":"\n        1. If _target_ is not an Object, throw a *TypeError* exception.\n        1. Let _key_ be ? ToPropertyKey(_propertyKey_).\n        1. Return ? <emu-meta effects=\"user-code\">_target_.[[Delete]]</emu-meta>(_key_).\n      "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Reflect"}},"name":"get"}},"params":[{"name":"target","ty":"Unknown","kind":{"Normal":{}}},{"name":"propertyKey","ty":"Unknown","kind":{"Normal":{}}},{"name":"receiver","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. If _target_ is not a Record[Object], throw a *TypeError* exception.\n  1. Let _key_ be ? ToPropertyKey(_propertyKey_).\n  1. If _receiver_ is not present, then\n    1. Set _receiver_ to _target_.\n  1. Return ? _target_.[[Get]](_key_, _receiver_).","code":"\n        1. If _target_ is not an Object, throw a *TypeError* exception.\n        1. Let _key_ be ? ToPropertyKey(_propertyKey_).\n        1. If _receiver_ is not present, then\n          1. Set _receiver_ to _target_.\n        1. Return ? <emu-meta effects=\"user-code\">_target_.[[Get]]</emu-meta>(_key_, _receiver_).\n      "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Reflect"}},"name":"getOwnPropertyDescriptor"}},"params":[{"name":"target","ty":"Unknown","kind":{"Normal":{}}},{"name":"propertyKey","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If _target_ is not a Record[Object], throw a *TypeError* exception.\n  1. Let _key_ be ? ToPropertyKey(_propertyKey_).\n  1. Let _desc_ be ? _target_.[[GetOwnProperty]](_key_).\n  1. Return FromPropertyDescriptor(_desc_).","code":"\n        1. If _target_ is not an Object, throw a *TypeError* exception.\n        1. Let _key_ be ? ToPropertyKey(_propertyKey_).\n        1. Let _desc_ be ? <emu-meta effects=\"user-code\">_target_.[[GetOwnProperty]]</emu-meta>(_key_).\n        1. Return FromPropertyDescriptor(_desc_).\n      "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Reflect"}},"name":"getPrototypeOf"}},"params":[{"name":"target","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If _target_ is not a Record[Object], throw a *TypeError* exception.\n  1. Return ? _target_.[[GetPrototypeOf]]().","code":"\n        1. If _target_ is not an Object, throw a *TypeError* exception.\n        1. Return ? <emu-meta effects=\"user-code\">_target_.[[GetPrototypeOf]]()</emu-meta>.\n      "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Reflect"}},"name":"has"}},"params":[{"name":"target","ty":"Unknown","kind":{"Normal":{}}},{"name":"propertyKey","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If _target_ is not a Record[Object], throw a *TypeError* exception.\n  1. Let _key_ be ? ToPropertyKey(_propertyKey_).\n  1. Return ? _target_.[[HasProperty]](_key_).","code":"\n        1. If _target_ is not an Object, throw a *TypeError* exception.\n        1. Let _key_ be ? ToPropertyKey(_propertyKey_).\n        1. Return ? <emu-meta effects=\"user-code\">_target_.[[HasProperty]]</emu-meta>(_key_).\n      "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Reflect"}},"name":"isExtensible"}},"params":[{"name":"target","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If _target_ is not a Record[Object], throw a *TypeError* exception.\n  1. Return ? _target_.[[IsExtensible]]().","code":"\n        1. If _target_ is not an Object, throw a *TypeError* exception.\n        1. Return ? <emu-meta effects=\"user-code\">_target_.[[IsExtensible]]()</emu-meta>.\n      "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Reflect"}},"name":"ownKeys"}},"params":[{"name":"target","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If _target_ is not a Record[Object], throw a *TypeError* exception.\n  1. Let _keys_ be ? _target_.[[OwnPropertyKeys]]().\n  1. Return CreateArrayFromList(_keys_).","code":"\n        1. If _target_ is not an Object, throw a *TypeError* exception.\n        1. Let _keys_ be ? <emu-meta effects=\"user-code\">_target_.[[OwnPropertyKeys]]()</emu-meta>.\n        1. Return CreateArrayFromList(_keys_).\n      "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Reflect"}},"name":"preventExtensions"}},"params":[{"name":"target","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If _target_ is not a Record[Object], throw a *TypeError* exception.\n  1. Return ? _target_.[[PreventExtensions]]().","code":"\n        1. If _target_ is not an Object, throw a *TypeError* exception.\n        1. Return ? <emu-meta effects=\"user-code\">_target_.[[PreventExtensions]]()</emu-meta>.\n      "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Reflect"}},"name":"set"}},"params":[{"name":"target","ty":"Unknown","kind":{"Normal":{}}},{"name":"propertyKey","ty":"Unknown","kind":{"Normal":{}}},{"name":"V","ty":"Unknown","kind":{"Normal":{}}},{"name":"receiver","ty":"Unknown","kind":{"Optional":{}}}],"retTy":"Unknown"}},"body":"\n  1. If _target_ is not a Record[Object], throw a *TypeError* exception.\n  1. Let _key_ be ? ToPropertyKey(_propertyKey_).\n  1. If _receiver_ is not present, then\n    1. Set _receiver_ to _target_.\n  1. Return ? _target_.[[Set]](_key_, _V_, _receiver_).","code":"\n        1. If _target_ is not an Object, throw a *TypeError* exception.\n        1. Let _key_ be ? ToPropertyKey(_propertyKey_).\n        1. If _receiver_ is not present, then\n          1. Set _receiver_ to _target_.\n        1. Return ? <emu-meta effects=\"user-code\">_target_.[[Set]]</emu-meta>(_key_, _V_, _receiver_).\n      "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Reflect"}},"name":"setPrototypeOf"}},"params":[{"name":"target","ty":"Unknown","kind":{"Normal":{}}},{"name":"proto","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If _target_ is not a Record[Object], throw a *TypeError* exception.\n  1. If _proto_ is not a Record[Object] and _proto_ is not *null*, throw a *TypeError* exception.\n  1. Return ? _target_.[[SetPrototypeOf]](_proto_).","code":"\n        1. If _target_ is not an Object, throw a *TypeError* exception.\n        1. If _proto_ is not an Object and _proto_ is not *null*, throw a *TypeError* exception.\n        1. Return ? <emu-meta effects=\"user-code\">_target_.[[SetPrototypeOf]]</emu-meta>(_proto_).\n      "},{"head":{"BuiltinHead":{"path":{"Base":{"name":"Proxy"}},"params":[{"name":"target","ty":"Unknown","kind":{"Normal":{}}},{"name":"handler","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. If NewTarget is *undefined*, throw a *TypeError* exception.\n  1. Return ? ProxyCreate(_target_, _handler_).","code":"\n          1. If NewTarget is *undefined*, throw a *TypeError* exception.\n          1. Return ? ProxyCreate(_target_, _handler_).\n        "},{"head":{"BuiltinHead":{"path":{"NormalAccess":{"base":{"Base":{"name":"Proxy"}},"name":"revocable"}},"params":[{"name":"target","ty":"Unknown","kind":{"Normal":{}}},{"name":"handler","ty":"Unknown","kind":{"Normal":{}}}],"retTy":"Unknown"}},"body":"\n  1. Let _proxy_ be ? ProxyCreate(_target_, _handler_).\n  1. Let _revokerClosure_ be a new Abstract Closure with no parameters that captures  and performs the following steps when called:\n    1. Let _F_ be the active function object.\n    1. Let _p_ be _F_.[[RevocableProxy]].\n    1. If _p_ is *null*, return *undefined*.\n    1. Set _F_.[[RevocableProxy]] to *null*.\n    1. Assert: _p_ is a Record[ProxyExoticObject].\n    1. Set _p_.[[ProxyTarget]] to *null*.\n    1. Set _p_.[[ProxyHandler]] to *null*.\n    1. Return *undefined*.\n  1. Let _revoker_ be CreateBuiltinFunction(_revokerClosure_, 0, *\"\"*, « [[RevocableProxy]] »).\n  1. Set _revoker_.[[RevocableProxy]] to _proxy_.\n  1. Let _result_ be OrdinaryObjectCreate(%Object.prototype%).\n  1. Perform ! CreateDataPropertyOrThrow(_result_, *\"proxy\"*, _proxy_).\n  1. Perform ! CreateDataPropertyOrThrow(_result_, *\"revoke\"*, _revoker_).\n  1. Return _result_.","code":"\n          1. Let _proxy_ be ? ProxyCreate(_target_, _handler_).\n          1. Let _revokerClosure_ be a new Abstract Closure with no parameters that captures nothing and performs the following steps when called:\n            1. Let _F_ be the active function object.\n            1. Let _p_ be _F_.[[RevocableProxy]].\n            1. If _p_ is *null*, return *undefined*.\n            1. Set _F_.[[RevocableProxy]] to *null*.\n            1. Assert: _p_ is a Proxy exotic object.\n            1. Set _p_.[[ProxyTarget]] to *null*.\n            1. Set _p_.[[ProxyHandler]] to *null*.\n            1. Return *undefined*.\n          1. Let _revoker_ be CreateBuiltinFunction(_revokerClosure_, 0, *\"\"*, « [[RevocableProxy]] »).\n          1. Set _revoker_.[[RevocableProxy]] to _proxy_.\n          1. Let _result_ be OrdinaryObjectCreate(%Object.prototype%).\n          1. Perform ! CreateDataPropertyOrThrow(_result_, *\"proxy\"*, _proxy_).\n          1. Perform ! CreateDataPropertyOrThrow(_result_, *\"revoke\"*, _revoker_).\n          1. Return _result_.\n        "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"EventSet","params":[{"name":"execution","ty":"Unknown[\"a candidate execution\"]","kind":{"Normal":{}}}],"retTy":"Unknown[\"a Set of events\"]"}},"body":"\n  1. Let _events_ be an empty Set.\n  1. For each Record[AgentEventsRecord] _aer_ of _execution_.[[EventsRecords]], do\n    1. For each event _E_ of _aer_.[[EventList]], do\n      1. Append _E_ to _events_.\n  1. Return _events_.","code":"\n        1. Let _events_ be an empty Set.\n        1. For each Agent Events Record _aer_ of _execution_.[[EventsRecords]], do\n          1. For each event _E_ of _aer_.[[EventList]], do\n            1. Add _E_ to _events_.\n        1. Return _events_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"SharedDataBlockEventSet","params":[{"name":"execution","ty":"Unknown[\"a candidate execution\"]","kind":{"Normal":{}}}],"retTy":"Unknown[\"a Set of events\"]"}},"body":"\n  1. Let _events_ be an empty Set.\n  1. For each event _E_ of EventSet(_execution_), do\n    1. If _E_ is a ReadSharedMemory, WriteSharedMemory, or ReadModifyWriteSharedMemory event, add _E_ to _events_.\n  1. Return _events_.","code":"\n        1. Let _events_ be an empty Set.\n        1. For each event _E_ of EventSet(_execution_), do\n          1. If _E_ is a ReadSharedMemory, WriteSharedMemory, or ReadModifyWriteSharedMemory event, add _E_ to _events_.\n        1. Return _events_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"HostEventSet","params":[{"name":"execution","ty":"Unknown[\"a candidate execution\"]","kind":{"Normal":{}}}],"retTy":"Unknown[\"a Set of events\"]"}},"body":"\n  1. Let _events_ be an empty Set.\n  1. For each event _E_ of EventSet(_execution_), do\n    1. If _E_ is not in SharedDataBlockEventSet(_execution_), add _E_ to _events_.\n  1. Return _events_.","code":"\n        1. Let _events_ be an empty Set.\n        1. For each event _E_ of EventSet(_execution_), do\n          1. If _E_ is not in SharedDataBlockEventSet(_execution_), add _E_ to _events_.\n        1. Return _events_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ComposeWriteEventBytes","params":[{"name":"execution","ty":"Unknown[\"a candidate execution\"]","kind":{"Normal":{}}},{"name":"byteIndex","ty":"NonNegInt","kind":{"Normal":{}}},{"name":"Ws","ty":"Unknown[\"a List of either WriteSharedMemory or ReadModifyWriteSharedMemory events\"]","kind":{"Normal":{}}}],"retTy":"Unknown[\"a List of byte values\"]"}},"body":"\n  1. Let _byteLocation_ be _byteIndex_.\n  1. Let _bytesRead_ be « ».\n  1. For each _W_ of _Ws_, do\n    1. Assert: _W_ has _byteLocation_ in its range..\n    1. Let _payloadIndex_ be _byteLocation_ - _W_.[[ByteIndex]].\n    1. If _W_ is a WriteSharedMemory event, then\n      1. Let _byte_ be _W_.[[Payload]][_payloadIndex_].\n    1. Else,\n      1. Assert: _W_ is a ReadModifyWriteSharedMemory event..\n      1. Let _bytes_ be ValueOfReadEvent(_execution_, _W_).\n      1. Let _bytesModified_ be _W_.[[ModifyOp]](_bytes_, _W_.[[Payload]]).\n      1. Let _byte_ be _bytesModified_[_payloadIndex_].\n    1. Append _byte_ to _bytesRead_.\n    1. Set _byteLocation_ to _byteLocation_ + 1.\n  1. Return _bytesRead_.","code":"\n        1. Let _byteLocation_ be _byteIndex_.\n        1. Let _bytesRead_ be a new empty List.\n        1. For each element _W_ of _Ws_, do\n          1. Assert: _W_ has _byteLocation_ in its range.\n          1. Let _payloadIndex_ be _byteLocation_ - _W_.[[ByteIndex]].\n          1. If _W_ is a WriteSharedMemory event, then\n            1. Let _byte_ be _W_.[[Payload]][_payloadIndex_].\n          1. Else,\n            1. Assert: _W_ is a ReadModifyWriteSharedMemory event.\n            1. Let _bytes_ be ValueOfReadEvent(_execution_, _W_).\n            1. Let _bytesModified_ be _W_.[[ModifyOp]](_bytes_, _W_.[[Payload]]).\n            1. Let _byte_ be _bytesModified_[_payloadIndex_].\n          1. Append _byte_ to _bytesRead_.\n          1. Set _byteLocation_ to _byteLocation_ + 1.\n        1. Return _bytesRead_.\n      "},{"head":{"AbstractOperationHead":{"isHostDefined":false,"name":"ValueOfReadEvent","params":[{"name":"execution","ty":"Unknown[\"a candidate execution\"]","kind":{"Normal":{}}},{"name":"R","ty":"Unknown[\"a ReadSharedMemory or ReadModifyWriteSharedMemory event\"]","kind":{"Normal":{}}}],"retTy":"Unknown[\"a List of byte values\"]"}},"body":"\n  1. Let _Ws_ be _execution_.[[ReadsBytesFrom]](_R_).\n  1. Assert: _Ws_ is a List of WriteSharedMemory or ReadModifyWriteSharedMemory events with length equal to _R_.[[ElementSize]]..\n  1. Return ComposeWriteEventBytes(_execution_, _R_.[[ByteIndex]], _Ws_).","code":"\n        1. Let _Ws_ be _execution_.[[ReadsBytesFrom]](_R_).\n        1. Assert: _Ws_ is a List of WriteSharedMemory or ReadModifyWriteSharedMemory events with length equal to _R_.[[ElementSize]].\n        1. Return ComposeWriteEventBytes(_execution_, _R_.[[ByteIndex]], _Ws_).\n      "}]