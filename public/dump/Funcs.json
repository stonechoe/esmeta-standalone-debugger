["def <NUM>:BigInt::exponentiate(\n  base: BigInt,\n  exponent: BigInt,\n): Normal[BigInt] | Throw = {\n  if (< exponent 0n) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  if (&& (= base 0n) (= exponent 0n)) {\n    call %2 = clo<\"NormalCompletion\">(1n)\n    return %2\n  }\n  call %3 = clo<\"NormalCompletion\">((** base exponent))\n  return %3\n}","def <NUM>:BigInt::leftShift(\n  x: BigInt,\n  y: BigInt,\n): BigInt = {\n  return (<< x y)\n}","def <NUM>:BigInt::toString(\n  x: BigInt,\n  radix?: Math,\n): String = {\n  if (exists radix) return ([str radix] x)\n  return ([str] x)\n}","def HostEnqueuePromiseJob(\n  job: Clo,\n  realm: Record[RealmRecord] | Null,\n): Enum[~unused~] = {\n  call %0 = clo<\"GetActiveScriptOrModule\">()\n  let newJob = (record {\n    \"Job\" : job,\n    \"Realm\" : realm,\n    \"ScriptOrModule\" : %0,\n  })[#0]\n  push @JOB_QUEUE < newJob\n  return ~unused~\n}","def HostEnsureCanCompileStrings(\n  calleeRealm: Record[RealmRecord],\n  parameterStrings: List[String],\n  bodyString: String,\n  direct: Boolean,\n): Normal[Enum[~unused~]] | Throw = {\n  call %0 = clo<\"NormalCompletion\">(~unused~)\n  return %0\n}","def HostFinalizeImportMeta(\n  importMeta: Record[Object],\n  moduleRecord: Record[ModuleRecord],\n): Enum[~unused~] = {\n  return ~unused~\n}","def HostGetImportMetaProperties(\n  moduleRecord: Record[ModuleRecord],\n): List[Record[{ Key : Record[Symbol] | String, Value : ESValue }]] = {\n  return (list [])[#1]\n}","def HostPromiseRejectionTracker(\n  promise: Record[Promise],\n  operation: String[\"handle\", \"reject\"],\n): Enum[~unused~] = {\n  return ~unused~\n}","def <BUILTIN>:INTRINSICS.EvalError(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#2]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop message < ArgumentsList\n    expand __args__.message\n  } else let message = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop options < ArgumentsList\n    expand __args__.options\n  } else let options = undefined\n  if (= NewTarget undefined) {\n    let newTarget = @EXECUTION_STACK[0].Function\n  } else {\n    let newTarget = NewTarget\n  }\n  call %0 = clo<\"OrdinaryCreateFromConstructor\">(newTarget, \"%EvalError.prototype%\", (list [\"ErrorData\"])[#3])\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  %1 = (exists __args__.message)\n  if %1 {\n    call %2 = clo<\"ToString\">(message)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let msg = %2\n    call %3 = clo<\"CreateNonEnumerableDataPropertyOrThrow\">(O, \"message\", msg)\n  }\n  call %4 = clo<\"InstallErrorCause\">(O, options)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  call %5 = clo<\"NormalCompletion\">(O)\n  return %5\n}","def <BUILTIN>:INTRINSICS.Function.prototype(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Object] | Undefined,\n): Unknown = {\n  call %0 = clo<\"NormalCompletion\">(undefined)\n  return %0\n}","def <BUILTIN>:INTRINSICS.Function.prototype.toString(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Object] | Undefined,\n): Unknown = {\n  let func = this\n  if (&& (= (typeof func) @Object) (&& (exists func.SourceText) (= (typeof func.SourceText) @String))) {\n    call %0 = clo<\"NormalCompletion\">(func.SourceText)\n    return %0\n  }\n  if (? func: Record[BuiltinFunctionObject]) {\n    call %1 = clo<\"NormalCompletion\">((concat \"function \" func.InitialName \"() { [native code] }\"))\n    return %1\n  }\n  if (= (typeof func) @Object) {\n    call %2 = clo<\"IsCallable\">(func)\n    if %2 {\n      call %3 = clo<\"NormalCompletion\">(\"function () { [native code] }\")\n      return %3\n    }\n  }\n  call %4 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n  call %5 = clo<\"ThrowCompletion\">(%4)\n  return %5\n}","def <BUILTIN>:INTRINSICS.Math.random(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Object] | Undefined,\n): Unknown = {\n  call %0 = clo<\"NormalCompletion\">((random))\n  return %0\n}","def <BUILTIN>:INTRINSICS.Number.prototype.toLocaleString(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Object] | Undefined,\n): Unknown = {\n  (yet \"[YET] Number.prototype.toLocaleString\")\n}","def <BUILTIN>:INTRINSICS.RangeError(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#4]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop message < ArgumentsList\n    expand __args__.message\n  } else let message = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop options < ArgumentsList\n    expand __args__.options\n  } else let options = undefined\n  if (= NewTarget undefined) {\n    let newTarget = @EXECUTION_STACK[0].Function\n  } else {\n    let newTarget = NewTarget\n  }\n  call %0 = clo<\"OrdinaryCreateFromConstructor\">(newTarget, \"%RangeError.prototype%\", (list [\"ErrorData\"])[#5])\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  %1 = (exists __args__.message)\n  if %1 {\n    call %2 = clo<\"ToString\">(message)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let msg = %2\n    call %3 = clo<\"CreateNonEnumerableDataPropertyOrThrow\">(O, \"message\", msg)\n  }\n  call %4 = clo<\"InstallErrorCause\">(O, options)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  call %5 = clo<\"NormalCompletion\">(O)\n  return %5\n}","def <BUILTIN>:INTRINSICS.ReferenceError(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#6]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop message < ArgumentsList\n    expand __args__.message\n  } else let message = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop options < ArgumentsList\n    expand __args__.options\n  } else let options = undefined\n  if (= NewTarget undefined) {\n    let newTarget = @EXECUTION_STACK[0].Function\n  } else {\n    let newTarget = NewTarget\n  }\n  call %0 = clo<\"OrdinaryCreateFromConstructor\">(newTarget, \"%ReferenceError.prototype%\", (list [\"ErrorData\"])[#7])\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  %1 = (exists __args__.message)\n  if %1 {\n    call %2 = clo<\"ToString\">(message)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let msg = %2\n    call %3 = clo<\"CreateNonEnumerableDataPropertyOrThrow\">(O, \"message\", msg)\n  }\n  call %4 = clo<\"InstallErrorCause\">(O, options)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  call %5 = clo<\"NormalCompletion\">(O)\n  return %5\n}","def <BUILTIN>:INTRINSICS.String.prototype.toLocaleLowerCase(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Object] | Undefined,\n): Unknown = {\n  (yet \"[YET] String.prototype.toLocaleLowerCase\")\n}","def <BUILTIN>:INTRINSICS.String.prototype.toLocaleUpperCase(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Object] | Undefined,\n): Unknown = {\n  (yet \"[YET] String.prototype.toLocaleUpperCase\")\n}","def <BUILTIN>:INTRINSICS.String.prototype.toUpperCase(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Object] | Undefined,\n): Unknown = {\n  (yet \"[YET] String.prototype.toUpperCase\")\n}","def <BUILTIN>:INTRINSICS.SyntaxError(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#8]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop message < ArgumentsList\n    expand __args__.message\n  } else let message = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop options < ArgumentsList\n    expand __args__.options\n  } else let options = undefined\n  if (= NewTarget undefined) {\n    let newTarget = @EXECUTION_STACK[0].Function\n  } else {\n    let newTarget = NewTarget\n  }\n  call %0 = clo<\"OrdinaryCreateFromConstructor\">(newTarget, \"%SyntaxError.prototype%\", (list [\"ErrorData\"])[#9])\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  %1 = (exists __args__.message)\n  if %1 {\n    call %2 = clo<\"ToString\">(message)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let msg = %2\n    call %3 = clo<\"CreateNonEnumerableDataPropertyOrThrow\">(O, \"message\", msg)\n  }\n  call %4 = clo<\"InstallErrorCause\">(O, options)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  call %5 = clo<\"NormalCompletion\">(O)\n  return %5\n}","def <BUILTIN>:INTRINSICS.TypeError(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#10]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop message < ArgumentsList\n    expand __args__.message\n  } else let message = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop options < ArgumentsList\n    expand __args__.options\n  } else let options = undefined\n  if (= NewTarget undefined) {\n    let newTarget = @EXECUTION_STACK[0].Function\n  } else {\n    let newTarget = NewTarget\n  }\n  call %0 = clo<\"OrdinaryCreateFromConstructor\">(newTarget, \"%TypeError.prototype%\", (list [\"ErrorData\"])[#11])\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  %1 = (exists __args__.message)\n  if %1 {\n    call %2 = clo<\"ToString\">(message)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let msg = %2\n    call %3 = clo<\"CreateNonEnumerableDataPropertyOrThrow\">(O, \"message\", msg)\n  }\n  call %4 = clo<\"InstallErrorCause\">(O, options)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  call %5 = clo<\"NormalCompletion\">(O)\n  return %5\n}","def <BUILTIN>:INTRINSICS.URIError(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#12]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop message < ArgumentsList\n    expand __args__.message\n  } else let message = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop options < ArgumentsList\n    expand __args__.options\n  } else let options = undefined\n  if (= NewTarget undefined) {\n    let newTarget = @EXECUTION_STACK[0].Function\n  } else {\n    let newTarget = NewTarget\n  }\n  call %0 = clo<\"OrdinaryCreateFromConstructor\">(newTarget, \"%URIError.prototype%\", (list [\"ErrorData\"])[#13])\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  %1 = (exists __args__.message)\n  if %1 {\n    call %2 = clo<\"ToString\">(message)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let msg = %2\n    call %3 = clo<\"CreateNonEnumerableDataPropertyOrThrow\">(O, \"message\", msg)\n  }\n  call %4 = clo<\"InstallErrorCause\">(O, options)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  call %5 = clo<\"NormalCompletion\">(O)\n  return %5\n}","def <BUILTIN>:INTRINSICS.print(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Object] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#14]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  print x\n  call %0 = clo<\"NormalCompletion\">(undefined)\n  return %0\n}","def IsInTailPosition(\n  call: Ast[CallExpression | MemberExpression | OptionalChain],\n): Boolean = {\n  nop\n  %0 = call\n  %1 = (? %0: Ast[AsyncConciseBody | ConciseBody | FunctionBody])\n  while (&& (! %1) (exists %0.parent)) {\n    %0 = %0.parent\n    %1 = (? %0: Ast[AsyncConciseBody | ConciseBody | FunctionBody])\n  }\n  if (! %1) return false\n  let body = %0\n  if (exists body.parent) {\n    if (&& (? body: Ast[FunctionBody]) (? body.parent: Ast[GeneratorBody])) return false\n    if (&& (? body: Ast[FunctionBody]) (? body.parent: Ast[AsyncFunctionBody])) return false\n    if (&& (? body: Ast[FunctionBody]) (? body.parent: Ast[AsyncGeneratorBody])) return false\n  }\n  if (? body: Ast[AsyncConciseBody]) return false\n  sdo-call %2 = body->HasCallInTailPosition(call)\n  return %2\n}","def <NUM>:Number::toString(\n  x: Number,\n  radix?: Math,\n): String = {\n  if (exists radix) return ([str radix] x)\n  return ([str] x)\n}","def PrepareForTailCall(\n): Enum[~unused~] = {\n  assert true\n  @EXECUTION_STACK[0] = @EXECUTION_STACK[1]\n  return ~unused~\n}","def RequireObjectCoercible(\n  argument: ESValue,\n): Normal[ESValue] | Throw = {\n  if (= (typeof argument) @Undefined) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  if (= (typeof argument) @Null) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  call %0 = clo<\"NormalCompletion\">(argument)\n  return %0\n}","def StringToBigInt(\n  str: String,\n): BigInt | Undefined = {\n  return ([bigInt] str)\n}","def StringToCodePoints(\n  string: String,\n): String = {\n  return string\n}","def StringToNumber(\n  str: String,\n): Number = {\n  return ([number] str)\n}","def ToBigInt(\n  argument: ESValue,\n): Normal[BigInt] | Throw = {\n  call %0 = clo<\"ToPrimitive\">(argument, ~number~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let prim = %0\n  if (= (typeof prim) @Undefined) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  if (= (typeof prim) @Null) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  if (= (typeof prim) @Boolean) {\n    if prim {\n      call %5 = clo<\"NormalCompletion\">(1n)\n      return %5\n    } else {\n      call %6 = clo<\"NormalCompletion\">(0n)\n      return %6\n    }\n  }\n  if (= (typeof prim) @BigInt) {\n    call %7 = clo<\"NormalCompletion\">(prim)\n    return %7\n  }\n  if (= (typeof prim) @Number) {\n    call %8 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %9 = clo<\"ThrowCompletion\">(%8)\n    return %9\n  }\n  if (= (typeof prim) @String) {\n    call %10 = clo<\"StringToBigInt\">(prim)\n    let n = %10\n    if (= n undefined) {\n      call %11 = clo<\"__NEW_ERROR_OBJ__\">(\"%SyntaxError.prototype%\")\n      call %12 = clo<\"ThrowCompletion\">(%11)\n      return %12\n    }\n    call %13 = clo<\"NormalCompletion\">(n)\n    return %13\n  }\n  if (= (typeof prim) @Symbol) {\n    call %14 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %15 = clo<\"ThrowCompletion\">(%14)\n    return %15\n  }\n  assert false\n}","def ToBoolean(\n  argument: ESValue,\n): Boolean = {\n  if (= (typeof argument) @Undefined) return false\n  if (= (typeof argument) @Null) return false\n  if (= (typeof argument) @Boolean) return argument\n  if (= (typeof argument) @BigInt) {\n    if (= argument 0n) return false\n    else return true\n  }\n  if (= (typeof argument) @Number) {\n    if (|| (|| (= argument 0.0f) (= argument -0.0f)) (= argument NaN)) return false\n    else return true\n  }\n  if (= (typeof argument) @String) {\n    if (= argument \"\") return false\n    else return true\n  }\n  if (= (typeof argument) @Symbol) return true\n  if (= (typeof argument) @Object) return true\n}","def ToObject(\n  argument: ESValue,\n): Normal[Record[Object]] | Throw = {\n  let intrinsics = @EXECUTION_STACK[0].Realm.Intrinsics\n  if (= (typeof argument) @Undefined) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  if (= (typeof argument) @Null) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  if (= (typeof argument) @Boolean) {\n    call %4 = clo<\"__NEW_OBJ__\">()\n    %4.Prototype = intrinsics[\"%Boolean.prototype%\"]\n    %4.BooleanData = argument\n    %4.Extensible = true\n    call %5 = clo<\"NormalCompletion\">(%4)\n    return %5\n  }\n  if (= (typeof argument) @Number) {\n    call %6 = clo<\"__NEW_OBJ__\">()\n    %6.Prototype = intrinsics[\"%Number.prototype%\"]\n    %6.NumberData = argument\n    %6.Extensible = true\n    call %7 = clo<\"NormalCompletion\">(%6)\n    return %7\n  }\n  if (= (typeof argument) @String) {\n    call %8 = clo<\"__NEW_OBJ__\">()\n    %8.GetOwnProperty = clo<\"Record[StringExoticObject].GetOwnProperty\">\n    %8.DefineOwnProperty = clo<\"Record[StringExoticObject].DefineOwnProperty\">\n    %8.OwnPropertyKeys = clo<\"Record[StringExoticObject].OwnPropertyKeys\">\n    %8.Prototype = intrinsics[\"%String.prototype%\"]\n    %8.StringData = argument\n    %8.Extensible = true\n    %8.__MAP__.length = (record [PropertyDescriptor] {\n      \"Value\" : ([number] (sizeof argument)),\n      \"Writable\" : false,\n      \"Enumerable\" : false,\n      \"Configurable\" : false,\n    })[#15]\n    call %9 = clo<\"NormalCompletion\">(%8)\n    return %9\n  }\n  if (= (typeof argument) @Symbol) {\n    call %10 = clo<\"__NEW_OBJ__\">()\n    %10.Prototype = intrinsics[\"%Symbol.prototype%\"]\n    %10.SymbolData = argument\n    %10.Extensible = true\n    call %11 = clo<\"NormalCompletion\">(%10)\n    return %11\n  }\n  if (= (typeof argument) @BigInt) {\n    call %12 = clo<\"__NEW_OBJ__\">()\n    %12.Prototype = intrinsics[\"%BigInt.prototype%\"]\n    %12.BigIntData = argument\n    %12.Extensible = true\n    call %13 = clo<\"NormalCompletion\">(%12)\n    return %13\n  }\n  if (= (typeof argument) @Object) {\n    call %14 = clo<\"NormalCompletion\">(argument)\n    return %14\n  }\n}","def <AUX>:__APPEND_LIST__(\n  to: List,\n  from: List,\n): List = {\n  let i = 0\n  let len = (sizeof from)\n  while (< i len) {\n    push to < from[i]\n    i = (+ i 1)\n  }\n  return to\n}","def <AUX>:__CLAMP__(\n  target: Math | INF,\n  lower: Math,\n  upper: Math,\n): Math = {\n  if (< target lower) return lower\n  if (< upper target) return upper\n  return target\n}","def <AUX>:__FLAT_LIST__(\n  lists: List[List],\n): List = {\n  let list = (list [])[#16]\n  let i = 0\n  let len = (sizeof lists)\n  while (< i len) {\n    call list = clo<\"__APPEND_LIST__\">(list, lists[i])\n    i = (+ i 1)\n  }\n  return list\n}","def <AUX>:__GET_ITEMS__(\n  ast: Ast,\n  target: GrammarSymbol,\n  parent: GrammarSymbol,\n): List[Ast] = {\n  let stack = (list [ast])[#17]\n  let items = (list [])[#18]\n  while (< 0 (sizeof stack)) {\n    pop stack > ast\n    if (instanceof ast target) push items < ast\n    else if (instanceof ast parent) {\n      let i = (sizeof ast)\n      while (< 0 i) {\n        i = (- i 1)\n        if (exists ast[i]) push stack < ast[i]\n      }\n    }\n  }\n  return items\n}","def <AUX>:__HAS_DUPLICATE__(\n  list: List,\n): Boolean = {\n  let i = 1\n  let len = (sizeof list)\n  while (< i len) {\n    let j = 0\n    while (< j i) {\n      if (= list[i] list[j]) return true\n      j = (+ j 1)\n    }\n    i = (+ i 1)\n  }\n  return false\n}","def <AUX>:__IS_ARRAY_INDEX__(\n  P: ESValue,\n): Boolean = {\n  if (= (typeof P) @String) {\n    call n = clo<\"CanonicalNumericIndexString\">(P)\n    if (? n: Number[Int]) {\n      return (&& (< -1.0f n) (< n (- (** 2.0f 32.0f) 1.0f)))\n    }\n  }\n  return false\n}","def <AUX>:__NEW_ERROR_OBJ__(\n  proto: String,\n): Record[ErrorObject] = {\n  call obj = clo<\"__NEW_OBJ__\">()\n  obj.Prototype = @EXECUTION_STACK[0].Realm.Intrinsics[proto]\n  obj.Extensible = true\n  obj.ErrorData = undefined\n  return obj\n}","def <AUX>:__NEW_OBJ__(\n): Record[Object] = {\n  return (record [Object] {\n    \"GetPrototypeOf\" : clo<\"Record[OrdinaryObject].GetPrototypeOf\">,\n    \"SetPrototypeOf\" : clo<\"Record[OrdinaryObject].SetPrototypeOf\">,\n    \"IsExtensible\" : clo<\"Record[OrdinaryObject].IsExtensible\">,\n    \"PreventExtensions\" : clo<\"Record[OrdinaryObject].PreventExtensions\">,\n    \"GetOwnProperty\" : clo<\"Record[OrdinaryObject].GetOwnProperty\">,\n    \"DefineOwnProperty\" : clo<\"Record[OrdinaryObject].DefineOwnProperty\">,\n    \"HasProperty\" : clo<\"Record[OrdinaryObject].HasProperty\">,\n    \"Get\" : clo<\"Record[OrdinaryObject].Get\">,\n    \"Set\" : clo<\"Record[OrdinaryObject].Set\">,\n    \"Delete\" : clo<\"Record[OrdinaryObject].Delete\">,\n    \"OwnPropertyKeys\" : clo<\"Record[OrdinaryObject].OwnPropertyKeys\">,\n    \"PrivateElements\" : (list [])[#20],\n    \"__MAP__\" : (map[Record[Symbol] | String, Record[PropertyDescriptor]])[#21],\n  })[#19]\n}","def <AUX>:__REMOVE_ELEM__(\n  elem: Any,\n  list: List,\n): List = {\n  let length = (sizeof list)\n  let from = length\n  let to = length\n  while (< 0 from) {\n    from = (- from 1)\n    if (! (= list[from] elem)) {\n      to = (- to 1)\n      list[to] = list[from]\n    }\n  }\n  while (< 0 to) {\n    pop x < list\n    to = (- to 1)\n  }\n  return list\n}","def <CONT>:Await:clo0:cont0(\n): Unknown = {\n  assert (&& (= prevContext @EXECUTION_STACK[0]) (! (= asyncContext @EXECUTION_STACK[0])))\n  call %0 = clo<\"NormalCompletion\">(undefined)\n  return %0\n}","def <CLO>:Await:clo0(\n  this: Unknown,\n  ArgumentsList: Unknown,\n  NewTarget: Unknown,\n): Unknown = {\n  let __args__ = (record)[#22]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  let prevContext = @EXECUTION_STACK[0]\n  nop\n  push asyncContext > @EXECUTION_STACK\n  call %1 = clo<\"NormalCompletion\">(value)\n  if (! (exists asyncContext.ReturnCont)) asyncContext.ReturnCont = (list [])[#23]\n  push cont<\"Await:clo0:cont0\"> > asyncContext.ReturnCont\n  call %0 = asyncContext.ResumeCont(%1)\n}","def <CONT>:Await:clo1:cont0(\n): Unknown = {\n  assert (&& (= prevContext @EXECUTION_STACK[0]) (! (= asyncContext @EXECUTION_STACK[0])))\n  call %0 = clo<\"NormalCompletion\">(undefined)\n  return %0\n}","def <CLO>:Await:clo1(\n  this: Unknown,\n  ArgumentsList: Unknown,\n  NewTarget: Unknown,\n): Unknown = {\n  let __args__ = (record)[#24]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop reason < ArgumentsList\n    expand __args__.reason\n  } else let reason = undefined\n  let prevContext = @EXECUTION_STACK[0]\n  nop\n  push asyncContext > @EXECUTION_STACK\n  call %1 = clo<\"ThrowCompletion\">(reason)\n  if (! (exists asyncContext.ReturnCont)) asyncContext.ReturnCont = (list [])[#25]\n  push cont<\"Await:clo1:cont0\"> > asyncContext.ReturnCont\n  call %0 = asyncContext.ResumeCont(%1)\n}","def <CONT>:Await:cont2(\n  completion: Unknown,\n): Unknown = {\n  return completion\n}","def Await(\n  value: Unknown,\n): Unknown = {\n  let asyncContext = @EXECUTION_STACK[0]\n  call %0 = clo<\"PromiseResolve\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Promise%\"], value)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let promise = %0\n  let fulfilledClosure = clo<\"Await:clo0\", [asyncContext]>\n  call %1 = clo<\"CreateBuiltinFunction\">(fulfilledClosure, 1, \"\", (list [])[#26])\n  let onFulfilled = %1\n  let rejectedClosure = clo<\"Await:clo1\", [asyncContext]>\n  call %2 = clo<\"CreateBuiltinFunction\">(rejectedClosure, 1, \"\", (list [])[#27])\n  let onRejected = %2\n  call %3 = clo<\"PerformPromiseThen\">(promise, onFulfilled, onRejected)\n  pop %4 < @EXECUTION_STACK\n  asyncContext.ResumeCont = cont<\"Await:cont2\">\n  call %5 = clo<\"NormalCompletion\">(~unused~)\n  pop %6 < asyncContext.ReturnCont\n  call %7 = %6(%5)\n}","def <CLO>:RunJobs:clo0(\n): Unknown = {\n  let sourceText = @SOURCE_TEXT\n  call %0 = clo<\"ParseScript\">(sourceText, @EXECUTION_STACK[0].Realm, ~empty~)\n  let script = %0\n  call %1 = clo<\"ScriptEvaluation\">(script)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  call %2 = clo<\"NormalCompletion\">(undefined)\n  return %2\n}","@main def RunJobs(\n): Unknown = {\n  call %0 = clo<\"InitializeHostDefinedRealm\">()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let scriptEvaluationJob = clo<\"RunJobs:clo0\">\n  call %1 = clo<\"HostEnqueuePromiseJob\">(scriptEvaluationJob, @EXECUTION_STACK[0].Realm)\n  let errors = undefined\n  while true {\n    pop %2 < @EXECUTION_STACK\n    assert (= (sizeof @EXECUTION_STACK) 0)\n    let nextQueue = @JOB_QUEUE\n    if (= (sizeof @JOB_QUEUE) 0) return errors\n    pop nextPending < @JOB_QUEUE\n    let newContext = (record [ExecutionContext])[#28]\n    newContext.Function = null\n    newContext.Realm = nextPending.Realm\n    newContext.ScriptOrModule = nextPending.ScriptOrModule\n    push newContext > @EXECUTION_STACK\n    let job = nextPending.Job\n    call %3 = job()\n    let result = %3\n    if (&& (? result: Completion) (! (= result.Type ~normal~))) {\n      if (= errors undefined) {\n        errors = (list [result.Value])[#29]\n      } else {\n        push errors < result.Value\n      }\n    }\n  }\n}","def Completion(\n  completionRecord: Completion,\n): Completion = {\n  assert (? completionRecord: Completion)\n  return completionRecord\n}","def StringIndexOf(\n  string: String,\n  searchValue: String,\n  fromIndex: NonNegInt,\n): Int = {\n  let len = (sizeof string)\n  if (&& (= searchValue \"\") (! (< len fromIndex))) {\n    return fromIndex\n  }\n  let searchLen = (sizeof searchValue)\n  let i = fromIndex\n  while (! (< (- len searchLen) i)) {\n    let candidate = (substring string i (+ i searchLen))\n    if (= candidate searchValue) {\n      return i\n    }\n    i = (+ i 1)\n  }\n  return (- 1)\n}","def <NUM>:Number::unaryMinus(\n  x: Number,\n): Number = {\n  if (= x NaN) {\n    return NaN\n  }\n  return (- x)\n}","def <NUM>:Number::bitwiseNOT(\n  x: Number,\n): Number[Int] = {\n  call %0 = clo<\"ToInt32\">(x)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let oldValue = %0\n  return (~ oldValue)\n}","def <NUM>:Number::exponentiate(\n  base: Number,\n  exponent: Number,\n): Number = {\n  if (= exponent NaN) {\n    return NaN\n  }\n  if (|| (= exponent 0.0f) (= exponent -0.0f)) {\n    return 1.0f\n  }\n  if (= base NaN) {\n    return NaN\n  }\n  if (= base +NUM_INF) {\n    if (< 0.0f exponent) {\n      return +NUM_INF\n    } else {\n      return 0.0f\n    }\n  }\n  if (= base -NUM_INF) {\n    if (< 0.0f exponent) {\n      (yet \"If _exponent_ is an odd integral Number, return *-‚àû*<sub>ùîΩ</sub>. Otherwise, return *+‚àû*<sub>ùîΩ</sub>.\")\n    } else {\n      (yet \"If _exponent_ is an odd integral Number, return *-0*<sub>ùîΩ</sub>. Otherwise, return *+0*<sub>ùîΩ</sub>.\")\n    }\n  }\n  if (= base 0.0f) {\n    if (< 0.0f exponent) {\n      return 0.0f\n    } else {\n      return +NUM_INF\n    }\n  }\n  if (= base -0.0f) {\n    if (< 0.0f exponent) {\n      (yet \"If _exponent_ is an odd integral Number, return *-0*<sub>ùîΩ</sub>. Otherwise, return *+0*<sub>ùîΩ</sub>.\")\n    } else {\n      (yet \"If _exponent_ is an odd integral Number, return *-‚àû*<sub>ùîΩ</sub>. Otherwise, return *+‚àû*<sub>ùîΩ</sub>.\")\n    }\n  }\n  assert (! (|| (= base 0.0f) (= base -0.0f)))\n  if (= exponent +NUM_INF) {\n    if (< 1 (abs ([math] base))) {\n      return +NUM_INF\n    }\n    if (== (abs ([math] base)) 1) {\n      return NaN\n    }\n    if (< (abs ([math] base)) 1) {\n      return 0.0f\n    }\n  }\n  if (= exponent -NUM_INF) {\n    if (< 1 (abs ([math] base))) {\n      return 0.0f\n    }\n    if (== (abs ([math] base)) 1) {\n      return NaN\n    }\n    if (< (abs ([math] base)) 1) {\n      return +NUM_INF\n    }\n  }\n  assert (! (|| (= exponent 0.0f) (= exponent -0.0f)))\n  if (&& (< base -0.0f) (! (? exponent: Number[Int]))) {\n    return NaN\n  }\n  return ([approx-number] (** ([math] base) ([math] exponent)))\n}","def <NUM>:Number::multiply(\n  x: Number,\n  y: Number,\n): Number = {\n  if (|| (= x NaN) (= y NaN)) {\n    return NaN\n  }\n  if (|| (= x +NUM_INF) (= x -NUM_INF)) {\n    if (|| (= y 0.0f) (= y -0.0f)) {\n      return NaN\n    }\n    if (< 0.0f y) {\n      return x\n    }\n    return (- x)\n  }\n  if (|| (= y +NUM_INF) (= y -NUM_INF)) {\n    if (|| (= x 0.0f) (= x -0.0f)) {\n      return NaN\n    }\n    if (< 0.0f x) {\n      return y\n    }\n    return (- y)\n  }\n  if (= x -0.0f) {\n    (yet \"If _y_ is *-0*<sub>ùîΩ</sub> or _y_ < *-0*<sub>ùîΩ</sub>, return *+0*<sub>ùîΩ</sub>.\")\n    (yet \"Else, return *-0*<sub>ùîΩ</sub>.\")\n  }\n  if (= y -0.0f) {\n    if (< x -0.0f) {\n      return 0.0f\n    } else {\n      return -0.0f\n    }\n  }\n  return ([number] (* ([math] x) ([math] y)))\n}","def <NUM>:Number::divide(\n  x: Number,\n  y: Number,\n): Number = {\n  if (|| (= x NaN) (= y NaN)) {\n    return NaN\n  }\n  if (|| (= x +NUM_INF) (= x -NUM_INF)) {\n    if (|| (= y +NUM_INF) (= y -NUM_INF)) {\n      return NaN\n    }\n    if (|| (= y 0.0f) (< 0.0f y)) {\n      return x\n    }\n    return (- x)\n  }\n  if (= y +NUM_INF) {\n    if (|| (= x 0.0f) (< 0.0f x)) {\n      return 0.0f\n    } else {\n      return -0.0f\n    }\n  }\n  if (= y -NUM_INF) {\n    if (|| (= x 0.0f) (< 0.0f x)) {\n      return -0.0f\n    } else {\n      return 0.0f\n    }\n  }\n  if (|| (= x 0.0f) (= x -0.0f)) {\n    if (|| (= y 0.0f) (= y -0.0f)) {\n      return NaN\n    }\n    if (< 0.0f y) {\n      return x\n    }\n    return (- x)\n  }\n  if (= y 0.0f) {\n    if (< 0.0f x) {\n      return +NUM_INF\n    } else {\n      return -NUM_INF\n    }\n  }\n  if (= y -0.0f) {\n    if (< 0.0f x) {\n      return -NUM_INF\n    } else {\n      return +NUM_INF\n    }\n  }\n  return ([number] (/ ([math] x) ([math] y)))\n}","def <NUM>:Number::remainder(\n  n: Number,\n  d: Number,\n): Number = {\n  if (|| (= n NaN) (= d NaN)) {\n    return NaN\n  }\n  if (|| (= n +NUM_INF) (= n -NUM_INF)) {\n    return NaN\n  }\n  if (|| (= d +NUM_INF) (= d -NUM_INF)) {\n    return n\n  }\n  if (|| (= d 0.0f) (= d -0.0f)) {\n    return NaN\n  }\n  if (|| (= n 0.0f) (= n -0.0f)) {\n    return n\n  }\n  assert (yet \"_n_ and _d_ are finite and non-zero.\")\n  let quotient = (/ ([math] n) ([math] d))\n  %0 = quotient\n  if (< %0 0) %0 = (- (floor (- %0)))\n  else %0 = (floor %0)\n  let q = %0\n  let r = (- ([math] n) (* ([math] d) q))\n  if (&& (== r 0) (< n -0.0f)) {\n    return -0.0f\n  }\n  return ([number] r)\n}","def <NUM>:Number::add(\n  x: Number,\n  y: Number,\n): Number = {\n  if (|| (= x NaN) (= y NaN)) {\n    return NaN\n  }\n  if (&& (= x +NUM_INF) (= y -NUM_INF)) {\n    return NaN\n  }\n  if (&& (= x -NUM_INF) (= y +NUM_INF)) {\n    return NaN\n  }\n  if (|| (= x +NUM_INF) (= x -NUM_INF)) {\n    return x\n  }\n  if (|| (= y +NUM_INF) (= y -NUM_INF)) {\n    return y\n  }\n  assert (&& (! (|| (= x +INF) (= x -INF))) (! (|| (= y +INF) (= y -INF))))\n  if (&& (= x -0.0f) (= y -0.0f)) {\n    return -0.0f\n  }\n  return ([number] (+ ([math] x) ([math] y)))\n}","def <NUM>:Number::subtract(\n  x: Number,\n  y: Number,\n): Number = {\n  call %1 = clo<\"Number::unaryMinus\">(y)\n  call %0 = clo<\"Number::add\">(x, %1)\n  return %0\n}","def <NUM>:Number::leftShift(\n  x: Number,\n  y: Number,\n): Number[Int] = {\n  call %0 = clo<\"ToInt32\">(x)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let lnum = %0\n  call %1 = clo<\"ToUint32\">(y)\n  assert (? %1: Normal)\n  %1 = %1.Value\n  let rnum = %1\n  let shiftCount = (% ([math] rnum) 32)\n  return ([number] (<< ([math] lnum) shiftCount))\n}","def <NUM>:Number::signedRightShift(\n  x: Number,\n  y: Number,\n): Number[Int] = {\n  call %0 = clo<\"ToInt32\">(x)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let lnum = %0\n  call %1 = clo<\"ToUint32\">(y)\n  assert (? %1: Normal)\n  %1 = %1.Value\n  let rnum = %1\n  let shiftCount = (% ([math] rnum) 32)\n  return ([number] (>> ([math] lnum) shiftCount))\n}","def <NUM>:Number::unsignedRightShift(\n  x: Number,\n  y: Number,\n): Number[Int] = {\n  call %0 = clo<\"ToUint32\">(x)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let lnum = %0\n  call %1 = clo<\"ToUint32\">(y)\n  assert (? %1: Normal)\n  %1 = %1.Value\n  let rnum = %1\n  let shiftCount = (% ([math] rnum) 32)\n  return ([number] (>>> ([math] lnum) shiftCount))\n}","def <NUM>:Number::lessThan(\n  x: Number,\n  y: Number,\n): Boolean | Undefined = {\n  if (= x NaN) {\n    return undefined\n  }\n  if (= y NaN) {\n    return undefined\n  }\n  if (= x y) {\n    return false\n  }\n  if (&& (= x 0.0f) (= y -0.0f)) {\n    return false\n  }\n  if (&& (= x -0.0f) (= y 0.0f)) {\n    return false\n  }\n  if (= x +NUM_INF) {\n    return false\n  }\n  if (= y +NUM_INF) {\n    return true\n  }\n  if (= y -NUM_INF) {\n    return false\n  }\n  if (= x -NUM_INF) {\n    return true\n  }\n  assert (yet \"_x_ and _y_ are finite.\")\n  if (< ([math] x) ([math] y)) {\n    return true\n  } else {\n    return false\n  }\n}","def <NUM>:Number::equal(\n  x: Number,\n  y: Number,\n): Boolean = {\n  if (= x NaN) {\n    return false\n  }\n  if (= y NaN) {\n    return false\n  }\n  if (= x y) {\n    return true\n  }\n  if (&& (= x 0.0f) (= y -0.0f)) {\n    return true\n  }\n  if (&& (= x -0.0f) (= y 0.0f)) {\n    return true\n  }\n  return false\n}","def <NUM>:Number::sameValue(\n  x: Number,\n  y: Number,\n): Boolean = {\n  if (&& (= x NaN) (= y NaN)) {\n    return true\n  }\n  if (&& (= x 0.0f) (= y -0.0f)) {\n    return false\n  }\n  if (&& (= x -0.0f) (= y 0.0f)) {\n    return false\n  }\n  if (= x y) {\n    return true\n  }\n  return false\n}","def <NUM>:Number::sameValueZero(\n  x: Number,\n  y: Number,\n): Boolean = {\n  if (&& (= x NaN) (= y NaN)) {\n    return true\n  }\n  if (&& (= x 0.0f) (= y -0.0f)) {\n    return true\n  }\n  if (&& (= x -0.0f) (= y 0.0f)) {\n    return true\n  }\n  if (= x y) {\n    return true\n  }\n  return false\n}","def NumberBitwiseOp(\n  op: Unknown[\"`&`,`^`,Or``\"],\n  x: Number,\n  y: Number,\n): Number[Int] = {\n  call %0 = clo<\"ToInt32\">(x)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let lnum = %0\n  call %1 = clo<\"ToInt32\">(y)\n  assert (? %1: Normal)\n  %1 = %1.Value\n  let rnum = %1\n  let lbits = ([math] lnum)\n  let rbits = ([math] rnum)\n  if (= op \"&\") {\n    let result = (& lbits rbits)\n  } else {\n    if (= op \"^\") {\n      let result = (^ lbits rbits)\n    } else {\n      assert (= op \"|\")\n      let result = (| lbits rbits)\n    }\n  }\n  return ([number] result)\n}","def <NUM>:Number::bitwiseAND(\n  x: Number,\n  y: Number,\n): Number[Int] = {\n  call %0 = clo<\"NumberBitwiseOp\">(\"&\", x, y)\n  return %0\n}","def <NUM>:Number::bitwiseXOR(\n  x: Number,\n  y: Number,\n): Number[Int] = {\n  call %0 = clo<\"NumberBitwiseOp\">(\"^\", x, y)\n  return %0\n}","def <NUM>:Number::bitwiseOR(\n  x: Number,\n  y: Number,\n): Number[Int] = {\n  call %0 = clo<\"NumberBitwiseOp\">(\"|\", x, y)\n  return %0\n}","def <NUM>:BigInt::unaryMinus(\n  x: BigInt,\n): BigInt = {\n  if (= x 0n) {\n    return 0n\n  }\n  return (- x)\n}","def <NUM>:BigInt::bitwiseNOT(\n  x: BigInt,\n): BigInt = {\n  return (- (- x) 1n)\n}","def <NUM>:BigInt::multiply(\n  x: BigInt,\n  y: BigInt,\n): BigInt = {\n  return (* x y)\n}","def <NUM>:BigInt::divide(\n  x: BigInt,\n  y: BigInt,\n): Normal[BigInt] | Throw = {\n  if (= y 0n) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  let quotient = (/ ([math] x) ([math] y))\n  %2 = quotient\n  if (< %2 0) %2 = (- (floor (- %2)))\n  else %2 = (floor %2)\n  %3 = ([bigInt] %2)\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <NUM>:BigInt::remainder(\n  n: BigInt,\n  d: BigInt,\n): Normal[BigInt] | Throw = {\n  if (= d 0n) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  if (= n 0n) {\n    call %2 = clo<\"NormalCompletion\">(0n)\n    return %2\n  }\n  let quotient = (/ ([math] n) ([math] d))\n  %3 = quotient\n  if (< %3 0) %3 = (- (floor (- %3)))\n  else %3 = (floor %3)\n  let q = ([bigInt] %3)\n  %4 = (- n (* d q))\n  if (? %4: Completion) return %4\n  call %5 = clo<\"NormalCompletion\">(%4)\n  return %5\n}","def <NUM>:BigInt::add(\n  x: BigInt,\n  y: BigInt,\n): BigInt = {\n  return (+ x y)\n}","def <NUM>:BigInt::subtract(\n  x: BigInt,\n  y: BigInt,\n): BigInt = {\n  return (- x y)\n}","def <NUM>:BigInt::signedRightShift(\n  x: BigInt,\n  y: BigInt,\n): BigInt = {\n  call %0 = clo<\"BigInt::leftShift\">(x, (- y))\n  return %0\n}","def <NUM>:BigInt::unsignedRightShift(\n  x: BigInt,\n  y: BigInt,\n): Throw = {\n  call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n  call %1 = clo<\"ThrowCompletion\">(%0)\n  return %1\n}","def <NUM>:BigInt::lessThan(\n  x: BigInt,\n  y: BigInt,\n): Boolean = {\n  if (< ([math] x) ([math] y)) {\n    return true\n  } else {\n    return false\n  }\n}","def <NUM>:BigInt::equal(\n  x: BigInt,\n  y: BigInt,\n): Boolean = {\n  if (== ([math] x) ([math] y)) {\n    return true\n  } else {\n    return false\n  }\n}","def BinaryAnd(\n  x: Math[0, 1],\n  y: Math[0, 1],\n): Math[0, 1] = {\n  if (&& (== x 1) (== y 1)) {\n    return 1\n  } else {\n    return 0\n  }\n}","def BinaryOr(\n  x: Math[0, 1],\n  y: Math[0, 1],\n): Math[0, 1] = {\n  if (|| (== x 1) (== y 1)) {\n    return 1\n  } else {\n    return 0\n  }\n}","def BinaryXor(\n  x: Math[0, 1],\n  y: Math[0, 1],\n): Math[0, 1] = {\n  if (&& (== x 1) (== y 0)) {\n    return 1\n  } else {\n    if (&& (== x 0) (== y 1)) {\n      return 1\n    } else {\n      return 0\n    }\n  }\n}","def BigIntBitwiseOp(\n  op: Unknown[\"`&`,`^`,Or``\"],\n  x: BigInt,\n  y: BigInt,\n): BigInt = {\n  x = ([math] x)\n  y = ([math] y)\n  let result = 0\n  let shift = 0\n  (yet \"Repeat, until (_x_ = 0 or _x_ = -1) and (_y_ = 0 or _y_ = -1),\\n  1. Let _xDigit_ be _x_ modulo 2.\\n  1. Let _yDigit_ be _y_ modulo 2.\\n  1. If _op_ is `&`, then\\n    1. Set _result_ to _result_ + 2<sup>_shift_</sup> √ó BinaryAnd(_xDigit_, _yDigit_).\\n  1. Else if _op_ is `|`, then\\n    1. Set _result_ to _result_ + 2<sup>_shift_</sup> √ó BinaryOr(_xDigit_, _yDigit_).\\n  1. Else,\\n    1. Assert: _op_ is `^`.\\n    1. Set _result_ to _result_ + 2<sup>_shift_</sup> √ó BinaryXor(_xDigit_, _yDigit_).\\n  1. Set _shift_ to _shift_ + 1.\\n  1. Set _x_ to (_x_ - _xDigit_) / 2.\\n  1. Set _y_ to (_y_ - _yDigit_) / 2.\")\n  if (= op \"&\") {\n    call %0 = clo<\"BinaryAnd\">((% x 2), (% y 2))\n    let tmp = %0\n  } else {\n    if (= op \"|\") {\n      call %1 = clo<\"BinaryOr\">((% x 2), (% y 2))\n      let tmp = %1\n    } else {\n      assert (= op \"^\")\n      call %2 = clo<\"BinaryXor\">((% x 2), (% y 2))\n      let tmp = %2\n    }\n  }\n  if (! (== tmp 0)) {\n    result = (- result (** 2 shift))\n    nop\n  }\n  return ([bigInt] result)\n}","def <NUM>:BigInt::bitwiseAND(\n  x: BigInt,\n  y: BigInt,\n): BigInt = {\n  call %0 = clo<\"BigIntBitwiseOp\">(\"&\", x, y)\n  return %0\n}","def <NUM>:BigInt::bitwiseXOR(\n  x: BigInt,\n  y: BigInt,\n): BigInt = {\n  call %0 = clo<\"BigIntBitwiseOp\">(\"^\", x, y)\n  return %0\n}","def <NUM>:BigInt::bitwiseOR(\n  x: BigInt,\n  y: BigInt,\n): BigInt = {\n  call %0 = clo<\"BigIntBitwiseOp\">(\"|\", x, y)\n  return %0\n}","def NormalCompletion(\n  value: Unknown[\"AnyValueExceptACompletionRecord\"],\n): Normal = {\n  return (record [CompletionRecord] {\n    \"Type\" : ~normal~,\n    \"Value\" : value,\n    \"Target\" : ~empty~,\n  })[#30]\n}","def ThrowCompletion(\n  value: ESValue,\n): Throw = {\n  %0 = (record [CompletionRecord] {\n    \"Type\" : ~throw~,\n    \"Value\" : value,\n    \"Target\" : ~empty~,\n  })[#31]\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def UpdateEmpty(\n  completionRecord: Completion,\n  value: Unknown[\"AnyValueExceptACompletionRecord\"],\n): Completion = {\n  assert (|| (! (|| (? completionRecord: Return) (? completionRecord: Throw))) (! (= completionRecord.Value ~empty~)))\n  if (! (= completionRecord.Value ~empty~)) {\n    assert (? completionRecord: Completion)\n    return completionRecord\n  }\n  %0 = (record [CompletionRecord] {\n    \"Type\" : completionRecord.Type,\n    \"Value\" : value,\n    \"Target\" : completionRecord.Target,\n  })[#32]\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def IsPropertyReference(\n  V: Record[ReferenceRecord],\n): Boolean = {\n  if (= V.Base ~unresolvable~) {\n    return false\n  }\n  if (? V.Base: Record[EnvironmentRecord]) {\n    return false\n  } else {\n    return true\n  }\n}","def IsUnresolvableReference(\n  V: Record[ReferenceRecord],\n): Boolean = {\n  if (= V.Base ~unresolvable~) {\n    return true\n  } else {\n    return false\n  }\n}","def IsSuperReference(\n  V: Record[ReferenceRecord],\n): Boolean = {\n  if (! (= V.ThisValue ~empty~)) {\n    return true\n  } else {\n    return false\n  }\n}","def IsPrivateReference(\n  V: Record[ReferenceRecord],\n): Boolean = {\n  if (? V.ReferencedName: Record[PrivateName]) {\n    return true\n  } else {\n    return false\n  }\n}","def GetValue(\n  V: ESValue | Record[ReferenceRecord],\n): Normal[ESValue] | Abrupt = {\n  if (! (? V: Record[ReferenceRecord])) {\n    if (? V: Completion) return V\n    call %0 = clo<\"NormalCompletion\">(V)\n    return %0\n  }\n  call %1 = clo<\"IsUnresolvableReference\">(V)\n  if (= %1 true) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%ReferenceError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  call %4 = clo<\"IsPropertyReference\">(V)\n  if (= %4 true) {\n    call %5 = clo<\"ToObject\">(V.Base)\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n    let baseObj = %5\n    call %6 = clo<\"IsPrivateReference\">(V)\n    if (= %6 true) {\n      call %7 = clo<\"PrivateGet\">(baseObj, V.ReferencedName)\n      assert (? %7: Completion)\n      return %7\n    }\n    call %9 = clo<\"GetThisValue\">(V)\n    call %8 = baseObj.Get(baseObj, V.ReferencedName, %9)\n    assert (? %8: Completion)\n    return %8\n  } else {\n    let base = V.Base\n    assert (? base: Record[EnvironmentRecord])\n    call %10 = base.GetBindingValue(base, V.ReferencedName, V.Strict)\n    assert (? %10: Completion)\n    return %10\n  }\n}","def PutValue(\n  V: ESValue | Record[ReferenceRecord],\n  W: ESValue,\n): Normal[Enum[~unused~]] | Abrupt = {\n  if (! (? V: Record[ReferenceRecord])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%ReferenceError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"IsUnresolvableReference\">(V)\n  if (= %2 true) {\n    if (= V.Strict true) {\n      call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%ReferenceError.prototype%\")\n      call %4 = clo<\"ThrowCompletion\">(%3)\n      return %4\n    }\n    call %5 = clo<\"GetGlobalObject\">()\n    let globalObj = %5\n    call %6 = clo<\"Set\">(globalObj, V.ReferencedName, W, false)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    call %7 = clo<\"NormalCompletion\">(~unused~)\n    return %7\n  }\n  call %8 = clo<\"IsPropertyReference\">(V)\n  if (= %8 true) {\n    call %9 = clo<\"ToObject\">(V.Base)\n    assert (? %9: Completion)\n    if (? %9: Abrupt) return %9\n    else %9 = %9.Value\n    let baseObj = %9\n    call %10 = clo<\"IsPrivateReference\">(V)\n    if (= %10 true) {\n      call %11 = clo<\"PrivateSet\">(baseObj, V.ReferencedName, W)\n      assert (? %11: Completion)\n      return %11\n    }\n    call %13 = clo<\"GetThisValue\">(V)\n    call %12 = baseObj.Set(baseObj, V.ReferencedName, W, %13)\n    assert (? %12: Completion)\n    if (? %12: Abrupt) return %12\n    else %12 = %12.Value\n    let succeeded = %12\n    if (&& (= succeeded false) (= V.Strict true)) {\n      call %14 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %15 = clo<\"ThrowCompletion\">(%14)\n      return %15\n    }\n    call %16 = clo<\"NormalCompletion\">(~unused~)\n    return %16\n  } else {\n    let base = V.Base\n    assert (? base: Record[EnvironmentRecord])\n    call %17 = base.SetMutableBinding(base, V.ReferencedName, W, V.Strict)\n    assert (? %17: Completion)\n    return %17\n  }\n}","def GetThisValue(\n  V: Record[ReferenceRecord],\n): ESValue = {\n  call %0 = clo<\"IsPropertyReference\">(V)\n  assert (= %0 true)\n  call %1 = clo<\"IsSuperReference\">(V)\n  if (= %1 true) {\n    return V.ThisValue\n  } else {\n    return V.Base\n  }\n}","def InitializeReferencedBinding(\n  V: Record[ReferenceRecord],\n  W: ESValue,\n): Normal[Enum[~unused~]] | Abrupt = {\n  call %0 = clo<\"IsUnresolvableReference\">(V)\n  assert (= %0 false)\n  let base = V.Base\n  assert (? base: Record[EnvironmentRecord])\n  call %1 = base.InitializeBinding(base, V.ReferencedName, W)\n  assert (? %1: Completion)\n  return %1\n}","def MakePrivateReference(\n  baseValue: ESValue,\n  privateIdentifier: String,\n): Record[ReferenceRecord] = {\n  let privEnv = @EXECUTION_STACK[0].PrivateEnvironment\n  assert (! (= privEnv null))\n  call %0 = clo<\"ResolvePrivateIdentifier\">(privEnv, privateIdentifier)\n  let privateName = %0\n  return (record [ReferenceRecord] {\n    \"Base\" : baseValue,\n    \"ReferencedName\" : privateName,\n    \"Strict\" : true,\n    \"ThisValue\" : ~empty~,\n  })[#33]\n}","def IsAccessorDescriptor(\n  Desc: Record[PropertyDescriptor] | Undefined,\n): Boolean = {\n  if (= Desc undefined) {\n    return false\n  }\n  if (exists Desc.Get) {\n    return true\n  }\n  if (exists Desc.Set) {\n    return true\n  }\n  return false\n}","def IsDataDescriptor(\n  Desc: Record[PropertyDescriptor] | Undefined,\n): Boolean = {\n  if (= Desc undefined) {\n    return false\n  }\n  if (exists Desc.Value) {\n    return true\n  }\n  if (exists Desc.Writable) {\n    return true\n  }\n  return false\n}","def IsGenericDescriptor(\n  Desc: Record[PropertyDescriptor] | Undefined,\n): Boolean = {\n  if (= Desc undefined) {\n    return false\n  }\n  call %0 = clo<\"IsAccessorDescriptor\">(Desc)\n  if (= %0 true) {\n    return false\n  }\n  call %1 = clo<\"IsDataDescriptor\">(Desc)\n  if (= %1 true) {\n    return false\n  }\n  return true\n}","def FromPropertyDescriptor(\n  Desc: Record[PropertyDescriptor] | Undefined,\n): Record[Object] | Undefined = {\n  if (= Desc undefined) {\n    return undefined\n  }\n  call %0 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Object.prototype%\"])\n  let obj = %0\n  assert (yet \"_obj_ is an extensible ordinary object with no own properties.\")\n  if (exists Desc.Value) {\n    call %1 = clo<\"CreateDataPropertyOrThrow\">(obj, \"value\", Desc.Value)\n    assert (? %1: Normal)\n    %1 = %1.Value\n  }\n  if (exists Desc.Writable) {\n    call %2 = clo<\"CreateDataPropertyOrThrow\">(obj, \"writable\", Desc.Writable)\n    assert (? %2: Normal)\n    %2 = %2.Value\n  }\n  if (exists Desc.Get) {\n    call %3 = clo<\"CreateDataPropertyOrThrow\">(obj, \"get\", Desc.Get)\n    assert (? %3: Normal)\n    %3 = %3.Value\n  }\n  if (exists Desc.Set) {\n    call %4 = clo<\"CreateDataPropertyOrThrow\">(obj, \"set\", Desc.Set)\n    assert (? %4: Normal)\n    %4 = %4.Value\n  }\n  if (exists Desc.Enumerable) {\n    call %5 = clo<\"CreateDataPropertyOrThrow\">(obj, \"enumerable\", Desc.Enumerable)\n    assert (? %5: Normal)\n    %5 = %5.Value\n  }\n  if (exists Desc.Configurable) {\n    call %6 = clo<\"CreateDataPropertyOrThrow\">(obj, \"configurable\", Desc.Configurable)\n    assert (? %6: Normal)\n    %6 = %6.Value\n  }\n  return obj\n}","def ToPropertyDescriptor(\n  Obj: ESValue,\n): Normal[Record[PropertyDescriptor]] | Throw = {\n  if (! (? Obj: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  let desc = (record [PropertyDescriptor])[#34]\n  call %2 = clo<\"HasProperty\">(Obj, \"enumerable\")\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let hasEnumerable = %2\n  if (= hasEnumerable true) {\n    call %3 = clo<\"Get\">(Obj, \"enumerable\")\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    call %4 = clo<\"ToBoolean\">(%3)\n    let enumerable = %4\n    desc.Enumerable = enumerable\n  }\n  call %5 = clo<\"HasProperty\">(Obj, \"configurable\")\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  let hasConfigurable = %5\n  if (= hasConfigurable true) {\n    call %6 = clo<\"Get\">(Obj, \"configurable\")\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    call %7 = clo<\"ToBoolean\">(%6)\n    let configurable = %7\n    desc.Configurable = configurable\n  }\n  call %8 = clo<\"HasProperty\">(Obj, \"value\")\n  assert (? %8: Completion)\n  if (? %8: Abrupt) return %8\n  else %8 = %8.Value\n  let hasValue = %8\n  if (= hasValue true) {\n    call %9 = clo<\"Get\">(Obj, \"value\")\n    assert (? %9: Completion)\n    if (? %9: Abrupt) return %9\n    else %9 = %9.Value\n    let value = %9\n    desc.Value = value\n  }\n  call %10 = clo<\"HasProperty\">(Obj, \"writable\")\n  assert (? %10: Completion)\n  if (? %10: Abrupt) return %10\n  else %10 = %10.Value\n  let hasWritable = %10\n  if (= hasWritable true) {\n    call %11 = clo<\"Get\">(Obj, \"writable\")\n    assert (? %11: Completion)\n    if (? %11: Abrupt) return %11\n    else %11 = %11.Value\n    call %12 = clo<\"ToBoolean\">(%11)\n    let writable = %12\n    desc.Writable = writable\n  }\n  call %13 = clo<\"HasProperty\">(Obj, \"get\")\n  assert (? %13: Completion)\n  if (? %13: Abrupt) return %13\n  else %13 = %13.Value\n  let hasGet = %13\n  if (= hasGet true) {\n    call %14 = clo<\"Get\">(Obj, \"get\")\n    assert (? %14: Completion)\n    if (? %14: Abrupt) return %14\n    else %14 = %14.Value\n    let getter = %14\n    call %15 = clo<\"IsCallable\">(getter)\n    if (&& (= %15 false) (! (= getter undefined))) {\n      call %16 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %17 = clo<\"ThrowCompletion\">(%16)\n      return %17\n    }\n    desc.Get = getter\n  }\n  call %18 = clo<\"HasProperty\">(Obj, \"set\")\n  assert (? %18: Completion)\n  if (? %18: Abrupt) return %18\n  else %18 = %18.Value\n  let hasSet = %18\n  if (= hasSet true) {\n    call %19 = clo<\"Get\">(Obj, \"set\")\n    assert (? %19: Completion)\n    if (? %19: Abrupt) return %19\n    else %19 = %19.Value\n    let setter = %19\n    call %20 = clo<\"IsCallable\">(setter)\n    if (&& (= %20 false) (! (= setter undefined))) {\n      call %21 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %22 = clo<\"ThrowCompletion\">(%21)\n      return %22\n    }\n    desc.Set = setter\n  }\n  if (|| (exists desc.Get) (exists desc.Set)) {\n    if (|| (exists desc.Value) (exists desc.Writable)) {\n      call %23 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %24 = clo<\"ThrowCompletion\">(%23)\n      return %24\n    }\n  }\n  if (? desc: Completion) return desc\n  call %25 = clo<\"NormalCompletion\">(desc)\n  return %25\n}","def CompletePropertyDescriptor(\n  Desc: Record[PropertyDescriptor],\n): Enum[~unused~] = {\n  let like = (record {\n    \"Value\" : undefined,\n    \"Writable\" : false,\n    \"Get\" : undefined,\n    \"Set\" : undefined,\n    \"Enumerable\" : false,\n    \"Configurable\" : false,\n  })[#35]\n  call %1 = clo<\"IsGenericDescriptor\">(Desc)\n  %0 = (= %1 true)\n  if %0 {} else {\n    call %2 = clo<\"IsDataDescriptor\">(Desc)\n    %0 = (= %2 true)\n  }\n  if %0 {\n    if (! (exists Desc.Value)) {\n      Desc.Value = like.Value\n    }\n    if (! (exists Desc.Writable)) {\n      Desc.Writable = like.Writable\n    }\n  } else {\n    if (! (exists Desc.Get)) {\n      Desc.Get = like.Get\n    }\n    if (! (exists Desc.Set)) {\n      Desc.Set = like.Set\n    }\n  }\n  if (! (exists Desc.Enumerable)) {\n    Desc.Enumerable = like.Enumerable\n  }\n  if (! (exists Desc.Configurable)) {\n    Desc.Configurable = like.Configurable\n  }\n  return ~unused~\n}","def CreateByteDataBlock(\n  size: NonNegInt,\n): Normal[Record[DataBlock]] | Throw = {\n  if (< (- (** 2 53) 1) size) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  (yet \"Let _db_ be a new Data Block value consisting of _size_ bytes. If it is impossible to create such a Data Block, throw a *RangeError* exception.\")\n  (yet \"Set all of the bytes of _db_ to 0.\")\n  if (? db: Completion) return db\n  call %2 = clo<\"NormalCompletion\">(db)\n  return %2\n}","def CreateSharedByteDataBlock(\n  size: NonNegInt,\n): Normal[Record[SharedDataBlock]] | Throw = {\n  (yet \"Let _db_ be a new Shared Data Block value consisting of _size_ bytes. If it is impossible to create such a Shared Data Block, throw a *RangeError* exception.\")\n  (yet \"Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\")\n  (yet \"Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\")\n  let zero = (list [0])[#36]\n  (yet \"For each index _i_ of _db_, do\\n  1. Append WriteSharedMemory { [[Order]]: ~init~, [[NoTear]]: *true*, [[Block]]: _db_, [[ByteIndex]]: _i_, [[ElementSize]]: 1, [[Payload]]: _zero_ } to _eventsRecord_.[[EventList]].\")\n  if (? db: Completion) return db\n  call %0 = clo<\"NormalCompletion\">(db)\n  return %0\n}","def CopyDataBlockBytes(\n  toBlock: Record[DataBlock | SharedDataBlock],\n  toIndex: NonNegInt,\n  fromBlock: Record[DataBlock | SharedDataBlock],\n  fromIndex: NonNegInt,\n  count: NonNegInt,\n): Enum[~unused~] = {\n  assert (yet \"_fromBlock_ and _toBlock_ are distinct values.\")\n  (yet \"Let _fromSize_ be the number of bytes in _fromBlock_.\")\n  assert (! (< fromSize (+ fromIndex count)))\n  (yet \"Let _toSize_ be the number of bytes in _toBlock_.\")\n  assert (! (< toSize (+ toIndex count)))\n  while (< 0 count) {\n    if (? fromBlock: Record[SharedDataBlock]) {\n      (yet \"Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\")\n      (yet \"Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\")\n      (yet \"Let _bytes_ be a List whose sole element is a nondeterministically chosen byte value.\")\n      nop\n      let readEvent = (record [ReadSharedMemory] {\n        \"Order\" : ~unordered~,\n        \"NoTear\" : true,\n        \"Block\" : fromBlock,\n        \"ByteIndex\" : fromIndex,\n        \"ElementSize\" : 1,\n      })[#37]\n      push eventsRecord.EventList < readEvent\n      push execution.ChosenValues < (record [ChosenValueRecord] {\n        \"Event\" : readEvent,\n        \"ChosenValue\" : bytes,\n      })[#38]\n      if (? toBlock: Record[SharedDataBlock]) {\n        push eventsRecord.EventList < (record [WriteSharedMemory] {\n          \"Order\" : ~unordered~,\n          \"NoTear\" : true,\n          \"Block\" : toBlock,\n          \"ByteIndex\" : toIndex,\n          \"ElementSize\" : 1,\n          \"Payload\" : bytes,\n        })[#39]\n      } else {\n        toBlock[toIndex] = bytes[0]\n      }\n    } else {\n      assert (! (? toBlock: Record[SharedDataBlock]))\n      toBlock[toIndex] = fromBlock[fromIndex]\n    }\n    toIndex = (+ toIndex 1)\n    fromIndex = (+ fromIndex 1)\n    count = (- count 1)\n  }\n  return ~unused~\n}","def ToPrimitive(\n  input: ESValue,\n  preferredType?: Enum[~number~, ~string~],\n): Normal[ESValue] | Throw = {\n  if (? input: Record[Object]) {\n    call %0 = clo<\"GetMethod\">(input, @SYMBOL.toPrimitive)\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let exoticToPrim = %0\n    if (! (= exoticToPrim undefined)) {\n      if (! (exists preferredType)) {\n        let hint = \"default\"\n      } else {\n        if (= preferredType ~string~) {\n          let hint = \"string\"\n        } else {\n          assert (= preferredType ~number~)\n          let hint = \"number\"\n        }\n      }\n      call %1 = clo<\"Call\">(exoticToPrim, input, (list [hint])[#40])\n      assert (? %1: Completion)\n      if (? %1: Abrupt) return %1\n      else %1 = %1.Value\n      let result = %1\n      if (! (? result: Record[Object])) {\n        if (? result: Completion) return result\n        call %2 = clo<\"NormalCompletion\">(result)\n        return %2\n      }\n      call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %4 = clo<\"ThrowCompletion\">(%3)\n      return %4\n    }\n    if (! (exists preferredType)) {\n      let preferredType = ~number~\n    }\n    call %5 = clo<\"OrdinaryToPrimitive\">(input, preferredType)\n    assert (? %5: Completion)\n    return %5\n  }\n  if (? input: Completion) return input\n  call %6 = clo<\"NormalCompletion\">(input)\n  return %6\n}","def OrdinaryToPrimitive(\n  O: Record[Object],\n  hint: Enum[~number~, ~string~],\n): Normal[ESValue] | Throw = {\n  if (= hint ~string~) {\n    let methodNames = (list [\"toString\", \"valueOf\"])[#41]\n  } else {\n    let methodNames = (list [\"valueOf\", \"toString\"])[#42]\n  }\n  %1 = methodNames\n  %0 = 0\n  while (< %0 (sizeof %1)) {\n    let name = %1[%0]\n    call %2 = clo<\"Get\">(O, name)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let method = %2\n    call %3 = clo<\"IsCallable\">(method)\n    if (= %3 true) {\n      call %4 = clo<\"Call\">(method, O)\n      assert (? %4: Completion)\n      if (? %4: Abrupt) return %4\n      else %4 = %4.Value\n      let result = %4\n      if (! (? result: Record[Object])) {\n        if (? result: Completion) return result\n        call %5 = clo<\"NormalCompletion\">(result)\n        return %5\n      }\n    }\n    %0 = (+ %0 1)\n  }\n  call %6 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n  call %7 = clo<\"ThrowCompletion\">(%6)\n  return %7\n}","def ToNumeric(\n  value: ESValue,\n): Normal[Number | BigInt] | Throw = {\n  call %0 = clo<\"ToPrimitive\">(value, ~number~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let primValue = %0\n  if (? primValue: BigInt) {\n    if (? primValue: Completion) return primValue\n    call %1 = clo<\"NormalCompletion\">(primValue)\n    return %1\n  }\n  call %2 = clo<\"ToNumber\">(primValue)\n  assert (? %2: Completion)\n  return %2\n}","def ToNumber(\n  argument: ESValue,\n): Normal[Number] | Throw = {\n  if (? argument: Number) {\n    if (? argument: Completion) return argument\n    call %0 = clo<\"NormalCompletion\">(argument)\n    return %0\n  }\n  if (|| (? argument: Record[Symbol]) (? argument: BigInt)) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  if (= argument undefined) {\n    call %3 = clo<\"NormalCompletion\">(NaN)\n    return %3\n  }\n  if (|| (= argument null) (= argument false)) {\n    call %4 = clo<\"NormalCompletion\">(0.0f)\n    return %4\n  }\n  if (= argument true) {\n    call %5 = clo<\"NormalCompletion\">(1.0f)\n    return %5\n  }\n  if (? argument: String) {\n    call %6 = clo<\"StringToNumber\">(argument)\n    if (? %6: Completion) return %6\n    call %7 = clo<\"NormalCompletion\">(%6)\n    return %7\n  }\n  assert (? argument: Record[Object])\n  call %8 = clo<\"ToPrimitive\">(argument, ~number~)\n  assert (? %8: Completion)\n  if (? %8: Abrupt) return %8\n  else %8 = %8.Value\n  let primValue = %8\n  assert (! (? primValue: Record[Object]))\n  call %9 = clo<\"ToNumber\">(primValue)\n  assert (? %9: Completion)\n  return %9\n}","def <SYNTAX>:StringNumericLiteral[0,0].StringNumericValue(\n  this: Ast[StringNumericLiteral[0]],\n): Number = {\n  return 0.0f\n}","def <SYNTAX>:StringNumericLiteral[0,1].StringNumericValue(\n  this: Ast[StringNumericLiteral[0]],\n): Number = {\n  return 0.0f\n}","def <SYNTAX>:StringNumericLiteral[1,0].StringNumericValue(\n  this: Ast[StringNumericLiteral[1]],\n): Number = {\n  sdo-call %0 = this[1]->StringNumericValue()\n  return %0\n}","def <SYNTAX>:StringNumericLiteral[1,1].StringNumericValue(\n  this: Ast[StringNumericLiteral[1]],\n): Number = {\n  sdo-call %0 = this[1]->StringNumericValue()\n  return %0\n}","def <SYNTAX>:StringNumericLiteral[1,2].StringNumericValue(\n  this: Ast[StringNumericLiteral[1]],\n): Number = {\n  sdo-call %0 = this[1]->StringNumericValue()\n  return %0\n}","def <SYNTAX>:StringNumericLiteral[1,3].StringNumericValue(\n  this: Ast[StringNumericLiteral[1]],\n): Number = {\n  sdo-call %0 = this[1]->StringNumericValue()\n  return %0\n}","def <SYNTAX>:StrNumericLiteral[1,0].StringNumericValue(\n  this: Ast[StrNumericLiteral[1]],\n): Number = {\n  sdo-call %0 = this[0]->MV()\n  return ([number] %0)\n}","def <SYNTAX>:StrDecimalLiteral[2,0].StringNumericValue(\n  this: Ast[StrDecimalLiteral[2]],\n): Number = {\n  sdo-call %0 = this[0]->StringNumericValue()\n  let a = %0\n  if (= a 0.0f) {\n    return -0.0f\n  }\n  return (- a)\n}","def <SYNTAX>:StrUnsignedDecimalLiteral[0,0].StringNumericValue(\n  this: Ast[StrUnsignedDecimalLiteral[0]],\n): Number = {\n  return +NUM_INF\n}","def <SYNTAX>:StrUnsignedDecimalLiteral[1,0].StringNumericValue(\n  this: Ast[StrUnsignedDecimalLiteral[1]],\n): Number = {\n  sdo-call %0 = this[0]->MV()\n  let a = %0\n  if (exists this[1]) {\n    sdo-call %1 = this[1]->MV()\n    let b = %1\n    (yet \"Let _n_ be the number of code points in the second |DecimalDigits|.\")\n  } else {\n    let b = 0\n    let n = 0\n  }\n  if (exists this[2]) {\n    sdo-call %2 = this[2]->MV()\n    let e = %2\n  } else {\n    let e = 0\n  }\n  call %3 = clo<\"RoundMVResult\">((* (+ a (* b (** 10 (- n)))) (** 10 e)))\n  return %3\n}","def <SYNTAX>:StrUnsignedDecimalLiteral[1,1].StringNumericValue(\n  this: Ast[StrUnsignedDecimalLiteral[1]],\n): Number = {\n  sdo-call %0 = this[0]->MV()\n  let a = %0\n  if (exists this[1]) {\n    sdo-call %1 = this[1]->MV()\n    let b = %1\n    (yet \"Let _n_ be the number of code points in the second |DecimalDigits|.\")\n  } else {\n    let b = 0\n    let n = 0\n  }\n  if (exists this[2]) {\n    sdo-call %2 = this[2]->MV()\n    let e = %2\n  } else {\n    let e = 0\n  }\n  call %3 = clo<\"RoundMVResult\">((* (+ a (* b (** 10 (- n)))) (** 10 e)))\n  return %3\n}","def <SYNTAX>:StrUnsignedDecimalLiteral[1,2].StringNumericValue(\n  this: Ast[StrUnsignedDecimalLiteral[1]],\n): Number = {\n  sdo-call %0 = this[0]->MV()\n  let a = %0\n  if (exists this[1]) {\n    sdo-call %1 = this[1]->MV()\n    let b = %1\n    (yet \"Let _n_ be the number of code points in the second |DecimalDigits|.\")\n  } else {\n    let b = 0\n    let n = 0\n  }\n  if (exists this[2]) {\n    sdo-call %2 = this[2]->MV()\n    let e = %2\n  } else {\n    let e = 0\n  }\n  call %3 = clo<\"RoundMVResult\">((* (+ a (* b (** 10 (- n)))) (** 10 e)))\n  return %3\n}","def <SYNTAX>:StrUnsignedDecimalLiteral[1,3].StringNumericValue(\n  this: Ast[StrUnsignedDecimalLiteral[1]],\n): Number = {\n  sdo-call %0 = this[0]->MV()\n  let a = %0\n  if (exists this[1]) {\n    sdo-call %1 = this[1]->MV()\n    let b = %1\n    (yet \"Let _n_ be the number of code points in the second |DecimalDigits|.\")\n  } else {\n    let b = 0\n    let n = 0\n  }\n  if (exists this[2]) {\n    sdo-call %2 = this[2]->MV()\n    let e = %2\n  } else {\n    let e = 0\n  }\n  call %3 = clo<\"RoundMVResult\">((* (+ a (* b (** 10 (- n)))) (** 10 e)))\n  return %3\n}","def <SYNTAX>:StrUnsignedDecimalLiteral[2,0].StringNumericValue(\n  this: Ast[StrUnsignedDecimalLiteral[2]],\n): Number = {\n  sdo-call %0 = this[0]->MV()\n  let b = %0\n  if (exists this[1]) {\n    sdo-call %1 = this[1]->MV()\n    let e = %1\n  } else {\n    let e = 0\n  }\n  (yet \"Let _n_ be the number of code points in |DecimalDigits|.\")\n  call %2 = clo<\"RoundMVResult\">((* b (** 10 (- e n))))\n  return %2\n}","def <SYNTAX>:StrUnsignedDecimalLiteral[2,1].StringNumericValue(\n  this: Ast[StrUnsignedDecimalLiteral[2]],\n): Number = {\n  sdo-call %0 = this[0]->MV()\n  let b = %0\n  if (exists this[1]) {\n    sdo-call %1 = this[1]->MV()\n    let e = %1\n  } else {\n    let e = 0\n  }\n  (yet \"Let _n_ be the number of code points in |DecimalDigits|.\")\n  call %2 = clo<\"RoundMVResult\">((* b (** 10 (- e n))))\n  return %2\n}","def <SYNTAX>:StrUnsignedDecimalLiteral[3,0].StringNumericValue(\n  this: Ast[StrUnsignedDecimalLiteral[3]],\n): Number = {\n  sdo-call %0 = this[0]->MV()\n  let a = %0\n  if (exists this[1]) {\n    sdo-call %1 = this[1]->MV()\n    let e = %1\n  } else {\n    let e = 0\n  }\n  call %2 = clo<\"RoundMVResult\">((* a (** 10 e)))\n  return %2\n}","def <SYNTAX>:StrUnsignedDecimalLiteral[3,1].StringNumericValue(\n  this: Ast[StrUnsignedDecimalLiteral[3]],\n): Number = {\n  sdo-call %0 = this[0]->MV()\n  let a = %0\n  if (exists this[1]) {\n    sdo-call %1 = this[1]->MV()\n    let e = %1\n  } else {\n    let e = 0\n  }\n  call %2 = clo<\"RoundMVResult\">((* a (** 10 e)))\n  return %2\n}","def RoundMVResult(\n  n: Unknown[\"MathematicalValue\"],\n): Number = {\n  (yet \"If the decimal representation of _n_ has 20 or fewer significant digits, return ùîΩ(_n_).\")\n  (yet \"Let _option1_ be the mathematical value denoted by the result of replacing each significant digit in the decimal representation of _n_ after the 20th with a 0 digit.\")\n  (yet \"Let _option2_ be the mathematical value denoted by the result of replacing each significant digit in the decimal representation of _n_ after the 20th with a 0 digit and then incrementing it at the 20th position (with carrying as necessary).\")\n  (yet \"Let _chosen_ be an implementation-defined choice of either _option1_ or _option2_.\")\n  return ([number] chosen)\n}","def ToIntegerOrInfinity(\n  argument: ESValue,\n): Normal[Int | INF] | Throw = {\n  call %0 = clo<\"ToNumber\">(argument)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let number = %0\n  if (|| (|| (= number NaN) (= number 0.0f)) (= number -0.0f)) {\n    call %1 = clo<\"NormalCompletion\">(0)\n    return %1\n  }\n  if (= number +NUM_INF) {\n    call %2 = clo<\"NormalCompletion\">(+INF)\n    return %2\n  }\n  if (= number -NUM_INF) {\n    call %3 = clo<\"NormalCompletion\">(-INF)\n    return %3\n  }\n  %4 = ([math] number)\n  if (< %4 0) %4 = (- (floor (- %4)))\n  else %4 = (floor %4)\n  if (? %4: Completion) return %4\n  call %5 = clo<\"NormalCompletion\">(%4)\n  return %5\n}","def ToInt32(\n  argument: ESValue,\n): Normal[Number[Int]] | Throw = {\n  call %0 = clo<\"ToNumber\">(argument)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let number = %0\n  if (|| (|| (= number NaN) (|| (= number +NUM_INF) (= number -NUM_INF))) (|| (= number 0.0f) (= number -0.0f))) {\n    call %1 = clo<\"NormalCompletion\">(0.0f)\n    return %1\n  }\n  %2 = ([math] number)\n  if (< %2 0) %2 = (- (floor (- %2)))\n  else %2 = (floor %2)\n  let int = %2\n  let int32bit = (% int (** 2 32))\n  if (! (< int32bit (** 2 31))) {\n    %3 = ([number] (- int32bit (** 2 32)))\n    if (? %3: Completion) return %3\n    call %4 = clo<\"NormalCompletion\">(%3)\n    return %4\n  } else {\n    %5 = ([number] int32bit)\n    if (? %5: Completion) return %5\n    call %6 = clo<\"NormalCompletion\">(%5)\n    return %6\n  }\n}","def ToUint32(\n  argument: ESValue,\n): Normal[Number[Int]] | Throw = {\n  call %0 = clo<\"ToNumber\">(argument)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let number = %0\n  if (|| (|| (= number NaN) (|| (= number +NUM_INF) (= number -NUM_INF))) (|| (= number 0.0f) (= number -0.0f))) {\n    call %1 = clo<\"NormalCompletion\">(0.0f)\n    return %1\n  }\n  %2 = ([math] number)\n  if (< %2 0) %2 = (- (floor (- %2)))\n  else %2 = (floor %2)\n  let int = %2\n  let int32bit = (% int (** 2 32))\n  %3 = ([number] int32bit)\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def ToInt16(\n  argument: ESValue,\n): Normal[Number[Int]] | Throw = {\n  call %0 = clo<\"ToNumber\">(argument)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let number = %0\n  if (|| (|| (= number NaN) (|| (= number +NUM_INF) (= number -NUM_INF))) (|| (= number 0.0f) (= number -0.0f))) {\n    call %1 = clo<\"NormalCompletion\">(0.0f)\n    return %1\n  }\n  %2 = ([math] number)\n  if (< %2 0) %2 = (- (floor (- %2)))\n  else %2 = (floor %2)\n  let int = %2\n  let int16bit = (% int (** 2 16))\n  if (! (< int16bit (** 2 15))) {\n    %3 = ([number] (- int16bit (** 2 16)))\n    if (? %3: Completion) return %3\n    call %4 = clo<\"NormalCompletion\">(%3)\n    return %4\n  } else {\n    %5 = ([number] int16bit)\n    if (? %5: Completion) return %5\n    call %6 = clo<\"NormalCompletion\">(%5)\n    return %6\n  }\n}","def ToUint16(\n  argument: ESValue,\n): Normal[Number[Int]] | Throw = {\n  call %0 = clo<\"ToNumber\">(argument)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let number = %0\n  if (|| (|| (= number NaN) (|| (= number +NUM_INF) (= number -NUM_INF))) (|| (= number 0.0f) (= number -0.0f))) {\n    call %1 = clo<\"NormalCompletion\">(0.0f)\n    return %1\n  }\n  %2 = ([math] number)\n  if (< %2 0) %2 = (- (floor (- %2)))\n  else %2 = (floor %2)\n  let int = %2\n  let int16bit = (% int (** 2 16))\n  %3 = ([number] int16bit)\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def ToInt8(\n  argument: ESValue,\n): Normal[Number[Int]] | Throw = {\n  call %0 = clo<\"ToNumber\">(argument)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let number = %0\n  if (|| (|| (= number NaN) (|| (= number +NUM_INF) (= number -NUM_INF))) (|| (= number 0.0f) (= number -0.0f))) {\n    call %1 = clo<\"NormalCompletion\">(0.0f)\n    return %1\n  }\n  %2 = ([math] number)\n  if (< %2 0) %2 = (- (floor (- %2)))\n  else %2 = (floor %2)\n  let int = %2\n  let int8bit = (% int (** 2 8))\n  if (! (< int8bit (** 2 7))) {\n    %3 = ([number] (- int8bit (** 2 8)))\n    if (? %3: Completion) return %3\n    call %4 = clo<\"NormalCompletion\">(%3)\n    return %4\n  } else {\n    %5 = ([number] int8bit)\n    if (? %5: Completion) return %5\n    call %6 = clo<\"NormalCompletion\">(%5)\n    return %6\n  }\n}","def ToUint8(\n  argument: ESValue,\n): Normal[Number[Int]] | Throw = {\n  call %0 = clo<\"ToNumber\">(argument)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let number = %0\n  if (|| (|| (= number NaN) (|| (= number +NUM_INF) (= number -NUM_INF))) (|| (= number 0.0f) (= number -0.0f))) {\n    call %1 = clo<\"NormalCompletion\">(0.0f)\n    return %1\n  }\n  %2 = ([math] number)\n  if (< %2 0) %2 = (- (floor (- %2)))\n  else %2 = (floor %2)\n  let int = %2\n  let int8bit = (% int (** 2 8))\n  %3 = ([number] int8bit)\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def ToUint8Clamp(\n  argument: ESValue,\n): Normal[Number[Int]] | Throw = {\n  call %0 = clo<\"ToNumber\">(argument)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let number = %0\n  if (= number NaN) {\n    call %1 = clo<\"NormalCompletion\">(0.0f)\n    return %1\n  }\n  (yet \"Let _mv_ be the extended mathematical value of _number_.\")\n  call %2 = clo<\"__CLAMP__\">(mv, 0, 255)\n  let clamped = %2\n  let f = (floor clamped)\n  if (< clamped (+ f 0.5)) {\n    %3 = ([number] f)\n    if (? %3: Completion) return %3\n    call %4 = clo<\"NormalCompletion\">(%3)\n    return %4\n  }\n  if (< (+ f 0.5) clamped) {\n    %5 = ([number] (+ f 1))\n    if (? %5: Completion) return %5\n    call %6 = clo<\"NormalCompletion\">(%5)\n    return %6\n  }\n  (yet \"If _f_ is even, return ùîΩ(_f_). Otherwise, return ùîΩ(_f_ + 1).\")\n}","def ToBigInt64(\n  argument: ESValue,\n): Normal[BigInt] | Throw = {\n  call %0 = clo<\"ToBigInt\">(argument)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  let int64bit = (% ([math] n) (** 2 64))\n  if (! (< int64bit (** 2 63))) {\n    %1 = ([bigInt] (- int64bit (** 2 64)))\n    if (? %1: Completion) return %1\n    call %2 = clo<\"NormalCompletion\">(%1)\n    return %2\n  } else {\n    %3 = ([bigInt] int64bit)\n    if (? %3: Completion) return %3\n    call %4 = clo<\"NormalCompletion\">(%3)\n    return %4\n  }\n}","def ToBigUint64(\n  argument: ESValue,\n): Normal[BigInt] | Throw = {\n  call %0 = clo<\"ToBigInt\">(argument)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  let int64bit = (% ([math] n) (** 2 64))\n  %1 = ([bigInt] int64bit)\n  if (? %1: Completion) return %1\n  call %2 = clo<\"NormalCompletion\">(%1)\n  return %2\n}","def ToString(\n  argument: ESValue,\n): Normal[String] | Throw = {\n  if (? argument: String) {\n    if (? argument: Completion) return argument\n    call %0 = clo<\"NormalCompletion\">(argument)\n    return %0\n  }\n  if (? argument: Record[Symbol]) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  if (= argument undefined) {\n    call %3 = clo<\"NormalCompletion\">(\"undefined\")\n    return %3\n  }\n  if (= argument null) {\n    call %4 = clo<\"NormalCompletion\">(\"null\")\n    return %4\n  }\n  if (= argument true) {\n    call %5 = clo<\"NormalCompletion\">(\"true\")\n    return %5\n  }\n  if (= argument false) {\n    call %6 = clo<\"NormalCompletion\">(\"false\")\n    return %6\n  }\n  if (? argument: Number) {\n    call %7 = clo<\"Number::toString\">(argument, 10)\n    if (? %7: Completion) return %7\n    call %8 = clo<\"NormalCompletion\">(%7)\n    return %8\n  }\n  if (? argument: BigInt) {\n    call %9 = clo<\"BigInt::toString\">(argument, 10)\n    if (? %9: Completion) return %9\n    call %10 = clo<\"NormalCompletion\">(%9)\n    return %10\n  }\n  assert (? argument: Record[Object])\n  call %11 = clo<\"ToPrimitive\">(argument, ~string~)\n  assert (? %11: Completion)\n  if (? %11: Abrupt) return %11\n  else %11 = %11.Value\n  let primValue = %11\n  assert (! (? primValue: Record[Object]))\n  call %12 = clo<\"ToString\">(primValue)\n  assert (? %12: Completion)\n  return %12\n}","def ToPropertyKey(\n  argument: ESValue,\n): Normal[Record[Symbol] | String] | Throw = {\n  call %0 = clo<\"ToPrimitive\">(argument, ~string~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let key = %0\n  if (? key: Record[Symbol]) {\n    if (? key: Completion) return key\n    call %1 = clo<\"NormalCompletion\">(key)\n    return %1\n  }\n  call %2 = clo<\"ToString\">(key)\n  assert (? %2: Normal)\n  return %2\n}","def ToLength(\n  argument: ESValue,\n): Normal[Number[Int]] | Throw = {\n  call %0 = clo<\"ToIntegerOrInfinity\">(argument)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let len = %0\n  if (! (< 0 len)) {\n    call %1 = clo<\"NormalCompletion\">(0.0f)\n    return %1\n  }\n  %2 = ([number] (min len (- (** 2 53) 1)))\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def CanonicalNumericIndexString(\n  argument: String,\n): Number | Undefined = {\n  if (= argument \"-0\") {\n    return -0.0f\n  }\n  call %0 = clo<\"ToNumber\">(argument)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let n = %0\n  call %1 = clo<\"ToString\">(n)\n  assert (? %1: Normal)\n  %1 = %1.Value\n  if (= %1 argument) {\n    return n\n  }\n  return undefined\n}","def ToIndex(\n  value: ESValue,\n): Normal[NonNegInt] | Throw = {\n  call %0 = clo<\"ToIntegerOrInfinity\">(value)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let integer = %0\n  if (|| (< integer 0) (< (- (** 2 53) 1) integer)) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  if (? integer: Completion) return integer\n  call %3 = clo<\"NormalCompletion\">(integer)\n  return %3\n}","def IsArray(\n  argument: ESValue,\n): Normal[Boolean] | Throw = {\n  if (! (? argument: Record[Object])) {\n    call %0 = clo<\"NormalCompletion\">(false)\n    return %0\n  }\n  if (? argument: Record[Array]) {\n    call %1 = clo<\"NormalCompletion\">(true)\n    return %1\n  }\n  if (? argument: Record[ProxyExoticObject]) {\n    call %2 = clo<\"ValidateNonRevokedProxy\">(argument)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let proxyTarget = argument.ProxyTarget\n    call %3 = clo<\"IsArray\">(proxyTarget)\n    assert (? %3: Completion)\n    return %3\n  }\n  call %4 = clo<\"NormalCompletion\">(false)\n  return %4\n}","def IsCallable(\n  argument: ESValue,\n): Boolean = {\n  if (! (? argument: Record[Object])) {\n    return false\n  }\n  if (exists argument.Call) {\n    return true\n  }\n  return false\n}","def IsConstructor(\n  argument: ESValue,\n): Boolean = {\n  if (! (? argument: Record[Object])) {\n    return false\n  }\n  if (exists argument.Construct) {\n    return true\n  }\n  return false\n}","def IsExtensible(\n  O: Record[Object],\n): Normal[Boolean] | Throw = {\n  call %0 = O.IsExtensible(O)\n  assert (? %0: Completion)\n  return %0\n}","def IsIntegralNumber(\n  argument: ESValue,\n): Boolean = {\n  if (! (? argument: Number)) {\n    return false\n  }\n  if (|| (= argument NaN) (|| (= argument +NUM_INF) (= argument -NUM_INF))) {\n    return false\n  }\n  %0 = ([math] argument)\n  if (< %0 0) %0 = (- (floor (- %0)))\n  else %0 = (floor %0)\n  if (! (== %0 ([math] argument))) {\n    return false\n  }\n  return true\n}","def IsPropertyKey(\n  argument: ESValue,\n): Boolean = {\n  if (? argument: String) {\n    return true\n  }\n  if (? argument: Record[Symbol]) {\n    return true\n  }\n  return false\n}","def IsRegExp(\n  argument: ESValue,\n): Normal[Boolean] | Throw = {\n  if (! (? argument: Record[Object])) {\n    call %0 = clo<\"NormalCompletion\">(false)\n    return %0\n  }\n  call %1 = clo<\"Get\">(argument, @SYMBOL.match)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let matcher = %1\n  if (! (= matcher undefined)) {\n    call %2 = clo<\"ToBoolean\">(matcher)\n    if (? %2: Completion) return %2\n    call %3 = clo<\"NormalCompletion\">(%2)\n    return %3\n  }\n  if (exists argument.RegExpMatcher) {\n    call %4 = clo<\"NormalCompletion\">(true)\n    return %4\n  }\n  call %5 = clo<\"NormalCompletion\">(false)\n  return %5\n}","def IsStringWellFormedUnicode(\n  string: String,\n): Boolean = {\n  let len = (sizeof string)\n  let k = 0\n  while (< k len) {\n    call %0 = clo<\"CodePointAt\">(string, k)\n    let cp = %0\n    if (= cp.IsUnpairedSurrogate true) {\n      return false\n    }\n    k = (+ k cp.CodeUnitCount)\n  }\n  return true\n}","def SameValue(\n  x: ESValue,\n  y: ESValue,\n): Boolean = {\n  if (! (= (typeof x) (typeof y))) {\n    return false\n  }\n  if (? x: Number) {\n    call %0 = clo<\"Number::sameValue\">(x, y)\n    return %0\n  }\n  call %1 = clo<\"SameValueNonNumber\">(x, y)\n  return %1\n}","def SameValueZero(\n  x: ESValue,\n  y: ESValue,\n): Boolean = {\n  if (! (= (typeof x) (typeof y))) {\n    return false\n  }\n  if (? x: Number) {\n    call %0 = clo<\"Number::sameValueZero\">(x, y)\n    return %0\n  }\n  call %1 = clo<\"SameValueNonNumber\">(x, y)\n  return %1\n}","def SameValueNonNumber(\n  x: Unknown[\"ECMAScriptLanguageValue,ButNotANumber\"],\n  y: Unknown[\"ECMAScriptLanguageValue,ButNotANumber\"],\n): Boolean = {\n  assert (= (typeof x) (typeof y))\n  if (|| (= x null) (= x undefined)) {\n    return true\n  }\n  if (? x: BigInt) {\n    call %0 = clo<\"BigInt::equal\">(x, y)\n    return %0\n  }\n  if (? x: String) {\n    if (= x y) return true\n    else return false\n  }\n  if (? x: Boolean) {\n    if (|| (&& (= x true) (= y true)) (&& (= x false) (= y false))) return true\n    else return false\n  }\n  nop\n  if (= x y) {\n    return true\n  } else {\n    return false\n  }\n}","def IsLessThan(\n  x: ESValue,\n  y: ESValue,\n  LeftFirst: Boolean,\n): Normal[Boolean | Undefined] | Throw = {\n  if (= LeftFirst true) {\n    call %0 = clo<\"ToPrimitive\">(x, ~number~)\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let px = %0\n    call %1 = clo<\"ToPrimitive\">(y, ~number~)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let py = %1\n  } else {\n    nop\n    call %2 = clo<\"ToPrimitive\">(y, ~number~)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let py = %2\n    call %3 = clo<\"ToPrimitive\">(x, ~number~)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let px = %3\n  }\n  if (&& (? px: String) (? py: String)) {\n    let lx = (sizeof px)\n    let ly = (sizeof py)\n    let i = 0\n    while (! (< (- (min lx ly) 1) i)) {\n      let cx = ([math] px[i])\n      let cy = ([math] py[i])\n      if (< cx cy) {\n        call %4 = clo<\"NormalCompletion\">(true)\n        return %4\n      }\n      if (< cy cx) {\n        call %5 = clo<\"NormalCompletion\">(false)\n        return %5\n      }\n      i = (+ i 1)\n    }\n    if (< lx ly) {\n      call %6 = clo<\"NormalCompletion\">(true)\n      return %6\n    } else {\n      call %7 = clo<\"NormalCompletion\">(false)\n      return %7\n    }\n  } else {\n    if (&& (? px: BigInt) (? py: String)) {\n      call %8 = clo<\"StringToBigInt\">(py)\n      let ny = %8\n      if (= ny undefined) {\n        call %9 = clo<\"NormalCompletion\">(undefined)\n        return %9\n      }\n      call %10 = clo<\"BigInt::lessThan\">(px, ny)\n      if (? %10: Completion) return %10\n      call %11 = clo<\"NormalCompletion\">(%10)\n      return %11\n    }\n    if (&& (? px: String) (? py: BigInt)) {\n      call %12 = clo<\"StringToBigInt\">(px)\n      let nx = %12\n      if (= nx undefined) {\n        call %13 = clo<\"NormalCompletion\">(undefined)\n        return %13\n      }\n      call %14 = clo<\"BigInt::lessThan\">(nx, py)\n      if (? %14: Completion) return %14\n      call %15 = clo<\"NormalCompletion\">(%14)\n      return %15\n    }\n    nop\n    call %16 = clo<\"ToNumeric\">(px)\n    assert (? %16: Completion)\n    if (? %16: Abrupt) return %16\n    else %16 = %16.Value\n    let nx = %16\n    call %17 = clo<\"ToNumeric\">(py)\n    assert (? %17: Completion)\n    if (? %17: Abrupt) return %17\n    else %17 = %17.Value\n    let ny = %17\n    if (= (typeof nx) (typeof ny)) {\n      if (? nx: Number) {\n        call %18 = clo<\"Number::lessThan\">(nx, ny)\n        if (? %18: Completion) return %18\n        call %19 = clo<\"NormalCompletion\">(%18)\n        return %19\n      } else {\n        assert (? nx: BigInt)\n        call %20 = clo<\"BigInt::lessThan\">(nx, ny)\n        if (? %20: Completion) return %20\n        call %21 = clo<\"NormalCompletion\">(%20)\n        return %21\n      }\n    }\n    assert (|| (&& (? nx: BigInt) (? ny: Number)) (&& (? nx: Number) (? ny: BigInt)))\n    if (|| (= nx NaN) (= ny NaN)) {\n      call %22 = clo<\"NormalCompletion\">(undefined)\n      return %22\n    }\n    if (|| (= nx -NUM_INF) (= ny +NUM_INF)) {\n      call %23 = clo<\"NormalCompletion\">(true)\n      return %23\n    }\n    if (|| (= nx +NUM_INF) (= ny -NUM_INF)) {\n      call %24 = clo<\"NormalCompletion\">(false)\n      return %24\n    }\n    if (< ([math] nx) ([math] ny)) {\n      call %25 = clo<\"NormalCompletion\">(true)\n      return %25\n    } else {\n      call %26 = clo<\"NormalCompletion\">(false)\n      return %26\n    }\n  }\n}","def IsLooselyEqual(\n  x: ESValue,\n  y: ESValue,\n): Normal[Boolean] | Throw = {\n  if (= (typeof x) (typeof y)) {\n    call %0 = clo<\"IsStrictlyEqual\">(x, y)\n    if (? %0: Completion) return %0\n    call %1 = clo<\"NormalCompletion\">(%0)\n    return %1\n  }\n  if (&& (= x null) (= y undefined)) {\n    call %2 = clo<\"NormalCompletion\">(true)\n    return %2\n  }\n  if (&& (= x undefined) (= y null)) {\n    call %3 = clo<\"NormalCompletion\">(true)\n    return %3\n  }\n  nop\n  if (&& (? x: Number) (? y: String)) {\n    call %4 = clo<\"ToNumber\">(y)\n    assert (? %4: Normal)\n    %4 = %4.Value\n    call %5 = clo<\"IsLooselyEqual\">(x, %4)\n    assert (? %5: Normal)\n    return %5\n  }\n  if (&& (? x: String) (? y: Number)) {\n    call %6 = clo<\"ToNumber\">(x)\n    assert (? %6: Normal)\n    %6 = %6.Value\n    call %7 = clo<\"IsLooselyEqual\">(%6, y)\n    assert (? %7: Normal)\n    return %7\n  }\n  if (&& (? x: BigInt) (? y: String)) {\n    call %8 = clo<\"StringToBigInt\">(y)\n    let n = %8\n    if (= n undefined) {\n      call %9 = clo<\"NormalCompletion\">(false)\n      return %9\n    }\n    call %10 = clo<\"IsLooselyEqual\">(x, n)\n    assert (? %10: Normal)\n    return %10\n  }\n  if (&& (? x: String) (? y: BigInt)) {\n    call %11 = clo<\"IsLooselyEqual\">(y, x)\n    assert (? %11: Normal)\n    return %11\n  }\n  if (? x: Boolean) {\n    call %12 = clo<\"ToNumber\">(x)\n    assert (? %12: Normal)\n    %12 = %12.Value\n    call %13 = clo<\"IsLooselyEqual\">(%12, y)\n    assert (? %13: Normal)\n    return %13\n  }\n  if (? y: Boolean) {\n    call %14 = clo<\"ToNumber\">(y)\n    assert (? %14: Normal)\n    %14 = %14.Value\n    call %15 = clo<\"IsLooselyEqual\">(x, %14)\n    assert (? %15: Normal)\n    return %15\n  }\n  if (&& (|| (|| (|| (? x: String) (? x: Number)) (? x: BigInt)) (? x: Record[Symbol])) (? y: Record[Object])) {\n    call %16 = clo<\"ToPrimitive\">(y)\n    assert (? %16: Completion)\n    if (? %16: Abrupt) return %16\n    else %16 = %16.Value\n    call %17 = clo<\"IsLooselyEqual\">(x, %16)\n    assert (? %17: Normal)\n    return %17\n  }\n  if (&& (? x: Record[Object]) (|| (|| (|| (? y: String) (? y: Number)) (? y: BigInt)) (? y: Record[Symbol]))) {\n    call %18 = clo<\"ToPrimitive\">(x)\n    assert (? %18: Completion)\n    if (? %18: Abrupt) return %18\n    else %18 = %18.Value\n    call %19 = clo<\"IsLooselyEqual\">(%18, y)\n    assert (? %19: Normal)\n    return %19\n  }\n  if (|| (&& (? x: BigInt) (? y: Number)) (&& (? x: Number) (? y: BigInt))) {\n    if (|| (|| (= x NaN) (|| (= x +NUM_INF) (= x -NUM_INF))) (|| (= y NaN) (|| (= y +NUM_INF) (= y -NUM_INF)))) {\n      call %20 = clo<\"NormalCompletion\">(false)\n      return %20\n    }\n    if (== ([math] x) ([math] y)) {\n      call %21 = clo<\"NormalCompletion\">(true)\n      return %21\n    } else {\n      call %22 = clo<\"NormalCompletion\">(false)\n      return %22\n    }\n  }\n  call %23 = clo<\"NormalCompletion\">(false)\n  return %23\n}","def IsStrictlyEqual(\n  x: ESValue,\n  y: ESValue,\n): Boolean = {\n  if (! (= (typeof x) (typeof y))) {\n    return false\n  }\n  if (? x: Number) {\n    call %0 = clo<\"Number::equal\">(x, y)\n    return %0\n  }\n  call %1 = clo<\"SameValueNonNumber\">(x, y)\n  return %1\n}","def MakeBasicObject(\n  internalSlotsList: List[String],\n): Record[Object] = {\n  call obj = clo<\"__NEW_OBJ__\">()\n  let idx = 0\n  while (< idx (sizeof internalSlotsList)) {\n    expand obj[internalSlotsList[idx]]\n    idx = (+ idx 1)\n  }\n  nop\n  assert (yet \"If the caller will not be overriding both _obj_'s [[GetPrototypeOf]] and [[SetPrototypeOf]] essential internal methods, then _internalSlotsList_ contains [[Prototype]].\")\n  assert (yet \"If the caller will not be overriding all of _obj_'s [[SetPrototypeOf]], [[IsExtensible]], and [[PreventExtensions]] essential internal methods, then _internalSlotsList_ contains [[Extensible]].\")\n  if (contains internalSlotsList \"Extensible\") {\n    obj.Extensible = true\n  }\n  return obj\n}","def Get(\n  O: Record[Object],\n  P: Record[Symbol] | String,\n): Normal[ESValue] | Throw = {\n  call %0 = O.Get(O, P, O)\n  assert (? %0: Completion)\n  return %0\n}","def GetV(\n  V: ESValue,\n  P: Record[Symbol] | String,\n): Normal[ESValue] | Throw = {\n  call %0 = clo<\"ToObject\">(V)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = O.Get(O, P, V)\n  assert (? %1: Completion)\n  return %1\n}","def Set(\n  O: Record[Object],\n  P: Record[Symbol] | String,\n  V: ESValue,\n  Throw: Boolean,\n): Normal[Enum[~unused~]] | Throw = {\n  call %0 = O.Set(O, P, V, O)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let success = %0\n  if (&& (= success false) (= Throw true)) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  call %3 = clo<\"NormalCompletion\">(~unused~)\n  return %3\n}","def CreateDataProperty(\n  O: Record[Object],\n  P: Record[Symbol] | String,\n  V: ESValue,\n): Normal[Boolean] | Throw = {\n  let newDesc = (record [PropertyDescriptor] {\n    \"Value\" : V,\n    \"Writable\" : true,\n    \"Enumerable\" : true,\n    \"Configurable\" : true,\n  })[#43]\n  call %0 = O.DefineOwnProperty(O, P, newDesc)\n  assert (? %0: Completion)\n  return %0\n}","def CreateDataPropertyOrThrow(\n  O: Record[Object],\n  P: Record[Symbol] | String,\n  V: ESValue,\n): Normal[Enum[~unused~]] | Throw = {\n  call %0 = clo<\"CreateDataProperty\">(O, P, V)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let success = %0\n  if (= success false) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  call %3 = clo<\"NormalCompletion\">(~unused~)\n  return %3\n}","def CreateNonEnumerableDataPropertyOrThrow(\n  O: Record[Object],\n  P: Record[Symbol] | String,\n  V: ESValue,\n): Enum[~unused~] = {\n  assert (&& (? O: Record[OrdinaryObject]) O.Extensible)\n  let newDesc = (record [PropertyDescriptor] {\n    \"Value\" : V,\n    \"Writable\" : true,\n    \"Enumerable\" : false,\n    \"Configurable\" : true,\n  })[#44]\n  call %0 = clo<\"DefinePropertyOrThrow\">(O, P, newDesc)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  return ~unused~\n}","def DefinePropertyOrThrow(\n  O: Record[Object],\n  P: Record[Symbol] | String,\n  desc: Record[PropertyDescriptor],\n): Normal[Enum[~unused~]] | Throw = {\n  call %0 = O.DefineOwnProperty(O, P, desc)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let success = %0\n  if (= success false) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  call %3 = clo<\"NormalCompletion\">(~unused~)\n  return %3\n}","def DeletePropertyOrThrow(\n  O: Record[Object],\n  P: Record[Symbol] | String,\n): Normal[Enum[~unused~]] | Throw = {\n  call %0 = O.Delete(O, P)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let success = %0\n  if (= success false) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  call %3 = clo<\"NormalCompletion\">(~unused~)\n  return %3\n}","def GetMethod(\n  V: ESValue,\n  P: Record[Symbol] | String,\n): Normal[Record[FunctionObject] | Undefined] | Throw = {\n  call %0 = clo<\"GetV\">(V, P)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let func = %0\n  if (|| (= func undefined) (= func null)) {\n    call %1 = clo<\"NormalCompletion\">(undefined)\n    return %1\n  }\n  call %2 = clo<\"IsCallable\">(func)\n  if (= %2 false) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  if (? func: Completion) return func\n  call %5 = clo<\"NormalCompletion\">(func)\n  return %5\n}","def HasProperty(\n  O: Record[Object],\n  P: Record[Symbol] | String,\n): Normal[Boolean] | Throw = {\n  call %0 = O.HasProperty(O, P)\n  assert (? %0: Completion)\n  return %0\n}","def HasOwnProperty(\n  O: Record[Object],\n  P: Record[Symbol] | String,\n): Normal[Boolean] | Throw = {\n  call %0 = O.GetOwnProperty(O, P)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let desc = %0\n  if (= desc undefined) {\n    call %1 = clo<\"NormalCompletion\">(false)\n    return %1\n  }\n  call %2 = clo<\"NormalCompletion\">(true)\n  return %2\n}","def Call(\n  F: ESValue,\n  V: ESValue,\n  argumentsList?: List[ESValue],\n): Normal[ESValue] | Throw = {\n  if (! (exists argumentsList)) {\n    argumentsList = (list [])[#45]\n  }\n  call %0 = clo<\"IsCallable\">(F)\n  if (= %0 false) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  call %3 = F.Call(F, V, argumentsList)\n  assert (? %3: Completion)\n  return %3\n}","def Construct(\n  F: Record[Constructor],\n  argumentsList?: List[ESValue],\n  newTarget?: Record[Constructor],\n): Normal[Record[Object]] | Throw = {\n  if (! (exists newTarget)) {\n    newTarget = F\n  }\n  if (! (exists argumentsList)) {\n    argumentsList = (list [])[#46]\n  }\n  call %0 = F.Construct(F, argumentsList, newTarget)\n  assert (? %0: Completion)\n  return %0\n}","def SetIntegrityLevel(\n  O: Record[Object],\n  level: Enum[~frozen~, ~sealed~],\n): Normal[Boolean] | Throw = {\n  call %0 = O.PreventExtensions(O)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let status = %0\n  if (= status false) {\n    call %1 = clo<\"NormalCompletion\">(false)\n    return %1\n  }\n  call %2 = O.OwnPropertyKeys(O)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let keys = %2\n  if (= level ~sealed~) {\n    %4 = keys\n    %3 = 0\n    while (< %3 (sizeof %4)) {\n      let k = %4[%3]\n      call %5 = clo<\"DefinePropertyOrThrow\">(O, k, (record [PropertyDescriptor] {\n        \"Configurable\" : false,\n      })[#47])\n      assert (? %5: Completion)\n      if (? %5: Abrupt) return %5\n      else %5 = %5.Value\n      %3 = (+ %3 1)\n    }\n  } else {\n    assert (= level ~frozen~)\n    %7 = keys\n    %6 = 0\n    while (< %6 (sizeof %7)) {\n      let k = %7[%6]\n      call %8 = O.GetOwnProperty(O, k)\n      assert (? %8: Completion)\n      if (? %8: Abrupt) return %8\n      else %8 = %8.Value\n      let currentDesc = %8\n      if (! (= currentDesc undefined)) {\n        call %9 = clo<\"IsAccessorDescriptor\">(currentDesc)\n        if (= %9 true) {\n          let desc = (record [PropertyDescriptor] {\n            \"Configurable\" : false,\n          })[#48]\n        } else {\n          let desc = (record [PropertyDescriptor] {\n            \"Configurable\" : false,\n            \"Writable\" : false,\n          })[#49]\n        }\n        call %10 = clo<\"DefinePropertyOrThrow\">(O, k, desc)\n        assert (? %10: Completion)\n        if (? %10: Abrupt) return %10\n        else %10 = %10.Value\n      }\n      %6 = (+ %6 1)\n    }\n  }\n  call %11 = clo<\"NormalCompletion\">(true)\n  return %11\n}","def TestIntegrityLevel(\n  O: Record[Object],\n  level: Enum[~frozen~, ~sealed~],\n): Normal[Boolean] | Throw = {\n  call %0 = clo<\"IsExtensible\">(O)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let extensible = %0\n  if (= extensible true) {\n    call %1 = clo<\"NormalCompletion\">(false)\n    return %1\n  }\n  nop\n  call %2 = O.OwnPropertyKeys(O)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let keys = %2\n  %4 = keys\n  %3 = 0\n  while (< %3 (sizeof %4)) {\n    let k = %4[%3]\n    call %5 = O.GetOwnProperty(O, k)\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n    let currentDesc = %5\n    if (! (= currentDesc undefined)) {\n      if (= currentDesc.Configurable true) {\n        call %6 = clo<\"NormalCompletion\">(false)\n        return %6\n      }\n      %7 = (= level ~frozen~)\n      if %7 {\n        call %8 = clo<\"IsDataDescriptor\">(currentDesc)\n        %7 = (= %8 true)\n      }\n      if %7 {\n        if (= currentDesc.Writable true) {\n          call %9 = clo<\"NormalCompletion\">(false)\n          return %9\n        }\n      }\n    }\n    %3 = (+ %3 1)\n  }\n  call %10 = clo<\"NormalCompletion\">(true)\n  return %10\n}","def CreateArrayFromList(\n  elements: List[ESValue],\n): Record[Array] = {\n  call %0 = clo<\"ArrayCreate\">(0)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let array = %0\n  let n = 0\n  %2 = elements\n  %1 = 0\n  while (< %1 (sizeof %2)) {\n    let e = %2[%1]\n    call %3 = clo<\"ToString\">(([number] n))\n    assert (? %3: Normal)\n    %3 = %3.Value\n    call %4 = clo<\"CreateDataPropertyOrThrow\">(array, %3, e)\n    assert (? %4: Normal)\n    %4 = %4.Value\n    n = (+ n 1)\n    %1 = (+ %1 1)\n  }\n  return array\n}","def LengthOfArrayLike(\n  obj: Record[Object],\n): Normal[NonNegInt] | Throw = {\n  call %0 = clo<\"Get\">(obj, \"length\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"ToLength\">(%0)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  %2 = ([math] %1)\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def CreateListFromArrayLike(\n  obj: ESValue,\n  elementTypes?: Unknown[\"ListOfNamesOfECMAScriptLanguageType\"],\n): Normal[List[ESValue]] | Throw = {\n  if (! (exists elementTypes)) {\n    elementTypes = (list [@Undefined, @Null, @Boolean, @String, @Symbol, @Number, @BigInt, @Object])[#50]\n  }\n  if (! (? obj: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"LengthOfArrayLike\">(obj)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let len = %2\n  let list = (list [])[#51]\n  let index = 0\n  while (< index len) {\n    call %3 = clo<\"ToString\">(([number] index))\n    assert (? %3: Normal)\n    %3 = %3.Value\n    let indexName = %3\n    call %4 = clo<\"Get\">(obj, indexName)\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    let next = %4\n    if (! (contains elementTypes (typeof next))) {\n      call %5 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %6 = clo<\"ThrowCompletion\">(%5)\n      return %6\n    }\n    push list < next\n    index = (+ index 1)\n  }\n  if (? list: Completion) return list\n  call %7 = clo<\"NormalCompletion\">(list)\n  return %7\n}","def Invoke(\n  V: ESValue,\n  P: Record[Symbol] | String,\n  argumentsList?: List[ESValue],\n): Normal[ESValue] | Throw = {\n  if (! (exists argumentsList)) {\n    argumentsList = (list [])[#52]\n  }\n  call %0 = clo<\"GetV\">(V, P)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let func = %0\n  call %1 = clo<\"Call\">(func, V, argumentsList)\n  assert (? %1: Completion)\n  return %1\n}","def OrdinaryHasInstance(\n  C: ESValue,\n  O: ESValue,\n): Normal[Boolean] | Throw = {\n  call %0 = clo<\"IsCallable\">(C)\n  if (= %0 false) {\n    call %1 = clo<\"NormalCompletion\">(false)\n    return %1\n  }\n  if (exists C.BoundTargetFunction) {\n    let BC = C.BoundTargetFunction\n    call %2 = clo<\"InstanceofOperator\">(O, BC)\n    assert (? %2: Completion)\n    return %2\n  }\n  if (! (? O: Record[Object])) {\n    call %3 = clo<\"NormalCompletion\">(false)\n    return %3\n  }\n  call %4 = clo<\"Get\">(C, \"prototype\")\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let P = %4\n  if (! (? P: Record[Object])) {\n    call %5 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %6 = clo<\"ThrowCompletion\">(%5)\n    return %6\n  }\n  while true {\n    call %7 = O.GetPrototypeOf(O)\n    assert (? %7: Completion)\n    if (? %7: Abrupt) return %7\n    else %7 = %7.Value\n    O = %7\n    if (= O null) {\n      call %8 = clo<\"NormalCompletion\">(false)\n      return %8\n    }\n    call %9 = clo<\"SameValue\">(P, O)\n    if (= %9 true) {\n      call %10 = clo<\"NormalCompletion\">(true)\n      return %10\n    }\n  }\n}","def SpeciesConstructor(\n  O: Record[Object],\n  defaultConstructor: Record[Constructor],\n): Normal[Record[Constructor]] | Throw = {\n  call %0 = clo<\"Get\">(O, \"constructor\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let C = %0\n  if (= C undefined) {\n    if (? defaultConstructor: Completion) return defaultConstructor\n    call %1 = clo<\"NormalCompletion\">(defaultConstructor)\n    return %1\n  }\n  if (! (? C: Record[Object])) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  call %4 = clo<\"Get\">(C, @SYMBOL.species)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let S = %4\n  if (|| (= S undefined) (= S null)) {\n    if (? defaultConstructor: Completion) return defaultConstructor\n    call %5 = clo<\"NormalCompletion\">(defaultConstructor)\n    return %5\n  }\n  call %6 = clo<\"IsConstructor\">(S)\n  if (= %6 true) {\n    if (? S: Completion) return S\n    call %7 = clo<\"NormalCompletion\">(S)\n    return %7\n  }\n  call %8 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n  call %9 = clo<\"ThrowCompletion\">(%8)\n  return %9\n}","def EnumerableOwnProperties(\n  O: Record[Object],\n  kind: Enum[~key+value~, ~key~, ~value~],\n): Normal[List[ESValue]] | Throw = {\n  call %0 = O.OwnPropertyKeys(O)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let ownKeys = %0\n  let results = (list [])[#53]\n  %2 = ownKeys\n  %1 = 0\n  while (< %1 (sizeof %2)) {\n    let key = %2[%1]\n    if (? key: String) {\n      call %3 = O.GetOwnProperty(O, key)\n      assert (? %3: Completion)\n      if (? %3: Abrupt) return %3\n      else %3 = %3.Value\n      let desc = %3\n      if (&& (! (= desc undefined)) (= desc.Enumerable true)) {\n        if (= kind ~key~) {\n          push results < key\n        } else {\n          call %4 = clo<\"Get\">(O, key)\n          assert (? %4: Completion)\n          if (? %4: Abrupt) return %4\n          else %4 = %4.Value\n          let value = %4\n          if (= kind ~value~) {\n            push results < value\n          } else {\n            assert (= kind ~key+value~)\n            call %5 = clo<\"CreateArrayFromList\">((list [key, value])[#54])\n            let entry = %5\n            push results < entry\n          }\n        }\n      }\n    }\n    %1 = (+ %1 1)\n  }\n  if (? results: Completion) return results\n  call %6 = clo<\"NormalCompletion\">(results)\n  return %6\n}","def GetFunctionRealm(\n  obj: Record[FunctionObject],\n): Normal[Record[RealmRecord]] | Throw = {\n  if (exists obj.Realm) {\n    %0 = obj.Realm\n    if (? %0: Completion) return %0\n    call %1 = clo<\"NormalCompletion\">(%0)\n    return %1\n  }\n  if (? obj: Record[BoundFunctionExoticObject]) {\n    let boundTargetFunction = obj.BoundTargetFunction\n    call %2 = clo<\"GetFunctionRealm\">(boundTargetFunction)\n    assert (? %2: Completion)\n    return %2\n  }\n  if (? obj: Record[ProxyExoticObject]) {\n    call %3 = clo<\"ValidateNonRevokedProxy\">(obj)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let proxyTarget = obj.ProxyTarget\n    call %4 = clo<\"GetFunctionRealm\">(proxyTarget)\n    assert (? %4: Completion)\n    return %4\n  }\n  %5 = @EXECUTION_STACK[0].Realm\n  if (? %5: Completion) return %5\n  call %6 = clo<\"NormalCompletion\">(%5)\n  return %6\n}","def CopyDataProperties(\n  target: Record[Object],\n  source: ESValue,\n  excludedItems: List[Record[Symbol] | String],\n): Normal[Enum[~unused~]] | Throw = {\n  if (|| (= source undefined) (= source null)) {\n    call %0 = clo<\"NormalCompletion\">(~unused~)\n    return %0\n  }\n  call %1 = clo<\"ToObject\">(source)\n  assert (? %1: Normal)\n  %1 = %1.Value\n  let from = %1\n  call %2 = from.OwnPropertyKeys(from)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let keys = %2\n  %4 = keys\n  %3 = 0\n  while (< %3 (sizeof %4)) {\n    let nextKey = %4[%3]\n    let excluded = false\n    %6 = excludedItems\n    %5 = 0\n    while (< %5 (sizeof %6)) {\n      let e = %6[%5]\n      call %7 = clo<\"SameValue\">(e, nextKey)\n      if (= %7 true) {\n        excluded = true\n      }\n      %5 = (+ %5 1)\n    }\n    if (= excluded false) {\n      call %8 = from.GetOwnProperty(from, nextKey)\n      assert (? %8: Completion)\n      if (? %8: Abrupt) return %8\n      else %8 = %8.Value\n      let desc = %8\n      if (&& (! (= desc undefined)) (= desc.Enumerable true)) {\n        call %9 = clo<\"Get\">(from, nextKey)\n        assert (? %9: Completion)\n        if (? %9: Abrupt) return %9\n        else %9 = %9.Value\n        let propValue = %9\n        call %10 = clo<\"CreateDataPropertyOrThrow\">(target, nextKey, propValue)\n        assert (? %10: Normal)\n        %10 = %10.Value\n      }\n    }\n    %3 = (+ %3 1)\n  }\n  call %11 = clo<\"NormalCompletion\">(~unused~)\n  return %11\n}","def PrivateElementFind(\n  O: Record[Object],\n  P: Record[PrivateName],\n): Record[PrivateElement] | Enum[~empty~] = {\n  %0 = O.PrivateElements\n  %1 = 0\n  %2 = false\n  while (&& (! %2) (< %1 (sizeof %0))) {\n    let pe = %0[%1]\n    %2 = (&& (? pe: Record[PrivateElement]) (= pe.Key P))\n    %1 = (+ %1 1)\n  }\n  if %2 {\n    return pe\n  }\n  return ~empty~\n}","def PrivateFieldAdd(\n  O: Record[Object],\n  P: Record[PrivateName],\n  value: ESValue,\n): Normal[Enum[~unused~]] | Throw = {\n  nop\n  call %0 = clo<\"PrivateElementFind\">(O, P)\n  let entry = %0\n  if (! (= entry ~empty~)) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  push O.PrivateElements < (record [PrivateElement] {\n    \"Key\" : P,\n    \"Kind\" : ~field~,\n    \"Value\" : value,\n  })[#55]\n  call %3 = clo<\"NormalCompletion\">(~unused~)\n  return %3\n}","def PrivateMethodOrAccessorAdd(\n  O: Record[Object],\n  method: Record[PrivateElement],\n): Normal[Enum[~unused~]] | Throw = {\n  assert (|| (= method.Kind ~method~) (= method.Kind ~accessor~))\n  nop\n  call %0 = clo<\"PrivateElementFind\">(O, method.Key)\n  let entry = %0\n  if (! (= entry ~empty~)) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  push O.PrivateElements < method\n  call %3 = clo<\"NormalCompletion\">(~unused~)\n  return %3\n}","def PrivateGet(\n  O: Record[Object],\n  P: Record[PrivateName],\n): Normal[ESValue] | Throw = {\n  call %0 = clo<\"PrivateElementFind\">(O, P)\n  let entry = %0\n  if (= entry ~empty~) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  if (|| (= entry.Kind ~field~) (= entry.Kind ~method~)) {\n    %3 = entry.Value\n    if (? %3: Completion) return %3\n    call %4 = clo<\"NormalCompletion\">(%3)\n    return %4\n  }\n  assert (= entry.Kind ~accessor~)\n  if (= entry.Get undefined) {\n    call %5 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %6 = clo<\"ThrowCompletion\">(%5)\n    return %6\n  }\n  let getter = entry.Get\n  call %7 = clo<\"Call\">(getter, O)\n  assert (? %7: Completion)\n  return %7\n}","def PrivateSet(\n  O: Record[Object],\n  P: Record[PrivateName],\n  value: ESValue,\n): Normal[Enum[~unused~]] | Throw = {\n  call %0 = clo<\"PrivateElementFind\">(O, P)\n  let entry = %0\n  if (= entry ~empty~) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  if (= entry.Kind ~field~) {\n    entry.Value = value\n  } else {\n    if (= entry.Kind ~method~) {\n      call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %4 = clo<\"ThrowCompletion\">(%3)\n      return %4\n    } else {\n      assert (= entry.Kind ~accessor~)\n      if (= entry.Set undefined) {\n        call %5 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n        call %6 = clo<\"ThrowCompletion\">(%5)\n        return %6\n      }\n      let setter = entry.Set\n      call %7 = clo<\"Call\">(setter, O, (list [value])[#56])\n      assert (? %7: Completion)\n      if (? %7: Abrupt) return %7\n      else %7 = %7.Value\n    }\n  }\n  call %8 = clo<\"NormalCompletion\">(~unused~)\n  return %8\n}","def DefineField(\n  receiver: Record[Object],\n  fieldRecord: Record[ClassFieldDefinitionRecord],\n): Normal[Enum[~unused~]] | Throw = {\n  let fieldName = fieldRecord.Name\n  let initializer = fieldRecord.Initializer\n  if (! (= initializer ~empty~)) {\n    call %0 = clo<\"Call\">(initializer, receiver)\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let initValue = %0\n  } else {\n    let initValue = undefined\n  }\n  if (? fieldName: Record[PrivateName]) {\n    call %1 = clo<\"PrivateFieldAdd\">(receiver, fieldName, initValue)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n  } else {\n    call %2 = clo<\"IsPropertyKey\">(fieldName)\n    assert (= %2 true)\n    call %3 = clo<\"CreateDataPropertyOrThrow\">(receiver, fieldName, initValue)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n  }\n  call %4 = clo<\"NormalCompletion\">(~unused~)\n  return %4\n}","def InitializeInstanceElements(\n  O: Record[Object],\n  constructor: Record[ECMAScriptFunctionObject],\n): Normal[Enum[~unused~]] | Throw = {\n  let methods = constructor.PrivateMethods\n  %1 = methods\n  %0 = 0\n  while (< %0 (sizeof %1)) {\n    let method = %1[%0]\n    if (? method: Record[PrivateElement]) {\n      call %2 = clo<\"PrivateMethodOrAccessorAdd\">(O, method)\n      assert (? %2: Completion)\n      if (? %2: Abrupt) return %2\n      else %2 = %2.Value\n    }\n    %0 = (+ %0 1)\n  }\n  let fields = constructor.Fields\n  %4 = fields\n  %3 = 0\n  while (< %3 (sizeof %4)) {\n    let fieldRecord = %4[%3]\n    call %5 = clo<\"DefineField\">(O, fieldRecord)\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n    %3 = (+ %3 1)\n  }\n  call %6 = clo<\"NormalCompletion\">(~unused~)\n  return %6\n}","def AddValueToKeyedGroup(\n  groups: Unknown[\"ListOfRecordsWithFields[[Key]](anECMAScriptLanguageValue)And[[Elements]](aListOfECMAScriptLanguageValues)\"],\n  key: ESValue,\n  value: ESValue,\n): Enum[~unused~] = {\n  %1 = groups\n  %0 = 0\n  while (< %0 (sizeof %1)) {\n    let g = %1[%0]\n    if (? g: Record[{ Elements, Key }]) {\n      call %2 = clo<\"SameValue\">(g.Key, key)\n      if (= %2 true) {\n        assert (yet \"Exactly one element of _groups_ meets this criterion.\")\n        push g.Elements < value\n        return ~unused~\n      }\n    }\n    %0 = (+ %0 1)\n  }\n  let group = (record {\n    \"Key\" : key,\n    \"Elements\" : (list [value])[#58],\n  })[#57]\n  push groups < group\n  return ~unused~\n}","def GroupBy(\n  items: ESValue,\n  callbackfn: ESValue,\n  keyCoercion: Enum[~property~, ~zero~],\n): Unknown[\"EitherANormalCompletionContainingAListOfRecordsWithFields[[Key]](anECMAScriptLanguageValue)And[[Elements]](aListOfECMAScriptLanguageValues),OrAThrowCompletion\"] = {\n  call %0 = clo<\"RequireObjectCoercible\">(items)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"IsCallable\">(callbackfn)\n  if (= %1 false) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  let groups = (list [])[#59]\n  call %4 = clo<\"GetIterator\">(items, ~sync~)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let iteratorRecord = %4\n  let k = 0\n  while true {\n    if (! (< k (- (** 2 53) 1))) {\n      call %5 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %6 = clo<\"ThrowCompletion\">(%5)\n      let error = %6\n      call %7 = clo<\"IteratorClose\">(iteratorRecord, error)\n      assert (? %7: Completion)\n      return %7\n    }\n    call %8 = clo<\"IteratorStepValue\">(iteratorRecord)\n    assert (? %8: Completion)\n    if (? %8: Abrupt) return %8\n    else %8 = %8.Value\n    let next = %8\n    if (= next ~done~) {\n      if (? groups: Completion) return groups\n      call %9 = clo<\"NormalCompletion\">(groups)\n      return %9\n    }\n    let value = next\n    call %10 = clo<\"Call\">(callbackfn, undefined, (list [value, ([number] k)])[#60])\n    call %11 = clo<\"Completion\">(%10)\n    let key = %11\n    assert (? key: Completion)\n    if (&& (? key: Completion) (! (= key.Type ~normal~))) {\n      call %12 = clo<\"IteratorClose\">(iteratorRecord, key)\n      assert (? %12: Completion)\n      return %12\n    } else {\n      assert (? key: Normal)\n      key = key.Value\n      key = key\n    }\n    if (= keyCoercion ~property~) {\n      call %13 = clo<\"ToPropertyKey\">(key)\n      call %14 = clo<\"Completion\">(%13)\n      key = %14\n      assert (? key: Completion)\n      if (&& (? key: Completion) (! (= key.Type ~normal~))) {\n        call %15 = clo<\"IteratorClose\">(iteratorRecord, key)\n        assert (? %15: Completion)\n        return %15\n      } else {\n        assert (? key: Normal)\n        key = key.Value\n        key = key\n      }\n    } else {\n      assert (= keyCoercion ~zero~)\n      if (= key -0.0f) {\n        key = 0.0f\n      }\n    }\n    call %16 = clo<\"AddValueToKeyedGroup\">(groups, key, value)\n    k = (+ k 1)\n  }\n}","def GetIteratorFromMethod(\n  obj: ESValue,\n  method: Record[FunctionObject],\n): Normal[Record[IteratorRecord]] | Throw = {\n  call %0 = clo<\"Call\">(method, obj)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let iterator = %0\n  if (! (? iterator: Record[Object])) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  call %3 = clo<\"Get\">(iterator, \"next\")\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let nextMethod = %3\n  let iteratorRecord = (record [IteratorRecord] {\n    \"Iterator\" : iterator,\n    \"NextMethod\" : nextMethod,\n    \"Done\" : false,\n  })[#61]\n  if (? iteratorRecord: Completion) return iteratorRecord\n  call %4 = clo<\"NormalCompletion\">(iteratorRecord)\n  return %4\n}","def GetIterator(\n  obj: ESValue,\n  kind: Enum[~async~, ~sync~],\n): Normal[Record[IteratorRecord]] | Throw = {\n  if (= kind ~async~) {\n    call %0 = clo<\"GetMethod\">(obj, @SYMBOL.asyncIterator)\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let method = %0\n    if (= method undefined) {\n      call %1 = clo<\"GetMethod\">(obj, @SYMBOL.iterator)\n      assert (? %1: Completion)\n      if (? %1: Abrupt) return %1\n      else %1 = %1.Value\n      let syncMethod = %1\n      if (= syncMethod undefined) {\n        call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n        call %3 = clo<\"ThrowCompletion\">(%2)\n        return %3\n      }\n      call %4 = clo<\"GetIteratorFromMethod\">(obj, syncMethod)\n      assert (? %4: Completion)\n      if (? %4: Abrupt) return %4\n      else %4 = %4.Value\n      let syncIteratorRecord = %4\n      call %5 = clo<\"CreateAsyncFromSyncIterator\">(syncIteratorRecord)\n      if (? %5: Completion) return %5\n      call %6 = clo<\"NormalCompletion\">(%5)\n      return %6\n    }\n  } else {\n    call %7 = clo<\"GetMethod\">(obj, @SYMBOL.iterator)\n    assert (? %7: Completion)\n    if (? %7: Abrupt) return %7\n    else %7 = %7.Value\n    let method = %7\n  }\n  if (= method undefined) {\n    call %8 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %9 = clo<\"ThrowCompletion\">(%8)\n    return %9\n  }\n  call %10 = clo<\"GetIteratorFromMethod\">(obj, method)\n  assert (? %10: Completion)\n  return %10\n}","def IteratorNext(\n  iteratorRecord: Record[IteratorRecord],\n  value?: ESValue,\n): Normal[Record[Object]] | Throw = {\n  if (! (exists value)) {\n    call %0 = clo<\"Call\">(iteratorRecord.NextMethod, iteratorRecord.Iterator)\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let result = %0\n  } else {\n    call %1 = clo<\"Call\">(iteratorRecord.NextMethod, iteratorRecord.Iterator, (list [value])[#62])\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let result = %1\n  }\n  if (! (? result: Record[Object])) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  if (? result: Completion) return result\n  call %4 = clo<\"NormalCompletion\">(result)\n  return %4\n}","def IteratorComplete(\n  iterResult: Record[Object],\n): Normal[Boolean] | Throw = {\n  call %0 = clo<\"Get\">(iterResult, \"done\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"ToBoolean\">(%0)\n  if (? %1: Completion) return %1\n  call %2 = clo<\"NormalCompletion\">(%1)\n  return %2\n}","def IteratorValue(\n  iterResult: Record[Object],\n): Normal[ESValue] | Throw = {\n  call %0 = clo<\"Get\">(iterResult, \"value\")\n  assert (? %0: Completion)\n  return %0\n}","def IteratorStep(\n  iteratorRecord: Record[IteratorRecord],\n): Normal[Record[Object] | False] | Throw = {\n  call %0 = clo<\"IteratorNext\">(iteratorRecord)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let result = %0\n  call %1 = clo<\"IteratorComplete\">(result)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let done = %1\n  if (= done true) {\n    call %2 = clo<\"NormalCompletion\">(false)\n    return %2\n  }\n  if (? result: Completion) return result\n  call %3 = clo<\"NormalCompletion\">(result)\n  return %3\n}","def IteratorStepValue(\n  iteratorRecord: Record[IteratorRecord],\n): Normal[ESValue | Enum[~done~]] | Throw = {\n  call %0 = clo<\"IteratorNext\">(iteratorRecord)\n  call %1 = clo<\"Completion\">(%0)\n  let result = %1\n  if (&& (? result: Completion) (= result.Type ~throw~)) {\n    iteratorRecord.Done = true\n    assert (? result: Completion)\n    return result\n  }\n  assert (? result: Normal)\n  result = result.Value\n  result = result\n  call %2 = clo<\"IteratorComplete\">(result)\n  call %3 = clo<\"Completion\">(%2)\n  let done = %3\n  if (&& (? done: Completion) (= done.Type ~throw~)) {\n    iteratorRecord.Done = true\n    assert (? done: Completion)\n    return done\n  }\n  assert (? done: Normal)\n  done = done.Value\n  done = done\n  if (= done true) {\n    iteratorRecord.Done = true\n    call %4 = clo<\"NormalCompletion\">(~done~)\n    return %4\n  }\n  call %5 = clo<\"Get\">(result, \"value\")\n  call %6 = clo<\"Completion\">(%5)\n  let value = %6\n  if (&& (? value: Completion) (= value.Type ~throw~)) {\n    iteratorRecord.Done = true\n  }\n  assert (? value: Completion)\n  return value\n}","def IteratorClose(\n  iteratorRecord: Record[IteratorRecord],\n  completion: Completion,\n): Completion = {\n  assert (? iteratorRecord.Iterator: Record[Object])\n  let iterator = iteratorRecord.Iterator\n  call %0 = clo<\"GetMethod\">(iterator, \"return\")\n  call %1 = clo<\"Completion\">(%0)\n  let innerResult = %1\n  if (&& (? innerResult: Completion) (= innerResult.Type ~normal~)) {\n    let return = innerResult.Value\n    if (= return undefined) {\n      assert (? completion: Completion)\n      return completion\n    }\n    call %2 = clo<\"Call\">(return, iterator)\n    call %3 = clo<\"Completion\">(%2)\n    innerResult = %3\n  }\n  if (&& (? completion: Completion) (= completion.Type ~throw~)) {\n    assert (? completion: Completion)\n    return completion\n  }\n  if (&& (? innerResult: Completion) (= innerResult.Type ~throw~)) {\n    assert (? innerResult: Completion)\n    return innerResult\n  }\n  if (! (? innerResult.Value: Record[Object])) {\n    call %4 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %5 = clo<\"ThrowCompletion\">(%4)\n    return %5\n  }\n  assert (? completion: Completion)\n  return completion\n}","def AsyncIteratorClose(\n  iteratorRecord: Record[IteratorRecord],\n  completion: Completion,\n): Completion = {\n  assert (? iteratorRecord.Iterator: Record[Object])\n  let iterator = iteratorRecord.Iterator\n  call %0 = clo<\"GetMethod\">(iterator, \"return\")\n  call %1 = clo<\"Completion\">(%0)\n  let innerResult = %1\n  if (&& (? innerResult: Completion) (= innerResult.Type ~normal~)) {\n    let return = innerResult.Value\n    if (= return undefined) {\n      assert (? completion: Completion)\n      return completion\n    }\n    call %2 = clo<\"Call\">(return, iterator)\n    call %3 = clo<\"Completion\">(%2)\n    innerResult = %3\n    if (&& (? innerResult: Completion) (= innerResult.Type ~normal~)) {\n      call %4 = clo<\"Await\">(innerResult.Value)\n      call %5 = clo<\"Completion\">(%4)\n      innerResult = %5\n    }\n  }\n  if (&& (? completion: Completion) (= completion.Type ~throw~)) {\n    assert (? completion: Completion)\n    return completion\n  }\n  if (&& (? innerResult: Completion) (= innerResult.Type ~throw~)) {\n    assert (? innerResult: Completion)\n    return innerResult\n  }\n  if (! (? innerResult.Value: Record[Object])) {\n    call %6 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %7 = clo<\"ThrowCompletion\">(%6)\n    return %7\n  }\n  assert (? completion: Completion)\n  return completion\n}","def CreateIterResultObject(\n  value: ESValue,\n  done: Boolean,\n): Unknown[\"ObjectThatConformsToThe<i>IteratorResult</i>Interface\"] = {\n  call %0 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Object.prototype%\"])\n  let obj = %0\n  call %1 = clo<\"CreateDataPropertyOrThrow\">(obj, \"value\", value)\n  assert (? %1: Normal)\n  %1 = %1.Value\n  call %2 = clo<\"CreateDataPropertyOrThrow\">(obj, \"done\", done)\n  assert (? %2: Normal)\n  %2 = %2.Value\n  return obj\n}","def <CLO>:CreateListIteratorRecord:clo0(\n): Unknown = {\n  %1 = list\n  %0 = 0\n  while (< %0 (sizeof %1)) {\n    let E = %1[%0]\n    call %2 = clo<\"CreateIterResultObject\">(E, false)\n    call %3 = clo<\"GeneratorYield\">(%2)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    %0 = (+ %0 1)\n  }\n  call %4 = clo<\"NormalCompletion\">(undefined)\n  if (? %4: Completion) return %4\n  call %5 = clo<\"NormalCompletion\">(%4)\n  return %5\n}","def CreateListIteratorRecord(\n  list: List[ESValue],\n): Record[IteratorRecord] = {\n  let closure = clo<\"CreateListIteratorRecord:clo0\", [list]>\n  call %0 = clo<\"CreateIteratorFromClosure\">(closure, ~empty~, @EXECUTION_STACK[0].Realm.Intrinsics[\"%IteratorPrototype%\"])\n  let iterator = %0\n  return (record [IteratorRecord] {\n    \"Iterator\" : iterator,\n    \"NextMethod\" : @EXECUTION_STACK[0].Realm.Intrinsics[\"%GeneratorFunction.prototype.prototype.next%\"],\n    \"Done\" : false,\n  })[#63]\n}","def IteratorToList(\n  iteratorRecord: Record[IteratorRecord],\n): Normal[List[ESValue]] | Throw = {\n  let values = (list [])[#64]\n  while true {\n    call %0 = clo<\"IteratorStepValue\">(iteratorRecord)\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let next = %0\n    if (= next ~done~) {\n      if (? values: Completion) return values\n      call %1 = clo<\"NormalCompletion\">(values)\n      return %1\n    }\n    push values < next\n  }\n}","def <SYNTAX>:BindingIdentifier[0,0].BoundNames(\n  this: Ast[BindingIdentifier[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->StringValue()\n  return (list [%0])[#65]\n}","def <SYNTAX>:BindingIdentifier[1,0].BoundNames(\n  this: Ast[BindingIdentifier[1]],\n): List[String] = {\n  return (list [\"yield\"])[#66]\n}","def <SYNTAX>:BindingIdentifier[2,0].BoundNames(\n  this: Ast[BindingIdentifier[2]],\n): List[String] = {\n  return (list [\"await\"])[#67]\n}","def <SYNTAX>:LexicalDeclaration[0,0].BoundNames(\n  this: Ast[LexicalDeclaration[0]],\n): List[String] = {\n  sdo-call %0 = this[1]->BoundNames()\n  return %0\n}","def <SYNTAX>:BindingList[1,0].BoundNames(\n  this: Ast[BindingList[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  let names1 = %0\n  sdo-call %1 = this[1]->BoundNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#68])\n  return %2\n}","def <SYNTAX>:LexicalBinding[0,0].BoundNames(\n  this: Ast[LexicalBinding[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:LexicalBinding[0,1].BoundNames(\n  this: Ast[LexicalBinding[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:LexicalBinding[1,0].BoundNames(\n  this: Ast[LexicalBinding[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:VariableDeclarationList[1,0].BoundNames(\n  this: Ast[VariableDeclarationList[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  let names1 = %0\n  sdo-call %1 = this[1]->BoundNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#69])\n  return %2\n}","def <SYNTAX>:VariableDeclaration[0,0].BoundNames(\n  this: Ast[VariableDeclaration[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:VariableDeclaration[0,1].BoundNames(\n  this: Ast[VariableDeclaration[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:VariableDeclaration[1,0].BoundNames(\n  this: Ast[VariableDeclaration[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:ObjectBindingPattern[0,0].BoundNames(\n  this: Ast[ObjectBindingPattern[0]],\n): List[String] = {\n  return (list [])[#70]\n}","def <SYNTAX>:ObjectBindingPattern[3,1].BoundNames(\n  this: Ast[ObjectBindingPattern[3]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  let names1 = %0\n  sdo-call %1 = this[1]->BoundNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#71])\n  return %2\n}","def <SYNTAX>:ArrayBindingPattern[0,0].BoundNames(\n  this: Ast[ArrayBindingPattern[0]],\n): List[String] = {\n  return (list [])[#72]\n}","def <SYNTAX>:ArrayBindingPattern[0,2].BoundNames(\n  this: Ast[ArrayBindingPattern[0]],\n): List[String] = {\n  return (list [])[#73]\n}","def <SYNTAX>:ArrayBindingPattern[0,1].BoundNames(\n  this: Ast[ArrayBindingPattern[0]],\n): List[String] = {\n  sdo-call %0 = this[1]->BoundNames()\n  return %0\n}","def <SYNTAX>:ArrayBindingPattern[0,3].BoundNames(\n  this: Ast[ArrayBindingPattern[0]],\n): List[String] = {\n  sdo-call %0 = this[1]->BoundNames()\n  return %0\n}","def <SYNTAX>:ArrayBindingPattern[2,0].BoundNames(\n  this: Ast[ArrayBindingPattern[2]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:ArrayBindingPattern[2,2].BoundNames(\n  this: Ast[ArrayBindingPattern[2]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:ArrayBindingPattern[2,1].BoundNames(\n  this: Ast[ArrayBindingPattern[2]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  let names1 = %0\n  sdo-call %1 = this[2]->BoundNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#74])\n  return %2\n}","def <SYNTAX>:ArrayBindingPattern[2,3].BoundNames(\n  this: Ast[ArrayBindingPattern[2]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  let names1 = %0\n  sdo-call %1 = this[2]->BoundNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#75])\n  return %2\n}","def <SYNTAX>:BindingPropertyList[1,0].BoundNames(\n  this: Ast[BindingPropertyList[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  let names1 = %0\n  sdo-call %1 = this[1]->BoundNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#76])\n  return %2\n}","def <SYNTAX>:BindingElementList[1,0].BoundNames(\n  this: Ast[BindingElementList[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  let names1 = %0\n  sdo-call %1 = this[1]->BoundNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#77])\n  return %2\n}","def <SYNTAX>:BindingElisionElement[0,0].BoundNames(\n  this: Ast[BindingElisionElement[0]],\n): List[String] = {\n  sdo-call %0 = this[1]->BoundNames()\n  return %0\n}","def <SYNTAX>:BindingElisionElement[0,1].BoundNames(\n  this: Ast[BindingElisionElement[0]],\n): List[String] = {\n  sdo-call %0 = this[1]->BoundNames()\n  return %0\n}","def <SYNTAX>:BindingProperty[1,0].BoundNames(\n  this: Ast[BindingProperty[1]],\n): List[String] = {\n  sdo-call %0 = this[1]->BoundNames()\n  return %0\n}","def <SYNTAX>:SingleNameBinding[0,0].BoundNames(\n  this: Ast[SingleNameBinding[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:SingleNameBinding[0,1].BoundNames(\n  this: Ast[SingleNameBinding[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:BindingElement[1,0].BoundNames(\n  this: Ast[BindingElement[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:BindingElement[1,1].BoundNames(\n  this: Ast[BindingElement[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:ForDeclaration[0,0].BoundNames(\n  this: Ast[ForDeclaration[0]],\n): List[String] = {\n  sdo-call %0 = this[1]->BoundNames()\n  return %0\n}","def <SYNTAX>:FunctionDeclaration[0,0].BoundNames(\n  this: Ast[FunctionDeclaration[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:FunctionDeclaration[1,0].BoundNames(\n  this: Ast[FunctionDeclaration[1]],\n): List[String] = {\n  return (list [\"*default*\"])[#78]\n}","def <SYNTAX>:FormalParameters[0,0].BoundNames(\n  this: Ast[FormalParameters[0]],\n): List[String] = {\n  return (list [])[#79]\n}","def <SYNTAX>:FormalParameters[4,0].BoundNames(\n  this: Ast[FormalParameters[4]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  let names1 = %0\n  sdo-call %1 = this[1]->BoundNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#80])\n  return %2\n}","def <SYNTAX>:FormalParameterList[1,0].BoundNames(\n  this: Ast[FormalParameterList[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  let names1 = %0\n  sdo-call %1 = this[1]->BoundNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#81])\n  return %2\n}","def <SYNTAX>:ArrowParameters[1,0].BoundNames(\n  this: Ast[ArrowParameters[1]],\n): List[String] = {\n  let formals = (parse this[0] (grammar-symbol |ArrowFormalParameters|))\n  sdo-call %0 = formals->BoundNames()\n  return %0\n}","def <SYNTAX>:GeneratorDeclaration[0,0].BoundNames(\n  this: Ast[GeneratorDeclaration[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:GeneratorDeclaration[1,0].BoundNames(\n  this: Ast[GeneratorDeclaration[1]],\n): List[String] = {\n  return (list [\"*default*\"])[#82]\n}","def <SYNTAX>:AsyncGeneratorDeclaration[0,0].BoundNames(\n  this: Ast[AsyncGeneratorDeclaration[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:AsyncGeneratorDeclaration[1,0].BoundNames(\n  this: Ast[AsyncGeneratorDeclaration[1]],\n): List[String] = {\n  return (list [\"*default*\"])[#83]\n}","def <SYNTAX>:ClassDeclaration[0,0].BoundNames(\n  this: Ast[ClassDeclaration[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:ClassDeclaration[1,0].BoundNames(\n  this: Ast[ClassDeclaration[1]],\n): List[String] = {\n  return (list [\"*default*\"])[#84]\n}","def <SYNTAX>:AsyncFunctionDeclaration[0,0].BoundNames(\n  this: Ast[AsyncFunctionDeclaration[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:AsyncFunctionDeclaration[1,0].BoundNames(\n  this: Ast[AsyncFunctionDeclaration[1]],\n): List[String] = {\n  return (list [\"*default*\"])[#85]\n}","def <SYNTAX>:CoverCallExpressionAndAsyncArrowHead[0,0].BoundNames(\n  this: Ast[CoverCallExpressionAndAsyncArrowHead[0]],\n): List[String] = {\n  let head = (parse this (grammar-symbol |AsyncArrowHead|))\n  sdo-call %0 = head->BoundNames()\n  return %0\n}","def <SYNTAX>:ImportDeclaration[0,0].BoundNames(\n  this: Ast[ImportDeclaration[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:ImportDeclaration[1,0].BoundNames(\n  this: Ast[ImportDeclaration[1]],\n): List[String] = {\n  return (list [])[#86]\n}","def <SYNTAX>:ImportClause[3,0].BoundNames(\n  this: Ast[ImportClause[3]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  let names1 = %0\n  sdo-call %1 = this[1]->BoundNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#87])\n  return %2\n}","def <SYNTAX>:ImportClause[4,0].BoundNames(\n  this: Ast[ImportClause[4]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  let names1 = %0\n  sdo-call %1 = this[1]->BoundNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#88])\n  return %2\n}","def <SYNTAX>:NamedImports[0,0].BoundNames(\n  this: Ast[NamedImports[0]],\n): List[String] = {\n  return (list [])[#89]\n}","def <SYNTAX>:ImportsList[1,0].BoundNames(\n  this: Ast[ImportsList[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  let names1 = %0\n  sdo-call %1 = this[1]->BoundNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#90])\n  return %2\n}","def <SYNTAX>:ImportSpecifier[1,0].BoundNames(\n  this: Ast[ImportSpecifier[1]],\n): List[String] = {\n  sdo-call %0 = this[1]->BoundNames()\n  return %0\n}","def <SYNTAX>:ExportDeclaration[0,0].BoundNames(\n  this: Ast[ExportDeclaration[0]],\n): List[String] = {\n  return (list [])[#91]\n}","def <SYNTAX>:ExportDeclaration[1,0].BoundNames(\n  this: Ast[ExportDeclaration[1]],\n): List[String] = {\n  return (list [])[#92]\n}","def <SYNTAX>:ExportDeclaration[2,0].BoundNames(\n  this: Ast[ExportDeclaration[2]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:ExportDeclaration[3,0].BoundNames(\n  this: Ast[ExportDeclaration[3]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:ExportDeclaration[4,0].BoundNames(\n  this: Ast[ExportDeclaration[4]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  let declarationNames = %0\n  (yet \"If _declarationNames_ does not include the element *\\\"\\\\*default\\\\*\\\"*, append *\\\"\\\\*default\\\\*\\\"* to _declarationNames_.\")\n  return declarationNames\n}","def <SYNTAX>:ExportDeclaration[5,0].BoundNames(\n  this: Ast[ExportDeclaration[5]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  let declarationNames = %0\n  (yet \"If _declarationNames_ does not include the element *\\\"\\\\*default\\\\*\\\"*, append *\\\"\\\\*default\\\\*\\\"* to _declarationNames_.\")\n  return declarationNames\n}","def <SYNTAX>:ExportDeclaration[6,0].BoundNames(\n  this: Ast[ExportDeclaration[6]],\n): List[String] = {\n  return (list [\"*default*\"])[#93]\n}","def <SYNTAX>:HoistableDeclaration[0,0].DeclarationPart(\n  this: Ast[HoistableDeclaration[0]],\n): Ast = {\n  return this[0]\n}","def <SYNTAX>:HoistableDeclaration[1,0].DeclarationPart(\n  this: Ast[HoistableDeclaration[1]],\n): Ast = {\n  return this[0]\n}","def <SYNTAX>:HoistableDeclaration[2,0].DeclarationPart(\n  this: Ast[HoistableDeclaration[2]],\n): Ast = {\n  return this[0]\n}","def <SYNTAX>:HoistableDeclaration[3,0].DeclarationPart(\n  this: Ast[HoistableDeclaration[3]],\n): Ast = {\n  return this[0]\n}","def <SYNTAX>:Declaration[1,0].DeclarationPart(\n  this: Ast[Declaration[1]],\n): Ast = {\n  return this[0]\n}","def <SYNTAX>:Declaration[2,0].DeclarationPart(\n  this: Ast[Declaration[2]],\n): Ast = {\n  return this[0]\n}","def <SYNTAX>:LexicalDeclaration[0,0].IsConstantDeclaration(\n  this: Ast[LexicalDeclaration[0]],\n): Boolean = {\n  sdo-call %0 = this[0]->IsConstantDeclaration()\n  return %0\n}","def <SYNTAX>:LetOrConst[0,0].IsConstantDeclaration(\n  this: Ast[LetOrConst[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:LetOrConst[1,0].IsConstantDeclaration(\n  this: Ast[LetOrConst[1]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:FunctionDeclaration[0,0].IsConstantDeclaration(\n  this: Ast[FunctionDeclaration[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:FunctionDeclaration[1,0].IsConstantDeclaration(\n  this: Ast[FunctionDeclaration[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:GeneratorDeclaration[0,0].IsConstantDeclaration(\n  this: Ast[GeneratorDeclaration[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:GeneratorDeclaration[1,0].IsConstantDeclaration(\n  this: Ast[GeneratorDeclaration[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AsyncGeneratorDeclaration[0,0].IsConstantDeclaration(\n  this: Ast[AsyncGeneratorDeclaration[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AsyncGeneratorDeclaration[1,0].IsConstantDeclaration(\n  this: Ast[AsyncGeneratorDeclaration[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AsyncFunctionDeclaration[0,0].IsConstantDeclaration(\n  this: Ast[AsyncFunctionDeclaration[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AsyncFunctionDeclaration[1,0].IsConstantDeclaration(\n  this: Ast[AsyncFunctionDeclaration[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ClassDeclaration[0,0].IsConstantDeclaration(\n  this: Ast[ClassDeclaration[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ClassDeclaration[1,0].IsConstantDeclaration(\n  this: Ast[ClassDeclaration[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ExportDeclaration[0,0].IsConstantDeclaration(\n  this: Ast[ExportDeclaration[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ExportDeclaration[1,0].IsConstantDeclaration(\n  this: Ast[ExportDeclaration[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ExportDeclaration[6,0].IsConstantDeclaration(\n  this: Ast[ExportDeclaration[6]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Block[0,0].LexicallyDeclaredNames(\n  this: Ast[Block[0]],\n): List[String] = {\n  return (list [])[#94]\n}","def <SYNTAX>:StatementList[1,0].LexicallyDeclaredNames(\n  this: Ast[StatementList[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->LexicallyDeclaredNames()\n  let names1 = %0\n  sdo-call %1 = this[1]->LexicallyDeclaredNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#95])\n  return %2\n}","def <SYNTAX>:StatementListItem[0,0].LexicallyDeclaredNames(\n  this: Ast[StatementListItem[0]],\n): List[String] = {\n  if (? this[0]: Ast[Statement[10]]) {\n    sdo-call %0 = this[0][0]->LexicallyDeclaredNames()\n    return %0\n  }\n  return (list [])[#96]\n}","def <SYNTAX>:StatementListItem[1,0].LexicallyDeclaredNames(\n  this: Ast[StatementListItem[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:CaseBlock[0,0].LexicallyDeclaredNames(\n  this: Ast[CaseBlock[0]],\n): List[String] = {\n  return (list [])[#97]\n}","def <SYNTAX>:CaseBlock[1,0].LexicallyDeclaredNames(\n  this: Ast[CaseBlock[1]],\n): List[String] = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->LexicallyDeclaredNames()\n    let names1 = %0\n  } else {\n    let names1 = (list [])[#98]\n  }\n  sdo-call %1 = this[1]->LexicallyDeclaredNames()\n  let names2 = %1\n  if (exists this[2]) {\n    sdo-call %2 = this[2]->LexicallyDeclaredNames()\n    let names3 = %2\n  } else {\n    let names3 = (list [])[#99]\n  }\n  call %3 = clo<\"__FLAT_LIST__\">((list [names1, names2, names3])[#100])\n  return %3\n}","def <SYNTAX>:CaseBlock[1,1].LexicallyDeclaredNames(\n  this: Ast[CaseBlock[1]],\n): List[String] = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->LexicallyDeclaredNames()\n    let names1 = %0\n  } else {\n    let names1 = (list [])[#101]\n  }\n  sdo-call %1 = this[1]->LexicallyDeclaredNames()\n  let names2 = %1\n  if (exists this[2]) {\n    sdo-call %2 = this[2]->LexicallyDeclaredNames()\n    let names3 = %2\n  } else {\n    let names3 = (list [])[#102]\n  }\n  call %3 = clo<\"__FLAT_LIST__\">((list [names1, names2, names3])[#103])\n  return %3\n}","def <SYNTAX>:CaseBlock[1,2].LexicallyDeclaredNames(\n  this: Ast[CaseBlock[1]],\n): List[String] = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->LexicallyDeclaredNames()\n    let names1 = %0\n  } else {\n    let names1 = (list [])[#104]\n  }\n  sdo-call %1 = this[1]->LexicallyDeclaredNames()\n  let names2 = %1\n  if (exists this[2]) {\n    sdo-call %2 = this[2]->LexicallyDeclaredNames()\n    let names3 = %2\n  } else {\n    let names3 = (list [])[#105]\n  }\n  call %3 = clo<\"__FLAT_LIST__\">((list [names1, names2, names3])[#106])\n  return %3\n}","def <SYNTAX>:CaseBlock[1,3].LexicallyDeclaredNames(\n  this: Ast[CaseBlock[1]],\n): List[String] = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->LexicallyDeclaredNames()\n    let names1 = %0\n  } else {\n    let names1 = (list [])[#107]\n  }\n  sdo-call %1 = this[1]->LexicallyDeclaredNames()\n  let names2 = %1\n  if (exists this[2]) {\n    sdo-call %2 = this[2]->LexicallyDeclaredNames()\n    let names3 = %2\n  } else {\n    let names3 = (list [])[#108]\n  }\n  call %3 = clo<\"__FLAT_LIST__\">((list [names1, names2, names3])[#109])\n  return %3\n}","def <SYNTAX>:CaseClauses[1,0].LexicallyDeclaredNames(\n  this: Ast[CaseClauses[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->LexicallyDeclaredNames()\n  let names1 = %0\n  sdo-call %1 = this[1]->LexicallyDeclaredNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#110])\n  return %2\n}","def <SYNTAX>:CaseClause[0,0].LexicallyDeclaredNames(\n  this: Ast[CaseClause[0]],\n): List[String] = {\n  if (exists this[1]) {\n    sdo-call %0 = this[1]->LexicallyDeclaredNames()\n    return %0\n  }\n  return (list [])[#111]\n}","def <SYNTAX>:CaseClause[0,1].LexicallyDeclaredNames(\n  this: Ast[CaseClause[0]],\n): List[String] = {\n  if (exists this[1]) {\n    sdo-call %0 = this[1]->LexicallyDeclaredNames()\n    return %0\n  }\n  return (list [])[#112]\n}","def <SYNTAX>:DefaultClause[0,0].LexicallyDeclaredNames(\n  this: Ast[DefaultClause[0]],\n): List[String] = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->LexicallyDeclaredNames()\n    return %0\n  }\n  return (list [])[#113]\n}","def <SYNTAX>:DefaultClause[0,1].LexicallyDeclaredNames(\n  this: Ast[DefaultClause[0]],\n): List[String] = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->LexicallyDeclaredNames()\n    return %0\n  }\n  return (list [])[#114]\n}","def <SYNTAX>:LabelledStatement[0,0].LexicallyDeclaredNames(\n  this: Ast[LabelledStatement[0]],\n): List[String] = {\n  sdo-call %0 = this[1]->LexicallyDeclaredNames()\n  return %0\n}","def <SYNTAX>:LabelledItem[0,0].LexicallyDeclaredNames(\n  this: Ast[LabelledItem[0]],\n): List[String] = {\n  return (list [])[#115]\n}","def <SYNTAX>:LabelledItem[1,0].LexicallyDeclaredNames(\n  this: Ast[LabelledItem[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:FunctionStatementList[0,0].LexicallyDeclaredNames(\n  this: Ast[FunctionStatementList[0]],\n): List[String] = {\n  return (list [])[#116]\n}","def <SYNTAX>:FunctionStatementList[0,1].LexicallyDeclaredNames(\n  this: Ast[FunctionStatementList[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->TopLevelLexicallyDeclaredNames()\n  return %0\n}","def <SYNTAX>:ClassStaticBlockStatementList[0,0].LexicallyDeclaredNames(\n  this: Ast[ClassStaticBlockStatementList[0]],\n): List[String] = {\n  return (list [])[#117]\n}","def <SYNTAX>:ClassStaticBlockStatementList[0,1].LexicallyDeclaredNames(\n  this: Ast[ClassStaticBlockStatementList[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->TopLevelLexicallyDeclaredNames()\n  return %0\n}","def <SYNTAX>:ConciseBody[0,0].LexicallyDeclaredNames(\n  this: Ast[ConciseBody[0]],\n): List[String] = {\n  return (list [])[#118]\n}","def <SYNTAX>:AsyncConciseBody[0,0].LexicallyDeclaredNames(\n  this: Ast[AsyncConciseBody[0]],\n): List[String] = {\n  return (list [])[#119]\n}","def <SYNTAX>:Script[0,0].LexicallyDeclaredNames(\n  this: Ast[Script[0]],\n): List[String] = {\n  return (list [])[#120]\n}","def <SYNTAX>:ScriptBody[0,0].LexicallyDeclaredNames(\n  this: Ast[ScriptBody[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->TopLevelLexicallyDeclaredNames()\n  return %0\n}","def <SYNTAX>:ModuleItemList[1,0].LexicallyDeclaredNames(\n  this: Ast[ModuleItemList[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->LexicallyDeclaredNames()\n  let names1 = %0\n  sdo-call %1 = this[1]->LexicallyDeclaredNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#121])\n  return %2\n}","def <SYNTAX>:ModuleItem[0,0].LexicallyDeclaredNames(\n  this: Ast[ModuleItem[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:ModuleItem[1,0].LexicallyDeclaredNames(\n  this: Ast[ModuleItem[1]],\n): List[String] = {\n  (yet \"If |ExportDeclaration| is `export` |VariableStatement|, return a new empty List.\")\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:ModuleItem[2,0].LexicallyDeclaredNames(\n  this: Ast[ModuleItem[2]],\n): List[String] = {\n  sdo-call %0 = this[0]->LexicallyDeclaredNames()\n  return %0\n}","def <SYNTAX>:StatementList[1,0].LexicallyScopedDeclarations(\n  this: Ast[StatementList[1]],\n): List[Ast] = {\n  sdo-call %0 = this[0]->LexicallyScopedDeclarations()\n  let declarations1 = %0\n  sdo-call %1 = this[1]->LexicallyScopedDeclarations()\n  let declarations2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [declarations1, declarations2])[#122])\n  return %2\n}","def <SYNTAX>:StatementListItem[0,0].LexicallyScopedDeclarations(\n  this: Ast[StatementListItem[0]],\n): List[Ast] = {\n  if (? this[0]: Ast[Statement[10]]) {\n    sdo-call %0 = this[0][0]->LexicallyScopedDeclarations()\n    return %0\n  }\n  return (list [])[#123]\n}","def <SYNTAX>:StatementListItem[1,0].LexicallyScopedDeclarations(\n  this: Ast[StatementListItem[1]],\n): List[Ast] = {\n  sdo-call %0 = this[0]->DeclarationPart()\n  return (list [%0])[#124]\n}","def <SYNTAX>:CaseBlock[0,0].LexicallyScopedDeclarations(\n  this: Ast[CaseBlock[0]],\n): List[Ast] = {\n  return (list [])[#125]\n}","def <SYNTAX>:CaseBlock[1,0].LexicallyScopedDeclarations(\n  this: Ast[CaseBlock[1]],\n): List[Ast] = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->LexicallyScopedDeclarations()\n    let declarations1 = %0\n  } else {\n    let declarations1 = (list [])[#126]\n  }\n  sdo-call %1 = this[1]->LexicallyScopedDeclarations()\n  let declarations2 = %1\n  if (exists this[2]) {\n    sdo-call %2 = this[2]->LexicallyScopedDeclarations()\n    let declarations3 = %2\n  } else {\n    let declarations3 = (list [])[#127]\n  }\n  call %3 = clo<\"__FLAT_LIST__\">((list [declarations1, declarations2, declarations3])[#128])\n  return %3\n}","def <SYNTAX>:CaseBlock[1,1].LexicallyScopedDeclarations(\n  this: Ast[CaseBlock[1]],\n): List[Ast] = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->LexicallyScopedDeclarations()\n    let declarations1 = %0\n  } else {\n    let declarations1 = (list [])[#129]\n  }\n  sdo-call %1 = this[1]->LexicallyScopedDeclarations()\n  let declarations2 = %1\n  if (exists this[2]) {\n    sdo-call %2 = this[2]->LexicallyScopedDeclarations()\n    let declarations3 = %2\n  } else {\n    let declarations3 = (list [])[#130]\n  }\n  call %3 = clo<\"__FLAT_LIST__\">((list [declarations1, declarations2, declarations3])[#131])\n  return %3\n}","def <SYNTAX>:CaseBlock[1,2].LexicallyScopedDeclarations(\n  this: Ast[CaseBlock[1]],\n): List[Ast] = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->LexicallyScopedDeclarations()\n    let declarations1 = %0\n  } else {\n    let declarations1 = (list [])[#132]\n  }\n  sdo-call %1 = this[1]->LexicallyScopedDeclarations()\n  let declarations2 = %1\n  if (exists this[2]) {\n    sdo-call %2 = this[2]->LexicallyScopedDeclarations()\n    let declarations3 = %2\n  } else {\n    let declarations3 = (list [])[#133]\n  }\n  call %3 = clo<\"__FLAT_LIST__\">((list [declarations1, declarations2, declarations3])[#134])\n  return %3\n}","def <SYNTAX>:CaseBlock[1,3].LexicallyScopedDeclarations(\n  this: Ast[CaseBlock[1]],\n): List[Ast] = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->LexicallyScopedDeclarations()\n    let declarations1 = %0\n  } else {\n    let declarations1 = (list [])[#135]\n  }\n  sdo-call %1 = this[1]->LexicallyScopedDeclarations()\n  let declarations2 = %1\n  if (exists this[2]) {\n    sdo-call %2 = this[2]->LexicallyScopedDeclarations()\n    let declarations3 = %2\n  } else {\n    let declarations3 = (list [])[#136]\n  }\n  call %3 = clo<\"__FLAT_LIST__\">((list [declarations1, declarations2, declarations3])[#137])\n  return %3\n}","def <SYNTAX>:CaseClauses[1,0].LexicallyScopedDeclarations(\n  this: Ast[CaseClauses[1]],\n): List[Ast] = {\n  sdo-call %0 = this[0]->LexicallyScopedDeclarations()\n  let declarations1 = %0\n  sdo-call %1 = this[1]->LexicallyScopedDeclarations()\n  let declarations2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [declarations1, declarations2])[#138])\n  return %2\n}","def <SYNTAX>:CaseClause[0,0].LexicallyScopedDeclarations(\n  this: Ast[CaseClause[0]],\n): List[Ast] = {\n  if (exists this[1]) {\n    sdo-call %0 = this[1]->LexicallyScopedDeclarations()\n    return %0\n  }\n  return (list [])[#139]\n}","def <SYNTAX>:CaseClause[0,1].LexicallyScopedDeclarations(\n  this: Ast[CaseClause[0]],\n): List[Ast] = {\n  if (exists this[1]) {\n    sdo-call %0 = this[1]->LexicallyScopedDeclarations()\n    return %0\n  }\n  return (list [])[#140]\n}","def <SYNTAX>:DefaultClause[0,0].LexicallyScopedDeclarations(\n  this: Ast[DefaultClause[0]],\n): List[Ast] = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->LexicallyScopedDeclarations()\n    return %0\n  }\n  return (list [])[#141]\n}","def <SYNTAX>:DefaultClause[0,1].LexicallyScopedDeclarations(\n  this: Ast[DefaultClause[0]],\n): List[Ast] = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->LexicallyScopedDeclarations()\n    return %0\n  }\n  return (list [])[#142]\n}","def <SYNTAX>:LabelledStatement[0,0].LexicallyScopedDeclarations(\n  this: Ast[LabelledStatement[0]],\n): List[Ast] = {\n  sdo-call %0 = this[1]->LexicallyScopedDeclarations()\n  return %0\n}","def <SYNTAX>:LabelledItem[0,0].LexicallyScopedDeclarations(\n  this: Ast[LabelledItem[0]],\n): List[Ast] = {\n  return (list [])[#143]\n}","def <SYNTAX>:LabelledItem[1,0].LexicallyScopedDeclarations(\n  this: Ast[LabelledItem[1]],\n): List[Ast] = {\n  return (list [this[0]])[#144]\n}","def <SYNTAX>:FunctionStatementList[0,0].LexicallyScopedDeclarations(\n  this: Ast[FunctionStatementList[0]],\n): List[Ast] = {\n  return (list [])[#145]\n}","def <SYNTAX>:FunctionStatementList[0,1].LexicallyScopedDeclarations(\n  this: Ast[FunctionStatementList[0]],\n): List[Ast] = {\n  sdo-call %0 = this[0]->TopLevelLexicallyScopedDeclarations()\n  return %0\n}","def <SYNTAX>:ClassStaticBlockStatementList[0,0].LexicallyScopedDeclarations(\n  this: Ast[ClassStaticBlockStatementList[0]],\n): List[Ast] = {\n  return (list [])[#146]\n}","def <SYNTAX>:ClassStaticBlockStatementList[0,1].LexicallyScopedDeclarations(\n  this: Ast[ClassStaticBlockStatementList[0]],\n): List[Ast] = {\n  sdo-call %0 = this[0]->TopLevelLexicallyScopedDeclarations()\n  return %0\n}","def <SYNTAX>:ConciseBody[0,0].LexicallyScopedDeclarations(\n  this: Ast[ConciseBody[0]],\n): List[Ast] = {\n  return (list [])[#147]\n}","def <SYNTAX>:AsyncConciseBody[0,0].LexicallyScopedDeclarations(\n  this: Ast[AsyncConciseBody[0]],\n): List[Ast] = {\n  return (list [])[#148]\n}","def <SYNTAX>:Script[0,0].LexicallyScopedDeclarations(\n  this: Ast[Script[0]],\n): List[Ast] = {\n  return (list [])[#149]\n}","def <SYNTAX>:ScriptBody[0,0].LexicallyScopedDeclarations(\n  this: Ast[ScriptBody[0]],\n): List[Ast] = {\n  sdo-call %0 = this[0]->TopLevelLexicallyScopedDeclarations()\n  return %0\n}","def <SYNTAX>:Module[0,0].LexicallyScopedDeclarations(\n  this: Ast[Module[0]],\n): List[Ast] = {\n  return (list [])[#150]\n}","def <SYNTAX>:ModuleItemList[1,0].LexicallyScopedDeclarations(\n  this: Ast[ModuleItemList[1]],\n): List[Ast] = {\n  sdo-call %0 = this[0]->LexicallyScopedDeclarations()\n  let declarations1 = %0\n  sdo-call %1 = this[1]->LexicallyScopedDeclarations()\n  let declarations2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [declarations1, declarations2])[#151])\n  return %2\n}","def <SYNTAX>:ModuleItem[0,0].LexicallyScopedDeclarations(\n  this: Ast[ModuleItem[0]],\n): List[Ast] = {\n  return (list [])[#152]\n}","def <SYNTAX>:ExportDeclaration[0,0].LexicallyScopedDeclarations(\n  this: Ast[ExportDeclaration[0]],\n): List[Ast] = {\n  return (list [])[#153]\n}","def <SYNTAX>:ExportDeclaration[1,0].LexicallyScopedDeclarations(\n  this: Ast[ExportDeclaration[1]],\n): List[Ast] = {\n  return (list [])[#154]\n}","def <SYNTAX>:ExportDeclaration[2,0].LexicallyScopedDeclarations(\n  this: Ast[ExportDeclaration[2]],\n): List[Ast] = {\n  return (list [])[#155]\n}","def <SYNTAX>:ExportDeclaration[3,0].LexicallyScopedDeclarations(\n  this: Ast[ExportDeclaration[3]],\n): List[Ast] = {\n  sdo-call %0 = this[0]->DeclarationPart()\n  return (list [%0])[#156]\n}","def <SYNTAX>:ExportDeclaration[4,0].LexicallyScopedDeclarations(\n  this: Ast[ExportDeclaration[4]],\n): List[Ast] = {\n  sdo-call %0 = this[0]->DeclarationPart()\n  return (list [%0])[#157]\n}","def <SYNTAX>:ExportDeclaration[5,0].LexicallyScopedDeclarations(\n  this: Ast[ExportDeclaration[5]],\n): List[Ast] = {\n  return (list [this[0]])[#158]\n}","def <SYNTAX>:ExportDeclaration[6,0].LexicallyScopedDeclarations(\n  this: Ast[ExportDeclaration[6]],\n): List[Ast] = {\n  return (list [this])[#159]\n}","def <SYNTAX>:Statement[2,0].VarDeclaredNames(\n  this: Ast[Statement[2]],\n): List[String] = {\n  return (list [])[#160]\n}","def <SYNTAX>:Statement[3,0].VarDeclaredNames(\n  this: Ast[Statement[3]],\n): List[String] = {\n  return (list [])[#161]\n}","def <SYNTAX>:Statement[6,0].VarDeclaredNames(\n  this: Ast[Statement[6]],\n): List[String] = {\n  return (list [])[#162]\n}","def <SYNTAX>:Statement[7,0].VarDeclaredNames(\n  this: Ast[Statement[7]],\n): List[String] = {\n  return (list [])[#163]\n}","def <SYNTAX>:Statement[8,0].VarDeclaredNames(\n  this: Ast[Statement[8]],\n): List[String] = {\n  return (list [])[#164]\n}","def <SYNTAX>:Statement[11,0].VarDeclaredNames(\n  this: Ast[Statement[11]],\n): List[String] = {\n  return (list [])[#165]\n}","def <SYNTAX>:Statement[13,0].VarDeclaredNames(\n  this: Ast[Statement[13]],\n): List[String] = {\n  return (list [])[#166]\n}","def <SYNTAX>:Block[0,0].VarDeclaredNames(\n  this: Ast[Block[0]],\n): List[String] = {\n  return (list [])[#167]\n}","def <SYNTAX>:StatementList[1,0].VarDeclaredNames(\n  this: Ast[StatementList[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->VarDeclaredNames()\n  let names1 = %0\n  sdo-call %1 = this[1]->VarDeclaredNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#168])\n  return %2\n}","def <SYNTAX>:StatementListItem[1,0].VarDeclaredNames(\n  this: Ast[StatementListItem[1]],\n): List[String] = {\n  return (list [])[#169]\n}","def <SYNTAX>:VariableStatement[0,0].VarDeclaredNames(\n  this: Ast[VariableStatement[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:IfStatement[0,0].VarDeclaredNames(\n  this: Ast[IfStatement[0]],\n): List[String] = {\n  sdo-call %0 = this[1]->VarDeclaredNames()\n  let names1 = %0\n  sdo-call %1 = this[2]->VarDeclaredNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#170])\n  return %2\n}","def <SYNTAX>:IfStatement[1,0].VarDeclaredNames(\n  this: Ast[IfStatement[1]],\n): List[String] = {\n  sdo-call %0 = this[1]->VarDeclaredNames()\n  return %0\n}","def <SYNTAX>:DoWhileStatement[0,0].VarDeclaredNames(\n  this: Ast[DoWhileStatement[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->VarDeclaredNames()\n  return %0\n}","def <SYNTAX>:WhileStatement[0,0].VarDeclaredNames(\n  this: Ast[WhileStatement[0]],\n): List[String] = {\n  sdo-call %0 = this[1]->VarDeclaredNames()\n  return %0\n}","def <SYNTAX>:ForStatement[0,0].VarDeclaredNames(\n  this: Ast[ForStatement[0]],\n): List[String] = {\n  sdo-call %0 = this[3]->VarDeclaredNames()\n  return %0\n}","def <SYNTAX>:ForStatement[0,1].VarDeclaredNames(\n  this: Ast[ForStatement[0]],\n): List[String] = {\n  sdo-call %0 = this[3]->VarDeclaredNames()\n  return %0\n}","def <SYNTAX>:ForStatement[0,2].VarDeclaredNames(\n  this: Ast[ForStatement[0]],\n): List[String] = {\n  sdo-call %0 = this[3]->VarDeclaredNames()\n  return %0\n}","def <SYNTAX>:ForStatement[0,3].VarDeclaredNames(\n  this: Ast[ForStatement[0]],\n): List[String] = {\n  sdo-call %0 = this[3]->VarDeclaredNames()\n  return %0\n}","def <SYNTAX>:ForStatement[0,4].VarDeclaredNames(\n  this: Ast[ForStatement[0]],\n): List[String] = {\n  sdo-call %0 = this[3]->VarDeclaredNames()\n  return %0\n}","def <SYNTAX>:ForStatement[0,5].VarDeclaredNames(\n  this: Ast[ForStatement[0]],\n): List[String] = {\n  sdo-call %0 = this[3]->VarDeclaredNames()\n  return %0\n}","def <SYNTAX>:ForStatement[0,6].VarDeclaredNames(\n  this: Ast[ForStatement[0]],\n): List[String] = {\n  sdo-call %0 = this[3]->VarDeclaredNames()\n  return %0\n}","def <SYNTAX>:ForStatement[0,7].VarDeclaredNames(\n  this: Ast[ForStatement[0]],\n): List[String] = {\n  sdo-call %0 = this[3]->VarDeclaredNames()\n  return %0\n}","def <SYNTAX>:ForStatement[1,0].VarDeclaredNames(\n  this: Ast[ForStatement[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  let names1 = %0\n  sdo-call %1 = this[3]->VarDeclaredNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#171])\n  return %2\n}","def <SYNTAX>:ForStatement[1,1].VarDeclaredNames(\n  this: Ast[ForStatement[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  let names1 = %0\n  sdo-call %1 = this[3]->VarDeclaredNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#172])\n  return %2\n}","def <SYNTAX>:ForStatement[1,2].VarDeclaredNames(\n  this: Ast[ForStatement[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  let names1 = %0\n  sdo-call %1 = this[3]->VarDeclaredNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#173])\n  return %2\n}","def <SYNTAX>:ForStatement[1,3].VarDeclaredNames(\n  this: Ast[ForStatement[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  let names1 = %0\n  sdo-call %1 = this[3]->VarDeclaredNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#174])\n  return %2\n}","def <SYNTAX>:ForStatement[2,0].VarDeclaredNames(\n  this: Ast[ForStatement[2]],\n): List[String] = {\n  sdo-call %0 = this[3]->VarDeclaredNames()\n  return %0\n}","def <SYNTAX>:ForStatement[2,1].VarDeclaredNames(\n  this: Ast[ForStatement[2]],\n): List[String] = {\n  sdo-call %0 = this[3]->VarDeclaredNames()\n  return %0\n}","def <SYNTAX>:ForStatement[2,2].VarDeclaredNames(\n  this: Ast[ForStatement[2]],\n): List[String] = {\n  sdo-call %0 = this[3]->VarDeclaredNames()\n  return %0\n}","def <SYNTAX>:ForStatement[2,3].VarDeclaredNames(\n  this: Ast[ForStatement[2]],\n): List[String] = {\n  sdo-call %0 = this[3]->VarDeclaredNames()\n  return %0\n}","def <SYNTAX>:ForInOfStatement[0,0].VarDeclaredNames(\n  this: Ast[ForInOfStatement[0]],\n): List[String] = {\n  sdo-call %0 = this[2]->VarDeclaredNames()\n  return %0\n}","def <SYNTAX>:ForInOfStatement[2,0].VarDeclaredNames(\n  this: Ast[ForInOfStatement[2]],\n): List[String] = {\n  sdo-call %0 = this[2]->VarDeclaredNames()\n  return %0\n}","def <SYNTAX>:ForInOfStatement[3,0].VarDeclaredNames(\n  this: Ast[ForInOfStatement[3]],\n): List[String] = {\n  sdo-call %0 = this[2]->VarDeclaredNames()\n  return %0\n}","def <SYNTAX>:ForInOfStatement[5,0].VarDeclaredNames(\n  this: Ast[ForInOfStatement[5]],\n): List[String] = {\n  sdo-call %0 = this[2]->VarDeclaredNames()\n  return %0\n}","def <SYNTAX>:ForInOfStatement[6,0].VarDeclaredNames(\n  this: Ast[ForInOfStatement[6]],\n): List[String] = {\n  sdo-call %0 = this[2]->VarDeclaredNames()\n  return %0\n}","def <SYNTAX>:ForInOfStatement[8,0].VarDeclaredNames(\n  this: Ast[ForInOfStatement[8]],\n): List[String] = {\n  sdo-call %0 = this[2]->VarDeclaredNames()\n  return %0\n}","def <SYNTAX>:ForInOfStatement[1,0].VarDeclaredNames(\n  this: Ast[ForInOfStatement[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  let names1 = %0\n  sdo-call %1 = this[2]->VarDeclaredNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#175])\n  return %2\n}","def <SYNTAX>:ForInOfStatement[4,0].VarDeclaredNames(\n  this: Ast[ForInOfStatement[4]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  let names1 = %0\n  sdo-call %1 = this[2]->VarDeclaredNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#176])\n  return %2\n}","def <SYNTAX>:ForInOfStatement[7,0].VarDeclaredNames(\n  this: Ast[ForInOfStatement[7]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  let names1 = %0\n  sdo-call %1 = this[2]->VarDeclaredNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#177])\n  return %2\n}","def <SYNTAX>:WithStatement[0,0].VarDeclaredNames(\n  this: Ast[WithStatement[0]],\n): List[String] = {\n  sdo-call %0 = this[1]->VarDeclaredNames()\n  return %0\n}","def <SYNTAX>:SwitchStatement[0,0].VarDeclaredNames(\n  this: Ast[SwitchStatement[0]],\n): List[String] = {\n  sdo-call %0 = this[1]->VarDeclaredNames()\n  return %0\n}","def <SYNTAX>:CaseBlock[0,0].VarDeclaredNames(\n  this: Ast[CaseBlock[0]],\n): List[String] = {\n  return (list [])[#178]\n}","def <SYNTAX>:CaseBlock[1,0].VarDeclaredNames(\n  this: Ast[CaseBlock[1]],\n): List[String] = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->VarDeclaredNames()\n    let names1 = %0\n  } else {\n    let names1 = (list [])[#179]\n  }\n  sdo-call %1 = this[1]->VarDeclaredNames()\n  let names2 = %1\n  if (exists this[2]) {\n    sdo-call %2 = this[2]->VarDeclaredNames()\n    let names3 = %2\n  } else {\n    let names3 = (list [])[#180]\n  }\n  call %3 = clo<\"__FLAT_LIST__\">((list [names1, names2, names3])[#181])\n  return %3\n}","def <SYNTAX>:CaseBlock[1,1].VarDeclaredNames(\n  this: Ast[CaseBlock[1]],\n): List[String] = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->VarDeclaredNames()\n    let names1 = %0\n  } else {\n    let names1 = (list [])[#182]\n  }\n  sdo-call %1 = this[1]->VarDeclaredNames()\n  let names2 = %1\n  if (exists this[2]) {\n    sdo-call %2 = this[2]->VarDeclaredNames()\n    let names3 = %2\n  } else {\n    let names3 = (list [])[#183]\n  }\n  call %3 = clo<\"__FLAT_LIST__\">((list [names1, names2, names3])[#184])\n  return %3\n}","def <SYNTAX>:CaseBlock[1,2].VarDeclaredNames(\n  this: Ast[CaseBlock[1]],\n): List[String] = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->VarDeclaredNames()\n    let names1 = %0\n  } else {\n    let names1 = (list [])[#185]\n  }\n  sdo-call %1 = this[1]->VarDeclaredNames()\n  let names2 = %1\n  if (exists this[2]) {\n    sdo-call %2 = this[2]->VarDeclaredNames()\n    let names3 = %2\n  } else {\n    let names3 = (list [])[#186]\n  }\n  call %3 = clo<\"__FLAT_LIST__\">((list [names1, names2, names3])[#187])\n  return %3\n}","def <SYNTAX>:CaseBlock[1,3].VarDeclaredNames(\n  this: Ast[CaseBlock[1]],\n): List[String] = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->VarDeclaredNames()\n    let names1 = %0\n  } else {\n    let names1 = (list [])[#188]\n  }\n  sdo-call %1 = this[1]->VarDeclaredNames()\n  let names2 = %1\n  if (exists this[2]) {\n    sdo-call %2 = this[2]->VarDeclaredNames()\n    let names3 = %2\n  } else {\n    let names3 = (list [])[#189]\n  }\n  call %3 = clo<\"__FLAT_LIST__\">((list [names1, names2, names3])[#190])\n  return %3\n}","def <SYNTAX>:CaseClauses[1,0].VarDeclaredNames(\n  this: Ast[CaseClauses[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->VarDeclaredNames()\n  let names1 = %0\n  sdo-call %1 = this[1]->VarDeclaredNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#191])\n  return %2\n}","def <SYNTAX>:CaseClause[0,0].VarDeclaredNames(\n  this: Ast[CaseClause[0]],\n): List[String] = {\n  if (exists this[1]) {\n    sdo-call %0 = this[1]->VarDeclaredNames()\n    return %0\n  }\n  return (list [])[#192]\n}","def <SYNTAX>:CaseClause[0,1].VarDeclaredNames(\n  this: Ast[CaseClause[0]],\n): List[String] = {\n  if (exists this[1]) {\n    sdo-call %0 = this[1]->VarDeclaredNames()\n    return %0\n  }\n  return (list [])[#193]\n}","def <SYNTAX>:DefaultClause[0,0].VarDeclaredNames(\n  this: Ast[DefaultClause[0]],\n): List[String] = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->VarDeclaredNames()\n    return %0\n  }\n  return (list [])[#194]\n}","def <SYNTAX>:DefaultClause[0,1].VarDeclaredNames(\n  this: Ast[DefaultClause[0]],\n): List[String] = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->VarDeclaredNames()\n    return %0\n  }\n  return (list [])[#195]\n}","def <SYNTAX>:LabelledStatement[0,0].VarDeclaredNames(\n  this: Ast[LabelledStatement[0]],\n): List[String] = {\n  sdo-call %0 = this[1]->VarDeclaredNames()\n  return %0\n}","def <SYNTAX>:LabelledItem[1,0].VarDeclaredNames(\n  this: Ast[LabelledItem[1]],\n): List[String] = {\n  return (list [])[#196]\n}","def <SYNTAX>:TryStatement[0,0].VarDeclaredNames(\n  this: Ast[TryStatement[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->VarDeclaredNames()\n  let names1 = %0\n  sdo-call %1 = this[1]->VarDeclaredNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#197])\n  return %2\n}","def <SYNTAX>:TryStatement[1,0].VarDeclaredNames(\n  this: Ast[TryStatement[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->VarDeclaredNames()\n  let names1 = %0\n  sdo-call %1 = this[1]->VarDeclaredNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#198])\n  return %2\n}","def <SYNTAX>:TryStatement[2,0].VarDeclaredNames(\n  this: Ast[TryStatement[2]],\n): List[String] = {\n  sdo-call %0 = this[0]->VarDeclaredNames()\n  let names1 = %0\n  sdo-call %1 = this[1]->VarDeclaredNames()\n  let names2 = %1\n  sdo-call %2 = this[2]->VarDeclaredNames()\n  let names3 = %2\n  call %3 = clo<\"__FLAT_LIST__\">((list [names1, names2, names3])[#199])\n  return %3\n}","def <SYNTAX>:Catch[0,0].VarDeclaredNames(\n  this: Ast[Catch[0]],\n): List[String] = {\n  sdo-call %0 = this[1]->VarDeclaredNames()\n  return %0\n}","def <SYNTAX>:FunctionStatementList[0,0].VarDeclaredNames(\n  this: Ast[FunctionStatementList[0]],\n): List[String] = {\n  return (list [])[#200]\n}","def <SYNTAX>:FunctionStatementList[0,1].VarDeclaredNames(\n  this: Ast[FunctionStatementList[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->TopLevelVarDeclaredNames()\n  return %0\n}","def <SYNTAX>:ClassStaticBlockStatementList[0,0].VarDeclaredNames(\n  this: Ast[ClassStaticBlockStatementList[0]],\n): List[String] = {\n  return (list [])[#201]\n}","def <SYNTAX>:ClassStaticBlockStatementList[0,1].VarDeclaredNames(\n  this: Ast[ClassStaticBlockStatementList[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->TopLevelVarDeclaredNames()\n  return %0\n}","def <SYNTAX>:ConciseBody[0,0].VarDeclaredNames(\n  this: Ast[ConciseBody[0]],\n): List[String] = {\n  return (list [])[#202]\n}","def <SYNTAX>:AsyncConciseBody[0,0].VarDeclaredNames(\n  this: Ast[AsyncConciseBody[0]],\n): List[String] = {\n  return (list [])[#203]\n}","def <SYNTAX>:Script[0,0].VarDeclaredNames(\n  this: Ast[Script[0]],\n): List[String] = {\n  return (list [])[#204]\n}","def <SYNTAX>:ScriptBody[0,0].VarDeclaredNames(\n  this: Ast[ScriptBody[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->TopLevelVarDeclaredNames()\n  return %0\n}","def <SYNTAX>:ModuleItemList[1,0].VarDeclaredNames(\n  this: Ast[ModuleItemList[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->VarDeclaredNames()\n  let names1 = %0\n  sdo-call %1 = this[1]->VarDeclaredNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#205])\n  return %2\n}","def <SYNTAX>:ModuleItem[0,0].VarDeclaredNames(\n  this: Ast[ModuleItem[0]],\n): List[String] = {\n  return (list [])[#206]\n}","def <SYNTAX>:ModuleItem[1,0].VarDeclaredNames(\n  this: Ast[ModuleItem[1]],\n): List[String] = {\n  (yet \"If |ExportDeclaration| is `export` |VariableStatement|, return BoundNames of |ExportDeclaration|.\")\n  return (list [])[#207]\n}","def <SYNTAX>:Statement[2,0].VarScopedDeclarations(\n  this: Ast[Statement[2]],\n): List[Ast] = {\n  return (list [])[#208]\n}","def <SYNTAX>:Statement[3,0].VarScopedDeclarations(\n  this: Ast[Statement[3]],\n): List[Ast] = {\n  return (list [])[#209]\n}","def <SYNTAX>:Statement[6,0].VarScopedDeclarations(\n  this: Ast[Statement[6]],\n): List[Ast] = {\n  return (list [])[#210]\n}","def <SYNTAX>:Statement[7,0].VarScopedDeclarations(\n  this: Ast[Statement[7]],\n): List[Ast] = {\n  return (list [])[#211]\n}","def <SYNTAX>:Statement[8,0].VarScopedDeclarations(\n  this: Ast[Statement[8]],\n): List[Ast] = {\n  return (list [])[#212]\n}","def <SYNTAX>:Statement[11,0].VarScopedDeclarations(\n  this: Ast[Statement[11]],\n): List[Ast] = {\n  return (list [])[#213]\n}","def <SYNTAX>:Statement[13,0].VarScopedDeclarations(\n  this: Ast[Statement[13]],\n): List[Ast] = {\n  return (list [])[#214]\n}","def <SYNTAX>:Block[0,0].VarScopedDeclarations(\n  this: Ast[Block[0]],\n): List[Ast] = {\n  return (list [])[#215]\n}","def <SYNTAX>:StatementList[1,0].VarScopedDeclarations(\n  this: Ast[StatementList[1]],\n): List[Ast] = {\n  sdo-call %0 = this[0]->VarScopedDeclarations()\n  let declarations1 = %0\n  sdo-call %1 = this[1]->VarScopedDeclarations()\n  let declarations2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [declarations1, declarations2])[#216])\n  return %2\n}","def <SYNTAX>:StatementListItem[1,0].VarScopedDeclarations(\n  this: Ast[StatementListItem[1]],\n): List[Ast] = {\n  return (list [])[#217]\n}","def <SYNTAX>:VariableDeclarationList[0,0].VarScopedDeclarations(\n  this: Ast[VariableDeclarationList[0]],\n): List[Ast] = {\n  return (list [this[0]])[#218]\n}","def <SYNTAX>:VariableDeclarationList[1,0].VarScopedDeclarations(\n  this: Ast[VariableDeclarationList[1]],\n): List[Ast] = {\n  sdo-call %0 = this[0]->VarScopedDeclarations()\n  let declarations1 = %0\n  call %1 = clo<\"__FLAT_LIST__\">((list [declarations1, (list [this[1]])[#220]])[#219])\n  return %1\n}","def <SYNTAX>:IfStatement[0,0].VarScopedDeclarations(\n  this: Ast[IfStatement[0]],\n): List[Ast] = {\n  sdo-call %0 = this[1]->VarScopedDeclarations()\n  let declarations1 = %0\n  sdo-call %1 = this[2]->VarScopedDeclarations()\n  let declarations2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [declarations1, declarations2])[#221])\n  return %2\n}","def <SYNTAX>:IfStatement[1,0].VarScopedDeclarations(\n  this: Ast[IfStatement[1]],\n): List[Ast] = {\n  sdo-call %0 = this[1]->VarScopedDeclarations()\n  return %0\n}","def <SYNTAX>:DoWhileStatement[0,0].VarScopedDeclarations(\n  this: Ast[DoWhileStatement[0]],\n): List[Ast] = {\n  sdo-call %0 = this[0]->VarScopedDeclarations()\n  return %0\n}","def <SYNTAX>:WhileStatement[0,0].VarScopedDeclarations(\n  this: Ast[WhileStatement[0]],\n): List[Ast] = {\n  sdo-call %0 = this[1]->VarScopedDeclarations()\n  return %0\n}","def <SYNTAX>:ForStatement[0,0].VarScopedDeclarations(\n  this: Ast[ForStatement[0]],\n): List[Ast] = {\n  sdo-call %0 = this[3]->VarScopedDeclarations()\n  return %0\n}","def <SYNTAX>:ForStatement[0,1].VarScopedDeclarations(\n  this: Ast[ForStatement[0]],\n): List[Ast] = {\n  sdo-call %0 = this[3]->VarScopedDeclarations()\n  return %0\n}","def <SYNTAX>:ForStatement[0,2].VarScopedDeclarations(\n  this: Ast[ForStatement[0]],\n): List[Ast] = {\n  sdo-call %0 = this[3]->VarScopedDeclarations()\n  return %0\n}","def <SYNTAX>:ForStatement[0,3].VarScopedDeclarations(\n  this: Ast[ForStatement[0]],\n): List[Ast] = {\n  sdo-call %0 = this[3]->VarScopedDeclarations()\n  return %0\n}","def <SYNTAX>:ForStatement[0,4].VarScopedDeclarations(\n  this: Ast[ForStatement[0]],\n): List[Ast] = {\n  sdo-call %0 = this[3]->VarScopedDeclarations()\n  return %0\n}","def <SYNTAX>:ForStatement[0,5].VarScopedDeclarations(\n  this: Ast[ForStatement[0]],\n): List[Ast] = {\n  sdo-call %0 = this[3]->VarScopedDeclarations()\n  return %0\n}","def <SYNTAX>:ForStatement[0,6].VarScopedDeclarations(\n  this: Ast[ForStatement[0]],\n): List[Ast] = {\n  sdo-call %0 = this[3]->VarScopedDeclarations()\n  return %0\n}","def <SYNTAX>:ForStatement[0,7].VarScopedDeclarations(\n  this: Ast[ForStatement[0]],\n): List[Ast] = {\n  sdo-call %0 = this[3]->VarScopedDeclarations()\n  return %0\n}","def <SYNTAX>:ForStatement[1,0].VarScopedDeclarations(\n  this: Ast[ForStatement[1]],\n): List[Ast] = {\n  sdo-call %0 = this[0]->VarScopedDeclarations()\n  let declarations1 = %0\n  sdo-call %1 = this[3]->VarScopedDeclarations()\n  let declarations2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [declarations1, declarations2])[#222])\n  return %2\n}","def <SYNTAX>:ForStatement[1,1].VarScopedDeclarations(\n  this: Ast[ForStatement[1]],\n): List[Ast] = {\n  sdo-call %0 = this[0]->VarScopedDeclarations()\n  let declarations1 = %0\n  sdo-call %1 = this[3]->VarScopedDeclarations()\n  let declarations2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [declarations1, declarations2])[#223])\n  return %2\n}","def <SYNTAX>:ForStatement[1,2].VarScopedDeclarations(\n  this: Ast[ForStatement[1]],\n): List[Ast] = {\n  sdo-call %0 = this[0]->VarScopedDeclarations()\n  let declarations1 = %0\n  sdo-call %1 = this[3]->VarScopedDeclarations()\n  let declarations2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [declarations1, declarations2])[#224])\n  return %2\n}","def <SYNTAX>:ForStatement[1,3].VarScopedDeclarations(\n  this: Ast[ForStatement[1]],\n): List[Ast] = {\n  sdo-call %0 = this[0]->VarScopedDeclarations()\n  let declarations1 = %0\n  sdo-call %1 = this[3]->VarScopedDeclarations()\n  let declarations2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [declarations1, declarations2])[#225])\n  return %2\n}","def <SYNTAX>:ForStatement[2,0].VarScopedDeclarations(\n  this: Ast[ForStatement[2]],\n): List[Ast] = {\n  sdo-call %0 = this[3]->VarScopedDeclarations()\n  return %0\n}","def <SYNTAX>:ForStatement[2,1].VarScopedDeclarations(\n  this: Ast[ForStatement[2]],\n): List[Ast] = {\n  sdo-call %0 = this[3]->VarScopedDeclarations()\n  return %0\n}","def <SYNTAX>:ForStatement[2,2].VarScopedDeclarations(\n  this: Ast[ForStatement[2]],\n): List[Ast] = {\n  sdo-call %0 = this[3]->VarScopedDeclarations()\n  return %0\n}","def <SYNTAX>:ForStatement[2,3].VarScopedDeclarations(\n  this: Ast[ForStatement[2]],\n): List[Ast] = {\n  sdo-call %0 = this[3]->VarScopedDeclarations()\n  return %0\n}","def <SYNTAX>:ForInOfStatement[0,0].VarScopedDeclarations(\n  this: Ast[ForInOfStatement[0]],\n): List[Ast] = {\n  sdo-call %0 = this[2]->VarScopedDeclarations()\n  return %0\n}","def <SYNTAX>:ForInOfStatement[2,0].VarScopedDeclarations(\n  this: Ast[ForInOfStatement[2]],\n): List[Ast] = {\n  sdo-call %0 = this[2]->VarScopedDeclarations()\n  return %0\n}","def <SYNTAX>:ForInOfStatement[3,0].VarScopedDeclarations(\n  this: Ast[ForInOfStatement[3]],\n): List[Ast] = {\n  sdo-call %0 = this[2]->VarScopedDeclarations()\n  return %0\n}","def <SYNTAX>:ForInOfStatement[5,0].VarScopedDeclarations(\n  this: Ast[ForInOfStatement[5]],\n): List[Ast] = {\n  sdo-call %0 = this[2]->VarScopedDeclarations()\n  return %0\n}","def <SYNTAX>:ForInOfStatement[6,0].VarScopedDeclarations(\n  this: Ast[ForInOfStatement[6]],\n): List[Ast] = {\n  sdo-call %0 = this[2]->VarScopedDeclarations()\n  return %0\n}","def <SYNTAX>:ForInOfStatement[8,0].VarScopedDeclarations(\n  this: Ast[ForInOfStatement[8]],\n): List[Ast] = {\n  sdo-call %0 = this[2]->VarScopedDeclarations()\n  return %0\n}","def <SYNTAX>:ForInOfStatement[1,0].VarScopedDeclarations(\n  this: Ast[ForInOfStatement[1]],\n): List[Ast] = {\n  let declarations1 = (list [this[0]])[#226]\n  sdo-call %0 = this[2]->VarScopedDeclarations()\n  let declarations2 = %0\n  call %1 = clo<\"__FLAT_LIST__\">((list [declarations1, declarations2])[#227])\n  return %1\n}","def <SYNTAX>:ForInOfStatement[4,0].VarScopedDeclarations(\n  this: Ast[ForInOfStatement[4]],\n): List[Ast] = {\n  let declarations1 = (list [this[0]])[#228]\n  sdo-call %0 = this[2]->VarScopedDeclarations()\n  let declarations2 = %0\n  call %1 = clo<\"__FLAT_LIST__\">((list [declarations1, declarations2])[#229])\n  return %1\n}","def <SYNTAX>:ForInOfStatement[7,0].VarScopedDeclarations(\n  this: Ast[ForInOfStatement[7]],\n): List[Ast] = {\n  let declarations1 = (list [this[0]])[#230]\n  sdo-call %0 = this[2]->VarScopedDeclarations()\n  let declarations2 = %0\n  call %1 = clo<\"__FLAT_LIST__\">((list [declarations1, declarations2])[#231])\n  return %1\n}","def <SYNTAX>:WithStatement[0,0].VarScopedDeclarations(\n  this: Ast[WithStatement[0]],\n): List[Ast] = {\n  sdo-call %0 = this[1]->VarScopedDeclarations()\n  return %0\n}","def <SYNTAX>:SwitchStatement[0,0].VarScopedDeclarations(\n  this: Ast[SwitchStatement[0]],\n): List[Ast] = {\n  sdo-call %0 = this[1]->VarScopedDeclarations()\n  return %0\n}","def <SYNTAX>:CaseBlock[0,0].VarScopedDeclarations(\n  this: Ast[CaseBlock[0]],\n): List[Ast] = {\n  return (list [])[#232]\n}","def <SYNTAX>:CaseBlock[1,0].VarScopedDeclarations(\n  this: Ast[CaseBlock[1]],\n): List[Ast] = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->VarScopedDeclarations()\n    let declarations1 = %0\n  } else {\n    let declarations1 = (list [])[#233]\n  }\n  sdo-call %1 = this[1]->VarScopedDeclarations()\n  let declarations2 = %1\n  if (exists this[2]) {\n    sdo-call %2 = this[2]->VarScopedDeclarations()\n    let declarations3 = %2\n  } else {\n    let declarations3 = (list [])[#234]\n  }\n  call %3 = clo<\"__FLAT_LIST__\">((list [declarations1, declarations2, declarations3])[#235])\n  return %3\n}","def <SYNTAX>:CaseBlock[1,1].VarScopedDeclarations(\n  this: Ast[CaseBlock[1]],\n): List[Ast] = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->VarScopedDeclarations()\n    let declarations1 = %0\n  } else {\n    let declarations1 = (list [])[#236]\n  }\n  sdo-call %1 = this[1]->VarScopedDeclarations()\n  let declarations2 = %1\n  if (exists this[2]) {\n    sdo-call %2 = this[2]->VarScopedDeclarations()\n    let declarations3 = %2\n  } else {\n    let declarations3 = (list [])[#237]\n  }\n  call %3 = clo<\"__FLAT_LIST__\">((list [declarations1, declarations2, declarations3])[#238])\n  return %3\n}","def <SYNTAX>:CaseBlock[1,2].VarScopedDeclarations(\n  this: Ast[CaseBlock[1]],\n): List[Ast] = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->VarScopedDeclarations()\n    let declarations1 = %0\n  } else {\n    let declarations1 = (list [])[#239]\n  }\n  sdo-call %1 = this[1]->VarScopedDeclarations()\n  let declarations2 = %1\n  if (exists this[2]) {\n    sdo-call %2 = this[2]->VarScopedDeclarations()\n    let declarations3 = %2\n  } else {\n    let declarations3 = (list [])[#240]\n  }\n  call %3 = clo<\"__FLAT_LIST__\">((list [declarations1, declarations2, declarations3])[#241])\n  return %3\n}","def <SYNTAX>:CaseBlock[1,3].VarScopedDeclarations(\n  this: Ast[CaseBlock[1]],\n): List[Ast] = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->VarScopedDeclarations()\n    let declarations1 = %0\n  } else {\n    let declarations1 = (list [])[#242]\n  }\n  sdo-call %1 = this[1]->VarScopedDeclarations()\n  let declarations2 = %1\n  if (exists this[2]) {\n    sdo-call %2 = this[2]->VarScopedDeclarations()\n    let declarations3 = %2\n  } else {\n    let declarations3 = (list [])[#243]\n  }\n  call %3 = clo<\"__FLAT_LIST__\">((list [declarations1, declarations2, declarations3])[#244])\n  return %3\n}","def <SYNTAX>:CaseClauses[1,0].VarScopedDeclarations(\n  this: Ast[CaseClauses[1]],\n): List[Ast] = {\n  sdo-call %0 = this[0]->VarScopedDeclarations()\n  let declarations1 = %0\n  sdo-call %1 = this[1]->VarScopedDeclarations()\n  let declarations2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [declarations1, declarations2])[#245])\n  return %2\n}","def <SYNTAX>:CaseClause[0,0].VarScopedDeclarations(\n  this: Ast[CaseClause[0]],\n): List[Ast] = {\n  if (exists this[1]) {\n    sdo-call %0 = this[1]->VarScopedDeclarations()\n    return %0\n  }\n  return (list [])[#246]\n}","def <SYNTAX>:CaseClause[0,1].VarScopedDeclarations(\n  this: Ast[CaseClause[0]],\n): List[Ast] = {\n  if (exists this[1]) {\n    sdo-call %0 = this[1]->VarScopedDeclarations()\n    return %0\n  }\n  return (list [])[#247]\n}","def <SYNTAX>:DefaultClause[0,0].VarScopedDeclarations(\n  this: Ast[DefaultClause[0]],\n): List[Ast] = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->VarScopedDeclarations()\n    return %0\n  }\n  return (list [])[#248]\n}","def <SYNTAX>:DefaultClause[0,1].VarScopedDeclarations(\n  this: Ast[DefaultClause[0]],\n): List[Ast] = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->VarScopedDeclarations()\n    return %0\n  }\n  return (list [])[#249]\n}","def <SYNTAX>:LabelledStatement[0,0].VarScopedDeclarations(\n  this: Ast[LabelledStatement[0]],\n): List[Ast] = {\n  sdo-call %0 = this[1]->VarScopedDeclarations()\n  return %0\n}","def <SYNTAX>:LabelledItem[1,0].VarScopedDeclarations(\n  this: Ast[LabelledItem[1]],\n): List[Ast] = {\n  return (list [])[#250]\n}","def <SYNTAX>:TryStatement[0,0].VarScopedDeclarations(\n  this: Ast[TryStatement[0]],\n): List[Ast] = {\n  sdo-call %0 = this[0]->VarScopedDeclarations()\n  let declarations1 = %0\n  sdo-call %1 = this[1]->VarScopedDeclarations()\n  let declarations2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [declarations1, declarations2])[#251])\n  return %2\n}","def <SYNTAX>:TryStatement[1,0].VarScopedDeclarations(\n  this: Ast[TryStatement[1]],\n): List[Ast] = {\n  sdo-call %0 = this[0]->VarScopedDeclarations()\n  let declarations1 = %0\n  sdo-call %1 = this[1]->VarScopedDeclarations()\n  let declarations2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [declarations1, declarations2])[#252])\n  return %2\n}","def <SYNTAX>:TryStatement[2,0].VarScopedDeclarations(\n  this: Ast[TryStatement[2]],\n): List[Ast] = {\n  sdo-call %0 = this[0]->VarScopedDeclarations()\n  let declarations1 = %0\n  sdo-call %1 = this[1]->VarScopedDeclarations()\n  let declarations2 = %1\n  sdo-call %2 = this[2]->VarScopedDeclarations()\n  let declarations3 = %2\n  call %3 = clo<\"__FLAT_LIST__\">((list [declarations1, declarations2, declarations3])[#253])\n  return %3\n}","def <SYNTAX>:Catch[0,0].VarScopedDeclarations(\n  this: Ast[Catch[0]],\n): List[Ast] = {\n  sdo-call %0 = this[1]->VarScopedDeclarations()\n  return %0\n}","def <SYNTAX>:FunctionStatementList[0,0].VarScopedDeclarations(\n  this: Ast[FunctionStatementList[0]],\n): List[Ast] = {\n  return (list [])[#254]\n}","def <SYNTAX>:FunctionStatementList[0,1].VarScopedDeclarations(\n  this: Ast[FunctionStatementList[0]],\n): List[Ast] = {\n  sdo-call %0 = this[0]->TopLevelVarScopedDeclarations()\n  return %0\n}","def <SYNTAX>:ClassStaticBlockStatementList[0,0].VarScopedDeclarations(\n  this: Ast[ClassStaticBlockStatementList[0]],\n): List[Ast] = {\n  return (list [])[#255]\n}","def <SYNTAX>:ClassStaticBlockStatementList[0,1].VarScopedDeclarations(\n  this: Ast[ClassStaticBlockStatementList[0]],\n): List[Ast] = {\n  sdo-call %0 = this[0]->TopLevelVarScopedDeclarations()\n  return %0\n}","def <SYNTAX>:ConciseBody[0,0].VarScopedDeclarations(\n  this: Ast[ConciseBody[0]],\n): List[Ast] = {\n  return (list [])[#256]\n}","def <SYNTAX>:AsyncConciseBody[0,0].VarScopedDeclarations(\n  this: Ast[AsyncConciseBody[0]],\n): List[Ast] = {\n  return (list [])[#257]\n}","def <SYNTAX>:Script[0,0].VarScopedDeclarations(\n  this: Ast[Script[0]],\n): List[Ast] = {\n  return (list [])[#258]\n}","def <SYNTAX>:ScriptBody[0,0].VarScopedDeclarations(\n  this: Ast[ScriptBody[0]],\n): List[Ast] = {\n  sdo-call %0 = this[0]->TopLevelVarScopedDeclarations()\n  return %0\n}","def <SYNTAX>:Module[0,0].VarScopedDeclarations(\n  this: Ast[Module[0]],\n): List[Ast] = {\n  return (list [])[#259]\n}","def <SYNTAX>:ModuleItemList[1,0].VarScopedDeclarations(\n  this: Ast[ModuleItemList[1]],\n): List[Ast] = {\n  sdo-call %0 = this[0]->VarScopedDeclarations()\n  let declarations1 = %0\n  sdo-call %1 = this[1]->VarScopedDeclarations()\n  let declarations2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [declarations1, declarations2])[#260])\n  return %2\n}","def <SYNTAX>:ModuleItem[0,0].VarScopedDeclarations(\n  this: Ast[ModuleItem[0]],\n): List[Ast] = {\n  return (list [])[#261]\n}","def <SYNTAX>:ModuleItem[1,0].VarScopedDeclarations(\n  this: Ast[ModuleItem[1]],\n): List[Ast] = {\n  (yet \"If |ExportDeclaration| is `export` |VariableStatement|, return VarScopedDeclarations of |VariableStatement|.\")\n  return (list [])[#262]\n}","def <SYNTAX>:StatementList[1,0].TopLevelLexicallyDeclaredNames(\n  this: Ast[StatementList[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->TopLevelLexicallyDeclaredNames()\n  let names1 = %0\n  sdo-call %1 = this[1]->TopLevelLexicallyDeclaredNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#263])\n  return %2\n}","def <SYNTAX>:StatementListItem[0,0].TopLevelLexicallyDeclaredNames(\n  this: Ast[StatementListItem[0]],\n): List[String] = {\n  return (list [])[#264]\n}","def <SYNTAX>:StatementListItem[1,0].TopLevelLexicallyDeclaredNames(\n  this: Ast[StatementListItem[1]],\n): List[String] = {\n  if (? this[0]: Ast[Declaration[0]]) {\n    return (list [])[#265]\n  }\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:StatementList[1,0].TopLevelLexicallyScopedDeclarations(\n  this: Ast[StatementList[1]],\n): List[Ast] = {\n  sdo-call %0 = this[0]->TopLevelLexicallyScopedDeclarations()\n  let declarations1 = %0\n  sdo-call %1 = this[1]->TopLevelLexicallyScopedDeclarations()\n  let declarations2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [declarations1, declarations2])[#266])\n  return %2\n}","def <SYNTAX>:StatementListItem[0,0].TopLevelLexicallyScopedDeclarations(\n  this: Ast[StatementListItem[0]],\n): List[Ast] = {\n  return (list [])[#267]\n}","def <SYNTAX>:StatementListItem[1,0].TopLevelLexicallyScopedDeclarations(\n  this: Ast[StatementListItem[1]],\n): List[Ast] = {\n  if (? this[0]: Ast[Declaration[0]]) {\n    return (list [])[#268]\n  }\n  return (list [this[0]])[#269]\n}","def <SYNTAX>:StatementList[1,0].TopLevelVarDeclaredNames(\n  this: Ast[StatementList[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->TopLevelVarDeclaredNames()\n  let names1 = %0\n  sdo-call %1 = this[1]->TopLevelVarDeclaredNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#270])\n  return %2\n}","def <SYNTAX>:StatementListItem[1,0].TopLevelVarDeclaredNames(\n  this: Ast[StatementListItem[1]],\n): List[String] = {\n  if (? this[0]: Ast[Declaration[0]]) {\n    sdo-call %0 = this[0][0]->BoundNames()\n    return %0\n  }\n  return (list [])[#271]\n}","def <SYNTAX>:StatementListItem[0,0].TopLevelVarDeclaredNames(\n  this: Ast[StatementListItem[0]],\n): List[String] = {\n  if (? this[0]: Ast[Statement[10]]) {\n    sdo-call %0 = this[0]->TopLevelVarDeclaredNames()\n    return %0\n  }\n  sdo-call %1 = this[0]->VarDeclaredNames()\n  return %1\n}","def <SYNTAX>:LabelledStatement[0,0].TopLevelVarDeclaredNames(\n  this: Ast[LabelledStatement[0]],\n): List[String] = {\n  sdo-call %0 = this[1]->TopLevelVarDeclaredNames()\n  return %0\n}","def <SYNTAX>:LabelledItem[0,0].TopLevelVarDeclaredNames(\n  this: Ast[LabelledItem[0]],\n): List[String] = {\n  if (? this[0]: Ast[Statement[10]]) {\n    sdo-call %0 = this[0]->TopLevelVarDeclaredNames()\n    return %0\n  }\n  sdo-call %1 = this[0]->VarDeclaredNames()\n  return %1\n}","def <SYNTAX>:LabelledItem[1,0].TopLevelVarDeclaredNames(\n  this: Ast[LabelledItem[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:StatementList[1,0].TopLevelVarScopedDeclarations(\n  this: Ast[StatementList[1]],\n): List[Ast] = {\n  sdo-call %0 = this[0]->TopLevelVarScopedDeclarations()\n  let declarations1 = %0\n  sdo-call %1 = this[1]->TopLevelVarScopedDeclarations()\n  let declarations2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [declarations1, declarations2])[#272])\n  return %2\n}","def <SYNTAX>:StatementListItem[0,0].TopLevelVarScopedDeclarations(\n  this: Ast[StatementListItem[0]],\n): List[Ast] = {\n  if (? this[0]: Ast[Statement[10]]) {\n    sdo-call %0 = this[0]->TopLevelVarScopedDeclarations()\n    return %0\n  }\n  sdo-call %1 = this[0]->VarScopedDeclarations()\n  return %1\n}","def <SYNTAX>:StatementListItem[1,0].TopLevelVarScopedDeclarations(\n  this: Ast[StatementListItem[1]],\n): List[Ast] = {\n  if (? this[0]: Ast[Declaration[0]]) {\n    sdo-call %0 = this[0][0]->DeclarationPart()\n    let declaration = %0\n    return (list [declaration])[#273]\n  }\n  return (list [])[#274]\n}","def <SYNTAX>:LabelledStatement[0,0].TopLevelVarScopedDeclarations(\n  this: Ast[LabelledStatement[0]],\n): List[Ast] = {\n  sdo-call %0 = this[1]->TopLevelVarScopedDeclarations()\n  return %0\n}","def <SYNTAX>:LabelledItem[0,0].TopLevelVarScopedDeclarations(\n  this: Ast[LabelledItem[0]],\n): List[Ast] = {\n  if (? this[0]: Ast[Statement[10]]) {\n    sdo-call %0 = this[0]->TopLevelVarScopedDeclarations()\n    return %0\n  }\n  sdo-call %1 = this[0]->VarScopedDeclarations()\n  return %1\n}","def <SYNTAX>:LabelledItem[1,0].TopLevelVarScopedDeclarations(\n  this: Ast[LabelledItem[1]],\n): List[Ast] = {\n  return (list [this[0]])[#275]\n}","def <SYNTAX>:Statement[1,0].ContainsDuplicateLabels(\n  this: Ast[Statement[1]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Statement[2,0].ContainsDuplicateLabels(\n  this: Ast[Statement[2]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Statement[3,0].ContainsDuplicateLabels(\n  this: Ast[Statement[3]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Statement[6,0].ContainsDuplicateLabels(\n  this: Ast[Statement[6]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Statement[7,0].ContainsDuplicateLabels(\n  this: Ast[Statement[7]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Statement[8,0].ContainsDuplicateLabels(\n  this: Ast[Statement[8]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Statement[11,0].ContainsDuplicateLabels(\n  this: Ast[Statement[11]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Statement[13,0].ContainsDuplicateLabels(\n  this: Ast[Statement[13]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Block[0,0].ContainsDuplicateLabels(\n  this: Ast[Block[0]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:StatementListItem[1,0].ContainsDuplicateLabels(\n  this: Ast[StatementListItem[1]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:StatementList[1,0].ContainsDuplicateLabels(\n  this: Ast[StatementList[1]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsDuplicateLabels(labelSet)\n  let hasDuplicates = %0\n  if (= hasDuplicates true) {\n    return true\n  }\n  sdo-call %1 = this[1]->ContainsDuplicateLabels(labelSet)\n  return %1\n}","def <SYNTAX>:IfStatement[0,0].ContainsDuplicateLabels(\n  this: Ast[IfStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[1]->ContainsDuplicateLabels(labelSet)\n  let hasDuplicate = %0\n  if (= hasDuplicate true) {\n    return true\n  }\n  sdo-call %1 = this[2]->ContainsDuplicateLabels(labelSet)\n  return %1\n}","def <SYNTAX>:IfStatement[1,0].ContainsDuplicateLabels(\n  this: Ast[IfStatement[1]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[1]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:DoWhileStatement[0,0].ContainsDuplicateLabels(\n  this: Ast[DoWhileStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:WhileStatement[0,0].ContainsDuplicateLabels(\n  this: Ast[WhileStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[1]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[0,0].ContainsDuplicateLabels(\n  this: Ast[ForStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[0,1].ContainsDuplicateLabels(\n  this: Ast[ForStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[0,2].ContainsDuplicateLabels(\n  this: Ast[ForStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[0,3].ContainsDuplicateLabels(\n  this: Ast[ForStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[0,4].ContainsDuplicateLabels(\n  this: Ast[ForStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[0,5].ContainsDuplicateLabels(\n  this: Ast[ForStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[0,6].ContainsDuplicateLabels(\n  this: Ast[ForStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[0,7].ContainsDuplicateLabels(\n  this: Ast[ForStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[1,0].ContainsDuplicateLabels(\n  this: Ast[ForStatement[1]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[1,1].ContainsDuplicateLabels(\n  this: Ast[ForStatement[1]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[1,2].ContainsDuplicateLabels(\n  this: Ast[ForStatement[1]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[1,3].ContainsDuplicateLabels(\n  this: Ast[ForStatement[1]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[2,0].ContainsDuplicateLabels(\n  this: Ast[ForStatement[2]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[2,1].ContainsDuplicateLabels(\n  this: Ast[ForStatement[2]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[2,2].ContainsDuplicateLabels(\n  this: Ast[ForStatement[2]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[2,3].ContainsDuplicateLabels(\n  this: Ast[ForStatement[2]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:ForInOfStatement[0,0].ContainsDuplicateLabels(\n  this: Ast[ForInOfStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[2]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:ForInOfStatement[1,0].ContainsDuplicateLabels(\n  this: Ast[ForInOfStatement[1]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[2]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:ForInOfStatement[2,0].ContainsDuplicateLabels(\n  this: Ast[ForInOfStatement[2]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[2]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:ForInOfStatement[3,0].ContainsDuplicateLabels(\n  this: Ast[ForInOfStatement[3]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[2]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:ForInOfStatement[4,0].ContainsDuplicateLabels(\n  this: Ast[ForInOfStatement[4]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[2]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:ForInOfStatement[5,0].ContainsDuplicateLabels(\n  this: Ast[ForInOfStatement[5]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[2]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:ForInOfStatement[6,0].ContainsDuplicateLabels(\n  this: Ast[ForInOfStatement[6]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[2]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:ForInOfStatement[7,0].ContainsDuplicateLabels(\n  this: Ast[ForInOfStatement[7]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[2]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:ForInOfStatement[8,0].ContainsDuplicateLabels(\n  this: Ast[ForInOfStatement[8]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[2]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:WithStatement[0,0].ContainsDuplicateLabels(\n  this: Ast[WithStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[1]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:SwitchStatement[0,0].ContainsDuplicateLabels(\n  this: Ast[SwitchStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[1]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:CaseBlock[0,0].ContainsDuplicateLabels(\n  this: Ast[CaseBlock[0]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:CaseBlock[1,0].ContainsDuplicateLabels(\n  this: Ast[CaseBlock[1]],\n  labelSet: List[String],\n): Boolean = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->ContainsDuplicateLabels(labelSet)\n    if (= %0 true) {\n      return true\n    }\n  }\n  sdo-call %1 = this[1]->ContainsDuplicateLabels(labelSet)\n  if (= %1 true) {\n    return true\n  }\n  if (! (exists this[2])) {\n    return false\n  }\n  sdo-call %2 = this[2]->ContainsDuplicateLabels(labelSet)\n  return %2\n}","def <SYNTAX>:CaseBlock[1,1].ContainsDuplicateLabels(\n  this: Ast[CaseBlock[1]],\n  labelSet: List[String],\n): Boolean = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->ContainsDuplicateLabels(labelSet)\n    if (= %0 true) {\n      return true\n    }\n  }\n  sdo-call %1 = this[1]->ContainsDuplicateLabels(labelSet)\n  if (= %1 true) {\n    return true\n  }\n  if (! (exists this[2])) {\n    return false\n  }\n  sdo-call %2 = this[2]->ContainsDuplicateLabels(labelSet)\n  return %2\n}","def <SYNTAX>:CaseBlock[1,2].ContainsDuplicateLabels(\n  this: Ast[CaseBlock[1]],\n  labelSet: List[String],\n): Boolean = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->ContainsDuplicateLabels(labelSet)\n    if (= %0 true) {\n      return true\n    }\n  }\n  sdo-call %1 = this[1]->ContainsDuplicateLabels(labelSet)\n  if (= %1 true) {\n    return true\n  }\n  if (! (exists this[2])) {\n    return false\n  }\n  sdo-call %2 = this[2]->ContainsDuplicateLabels(labelSet)\n  return %2\n}","def <SYNTAX>:CaseBlock[1,3].ContainsDuplicateLabels(\n  this: Ast[CaseBlock[1]],\n  labelSet: List[String],\n): Boolean = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->ContainsDuplicateLabels(labelSet)\n    if (= %0 true) {\n      return true\n    }\n  }\n  sdo-call %1 = this[1]->ContainsDuplicateLabels(labelSet)\n  if (= %1 true) {\n    return true\n  }\n  if (! (exists this[2])) {\n    return false\n  }\n  sdo-call %2 = this[2]->ContainsDuplicateLabels(labelSet)\n  return %2\n}","def <SYNTAX>:CaseClauses[1,0].ContainsDuplicateLabels(\n  this: Ast[CaseClauses[1]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsDuplicateLabels(labelSet)\n  let hasDuplicates = %0\n  if (= hasDuplicates true) {\n    return true\n  }\n  sdo-call %1 = this[1]->ContainsDuplicateLabels(labelSet)\n  return %1\n}","def <SYNTAX>:CaseClause[0,0].ContainsDuplicateLabels(\n  this: Ast[CaseClause[0]],\n  labelSet: List[String],\n): Boolean = {\n  if (exists this[1]) {\n    sdo-call %0 = this[1]->ContainsDuplicateLabels(labelSet)\n    return %0\n  }\n  return false\n}","def <SYNTAX>:CaseClause[0,1].ContainsDuplicateLabels(\n  this: Ast[CaseClause[0]],\n  labelSet: List[String],\n): Boolean = {\n  if (exists this[1]) {\n    sdo-call %0 = this[1]->ContainsDuplicateLabels(labelSet)\n    return %0\n  }\n  return false\n}","def <SYNTAX>:DefaultClause[0,0].ContainsDuplicateLabels(\n  this: Ast[DefaultClause[0]],\n  labelSet: List[String],\n): Boolean = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->ContainsDuplicateLabels(labelSet)\n    return %0\n  }\n  return false\n}","def <SYNTAX>:DefaultClause[0,1].ContainsDuplicateLabels(\n  this: Ast[DefaultClause[0]],\n  labelSet: List[String],\n): Boolean = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->ContainsDuplicateLabels(labelSet)\n    return %0\n  }\n  return false\n}","def <SYNTAX>:LabelledStatement[0,0].ContainsDuplicateLabels(\n  this: Ast[LabelledStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[0]->StringValue()\n  let label = %0\n  if (contains labelSet label) {\n    return true\n  }\n  call %1 = clo<\"__FLAT_LIST__\">((list [labelSet, (list [label])[#277]])[#276])\n  let newLabelSet = %1\n  sdo-call %2 = this[1]->ContainsDuplicateLabels(newLabelSet)\n  return %2\n}","def <SYNTAX>:LabelledItem[1,0].ContainsDuplicateLabels(\n  this: Ast[LabelledItem[1]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:TryStatement[0,0].ContainsDuplicateLabels(\n  this: Ast[TryStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsDuplicateLabels(labelSet)\n  let hasDuplicates = %0\n  if (= hasDuplicates true) {\n    return true\n  }\n  sdo-call %1 = this[1]->ContainsDuplicateLabels(labelSet)\n  return %1\n}","def <SYNTAX>:TryStatement[1,0].ContainsDuplicateLabels(\n  this: Ast[TryStatement[1]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsDuplicateLabels(labelSet)\n  let hasDuplicates = %0\n  if (= hasDuplicates true) {\n    return true\n  }\n  sdo-call %1 = this[1]->ContainsDuplicateLabels(labelSet)\n  return %1\n}","def <SYNTAX>:TryStatement[2,0].ContainsDuplicateLabels(\n  this: Ast[TryStatement[2]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsDuplicateLabels(labelSet)\n  if (= %0 true) {\n    return true\n  }\n  sdo-call %1 = this[1]->ContainsDuplicateLabels(labelSet)\n  if (= %1 true) {\n    return true\n  }\n  sdo-call %2 = this[2]->ContainsDuplicateLabels(labelSet)\n  return %2\n}","def <SYNTAX>:Catch[0,0].ContainsDuplicateLabels(\n  this: Ast[Catch[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[1]->ContainsDuplicateLabels(labelSet)\n  return %0\n}","def <SYNTAX>:FunctionStatementList[0,0].ContainsDuplicateLabels(\n  this: Ast[FunctionStatementList[0]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ClassStaticBlockStatementList[0,0].ContainsDuplicateLabels(\n  this: Ast[ClassStaticBlockStatementList[0]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ModuleItemList[1,0].ContainsDuplicateLabels(\n  this: Ast[ModuleItemList[1]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsDuplicateLabels(labelSet)\n  let hasDuplicates = %0\n  if (= hasDuplicates true) {\n    return true\n  }\n  sdo-call %1 = this[1]->ContainsDuplicateLabels(labelSet)\n  return %1\n}","def <SYNTAX>:ModuleItem[0,0].ContainsDuplicateLabels(\n  this: Ast[ModuleItem[0]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ModuleItem[1,0].ContainsDuplicateLabels(\n  this: Ast[ModuleItem[1]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Statement[1,0].ContainsUndefinedBreakTarget(\n  this: Ast[Statement[1]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Statement[2,0].ContainsUndefinedBreakTarget(\n  this: Ast[Statement[2]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Statement[3,0].ContainsUndefinedBreakTarget(\n  this: Ast[Statement[3]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Statement[6,0].ContainsUndefinedBreakTarget(\n  this: Ast[Statement[6]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Statement[8,0].ContainsUndefinedBreakTarget(\n  this: Ast[Statement[8]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Statement[11,0].ContainsUndefinedBreakTarget(\n  this: Ast[Statement[11]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Statement[13,0].ContainsUndefinedBreakTarget(\n  this: Ast[Statement[13]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Block[0,0].ContainsUndefinedBreakTarget(\n  this: Ast[Block[0]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:StatementListItem[1,0].ContainsUndefinedBreakTarget(\n  this: Ast[StatementListItem[1]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:StatementList[1,0].ContainsUndefinedBreakTarget(\n  this: Ast[StatementList[1]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsUndefinedBreakTarget(labelSet)\n  let hasUndefinedLabels = %0\n  if (= hasUndefinedLabels true) {\n    return true\n  }\n  sdo-call %1 = this[1]->ContainsUndefinedBreakTarget(labelSet)\n  return %1\n}","def <SYNTAX>:IfStatement[0,0].ContainsUndefinedBreakTarget(\n  this: Ast[IfStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[1]->ContainsUndefinedBreakTarget(labelSet)\n  let hasUndefinedLabels = %0\n  if (= hasUndefinedLabels true) {\n    return true\n  }\n  sdo-call %1 = this[2]->ContainsUndefinedBreakTarget(labelSet)\n  return %1\n}","def <SYNTAX>:IfStatement[1,0].ContainsUndefinedBreakTarget(\n  this: Ast[IfStatement[1]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[1]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:DoWhileStatement[0,0].ContainsUndefinedBreakTarget(\n  this: Ast[DoWhileStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:WhileStatement[0,0].ContainsUndefinedBreakTarget(\n  this: Ast[WhileStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[1]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[0,0].ContainsUndefinedBreakTarget(\n  this: Ast[ForStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[0,1].ContainsUndefinedBreakTarget(\n  this: Ast[ForStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[0,2].ContainsUndefinedBreakTarget(\n  this: Ast[ForStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[0,3].ContainsUndefinedBreakTarget(\n  this: Ast[ForStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[0,4].ContainsUndefinedBreakTarget(\n  this: Ast[ForStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[0,5].ContainsUndefinedBreakTarget(\n  this: Ast[ForStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[0,6].ContainsUndefinedBreakTarget(\n  this: Ast[ForStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[0,7].ContainsUndefinedBreakTarget(\n  this: Ast[ForStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[1,0].ContainsUndefinedBreakTarget(\n  this: Ast[ForStatement[1]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[1,1].ContainsUndefinedBreakTarget(\n  this: Ast[ForStatement[1]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[1,2].ContainsUndefinedBreakTarget(\n  this: Ast[ForStatement[1]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[1,3].ContainsUndefinedBreakTarget(\n  this: Ast[ForStatement[1]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[2,0].ContainsUndefinedBreakTarget(\n  this: Ast[ForStatement[2]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[2,1].ContainsUndefinedBreakTarget(\n  this: Ast[ForStatement[2]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[2,2].ContainsUndefinedBreakTarget(\n  this: Ast[ForStatement[2]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:ForStatement[2,3].ContainsUndefinedBreakTarget(\n  this: Ast[ForStatement[2]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:ForInOfStatement[0,0].ContainsUndefinedBreakTarget(\n  this: Ast[ForInOfStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[2]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:ForInOfStatement[1,0].ContainsUndefinedBreakTarget(\n  this: Ast[ForInOfStatement[1]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[2]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:ForInOfStatement[2,0].ContainsUndefinedBreakTarget(\n  this: Ast[ForInOfStatement[2]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[2]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:ForInOfStatement[3,0].ContainsUndefinedBreakTarget(\n  this: Ast[ForInOfStatement[3]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[2]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:ForInOfStatement[4,0].ContainsUndefinedBreakTarget(\n  this: Ast[ForInOfStatement[4]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[2]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:ForInOfStatement[5,0].ContainsUndefinedBreakTarget(\n  this: Ast[ForInOfStatement[5]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[2]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:ForInOfStatement[6,0].ContainsUndefinedBreakTarget(\n  this: Ast[ForInOfStatement[6]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[2]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:ForInOfStatement[7,0].ContainsUndefinedBreakTarget(\n  this: Ast[ForInOfStatement[7]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[2]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:ForInOfStatement[8,0].ContainsUndefinedBreakTarget(\n  this: Ast[ForInOfStatement[8]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[2]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:BreakStatement[0,0].ContainsUndefinedBreakTarget(\n  this: Ast[BreakStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:BreakStatement[1,0].ContainsUndefinedBreakTarget(\n  this: Ast[BreakStatement[1]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[0]->StringValue()\n  if (! (contains labelSet %0)) {\n    return true\n  }\n  return false\n}","def <SYNTAX>:WithStatement[0,0].ContainsUndefinedBreakTarget(\n  this: Ast[WithStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[1]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:SwitchStatement[0,0].ContainsUndefinedBreakTarget(\n  this: Ast[SwitchStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[1]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:CaseBlock[0,0].ContainsUndefinedBreakTarget(\n  this: Ast[CaseBlock[0]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:CaseBlock[1,0].ContainsUndefinedBreakTarget(\n  this: Ast[CaseBlock[1]],\n  labelSet: List[String],\n): Boolean = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->ContainsUndefinedBreakTarget(labelSet)\n    if (= %0 true) {\n      return true\n    }\n  }\n  sdo-call %1 = this[1]->ContainsUndefinedBreakTarget(labelSet)\n  if (= %1 true) {\n    return true\n  }\n  if (! (exists this[2])) {\n    return false\n  }\n  sdo-call %2 = this[2]->ContainsUndefinedBreakTarget(labelSet)\n  return %2\n}","def <SYNTAX>:CaseBlock[1,1].ContainsUndefinedBreakTarget(\n  this: Ast[CaseBlock[1]],\n  labelSet: List[String],\n): Boolean = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->ContainsUndefinedBreakTarget(labelSet)\n    if (= %0 true) {\n      return true\n    }\n  }\n  sdo-call %1 = this[1]->ContainsUndefinedBreakTarget(labelSet)\n  if (= %1 true) {\n    return true\n  }\n  if (! (exists this[2])) {\n    return false\n  }\n  sdo-call %2 = this[2]->ContainsUndefinedBreakTarget(labelSet)\n  return %2\n}","def <SYNTAX>:CaseBlock[1,2].ContainsUndefinedBreakTarget(\n  this: Ast[CaseBlock[1]],\n  labelSet: List[String],\n): Boolean = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->ContainsUndefinedBreakTarget(labelSet)\n    if (= %0 true) {\n      return true\n    }\n  }\n  sdo-call %1 = this[1]->ContainsUndefinedBreakTarget(labelSet)\n  if (= %1 true) {\n    return true\n  }\n  if (! (exists this[2])) {\n    return false\n  }\n  sdo-call %2 = this[2]->ContainsUndefinedBreakTarget(labelSet)\n  return %2\n}","def <SYNTAX>:CaseBlock[1,3].ContainsUndefinedBreakTarget(\n  this: Ast[CaseBlock[1]],\n  labelSet: List[String],\n): Boolean = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->ContainsUndefinedBreakTarget(labelSet)\n    if (= %0 true) {\n      return true\n    }\n  }\n  sdo-call %1 = this[1]->ContainsUndefinedBreakTarget(labelSet)\n  if (= %1 true) {\n    return true\n  }\n  if (! (exists this[2])) {\n    return false\n  }\n  sdo-call %2 = this[2]->ContainsUndefinedBreakTarget(labelSet)\n  return %2\n}","def <SYNTAX>:CaseClauses[1,0].ContainsUndefinedBreakTarget(\n  this: Ast[CaseClauses[1]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsUndefinedBreakTarget(labelSet)\n  let hasUndefinedLabels = %0\n  if (= hasUndefinedLabels true) {\n    return true\n  }\n  sdo-call %1 = this[1]->ContainsUndefinedBreakTarget(labelSet)\n  return %1\n}","def <SYNTAX>:CaseClause[0,0].ContainsUndefinedBreakTarget(\n  this: Ast[CaseClause[0]],\n  labelSet: List[String],\n): Boolean = {\n  if (exists this[1]) {\n    sdo-call %0 = this[1]->ContainsUndefinedBreakTarget(labelSet)\n    return %0\n  }\n  return false\n}","def <SYNTAX>:CaseClause[0,1].ContainsUndefinedBreakTarget(\n  this: Ast[CaseClause[0]],\n  labelSet: List[String],\n): Boolean = {\n  if (exists this[1]) {\n    sdo-call %0 = this[1]->ContainsUndefinedBreakTarget(labelSet)\n    return %0\n  }\n  return false\n}","def <SYNTAX>:DefaultClause[0,0].ContainsUndefinedBreakTarget(\n  this: Ast[DefaultClause[0]],\n  labelSet: List[String],\n): Boolean = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->ContainsUndefinedBreakTarget(labelSet)\n    return %0\n  }\n  return false\n}","def <SYNTAX>:DefaultClause[0,1].ContainsUndefinedBreakTarget(\n  this: Ast[DefaultClause[0]],\n  labelSet: List[String],\n): Boolean = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->ContainsUndefinedBreakTarget(labelSet)\n    return %0\n  }\n  return false\n}","def <SYNTAX>:LabelledStatement[0,0].ContainsUndefinedBreakTarget(\n  this: Ast[LabelledStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[0]->StringValue()\n  let label = %0\n  call %1 = clo<\"__FLAT_LIST__\">((list [labelSet, (list [label])[#279]])[#278])\n  let newLabelSet = %1\n  sdo-call %2 = this[1]->ContainsUndefinedBreakTarget(newLabelSet)\n  return %2\n}","def <SYNTAX>:LabelledItem[1,0].ContainsUndefinedBreakTarget(\n  this: Ast[LabelledItem[1]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:TryStatement[0,0].ContainsUndefinedBreakTarget(\n  this: Ast[TryStatement[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsUndefinedBreakTarget(labelSet)\n  let hasUndefinedLabels = %0\n  if (= hasUndefinedLabels true) {\n    return true\n  }\n  sdo-call %1 = this[1]->ContainsUndefinedBreakTarget(labelSet)\n  return %1\n}","def <SYNTAX>:TryStatement[1,0].ContainsUndefinedBreakTarget(\n  this: Ast[TryStatement[1]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsUndefinedBreakTarget(labelSet)\n  let hasUndefinedLabels = %0\n  if (= hasUndefinedLabels true) {\n    return true\n  }\n  sdo-call %1 = this[1]->ContainsUndefinedBreakTarget(labelSet)\n  return %1\n}","def <SYNTAX>:TryStatement[2,0].ContainsUndefinedBreakTarget(\n  this: Ast[TryStatement[2]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsUndefinedBreakTarget(labelSet)\n  if (= %0 true) {\n    return true\n  }\n  sdo-call %1 = this[1]->ContainsUndefinedBreakTarget(labelSet)\n  if (= %1 true) {\n    return true\n  }\n  sdo-call %2 = this[2]->ContainsUndefinedBreakTarget(labelSet)\n  return %2\n}","def <SYNTAX>:Catch[0,0].ContainsUndefinedBreakTarget(\n  this: Ast[Catch[0]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[1]->ContainsUndefinedBreakTarget(labelSet)\n  return %0\n}","def <SYNTAX>:FunctionStatementList[0,0].ContainsUndefinedBreakTarget(\n  this: Ast[FunctionStatementList[0]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ClassStaticBlockStatementList[0,0].ContainsUndefinedBreakTarget(\n  this: Ast[ClassStaticBlockStatementList[0]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ModuleItemList[1,0].ContainsUndefinedBreakTarget(\n  this: Ast[ModuleItemList[1]],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsUndefinedBreakTarget(labelSet)\n  let hasUndefinedLabels = %0\n  if (= hasUndefinedLabels true) {\n    return true\n  }\n  sdo-call %1 = this[1]->ContainsUndefinedBreakTarget(labelSet)\n  return %1\n}","def <SYNTAX>:ModuleItem[0,0].ContainsUndefinedBreakTarget(\n  this: Ast[ModuleItem[0]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ModuleItem[1,0].ContainsUndefinedBreakTarget(\n  this: Ast[ModuleItem[1]],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Statement[1,0].ContainsUndefinedContinueTarget(\n  this: Ast[Statement[1]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Statement[2,0].ContainsUndefinedContinueTarget(\n  this: Ast[Statement[2]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Statement[3,0].ContainsUndefinedContinueTarget(\n  this: Ast[Statement[3]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Statement[7,0].ContainsUndefinedContinueTarget(\n  this: Ast[Statement[7]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Statement[8,0].ContainsUndefinedContinueTarget(\n  this: Ast[Statement[8]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Statement[11,0].ContainsUndefinedContinueTarget(\n  this: Ast[Statement[11]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Statement[13,0].ContainsUndefinedContinueTarget(\n  this: Ast[Statement[13]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Block[0,0].ContainsUndefinedContinueTarget(\n  this: Ast[Block[0]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:StatementListItem[1,0].ContainsUndefinedContinueTarget(\n  this: Ast[StatementListItem[1]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Statement[0,0].ContainsUndefinedContinueTarget(\n  this: Ast[Statement[0]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#280])\n  return %0\n}","def <SYNTAX>:BreakableStatement[0,0].ContainsUndefinedContinueTarget(\n  this: Ast[BreakableStatement[0]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  call %0 = clo<\"__FLAT_LIST__\">((list [iterationSet, labelSet])[#281])\n  let newIterationSet = %0\n  sdo-call %1 = this[0]->ContainsUndefinedContinueTarget(newIterationSet, (list [])[#282])\n  return %1\n}","def <SYNTAX>:StatementList[1,0].ContainsUndefinedContinueTarget(\n  this: Ast[StatementList[1]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#283])\n  let hasUndefinedLabels = %0\n  if (= hasUndefinedLabels true) {\n    return true\n  }\n  sdo-call %1 = this[1]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#284])\n  return %1\n}","def <SYNTAX>:IfStatement[0,0].ContainsUndefinedContinueTarget(\n  this: Ast[IfStatement[0]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[1]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#285])\n  let hasUndefinedLabels = %0\n  if (= hasUndefinedLabels true) {\n    return true\n  }\n  sdo-call %1 = this[2]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#286])\n  return %1\n}","def <SYNTAX>:IfStatement[1,0].ContainsUndefinedContinueTarget(\n  this: Ast[IfStatement[1]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[1]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#287])\n  return %0\n}","def <SYNTAX>:DoWhileStatement[0,0].ContainsUndefinedContinueTarget(\n  this: Ast[DoWhileStatement[0]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#288])\n  return %0\n}","def <SYNTAX>:WhileStatement[0,0].ContainsUndefinedContinueTarget(\n  this: Ast[WhileStatement[0]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[1]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#289])\n  return %0\n}","def <SYNTAX>:ForStatement[0,0].ContainsUndefinedContinueTarget(\n  this: Ast[ForStatement[0]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#290])\n  return %0\n}","def <SYNTAX>:ForStatement[0,1].ContainsUndefinedContinueTarget(\n  this: Ast[ForStatement[0]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#291])\n  return %0\n}","def <SYNTAX>:ForStatement[0,2].ContainsUndefinedContinueTarget(\n  this: Ast[ForStatement[0]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#292])\n  return %0\n}","def <SYNTAX>:ForStatement[0,3].ContainsUndefinedContinueTarget(\n  this: Ast[ForStatement[0]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#293])\n  return %0\n}","def <SYNTAX>:ForStatement[0,4].ContainsUndefinedContinueTarget(\n  this: Ast[ForStatement[0]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#294])\n  return %0\n}","def <SYNTAX>:ForStatement[0,5].ContainsUndefinedContinueTarget(\n  this: Ast[ForStatement[0]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#295])\n  return %0\n}","def <SYNTAX>:ForStatement[0,6].ContainsUndefinedContinueTarget(\n  this: Ast[ForStatement[0]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#296])\n  return %0\n}","def <SYNTAX>:ForStatement[0,7].ContainsUndefinedContinueTarget(\n  this: Ast[ForStatement[0]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#297])\n  return %0\n}","def <SYNTAX>:ForStatement[1,0].ContainsUndefinedContinueTarget(\n  this: Ast[ForStatement[1]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#298])\n  return %0\n}","def <SYNTAX>:ForStatement[1,1].ContainsUndefinedContinueTarget(\n  this: Ast[ForStatement[1]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#299])\n  return %0\n}","def <SYNTAX>:ForStatement[1,2].ContainsUndefinedContinueTarget(\n  this: Ast[ForStatement[1]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#300])\n  return %0\n}","def <SYNTAX>:ForStatement[1,3].ContainsUndefinedContinueTarget(\n  this: Ast[ForStatement[1]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#301])\n  return %0\n}","def <SYNTAX>:ForStatement[2,0].ContainsUndefinedContinueTarget(\n  this: Ast[ForStatement[2]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#302])\n  return %0\n}","def <SYNTAX>:ForStatement[2,1].ContainsUndefinedContinueTarget(\n  this: Ast[ForStatement[2]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#303])\n  return %0\n}","def <SYNTAX>:ForStatement[2,2].ContainsUndefinedContinueTarget(\n  this: Ast[ForStatement[2]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#304])\n  return %0\n}","def <SYNTAX>:ForStatement[2,3].ContainsUndefinedContinueTarget(\n  this: Ast[ForStatement[2]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[3]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#305])\n  return %0\n}","def <SYNTAX>:ForInOfStatement[0,0].ContainsUndefinedContinueTarget(\n  this: Ast[ForInOfStatement[0]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[2]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#306])\n  return %0\n}","def <SYNTAX>:ForInOfStatement[1,0].ContainsUndefinedContinueTarget(\n  this: Ast[ForInOfStatement[1]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[2]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#307])\n  return %0\n}","def <SYNTAX>:ForInOfStatement[2,0].ContainsUndefinedContinueTarget(\n  this: Ast[ForInOfStatement[2]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[2]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#308])\n  return %0\n}","def <SYNTAX>:ForInOfStatement[3,0].ContainsUndefinedContinueTarget(\n  this: Ast[ForInOfStatement[3]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[2]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#309])\n  return %0\n}","def <SYNTAX>:ForInOfStatement[4,0].ContainsUndefinedContinueTarget(\n  this: Ast[ForInOfStatement[4]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[2]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#310])\n  return %0\n}","def <SYNTAX>:ForInOfStatement[5,0].ContainsUndefinedContinueTarget(\n  this: Ast[ForInOfStatement[5]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[2]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#311])\n  return %0\n}","def <SYNTAX>:ForInOfStatement[6,0].ContainsUndefinedContinueTarget(\n  this: Ast[ForInOfStatement[6]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[2]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#312])\n  return %0\n}","def <SYNTAX>:ForInOfStatement[7,0].ContainsUndefinedContinueTarget(\n  this: Ast[ForInOfStatement[7]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[2]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#313])\n  return %0\n}","def <SYNTAX>:ForInOfStatement[8,0].ContainsUndefinedContinueTarget(\n  this: Ast[ForInOfStatement[8]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[2]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#314])\n  return %0\n}","def <SYNTAX>:ContinueStatement[0,0].ContainsUndefinedContinueTarget(\n  this: Ast[ContinueStatement[0]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ContinueStatement[1,0].ContainsUndefinedContinueTarget(\n  this: Ast[ContinueStatement[1]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[0]->StringValue()\n  if (! (contains iterationSet %0)) {\n    return true\n  }\n  return false\n}","def <SYNTAX>:WithStatement[0,0].ContainsUndefinedContinueTarget(\n  this: Ast[WithStatement[0]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[1]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#315])\n  return %0\n}","def <SYNTAX>:SwitchStatement[0,0].ContainsUndefinedContinueTarget(\n  this: Ast[SwitchStatement[0]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[1]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#316])\n  return %0\n}","def <SYNTAX>:CaseBlock[0,0].ContainsUndefinedContinueTarget(\n  this: Ast[CaseBlock[0]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:CaseBlock[1,0].ContainsUndefinedContinueTarget(\n  this: Ast[CaseBlock[1]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#317])\n    if (= %0 true) {\n      return true\n    }\n  }\n  sdo-call %1 = this[1]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#318])\n  if (= %1 true) {\n    return true\n  }\n  if (! (exists this[2])) {\n    return false\n  }\n  sdo-call %2 = this[2]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#319])\n  return %2\n}","def <SYNTAX>:CaseBlock[1,1].ContainsUndefinedContinueTarget(\n  this: Ast[CaseBlock[1]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#320])\n    if (= %0 true) {\n      return true\n    }\n  }\n  sdo-call %1 = this[1]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#321])\n  if (= %1 true) {\n    return true\n  }\n  if (! (exists this[2])) {\n    return false\n  }\n  sdo-call %2 = this[2]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#322])\n  return %2\n}","def <SYNTAX>:CaseBlock[1,2].ContainsUndefinedContinueTarget(\n  this: Ast[CaseBlock[1]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#323])\n    if (= %0 true) {\n      return true\n    }\n  }\n  sdo-call %1 = this[1]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#324])\n  if (= %1 true) {\n    return true\n  }\n  if (! (exists this[2])) {\n    return false\n  }\n  sdo-call %2 = this[2]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#325])\n  return %2\n}","def <SYNTAX>:CaseBlock[1,3].ContainsUndefinedContinueTarget(\n  this: Ast[CaseBlock[1]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#326])\n    if (= %0 true) {\n      return true\n    }\n  }\n  sdo-call %1 = this[1]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#327])\n  if (= %1 true) {\n    return true\n  }\n  if (! (exists this[2])) {\n    return false\n  }\n  sdo-call %2 = this[2]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#328])\n  return %2\n}","def <SYNTAX>:CaseClauses[1,0].ContainsUndefinedContinueTarget(\n  this: Ast[CaseClauses[1]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#329])\n  let hasUndefinedLabels = %0\n  if (= hasUndefinedLabels true) {\n    return true\n  }\n  sdo-call %1 = this[1]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#330])\n  return %1\n}","def <SYNTAX>:CaseClause[0,0].ContainsUndefinedContinueTarget(\n  this: Ast[CaseClause[0]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  if (exists this[1]) {\n    sdo-call %0 = this[1]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#331])\n    return %0\n  }\n  return false\n}","def <SYNTAX>:CaseClause[0,1].ContainsUndefinedContinueTarget(\n  this: Ast[CaseClause[0]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  if (exists this[1]) {\n    sdo-call %0 = this[1]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#332])\n    return %0\n  }\n  return false\n}","def <SYNTAX>:DefaultClause[0,0].ContainsUndefinedContinueTarget(\n  this: Ast[DefaultClause[0]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#333])\n    return %0\n  }\n  return false\n}","def <SYNTAX>:DefaultClause[0,1].ContainsUndefinedContinueTarget(\n  this: Ast[DefaultClause[0]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#334])\n    return %0\n  }\n  return false\n}","def <SYNTAX>:LabelledStatement[0,0].ContainsUndefinedContinueTarget(\n  this: Ast[LabelledStatement[0]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[0]->StringValue()\n  let label = %0\n  call %1 = clo<\"__FLAT_LIST__\">((list [labelSet, (list [label])[#336]])[#335])\n  let newLabelSet = %1\n  sdo-call %2 = this[1]->ContainsUndefinedContinueTarget(iterationSet, newLabelSet)\n  return %2\n}","def <SYNTAX>:LabelledItem[1,0].ContainsUndefinedContinueTarget(\n  this: Ast[LabelledItem[1]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:TryStatement[0,0].ContainsUndefinedContinueTarget(\n  this: Ast[TryStatement[0]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#337])\n  let hasUndefinedLabels = %0\n  if (= hasUndefinedLabels true) {\n    return true\n  }\n  sdo-call %1 = this[1]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#338])\n  return %1\n}","def <SYNTAX>:TryStatement[1,0].ContainsUndefinedContinueTarget(\n  this: Ast[TryStatement[1]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#339])\n  let hasUndefinedLabels = %0\n  if (= hasUndefinedLabels true) {\n    return true\n  }\n  sdo-call %1 = this[1]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#340])\n  return %1\n}","def <SYNTAX>:TryStatement[2,0].ContainsUndefinedContinueTarget(\n  this: Ast[TryStatement[2]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#341])\n  if (= %0 true) {\n    return true\n  }\n  sdo-call %1 = this[1]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#342])\n  if (= %1 true) {\n    return true\n  }\n  sdo-call %2 = this[2]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#343])\n  return %2\n}","def <SYNTAX>:Catch[0,0].ContainsUndefinedContinueTarget(\n  this: Ast[Catch[0]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[1]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#344])\n  return %0\n}","def <SYNTAX>:FunctionStatementList[0,0].ContainsUndefinedContinueTarget(\n  this: Ast[FunctionStatementList[0]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ClassStaticBlockStatementList[0,0].ContainsUndefinedContinueTarget(\n  this: Ast[ClassStaticBlockStatementList[0]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ModuleItemList[1,0].ContainsUndefinedContinueTarget(\n  this: Ast[ModuleItemList[1]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#345])\n  let hasUndefinedLabels = %0\n  if (= hasUndefinedLabels true) {\n    return true\n  }\n  sdo-call %1 = this[1]->ContainsUndefinedContinueTarget(iterationSet, (list [])[#346])\n  return %1\n}","def <SYNTAX>:ModuleItem[0,0].ContainsUndefinedContinueTarget(\n  this: Ast[ModuleItem[0]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ModuleItem[1,0].ContainsUndefinedContinueTarget(\n  this: Ast[ModuleItem[1]],\n  iterationSet: List[String],\n  labelSet: List[String],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[12,0].HasName(\n  this: Ast[PrimaryExpression[12]],\n): Boolean = {\n  let expr = (parse this[0] (grammar-symbol |ParenthesizedExpression|))\n  sdo-call %0 = expr->IsFunctionDefinition()\n  if (= %0 false) {\n    return false\n  }\n  sdo-call %1 = expr->HasName()\n  return %1\n}","def <SYNTAX>:FunctionExpression[0,0].HasName(\n  this: Ast[FunctionExpression[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:GeneratorExpression[0,0].HasName(\n  this: Ast[GeneratorExpression[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AsyncGeneratorExpression[0,0].HasName(\n  this: Ast[AsyncGeneratorExpression[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AsyncFunctionExpression[0,0].HasName(\n  this: Ast[AsyncFunctionExpression[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ArrowFunction[0,0].HasName(\n  this: Ast[ArrowFunction[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AsyncArrowFunction[0,0].HasName(\n  this: Ast[AsyncArrowFunction[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AsyncArrowFunction[1,0].HasName(\n  this: Ast[AsyncArrowFunction[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ClassExpression[0,0].HasName(\n  this: Ast[ClassExpression[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:FunctionExpression[0,1].HasName(\n  this: Ast[FunctionExpression[0]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:GeneratorExpression[0,1].HasName(\n  this: Ast[GeneratorExpression[0]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:AsyncGeneratorExpression[0,1].HasName(\n  this: Ast[AsyncGeneratorExpression[0]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:AsyncFunctionExpression[0,1].HasName(\n  this: Ast[AsyncFunctionExpression[0]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:ClassExpression[0,1].HasName(\n  this: Ast[ClassExpression[0]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:PrimaryExpression[12,0].IsFunctionDefinition(\n  this: Ast[PrimaryExpression[12]],\n): Boolean = {\n  let expr = (parse this[0] (grammar-symbol |ParenthesizedExpression|))\n  sdo-call %0 = expr->IsFunctionDefinition()\n  return %0\n}","def <SYNTAX>:PrimaryExpression[0,0].IsFunctionDefinition(\n  this: Ast[PrimaryExpression[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[1,0].IsFunctionDefinition(\n  this: Ast[PrimaryExpression[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[2,0].IsFunctionDefinition(\n  this: Ast[PrimaryExpression[2]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[3,0].IsFunctionDefinition(\n  this: Ast[PrimaryExpression[3]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[4,0].IsFunctionDefinition(\n  this: Ast[PrimaryExpression[4]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[10,0].IsFunctionDefinition(\n  this: Ast[PrimaryExpression[10]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[11,0].IsFunctionDefinition(\n  this: Ast[PrimaryExpression[11]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MemberExpression[1,0].IsFunctionDefinition(\n  this: Ast[MemberExpression[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MemberExpression[2,0].IsFunctionDefinition(\n  this: Ast[MemberExpression[2]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MemberExpression[3,0].IsFunctionDefinition(\n  this: Ast[MemberExpression[3]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MemberExpression[4,0].IsFunctionDefinition(\n  this: Ast[MemberExpression[4]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MemberExpression[5,0].IsFunctionDefinition(\n  this: Ast[MemberExpression[5]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MemberExpression[6,0].IsFunctionDefinition(\n  this: Ast[MemberExpression[6]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MemberExpression[7,0].IsFunctionDefinition(\n  this: Ast[MemberExpression[7]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:NewExpression[1,0].IsFunctionDefinition(\n  this: Ast[NewExpression[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:LeftHandSideExpression[1,0].IsFunctionDefinition(\n  this: Ast[LeftHandSideExpression[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:LeftHandSideExpression[2,0].IsFunctionDefinition(\n  this: Ast[LeftHandSideExpression[2]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:UpdateExpression[1,0].IsFunctionDefinition(\n  this: Ast[UpdateExpression[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:UpdateExpression[2,0].IsFunctionDefinition(\n  this: Ast[UpdateExpression[2]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:UpdateExpression[3,0].IsFunctionDefinition(\n  this: Ast[UpdateExpression[3]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:UpdateExpression[4,0].IsFunctionDefinition(\n  this: Ast[UpdateExpression[4]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:UnaryExpression[1,0].IsFunctionDefinition(\n  this: Ast[UnaryExpression[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:UnaryExpression[2,0].IsFunctionDefinition(\n  this: Ast[UnaryExpression[2]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:UnaryExpression[3,0].IsFunctionDefinition(\n  this: Ast[UnaryExpression[3]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:UnaryExpression[4,0].IsFunctionDefinition(\n  this: Ast[UnaryExpression[4]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:UnaryExpression[5,0].IsFunctionDefinition(\n  this: Ast[UnaryExpression[5]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:UnaryExpression[6,0].IsFunctionDefinition(\n  this: Ast[UnaryExpression[6]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:UnaryExpression[7,0].IsFunctionDefinition(\n  this: Ast[UnaryExpression[7]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:UnaryExpression[8,0].IsFunctionDefinition(\n  this: Ast[UnaryExpression[8]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ExponentiationExpression[1,0].IsFunctionDefinition(\n  this: Ast[ExponentiationExpression[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MultiplicativeExpression[1,0].IsFunctionDefinition(\n  this: Ast[MultiplicativeExpression[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AdditiveExpression[1,0].IsFunctionDefinition(\n  this: Ast[AdditiveExpression[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AdditiveExpression[2,0].IsFunctionDefinition(\n  this: Ast[AdditiveExpression[2]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ShiftExpression[1,0].IsFunctionDefinition(\n  this: Ast[ShiftExpression[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ShiftExpression[2,0].IsFunctionDefinition(\n  this: Ast[ShiftExpression[2]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ShiftExpression[3,0].IsFunctionDefinition(\n  this: Ast[ShiftExpression[3]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:RelationalExpression[1,0].IsFunctionDefinition(\n  this: Ast[RelationalExpression[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:RelationalExpression[2,0].IsFunctionDefinition(\n  this: Ast[RelationalExpression[2]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:RelationalExpression[3,0].IsFunctionDefinition(\n  this: Ast[RelationalExpression[3]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:RelationalExpression[4,0].IsFunctionDefinition(\n  this: Ast[RelationalExpression[4]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:RelationalExpression[5,0].IsFunctionDefinition(\n  this: Ast[RelationalExpression[5]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:RelationalExpression[6,0].IsFunctionDefinition(\n  this: Ast[RelationalExpression[6]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:RelationalExpression[7,0].IsFunctionDefinition(\n  this: Ast[RelationalExpression[7]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:EqualityExpression[1,0].IsFunctionDefinition(\n  this: Ast[EqualityExpression[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:EqualityExpression[2,0].IsFunctionDefinition(\n  this: Ast[EqualityExpression[2]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:EqualityExpression[3,0].IsFunctionDefinition(\n  this: Ast[EqualityExpression[3]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:EqualityExpression[4,0].IsFunctionDefinition(\n  this: Ast[EqualityExpression[4]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:BitwiseANDExpression[1,0].IsFunctionDefinition(\n  this: Ast[BitwiseANDExpression[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:BitwiseXORExpression[1,0].IsFunctionDefinition(\n  this: Ast[BitwiseXORExpression[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:BitwiseORExpression[1,0].IsFunctionDefinition(\n  this: Ast[BitwiseORExpression[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:LogicalANDExpression[1,0].IsFunctionDefinition(\n  this: Ast[LogicalANDExpression[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:LogicalORExpression[1,0].IsFunctionDefinition(\n  this: Ast[LogicalORExpression[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:CoalesceExpression[0,0].IsFunctionDefinition(\n  this: Ast[CoalesceExpression[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ConditionalExpression[1,0].IsFunctionDefinition(\n  this: Ast[ConditionalExpression[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AssignmentExpression[1,0].IsFunctionDefinition(\n  this: Ast[AssignmentExpression[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AssignmentExpression[4,0].IsFunctionDefinition(\n  this: Ast[AssignmentExpression[4]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AssignmentExpression[5,0].IsFunctionDefinition(\n  this: Ast[AssignmentExpression[5]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AssignmentExpression[6,0].IsFunctionDefinition(\n  this: Ast[AssignmentExpression[6]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AssignmentExpression[7,0].IsFunctionDefinition(\n  this: Ast[AssignmentExpression[7]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AssignmentExpression[8,0].IsFunctionDefinition(\n  this: Ast[AssignmentExpression[8]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Expression[1,0].IsFunctionDefinition(\n  this: Ast[Expression[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AssignmentExpression[2,0].IsFunctionDefinition(\n  this: Ast[AssignmentExpression[2]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:AssignmentExpression[3,0].IsFunctionDefinition(\n  this: Ast[AssignmentExpression[3]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:FunctionExpression[0,0].IsFunctionDefinition(\n  this: Ast[FunctionExpression[0]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:FunctionExpression[0,1].IsFunctionDefinition(\n  this: Ast[FunctionExpression[0]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:GeneratorExpression[0,0].IsFunctionDefinition(\n  this: Ast[GeneratorExpression[0]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:GeneratorExpression[0,1].IsFunctionDefinition(\n  this: Ast[GeneratorExpression[0]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:AsyncGeneratorExpression[0,0].IsFunctionDefinition(\n  this: Ast[AsyncGeneratorExpression[0]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:AsyncGeneratorExpression[0,1].IsFunctionDefinition(\n  this: Ast[AsyncGeneratorExpression[0]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:AsyncFunctionExpression[0,0].IsFunctionDefinition(\n  this: Ast[AsyncFunctionExpression[0]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:AsyncFunctionExpression[0,1].IsFunctionDefinition(\n  this: Ast[AsyncFunctionExpression[0]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:ClassExpression[0,0].IsFunctionDefinition(\n  this: Ast[ClassExpression[0]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:ClassExpression[0,1].IsFunctionDefinition(\n  this: Ast[ClassExpression[0]],\n): Boolean = {\n  return true\n}","def IsAnonymousFunctionDefinition(\n  expr: Unknown[\"AssignmentExpressionParseNode,AnInitializerParseNode,OrAnExpressionParseNode\"],\n): Boolean = {\n  sdo-call %0 = expr->IsFunctionDefinition()\n  if (= %0 false) {\n    return false\n  }\n  sdo-call %1 = expr->HasName()\n  let hasName = %1\n  if (= hasName true) {\n    return false\n  }\n  return true\n}","def <SYNTAX>:PrimaryExpression[1,0].IsIdentifierRef(\n  this: Ast[PrimaryExpression[1]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:PrimaryExpression[0,0].IsIdentifierRef(\n  this: Ast[PrimaryExpression[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[2,0].IsIdentifierRef(\n  this: Ast[PrimaryExpression[2]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[3,0].IsIdentifierRef(\n  this: Ast[PrimaryExpression[3]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[4,0].IsIdentifierRef(\n  this: Ast[PrimaryExpression[4]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[5,0].IsIdentifierRef(\n  this: Ast[PrimaryExpression[5]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[6,0].IsIdentifierRef(\n  this: Ast[PrimaryExpression[6]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[7,0].IsIdentifierRef(\n  this: Ast[PrimaryExpression[7]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[8,0].IsIdentifierRef(\n  this: Ast[PrimaryExpression[8]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[9,0].IsIdentifierRef(\n  this: Ast[PrimaryExpression[9]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[10,0].IsIdentifierRef(\n  this: Ast[PrimaryExpression[10]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[11,0].IsIdentifierRef(\n  this: Ast[PrimaryExpression[11]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[12,0].IsIdentifierRef(\n  this: Ast[PrimaryExpression[12]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MemberExpression[1,0].IsIdentifierRef(\n  this: Ast[MemberExpression[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MemberExpression[2,0].IsIdentifierRef(\n  this: Ast[MemberExpression[2]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MemberExpression[3,0].IsIdentifierRef(\n  this: Ast[MemberExpression[3]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MemberExpression[4,0].IsIdentifierRef(\n  this: Ast[MemberExpression[4]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MemberExpression[5,0].IsIdentifierRef(\n  this: Ast[MemberExpression[5]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MemberExpression[6,0].IsIdentifierRef(\n  this: Ast[MemberExpression[6]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MemberExpression[7,0].IsIdentifierRef(\n  this: Ast[MemberExpression[7]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:NewExpression[1,0].IsIdentifierRef(\n  this: Ast[NewExpression[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:LeftHandSideExpression[1,0].IsIdentifierRef(\n  this: Ast[LeftHandSideExpression[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:LeftHandSideExpression[2,0].IsIdentifierRef(\n  this: Ast[LeftHandSideExpression[2]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[12,0].NamedEvaluation(\n  this: Ast[PrimaryExpression[12]],\n  name: Record[PrivateName | Symbol] | String,\n): Normal[Record[FunctionObject]] | Abrupt = {\n  let expr = (parse this[0] (grammar-symbol |ParenthesizedExpression|))\n  sdo-call %0 = expr->NamedEvaluation(name)\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:ParenthesizedExpression[0,0].NamedEvaluation(\n  this: Ast[ParenthesizedExpression[0]],\n  name: Record[PrivateName | Symbol] | String,\n): Normal[Record[FunctionObject]] | Abrupt = {\n  call %0 = clo<\"IsAnonymousFunctionDefinition\">(this[0])\n  assert (= %0 true)\n  sdo-call %1 = this[0]->NamedEvaluation(name)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:FunctionExpression[0,0].NamedEvaluation(\n  this: Ast[FunctionExpression[0]],\n  name: Record[PrivateName | Symbol] | String,\n): Normal[Record[FunctionObject]] | Abrupt = {\n  sdo-call %0 = this->InstantiateOrdinaryFunctionExpression(name)\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:GeneratorExpression[0,0].NamedEvaluation(\n  this: Ast[GeneratorExpression[0]],\n  name: Record[PrivateName | Symbol] | String,\n): Normal[Record[FunctionObject]] | Abrupt = {\n  sdo-call %0 = this->InstantiateGeneratorFunctionExpression(name)\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:AsyncGeneratorExpression[0,0].NamedEvaluation(\n  this: Ast[AsyncGeneratorExpression[0]],\n  name: Record[PrivateName | Symbol] | String,\n): Normal[Record[FunctionObject]] | Abrupt = {\n  sdo-call %0 = this->InstantiateAsyncGeneratorFunctionExpression(name)\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:AsyncFunctionExpression[0,0].NamedEvaluation(\n  this: Ast[AsyncFunctionExpression[0]],\n  name: Record[PrivateName | Symbol] | String,\n): Normal[Record[FunctionObject]] | Abrupt = {\n  sdo-call %0 = this->InstantiateAsyncFunctionExpression(name)\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:ArrowFunction[0,0].NamedEvaluation(\n  this: Ast[ArrowFunction[0]],\n  name: Record[PrivateName | Symbol] | String,\n): Normal[Record[FunctionObject]] | Abrupt = {\n  sdo-call %0 = this->InstantiateArrowFunctionExpression(name)\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:AsyncArrowFunction[0,0].NamedEvaluation(\n  this: Ast[AsyncArrowFunction[0]],\n  name: Record[PrivateName | Symbol] | String,\n): Normal[Record[FunctionObject]] | Abrupt = {\n  sdo-call %0 = this->InstantiateAsyncArrowFunctionExpression(name)\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:AsyncArrowFunction[1,0].NamedEvaluation(\n  this: Ast[AsyncArrowFunction[1]],\n  name: Record[PrivateName | Symbol] | String,\n): Normal[Record[FunctionObject]] | Abrupt = {\n  sdo-call %0 = this->InstantiateAsyncArrowFunctionExpression(name)\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:ClassExpression[0,0].NamedEvaluation(\n  this: Ast[ClassExpression[0]],\n  name: Record[PrivateName | Symbol] | String,\n): Normal[Record[FunctionObject]] | Abrupt = {\n  sdo-call %0 = this[1]->ClassDefinitionEvaluation(undefined, name)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let value = %0\n  value.SourceText = (source-text this)\n  if (? value: Completion) return value\n  call %1 = clo<\"NormalCompletion\">(value)\n  return %1\n}","def <SYNTAX>:<DEFAULT>.Contains(\n  this: Ast,\n  symbol: GrammarSymbol,\n): Boolean = {\n  %1 = this\n  %0 = 0\n  %2 = (sizeof %1)\n  while (< %0 %2) {\n    if (exists %1[%0]) {\n      let child = %1[%0]\n      if (instanceof child symbol) return true\n      if (instanceof child (grammar-symbol ||)) {\n        sdo-call result = child->Contains(symbol)\n        let contained = result\n        if (= contained true) {\n          return true\n        }\n      }\n    }\n    %0 = (+ %0 1)\n  }\n  return false\n}","def <SYNTAX>:FunctionDeclaration[0,0].Contains(\n  this: Ast[FunctionDeclaration[0]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  return false\n}","def <SYNTAX>:FunctionDeclaration[1,0].Contains(\n  this: Ast[FunctionDeclaration[1]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  return false\n}","def <SYNTAX>:FunctionExpression[0,0].Contains(\n  this: Ast[FunctionExpression[0]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  return false\n}","def <SYNTAX>:FunctionExpression[0,1].Contains(\n  this: Ast[FunctionExpression[0]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  return false\n}","def <SYNTAX>:GeneratorDeclaration[0,0].Contains(\n  this: Ast[GeneratorDeclaration[0]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  return false\n}","def <SYNTAX>:GeneratorDeclaration[1,0].Contains(\n  this: Ast[GeneratorDeclaration[1]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  return false\n}","def <SYNTAX>:GeneratorExpression[0,0].Contains(\n  this: Ast[GeneratorExpression[0]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  return false\n}","def <SYNTAX>:GeneratorExpression[0,1].Contains(\n  this: Ast[GeneratorExpression[0]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  return false\n}","def <SYNTAX>:AsyncGeneratorDeclaration[0,0].Contains(\n  this: Ast[AsyncGeneratorDeclaration[0]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  return false\n}","def <SYNTAX>:AsyncGeneratorDeclaration[1,0].Contains(\n  this: Ast[AsyncGeneratorDeclaration[1]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  return false\n}","def <SYNTAX>:AsyncGeneratorExpression[0,0].Contains(\n  this: Ast[AsyncGeneratorExpression[0]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  return false\n}","def <SYNTAX>:AsyncGeneratorExpression[0,1].Contains(\n  this: Ast[AsyncGeneratorExpression[0]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  return false\n}","def <SYNTAX>:AsyncFunctionDeclaration[0,0].Contains(\n  this: Ast[AsyncFunctionDeclaration[0]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  return false\n}","def <SYNTAX>:AsyncFunctionDeclaration[1,0].Contains(\n  this: Ast[AsyncFunctionDeclaration[1]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  return false\n}","def <SYNTAX>:AsyncFunctionExpression[0,0].Contains(\n  this: Ast[AsyncFunctionExpression[0]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  return false\n}","def <SYNTAX>:AsyncFunctionExpression[0,1].Contains(\n  this: Ast[AsyncFunctionExpression[0]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  return false\n}","def <SYNTAX>:ClassTail[0,1].Contains(\n  this: Ast[ClassTail[0]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  if (= symbol this[1]) {\n    return true\n  }\n  if (= symbol this[0]) {\n    if (exists this[0]) {\n      return true\n    } else {\n      return false\n    }\n  }\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->Contains(symbol)\n    if (= %0 true) {\n      return true\n    }\n  }\n  sdo-call %1 = this[1]->ComputedPropertyContains(symbol)\n  return %1\n}","def <SYNTAX>:ClassTail[0,3].Contains(\n  this: Ast[ClassTail[0]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  if (= symbol this[1]) {\n    return true\n  }\n  if (= symbol this[0]) {\n    if (exists this[0]) {\n      return true\n    } else {\n      return false\n    }\n  }\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->Contains(symbol)\n    if (= %0 true) {\n      return true\n    }\n  }\n  sdo-call %1 = this[1]->ComputedPropertyContains(symbol)\n  return %1\n}","def <SYNTAX>:ClassStaticBlock[0,0].Contains(\n  this: Ast[ClassStaticBlock[0]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  return false\n}","def <SYNTAX>:ArrowFunction[0,0].Contains(\n  this: Ast[ArrowFunction[0]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  if (! (|| (|| (|| (|| (= symbol (grammar-symbol |NewTarget|)) (= symbol (grammar-symbol |SuperProperty|))) (= symbol (grammar-symbol |SuperCall|))) (= symbol \"super\")) (= symbol \"this\"))) {\n    return false\n  }\n  sdo-call %0 = this[0]->Contains(symbol)\n  if (= %0 true) {\n    return true\n  }\n  sdo-call %1 = this[1]->Contains(symbol)\n  return %1\n}","def <SYNTAX>:ArrowParameters[1,0].Contains(\n  this: Ast[ArrowParameters[1]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  let formals = (parse this[0] (grammar-symbol |ArrowFormalParameters|))\n  sdo-call %0 = formals->Contains(symbol)\n  return %0\n}","def <SYNTAX>:AsyncArrowFunction[0,0].Contains(\n  this: Ast[AsyncArrowFunction[0]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  if (! (|| (|| (|| (|| (= symbol (grammar-symbol |NewTarget|)) (= symbol (grammar-symbol |SuperProperty|))) (= symbol (grammar-symbol |SuperCall|))) (= symbol \"super\")) (= symbol \"this\"))) {\n    return false\n  }\n  sdo-call %0 = this[1]->Contains(symbol)\n  return %0\n}","def <SYNTAX>:AsyncArrowFunction[1,0].Contains(\n  this: Ast[AsyncArrowFunction[1]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  if (! (|| (|| (|| (|| (= symbol (grammar-symbol |NewTarget|)) (= symbol (grammar-symbol |SuperProperty|))) (= symbol (grammar-symbol |SuperCall|))) (= symbol \"super\")) (= symbol \"this\"))) {\n    return false\n  }\n  let head = (parse this[0] (grammar-symbol |AsyncArrowHead|))\n  sdo-call %0 = head->Contains(symbol)\n  if (= %0 true) {\n    return true\n  }\n  sdo-call %1 = this[1]->Contains(symbol)\n  return %1\n}","def <SYNTAX>:PropertyDefinition[3,0].Contains(\n  this: Ast[PropertyDefinition[3]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  if (= symbol this[0]) {\n    return true\n  }\n  sdo-call %0 = this[0]->ComputedPropertyContains(symbol)\n  return %0\n}","def <SYNTAX>:LiteralPropertyName[0,0].Contains(\n  this: Ast[LiteralPropertyName[0]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  return false\n}","def <SYNTAX>:MemberExpression[2,0].Contains(\n  this: Ast[MemberExpression[2]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  sdo-call %0 = this[0]->Contains(symbol)\n  if (= %0 true) {\n    return true\n  }\n  return false\n}","def <SYNTAX>:SuperProperty[1,0].Contains(\n  this: Ast[SuperProperty[1]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  (yet \"If _symbol_ is the |ReservedWord| `super`, return *true*.\")\n  return false\n}","def <SYNTAX>:CallExpression[5,0].Contains(\n  this: Ast[CallExpression[5]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  sdo-call %0 = this[0]->Contains(symbol)\n  if (= %0 true) {\n    return true\n  }\n  return false\n}","def <SYNTAX>:OptionalChain[2,0].Contains(\n  this: Ast[OptionalChain[2]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  return false\n}","def <SYNTAX>:OptionalChain[7,0].Contains(\n  this: Ast[OptionalChain[7]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  sdo-call %0 = this[0]->Contains(symbol)\n  if (= %0 true) {\n    return true\n  }\n  return false\n}","def <SYNTAX>:ClassElementName[1,0].ComputedPropertyContains(\n  this: Ast[ClassElementName[1]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  return false\n}","def <SYNTAX>:PropertyName[0,0].ComputedPropertyContains(\n  this: Ast[PropertyName[0]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  return false\n}","def <SYNTAX>:PropertyName[1,0].ComputedPropertyContains(\n  this: Ast[PropertyName[1]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  (yet \"Return the result of |ComputedPropertyName| Contains _symbol_.\")\n}","def <SYNTAX>:MethodDefinition[0,0].ComputedPropertyContains(\n  this: Ast[MethodDefinition[0]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  sdo-call %0 = this[0]->ComputedPropertyContains(symbol)\n  return %0\n}","def <SYNTAX>:MethodDefinition[4,0].ComputedPropertyContains(\n  this: Ast[MethodDefinition[4]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  sdo-call %0 = this[0]->ComputedPropertyContains(symbol)\n  return %0\n}","def <SYNTAX>:MethodDefinition[5,0].ComputedPropertyContains(\n  this: Ast[MethodDefinition[5]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  sdo-call %0 = this[0]->ComputedPropertyContains(symbol)\n  return %0\n}","def <SYNTAX>:GeneratorMethod[0,0].ComputedPropertyContains(\n  this: Ast[GeneratorMethod[0]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  sdo-call %0 = this[0]->ComputedPropertyContains(symbol)\n  return %0\n}","def <SYNTAX>:AsyncGeneratorMethod[0,0].ComputedPropertyContains(\n  this: Ast[AsyncGeneratorMethod[0]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  sdo-call %0 = this[0]->ComputedPropertyContains(symbol)\n  return %0\n}","def <SYNTAX>:ClassElementList[1,0].ComputedPropertyContains(\n  this: Ast[ClassElementList[1]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  sdo-call %0 = this[0]->ComputedPropertyContains(symbol)\n  let inList = %0\n  if (= inList true) {\n    return true\n  }\n  sdo-call %1 = this[1]->ComputedPropertyContains(symbol)\n  return %1\n}","def <SYNTAX>:ClassElement[4,0].ComputedPropertyContains(\n  this: Ast[ClassElement[4]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  return false\n}","def <SYNTAX>:ClassElement[5,0].ComputedPropertyContains(\n  this: Ast[ClassElement[5]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  return false\n}","def <SYNTAX>:AsyncMethod[0,0].ComputedPropertyContains(\n  this: Ast[AsyncMethod[0]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  sdo-call %0 = this[0]->ComputedPropertyContains(symbol)\n  return %0\n}","def <SYNTAX>:FieldDefinition[0,0].ComputedPropertyContains(\n  this: Ast[FieldDefinition[0]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  sdo-call %0 = this[0]->ComputedPropertyContains(symbol)\n  return %0\n}","def <SYNTAX>:FieldDefinition[0,1].ComputedPropertyContains(\n  this: Ast[FieldDefinition[0]],\n  symbol: GrammarSymbol,\n): Boolean = {\n  sdo-call %0 = this[0]->ComputedPropertyContains(symbol)\n  return %0\n}","def <SYNTAX>:FunctionDeclaration[0,0].InstantiateFunctionObject(\n  this: Ast[FunctionDeclaration[0]],\n  env: Record[EnvironmentRecord],\n  privateEnv: Record[PrivateEnvironmentRecord] | Null,\n): Record[ECMAScriptFunctionObject] = {\n  sdo-call %0 = this->InstantiateOrdinaryFunctionObject(env, privateEnv)\n  return %0\n}","def <SYNTAX>:FunctionDeclaration[1,0].InstantiateFunctionObject(\n  this: Ast[FunctionDeclaration[1]],\n  env: Record[EnvironmentRecord],\n  privateEnv: Record[PrivateEnvironmentRecord] | Null,\n): Record[ECMAScriptFunctionObject] = {\n  sdo-call %0 = this->InstantiateOrdinaryFunctionObject(env, privateEnv)\n  return %0\n}","def <SYNTAX>:GeneratorDeclaration[0,0].InstantiateFunctionObject(\n  this: Ast[GeneratorDeclaration[0]],\n  env: Record[EnvironmentRecord],\n  privateEnv: Record[PrivateEnvironmentRecord] | Null,\n): Record[ECMAScriptFunctionObject] = {\n  sdo-call %0 = this->InstantiateGeneratorFunctionObject(env, privateEnv)\n  return %0\n}","def <SYNTAX>:GeneratorDeclaration[1,0].InstantiateFunctionObject(\n  this: Ast[GeneratorDeclaration[1]],\n  env: Record[EnvironmentRecord],\n  privateEnv: Record[PrivateEnvironmentRecord] | Null,\n): Record[ECMAScriptFunctionObject] = {\n  sdo-call %0 = this->InstantiateGeneratorFunctionObject(env, privateEnv)\n  return %0\n}","def <SYNTAX>:AsyncGeneratorDeclaration[0,0].InstantiateFunctionObject(\n  this: Ast[AsyncGeneratorDeclaration[0]],\n  env: Record[EnvironmentRecord],\n  privateEnv: Record[PrivateEnvironmentRecord] | Null,\n): Record[ECMAScriptFunctionObject] = {\n  sdo-call %0 = this->InstantiateAsyncGeneratorFunctionObject(env, privateEnv)\n  return %0\n}","def <SYNTAX>:AsyncGeneratorDeclaration[1,0].InstantiateFunctionObject(\n  this: Ast[AsyncGeneratorDeclaration[1]],\n  env: Record[EnvironmentRecord],\n  privateEnv: Record[PrivateEnvironmentRecord] | Null,\n): Record[ECMAScriptFunctionObject] = {\n  sdo-call %0 = this->InstantiateAsyncGeneratorFunctionObject(env, privateEnv)\n  return %0\n}","def <SYNTAX>:AsyncFunctionDeclaration[0,0].InstantiateFunctionObject(\n  this: Ast[AsyncFunctionDeclaration[0]],\n  env: Record[EnvironmentRecord],\n  privateEnv: Record[PrivateEnvironmentRecord] | Null,\n): Record[ECMAScriptFunctionObject] = {\n  sdo-call %0 = this->InstantiateAsyncFunctionObject(env, privateEnv)\n  return %0\n}","def <SYNTAX>:AsyncFunctionDeclaration[1,0].InstantiateFunctionObject(\n  this: Ast[AsyncFunctionDeclaration[1]],\n  env: Record[EnvironmentRecord],\n  privateEnv: Record[PrivateEnvironmentRecord] | Null,\n): Record[ECMAScriptFunctionObject] = {\n  sdo-call %0 = this->InstantiateAsyncFunctionObject(env, privateEnv)\n  return %0\n}","def <SYNTAX>:BindingIdentifier[0,0].BindingInitialization(\n  this: Ast[BindingIdentifier[0]],\n  value: ESValue,\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->StringValue()\n  let name = %0\n  call %1 = clo<\"InitializeBoundName\">(name, value, environment)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:BindingIdentifier[1,0].BindingInitialization(\n  this: Ast[BindingIdentifier[1]],\n  value: ESValue,\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  call %0 = clo<\"InitializeBoundName\">(\"yield\", value, environment)\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:BindingIdentifier[2,0].BindingInitialization(\n  this: Ast[BindingIdentifier[2]],\n  value: ESValue,\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  call %0 = clo<\"InitializeBoundName\">(\"await\", value, environment)\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:BindingPattern[0,0].BindingInitialization(\n  this: Ast[BindingPattern[0]],\n  value: ESValue,\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  call %0 = clo<\"RequireObjectCoercible\">(value)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  sdo-call %1 = this[0]->BindingInitialization(value, environment)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:BindingPattern[1,0].BindingInitialization(\n  this: Ast[BindingPattern[1]],\n  value: ESValue,\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  call %0 = clo<\"GetIterator\">(value, ~sync~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let iteratorRecord = %0\n  sdo-call %1 = this[0]->IteratorBindingInitialization(iteratorRecord, environment)\n  call %2 = clo<\"Completion\">(%1)\n  let result = %2\n  if (= iteratorRecord.Done false) {\n    call %3 = clo<\"IteratorClose\">(iteratorRecord, result)\n    assert (? %3: Completion)\n    return %3\n  }\n  assert (? result: Completion)\n  return result\n}","def <SYNTAX>:ObjectBindingPattern[0,0].BindingInitialization(\n  this: Ast[ObjectBindingPattern[0]],\n  value: ESValue,\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  call %0 = clo<\"NormalCompletion\">(~unused~)\n  return %0\n}","def <SYNTAX>:ObjectBindingPattern[2,0].BindingInitialization(\n  this: Ast[ObjectBindingPattern[2]],\n  value: ESValue,\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->PropertyBindingInitialization(value, environment)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"NormalCompletion\">(~unused~)\n  return %1\n}","def <SYNTAX>:ObjectBindingPattern[3,0].BindingInitialization(\n  this: Ast[ObjectBindingPattern[3]],\n  value: ESValue,\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->PropertyBindingInitialization(value, environment)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"NormalCompletion\">(~unused~)\n  return %1\n}","def <SYNTAX>:ObjectBindingPattern[1,0].BindingInitialization(\n  this: Ast[ObjectBindingPattern[1]],\n  value: ESValue,\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  let excludedNames = (list [])[#347]\n  sdo-call %0 = this[0]->RestBindingInitialization(value, environment, excludedNames)\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:ObjectBindingPattern[3,1].BindingInitialization(\n  this: Ast[ObjectBindingPattern[3]],\n  value: ESValue,\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->PropertyBindingInitialization(value, environment)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let excludedNames = %0\n  sdo-call %1 = this[1]->RestBindingInitialization(value, environment, excludedNames)\n  assert (? %1: Completion)\n  return %1\n}","def InitializeBoundName(\n  name: String,\n  value: ESValue,\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  if (! (= environment undefined)) {\n    call %0 = environment.InitializeBinding(environment, name, value)\n    assert (? %0: Normal)\n    %0 = %0.Value\n    call %1 = clo<\"NormalCompletion\">(~unused~)\n    return %1\n  } else {\n    call %2 = clo<\"ResolveBinding\">(name)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let lhs = %2\n    call %3 = clo<\"PutValue\">(lhs, value)\n    assert (? %3: Completion)\n    return %3\n  }\n}","def <SYNTAX>:ArrayBindingPattern[0,0].IteratorBindingInitialization(\n  this: Ast[ArrayBindingPattern[0]],\n  iteratorRecord: Record[IteratorRecord],\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  call %0 = clo<\"NormalCompletion\">(~unused~)\n  return %0\n}","def <SYNTAX>:ArrayBindingPattern[0,2].IteratorBindingInitialization(\n  this: Ast[ArrayBindingPattern[0]],\n  iteratorRecord: Record[IteratorRecord],\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:ArrayBindingPattern[0,1].IteratorBindingInitialization(\n  this: Ast[ArrayBindingPattern[0]],\n  iteratorRecord: Record[IteratorRecord],\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n  }\n  sdo-call %1 = this[1]->IteratorBindingInitialization(iteratorRecord, environment)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:ArrayBindingPattern[0,3].IteratorBindingInitialization(\n  this: Ast[ArrayBindingPattern[0]],\n  iteratorRecord: Record[IteratorRecord],\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n  }\n  sdo-call %1 = this[1]->IteratorBindingInitialization(iteratorRecord, environment)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:ArrayBindingPattern[2,2].IteratorBindingInitialization(\n  this: Ast[ArrayBindingPattern[2]],\n  iteratorRecord: Record[IteratorRecord],\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->IteratorBindingInitialization(iteratorRecord, environment)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  sdo-call %1 = this[1]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:ArrayBindingPattern[2,1].IteratorBindingInitialization(\n  this: Ast[ArrayBindingPattern[2]],\n  iteratorRecord: Record[IteratorRecord],\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->IteratorBindingInitialization(iteratorRecord, environment)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  if (exists this[1]) {\n    sdo-call %1 = this[1]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n  }\n  sdo-call %2 = this[2]->IteratorBindingInitialization(iteratorRecord, environment)\n  assert (? %2: Completion)\n  return %2\n}","def <SYNTAX>:ArrayBindingPattern[2,3].IteratorBindingInitialization(\n  this: Ast[ArrayBindingPattern[2]],\n  iteratorRecord: Record[IteratorRecord],\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->IteratorBindingInitialization(iteratorRecord, environment)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  if (exists this[1]) {\n    sdo-call %1 = this[1]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n  }\n  sdo-call %2 = this[2]->IteratorBindingInitialization(iteratorRecord, environment)\n  assert (? %2: Completion)\n  return %2\n}","def <SYNTAX>:BindingElementList[1,0].IteratorBindingInitialization(\n  this: Ast[BindingElementList[1]],\n  iteratorRecord: Record[IteratorRecord],\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->IteratorBindingInitialization(iteratorRecord, environment)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  sdo-call %1 = this[1]->IteratorBindingInitialization(iteratorRecord, environment)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:BindingElisionElement[0,1].IteratorBindingInitialization(\n  this: Ast[BindingElisionElement[0]],\n  iteratorRecord: Record[IteratorRecord],\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  sdo-call %1 = this[1]->IteratorBindingInitialization(iteratorRecord, environment)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:SingleNameBinding[0,0].IteratorBindingInitialization(\n  this: Ast[SingleNameBinding[0]],\n  iteratorRecord: Record[IteratorRecord],\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->StringValue()\n  let bindingId = %0\n  call %1 = clo<\"ResolveBinding\">(bindingId, environment)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let lhs = %1\n  let v = undefined\n  if (= iteratorRecord.Done false) {\n    call %2 = clo<\"IteratorStepValue\">(iteratorRecord)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let next = %2\n    if (! (= next ~done~)) {\n      v = next\n    }\n  }\n  if (&& (exists this[1]) (= v undefined)) {\n    call %3 = clo<\"IsAnonymousFunctionDefinition\">(this[1])\n    if (= %3 true) {\n      sdo-call %4 = this[1]->NamedEvaluation(bindingId)\n      assert (? %4: Completion)\n      if (? %4: Abrupt) return %4\n      else %4 = %4.Value\n      v = %4\n    } else {\n      sdo-call %5 = this[1]->Evaluation()\n      assert (? %5: Completion)\n      if (? %5: Abrupt) return %5\n      else %5 = %5.Value\n      let defaultValue = %5\n      call %6 = clo<\"GetValue\">(defaultValue)\n      assert (? %6: Completion)\n      if (? %6: Abrupt) return %6\n      else %6 = %6.Value\n      v = %6\n    }\n  }\n  if (= environment undefined) {\n    call %7 = clo<\"PutValue\">(lhs, v)\n    assert (? %7: Completion)\n    return %7\n  }\n  call %8 = clo<\"InitializeReferencedBinding\">(lhs, v)\n  assert (? %8: Completion)\n  return %8\n}","def <SYNTAX>:SingleNameBinding[0,1].IteratorBindingInitialization(\n  this: Ast[SingleNameBinding[0]],\n  iteratorRecord: Record[IteratorRecord],\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->StringValue()\n  let bindingId = %0\n  call %1 = clo<\"ResolveBinding\">(bindingId, environment)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let lhs = %1\n  let v = undefined\n  if (= iteratorRecord.Done false) {\n    call %2 = clo<\"IteratorStepValue\">(iteratorRecord)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let next = %2\n    if (! (= next ~done~)) {\n      v = next\n    }\n  }\n  if (&& (exists this[1]) (= v undefined)) {\n    call %3 = clo<\"IsAnonymousFunctionDefinition\">(this[1])\n    if (= %3 true) {\n      sdo-call %4 = this[1]->NamedEvaluation(bindingId)\n      assert (? %4: Completion)\n      if (? %4: Abrupt) return %4\n      else %4 = %4.Value\n      v = %4\n    } else {\n      sdo-call %5 = this[1]->Evaluation()\n      assert (? %5: Completion)\n      if (? %5: Abrupt) return %5\n      else %5 = %5.Value\n      let defaultValue = %5\n      call %6 = clo<\"GetValue\">(defaultValue)\n      assert (? %6: Completion)\n      if (? %6: Abrupt) return %6\n      else %6 = %6.Value\n      v = %6\n    }\n  }\n  if (= environment undefined) {\n    call %7 = clo<\"PutValue\">(lhs, v)\n    assert (? %7: Completion)\n    return %7\n  }\n  call %8 = clo<\"InitializeReferencedBinding\">(lhs, v)\n  assert (? %8: Completion)\n  return %8\n}","def <SYNTAX>:BindingElement[1,0].IteratorBindingInitialization(\n  this: Ast[BindingElement[1]],\n  iteratorRecord: Record[IteratorRecord],\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  let v = undefined\n  if (= iteratorRecord.Done false) {\n    call %0 = clo<\"IteratorStepValue\">(iteratorRecord)\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let next = %0\n    if (! (= next ~done~)) {\n      v = next\n    }\n  }\n  if (&& (exists this[1]) (= v undefined)) {\n    sdo-call %1 = this[1]->Evaluation()\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let defaultValue = %1\n    call %2 = clo<\"GetValue\">(defaultValue)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    v = %2\n  }\n  sdo-call %3 = this[0]->BindingInitialization(v, environment)\n  assert (? %3: Completion)\n  return %3\n}","def <SYNTAX>:BindingElement[1,1].IteratorBindingInitialization(\n  this: Ast[BindingElement[1]],\n  iteratorRecord: Record[IteratorRecord],\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  let v = undefined\n  if (= iteratorRecord.Done false) {\n    call %0 = clo<\"IteratorStepValue\">(iteratorRecord)\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let next = %0\n    if (! (= next ~done~)) {\n      v = next\n    }\n  }\n  if (&& (exists this[1]) (= v undefined)) {\n    sdo-call %1 = this[1]->Evaluation()\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let defaultValue = %1\n    call %2 = clo<\"GetValue\">(defaultValue)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    v = %2\n  }\n  sdo-call %3 = this[0]->BindingInitialization(v, environment)\n  assert (? %3: Completion)\n  return %3\n}","def <SYNTAX>:BindingRestElement[0,0].IteratorBindingInitialization(\n  this: Ast[BindingRestElement[0]],\n  iteratorRecord: Record[IteratorRecord],\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->StringValue()\n  call %1 = clo<\"ResolveBinding\">(%0, environment)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let lhs = %1\n  call %2 = clo<\"ArrayCreate\">(0)\n  assert (? %2: Normal)\n  %2 = %2.Value\n  let A = %2\n  let n = 0\n  while true {\n    let next = ~done~\n    if (= iteratorRecord.Done false) {\n      call %3 = clo<\"IteratorStepValue\">(iteratorRecord)\n      assert (? %3: Completion)\n      if (? %3: Abrupt) return %3\n      else %3 = %3.Value\n      next = %3\n    }\n    if (= next ~done~) {\n      if (= environment undefined) {\n        call %4 = clo<\"PutValue\">(lhs, A)\n        assert (? %4: Completion)\n        return %4\n      }\n      call %5 = clo<\"InitializeReferencedBinding\">(lhs, A)\n      assert (? %5: Completion)\n      return %5\n    }\n    call %6 = clo<\"ToString\">(([number] n))\n    assert (? %6: Normal)\n    %6 = %6.Value\n    call %7 = clo<\"CreateDataPropertyOrThrow\">(A, %6, next)\n    assert (? %7: Normal)\n    %7 = %7.Value\n    n = (+ n 1)\n  }\n}","def <SYNTAX>:BindingRestElement[1,0].IteratorBindingInitialization(\n  this: Ast[BindingRestElement[1]],\n  iteratorRecord: Record[IteratorRecord],\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  call %0 = clo<\"ArrayCreate\">(0)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let A = %0\n  let n = 0\n  while true {\n    let next = ~done~\n    if (= iteratorRecord.Done false) {\n      call %1 = clo<\"IteratorStepValue\">(iteratorRecord)\n      assert (? %1: Completion)\n      if (? %1: Abrupt) return %1\n      else %1 = %1.Value\n      next = %1\n    }\n    if (= next ~done~) {\n      sdo-call %2 = this[0]->BindingInitialization(A, environment)\n      assert (? %2: Completion)\n      return %2\n    }\n    call %3 = clo<\"ToString\">(([number] n))\n    assert (? %3: Normal)\n    %3 = %3.Value\n    call %4 = clo<\"CreateDataPropertyOrThrow\">(A, %3, next)\n    assert (? %4: Normal)\n    %4 = %4.Value\n    n = (+ n 1)\n  }\n}","def <SYNTAX>:FormalParameters[0,0].IteratorBindingInitialization(\n  this: Ast[FormalParameters[0]],\n  iteratorRecord: Record[IteratorRecord],\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  call %0 = clo<\"NormalCompletion\">(~unused~)\n  return %0\n}","def <SYNTAX>:FormalParameters[4,0].IteratorBindingInitialization(\n  this: Ast[FormalParameters[4]],\n  iteratorRecord: Record[IteratorRecord],\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->IteratorBindingInitialization(iteratorRecord, environment)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  sdo-call %1 = this[1]->IteratorBindingInitialization(iteratorRecord, environment)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:FormalParameterList[1,0].IteratorBindingInitialization(\n  this: Ast[FormalParameterList[1]],\n  iteratorRecord: Record[IteratorRecord],\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->IteratorBindingInitialization(iteratorRecord, environment)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  sdo-call %1 = this[1]->IteratorBindingInitialization(iteratorRecord, environment)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:ArrowParameters[0,0].IteratorBindingInitialization(\n  this: Ast[ArrowParameters[0]],\n  iteratorRecord: Record[IteratorRecord],\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  let v = undefined\n  assert (= iteratorRecord.Done false)\n  call %0 = clo<\"IteratorStepValue\">(iteratorRecord)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let next = %0\n  if (! (= next ~done~)) {\n    v = next\n  }\n  sdo-call %1 = this[0]->BindingInitialization(v, environment)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:ArrowParameters[1,0].IteratorBindingInitialization(\n  this: Ast[ArrowParameters[1]],\n  iteratorRecord: Record[IteratorRecord],\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  let formals = (parse this[0] (grammar-symbol |ArrowFormalParameters|))\n  sdo-call %0 = formals->IteratorBindingInitialization(iteratorRecord, environment)\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:AsyncArrowBindingIdentifier[0,0].IteratorBindingInitialization(\n  this: Ast[AsyncArrowBindingIdentifier[0]],\n  iteratorRecord: Record[IteratorRecord],\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  let v = undefined\n  assert (= iteratorRecord.Done false)\n  call %0 = clo<\"IteratorStepValue\">(iteratorRecord)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let next = %0\n  if (! (= next ~done~)) {\n    v = next\n  }\n  sdo-call %1 = this[0]->BindingInitialization(v, environment)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:IdentifierReference[0,0].AssignmentTargetType(\n  this: Ast[IdentifierReference[0]],\n): Enum[~invalid~, ~simple~] = {\n  (yet \"If this |IdentifierReference| is contained in strict mode code and StringValue of |Identifier| is either *\\\"eval\\\"* or *\\\"arguments\\\"*, return ~invalid~.\")\n  return ~simple~\n}","def <SYNTAX>:IdentifierReference[1,0].AssignmentTargetType(\n  this: Ast[IdentifierReference[1]],\n): Enum[~invalid~, ~simple~] = {\n  return ~simple~\n}","def <SYNTAX>:IdentifierReference[2,0].AssignmentTargetType(\n  this: Ast[IdentifierReference[2]],\n): Enum[~invalid~, ~simple~] = {\n  return ~simple~\n}","def <SYNTAX>:CallExpression[4,0].AssignmentTargetType(\n  this: Ast[CallExpression[4]],\n): Enum[~invalid~, ~simple~] = {\n  return ~simple~\n}","def <SYNTAX>:CallExpression[5,0].AssignmentTargetType(\n  this: Ast[CallExpression[5]],\n): Enum[~invalid~, ~simple~] = {\n  return ~simple~\n}","def <SYNTAX>:CallExpression[7,0].AssignmentTargetType(\n  this: Ast[CallExpression[7]],\n): Enum[~invalid~, ~simple~] = {\n  return ~simple~\n}","def <SYNTAX>:MemberExpression[1,0].AssignmentTargetType(\n  this: Ast[MemberExpression[1]],\n): Enum[~invalid~, ~simple~] = {\n  return ~simple~\n}","def <SYNTAX>:MemberExpression[2,0].AssignmentTargetType(\n  this: Ast[MemberExpression[2]],\n): Enum[~invalid~, ~simple~] = {\n  return ~simple~\n}","def <SYNTAX>:MemberExpression[4,0].AssignmentTargetType(\n  this: Ast[MemberExpression[4]],\n): Enum[~invalid~, ~simple~] = {\n  return ~simple~\n}","def <SYNTAX>:MemberExpression[7,0].AssignmentTargetType(\n  this: Ast[MemberExpression[7]],\n): Enum[~invalid~, ~simple~] = {\n  return ~simple~\n}","def <SYNTAX>:PrimaryExpression[12,0].AssignmentTargetType(\n  this: Ast[PrimaryExpression[12]],\n): Enum[~invalid~, ~simple~] = {\n  let expr = (parse this[0] (grammar-symbol |ParenthesizedExpression|))\n  sdo-call %0 = expr->AssignmentTargetType()\n  return %0\n}","def <SYNTAX>:PrimaryExpression[0,0].AssignmentTargetType(\n  this: Ast[PrimaryExpression[0]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:PrimaryExpression[2,0].AssignmentTargetType(\n  this: Ast[PrimaryExpression[2]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:PrimaryExpression[3,0].AssignmentTargetType(\n  this: Ast[PrimaryExpression[3]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:PrimaryExpression[4,0].AssignmentTargetType(\n  this: Ast[PrimaryExpression[4]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:PrimaryExpression[5,0].AssignmentTargetType(\n  this: Ast[PrimaryExpression[5]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:PrimaryExpression[6,0].AssignmentTargetType(\n  this: Ast[PrimaryExpression[6]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:PrimaryExpression[7,0].AssignmentTargetType(\n  this: Ast[PrimaryExpression[7]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:PrimaryExpression[8,0].AssignmentTargetType(\n  this: Ast[PrimaryExpression[8]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:PrimaryExpression[9,0].AssignmentTargetType(\n  this: Ast[PrimaryExpression[9]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:PrimaryExpression[10,0].AssignmentTargetType(\n  this: Ast[PrimaryExpression[10]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:PrimaryExpression[11,0].AssignmentTargetType(\n  this: Ast[PrimaryExpression[11]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:CallExpression[0,0].AssignmentTargetType(\n  this: Ast[CallExpression[0]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:CallExpression[1,0].AssignmentTargetType(\n  this: Ast[CallExpression[1]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:CallExpression[2,0].AssignmentTargetType(\n  this: Ast[CallExpression[2]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:CallExpression[3,0].AssignmentTargetType(\n  this: Ast[CallExpression[3]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:CallExpression[6,0].AssignmentTargetType(\n  this: Ast[CallExpression[6]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:NewExpression[1,0].AssignmentTargetType(\n  this: Ast[NewExpression[1]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:MemberExpression[3,0].AssignmentTargetType(\n  this: Ast[MemberExpression[3]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:MemberExpression[6,0].AssignmentTargetType(\n  this: Ast[MemberExpression[6]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:NewTarget[0,0].AssignmentTargetType(\n  this: Ast[NewTarget[0]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:ImportMeta[0,0].AssignmentTargetType(\n  this: Ast[ImportMeta[0]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:LeftHandSideExpression[2,0].AssignmentTargetType(\n  this: Ast[LeftHandSideExpression[2]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:UpdateExpression[1,0].AssignmentTargetType(\n  this: Ast[UpdateExpression[1]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:UpdateExpression[2,0].AssignmentTargetType(\n  this: Ast[UpdateExpression[2]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:UpdateExpression[3,0].AssignmentTargetType(\n  this: Ast[UpdateExpression[3]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:UpdateExpression[4,0].AssignmentTargetType(\n  this: Ast[UpdateExpression[4]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:UnaryExpression[1,0].AssignmentTargetType(\n  this: Ast[UnaryExpression[1]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:UnaryExpression[2,0].AssignmentTargetType(\n  this: Ast[UnaryExpression[2]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:UnaryExpression[3,0].AssignmentTargetType(\n  this: Ast[UnaryExpression[3]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:UnaryExpression[4,0].AssignmentTargetType(\n  this: Ast[UnaryExpression[4]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:UnaryExpression[5,0].AssignmentTargetType(\n  this: Ast[UnaryExpression[5]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:UnaryExpression[6,0].AssignmentTargetType(\n  this: Ast[UnaryExpression[6]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:UnaryExpression[7,0].AssignmentTargetType(\n  this: Ast[UnaryExpression[7]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:UnaryExpression[8,0].AssignmentTargetType(\n  this: Ast[UnaryExpression[8]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:ExponentiationExpression[1,0].AssignmentTargetType(\n  this: Ast[ExponentiationExpression[1]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:MultiplicativeExpression[1,0].AssignmentTargetType(\n  this: Ast[MultiplicativeExpression[1]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:AdditiveExpression[1,0].AssignmentTargetType(\n  this: Ast[AdditiveExpression[1]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:AdditiveExpression[2,0].AssignmentTargetType(\n  this: Ast[AdditiveExpression[2]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:ShiftExpression[1,0].AssignmentTargetType(\n  this: Ast[ShiftExpression[1]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:ShiftExpression[2,0].AssignmentTargetType(\n  this: Ast[ShiftExpression[2]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:ShiftExpression[3,0].AssignmentTargetType(\n  this: Ast[ShiftExpression[3]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:RelationalExpression[1,0].AssignmentTargetType(\n  this: Ast[RelationalExpression[1]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:RelationalExpression[2,0].AssignmentTargetType(\n  this: Ast[RelationalExpression[2]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:RelationalExpression[3,0].AssignmentTargetType(\n  this: Ast[RelationalExpression[3]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:RelationalExpression[4,0].AssignmentTargetType(\n  this: Ast[RelationalExpression[4]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:RelationalExpression[5,0].AssignmentTargetType(\n  this: Ast[RelationalExpression[5]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:RelationalExpression[6,0].AssignmentTargetType(\n  this: Ast[RelationalExpression[6]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:RelationalExpression[7,0].AssignmentTargetType(\n  this: Ast[RelationalExpression[7]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:EqualityExpression[1,0].AssignmentTargetType(\n  this: Ast[EqualityExpression[1]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:EqualityExpression[2,0].AssignmentTargetType(\n  this: Ast[EqualityExpression[2]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:EqualityExpression[3,0].AssignmentTargetType(\n  this: Ast[EqualityExpression[3]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:EqualityExpression[4,0].AssignmentTargetType(\n  this: Ast[EqualityExpression[4]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:BitwiseANDExpression[1,0].AssignmentTargetType(\n  this: Ast[BitwiseANDExpression[1]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:BitwiseXORExpression[1,0].AssignmentTargetType(\n  this: Ast[BitwiseXORExpression[1]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:BitwiseORExpression[1,0].AssignmentTargetType(\n  this: Ast[BitwiseORExpression[1]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:LogicalANDExpression[1,0].AssignmentTargetType(\n  this: Ast[LogicalANDExpression[1]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:LogicalORExpression[1,0].AssignmentTargetType(\n  this: Ast[LogicalORExpression[1]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:CoalesceExpression[0,0].AssignmentTargetType(\n  this: Ast[CoalesceExpression[0]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:ConditionalExpression[1,0].AssignmentTargetType(\n  this: Ast[ConditionalExpression[1]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:AssignmentExpression[1,0].AssignmentTargetType(\n  this: Ast[AssignmentExpression[1]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:AssignmentExpression[2,0].AssignmentTargetType(\n  this: Ast[AssignmentExpression[2]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:AssignmentExpression[3,0].AssignmentTargetType(\n  this: Ast[AssignmentExpression[3]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:AssignmentExpression[4,0].AssignmentTargetType(\n  this: Ast[AssignmentExpression[4]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:AssignmentExpression[5,0].AssignmentTargetType(\n  this: Ast[AssignmentExpression[5]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:AssignmentExpression[6,0].AssignmentTargetType(\n  this: Ast[AssignmentExpression[6]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:AssignmentExpression[7,0].AssignmentTargetType(\n  this: Ast[AssignmentExpression[7]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:AssignmentExpression[8,0].AssignmentTargetType(\n  this: Ast[AssignmentExpression[8]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:Expression[1,0].AssignmentTargetType(\n  this: Ast[Expression[1]],\n): Enum[~invalid~, ~simple~] = {\n  return ~invalid~\n}","def <SYNTAX>:PropertyDefinition[0,0].PropName(\n  this: Ast[PropertyDefinition[0]],\n): Enum[~empty~] | String = {\n  sdo-call %0 = this[0]->StringValue()\n  return %0\n}","def <SYNTAX>:PropertyDefinition[4,0].PropName(\n  this: Ast[PropertyDefinition[4]],\n): Enum[~empty~] | String = {\n  return ~empty~\n}","def <SYNTAX>:PropertyDefinition[2,0].PropName(\n  this: Ast[PropertyDefinition[2]],\n): Enum[~empty~] | String = {\n  sdo-call %0 = this[0]->PropName()\n  return %0\n}","def <SYNTAX>:LiteralPropertyName[0,0].PropName(\n  this: Ast[LiteralPropertyName[0]],\n): Enum[~empty~] | String = {\n  sdo-call %0 = this[0]->StringValue()\n  return %0\n}","def <SYNTAX>:LiteralPropertyName[1,0].PropName(\n  this: Ast[LiteralPropertyName[1]],\n): Enum[~empty~] | String = {\n  sdo-call %0 = this[0]->SV()\n  return %0\n}","def <SYNTAX>:LiteralPropertyName[2,0].PropName(\n  this: Ast[LiteralPropertyName[2]],\n): Enum[~empty~] | String = {\n  sdo-call %0 = this[0]->NumericValue()\n  let nbr = %0\n  call %1 = clo<\"ToString\">(nbr)\n  assert (? %1: Normal)\n  %1 = %1.Value\n  return %1\n}","def <SYNTAX>:ComputedPropertyName[0,0].PropName(\n  this: Ast[ComputedPropertyName[0]],\n): Enum[~empty~] | String = {\n  return ~empty~\n}","def <SYNTAX>:MethodDefinition[0,0].PropName(\n  this: Ast[MethodDefinition[0]],\n): Enum[~empty~] | String = {\n  sdo-call %0 = this[0]->PropName()\n  return %0\n}","def <SYNTAX>:MethodDefinition[4,0].PropName(\n  this: Ast[MethodDefinition[4]],\n): Enum[~empty~] | String = {\n  sdo-call %0 = this[0]->PropName()\n  return %0\n}","def <SYNTAX>:MethodDefinition[5,0].PropName(\n  this: Ast[MethodDefinition[5]],\n): Enum[~empty~] | String = {\n  sdo-call %0 = this[0]->PropName()\n  return %0\n}","def <SYNTAX>:GeneratorMethod[0,0].PropName(\n  this: Ast[GeneratorMethod[0]],\n): Enum[~empty~] | String = {\n  sdo-call %0 = this[0]->PropName()\n  return %0\n}","def <SYNTAX>:AsyncGeneratorMethod[0,0].PropName(\n  this: Ast[AsyncGeneratorMethod[0]],\n): Enum[~empty~] | String = {\n  sdo-call %0 = this[0]->PropName()\n  return %0\n}","def <SYNTAX>:ClassElement[4,0].PropName(\n  this: Ast[ClassElement[4]],\n): Enum[~empty~] | String = {\n  return ~empty~\n}","def <SYNTAX>:ClassElement[5,0].PropName(\n  this: Ast[ClassElement[5]],\n): Enum[~empty~] | String = {\n  return ~empty~\n}","def <SYNTAX>:AsyncMethod[0,0].PropName(\n  this: Ast[AsyncMethod[0]],\n): Enum[~empty~] | String = {\n  sdo-call %0 = this[0]->PropName()\n  return %0\n}","def <SYNTAX>:FieldDefinition[0,0].PropName(\n  this: Ast[FieldDefinition[0]],\n): Enum[~empty~] | String = {\n  sdo-call %0 = this[0]->PropName()\n  return %0\n}","def <SYNTAX>:FieldDefinition[0,1].PropName(\n  this: Ast[FieldDefinition[0]],\n): Enum[~empty~] | String = {\n  sdo-call %0 = this[0]->PropName()\n  return %0\n}","def <SYNTAX>:ClassElementName[1,0].PropName(\n  this: Ast[ClassElementName[1]],\n): Enum[~empty~] | String = {\n  return ~empty~\n}","def <CONC>:Record[DeclarativeEnvironmentRecord].HasBinding(\n  envRec: Record[DeclarativeEnvironmentRecord],\n  N: String,\n): Normal[Boolean] = {\n  if (exists envRec.__MAP__[N]) {\n    call %0 = clo<\"NormalCompletion\">(true)\n    return %0\n  }\n  call %1 = clo<\"NormalCompletion\">(false)\n  return %1\n}","def <CONC>:Record[DeclarativeEnvironmentRecord].CreateMutableBinding(\n  envRec: Record[DeclarativeEnvironmentRecord],\n  N: String,\n  D: Boolean,\n): Normal[Enum[~unused~]] = {\n  assert (! (exists envRec.__MAP__[N]))\n  envRec.__MAP__[N] = (record [MutableBinding] {\n    \"initialized\" : false,\n    \"mutable\" : true,\n    \"strict\" : false,\n  })[#348]\n  if (= D true) envRec.__MAP__[N].maybeDeleted = true\n  call %0 = clo<\"NormalCompletion\">(~unused~)\n  return %0\n}","def <CONC>:Record[DeclarativeEnvironmentRecord].CreateImmutableBinding(\n  envRec: Record[DeclarativeEnvironmentRecord],\n  N: String,\n  S: Boolean,\n): Normal[Enum[~unused~]] = {\n  assert (! (exists envRec.__MAP__[N]))\n  envRec.__MAP__[N] = (record [ImmutableBinding] {\n    \"initialized\" : false,\n    \"mutable\" : false,\n    \"strict\" : S,\n  })[#349]\n  call %0 = clo<\"NormalCompletion\">(~unused~)\n  return %0\n}","def <CONC>:Record[DeclarativeEnvironmentRecord].InitializeBinding(\n  envRec: Record[DeclarativeEnvironmentRecord],\n  N: String,\n  V: ESValue,\n): Normal[Enum[~unused~]] = {\n  assert (= envRec.__MAP__[N].initialized false)\n  envRec.__MAP__[N].BoundValue = V\n  envRec.__MAP__[N].initialized = true\n  call %0 = clo<\"NormalCompletion\">(~unused~)\n  return %0\n}","def <CONC>:Record[DeclarativeEnvironmentRecord].SetMutableBinding(\n  envRec: Record[DeclarativeEnvironmentRecord],\n  N: String,\n  V: ESValue,\n  S: Boolean,\n): Normal[Enum[~unused~]] | Throw = {\n  if (! (exists envRec.__MAP__[N])) {\n    if (= S true) {\n      call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%ReferenceError.prototype%\")\n      call %1 = clo<\"ThrowCompletion\">(%0)\n      return %1\n    }\n    call %2 = envRec.CreateMutableBinding(envRec, N, true)\n    assert (? %2: Normal)\n    %2 = %2.Value\n    call %3 = envRec.InitializeBinding(envRec, N, V)\n    assert (? %3: Normal)\n    %3 = %3.Value\n    call %4 = clo<\"NormalCompletion\">(~unused~)\n    return %4\n  }\n  if (= envRec.__MAP__[N].strict true) {\n    S = true\n  }\n  if (! (= envRec.__MAP__[N].initialized true)) {\n    call %5 = clo<\"__NEW_ERROR_OBJ__\">(\"%ReferenceError.prototype%\")\n    call %6 = clo<\"ThrowCompletion\">(%5)\n    return %6\n  } else {\n    if (? envRec.__MAP__[N]: Record[MutableBinding]) {\n      envRec.__MAP__[N].BoundValue = V\n    } else {\n      assert true\n      if (= S true) {\n        call %7 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n        call %8 = clo<\"ThrowCompletion\">(%7)\n        return %8\n      }\n    }\n  }\n  call %9 = clo<\"NormalCompletion\">(~unused~)\n  return %9\n}","def <CONC>:Record[DeclarativeEnvironmentRecord].GetBindingValue(\n  envRec: Record[DeclarativeEnvironmentRecord],\n  N: String,\n  S: Boolean,\n): Normal[ESValue] | Throw = {\n  assert (exists envRec.__MAP__[N])\n  if (! envRec.__MAP__[N].initialized) {\n    call __errObj__ = clo<\"__NEW_ERROR_OBJ__\">(\"%ReferenceError.prototype%\")\n    call __comp__ = clo<\"ThrowCompletion\">(__errObj__)\n    {\n      if (? __comp__: Completion) return __comp__\n      call %0 = clo<\"NormalCompletion\">(__comp__)\n      return %0\n    }\n  }\n  %1 = envRec.__MAP__[N].BoundValue\n  if (? %1: Completion) return %1\n  call %2 = clo<\"NormalCompletion\">(%1)\n  return %2\n}","def <CONC>:Record[DeclarativeEnvironmentRecord].DeleteBinding(\n  envRec: Record[DeclarativeEnvironmentRecord],\n  N: String,\n): Normal[Boolean] = {\n  assert (exists envRec.__MAP__[N])\n  (yet \"If the binding for _N_ in _envRec_ cannot be deleted, return *false*.\")\n  (yet \"Remove the binding for _N_ from _envRec_.\")\n  call %0 = clo<\"NormalCompletion\">(true)\n  return %0\n}","def <CONC>:Record[DeclarativeEnvironmentRecord].HasThisBinding(\n  envRec: Record[DeclarativeEnvironmentRecord],\n): False = {\n  return false\n}","def <CONC>:Record[DeclarativeEnvironmentRecord].HasSuperBinding(\n  envRec: Record[DeclarativeEnvironmentRecord],\n): False = {\n  return false\n}","def <CONC>:Record[DeclarativeEnvironmentRecord].WithBaseObject(\n  envRec: Record[DeclarativeEnvironmentRecord],\n): Undefined = {\n  return undefined\n}","def <CONC>:Record[ObjectEnvironmentRecord].HasBinding(\n  envRec: Record[ObjectEnvironmentRecord],\n  N: String,\n): Normal[Boolean] | Throw = {\n  let bindingObject = envRec.BindingObject\n  call %0 = clo<\"HasProperty\">(bindingObject, N)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let foundBinding = %0\n  if (= foundBinding false) {\n    call %1 = clo<\"NormalCompletion\">(false)\n    return %1\n  }\n  if (= envRec.IsWithEnvironment false) {\n    call %2 = clo<\"NormalCompletion\">(true)\n    return %2\n  }\n  call %3 = clo<\"Get\">(bindingObject, @SYMBOL.unscopables)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let unscopables = %3\n  if (? unscopables: Record[Object]) {\n    call %4 = clo<\"Get\">(unscopables, N)\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    call %5 = clo<\"ToBoolean\">(%4)\n    let blocked = %5\n    if (= blocked true) {\n      call %6 = clo<\"NormalCompletion\">(false)\n      return %6\n    }\n  }\n  call %7 = clo<\"NormalCompletion\">(true)\n  return %7\n}","def <CONC>:Record[ObjectEnvironmentRecord].CreateMutableBinding(\n  envRec: Record[ObjectEnvironmentRecord],\n  N: String,\n  D: Boolean,\n): Normal[Enum[~unused~]] | Throw = {\n  let bindingObject = envRec.BindingObject\n  call %0 = clo<\"DefinePropertyOrThrow\">(bindingObject, N, (record [PropertyDescriptor] {\n    \"Value\" : undefined,\n    \"Writable\" : true,\n    \"Enumerable\" : true,\n    \"Configurable\" : D,\n  })[#350])\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"NormalCompletion\">(~unused~)\n  return %1\n}","def <CONC>:Record[ObjectEnvironmentRecord].InitializeBinding(\n  envRec: Record[ObjectEnvironmentRecord],\n  N: String,\n  V: ESValue,\n): Normal[Enum[~unused~]] | Throw = {\n  call %0 = envRec.SetMutableBinding(envRec, N, V, false)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"NormalCompletion\">(~unused~)\n  return %1\n}","def <CONC>:Record[ObjectEnvironmentRecord].SetMutableBinding(\n  envRec: Record[ObjectEnvironmentRecord],\n  N: String,\n  V: ESValue,\n  S: Boolean,\n): Normal[Enum[~unused~]] | Throw = {\n  let bindingObject = envRec.BindingObject\n  call %0 = clo<\"HasProperty\">(bindingObject, N)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let stillExists = %0\n  if (&& (= stillExists false) (= S true)) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%ReferenceError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  call %3 = clo<\"Set\">(bindingObject, N, V, S)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  call %4 = clo<\"NormalCompletion\">(~unused~)\n  return %4\n}","def <CONC>:Record[ObjectEnvironmentRecord].GetBindingValue(\n  envRec: Record[ObjectEnvironmentRecord],\n  N: String,\n  S: Boolean,\n): Normal[ESValue] | Throw = {\n  let bindingObject = envRec.BindingObject\n  call %0 = clo<\"HasProperty\">(bindingObject, N)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let value = %0\n  if (= value false) {\n    if (= S false) {\n      call %1 = clo<\"NormalCompletion\">(undefined)\n      return %1\n    } else {\n      call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%ReferenceError.prototype%\")\n      call %3 = clo<\"ThrowCompletion\">(%2)\n      return %3\n    }\n  }\n  call %4 = clo<\"Get\">(bindingObject, N)\n  assert (? %4: Completion)\n  return %4\n}","def <CONC>:Record[ObjectEnvironmentRecord].DeleteBinding(\n  envRec: Record[ObjectEnvironmentRecord],\n  N: String,\n): Normal[Boolean] | Throw = {\n  let bindingObject = envRec.BindingObject\n  call %0 = bindingObject.Delete(bindingObject, N)\n  assert (? %0: Completion)\n  return %0\n}","def <CONC>:Record[ObjectEnvironmentRecord].HasThisBinding(\n  envRec: Record[ObjectEnvironmentRecord],\n): False = {\n  return false\n}","def <CONC>:Record[ObjectEnvironmentRecord].HasSuperBinding(\n  envRec: Record[ObjectEnvironmentRecord],\n): False = {\n  return false\n}","def <CONC>:Record[ObjectEnvironmentRecord].WithBaseObject(\n  envRec: Record[ObjectEnvironmentRecord],\n): Record[Object] | Undefined = {\n  if (= envRec.IsWithEnvironment true) {\n    return envRec.BindingObject\n  } else {\n    return undefined\n  }\n}","def <CONC>:Record[FunctionEnvironmentRecord].BindThisValue(\n  envRec: Record[FunctionEnvironmentRecord],\n  V: ESValue,\n): Normal[ESValue] | Throw = {\n  assert (! (= envRec.ThisBindingStatus ~lexical~))\n  if (= envRec.ThisBindingStatus ~initialized~) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%ReferenceError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  envRec.ThisValue = V\n  envRec.ThisBindingStatus = ~initialized~\n  if (? V: Completion) return V\n  call %2 = clo<\"NormalCompletion\">(V)\n  return %2\n}","def <CONC>:Record[FunctionEnvironmentRecord].HasThisBinding(\n  envRec: Record[FunctionEnvironmentRecord],\n): Boolean = {\n  if (= envRec.ThisBindingStatus ~lexical~) {\n    return false\n  } else {\n    return true\n  }\n}","def <CONC>:Record[FunctionEnvironmentRecord].HasSuperBinding(\n  envRec: Record[FunctionEnvironmentRecord],\n): Boolean = {\n  if (= envRec.ThisBindingStatus ~lexical~) {\n    return false\n  }\n  if (= envRec.FunctionObject.HomeObject undefined) {\n    return false\n  } else {\n    return true\n  }\n}","def <CONC>:Record[FunctionEnvironmentRecord].GetThisBinding(\n  envRec: Record[FunctionEnvironmentRecord],\n): Normal[ESValue] | Throw = {\n  assert (! (= envRec.ThisBindingStatus ~lexical~))\n  if (= envRec.ThisBindingStatus ~uninitialized~) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%ReferenceError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  %2 = envRec.ThisValue\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <CONC>:Record[FunctionEnvironmentRecord].GetSuperBase(\n  envRec: Record[FunctionEnvironmentRecord],\n): Normal[Record[Object] | Undefined | Null] | Throw = {\n  let home = envRec.FunctionObject.HomeObject\n  if (= home undefined) {\n    call %0 = clo<\"NormalCompletion\">(undefined)\n    return %0\n  }\n  assert (? home: Record[Object])\n  call %1 = home.GetPrototypeOf(home)\n  assert (? %1: Completion)\n  return %1\n}","def <CONC>:Record[GlobalEnvironmentRecord].HasBinding(\n  envRec: Record[GlobalEnvironmentRecord],\n  N: String,\n): Normal[Boolean] | Throw = {\n  let DclRec = envRec.DeclarativeRecord\n  call %0 = DclRec.HasBinding(DclRec, N)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  if (= %0 true) {\n    call %1 = clo<\"NormalCompletion\">(true)\n    return %1\n  }\n  let ObjRec = envRec.ObjectRecord\n  call %2 = ObjRec.HasBinding(ObjRec, N)\n  assert (? %2: Completion)\n  return %2\n}","def <CONC>:Record[GlobalEnvironmentRecord].CreateMutableBinding(\n  envRec: Record[GlobalEnvironmentRecord],\n  N: String,\n  D: Boolean,\n): Normal[Enum[~unused~]] | Throw = {\n  let DclRec = envRec.DeclarativeRecord\n  call %0 = DclRec.HasBinding(DclRec, N)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  if (= %0 true) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  call %3 = DclRec.CreateMutableBinding(DclRec, N, D)\n  assert (? %3: Normal)\n  return %3\n}","def <CONC>:Record[GlobalEnvironmentRecord].CreateImmutableBinding(\n  envRec: Record[GlobalEnvironmentRecord],\n  N: String,\n  S: Boolean,\n): Normal[Enum[~unused~]] | Throw = {\n  let DclRec = envRec.DeclarativeRecord\n  call %0 = DclRec.HasBinding(DclRec, N)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  if (= %0 true) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  call %3 = DclRec.CreateImmutableBinding(DclRec, N, S)\n  assert (? %3: Normal)\n  return %3\n}","def <CONC>:Record[GlobalEnvironmentRecord].InitializeBinding(\n  envRec: Record[GlobalEnvironmentRecord],\n  N: String,\n  V: ESValue,\n): Normal[Enum[~unused~]] | Throw = {\n  let DclRec = envRec.DeclarativeRecord\n  call %0 = DclRec.HasBinding(DclRec, N)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  if (= %0 true) {\n    call %1 = DclRec.InitializeBinding(DclRec, N, V)\n    assert (? %1: Normal)\n    return %1\n  }\n  assert (yet \"If the binding exists, it must be in the Object Environment Record.\")\n  let ObjRec = envRec.ObjectRecord\n  call %2 = ObjRec.InitializeBinding(ObjRec, N, V)\n  assert (? %2: Completion)\n  return %2\n}","def <CONC>:Record[GlobalEnvironmentRecord].SetMutableBinding(\n  envRec: Record[GlobalEnvironmentRecord],\n  N: String,\n  V: ESValue,\n  S: Boolean,\n): Normal[Enum[~unused~]] | Throw = {\n  let DclRec = envRec.DeclarativeRecord\n  call %0 = DclRec.HasBinding(DclRec, N)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  if (= %0 true) {\n    call %1 = DclRec.SetMutableBinding(DclRec, N, V, S)\n    assert (? %1: Completion)\n    return %1\n  }\n  let ObjRec = envRec.ObjectRecord\n  call %2 = ObjRec.SetMutableBinding(ObjRec, N, V, S)\n  assert (? %2: Completion)\n  return %2\n}","def <CONC>:Record[GlobalEnvironmentRecord].GetBindingValue(\n  envRec: Record[GlobalEnvironmentRecord],\n  N: String,\n  S: Boolean,\n): Normal[ESValue] | Throw = {\n  let DclRec = envRec.DeclarativeRecord\n  call %0 = DclRec.HasBinding(DclRec, N)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  if (= %0 true) {\n    call %1 = DclRec.GetBindingValue(DclRec, N, S)\n    assert (? %1: Completion)\n    return %1\n  }\n  let ObjRec = envRec.ObjectRecord\n  call %2 = ObjRec.GetBindingValue(ObjRec, N, S)\n  assert (? %2: Completion)\n  return %2\n}","def <CONC>:Record[GlobalEnvironmentRecord].DeleteBinding(\n  envRec: Record[GlobalEnvironmentRecord],\n  N: String,\n): Normal[Boolean] | Throw = {\n  let DclRec = envRec.DeclarativeRecord\n  call %0 = DclRec.HasBinding(DclRec, N)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  if (= %0 true) {\n    call %1 = DclRec.DeleteBinding(DclRec, N)\n    assert (? %1: Normal)\n    return %1\n  }\n  let ObjRec = envRec.ObjectRecord\n  let globalObject = ObjRec.BindingObject\n  call %2 = clo<\"HasOwnProperty\">(globalObject, N)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let existingProp = %2\n  if (= existingProp true) {\n    call %3 = ObjRec.DeleteBinding(ObjRec, N)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let status = %3\n    if (&& (= status true) (contains envRec.VarNames N)) {\n      call %4 = clo<\"__REMOVE_ELEM__\">(N, envRec.VarNames)\n    }\n    if (? status: Completion) return status\n    call %5 = clo<\"NormalCompletion\">(status)\n    return %5\n  }\n  call %6 = clo<\"NormalCompletion\">(true)\n  return %6\n}","def <CONC>:Record[GlobalEnvironmentRecord].HasThisBinding(\n  envRec: Record[GlobalEnvironmentRecord],\n): True = {\n  return true\n}","def <CONC>:Record[GlobalEnvironmentRecord].HasSuperBinding(\n  envRec: Record[GlobalEnvironmentRecord],\n): False = {\n  return false\n}","def <CONC>:Record[GlobalEnvironmentRecord].WithBaseObject(\n  envRec: Record[GlobalEnvironmentRecord],\n): Undefined = {\n  return undefined\n}","def <CONC>:Record[GlobalEnvironmentRecord].GetThisBinding(\n  envRec: Record[GlobalEnvironmentRecord],\n): Normal[Record[Object]] = {\n  %0 = envRec.GlobalThisValue\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <CONC>:Record[GlobalEnvironmentRecord].HasVarDeclaration(\n  envRec: Record[GlobalEnvironmentRecord],\n  N: String,\n): Boolean = {\n  let varDeclaredNames = envRec.VarNames\n  if (contains varDeclaredNames N) {\n    return true\n  }\n  return false\n}","def <CONC>:Record[GlobalEnvironmentRecord].HasLexicalDeclaration(\n  envRec: Record[GlobalEnvironmentRecord],\n  N: String,\n): Boolean = {\n  let DclRec = envRec.DeclarativeRecord\n  call %0 = DclRec.HasBinding(DclRec, N)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  return %0\n}","def <CONC>:Record[GlobalEnvironmentRecord].HasRestrictedGlobalProperty(\n  envRec: Record[GlobalEnvironmentRecord],\n  N: String,\n): Normal[Boolean] | Throw = {\n  let ObjRec = envRec.ObjectRecord\n  let globalObject = ObjRec.BindingObject\n  call %0 = globalObject.GetOwnProperty(globalObject, N)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let existingProp = %0\n  if (= existingProp undefined) {\n    call %1 = clo<\"NormalCompletion\">(false)\n    return %1\n  }\n  if (= existingProp.Configurable true) {\n    call %2 = clo<\"NormalCompletion\">(false)\n    return %2\n  }\n  call %3 = clo<\"NormalCompletion\">(true)\n  return %3\n}","def <CONC>:Record[GlobalEnvironmentRecord].CanDeclareGlobalVar(\n  envRec: Record[GlobalEnvironmentRecord],\n  N: String,\n): Normal[Boolean] | Throw = {\n  let ObjRec = envRec.ObjectRecord\n  let globalObject = ObjRec.BindingObject\n  call %0 = clo<\"HasOwnProperty\">(globalObject, N)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let hasProperty = %0\n  if (= hasProperty true) {\n    call %1 = clo<\"NormalCompletion\">(true)\n    return %1\n  }\n  call %2 = clo<\"IsExtensible\">(globalObject)\n  assert (? %2: Completion)\n  return %2\n}","def <CONC>:Record[GlobalEnvironmentRecord].CanDeclareGlobalFunction(\n  envRec: Record[GlobalEnvironmentRecord],\n  N: String,\n): Normal[Boolean] | Throw = {\n  let ObjRec = envRec.ObjectRecord\n  let globalObject = ObjRec.BindingObject\n  call %0 = globalObject.GetOwnProperty(globalObject, N)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let existingProp = %0\n  if (= existingProp undefined) {\n    call %1 = clo<\"IsExtensible\">(globalObject)\n    assert (? %1: Completion)\n    return %1\n  }\n  if (= existingProp.Configurable true) {\n    call %2 = clo<\"NormalCompletion\">(true)\n    return %2\n  }\n  (yet \"If IsDataDescriptor(_existingProp_) is *true* and _existingProp_ has attribute values { [[Writable]]: *true*, [[Enumerable]]: *true* }, return *true*.\")\n  call %3 = clo<\"NormalCompletion\">(false)\n  return %3\n}","def <CONC>:Record[GlobalEnvironmentRecord].CreateGlobalVarBinding(\n  envRec: Record[GlobalEnvironmentRecord],\n  N: String,\n  D: Boolean,\n): Normal[Enum[~unused~]] | Throw = {\n  let ObjRec = envRec.ObjectRecord\n  let globalObject = ObjRec.BindingObject\n  call %0 = clo<\"HasOwnProperty\">(globalObject, N)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let hasProperty = %0\n  call %1 = clo<\"IsExtensible\">(globalObject)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let extensible = %1\n  if (&& (= hasProperty false) (= extensible true)) {\n    call %2 = ObjRec.CreateMutableBinding(ObjRec, N, D)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    call %3 = ObjRec.InitializeBinding(ObjRec, N, undefined)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n  }\n  if (! (contains envRec.VarNames N)) {\n    push envRec.VarNames < N\n  }\n  call %4 = clo<\"NormalCompletion\">(~unused~)\n  return %4\n}","def <CONC>:Record[GlobalEnvironmentRecord].CreateGlobalFunctionBinding(\n  envRec: Record[GlobalEnvironmentRecord],\n  N: String,\n  V: ESValue,\n  D: Boolean,\n): Normal[Enum[~unused~]] | Throw = {\n  let ObjRec = envRec.ObjectRecord\n  let globalObject = ObjRec.BindingObject\n  call %0 = globalObject.GetOwnProperty(globalObject, N)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let existingProp = %0\n  if (|| (= existingProp undefined) (= existingProp.Configurable true)) {\n    let desc = (record [PropertyDescriptor] {\n      \"Value\" : V,\n      \"Writable\" : true,\n      \"Enumerable\" : true,\n      \"Configurable\" : D,\n    })[#351]\n  } else {\n    let desc = (record [PropertyDescriptor] {\n      \"Value\" : V,\n    })[#352]\n  }\n  call %1 = clo<\"DefinePropertyOrThrow\">(globalObject, N, desc)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  call %2 = clo<\"Set\">(globalObject, N, V, false)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  if (! (contains envRec.VarNames N)) {\n    push envRec.VarNames < N\n  }\n  call %3 = clo<\"NormalCompletion\">(~unused~)\n  return %3\n}","def <CONC>:Record[ModuleEnvironmentRecord].GetBindingValue(\n  envRec: Record[ModuleEnvironmentRecord],\n  N: String,\n  S: Boolean,\n): Normal[ESValue] | Throw = {\n  assert (= S true)\n  assert (exists envRec.__MAP__[N])\n  (yet \"If the binding for _N_ is an indirect binding, then\\n  1. Let _M_ and _N2_ be the indirection values provided when this binding for _N_ was created.\\n  1. Let _targetEnv_ be _M_.[[Environment]].\\n  1. If _targetEnv_ is ~empty~, throw a *ReferenceError* exception.\\n  1. Return ? _targetEnv_.GetBindingValue(_N2_, *true*).\")\n  if (! envRec.__MAP__[N].initialized) {\n    call __errObj__ = clo<\"__NEW_ERROR_OBJ__\">(\"%ReferenceError.prototype%\")\n    call __comp__ = clo<\"ThrowCompletion\">(__errObj__)\n    {\n      if (? __comp__: Completion) return __comp__\n      call %0 = clo<\"NormalCompletion\">(__comp__)\n      return %0\n    }\n  }\n  %1 = envRec.__MAP__[N].BoundValue\n  if (? %1: Completion) return %1\n  call %2 = clo<\"NormalCompletion\">(%1)\n  return %2\n}","def <CONC>:Record[ModuleEnvironmentRecord].HasThisBinding(\n  envRec: Record[ModuleEnvironmentRecord],\n): True = {\n  return true\n}","def <CONC>:Record[ModuleEnvironmentRecord].GetThisBinding(\n  envRec: Record[ModuleEnvironmentRecord],\n): Normal[Undefined] = {\n  call %0 = clo<\"NormalCompletion\">(undefined)\n  return %0\n}","def <CONC>:Record[ModuleEnvironmentRecord].CreateImportBinding(\n  envRec: Record[ModuleEnvironmentRecord],\n  N: String,\n  M: Record[ModuleRecord],\n  N2: String,\n): Enum[~unused~] = {\n  assert (! (exists envRec.__MAP__[N]))\n  assert (yet \"When _M_.[[Environment]] is instantiated, it will have a direct binding for _N2_.\")\n  (yet \"Create an immutable indirect binding in _envRec_ for _N_ that references _M_ and _N2_ as its target binding and record that the binding is initialized.\")\n  return ~unused~\n}","def GetIdentifierReference(\n  env: Record[EnvironmentRecord] | Null,\n  name: String,\n  strict: Boolean,\n): Normal[Record[ReferenceRecord]] | Throw = {\n  if (= env null) {\n    %0 = (record [ReferenceRecord] {\n      \"Base\" : ~unresolvable~,\n      \"ReferencedName\" : name,\n      \"Strict\" : strict,\n      \"ThisValue\" : ~empty~,\n    })[#353]\n    if (? %0: Completion) return %0\n    call %1 = clo<\"NormalCompletion\">(%0)\n    return %1\n  }\n  call %2 = env.HasBinding(env, name)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let exists = %2\n  if (= exists true) {\n    %3 = (record [ReferenceRecord] {\n      \"Base\" : env,\n      \"ReferencedName\" : name,\n      \"Strict\" : strict,\n      \"ThisValue\" : ~empty~,\n    })[#354]\n    if (? %3: Completion) return %3\n    call %4 = clo<\"NormalCompletion\">(%3)\n    return %4\n  } else {\n    let outer = env.OuterEnv\n    call %5 = clo<\"GetIdentifierReference\">(outer, name, strict)\n    assert (? %5: Completion)\n    return %5\n  }\n}","def NewDeclarativeEnvironment(\n  E: Record[EnvironmentRecord] | Null,\n): Record[DeclarativeEnvironmentRecord] = {\n  let env = (record [DeclarativeEnvironmentRecord] {\n    \"CreateImmutableBinding\" : clo<\"Record[DeclarativeEnvironmentRecord].CreateImmutableBinding\">,\n    \"CreateMutableBinding\" : clo<\"Record[DeclarativeEnvironmentRecord].CreateMutableBinding\">,\n    \"DeleteBinding\" : clo<\"Record[DeclarativeEnvironmentRecord].DeleteBinding\">,\n    \"GetBindingValue\" : clo<\"Record[DeclarativeEnvironmentRecord].GetBindingValue\">,\n    \"HasBinding\" : clo<\"Record[DeclarativeEnvironmentRecord].HasBinding\">,\n    \"HasSuperBinding\" : clo<\"Record[DeclarativeEnvironmentRecord].HasSuperBinding\">,\n    \"HasThisBinding\" : clo<\"Record[DeclarativeEnvironmentRecord].HasThisBinding\">,\n    \"InitializeBinding\" : clo<\"Record[DeclarativeEnvironmentRecord].InitializeBinding\">,\n    \"SetMutableBinding\" : clo<\"Record[DeclarativeEnvironmentRecord].SetMutableBinding\">,\n    \"WithBaseObject\" : clo<\"Record[DeclarativeEnvironmentRecord].WithBaseObject\">,\n    \"__MAP__\" : (map[String, Record[Binding]])[#356],\n  })[#355]\n  env.OuterEnv = E\n  return env\n}","def NewObjectEnvironment(\n  O: Record[Object],\n  W: Boolean,\n  E: Record[EnvironmentRecord] | Null,\n): Record[ObjectEnvironmentRecord] = {\n  let env = (record [ObjectEnvironmentRecord] {\n    \"CreateMutableBinding\" : clo<\"Record[ObjectEnvironmentRecord].CreateMutableBinding\">,\n    \"DeleteBinding\" : clo<\"Record[ObjectEnvironmentRecord].DeleteBinding\">,\n    \"GetBindingValue\" : clo<\"Record[ObjectEnvironmentRecord].GetBindingValue\">,\n    \"HasBinding\" : clo<\"Record[ObjectEnvironmentRecord].HasBinding\">,\n    \"HasSuperBinding\" : clo<\"Record[ObjectEnvironmentRecord].HasSuperBinding\">,\n    \"HasThisBinding\" : clo<\"Record[ObjectEnvironmentRecord].HasThisBinding\">,\n    \"InitializeBinding\" : clo<\"Record[ObjectEnvironmentRecord].InitializeBinding\">,\n    \"SetMutableBinding\" : clo<\"Record[ObjectEnvironmentRecord].SetMutableBinding\">,\n    \"WithBaseObject\" : clo<\"Record[ObjectEnvironmentRecord].WithBaseObject\">,\n    \"__MAP__\" : (map[String, Record[Binding]])[#358],\n  })[#357]\n  env.BindingObject = O\n  env.IsWithEnvironment = W\n  env.OuterEnv = E\n  return env\n}","def NewFunctionEnvironment(\n  F: Record[ECMAScriptFunctionObject],\n  newTarget: Record[Object] | Undefined,\n): Record[FunctionEnvironmentRecord] = {\n  let env = (record [FunctionEnvironmentRecord] {\n    \"BindThisValue\" : clo<\"Record[FunctionEnvironmentRecord].BindThisValue\">,\n    \"CreateImmutableBinding\" : clo<\"Record[DeclarativeEnvironmentRecord].CreateImmutableBinding\">,\n    \"CreateMutableBinding\" : clo<\"Record[DeclarativeEnvironmentRecord].CreateMutableBinding\">,\n    \"DeleteBinding\" : clo<\"Record[DeclarativeEnvironmentRecord].DeleteBinding\">,\n    \"GetBindingValue\" : clo<\"Record[DeclarativeEnvironmentRecord].GetBindingValue\">,\n    \"GetSuperBase\" : clo<\"Record[FunctionEnvironmentRecord].GetSuperBase\">,\n    \"GetThisBinding\" : clo<\"Record[FunctionEnvironmentRecord].GetThisBinding\">,\n    \"HasBinding\" : clo<\"Record[DeclarativeEnvironmentRecord].HasBinding\">,\n    \"HasSuperBinding\" : clo<\"Record[FunctionEnvironmentRecord].HasSuperBinding\">,\n    \"HasThisBinding\" : clo<\"Record[FunctionEnvironmentRecord].HasThisBinding\">,\n    \"InitializeBinding\" : clo<\"Record[DeclarativeEnvironmentRecord].InitializeBinding\">,\n    \"SetMutableBinding\" : clo<\"Record[DeclarativeEnvironmentRecord].SetMutableBinding\">,\n    \"WithBaseObject\" : clo<\"Record[DeclarativeEnvironmentRecord].WithBaseObject\">,\n    \"__MAP__\" : (map[String, Record[Binding]])[#360],\n  })[#359]\n  env.FunctionObject = F\n  if (= F.ThisMode ~lexical~) {\n    env.ThisBindingStatus = ~lexical~\n  } else {\n    env.ThisBindingStatus = ~uninitialized~\n  }\n  env.NewTarget = newTarget\n  env.OuterEnv = F.Environment\n  return env\n}","def NewGlobalEnvironment(\n  G: Record[Object],\n  thisValue: Record[Object],\n): Record[GlobalEnvironmentRecord] = {\n  call %0 = clo<\"NewObjectEnvironment\">(G, false, null)\n  let objRec = %0\n  call %1 = clo<\"NewDeclarativeEnvironment\">(null)\n  let dclRec = %1\n  let env = (record [GlobalEnvironmentRecord] {\n    \"CanDeclareGlobalFunction\" : clo<\"Record[GlobalEnvironmentRecord].CanDeclareGlobalFunction\">,\n    \"CanDeclareGlobalVar\" : clo<\"Record[GlobalEnvironmentRecord].CanDeclareGlobalVar\">,\n    \"CreateGlobalFunctionBinding\" : clo<\"Record[GlobalEnvironmentRecord].CreateGlobalFunctionBinding\">,\n    \"CreateGlobalVarBinding\" : clo<\"Record[GlobalEnvironmentRecord].CreateGlobalVarBinding\">,\n    \"CreateImmutableBinding\" : clo<\"Record[GlobalEnvironmentRecord].CreateImmutableBinding\">,\n    \"CreateMutableBinding\" : clo<\"Record[GlobalEnvironmentRecord].CreateMutableBinding\">,\n    \"DeleteBinding\" : clo<\"Record[GlobalEnvironmentRecord].DeleteBinding\">,\n    \"GetBindingValue\" : clo<\"Record[GlobalEnvironmentRecord].GetBindingValue\">,\n    \"GetThisBinding\" : clo<\"Record[GlobalEnvironmentRecord].GetThisBinding\">,\n    \"HasBinding\" : clo<\"Record[GlobalEnvironmentRecord].HasBinding\">,\n    \"HasLexicalDeclaration\" : clo<\"Record[GlobalEnvironmentRecord].HasLexicalDeclaration\">,\n    \"HasRestrictedGlobalProperty\" : clo<\"Record[GlobalEnvironmentRecord].HasRestrictedGlobalProperty\">,\n    \"HasSuperBinding\" : clo<\"Record[GlobalEnvironmentRecord].HasSuperBinding\">,\n    \"HasThisBinding\" : clo<\"Record[GlobalEnvironmentRecord].HasThisBinding\">,\n    \"HasVarDeclaration\" : clo<\"Record[GlobalEnvironmentRecord].HasVarDeclaration\">,\n    \"InitializeBinding\" : clo<\"Record[GlobalEnvironmentRecord].InitializeBinding\">,\n    \"SetMutableBinding\" : clo<\"Record[GlobalEnvironmentRecord].SetMutableBinding\">,\n    \"WithBaseObject\" : clo<\"Record[GlobalEnvironmentRecord].WithBaseObject\">,\n    \"__MAP__\" : (map[String, Record[Binding]])[#362],\n  })[#361]\n  env.ObjectRecord = objRec\n  env.GlobalThisValue = thisValue\n  env.DeclarativeRecord = dclRec\n  env.VarNames = (list [])[#363]\n  env.OuterEnv = null\n  return env\n}","def NewModuleEnvironment(\n  E: Record[EnvironmentRecord],\n): Record[ModuleEnvironmentRecord] = {\n  let env = (record [ModuleEnvironmentRecord] {\n    \"CreateImmutableBinding\" : clo<\"Record[DeclarativeEnvironmentRecord].CreateImmutableBinding\">,\n    \"CreateImportBinding\" : clo<\"Record[ModuleEnvironmentRecord].CreateImportBinding\">,\n    \"CreateMutableBinding\" : clo<\"Record[DeclarativeEnvironmentRecord].CreateMutableBinding\">,\n    \"DeleteBinding\" : clo<\"Record[DeclarativeEnvironmentRecord].DeleteBinding\">,\n    \"GetBindingValue\" : clo<\"Record[ModuleEnvironmentRecord].GetBindingValue\">,\n    \"GetThisBinding\" : clo<\"Record[ModuleEnvironmentRecord].GetThisBinding\">,\n    \"HasBinding\" : clo<\"Record[DeclarativeEnvironmentRecord].HasBinding\">,\n    \"HasSuperBinding\" : clo<\"Record[DeclarativeEnvironmentRecord].HasSuperBinding\">,\n    \"HasThisBinding\" : clo<\"Record[ModuleEnvironmentRecord].HasThisBinding\">,\n    \"InitializeBinding\" : clo<\"Record[DeclarativeEnvironmentRecord].InitializeBinding\">,\n    \"SetMutableBinding\" : clo<\"Record[DeclarativeEnvironmentRecord].SetMutableBinding\">,\n    \"WithBaseObject\" : clo<\"Record[DeclarativeEnvironmentRecord].WithBaseObject\">,\n    \"__MAP__\" : (map[String, Record[Binding]])[#365],\n  })[#364]\n  env.OuterEnv = E\n  return env\n}","def NewPrivateEnvironment(\n  outerPrivEnv: Record[PrivateEnvironmentRecord] | Null,\n): Record[PrivateEnvironmentRecord] = {\n  let names = (list [])[#366]\n  return (record [PrivateEnvironmentRecord] {\n    \"OuterPrivateEnvironment\" : outerPrivEnv,\n    \"Names\" : names,\n    \"__MAP__\" : (map[String, Record[Binding]])[#368],\n  })[#367]\n}","def ResolvePrivateIdentifier(\n  privEnv: Record[PrivateEnvironmentRecord],\n  identifier: String,\n): Record[PrivateName] = {\n  let names = privEnv.Names\n  %1 = names\n  %0 = 0\n  while (< %0 (sizeof %1)) {\n    let pn = %1[%0]\n    if (? pn: Record[PrivateName]) {\n      if (= pn.Description identifier) {\n        return pn\n      }\n    }\n    %0 = (+ %0 1)\n  }\n  let outerPrivEnv = privEnv.OuterPrivateEnvironment\n  assert (! (= outerPrivEnv null))\n  call %2 = clo<\"ResolvePrivateIdentifier\">(outerPrivEnv, identifier)\n  return %2\n}","def CreateRealm(\n): Record[RealmRecord] = {\n  let realmRec = @REALM\n  call %0 = clo<\"CreateIntrinsics\">(realmRec)\n  call %1 = clo<\"AgentSignifier\">()\n  realmRec.AgentSignifier = %1\n  realmRec.GlobalObject = undefined\n  realmRec.GlobalEnv = undefined\n  realmRec.TemplateMap = (list [])[#369]\n  return realmRec\n}","def CreateIntrinsics(\n  realmRec: Record[RealmRecord],\n): Enum[~unused~] = {\n  realmRec.Intrinsics = (record)[#370]\n  realmRec.Intrinsics = @INTRINSICS\n  call %0 = clo<\"AddRestrictedFunctionProperties\">(realmRec.Intrinsics[\"%Function.prototype%\"], realmRec)\n  return ~unused~\n}","def SetRealmGlobalObject(\n  realmRec: Record[RealmRecord],\n  globalObj: Record[Object] | Undefined,\n  thisValue: Record[Object] | Undefined,\n): Enum[~unused~] = {\n  if (= globalObj undefined) {\n    let intrinsics = realmRec.Intrinsics\n    call %0 = clo<\"OrdinaryObjectCreate\">(intrinsics[\"%Object.prototype%\"])\n    globalObj = %0\n  }\n  assert (? globalObj: Record[Object])\n  if (= thisValue undefined) {\n    thisValue = globalObj\n  }\n  realmRec.GlobalObject = globalObj\n  call %1 = clo<\"NewGlobalEnvironment\">(globalObj, thisValue)\n  let newGlobalEnv = %1\n  realmRec.GlobalEnv = newGlobalEnv\n  return ~unused~\n}","def SetDefaultGlobalBindings(\n  realmRec: Record[RealmRecord],\n): Normal[Record[Object]] | Throw = {\n  let global = realmRec.GlobalObject\n  let keys = (keys @GLOBAL.__MAP__)[#371]\n  let idx = 0\n  while (< idx (sizeof keys)) {\n    let name = keys[idx]\n    global.__MAP__[name] = @GLOBAL.__MAP__[name]\n    idx = (+ idx 1)\n  }\n  global.__MAP__.globalThis = (record [PropertyDescriptor] {\n    \"Value\" : global,\n    \"Writable\" : true,\n    \"Enumerable\" : false,\n    \"Configurable\" : true,\n  })[#372]\n  if (? global: Completion) return global\n  call %0 = clo<\"NormalCompletion\">(global)\n  return %0\n}","def GetActiveScriptOrModule(\n): Record[ModuleRecord | ScriptRecord] | Null = {\n  if (= (sizeof @EXECUTION_STACK) 0) return null\n  let idx = 0\n  while (&& (< idx (sizeof @EXECUTION_STACK)) (! (exists ec))) {\n    if (! (= @EXECUTION_STACK[idx].ScriptOrModule null)) let ec = @EXECUTION_STACK[idx]\n    idx = (+ idx 1)\n  }\n  if (! (exists ec)) return null\n  else return ec.ScriptOrModule\n}","def ResolveBinding(\n  name: String,\n  env?: Record[EnvironmentRecord] | Undefined,\n): Normal[Record[ReferenceRecord]] | Throw = {\n  if (|| (! (exists env)) (= env undefined)) {\n    env = @EXECUTION_STACK[0].LexicalEnvironment\n  }\n  assert (? env: Record[EnvironmentRecord])\n  if true {\n    let strict = true\n  } else {\n    let strict = false\n  }\n  call %0 = clo<\"GetIdentifierReference\">(env, name, strict)\n  assert (? %0: Completion)\n  return %0\n}","def GetThisEnvironment(\n): Record[EnvironmentRecord] = {\n  let env = @EXECUTION_STACK[0].LexicalEnvironment\n  while true {\n    call %0 = env.HasThisBinding(env)\n    let exists = %0\n    if (= exists true) {\n      return env\n    }\n    let outer = env.OuterEnv\n    assert (! (= outer null))\n    env = outer\n  }\n}","def ResolveThisBinding(\n): Normal[ESValue] | Throw = {\n  call %0 = clo<\"GetThisEnvironment\">()\n  let envRec = %0\n  call %1 = envRec.GetThisBinding(envRec)\n  assert (? %1: Completion)\n  return %1\n}","def GetNewTarget(\n): Record[Object] | Undefined = {\n  call %0 = clo<\"GetThisEnvironment\">()\n  let envRec = %0\n  assert (exists envRec.NewTarget)\n  return envRec.NewTarget\n}","def GetGlobalObject(\n): Record[Object] = {\n  let currentRealm = @EXECUTION_STACK[0].Realm\n  return currentRealm.GlobalObject\n}","def HostMakeJobCallback(\n  callback: Record[FunctionObject],\n): Record[JobCallbackRecord] = {\n  return (record [JobCallbackRecord] {\n    \"Callback\" : callback,\n    \"HostDefined\" : ~empty~,\n  })[#373]\n}","def HostCallJobCallback(\n  jobCallback: Record[JobCallbackRecord],\n  V: ESValue,\n  argumentsList: List[ESValue],\n): Normal[ESValue] | Throw = {\n  call %0 = clo<\"IsCallable\">(jobCallback.Callback)\n  assert (= %0 true)\n  call %1 = clo<\"Call\">(jobCallback.Callback, V, argumentsList)\n  assert (? %1: Completion)\n  return %1\n}","def InitializeHostDefinedRealm(\n): Normal[Enum[~unused~]] | Throw = {\n  call %0 = clo<\"CreateRealm\">()\n  let realm = %0\n  let newContext = (record [ExecutionContext])[#374]\n  newContext.Function = null\n  newContext.Realm = realm\n  newContext.ScriptOrModule = null\n  push newContext > @EXECUTION_STACK\n  let global = undefined\n  let thisValue = undefined\n  call %1 = clo<\"SetRealmGlobalObject\">(realm, global, thisValue)\n  call %2 = clo<\"SetDefaultGlobalBindings\">(realm)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let globalObj = %2\n  nop\n  call %3 = clo<\"NormalCompletion\">(~unused~)\n  return %3\n}","def AgentSignifier(\n): Unknown[\"AgentSignifier\"] = {\n  let AR = @AGENT_RECORD\n  return AR.Signifier\n}","def AgentCanSuspend(\n): Boolean = {\n  let AR = @AGENT_RECORD\n  return AR.CanBlock\n}","def HostEnqueueFinalizationRegistryCleanupJob(\n  finalizationRegistry: Record[FinalizationRegistry],\n): Enum[~unused~] = {\n  call %0 = clo<\"CleanupFinalizationRegistry\">(finalizationRegistry)\n  call %1 = clo<\"Completion\">(%0)\n  let cleanupResult = %1\n  if (&& (? cleanupResult: Completion) (! (= cleanupResult.Type ~normal~))) {\n    (yet \"perform any host-defined steps for reporting the error.\")\n  }\n  return ~unused~\n}","def ClearKeptObjects(\n): Enum[~unused~] = {\n  (yet \"Let _agentRecord_ be the surrounding agent's Agent Record.\")\n  agentRecord.KeptAlive = (list [])[#375]\n  return ~unused~\n}","def AddToKeptObjects(\n  value: Record[Object | Symbol],\n): Enum[~unused~] = {\n  (yet \"Let _agentRecord_ be the surrounding agent's Agent Record.\")\n  push agentRecord.KeptAlive < value\n  return ~unused~\n}","def CleanupFinalizationRegistry(\n  finalizationRegistry: Record[FinalizationRegistry],\n): Normal[Enum[~unused~]] | Throw = {\n  assert (yet \"_finalizationRegistry_ has [[Cells]] and [[CleanupCallback]] internal slots.\")\n  let callback = finalizationRegistry.CleanupCallback\n  (yet \"While _finalizationRegistry_.[[Cells]] contains a Record _cell_ such that _cell_.[[WeakRefTarget]] is ~empty~, an implementation may perform the following steps:\\n  1. Choose any such _cell_.\\n  1. Remove _cell_ from _finalizationRegistry_.[[Cells]].\\n  1. Perform ? HostCallJobCallback(_callback_, *undefined*, ¬´ _cell_.[[HeldValue]] ¬ª).\")\n  call %0 = clo<\"NormalCompletion\">(~unused~)\n  return %0\n}","def CanBeHeldWeakly(\n  v: ESValue,\n): Boolean = {\n  if (? v: Record[Object]) {\n    return true\n  }\n  %0 = (? v: Record[Symbol])\n  if %0 {\n    call %1 = clo<\"KeyForSymbol\">(v)\n    %0 = (= %1 undefined)\n  }\n  if %0 {\n    return true\n  }\n  return false\n}","def <INTERNAL>:Record[OrdinaryObject].GetPrototypeOf(\n  O: Record[OrdinaryObject],\n): Normal[Record[Object] | Null] = {\n  call %0 = clo<\"OrdinaryGetPrototypeOf\">(O)\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def OrdinaryGetPrototypeOf(\n  O: Record[Object],\n): Record[Object] | Null = {\n  return O.Prototype\n}","def <INTERNAL>:Record[OrdinaryObject].SetPrototypeOf(\n  O: Record[OrdinaryObject],\n  V: Record[Object] | Null,\n): Normal[Boolean] = {\n  call %0 = clo<\"OrdinarySetPrototypeOf\">(O, V)\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def OrdinarySetPrototypeOf(\n  O: Record[Object],\n  V: Record[Object] | Null,\n): Boolean = {\n  let current = O.Prototype\n  call %0 = clo<\"SameValue\">(V, current)\n  if (= %0 true) {\n    return true\n  }\n  let extensible = O.Extensible\n  if (= extensible false) {\n    return false\n  }\n  let p = V\n  let done = false\n  while (= done false) {\n    if (= p null) {\n      done = true\n    } else {\n      call %1 = clo<\"SameValue\">(p, O)\n      if (= %1 true) {\n        return false\n      } else {\n        if (! (= p.GetPrototypeOf clo<\"Record[OrdinaryObject].GetPrototypeOf\">)) {\n          done = true\n        } else {\n          p = p.Prototype\n        }\n      }\n    }\n  }\n  O.Prototype = V\n  return true\n}","def <INTERNAL>:Record[OrdinaryObject].IsExtensible(\n  O: Record[OrdinaryObject],\n): Normal[Boolean] = {\n  call %0 = clo<\"OrdinaryIsExtensible\">(O)\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def OrdinaryIsExtensible(\n  O: Record[Object],\n): Boolean = {\n  return O.Extensible\n}","def <INTERNAL>:Record[OrdinaryObject].PreventExtensions(\n  O: Record[OrdinaryObject],\n): Normal[True] = {\n  call %0 = clo<\"OrdinaryPreventExtensions\">(O)\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def OrdinaryPreventExtensions(\n  O: Record[Object],\n): True = {\n  O.Extensible = false\n  return true\n}","def <INTERNAL>:Record[OrdinaryObject].GetOwnProperty(\n  O: Record[OrdinaryObject],\n  P: Record[Symbol] | String,\n): Normal[Record[PropertyDescriptor] | Undefined] = {\n  call %0 = clo<\"OrdinaryGetOwnProperty\">(O, P)\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def OrdinaryGetOwnProperty(\n  O: Record[Object],\n  P: Record[Symbol] | String,\n): Record[PropertyDescriptor] | Undefined = {\n  if (! (exists O.__MAP__[P])) return undefined\n  let D = (record [PropertyDescriptor])[#376]\n  let X = O.__MAP__[P]\n  call %0 = clo<\"IsDataDescriptor\">(X)\n  if %0 {\n    D.Value = X.Value\n    D.Writable = X.Writable\n  } else {\n    call %1 = clo<\"IsAccessorDescriptor\">(X)\n    assert %1\n    D.Get = X.Get\n    D.Set = X.Set\n  }\n  D.Enumerable = X.Enumerable\n  D.Configurable = X.Configurable\n  return D\n}","def <INTERNAL>:Record[OrdinaryObject].DefineOwnProperty(\n  O: Record[OrdinaryObject],\n  P: Record[Symbol] | String,\n  Desc: Record[PropertyDescriptor],\n): Normal[Boolean] | Throw = {\n  call %0 = clo<\"OrdinaryDefineOwnProperty\">(O, P, Desc)\n  assert (? %0: Completion)\n  return %0\n}","def OrdinaryDefineOwnProperty(\n  O: Record[Object],\n  P: Record[Symbol] | String,\n  Desc: Record[PropertyDescriptor],\n): Normal[Boolean] | Throw = {\n  call %0 = O.GetOwnProperty(O, P)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let current = %0\n  call %1 = clo<\"IsExtensible\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let extensible = %1\n  call %2 = clo<\"ValidateAndApplyPropertyDescriptor\">(O, P, extensible, Desc, current)\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def IsCompatiblePropertyDescriptor(\n  Extensible: Boolean,\n  Desc: Record[PropertyDescriptor],\n  Current: Record[PropertyDescriptor] | Undefined,\n): Boolean = {\n  call %0 = clo<\"ValidateAndApplyPropertyDescriptor\">(undefined, \"\", Extensible, Desc, Current)\n  return %0\n}","def ValidateAndApplyPropertyDescriptor(\n  O: Record[Object] | Undefined,\n  P: Record[Symbol] | String,\n  extensible: Boolean,\n  Desc: Record[PropertyDescriptor],\n  current: Record[PropertyDescriptor] | Undefined,\n): Boolean = {\n  call %0 = clo<\"IsPropertyKey\">(P)\n  assert (= %0 true)\n  if (= current undefined) {\n    if (= extensible false) {\n      return false\n    }\n    if (= O undefined) {\n      return true\n    }\n    call %1 = clo<\"IsAccessorDescriptor\">(Desc)\n    if (= %1 true) {\n      let ap = (record [PropertyDescriptor])[#377]\n      if (! (exists Desc.Get)) ap.Get = undefined\n      else ap.Get = Desc.Get\n      if (! (exists Desc.Set)) ap.Set = undefined\n      else ap.Set = Desc.Set\n      if (! (exists Desc.Enumerable)) ap.Enumerable = false\n      else ap.Enumerable = Desc.Enumerable\n      if (! (exists Desc.Configurable)) ap.Configurable = false\n      else ap.Configurable = Desc.Configurable\n      O.__MAP__[P] = ap\n    } else {\n      let dp = (record [PropertyDescriptor])[#378]\n      if (! (exists Desc.Value)) dp.Value = undefined\n      else dp.Value = Desc.Value\n      if (! (exists Desc.Writable)) dp.Writable = false\n      else dp.Writable = Desc.Writable\n      if (! (exists Desc.Enumerable)) dp.Enumerable = false\n      else dp.Enumerable = Desc.Enumerable\n      if (! (exists Desc.Configurable)) dp.Configurable = false\n      else dp.Configurable = Desc.Configurable\n      O.__MAP__[P] = dp\n    }\n    return true\n  }\n  assert (|| (&& (&& (&& (exists current.Value) (exists current.Writable)) (exists current.Enumerable)) (exists current.Configurable)) (&& (&& (&& (exists current.Get) (exists current.Set)) (exists current.Enumerable)) (exists current.Configurable)))\n  let descKeys = (keys Desc)[#379]\n  if (= (sizeof descKeys) 0) return true\n  if (= current.Configurable false) {\n    if (&& (exists Desc.Configurable) (= Desc.Configurable true)) {\n      return false\n    }\n    if (&& (exists Desc.Enumerable) (! (= Desc.Enumerable current.Enumerable))) {\n      return false\n    }\n    call %3 = clo<\"IsGenericDescriptor\">(Desc)\n    %2 = (= %3 false)\n    if %2 {\n      call %4 = clo<\"IsAccessorDescriptor\">(Desc)\n      call %5 = clo<\"IsAccessorDescriptor\">(current)\n      %2 = (! (= %4 %5))\n    }\n    if %2 {\n      return false\n    }\n    call %6 = clo<\"IsAccessorDescriptor\">(current)\n    if (= %6 true) {\n      %7 = (exists Desc.Get)\n      if %7 {\n        call %8 = clo<\"SameValue\">(Desc.Get, current.Get)\n        %7 = (= %8 false)\n      }\n      if %7 {\n        return false\n      }\n      %9 = (exists Desc.Set)\n      if %9 {\n        call %10 = clo<\"SameValue\">(Desc.Set, current.Set)\n        %9 = (= %10 false)\n      }\n      if %9 {\n        return false\n      }\n    } else {\n      if (= current.Writable false) {\n        if (&& (exists Desc.Writable) (= Desc.Writable true)) {\n          return false\n        }\n        %11 = (exists Desc.Value)\n        if %11 {\n          call %12 = clo<\"SameValue\">(Desc.Value, current.Value)\n          %11 = (= %12 false)\n        }\n        if %11 {\n          return false\n        }\n      }\n    }\n  }\n  if (! (= O undefined)) {\n    call %14 = clo<\"IsDataDescriptor\">(current)\n    %13 = (= %14 true)\n    if %13 {\n      call %15 = clo<\"IsAccessorDescriptor\">(Desc)\n      %13 = (= %15 true)\n    }\n    if %13 {\n      if (exists Desc.Configurable) {\n        let configurable = Desc.Configurable\n      } else {\n        let configurable = current.Configurable\n      }\n      if (exists Desc.Enumerable) {\n        let enumerable = Desc.Enumerable\n      } else {\n        let enumerable = current.Enumerable\n      }\n      let ap2 = (record [PropertyDescriptor] {\n        \"Configurable\" : configurable,\n        \"Enumerable\" : enumerable,\n      })[#380]\n      if (! (exists Desc.Get)) ap2.Get = undefined\n      else ap2.Get = Desc.Get\n      if (! (exists Desc.Set)) ap2.Set = undefined\n      else ap2.Set = Desc.Set\n      O.__MAP__[P] = ap2\n    } else {\n      call %17 = clo<\"IsAccessorDescriptor\">(current)\n      %16 = (= %17 true)\n      if %16 {\n        call %18 = clo<\"IsDataDescriptor\">(Desc)\n        %16 = (= %18 true)\n      }\n      if %16 {\n        if (exists Desc.Configurable) {\n          let configurable = Desc.Configurable\n        } else {\n          let configurable = current.Configurable\n        }\n        if (exists Desc.Enumerable) {\n          let enumerable = Desc.Enumerable\n        } else {\n          let enumerable = current.Enumerable\n        }\n        let dp2 = (record [PropertyDescriptor] {\n          \"Configurable\" : configurable,\n          \"Enumerable\" : enumerable,\n        })[#381]\n        if (! (exists Desc.Value)) dp2.Value = undefined\n        else dp2.Value = Desc.Value\n        if (! (exists Desc.Writable)) dp2.Writable = false\n        else dp2.Writable = Desc.Writable\n        O.__MAP__[P] = dp2\n      } else {\n        let fields = (keys Desc)[#382]\n        let idx = 0\n        while (< idx (sizeof fields)) {\n          let f = fields[idx]\n          O.__MAP__[P][f] = Desc[f]\n          idx = (+ idx 1)\n        }\n      }\n    }\n  }\n  return true\n}","def <INTERNAL>:Record[OrdinaryObject].HasProperty(\n  O: Record[OrdinaryObject],\n  P: Record[Symbol] | String,\n): Normal[Boolean] | Throw = {\n  call %0 = clo<\"OrdinaryHasProperty\">(O, P)\n  assert (? %0: Completion)\n  return %0\n}","def OrdinaryHasProperty(\n  O: Record[Object],\n  P: Record[Symbol] | String,\n): Normal[Boolean] | Throw = {\n  call %0 = O.GetOwnProperty(O, P)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let hasOwn = %0\n  if (! (= hasOwn undefined)) {\n    call %1 = clo<\"NormalCompletion\">(true)\n    return %1\n  }\n  call %2 = O.GetPrototypeOf(O)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let parent = %2\n  if (! (= parent null)) {\n    call %3 = parent.HasProperty(parent, P)\n    assert (? %3: Completion)\n    return %3\n  }\n  call %4 = clo<\"NormalCompletion\">(false)\n  return %4\n}","def <INTERNAL>:Record[OrdinaryObject].Get(\n  O: Record[OrdinaryObject],\n  P: Record[Symbol] | String,\n  Receiver: ESValue,\n): Normal[ESValue] | Throw = {\n  call %0 = clo<\"OrdinaryGet\">(O, P, Receiver)\n  assert (? %0: Completion)\n  return %0\n}","def OrdinaryGet(\n  O: Record[Object],\n  P: Record[Symbol] | String,\n  Receiver: ESValue,\n): Normal[ESValue] | Throw = {\n  call %0 = O.GetOwnProperty(O, P)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let desc = %0\n  if (= desc undefined) {\n    call %1 = O.GetPrototypeOf(O)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let parent = %1\n    if (= parent null) {\n      call %2 = clo<\"NormalCompletion\">(undefined)\n      return %2\n    }\n    call %3 = parent.Get(parent, P, Receiver)\n    assert (? %3: Completion)\n    return %3\n  }\n  call %4 = clo<\"IsDataDescriptor\">(desc)\n  if (= %4 true) {\n    %5 = desc.Value\n    if (? %5: Completion) return %5\n    call %6 = clo<\"NormalCompletion\">(%5)\n    return %6\n  }\n  call %7 = clo<\"IsAccessorDescriptor\">(desc)\n  assert (= %7 true)\n  let getter = desc.Get\n  if (= getter undefined) {\n    call %8 = clo<\"NormalCompletion\">(undefined)\n    return %8\n  }\n  call %9 = clo<\"Call\">(getter, Receiver)\n  assert (? %9: Completion)\n  return %9\n}","def <INTERNAL>:Record[OrdinaryObject].Set(\n  O: Record[OrdinaryObject],\n  P: Record[Symbol] | String,\n  V: ESValue,\n  Receiver: ESValue,\n): Normal[Boolean] | Throw = {\n  call %0 = clo<\"OrdinarySet\">(O, P, V, Receiver)\n  assert (? %0: Completion)\n  return %0\n}","def OrdinarySet(\n  O: Record[Object],\n  P: Record[Symbol] | String,\n  V: ESValue,\n  Receiver: ESValue,\n): Normal[Boolean] | Throw = {\n  call %0 = O.GetOwnProperty(O, P)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let ownDesc = %0\n  call %1 = clo<\"OrdinarySetWithOwnDescriptor\">(O, P, V, Receiver, ownDesc)\n  assert (? %1: Completion)\n  return %1\n}","def OrdinarySetWithOwnDescriptor(\n  O: Record[Object],\n  P: Record[Symbol] | String,\n  V: ESValue,\n  Receiver: ESValue,\n  ownDesc: Record[PropertyDescriptor] | Undefined,\n): Normal[Boolean] | Throw = {\n  if (= ownDesc undefined) {\n    call %0 = O.GetPrototypeOf(O)\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let parent = %0\n    if (! (= parent null)) {\n      call %1 = parent.Set(parent, P, V, Receiver)\n      assert (? %1: Completion)\n      return %1\n    } else {\n      ownDesc = (record [PropertyDescriptor] {\n        \"Value\" : undefined,\n        \"Writable\" : true,\n        \"Enumerable\" : true,\n        \"Configurable\" : true,\n      })[#383]\n    }\n  }\n  call %2 = clo<\"IsDataDescriptor\">(ownDesc)\n  if (= %2 true) {\n    if (= ownDesc.Writable false) {\n      call %3 = clo<\"NormalCompletion\">(false)\n      return %3\n    }\n    if (! (? Receiver: Record[Object])) {\n      call %4 = clo<\"NormalCompletion\">(false)\n      return %4\n    }\n    call %5 = Receiver.GetOwnProperty(Receiver, P)\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n    let existingDescriptor = %5\n    if (! (= existingDescriptor undefined)) {\n      call %6 = clo<\"IsAccessorDescriptor\">(existingDescriptor)\n      if (= %6 true) {\n        call %7 = clo<\"NormalCompletion\">(false)\n        return %7\n      }\n      if (= existingDescriptor.Writable false) {\n        call %8 = clo<\"NormalCompletion\">(false)\n        return %8\n      }\n      let valueDesc = (record [PropertyDescriptor] {\n        \"Value\" : V,\n      })[#384]\n      call %9 = Receiver.DefineOwnProperty(Receiver, P, valueDesc)\n      assert (? %9: Completion)\n      return %9\n    } else {\n      assert (! (exists Receiver.__MAP__[P]))\n      call %10 = clo<\"CreateDataProperty\">(Receiver, P, V)\n      assert (? %10: Completion)\n      return %10\n    }\n  }\n  call %11 = clo<\"IsAccessorDescriptor\">(ownDesc)\n  assert (= %11 true)\n  let setter = ownDesc.Set\n  if (= setter undefined) {\n    call %12 = clo<\"NormalCompletion\">(false)\n    return %12\n  }\n  call %13 = clo<\"Call\">(setter, Receiver, (list [V])[#385])\n  assert (? %13: Completion)\n  if (? %13: Abrupt) return %13\n  else %13 = %13.Value\n  call %14 = clo<\"NormalCompletion\">(true)\n  return %14\n}","def <INTERNAL>:Record[OrdinaryObject].Delete(\n  O: Record[OrdinaryObject],\n  P: Record[Symbol] | String,\n): Normal[Boolean] | Throw = {\n  call %0 = clo<\"OrdinaryDelete\">(O, P)\n  assert (? %0: Completion)\n  return %0\n}","def OrdinaryDelete(\n  O: Record[Object],\n  P: Record[Symbol] | String,\n): Normal[Boolean] | Throw = {\n  call %0 = O.GetOwnProperty(O, P)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let desc = %0\n  if (= desc undefined) {\n    call %1 = clo<\"NormalCompletion\">(true)\n    return %1\n  }\n  if (= desc.Configurable true) {\n    delete O.__MAP__[P]\n    call %2 = clo<\"NormalCompletion\">(true)\n    return %2\n  }\n  call %3 = clo<\"NormalCompletion\">(false)\n  return %3\n}","def <INTERNAL>:Record[OrdinaryObject].OwnPropertyKeys(\n  O: Record[OrdinaryObject],\n): Normal[List[Record[Symbol] | String]] = {\n  call %0 = clo<\"OrdinaryOwnPropertyKeys\">(O)\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def OrdinaryOwnPropertyKeys(\n  O: Record[Object],\n): List[Record[Symbol] | String] = {\n  let keys = (list [])[#386]\n  %1 = (keys-int O.__MAP__)[#387]\n  %0 = 0\n  while (< %0 (sizeof %1)) {\n    let P = %1[%0]\n    call %2 = clo<\"__IS_ARRAY_INDEX__\">(P)\n    if %2 {\n      push keys < P\n    }\n    %0 = (+ %0 1)\n  }\n  %4 = (keys O.__MAP__)[#388]\n  %3 = 0\n  while (< %3 (sizeof %4)) {\n    let P = %4[%3]\n    call %5 = clo<\"__IS_ARRAY_INDEX__\">(P)\n    if (&& (? P: String) (! %5)) {\n      push keys < P\n    }\n    %3 = (+ %3 1)\n  }\n  %7 = (keys O.__MAP__)[#389]\n  %6 = 0\n  while (< %6 (sizeof %7)) {\n    let P = %7[%6]\n    if (? P: Record[Symbol]) {\n      push keys < P\n    }\n    %6 = (+ %6 1)\n  }\n  return keys\n}","def OrdinaryObjectCreate(\n  proto: Record[Object] | Null,\n  additionalInternalSlotsList?: Unknown[\"ListOfNamesOfInternalSlot\"],\n): Record[Object] = {\n  let internalSlotsList = (list [\"Prototype\", \"Extensible\"])[#390]\n  if (exists additionalInternalSlotsList) {\n    call %0 = clo<\"__FLAT_LIST__\">((list [internalSlotsList, additionalInternalSlotsList])[#391])\n    internalSlotsList = %0\n  }\n  call %1 = clo<\"MakeBasicObject\">(internalSlotsList)\n  let O = %1\n  O.Prototype = proto\n  return O\n}","def OrdinaryCreateFromConstructor(\n  constructor: Record[Constructor],\n  intrinsicDefaultProto: String,\n  internalSlotsList?: Unknown[\"ListOfNamesOfInternalSlot\"],\n): Normal[Record[Object]] | Throw = {\n  assert (yet \"_intrinsicDefaultProto_ is this specification's name of an intrinsic object. The corresponding object must be an intrinsic that is intended to be used as the [[Prototype]] value of an object.\")\n  call %0 = clo<\"GetPrototypeFromConstructor\">(constructor, intrinsicDefaultProto)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let proto = %0\n  if (exists internalSlotsList) {\n    let slotsList = internalSlotsList\n  } else {\n    let slotsList = (list [])[#392]\n  }\n  call %1 = clo<\"OrdinaryObjectCreate\">(proto, slotsList)\n  if (? %1: Completion) return %1\n  call %2 = clo<\"NormalCompletion\">(%1)\n  return %2\n}","def GetPrototypeFromConstructor(\n  constructor: Record[FunctionObject],\n  intrinsicDefaultProto: String,\n): Normal[Record[Object]] | Throw = {\n  assert (yet \"_intrinsicDefaultProto_ is this specification's name of an intrinsic object. The corresponding object must be an intrinsic that is intended to be used as the [[Prototype]] value of an object.\")\n  call %0 = clo<\"Get\">(constructor, \"prototype\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let proto = %0\n  if (! (? proto: Record[Object])) {\n    call %1 = clo<\"GetFunctionRealm\">(constructor)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let realm = %1\n    proto = realm.Intrinsics[intrinsicDefaultProto]\n  }\n  if (? proto: Completion) return proto\n  call %2 = clo<\"NormalCompletion\">(proto)\n  return %2\n}","def RequireInternalSlot(\n  O: ESValue,\n  internalSlot: String,\n): Normal[Enum[~unused~]] | Throw = {\n  if (! (? O: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  if (! (exists O[internalSlot])) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  call %4 = clo<\"NormalCompletion\">(~unused~)\n  return %4\n}","def <INTERNAL>:Record[ECMAScriptFunctionObject].Call(\n  F: Record[ECMAScriptFunctionObject],\n  thisArgument: ESValue,\n  argumentsList: List[ESValue],\n): Normal[ESValue] | Throw = {\n  let callerContext = @EXECUTION_STACK[0]\n  call %0 = clo<\"PrepareForOrdinaryCall\">(F, undefined)\n  let calleeContext = %0\n  assert (= calleeContext @EXECUTION_STACK[0])\n  if (= F.IsClassConstructor true) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    let error = %1\n    nop\n    pop %2 < @EXECUTION_STACK\n    call %3 = clo<\"ThrowCompletion\">(error)\n    if (? %3: Completion) return %3\n    call %4 = clo<\"NormalCompletion\">(%3)\n    return %4\n  }\n  call %5 = clo<\"OrdinaryCallBindThis\">(F, calleeContext, thisArgument)\n  call %6 = clo<\"OrdinaryCallEvaluateBody\">(F, argumentsList)\n  call %7 = clo<\"Completion\">(%6)\n  let result = %7\n  pop %8 < @EXECUTION_STACK\n  if (&& (? result: Completion) (= result.Type ~return~)) {\n    %9 = result.Value\n    if (? %9: Completion) return %9\n    call %10 = clo<\"NormalCompletion\">(%9)\n    return %10\n  }\n  assert (? result: Completion)\n  if (? result: Abrupt) return result\n  else result = result.Value\n  call %11 = clo<\"NormalCompletion\">(undefined)\n  return %11\n}","def PrepareForOrdinaryCall(\n  F: Record[ECMAScriptFunctionObject],\n  newTarget: Record[Object] | Undefined,\n): Record[ExecutionContext] = {\n  let callerContext = @EXECUTION_STACK[0]\n  let calleeContext = (record [ExecutionContext])[#393]\n  calleeContext.Function = F\n  let calleeRealm = F.Realm\n  calleeContext.Realm = calleeRealm\n  calleeContext.ScriptOrModule = F.ScriptOrModule\n  call %0 = clo<\"NewFunctionEnvironment\">(F, newTarget)\n  let localEnv = %0\n  calleeContext.LexicalEnvironment = localEnv\n  calleeContext.VariableEnvironment = localEnv\n  calleeContext.PrivateEnvironment = F.PrivateEnvironment\n  nop\n  push calleeContext > @EXECUTION_STACK\n  nop\n  return calleeContext\n}","def OrdinaryCallBindThis(\n  F: Record[ECMAScriptFunctionObject],\n  calleeContext: Record[ExecutionContext],\n  thisArgument: ESValue,\n): Enum[~unused~] = {\n  let thisMode = F.ThisMode\n  if (= thisMode ~lexical~) {\n    return ~unused~\n  }\n  let calleeRealm = F.Realm\n  let localEnv = calleeContext.LexicalEnvironment\n  if (= thisMode ~strict~) {\n    let thisValue = thisArgument\n  } else {\n    if (|| (= thisArgument undefined) (= thisArgument null)) {\n      let globalEnv = calleeRealm.GlobalEnv\n      assert (? globalEnv: Record[GlobalEnvironmentRecord])\n      let thisValue = globalEnv.GlobalThisValue\n    } else {\n      call %0 = clo<\"ToObject\">(thisArgument)\n      assert (? %0: Normal)\n      %0 = %0.Value\n      let thisValue = %0\n      nop\n    }\n  }\n  assert (? localEnv: Record[FunctionEnvironmentRecord])\n  assert (yet \"The next step never returns an abrupt completion because _localEnv_.[[ThisBindingStatus]] is not ~initialized~.\")\n  call %1 = localEnv.BindThisValue(localEnv, thisValue)\n  assert (? %1: Normal)\n  %1 = %1.Value\n  return ~unused~\n}","def <SYNTAX>:FunctionBody[0,0].EvaluateBody(\n  this: Ast[FunctionBody[0]],\n  functionObject: Record[ECMAScriptFunctionObject],\n  argumentsList: List[ESValue],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this->EvaluateFunctionBody(functionObject, argumentsList)\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:ConciseBody[0,0].EvaluateBody(\n  this: Ast[ConciseBody[0]],\n  functionObject: Record[ECMAScriptFunctionObject],\n  argumentsList: List[ESValue],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this->EvaluateConciseBody(functionObject, argumentsList)\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:GeneratorBody[0,0].EvaluateBody(\n  this: Ast[GeneratorBody[0]],\n  functionObject: Record[ECMAScriptFunctionObject],\n  argumentsList: List[ESValue],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this->EvaluateGeneratorBody(functionObject, argumentsList)\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:AsyncGeneratorBody[0,0].EvaluateBody(\n  this: Ast[AsyncGeneratorBody[0]],\n  functionObject: Record[ECMAScriptFunctionObject],\n  argumentsList: List[ESValue],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this->EvaluateAsyncGeneratorBody(functionObject, argumentsList)\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:AsyncFunctionBody[0,0].EvaluateBody(\n  this: Ast[AsyncFunctionBody[0]],\n  functionObject: Record[ECMAScriptFunctionObject],\n  argumentsList: List[ESValue],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this->EvaluateAsyncFunctionBody(functionObject, argumentsList)\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:AsyncConciseBody[0,0].EvaluateBody(\n  this: Ast[AsyncConciseBody[0]],\n  functionObject: Record[ECMAScriptFunctionObject],\n  argumentsList: List[ESValue],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this->EvaluateAsyncConciseBody(functionObject, argumentsList)\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:Initializer[0,0].EvaluateBody(\n  this: Ast[Initializer[0]],\n  functionObject: Record[ECMAScriptFunctionObject],\n  argumentsList: List[ESValue],\n): Normal[ESValue] | Abrupt = {\n  assert (= (sizeof argumentsList) 0)\n  assert (! (= functionObject.ClassFieldInitializerName ~empty~))\n  call %0 = clo<\"IsAnonymousFunctionDefinition\">(this[0])\n  if (= %0 true) {\n    sdo-call %1 = this->NamedEvaluation(functionObject.ClassFieldInitializerName)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let value = %1\n  } else {\n    sdo-call %2 = this[0]->Evaluation()\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let rhs = %2\n    call %3 = clo<\"GetValue\">(rhs)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let value = %3\n  }\n  %4 = (record [CompletionRecord] {\n    \"Type\" : ~return~,\n    \"Value\" : value,\n    \"Target\" : ~empty~,\n  })[#394]\n  if (? %4: Completion) return %4\n  call %5 = clo<\"NormalCompletion\">(%4)\n  return %5\n}","def <SYNTAX>:ClassStaticBlockBody[0,0].EvaluateBody(\n  this: Ast[ClassStaticBlockBody[0]],\n  functionObject: Record[ECMAScriptFunctionObject],\n  argumentsList: List[ESValue],\n): Normal[ESValue] | Abrupt = {\n  assert (= (sizeof argumentsList) 0)\n  sdo-call %0 = this->EvaluateClassStaticBlockBody(functionObject)\n  assert (? %0: Completion)\n  return %0\n}","def OrdinaryCallEvaluateBody(\n  F: Record[ECMAScriptFunctionObject],\n  argumentsList: List[ESValue],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = F.ECMAScriptCode->EvaluateBody(F, argumentsList)\n  assert (? %0: Completion)\n  return %0\n}","def <INTERNAL>:Record[ECMAScriptFunctionObject].Construct(\n  F: Record[ECMAScriptFunctionObject],\n  argumentsList: List[ESValue],\n  newTarget: Record[Constructor],\n): Normal[Record[Object]] | Throw = {\n  let callerContext = @EXECUTION_STACK[0]\n  let kind = F.ConstructorKind\n  if (= kind ~base~) {\n    call %0 = clo<\"OrdinaryCreateFromConstructor\">(newTarget, \"%Object.prototype%\")\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let thisArgument = %0\n  }\n  call %1 = clo<\"PrepareForOrdinaryCall\">(F, newTarget)\n  let calleeContext = %1\n  assert (= calleeContext @EXECUTION_STACK[0])\n  if (= kind ~base~) {\n    call %2 = clo<\"OrdinaryCallBindThis\">(F, calleeContext, thisArgument)\n    call %3 = clo<\"InitializeInstanceElements\">(thisArgument, F)\n    call %4 = clo<\"Completion\">(%3)\n    let initializeResult = %4\n    if (&& (? initializeResult: Completion) (! (= initializeResult.Type ~normal~))) {\n      pop %5 < @EXECUTION_STACK\n      assert (? initializeResult: Completion)\n      return initializeResult\n    }\n  }\n  let constructorEnv = calleeContext.LexicalEnvironment\n  call %6 = clo<\"OrdinaryCallEvaluateBody\">(F, argumentsList)\n  call %7 = clo<\"Completion\">(%6)\n  let result = %7\n  pop %8 < @EXECUTION_STACK\n  if (&& (? result: Completion) (= result.Type ~return~)) {\n    if (? result.Value: Record[Object]) {\n      %9 = result.Value\n      if (? %9: Completion) return %9\n      call %10 = clo<\"NormalCompletion\">(%9)\n      return %10\n    }\n    if (= kind ~base~) {\n      if (? thisArgument: Completion) return thisArgument\n      call %11 = clo<\"NormalCompletion\">(thisArgument)\n      return %11\n    }\n    if (! (= result.Value undefined)) {\n      call %12 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %13 = clo<\"ThrowCompletion\">(%12)\n      return %13\n    }\n  } else {\n    assert (? result: Completion)\n    if (? result: Abrupt) return result\n    else result = result.Value\n  }\n  call %14 = constructorEnv.GetThisBinding(constructorEnv)\n  assert (? %14: Completion)\n  if (? %14: Abrupt) return %14\n  else %14 = %14.Value\n  let thisBinding = %14\n  assert (? thisBinding: Record[Object])\n  if (? thisBinding: Completion) return thisBinding\n  call %15 = clo<\"NormalCompletion\">(thisBinding)\n  return %15\n}","def OrdinaryFunctionCreate(\n  functionPrototype: Record[Object],\n  sourceText: Unknown[\"SequenceOfUnicodeCodePoint\"],\n  ParameterList: Ast,\n  Body: Ast,\n  thisMode: Enum[~lexical-this~, ~non-lexical-this~],\n  env: Record[EnvironmentRecord],\n  privateEnv: Record[PrivateEnvironmentRecord] | Null,\n): Record[ECMAScriptFunctionObject] = {\n  let internalSlotsList = (list [\"Environment\", \"PrivateEnvironment\", \"FormalParameters\", \"ECMAScriptCode\", \"ConstructorKind\", \"Realm\", \"ScriptOrModule\", \"ThisMode\", \"Strict\", \"HomeObject\", \"SourceText\", \"Fields\", \"PrivateMethods\", \"ClassFieldInitializerName\", \"IsClassConstructor\"])[#395]\n  call %0 = clo<\"OrdinaryObjectCreate\">(functionPrototype, internalSlotsList)\n  let F = %0\n  F.Call = clo<\"Record[ECMAScriptFunctionObject].Call\">\n  F.SourceText = sourceText\n  F.FormalParameters = ParameterList\n  F.ECMAScriptCode = Body\n  if true {\n    let Strict = true\n  } else {\n    let Strict = false\n  }\n  F.Strict = Strict\n  if (= thisMode ~lexical-this~) {\n    F.ThisMode = ~lexical~\n  } else {\n    if (= Strict true) {\n      F.ThisMode = ~strict~\n    } else {\n      F.ThisMode = ~global~\n    }\n  }\n  F.IsClassConstructor = false\n  F.Environment = env\n  F.PrivateEnvironment = privateEnv\n  call %1 = clo<\"GetActiveScriptOrModule\">()\n  F.ScriptOrModule = %1\n  F.Realm = @EXECUTION_STACK[0].Realm\n  F.HomeObject = undefined\n  F.Fields = (list [])[#396]\n  F.PrivateMethods = (list [])[#397]\n  F.ClassFieldInitializerName = ~empty~\n  sdo-call %2 = ParameterList->ExpectedArgumentCount()\n  let len = %2\n  call %3 = clo<\"SetFunctionLength\">(F, len)\n  return F\n}","def AddRestrictedFunctionProperties(\n  F: Record[FunctionObject],\n  realm: Record[RealmRecord],\n): Enum[~unused~] = {\n  assert (exists realm.Intrinsics[\"%ThrowTypeError%\"])\n  let thrower = realm.Intrinsics[\"%ThrowTypeError%\"]\n  call %0 = clo<\"DefinePropertyOrThrow\">(F, \"caller\", (record [PropertyDescriptor] {\n    \"Get\" : thrower,\n    \"Set\" : thrower,\n    \"Enumerable\" : false,\n    \"Configurable\" : true,\n  })[#398])\n  assert (? %0: Normal)\n  %0 = %0.Value\n  call %1 = clo<\"DefinePropertyOrThrow\">(F, \"arguments\", (record [PropertyDescriptor] {\n    \"Get\" : thrower,\n    \"Set\" : thrower,\n    \"Enumerable\" : false,\n    \"Configurable\" : true,\n  })[#399])\n  assert (? %1: Normal)\n  %1 = %1.Value\n  return ~unused~\n}","def <BUILTIN>:INTRINSICS.ThrowTypeError(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#400]\n  call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n  call %1 = clo<\"ThrowCompletion\">(%0)\n  return %1\n}","def MakeConstructor(\n  F: Record[BuiltinFunctionObject | ECMAScriptFunctionObject],\n  writablePrototype?: Boolean,\n  prototype?: Record[Object],\n): Enum[~unused~] = {\n  if (? F: Record[ECMAScriptFunctionObject]) {\n    call %0 = clo<\"IsConstructor\">(F)\n    assert (= %0 false)\n    assert (&& F.Extensible (! (exists F.__MAP__.prototype)))\n    F.Construct = clo<\"Record[ECMAScriptFunctionObject].Construct\">\n  } else {\n    F.Construct = clo<\"Record[BuiltinFunctionObject].Construct\">\n  }\n  F.ConstructorKind = ~base~\n  if (! (exists writablePrototype)) {\n    writablePrototype = true\n  }\n  if (! (exists prototype)) {\n    call %1 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Object.prototype%\"])\n    prototype = %1\n    call %2 = clo<\"DefinePropertyOrThrow\">(prototype, \"constructor\", (record [PropertyDescriptor] {\n      \"Value\" : F,\n      \"Writable\" : writablePrototype,\n      \"Enumerable\" : false,\n      \"Configurable\" : true,\n    })[#401])\n    assert (? %2: Normal)\n    %2 = %2.Value\n  }\n  call %3 = clo<\"DefinePropertyOrThrow\">(F, \"prototype\", (record [PropertyDescriptor] {\n    \"Value\" : prototype,\n    \"Writable\" : writablePrototype,\n    \"Enumerable\" : false,\n    \"Configurable\" : false,\n  })[#402])\n  assert (? %3: Normal)\n  %3 = %3.Value\n  return ~unused~\n}","def MakeClassConstructor(\n  F: Record[ECMAScriptFunctionObject],\n): Enum[~unused~] = {\n  assert (= F.IsClassConstructor false)\n  F.IsClassConstructor = true\n  return ~unused~\n}","def MakeMethod(\n  F: Record[ECMAScriptFunctionObject],\n  homeObject: Record[Object],\n): Enum[~unused~] = {\n  F.HomeObject = homeObject\n  return ~unused~\n}","def DefineMethodProperty(\n  homeObject: Record[Object],\n  key: Record[PrivateName | Symbol] | String,\n  closure: Record[FunctionObject],\n  enumerable: Boolean,\n): Normal[Record[PrivateElement] | Enum[~unused~]] | Abrupt = {\n  assert (yet \"_homeObject_ is an ordinary, extensible object.\")\n  if (? key: Record[PrivateName]) {\n    %0 = (record [PrivateElement] {\n      \"Key\" : key,\n      \"Kind\" : ~method~,\n      \"Value\" : closure,\n    })[#403]\n    if (? %0: Completion) return %0\n    call %1 = clo<\"NormalCompletion\">(%0)\n    return %1\n  } else {\n    let desc = (record [PropertyDescriptor] {\n      \"Value\" : closure,\n      \"Writable\" : true,\n      \"Enumerable\" : enumerable,\n      \"Configurable\" : true,\n    })[#404]\n    call %2 = clo<\"DefinePropertyOrThrow\">(homeObject, key, desc)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    nop\n    call %3 = clo<\"NormalCompletion\">(~unused~)\n    return %3\n  }\n}","def SetFunctionName(\n  F: Record[FunctionObject],\n  name: Record[PrivateName | Symbol] | String,\n  prefix?: String,\n): Enum[~unused~] = {\n  assert (&& F.Extensible (! (exists F.__MAP__.name)))\n  if (? name: Record[Symbol]) {\n    let description = name.Description\n    if (= description undefined) {\n      name = \"\"\n    } else {\n      name = (concat \"[\" description \"]\")\n    }\n  } else {\n    if (? name: Record[PrivateName]) {\n      name = name.Description\n    }\n  }\n  if (exists F.InitialName) {\n    F.InitialName = name\n  }\n  if (exists prefix) {\n    name = (concat prefix 32cu name)\n    if (exists F.InitialName) {\n      (yet \"Optionally, set _F_.[[InitialName]] to _name_.\")\n    }\n  }\n  call %0 = clo<\"DefinePropertyOrThrow\">(F, \"name\", (record [PropertyDescriptor] {\n    \"Value\" : name,\n    \"Writable\" : false,\n    \"Enumerable\" : false,\n    \"Configurable\" : true,\n  })[#405])\n  assert (? %0: Normal)\n  %0 = %0.Value\n  return ~unused~\n}","def SetFunctionLength(\n  F: Record[FunctionObject],\n  length: NonNegInt | +INF,\n): Enum[~unused~] = {\n  assert (&& F.Extensible (! (exists F.__MAP__.length)))\n  call %0 = clo<\"DefinePropertyOrThrow\">(F, \"length\", (record [PropertyDescriptor] {\n    \"Value\" : ([number] length),\n    \"Writable\" : false,\n    \"Enumerable\" : false,\n    \"Configurable\" : true,\n  })[#406])\n  assert (? %0: Normal)\n  %0 = %0.Value\n  return ~unused~\n}","def FunctionDeclarationInstantiation(\n  func: Record[ECMAScriptFunctionObject],\n  argumentsList: List[ESValue],\n): Normal[Enum[~unused~]] | Abrupt = {\n  let calleeContext = @EXECUTION_STACK[0]\n  let code = func.ECMAScriptCode\n  let strict = func.Strict\n  let formals = func.FormalParameters\n  sdo-call %0 = formals->BoundNames()\n  let parameterNames = %0\n  call %1 = clo<\"__HAS_DUPLICATE__\">(parameterNames)\n  if %1 {\n    let hasDuplicates = true\n  } else {\n    let hasDuplicates = false\n  }\n  sdo-call %2 = formals->IsSimpleParameterList()\n  let simpleParameterList = %2\n  sdo-call %3 = formals->ContainsExpression()\n  let hasParameterExpressions = %3\n  sdo-call %4 = code->VarDeclaredNames()\n  let varNames = %4\n  sdo-call %5 = code->VarScopedDeclarations()\n  let varDeclarations = %5\n  sdo-call %6 = code->LexicallyDeclaredNames()\n  let lexicalNames = %6\n  let functionNames = (list [])[#407]\n  let functionsToInitialize = (list [])[#408]\n  %8 = varDeclarations\n  %7 = (sizeof %8)\n  while (< 0 %7) {\n    %7 = (- %7 1)\n    let d = %8[%7]\n    if (! (|| (|| (? d: Ast[VariableDeclaration]) (? d: Ast[ForBinding])) (? d: Ast[BindingIdentifier]))) {\n      assert (? d: Ast[AsyncFunctionDeclaration | AsyncGeneratorDeclaration | FunctionDeclaration | GeneratorDeclaration])\n      sdo-call %9 = d->BoundNames()\n      let fn = %9[0]\n      if (! (contains functionNames fn)) {\n        push fn > functionNames\n        nop\n        push d > functionsToInitialize\n      }\n    }\n  }\n  let argumentsObjectNeeded = true\n  if (= func.ThisMode ~lexical~) {\n    nop\n    argumentsObjectNeeded = false\n  } else {\n    if (contains parameterNames \"arguments\") {\n      argumentsObjectNeeded = false\n    } else {\n      if (= hasParameterExpressions false) {\n        if (|| (contains functionNames \"arguments\") (contains lexicalNames \"arguments\")) {\n          argumentsObjectNeeded = false\n        }\n      }\n    }\n  }\n  if (|| (= strict true) (= hasParameterExpressions false)) {\n    nop\n    let env = calleeContext.LexicalEnvironment\n  } else {\n    nop\n    let calleeEnv = calleeContext.LexicalEnvironment\n    call %10 = clo<\"NewDeclarativeEnvironment\">(calleeEnv)\n    let env = %10\n    assert (= calleeContext.VariableEnvironment calleeEnv)\n    calleeContext.LexicalEnvironment = env\n  }\n  %12 = parameterNames\n  %11 = 0\n  while (< %11 (sizeof %12)) {\n    let paramName = %12[%11]\n    if (? paramName: String) {\n      call %13 = env.HasBinding(env, paramName)\n      assert (? %13: Normal)\n      %13 = %13.Value\n      let alreadyDeclared = %13\n      nop\n      if (= alreadyDeclared false) {\n        call %14 = env.CreateMutableBinding(env, paramName, false)\n        assert (? %14: Normal)\n        %14 = %14.Value\n        if (= hasDuplicates true) {\n          call %15 = env.InitializeBinding(env, paramName, undefined)\n          assert (? %15: Normal)\n          %15 = %15.Value\n        }\n      }\n    }\n    %11 = (+ %11 1)\n  }\n  if (= argumentsObjectNeeded true) {\n    if (|| (= strict true) (= simpleParameterList false)) {\n      call %16 = clo<\"CreateUnmappedArgumentsObject\">(argumentsList)\n      let ao = %16\n    } else {\n      nop\n      call %17 = clo<\"CreateMappedArgumentsObject\">(func, formals, argumentsList, env)\n      let ao = %17\n    }\n    if (= strict true) {\n      call %18 = env.CreateImmutableBinding(env, \"arguments\", false)\n      assert (? %18: Normal)\n      %18 = %18.Value\n      nop\n    } else {\n      call %19 = env.CreateMutableBinding(env, \"arguments\", false)\n      assert (? %19: Normal)\n      %19 = %19.Value\n    }\n    call %20 = env.InitializeBinding(env, \"arguments\", ao)\n    assert (? %20: Normal)\n    %20 = %20.Value\n    call %21 = clo<\"__FLAT_LIST__\">((list [parameterNames, (list [\"arguments\"])[#410]])[#409])\n    let parameterBindings = %21\n  } else {\n    let parameterBindings = parameterNames\n  }\n  call %22 = clo<\"CreateListIteratorRecord\">(argumentsList)\n  let iteratorRecord = %22\n  if (= hasDuplicates true) {\n    sdo-call %23 = formals->IteratorBindingInitialization(iteratorRecord, undefined)\n    assert (? %23: Completion)\n    if (? %23: Abrupt) return %23\n    else %23 = %23.Value\n  } else {\n    sdo-call %24 = formals->IteratorBindingInitialization(iteratorRecord, env)\n    assert (? %24: Completion)\n    if (? %24: Abrupt) return %24\n    else %24 = %24.Value\n  }\n  if (= hasParameterExpressions false) {\n    nop\n    let instantiatedVarNames = (copy parameterBindings)[#411]\n    %26 = varNames\n    %25 = 0\n    while (< %25 (sizeof %26)) {\n      let n = %26[%25]\n      if (! (contains instantiatedVarNames n)) {\n        push instantiatedVarNames < n\n        call %27 = env.CreateMutableBinding(env, n, false)\n        assert (? %27: Normal)\n        %27 = %27.Value\n        call %28 = env.InitializeBinding(env, n, undefined)\n        assert (? %28: Normal)\n        %28 = %28.Value\n      }\n      %25 = (+ %25 1)\n    }\n    let varEnv = env\n  } else {\n    nop\n    call %29 = clo<\"NewDeclarativeEnvironment\">(env)\n    let varEnv = %29\n    calleeContext.VariableEnvironment = varEnv\n    let instantiatedVarNames = (list [])[#412]\n    %31 = varNames\n    %30 = 0\n    while (< %30 (sizeof %31)) {\n      let n = %31[%30]\n      if (! (contains instantiatedVarNames n)) {\n        push instantiatedVarNames < n\n        call %32 = varEnv.CreateMutableBinding(varEnv, n, false)\n        assert (? %32: Normal)\n        %32 = %32.Value\n        if (|| (! (contains parameterBindings n)) (contains functionNames n)) {\n          let initialValue = undefined\n        } else {\n          call %33 = env.GetBindingValue(env, n, false)\n          assert (? %33: Normal)\n          %33 = %33.Value\n          let initialValue = %33\n        }\n        call %34 = varEnv.InitializeBinding(varEnv, n, initialValue)\n        assert (? %34: Normal)\n        %34 = %34.Value\n        nop\n      }\n      %30 = (+ %30 1)\n    }\n  }\n  nop\n  if (= strict false) {\n    call %35 = clo<\"NewDeclarativeEnvironment\">(varEnv)\n    let lexEnv = %35\n    nop\n  } else {\n    let lexEnv = varEnv\n  }\n  calleeContext.LexicalEnvironment = lexEnv\n  sdo-call %36 = code->LexicallyScopedDeclarations()\n  let lexDeclarations = %36\n  %38 = lexDeclarations\n  %37 = 0\n  while (< %37 (sizeof %38)) {\n    let d = %38[%37]\n    nop\n    sdo-call %41 = d->BoundNames()\n    %40 = %41\n    %39 = 0\n    while (< %39 (sizeof %40)) {\n      let dn = %40[%39]\n      sdo-call %42 = d->IsConstantDeclaration()\n      if (= %42 true) {\n        call %43 = lexEnv.CreateImmutableBinding(lexEnv, dn, true)\n        assert (? %43: Normal)\n        %43 = %43.Value\n      } else {\n        call %44 = lexEnv.CreateMutableBinding(lexEnv, dn, false)\n        assert (? %44: Normal)\n        %44 = %44.Value\n      }\n      %39 = (+ %39 1)\n    }\n    %37 = (+ %37 1)\n  }\n  let privateEnv = calleeContext.PrivateEnvironment\n  %46 = functionsToInitialize\n  %45 = 0\n  while (< %45 (sizeof %46)) {\n    let f = %46[%45]\n    if (? f: Ast) {\n      sdo-call %47 = f->BoundNames()\n      let fn = %47[0]\n      sdo-call %48 = f->InstantiateFunctionObject(lexEnv, privateEnv)\n      let fo = %48\n      call %49 = varEnv.SetMutableBinding(varEnv, fn, fo, false)\n      assert (? %49: Normal)\n      %49 = %49.Value\n    }\n    %45 = (+ %45 1)\n  }\n  call %50 = clo<\"NormalCompletion\">(~unused~)\n  return %50\n}","def <INTERNAL>:Record[BuiltinFunctionObject].Call(\n  F: Record[BuiltinFunctionObject],\n  thisArgument: ESValue,\n  argumentsList: List[ESValue],\n): Normal[ESValue] | Throw = {\n  call %0 = clo<\"BuiltinCallOrConstruct\">(F, thisArgument, argumentsList, undefined)\n  assert (? %0: Completion)\n  return %0\n}","def <INTERNAL>:Record[BuiltinFunctionObject].Construct(\n  F: Record[BuiltinFunctionObject],\n  argumentsList: List[ESValue],\n  newTarget: Record[Constructor],\n): Normal[Record[Object]] | Throw = {\n  call %0 = clo<\"BuiltinCallOrConstruct\">(F, ~uninitialized~, argumentsList, newTarget)\n  assert (? %0: Completion)\n  return %0\n}","def BuiltinCallOrConstruct(\n  F: Record[BuiltinFunctionObject],\n  thisArgument: ESValue | Enum[~uninitialized~],\n  argumentsList: List[ESValue],\n  newTarget: Record[Constructor] | Undefined,\n): Normal[ESValue] | Throw = {\n  let callerContext = @EXECUTION_STACK[0]\n  nop\n  let calleeContext = (record [ExecutionContext])[#413]\n  calleeContext.Function = F\n  let calleeRealm = F.Realm\n  calleeContext.Realm = calleeRealm\n  calleeContext.ScriptOrModule = null\n  nop\n  push calleeContext > @EXECUTION_STACK\n  if (= thisArgument ~uninitialized~) call result = F.__CODE__(undefined, argumentsList, newTarget)\n  else call result = F.__CODE__(thisArgument, argumentsList, undefined)\n  nop\n  pop %0 < @EXECUTION_STACK\n  assert (? result: Completion)\n  return result\n}","def CreateBuiltinFunction(\n  behaviour: Unknown[\"AbstractClosure,ASetOfAlgorithmSteps,OrSomeOtherDefinitionOfAFunction'sBehaviourProvidedInThisSpecification\"],\n  length: NonNegInt | +INF,\n  name: Record[PrivateName | Symbol] | String,\n  additionalInternalSlotsList: Unknown[\"ListOfNamesOfInternalSlot\"],\n  realm?: Record[RealmRecord],\n  prototype?: Record[Object] | Null,\n  prefix?: String,\n): Record[FunctionObject] = {\n  if (! (exists realm)) {\n    realm = @EXECUTION_STACK[0].Realm\n  }\n  if (! (exists prototype)) {\n    prototype = realm.Intrinsics[\"%Function.prototype%\"]\n  }\n  let internalSlotsList = (list [\"Prototype\", \"Extensible\", \"Realm\", \"InitialName\"])[#414]\n  call interanlSlotsList = clo<\"__APPEND_LIST__\">(internalSlotsList, additionalInternalSlotsList)\n  call func = clo<\"__NEW_OBJ__\">()\n  func.Call = clo<\"Record[BuiltinFunctionObject].Call\">\n  func.__CODE__ = behaviour\n  func.Prototype = prototype\n  func.Extensible = true\n  func.Realm = realm\n  func.InitialName = null\n  call %0 = clo<\"SetFunctionLength\">(func, length)\n  if (! (exists prefix)) {\n    call %1 = clo<\"SetFunctionName\">(func, name)\n  } else {\n    call %2 = clo<\"SetFunctionName\">(func, name, prefix)\n  }\n  return func\n}","def <INTERNAL>:Record[BoundFunctionExoticObject].Call(\n  F: Record[BoundFunctionExoticObject],\n  thisArgument: ESValue,\n  argumentsList: List[ESValue],\n): Normal[ESValue] | Throw = {\n  let target = F.BoundTargetFunction\n  let boundThis = F.BoundThis\n  let boundArgs = F.BoundArguments\n  call %0 = clo<\"__FLAT_LIST__\">((list [boundArgs, argumentsList])[#415])\n  let args = %0\n  call %1 = clo<\"Call\">(target, boundThis, args)\n  assert (? %1: Completion)\n  return %1\n}","def <INTERNAL>:Record[BoundFunctionExoticObject].Construct(\n  F: Record[BoundFunctionExoticObject],\n  argumentsList: List[ESValue],\n  newTarget: Record[Constructor],\n): Normal[Record[Object]] | Throw = {\n  let target = F.BoundTargetFunction\n  call %0 = clo<\"IsConstructor\">(target)\n  assert (= %0 true)\n  let boundArgs = F.BoundArguments\n  call %1 = clo<\"__FLAT_LIST__\">((list [boundArgs, argumentsList])[#416])\n  let args = %1\n  call %2 = clo<\"SameValue\">(F, newTarget)\n  if (= %2 true) {\n    newTarget = target\n  }\n  call %3 = clo<\"Construct\">(target, args, newTarget)\n  assert (? %3: Completion)\n  return %3\n}","def BoundFunctionCreate(\n  targetFunction: Record[FunctionObject],\n  boundThis: ESValue,\n  boundArgs: List[ESValue],\n): Normal[Record[FunctionObject]] | Throw = {\n  call %0 = targetFunction.GetPrototypeOf(targetFunction)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let proto = %0\n  call %1 = clo<\"__FLAT_LIST__\">((list [(list [\"Prototype\", \"Extensible\"])[#418], (list [\"BoundTargetFunction\", \"BoundThis\", \"BoundArguments\"])[#419]])[#417])\n  let internalSlotsList = %1\n  call %2 = clo<\"MakeBasicObject\">(internalSlotsList)\n  let obj = %2\n  obj.Prototype = proto\n  obj.Call = clo<\"Record[BoundFunctionExoticObject].Call\">\n  call %3 = clo<\"IsConstructor\">(targetFunction)\n  if (= %3 true) {\n    obj.Construct = clo<\"Record[BoundFunctionExoticObject].Construct\">\n  }\n  obj.BoundTargetFunction = targetFunction\n  obj.BoundThis = boundThis\n  obj.BoundArguments = boundArgs\n  if (? obj: Completion) return obj\n  call %4 = clo<\"NormalCompletion\">(obj)\n  return %4\n}","def <INTERNAL>:Record[Array].DefineOwnProperty(\n  A: Record[Array],\n  P: Record[Symbol] | String,\n  Desc: Record[PropertyDescriptor],\n): Normal[Boolean] | Throw = {\n  if (= P \"length\") {\n    call %0 = clo<\"ArraySetLength\">(A, Desc)\n    assert (? %0: Completion)\n    return %0\n  } else {\n    call %1 = clo<\"__IS_ARRAY_INDEX__\">(P)\n    if %1 {\n      call %2 = clo<\"OrdinaryGetOwnProperty\">(A, \"length\")\n      let lengthDesc = %2\n      call %3 = clo<\"IsDataDescriptor\">(lengthDesc)\n      assert (= %3 true)\n      assert (= lengthDesc.Configurable false)\n      let length = lengthDesc.Value\n      assert (? length: Number[NonNegInt])\n      call %4 = clo<\"ToUint32\">(P)\n      assert (? %4: Normal)\n      %4 = %4.Value\n      let index = %4\n      if (&& (! (< index length)) (= lengthDesc.Writable false)) {\n        call %5 = clo<\"NormalCompletion\">(false)\n        return %5\n      }\n      call %6 = clo<\"OrdinaryDefineOwnProperty\">(A, P, Desc)\n      assert (? %6: Normal)\n      %6 = %6.Value\n      let succeeded = %6\n      if (= succeeded false) {\n        call %7 = clo<\"NormalCompletion\">(false)\n        return %7\n      }\n      if (! (< index length)) {\n        lengthDesc.Value = (+ index 1.0f)\n        call %8 = clo<\"OrdinaryDefineOwnProperty\">(A, \"length\", lengthDesc)\n        assert (? %8: Normal)\n        %8 = %8.Value\n        succeeded = %8\n        assert (= succeeded true)\n      }\n      call %9 = clo<\"NormalCompletion\">(true)\n      return %9\n    }\n  }\n  call %10 = clo<\"OrdinaryDefineOwnProperty\">(A, P, Desc)\n  assert (? %10: Completion)\n  return %10\n}","def ArrayCreate(\n  length: NonNegInt,\n  proto?: Record[Object],\n): Normal[Record[Array]] | Throw = {\n  if (< (- (** 2 32) 1) length) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  if (! (exists proto)) {\n    proto = @EXECUTION_STACK[0].Realm.Intrinsics[\"%Array.prototype%\"]\n  }\n  call %2 = clo<\"MakeBasicObject\">((list [\"Prototype\", \"Extensible\"])[#420])\n  let A = %2\n  A.Prototype = proto\n  A.DefineOwnProperty = clo<\"Record[Array].DefineOwnProperty\">\n  call %3 = clo<\"OrdinaryDefineOwnProperty\">(A, \"length\", (record [PropertyDescriptor] {\n    \"Value\" : ([number] length),\n    \"Writable\" : true,\n    \"Enumerable\" : false,\n    \"Configurable\" : false,\n  })[#421])\n  assert (? %3: Normal)\n  %3 = %3.Value\n  if (? A: Completion) return A\n  call %4 = clo<\"NormalCompletion\">(A)\n  return %4\n}","def ArraySpeciesCreate(\n  originalArray: Record[Object],\n  length: NonNegInt,\n): Normal[Record[Object]] | Throw = {\n  call %0 = clo<\"IsArray\">(originalArray)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let isArray = %0\n  if (= isArray false) {\n    call %1 = clo<\"ArrayCreate\">(length)\n    assert (? %1: Completion)\n    return %1\n  }\n  call %2 = clo<\"Get\">(originalArray, \"constructor\")\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let C = %2\n  call %3 = clo<\"IsConstructor\">(C)\n  if (= %3 true) {\n    let thisRealm = @EXECUTION_STACK[0].Realm\n    call %4 = clo<\"GetFunctionRealm\">(C)\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    let realmC = %4\n    if (! (= thisRealm realmC)) {\n      call %5 = clo<\"SameValue\">(C, realmC.Intrinsics[\"%Array%\"])\n      if (= %5 true) {\n        C = undefined\n      }\n    }\n  }\n  if (? C: Record[Object]) {\n    call %6 = clo<\"Get\">(C, @SYMBOL.species)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    C = %6\n    if (= C null) {\n      C = undefined\n    }\n  }\n  if (= C undefined) {\n    call %7 = clo<\"ArrayCreate\">(length)\n    assert (? %7: Completion)\n    return %7\n  }\n  call %8 = clo<\"IsConstructor\">(C)\n  if (= %8 false) {\n    call %9 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %10 = clo<\"ThrowCompletion\">(%9)\n    return %10\n  }\n  call %11 = clo<\"Construct\">(C, (list [([number] length)])[#422])\n  assert (? %11: Completion)\n  return %11\n}","def ArraySetLength(\n  A: Record[Array],\n  Desc: Record[PropertyDescriptor],\n): Normal[Boolean] | Throw = {\n  if (! (exists Desc.Value)) {\n    call %0 = clo<\"OrdinaryDefineOwnProperty\">(A, \"length\", Desc)\n    assert (? %0: Normal)\n    return %0\n  }\n  let newLenDesc = (copy Desc)[#423]\n  call %1 = clo<\"ToUint32\">(Desc.Value)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let newLen = %1\n  call %2 = clo<\"ToNumber\">(Desc.Value)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let numberLen = %2\n  call %3 = clo<\"SameValueZero\">(newLen, numberLen)\n  if (= %3 false) {\n    call %4 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %5 = clo<\"ThrowCompletion\">(%4)\n    return %5\n  }\n  newLenDesc.Value = newLen\n  call %6 = clo<\"OrdinaryGetOwnProperty\">(A, \"length\")\n  let oldLenDesc = %6\n  call %7 = clo<\"IsDataDescriptor\">(oldLenDesc)\n  assert (= %7 true)\n  assert (= oldLenDesc.Configurable false)\n  let oldLen = oldLenDesc.Value\n  if (! (< newLen oldLen)) {\n    call %8 = clo<\"OrdinaryDefineOwnProperty\">(A, \"length\", newLenDesc)\n    assert (? %8: Normal)\n    return %8\n  }\n  if (= oldLenDesc.Writable false) {\n    call %9 = clo<\"NormalCompletion\">(false)\n    return %9\n  }\n  if (|| (! (exists newLenDesc.Writable)) (= newLenDesc.Writable true)) {\n    let newWritable = true\n  } else {\n    nop\n    let newWritable = false\n    newLenDesc.Writable = true\n  }\n  call %10 = clo<\"OrdinaryDefineOwnProperty\">(A, \"length\", newLenDesc)\n  assert (? %10: Normal)\n  %10 = %10.Value\n  let succeeded = %10\n  if (= succeeded false) {\n    call %11 = clo<\"NormalCompletion\">(false)\n    return %11\n  }\n  %13 = (keys-int A.__MAP__)[#424]\n  %12 = (sizeof %13)\n  while (< 0 %12) {\n    %12 = (- %12 1)\n    let P = %13[%12]\n    call %14 = clo<\"__IS_ARRAY_INDEX__\">(P)\n    call %15 = clo<\"ToUint32\">(P)\n    assert (? %15: Normal)\n    %15 = %15.Value\n    if (&& %14 (! (< %15 newLen))) {\n      call %16 = A.Delete(A, P)\n      assert (? %16: Normal)\n      %16 = %16.Value\n      let deleteSucceeded = %16\n      if (= deleteSucceeded false) {\n        call %17 = clo<\"ToUint32\">(P)\n        assert (? %17: Normal)\n        %17 = %17.Value\n        newLenDesc.Value = (+ %17 1.0f)\n        if (= newWritable false) {\n          newLenDesc.Writable = false\n        }\n        call %18 = clo<\"OrdinaryDefineOwnProperty\">(A, \"length\", newLenDesc)\n        assert (? %18: Normal)\n        %18 = %18.Value\n        call %19 = clo<\"NormalCompletion\">(false)\n        return %19\n      }\n    }\n  }\n  if (= newWritable false) {\n    call %20 = clo<\"OrdinaryDefineOwnProperty\">(A, \"length\", (record [PropertyDescriptor] {\n      \"Writable\" : false,\n    })[#425])\n    assert (? %20: Normal)\n    %20 = %20.Value\n    succeeded = %20\n    assert (= succeeded true)\n  }\n  call %21 = clo<\"NormalCompletion\">(true)\n  return %21\n}","def <INTERNAL>:Record[StringExoticObject].GetOwnProperty(\n  S: Record[StringExoticObject],\n  P: Record[Symbol] | String,\n): Normal[Record[PropertyDescriptor] | Undefined] = {\n  call %0 = clo<\"OrdinaryGetOwnProperty\">(S, P)\n  let desc = %0\n  if (! (= desc undefined)) {\n    if (? desc: Completion) return desc\n    call %1 = clo<\"NormalCompletion\">(desc)\n    return %1\n  }\n  call %2 = clo<\"StringGetOwnProperty\">(S, P)\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <INTERNAL>:Record[StringExoticObject].DefineOwnProperty(\n  S: Record[StringExoticObject],\n  P: Record[Symbol] | String,\n  Desc: Record[PropertyDescriptor],\n): Normal[Boolean] = {\n  call %0 = clo<\"StringGetOwnProperty\">(S, P)\n  let stringDesc = %0\n  if (! (= stringDesc undefined)) {\n    let extensible = S.Extensible\n    call %1 = clo<\"IsCompatiblePropertyDescriptor\">(extensible, Desc, stringDesc)\n    if (? %1: Completion) return %1\n    call %2 = clo<\"NormalCompletion\">(%1)\n    return %2\n  }\n  call %3 = clo<\"OrdinaryDefineOwnProperty\">(S, P, Desc)\n  assert (? %3: Normal)\n  return %3\n}","def <INTERNAL>:Record[StringExoticObject].OwnPropertyKeys(\n  O: Record[StringExoticObject],\n): Normal[List[Record[Symbol] | String]] = {\n  let keys = (list [])[#426]\n  let str = O.StringData\n  assert (? str: String)\n  let len = (sizeof str)\n  let i = 0\n  while (! (< (- len 1) i)) {\n    call %0 = clo<\"ToString\">(([number] i))\n    assert (? %0: Normal)\n    %0 = %0.Value\n    push keys < %0\n    i = (+ i 1)\n  }\n  %2 = (keys-int O.__MAP__)[#427]\n  %1 = 0\n  while (< %1 (sizeof %2)) {\n    let P = %2[%1]\n    call %3 = clo<\"__IS_ARRAY_INDEX__\">(P)\n    call %4 = clo<\"ToIntegerOrInfinity\">(P)\n    assert (? %4: Normal)\n    %4 = %4.Value\n    if (&& %3 (! (< %4 len))) {\n      push keys < P\n    }\n    %1 = (+ %1 1)\n  }\n  %6 = (keys O.__MAP__)[#428]\n  %5 = 0\n  while (< %5 (sizeof %6)) {\n    let P = %6[%5]\n    call %7 = clo<\"__IS_ARRAY_INDEX__\">(P)\n    if (&& (? P: String) (! %7)) {\n      push keys < P\n    }\n    %5 = (+ %5 1)\n  }\n  %9 = (keys O.__MAP__)[#429]\n  %8 = 0\n  while (< %8 (sizeof %9)) {\n    let P = %9[%8]\n    if (? P: Record[Symbol]) {\n      push keys < P\n    }\n    %8 = (+ %8 1)\n  }\n  if (? keys: Completion) return keys\n  call %10 = clo<\"NormalCompletion\">(keys)\n  return %10\n}","def StringCreate(\n  value: String,\n  prototype: Record[Object],\n): Record[StringExoticObject] = {\n  call %0 = clo<\"MakeBasicObject\">((list [\"Prototype\", \"Extensible\", \"StringData\"])[#430])\n  let S = %0\n  S.Prototype = prototype\n  S.StringData = value\n  S.GetOwnProperty = clo<\"Record[StringExoticObject].GetOwnProperty\">\n  S.DefineOwnProperty = clo<\"Record[StringExoticObject].DefineOwnProperty\">\n  S.OwnPropertyKeys = clo<\"Record[StringExoticObject].OwnPropertyKeys\">\n  let length = (sizeof value)\n  call %1 = clo<\"DefinePropertyOrThrow\">(S, \"length\", (record [PropertyDescriptor] {\n    \"Value\" : ([number] length),\n    \"Writable\" : false,\n    \"Enumerable\" : false,\n    \"Configurable\" : false,\n  })[#431])\n  assert (? %1: Normal)\n  %1 = %1.Value\n  return S\n}","def StringGetOwnProperty(\n  S: Unknown[\"ObjectThatHasA[[StringData]]InternalSlot\"],\n  P: Record[Symbol] | String,\n): Record[PropertyDescriptor] | Undefined = {\n  if (! (? P: String)) {\n    return undefined\n  }\n  call %0 = clo<\"CanonicalNumericIndexString\">(P)\n  let index = %0\n  if (= index undefined) {\n    return undefined\n  }\n  call %1 = clo<\"IsIntegralNumber\">(index)\n  if (= %1 false) {\n    return undefined\n  }\n  if (= index -0.0f) {\n    return undefined\n  }\n  let str = S.StringData\n  assert (? str: String)\n  let len = (sizeof str)\n  if (|| (< ([math] index) 0) (! (< ([math] index) len))) {\n    return undefined\n  }\n  let resultStr = (substring str ([math] index) (+ ([math] index) 1))\n  return (record [PropertyDescriptor] {\n    \"Value\" : resultStr,\n    \"Writable\" : false,\n    \"Enumerable\" : true,\n    \"Configurable\" : false,\n  })[#432]\n}","def <INTERNAL>:Record[ArgumentsExoticObject].GetOwnProperty(\n  args: Record[ArgumentsExoticObject],\n  P: Record[Symbol] | String,\n): Normal[Record[PropertyDescriptor] | Undefined] = {\n  call %0 = clo<\"OrdinaryGetOwnProperty\">(args, P)\n  let desc = %0\n  if (= desc undefined) {\n    call %1 = clo<\"NormalCompletion\">(undefined)\n    return %1\n  }\n  let map = args.ParameterMap\n  call %2 = clo<\"HasOwnProperty\">(map, P)\n  assert (? %2: Normal)\n  %2 = %2.Value\n  let isMapped = %2\n  if (= isMapped true) {\n    call %3 = clo<\"Get\">(map, P)\n    assert (? %3: Normal)\n    %3 = %3.Value\n    desc.Value = %3\n  }\n  if (? desc: Completion) return desc\n  call %4 = clo<\"NormalCompletion\">(desc)\n  return %4\n}","def <INTERNAL>:Record[ArgumentsExoticObject].DefineOwnProperty(\n  args: Record[ArgumentsExoticObject],\n  P: Record[Symbol] | String,\n  Desc: Record[PropertyDescriptor],\n): Normal[Boolean] = {\n  let map = args.ParameterMap\n  call %0 = clo<\"HasOwnProperty\">(map, P)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let isMapped = %0\n  let newArgDesc = Desc\n  %1 = (= isMapped true)\n  if %1 {\n    call %2 = clo<\"IsDataDescriptor\">(Desc)\n    %1 = (= %2 true)\n  }\n  if %1 {\n    if (&& (! (exists Desc.Value)) (&& (exists Desc.Writable) (= Desc.Writable false))) {\n      (yet \"Set _newArgDesc_ to a copy of _Desc_.\")\n      call %3 = clo<\"Get\">(map, P)\n      assert (? %3: Normal)\n      %3 = %3.Value\n      newArgDesc.Value = %3\n    }\n  }\n  call %4 = clo<\"OrdinaryDefineOwnProperty\">(args, P, newArgDesc)\n  assert (? %4: Normal)\n  %4 = %4.Value\n  let allowed = %4\n  if (= allowed false) {\n    call %5 = clo<\"NormalCompletion\">(false)\n    return %5\n  }\n  if (= isMapped true) {\n    call %6 = clo<\"IsAccessorDescriptor\">(Desc)\n    if (= %6 true) {\n      call %7 = map.Delete(map, P)\n      assert (? %7: Normal)\n      %7 = %7.Value\n    } else {\n      if (exists Desc.Value) {\n        assert (yet \"The following Set will succeed, since formal parameters mapped by arguments objects are always writable.\")\n        call %8 = clo<\"Set\">(map, P, Desc.Value, false)\n        assert (? %8: Normal)\n        %8 = %8.Value\n      }\n      if (&& (exists Desc.Writable) (= Desc.Writable false)) {\n        call %9 = map.Delete(map, P)\n        assert (? %9: Normal)\n        %9 = %9.Value\n      }\n    }\n  }\n  call %10 = clo<\"NormalCompletion\">(true)\n  return %10\n}","def <INTERNAL>:Record[ArgumentsExoticObject].Get(\n  args: Record[ArgumentsExoticObject],\n  P: Record[Symbol] | String,\n  Receiver: ESValue,\n): Normal[ESValue] | Throw = {\n  let map = args.ParameterMap\n  call %0 = clo<\"HasOwnProperty\">(map, P)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let isMapped = %0\n  if (= isMapped false) {\n    call %1 = clo<\"OrdinaryGet\">(args, P, Receiver)\n    assert (? %1: Completion)\n    return %1\n  } else {\n    assert (yet \"_map_ contains a formal parameter mapping for _P_.\")\n    call %2 = clo<\"Get\">(map, P)\n    assert (? %2: Normal)\n    return %2\n  }\n}","def <INTERNAL>:Record[ArgumentsExoticObject].Set(\n  args: Record[ArgumentsExoticObject],\n  P: Record[Symbol] | String,\n  V: ESValue,\n  Receiver: ESValue,\n): Normal[Boolean] | Throw = {\n  call %0 = clo<\"SameValue\">(args, Receiver)\n  if (= %0 false) {\n    let isMapped = false\n  } else {\n    let map = args.ParameterMap\n    call %1 = clo<\"HasOwnProperty\">(map, P)\n    assert (? %1: Normal)\n    %1 = %1.Value\n    let isMapped = %1\n  }\n  if (= isMapped true) {\n    assert (yet \"The following Set will succeed, since formal parameters mapped by arguments objects are always writable.\")\n    call %2 = clo<\"Set\">(map, P, V, false)\n    assert (? %2: Normal)\n    %2 = %2.Value\n  }\n  call %3 = clo<\"OrdinarySet\">(args, P, V, Receiver)\n  assert (? %3: Completion)\n  return %3\n}","def <INTERNAL>:Record[ArgumentsExoticObject].Delete(\n  args: Record[ArgumentsExoticObject],\n  P: Record[Symbol] | String,\n): Normal[Boolean] | Throw = {\n  let map = args.ParameterMap\n  call %0 = clo<\"HasOwnProperty\">(map, P)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let isMapped = %0\n  call %1 = clo<\"OrdinaryDelete\">(args, P)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let result = %1\n  if (&& (= result true) (= isMapped true)) {\n    call %2 = map.Delete(map, P)\n    assert (? %2: Normal)\n    %2 = %2.Value\n  }\n  if (? result: Completion) return result\n  call %3 = clo<\"NormalCompletion\">(result)\n  return %3\n}","def CreateUnmappedArgumentsObject(\n  argumentsList: List[ESValue],\n): Record[OrdinaryObject] = {\n  let len = (sizeof argumentsList)\n  call %0 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Object.prototype%\"], (list [\"ParameterMap\"])[#433])\n  let obj = %0\n  obj.ParameterMap = undefined\n  call %1 = clo<\"DefinePropertyOrThrow\">(obj, \"length\", (record [PropertyDescriptor] {\n    \"Value\" : ([number] len),\n    \"Writable\" : true,\n    \"Enumerable\" : false,\n    \"Configurable\" : true,\n  })[#434])\n  assert (? %1: Normal)\n  %1 = %1.Value\n  let index = 0\n  while (< index len) {\n    let val = argumentsList[index]\n    call %2 = clo<\"ToString\">(([number] index))\n    assert (? %2: Normal)\n    %2 = %2.Value\n    call %3 = clo<\"CreateDataPropertyOrThrow\">(obj, %2, val)\n    assert (? %3: Normal)\n    %3 = %3.Value\n    index = (+ index 1)\n  }\n  call %4 = clo<\"DefinePropertyOrThrow\">(obj, @SYMBOL.iterator, (record [PropertyDescriptor] {\n    \"Value\" : @EXECUTION_STACK[0].Realm.Intrinsics[\"%Array.prototype.values%\"],\n    \"Writable\" : true,\n    \"Enumerable\" : false,\n    \"Configurable\" : true,\n  })[#435])\n  assert (? %4: Normal)\n  %4 = %4.Value\n  call %5 = clo<\"DefinePropertyOrThrow\">(obj, \"callee\", (record [PropertyDescriptor] {\n    \"Get\" : @EXECUTION_STACK[0].Realm.Intrinsics[\"%ThrowTypeError%\"],\n    \"Set\" : @EXECUTION_STACK[0].Realm.Intrinsics[\"%ThrowTypeError%\"],\n    \"Enumerable\" : false,\n    \"Configurable\" : false,\n  })[#436])\n  assert (? %5: Normal)\n  %5 = %5.Value\n  return obj\n}","def CreateMappedArgumentsObject(\n  func: Record[Object],\n  formals: Ast,\n  argumentsList: List[ESValue],\n  env: Record[EnvironmentRecord],\n): Record[ArgumentsExoticObject] = {\n  assert (yet \"_formals_ does not contain a rest parameter, any binding patterns, or any initializers. It may contain duplicate identifiers.\")\n  let len = (sizeof argumentsList)\n  call %0 = clo<\"MakeBasicObject\">((list [\"Prototype\", \"Extensible\", \"ParameterMap\"])[#437])\n  let obj = %0\n  obj.GetOwnProperty = clo<\"Record[ArgumentsExoticObject].GetOwnProperty\">\n  obj.DefineOwnProperty = clo<\"Record[ArgumentsExoticObject].DefineOwnProperty\">\n  obj.Get = clo<\"Record[ArgumentsExoticObject].Get\">\n  obj.Set = clo<\"Record[ArgumentsExoticObject].Set\">\n  obj.Delete = clo<\"Record[ArgumentsExoticObject].Delete\">\n  obj.Prototype = @EXECUTION_STACK[0].Realm.Intrinsics[\"%Object.prototype%\"]\n  call %1 = clo<\"OrdinaryObjectCreate\">(null)\n  let map = %1\n  obj.ParameterMap = map\n  sdo-call %2 = formals->BoundNames()\n  let parameterNames = %2\n  let numberOfParameters = (sizeof parameterNames)\n  let index = 0\n  while (< index len) {\n    let val = argumentsList[index]\n    call %3 = clo<\"ToString\">(([number] index))\n    assert (? %3: Normal)\n    %3 = %3.Value\n    call %4 = clo<\"CreateDataPropertyOrThrow\">(obj, %3, val)\n    assert (? %4: Normal)\n    %4 = %4.Value\n    index = (+ index 1)\n  }\n  call %5 = clo<\"DefinePropertyOrThrow\">(obj, \"length\", (record [PropertyDescriptor] {\n    \"Value\" : ([number] len),\n    \"Writable\" : true,\n    \"Enumerable\" : false,\n    \"Configurable\" : true,\n  })[#438])\n  assert (? %5: Normal)\n  %5 = %5.Value\n  let mappedNames = (list [])[#439]\n  index = (- numberOfParameters 1)\n  while (! (< index 0)) {\n    let name = parameterNames[index]\n    if (! (contains mappedNames name)) {\n      push mappedNames < name\n      if (< index len) {\n        call %6 = clo<\"MakeArgGetter\">(name, env)\n        let g = %6\n        call %7 = clo<\"MakeArgSetter\">(name, env)\n        let p = %7\n        call %9 = clo<\"ToString\">(([number] index))\n        assert (? %9: Normal)\n        %9 = %9.Value\n        call %8 = map.DefineOwnProperty(map, %9, (record [PropertyDescriptor] {\n          \"Set\" : p,\n          \"Get\" : g,\n          \"Enumerable\" : false,\n          \"Configurable\" : true,\n        })[#440])\n        assert (? %8: Normal)\n        %8 = %8.Value\n      }\n    }\n    index = (- index 1)\n  }\n  call %10 = clo<\"DefinePropertyOrThrow\">(obj, @SYMBOL.iterator, (record [PropertyDescriptor] {\n    \"Value\" : @EXECUTION_STACK[0].Realm.Intrinsics[\"%Array.prototype.values%\"],\n    \"Writable\" : true,\n    \"Enumerable\" : false,\n    \"Configurable\" : true,\n  })[#441])\n  assert (? %10: Normal)\n  %10 = %10.Value\n  call %11 = clo<\"DefinePropertyOrThrow\">(obj, \"callee\", (record [PropertyDescriptor] {\n    \"Value\" : func,\n    \"Writable\" : true,\n    \"Enumerable\" : false,\n    \"Configurable\" : true,\n  })[#442])\n  assert (? %11: Normal)\n  %11 = %11.Value\n  return obj\n}","def <CLO>:MakeArgGetter:clo0(\n  this: Unknown,\n  ArgumentsList: Unknown,\n  NewTarget: Unknown,\n): Unknown = {\n  let __args__ = (record)[#443]\n  call %0 = env.GetBindingValue(env, name, false)\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def MakeArgGetter(\n  name: String,\n  env: Record[EnvironmentRecord],\n): Record[FunctionObject] = {\n  let getterClosure = clo<\"MakeArgGetter:clo0\", [name, env]>\n  call %0 = clo<\"CreateBuiltinFunction\">(getterClosure, 0, \"\", (list [])[#444])\n  let getter = %0\n  nop\n  return getter\n}","def <CLO>:MakeArgSetter:clo0(\n  this: Unknown,\n  ArgumentsList: Unknown,\n  NewTarget: Unknown,\n): Unknown = {\n  let __args__ = (record)[#445]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  call %0 = env.SetMutableBinding(env, name, value, false)\n  assert (? %0: Normal)\n  return %0\n}","def MakeArgSetter(\n  name: String,\n  env: Record[EnvironmentRecord],\n): Record[FunctionObject] = {\n  let setterClosure = clo<\"MakeArgSetter:clo0\", [name, env]>\n  call %0 = clo<\"CreateBuiltinFunction\">(setterClosure, 1, \"\", (list [])[#446])\n  let setter = %0\n  nop\n  return setter\n}","def <INTERNAL>:Record[TypedArray].GetOwnProperty(\n  O: Record[TypedArray],\n  P: Record[Symbol] | String,\n): Normal[Record[PropertyDescriptor] | Undefined] = {\n  if (? P: String) {\n    call %0 = clo<\"CanonicalNumericIndexString\">(P)\n    let numericIndex = %0\n    if (! (= numericIndex undefined)) {\n      call %1 = clo<\"TypedArrayGetElement\">(O, numericIndex)\n      let value = %1\n      if (= value undefined) {\n        call %2 = clo<\"NormalCompletion\">(undefined)\n        return %2\n      }\n      %3 = (record [PropertyDescriptor] {\n        \"Value\" : value,\n        \"Writable\" : true,\n        \"Enumerable\" : true,\n        \"Configurable\" : true,\n      })[#447]\n      if (? %3: Completion) return %3\n      call %4 = clo<\"NormalCompletion\">(%3)\n      return %4\n    }\n  }\n  call %5 = clo<\"OrdinaryGetOwnProperty\">(O, P)\n  if (? %5: Completion) return %5\n  call %6 = clo<\"NormalCompletion\">(%5)\n  return %6\n}","def <INTERNAL>:Record[TypedArray].HasProperty(\n  O: Record[TypedArray],\n  P: Record[Symbol] | String,\n): Normal[Boolean] | Throw = {\n  if (? P: String) {\n    call %0 = clo<\"CanonicalNumericIndexString\">(P)\n    let numericIndex = %0\n    if (! (= numericIndex undefined)) {\n      call %1 = clo<\"IsValidIntegerIndex\">(O, numericIndex)\n      if (? %1: Completion) return %1\n      call %2 = clo<\"NormalCompletion\">(%1)\n      return %2\n    }\n  }\n  call %3 = clo<\"OrdinaryHasProperty\">(O, P)\n  assert (? %3: Completion)\n  return %3\n}","def <INTERNAL>:Record[TypedArray].DefineOwnProperty(\n  O: Record[TypedArray],\n  P: Record[Symbol] | String,\n  Desc: Record[PropertyDescriptor],\n): Normal[Boolean] | Throw = {\n  if (? P: String) {\n    call %0 = clo<\"CanonicalNumericIndexString\">(P)\n    let numericIndex = %0\n    if (! (= numericIndex undefined)) {\n      call %1 = clo<\"IsValidIntegerIndex\">(O, numericIndex)\n      if (= %1 false) {\n        call %2 = clo<\"NormalCompletion\">(false)\n        return %2\n      }\n      if (&& (exists Desc.Configurable) (= Desc.Configurable false)) {\n        call %3 = clo<\"NormalCompletion\">(false)\n        return %3\n      }\n      if (&& (exists Desc.Enumerable) (= Desc.Enumerable false)) {\n        call %4 = clo<\"NormalCompletion\">(false)\n        return %4\n      }\n      call %5 = clo<\"IsAccessorDescriptor\">(Desc)\n      if (= %5 true) {\n        call %6 = clo<\"NormalCompletion\">(false)\n        return %6\n      }\n      if (&& (exists Desc.Writable) (= Desc.Writable false)) {\n        call %7 = clo<\"NormalCompletion\">(false)\n        return %7\n      }\n      if (exists Desc.Value) {\n        call %8 = clo<\"TypedArraySetElement\">(O, numericIndex, Desc.Value)\n        assert (? %8: Completion)\n        if (? %8: Abrupt) return %8\n        else %8 = %8.Value\n      }\n      call %9 = clo<\"NormalCompletion\">(true)\n      return %9\n    }\n  }\n  call %10 = clo<\"OrdinaryDefineOwnProperty\">(O, P, Desc)\n  assert (? %10: Normal)\n  return %10\n}","def <INTERNAL>:Record[TypedArray].Get(\n  O: Record[TypedArray],\n  P: Record[Symbol] | String,\n  Receiver: ESValue,\n): Normal[ESValue] | Throw = {\n  if (? P: String) {\n    call %0 = clo<\"CanonicalNumericIndexString\">(P)\n    let numericIndex = %0\n    if (! (= numericIndex undefined)) {\n      call %1 = clo<\"TypedArrayGetElement\">(O, numericIndex)\n      if (? %1: Completion) return %1\n      call %2 = clo<\"NormalCompletion\">(%1)\n      return %2\n    }\n  }\n  call %3 = clo<\"OrdinaryGet\">(O, P, Receiver)\n  assert (? %3: Completion)\n  return %3\n}","def <INTERNAL>:Record[TypedArray].Set(\n  O: Record[TypedArray],\n  P: Record[Symbol] | String,\n  V: ESValue,\n  Receiver: ESValue,\n): Normal[Boolean] | Throw = {\n  if (? P: String) {\n    call %0 = clo<\"CanonicalNumericIndexString\">(P)\n    let numericIndex = %0\n    if (! (= numericIndex undefined)) {\n      call %1 = clo<\"SameValue\">(O, Receiver)\n      if (= %1 true) {\n        call %2 = clo<\"TypedArraySetElement\">(O, numericIndex, V)\n        assert (? %2: Completion)\n        if (? %2: Abrupt) return %2\n        else %2 = %2.Value\n        call %3 = clo<\"NormalCompletion\">(true)\n        return %3\n      }\n      call %4 = clo<\"IsValidIntegerIndex\">(O, numericIndex)\n      if (= %4 false) {\n        call %5 = clo<\"NormalCompletion\">(true)\n        return %5\n      }\n    }\n  }\n  call %6 = clo<\"OrdinarySet\">(O, P, V, Receiver)\n  assert (? %6: Completion)\n  return %6\n}","def <INTERNAL>:Record[TypedArray].Delete(\n  O: Record[TypedArray],\n  P: Record[Symbol] | String,\n): Normal[Boolean] = {\n  if (? P: String) {\n    call %0 = clo<\"CanonicalNumericIndexString\">(P)\n    let numericIndex = %0\n    if (! (= numericIndex undefined)) {\n      call %1 = clo<\"IsValidIntegerIndex\">(O, numericIndex)\n      if (= %1 false) {\n        call %2 = clo<\"NormalCompletion\">(true)\n        return %2\n      } else {\n        call %3 = clo<\"NormalCompletion\">(false)\n        return %3\n      }\n    }\n  }\n  call %4 = clo<\"OrdinaryDelete\">(O, P)\n  assert (? %4: Normal)\n  return %4\n}","def <INTERNAL>:Record[TypedArray].OwnPropertyKeys(\n  O: Record[TypedArray],\n): Normal[List[Record[Symbol] | String]] = {\n  call %0 = clo<\"MakeTypedArrayWithBufferWitnessRecord\">(O, ~seq-cst~)\n  let taRecord = %0\n  let keys = (list [])[#448]\n  call %1 = clo<\"IsTypedArrayOutOfBounds\">(taRecord)\n  if (= %1 false) {\n    call %2 = clo<\"TypedArrayLength\">(taRecord)\n    let length = %2\n    let i = 0\n    while (! (< (- length 1) i)) {\n      call %3 = clo<\"ToString\">(([number] i))\n      assert (? %3: Normal)\n      %3 = %3.Value\n      push keys < %3\n      i = (+ i 1)\n    }\n  }\n  (yet \"For each own property key _P_ of _O_ such that _P_ is a String and _P_ is not an integer index, in ascending chronological order of property creation, do\\n  1. Append _P_ to _keys_.\")\n  %5 = (keys O.__MAP__)[#449]\n  %4 = 0\n  while (< %4 (sizeof %5)) {\n    let P = %5[%4]\n    if (? P: Record[Symbol]) {\n      push keys < P\n    }\n    %4 = (+ %4 1)\n  }\n  if (? keys: Completion) return keys\n  call %6 = clo<\"NormalCompletion\">(keys)\n  return %6\n}","def MakeTypedArrayWithBufferWitnessRecord(\n  obj: Record[TypedArray],\n  order: Enum[~seq-cst~, ~unordered~],\n): Record[TypedArrayWithBufferWitnessRecord] = {\n  let buffer = obj.ViewedArrayBuffer\n  call %0 = clo<\"IsDetachedBuffer\">(buffer)\n  if (= %0 true) {\n    let byteLength = ~detached~\n  } else {\n    call %1 = clo<\"ArrayBufferByteLength\">(buffer, order)\n    let byteLength = %1\n  }\n  return (record [TypedArrayWithBufferWitnessRecord] {\n    \"Object\" : obj,\n    \"CachedBufferByteLength\" : byteLength,\n  })[#450]\n}","def TypedArrayCreate(\n  prototype: Record[Object],\n): Record[TypedArray] = {\n  let internalSlotsList = (list [\"Prototype\", \"Extensible\", \"ViewedArrayBuffer\", \"TypedArrayName\", \"ContentType\", \"ByteLength\", \"ByteOffset\", \"ArrayLength\"])[#451]\n  call %0 = clo<\"MakeBasicObject\">(internalSlotsList)\n  let A = %0\n  A.GetOwnProperty = clo<\"Record[TypedArray].GetOwnProperty\">\n  A.HasProperty = clo<\"Record[TypedArray].HasProperty\">\n  A.DefineOwnProperty = clo<\"Record[TypedArray].DefineOwnProperty\">\n  A.Get = clo<\"Record[TypedArray].Get\">\n  A.Set = clo<\"Record[TypedArray].Set\">\n  A.Delete = clo<\"Record[TypedArray].Delete\">\n  A.OwnPropertyKeys = clo<\"Record[TypedArray].OwnPropertyKeys\">\n  A.Prototype = prototype\n  return A\n}","def TypedArrayByteLength(\n  taRecord: Record[TypedArrayWithBufferWitnessRecord],\n): NonNegInt = {\n  call %0 = clo<\"IsTypedArrayOutOfBounds\">(taRecord)\n  if (= %0 true) {\n    return 0\n  }\n  call %1 = clo<\"TypedArrayLength\">(taRecord)\n  let length = %1\n  if (== length 0) {\n    return 0\n  }\n  let O = taRecord.Object\n  if (! (= O.ByteLength ~auto~)) {\n    return O.ByteLength\n  }\n  call %2 = clo<\"TypedArrayElementSize\">(O)\n  let elementSize = %2\n  return (* length elementSize)\n}","def TypedArrayLength(\n  taRecord: Record[TypedArrayWithBufferWitnessRecord],\n): NonNegInt = {\n  call %0 = clo<\"IsTypedArrayOutOfBounds\">(taRecord)\n  assert (= %0 false)\n  let O = taRecord.Object\n  if (! (= O.ArrayLength ~auto~)) {\n    return O.ArrayLength\n  }\n  call %1 = clo<\"IsFixedLengthArrayBuffer\">(O.ViewedArrayBuffer)\n  assert (= %1 false)\n  let byteOffset = O.ByteOffset\n  call %2 = clo<\"TypedArrayElementSize\">(O)\n  let elementSize = %2\n  let byteLength = taRecord.CachedBufferByteLength\n  assert (! (= byteLength ~detached~))\n  return (floor (/ (- byteLength byteOffset) elementSize))\n}","def IsTypedArrayOutOfBounds(\n  taRecord: Record[TypedArrayWithBufferWitnessRecord],\n): Boolean = {\n  let O = taRecord.Object\n  let bufferByteLength = taRecord.CachedBufferByteLength\n  assert (yet \"IsDetachedBuffer(_O_.[[ViewedArrayBuffer]]) is *true* if and only if _bufferByteLength_ is ~detached~.\")\n  if (= bufferByteLength ~detached~) {\n    return true\n  }\n  let byteOffsetStart = O.ByteOffset\n  if (= O.ArrayLength ~auto~) {\n    let byteOffsetEnd = bufferByteLength\n  } else {\n    call %0 = clo<\"TypedArrayElementSize\">(O)\n    let elementSize = %0\n    let byteOffsetEnd = (+ byteOffsetStart (* O.ArrayLength elementSize))\n  }\n  if (|| (< bufferByteLength byteOffsetStart) (< bufferByteLength byteOffsetEnd)) {\n    return true\n  }\n  nop\n  return false\n}","def IsValidIntegerIndex(\n  O: Record[TypedArray],\n  index: Number,\n): Boolean = {\n  call %0 = clo<\"IsDetachedBuffer\">(O.ViewedArrayBuffer)\n  if (= %0 true) {\n    return false\n  }\n  call %1 = clo<\"IsIntegralNumber\">(index)\n  if (= %1 false) {\n    return false\n  }\n  if (= index -0.0f) {\n    return false\n  }\n  call %2 = clo<\"MakeTypedArrayWithBufferWitnessRecord\">(O, ~unordered~)\n  let taRecord = %2\n  nop\n  call %3 = clo<\"IsTypedArrayOutOfBounds\">(taRecord)\n  if (= %3 true) {\n    return false\n  }\n  call %4 = clo<\"TypedArrayLength\">(taRecord)\n  let length = %4\n  if (|| (< ([math] index) 0) (! (< ([math] index) length))) {\n    return false\n  }\n  return true\n}","def TypedArrayGetElement(\n  O: Record[TypedArray],\n  index: Number,\n): Number | BigInt | Undefined = {\n  call %0 = clo<\"IsValidIntegerIndex\">(O, index)\n  if (= %0 false) {\n    return undefined\n  }\n  let offset = O.ByteOffset\n  call %1 = clo<\"TypedArrayElementSize\">(O)\n  let elementSize = %1\n  let byteIndexInBuffer = (+ (* ([math] index) elementSize) offset)\n  call %2 = clo<\"TypedArrayElementType\">(O)\n  let elementType = %2\n  call %3 = clo<\"GetValueFromBuffer\">(O.ViewedArrayBuffer, byteIndexInBuffer, elementType, true, ~unordered~)\n  return %3\n}","def TypedArraySetElement(\n  O: Record[TypedArray],\n  index: Number,\n  value: ESValue,\n): Normal[Enum[~unused~]] | Throw = {\n  if (= O.ContentType ~bigint~) {\n    call %0 = clo<\"ToBigInt\">(value)\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let numValue = %0\n  } else {\n    call %1 = clo<\"ToNumber\">(value)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let numValue = %1\n  }\n  call %2 = clo<\"IsValidIntegerIndex\">(O, index)\n  if (= %2 true) {\n    let offset = O.ByteOffset\n    call %3 = clo<\"TypedArrayElementSize\">(O)\n    let elementSize = %3\n    let byteIndexInBuffer = (+ (* ([math] index) elementSize) offset)\n    call %4 = clo<\"TypedArrayElementType\">(O)\n    let elementType = %4\n    call %5 = clo<\"SetValueInBuffer\">(O.ViewedArrayBuffer, byteIndexInBuffer, elementType, numValue, true, ~unordered~)\n  }\n  call %6 = clo<\"NormalCompletion\">(~unused~)\n  return %6\n}","def IsArrayBufferViewOutOfBounds(\n  O: Record[DataView | TypedArray],\n): Boolean = {\n  if (exists O.DataView) {\n    call %0 = clo<\"MakeDataViewWithBufferWitnessRecord\">(O, ~seq-cst~)\n    let viewRecord = %0\n    call %1 = clo<\"IsViewOutOfBounds\">(viewRecord)\n    return %1\n  }\n  call %2 = clo<\"MakeTypedArrayWithBufferWitnessRecord\">(O, ~seq-cst~)\n  let taRecord = %2\n  call %3 = clo<\"IsTypedArrayOutOfBounds\">(taRecord)\n  return %3\n}","def <INTERNAL>:Record[ModuleNamespaceExoticObject].GetPrototypeOf(\n  this: Record[ModuleNamespaceExoticObject],\n): Normal[Null] = {\n  call %0 = clo<\"NormalCompletion\">(null)\n  return %0\n}","def <INTERNAL>:Record[ModuleNamespaceExoticObject].SetPrototypeOf(\n  O: Record[ModuleNamespaceExoticObject],\n  V: Record[Object] | Null,\n): Normal[Boolean] = {\n  call %0 = clo<\"SetImmutablePrototype\">(O, V)\n  assert (? %0: Normal)\n  return %0\n}","def <INTERNAL>:Record[ModuleNamespaceExoticObject].IsExtensible(\n  this: Record[ModuleNamespaceExoticObject],\n): Normal[False] = {\n  call %0 = clo<\"NormalCompletion\">(false)\n  return %0\n}","def <INTERNAL>:Record[ModuleNamespaceExoticObject].PreventExtensions(\n  this: Record[ModuleNamespaceExoticObject],\n): Normal[True] = {\n  call %0 = clo<\"NormalCompletion\">(true)\n  return %0\n}","def <INTERNAL>:Record[ModuleNamespaceExoticObject].GetOwnProperty(\n  O: Record[ModuleNamespaceExoticObject],\n  P: Record[Symbol] | String,\n): Normal[Record[PropertyDescriptor] | Undefined] | Throw = {\n  if (? P: Record[Symbol]) {\n    call %0 = clo<\"OrdinaryGetOwnProperty\">(O, P)\n    if (? %0: Completion) return %0\n    call %1 = clo<\"NormalCompletion\">(%0)\n    return %1\n  }\n  let exports = O.Exports\n  if (! (contains exports P)) {\n    call %2 = clo<\"NormalCompletion\">(undefined)\n    return %2\n  }\n  call %3 = O.Get(O, P, O)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let value = %3\n  %4 = (record [PropertyDescriptor] {\n    \"Value\" : value,\n    \"Writable\" : true,\n    \"Enumerable\" : true,\n    \"Configurable\" : false,\n  })[#452]\n  if (? %4: Completion) return %4\n  call %5 = clo<\"NormalCompletion\">(%4)\n  return %5\n}","def <INTERNAL>:Record[ModuleNamespaceExoticObject].DefineOwnProperty(\n  O: Record[ModuleNamespaceExoticObject],\n  P: Record[Symbol] | String,\n  Desc: Record[PropertyDescriptor],\n): Normal[Boolean] | Throw = {\n  if (? P: Record[Symbol]) {\n    call %0 = clo<\"OrdinaryDefineOwnProperty\">(O, P, Desc)\n    assert (? %0: Normal)\n    return %0\n  }\n  call %1 = O.GetOwnProperty(O, P)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let current = %1\n  if (= current undefined) {\n    call %2 = clo<\"NormalCompletion\">(false)\n    return %2\n  }\n  if (&& (exists Desc.Configurable) (= Desc.Configurable true)) {\n    call %3 = clo<\"NormalCompletion\">(false)\n    return %3\n  }\n  if (&& (exists Desc.Enumerable) (= Desc.Enumerable false)) {\n    call %4 = clo<\"NormalCompletion\">(false)\n    return %4\n  }\n  call %5 = clo<\"IsAccessorDescriptor\">(Desc)\n  if (= %5 true) {\n    call %6 = clo<\"NormalCompletion\">(false)\n    return %6\n  }\n  if (&& (exists Desc.Writable) (= Desc.Writable false)) {\n    call %7 = clo<\"NormalCompletion\">(false)\n    return %7\n  }\n  if (exists Desc.Value) {\n    call %8 = clo<\"SameValue\">(Desc.Value, current.Value)\n    if (? %8: Completion) return %8\n    call %9 = clo<\"NormalCompletion\">(%8)\n    return %9\n  }\n  call %10 = clo<\"NormalCompletion\">(true)\n  return %10\n}","def <INTERNAL>:Record[ModuleNamespaceExoticObject].HasProperty(\n  O: Record[ModuleNamespaceExoticObject],\n  P: Record[Symbol] | String,\n): Normal[Boolean] = {\n  if (? P: Record[Symbol]) {\n    call %0 = clo<\"OrdinaryHasProperty\">(O, P)\n    assert (? %0: Normal)\n    return %0\n  }\n  let exports = O.Exports\n  if (contains exports P) {\n    call %1 = clo<\"NormalCompletion\">(true)\n    return %1\n  }\n  call %2 = clo<\"NormalCompletion\">(false)\n  return %2\n}","def <INTERNAL>:Record[ModuleNamespaceExoticObject].Get(\n  O: Record[ModuleNamespaceExoticObject],\n  P: Record[Symbol] | String,\n  Receiver: ESValue,\n): Normal[ESValue] | Throw = {\n  if (? P: Record[Symbol]) {\n    call %0 = clo<\"OrdinaryGet\">(O, P, Receiver)\n    assert (? %0: Normal)\n    return %0\n  }\n  let exports = O.Exports\n  if (! (contains exports P)) {\n    call %1 = clo<\"NormalCompletion\">(undefined)\n    return %1\n  }\n  let m = O.Module\n  call %2 = m.ResolveExport(m, P)\n  let binding = %2\n  assert (? binding: Record[ResolvedBindingRecord])\n  let targetModule = binding.Module\n  assert (! (= targetModule undefined))\n  if (= binding.BindingName ~namespace~) {\n    call %3 = clo<\"GetModuleNamespace\">(targetModule)\n    if (? %3: Completion) return %3\n    call %4 = clo<\"NormalCompletion\">(%3)\n    return %4\n  }\n  let targetEnv = targetModule.Environment\n  if (= targetEnv ~empty~) {\n    call %5 = clo<\"__NEW_ERROR_OBJ__\">(\"%ReferenceError.prototype%\")\n    call %6 = clo<\"ThrowCompletion\">(%5)\n    return %6\n  }\n  call %7 = targetEnv.GetBindingValue(targetEnv, binding.BindingName, true)\n  assert (? %7: Completion)\n  return %7\n}","def <INTERNAL>:Record[ModuleNamespaceExoticObject].Set(\n  this: Record[ModuleNamespaceExoticObject],\n  P: Record[Symbol] | String,\n  V: ESValue,\n  Receiver: ESValue,\n): Normal[False] = {\n  call %0 = clo<\"NormalCompletion\">(false)\n  return %0\n}","def <INTERNAL>:Record[ModuleNamespaceExoticObject].Delete(\n  O: Record[ModuleNamespaceExoticObject],\n  P: Record[Symbol] | String,\n): Normal[Boolean] = {\n  if (? P: Record[Symbol]) {\n    call %0 = clo<\"OrdinaryDelete\">(O, P)\n    assert (? %0: Normal)\n    return %0\n  }\n  let exports = O.Exports\n  if (contains exports P) {\n    call %1 = clo<\"NormalCompletion\">(false)\n    return %1\n  }\n  call %2 = clo<\"NormalCompletion\">(true)\n  return %2\n}","def <INTERNAL>:Record[ModuleNamespaceExoticObject].OwnPropertyKeys(\n  O: Record[ModuleNamespaceExoticObject],\n): Normal[List[Record[Symbol] | String]] = {\n  let exports = O.Exports\n  call %0 = clo<\"OrdinaryOwnPropertyKeys\">(O)\n  let symbolKeys = %0\n  call %1 = clo<\"__FLAT_LIST__\">((list [exports, symbolKeys])[#453])\n  if (? %1: Completion) return %1\n  call %2 = clo<\"NormalCompletion\">(%1)\n  return %2\n}","def ModuleNamespaceCreate(\n  module: Record[ModuleRecord],\n  exports: List[String],\n): Record[ModuleNamespaceExoticObject] = {\n  assert (= module.Namespace ~empty~)\n  let internalSlotsList = (list [\"Module\", \"Exports\"])[#454]\n  call %0 = clo<\"MakeBasicObject\">(internalSlotsList)\n  let M = %0\n  (yet \"Set _M_'s essential internal methods to the definitions specified in <emu-xref href=\\\"#sec-module-namespace-exotic-objects\\\"></emu-xref>.\")\n  M.Module = module\n  (yet \"Let _sortedExports_ be a List whose elements are the elements of _exports_ ordered as if an Array of the same values had been sorted using %Array.prototype.sort% using *undefined* as _comparefn_.\")\n  M.Exports = sortedExports\n  (yet \"Create own properties of _M_ corresponding to the definitions in <emu-xref href=\\\"#sec-module-namespace-objects\\\"></emu-xref>.\")\n  module.Namespace = M\n  return M\n}","def <INTERNAL>:Record[ImmutablePrototypeExoticObject].SetPrototypeOf(\n  O: Record[ImmutablePrototypeExoticObject],\n  V: Record[Object] | Null,\n): Normal[Boolean] | Throw = {\n  call %0 = clo<\"SetImmutablePrototype\">(O, V)\n  assert (? %0: Completion)\n  return %0\n}","def SetImmutablePrototype(\n  O: Record[Object],\n  V: Record[Object] | Null,\n): Normal[Boolean] | Throw = {\n  call %0 = O.GetPrototypeOf(O)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let current = %0\n  call %1 = clo<\"SameValue\">(V, current)\n  if (= %1 true) {\n    call %2 = clo<\"NormalCompletion\">(true)\n    return %2\n  }\n  call %3 = clo<\"NormalCompletion\">(false)\n  return %3\n}","def <INTERNAL>:Record[ProxyExoticObject].GetPrototypeOf(\n  O: Record[ProxyExoticObject],\n): Normal[Record[Object] | Null] | Throw = {\n  call %0 = clo<\"ValidateNonRevokedProxy\">(O)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let target = O.ProxyTarget\n  let handler = O.ProxyHandler\n  assert (? handler: Record[Object])\n  call %1 = clo<\"GetMethod\">(handler, \"getPrototypeOf\")\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let trap = %1\n  if (= trap undefined) {\n    call %2 = target.GetPrototypeOf(target)\n    assert (? %2: Completion)\n    return %2\n  }\n  call %3 = clo<\"Call\">(trap, handler, (list [target])[#455])\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let handlerProto = %3\n  if (&& (! (? handlerProto: Record[Object])) (! (= handlerProto null))) {\n    call %4 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %5 = clo<\"ThrowCompletion\">(%4)\n    return %5\n  }\n  call %6 = clo<\"IsExtensible\">(target)\n  assert (? %6: Completion)\n  if (? %6: Abrupt) return %6\n  else %6 = %6.Value\n  let extensibleTarget = %6\n  if (= extensibleTarget true) {\n    if (? handlerProto: Completion) return handlerProto\n    call %7 = clo<\"NormalCompletion\">(handlerProto)\n    return %7\n  }\n  call %8 = target.GetPrototypeOf(target)\n  assert (? %8: Completion)\n  if (? %8: Abrupt) return %8\n  else %8 = %8.Value\n  let targetProto = %8\n  call %9 = clo<\"SameValue\">(handlerProto, targetProto)\n  if (= %9 false) {\n    call %10 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %11 = clo<\"ThrowCompletion\">(%10)\n    return %11\n  }\n  if (? handlerProto: Completion) return handlerProto\n  call %12 = clo<\"NormalCompletion\">(handlerProto)\n  return %12\n}","def <INTERNAL>:Record[ProxyExoticObject].SetPrototypeOf(\n  O: Record[ProxyExoticObject],\n  V: Record[Object] | Null,\n): Normal[Boolean] | Throw = {\n  call %0 = clo<\"ValidateNonRevokedProxy\">(O)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let target = O.ProxyTarget\n  let handler = O.ProxyHandler\n  assert (? handler: Record[Object])\n  call %1 = clo<\"GetMethod\">(handler, \"setPrototypeOf\")\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let trap = %1\n  if (= trap undefined) {\n    call %2 = target.SetPrototypeOf(target, V)\n    assert (? %2: Completion)\n    return %2\n  }\n  call %3 = clo<\"Call\">(trap, handler, (list [target, V])[#456])\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  call %4 = clo<\"ToBoolean\">(%3)\n  let booleanTrapResult = %4\n  if (= booleanTrapResult false) {\n    call %5 = clo<\"NormalCompletion\">(false)\n    return %5\n  }\n  call %6 = clo<\"IsExtensible\">(target)\n  assert (? %6: Completion)\n  if (? %6: Abrupt) return %6\n  else %6 = %6.Value\n  let extensibleTarget = %6\n  if (= extensibleTarget true) {\n    call %7 = clo<\"NormalCompletion\">(true)\n    return %7\n  }\n  call %8 = target.GetPrototypeOf(target)\n  assert (? %8: Completion)\n  if (? %8: Abrupt) return %8\n  else %8 = %8.Value\n  let targetProto = %8\n  call %9 = clo<\"SameValue\">(V, targetProto)\n  if (= %9 false) {\n    call %10 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %11 = clo<\"ThrowCompletion\">(%10)\n    return %11\n  }\n  call %12 = clo<\"NormalCompletion\">(true)\n  return %12\n}","def <INTERNAL>:Record[ProxyExoticObject].IsExtensible(\n  O: Record[ProxyExoticObject],\n): Normal[Boolean] | Throw = {\n  call %0 = clo<\"ValidateNonRevokedProxy\">(O)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let target = O.ProxyTarget\n  let handler = O.ProxyHandler\n  assert (? handler: Record[Object])\n  call %1 = clo<\"GetMethod\">(handler, \"isExtensible\")\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let trap = %1\n  if (= trap undefined) {\n    call %2 = clo<\"IsExtensible\">(target)\n    assert (? %2: Completion)\n    return %2\n  }\n  call %3 = clo<\"Call\">(trap, handler, (list [target])[#457])\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  call %4 = clo<\"ToBoolean\">(%3)\n  let booleanTrapResult = %4\n  call %5 = clo<\"IsExtensible\">(target)\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  let targetResult = %5\n  if (! (= booleanTrapResult targetResult)) {\n    call %6 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %7 = clo<\"ThrowCompletion\">(%6)\n    return %7\n  }\n  if (? booleanTrapResult: Completion) return booleanTrapResult\n  call %8 = clo<\"NormalCompletion\">(booleanTrapResult)\n  return %8\n}","def <INTERNAL>:Record[ProxyExoticObject].PreventExtensions(\n  O: Record[ProxyExoticObject],\n): Normal[Boolean] | Throw = {\n  call %0 = clo<\"ValidateNonRevokedProxy\">(O)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let target = O.ProxyTarget\n  let handler = O.ProxyHandler\n  assert (? handler: Record[Object])\n  call %1 = clo<\"GetMethod\">(handler, \"preventExtensions\")\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let trap = %1\n  if (= trap undefined) {\n    call %2 = target.PreventExtensions(target)\n    assert (? %2: Completion)\n    return %2\n  }\n  call %3 = clo<\"Call\">(trap, handler, (list [target])[#458])\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  call %4 = clo<\"ToBoolean\">(%3)\n  let booleanTrapResult = %4\n  if (= booleanTrapResult true) {\n    call %5 = clo<\"IsExtensible\">(target)\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n    let extensibleTarget = %5\n    if (= extensibleTarget true) {\n      call %6 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %7 = clo<\"ThrowCompletion\">(%6)\n      return %7\n    }\n  }\n  if (? booleanTrapResult: Completion) return booleanTrapResult\n  call %8 = clo<\"NormalCompletion\">(booleanTrapResult)\n  return %8\n}","def <INTERNAL>:Record[ProxyExoticObject].GetOwnProperty(\n  O: Record[ProxyExoticObject],\n  P: Record[Symbol] | String,\n): Normal[Record[PropertyDescriptor] | Undefined] | Throw = {\n  call %0 = clo<\"ValidateNonRevokedProxy\">(O)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let target = O.ProxyTarget\n  let handler = O.ProxyHandler\n  assert (? handler: Record[Object])\n  call %1 = clo<\"GetMethod\">(handler, \"getOwnPropertyDescriptor\")\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let trap = %1\n  if (= trap undefined) {\n    call %2 = target.GetOwnProperty(target, P)\n    assert (? %2: Completion)\n    return %2\n  }\n  call %3 = clo<\"Call\">(trap, handler, (list [target, P])[#459])\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let trapResultObj = %3\n  if (&& (! (? trapResultObj: Record[Object])) (! (= trapResultObj undefined))) {\n    call %4 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %5 = clo<\"ThrowCompletion\">(%4)\n    return %5\n  }\n  call %6 = target.GetOwnProperty(target, P)\n  assert (? %6: Completion)\n  if (? %6: Abrupt) return %6\n  else %6 = %6.Value\n  let targetDesc = %6\n  if (= trapResultObj undefined) {\n    if (= targetDesc undefined) {\n      call %7 = clo<\"NormalCompletion\">(undefined)\n      return %7\n    }\n    if (= targetDesc.Configurable false) {\n      call %8 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %9 = clo<\"ThrowCompletion\">(%8)\n      return %9\n    }\n    call %10 = clo<\"IsExtensible\">(target)\n    assert (? %10: Completion)\n    if (? %10: Abrupt) return %10\n    else %10 = %10.Value\n    let extensibleTarget = %10\n    if (= extensibleTarget false) {\n      call %11 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %12 = clo<\"ThrowCompletion\">(%11)\n      return %12\n    }\n    call %13 = clo<\"NormalCompletion\">(undefined)\n    return %13\n  }\n  call %14 = clo<\"IsExtensible\">(target)\n  assert (? %14: Completion)\n  if (? %14: Abrupt) return %14\n  else %14 = %14.Value\n  let extensibleTarget = %14\n  call %15 = clo<\"ToPropertyDescriptor\">(trapResultObj)\n  assert (? %15: Completion)\n  if (? %15: Abrupt) return %15\n  else %15 = %15.Value\n  let resultDesc = %15\n  call %16 = clo<\"CompletePropertyDescriptor\">(resultDesc)\n  call %17 = clo<\"IsCompatiblePropertyDescriptor\">(extensibleTarget, resultDesc, targetDesc)\n  let valid = %17\n  if (= valid false) {\n    call %18 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %19 = clo<\"ThrowCompletion\">(%18)\n    return %19\n  }\n  if (= resultDesc.Configurable false) {\n    if (|| (= targetDesc undefined) (= targetDesc.Configurable true)) {\n      call %20 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %21 = clo<\"ThrowCompletion\">(%20)\n      return %21\n    }\n    if (&& (exists resultDesc.Writable) (= resultDesc.Writable false)) {\n      assert (exists targetDesc.Writable)\n      if (= targetDesc.Writable true) {\n        call %22 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n        call %23 = clo<\"ThrowCompletion\">(%22)\n        return %23\n      }\n    }\n  }\n  if (? resultDesc: Completion) return resultDesc\n  call %24 = clo<\"NormalCompletion\">(resultDesc)\n  return %24\n}","def <INTERNAL>:Record[ProxyExoticObject].DefineOwnProperty(\n  O: Record[ProxyExoticObject],\n  P: Record[Symbol] | String,\n  Desc: Record[PropertyDescriptor],\n): Normal[Boolean] | Throw = {\n  call %0 = clo<\"ValidateNonRevokedProxy\">(O)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let target = O.ProxyTarget\n  let handler = O.ProxyHandler\n  assert (? handler: Record[Object])\n  call %1 = clo<\"GetMethod\">(handler, \"defineProperty\")\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let trap = %1\n  if (= trap undefined) {\n    call %2 = target.DefineOwnProperty(target, P, Desc)\n    assert (? %2: Completion)\n    return %2\n  }\n  call %3 = clo<\"FromPropertyDescriptor\">(Desc)\n  let descObj = %3\n  call %4 = clo<\"Call\">(trap, handler, (list [target, P, descObj])[#460])\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  call %5 = clo<\"ToBoolean\">(%4)\n  let booleanTrapResult = %5\n  if (= booleanTrapResult false) {\n    call %6 = clo<\"NormalCompletion\">(false)\n    return %6\n  }\n  call %7 = target.GetOwnProperty(target, P)\n  assert (? %7: Completion)\n  if (? %7: Abrupt) return %7\n  else %7 = %7.Value\n  let targetDesc = %7\n  call %8 = clo<\"IsExtensible\">(target)\n  assert (? %8: Completion)\n  if (? %8: Abrupt) return %8\n  else %8 = %8.Value\n  let extensibleTarget = %8\n  if (&& (exists Desc.Configurable) (= Desc.Configurable false)) {\n    let settingConfigFalse = true\n  } else {\n    let settingConfigFalse = false\n  }\n  if (= targetDesc undefined) {\n    if (= extensibleTarget false) {\n      call %9 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %10 = clo<\"ThrowCompletion\">(%9)\n      return %10\n    }\n    if (= settingConfigFalse true) {\n      call %11 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %12 = clo<\"ThrowCompletion\">(%11)\n      return %12\n    }\n  } else {\n    call %13 = clo<\"IsCompatiblePropertyDescriptor\">(extensibleTarget, Desc, targetDesc)\n    if (= %13 false) {\n      call %14 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %15 = clo<\"ThrowCompletion\">(%14)\n      return %15\n    }\n    if (&& (= settingConfigFalse true) (= targetDesc.Configurable true)) {\n      call %16 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %17 = clo<\"ThrowCompletion\">(%16)\n      return %17\n    }\n    call %18 = clo<\"IsDataDescriptor\">(targetDesc)\n    if (&& (= %18 true) (&& (= targetDesc.Configurable false) (= targetDesc.Writable true))) {\n      if (&& (exists Desc.Writable) (= Desc.Writable false)) {\n        call %19 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n        call %20 = clo<\"ThrowCompletion\">(%19)\n        return %20\n      }\n    }\n  }\n  call %21 = clo<\"NormalCompletion\">(true)\n  return %21\n}","def <INTERNAL>:Record[ProxyExoticObject].HasProperty(\n  O: Record[ProxyExoticObject],\n  P: Record[Symbol] | String,\n): Normal[Boolean] | Throw = {\n  call %0 = clo<\"ValidateNonRevokedProxy\">(O)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let target = O.ProxyTarget\n  let handler = O.ProxyHandler\n  assert (? handler: Record[Object])\n  call %1 = clo<\"GetMethod\">(handler, \"has\")\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let trap = %1\n  if (= trap undefined) {\n    call %2 = target.HasProperty(target, P)\n    assert (? %2: Completion)\n    return %2\n  }\n  call %3 = clo<\"Call\">(trap, handler, (list [target, P])[#461])\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  call %4 = clo<\"ToBoolean\">(%3)\n  let booleanTrapResult = %4\n  if (= booleanTrapResult false) {\n    call %5 = target.GetOwnProperty(target, P)\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n    let targetDesc = %5\n    if (! (= targetDesc undefined)) {\n      if (= targetDesc.Configurable false) {\n        call %6 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n        call %7 = clo<\"ThrowCompletion\">(%6)\n        return %7\n      }\n      call %8 = clo<\"IsExtensible\">(target)\n      assert (? %8: Completion)\n      if (? %8: Abrupt) return %8\n      else %8 = %8.Value\n      let extensibleTarget = %8\n      if (= extensibleTarget false) {\n        call %9 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n        call %10 = clo<\"ThrowCompletion\">(%9)\n        return %10\n      }\n    }\n  }\n  if (? booleanTrapResult: Completion) return booleanTrapResult\n  call %11 = clo<\"NormalCompletion\">(booleanTrapResult)\n  return %11\n}","def <INTERNAL>:Record[ProxyExoticObject].Get(\n  O: Record[ProxyExoticObject],\n  P: Record[Symbol] | String,\n  Receiver: ESValue,\n): Normal[ESValue] | Throw = {\n  call %0 = clo<\"ValidateNonRevokedProxy\">(O)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let target = O.ProxyTarget\n  let handler = O.ProxyHandler\n  assert (? handler: Record[Object])\n  call %1 = clo<\"GetMethod\">(handler, \"get\")\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let trap = %1\n  if (= trap undefined) {\n    call %2 = target.Get(target, P, Receiver)\n    assert (? %2: Completion)\n    return %2\n  }\n  call %3 = clo<\"Call\">(trap, handler, (list [target, P, Receiver])[#462])\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let trapResult = %3\n  call %4 = target.GetOwnProperty(target, P)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let targetDesc = %4\n  if (&& (! (= targetDesc undefined)) (= targetDesc.Configurable false)) {\n    call %5 = clo<\"IsDataDescriptor\">(targetDesc)\n    if (&& (= %5 true) (= targetDesc.Writable false)) {\n      call %6 = clo<\"SameValue\">(trapResult, targetDesc.Value)\n      if (= %6 false) {\n        call %7 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n        call %8 = clo<\"ThrowCompletion\">(%7)\n        return %8\n      }\n    }\n    call %9 = clo<\"IsAccessorDescriptor\">(targetDesc)\n    if (&& (= %9 true) (= targetDesc.Get undefined)) {\n      if (! (= trapResult undefined)) {\n        call %10 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n        call %11 = clo<\"ThrowCompletion\">(%10)\n        return %11\n      }\n    }\n  }\n  if (? trapResult: Completion) return trapResult\n  call %12 = clo<\"NormalCompletion\">(trapResult)\n  return %12\n}","def <INTERNAL>:Record[ProxyExoticObject].Set(\n  O: Record[ProxyExoticObject],\n  P: Record[Symbol] | String,\n  V: ESValue,\n  Receiver: ESValue,\n): Normal[Boolean] | Throw = {\n  call %0 = clo<\"ValidateNonRevokedProxy\">(O)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let target = O.ProxyTarget\n  let handler = O.ProxyHandler\n  assert (? handler: Record[Object])\n  call %1 = clo<\"GetMethod\">(handler, \"set\")\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let trap = %1\n  if (= trap undefined) {\n    call %2 = target.Set(target, P, V, Receiver)\n    assert (? %2: Completion)\n    return %2\n  }\n  call %3 = clo<\"Call\">(trap, handler, (list [target, P, V, Receiver])[#463])\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  call %4 = clo<\"ToBoolean\">(%3)\n  let booleanTrapResult = %4\n  if (= booleanTrapResult false) {\n    call %5 = clo<\"NormalCompletion\">(false)\n    return %5\n  }\n  call %6 = target.GetOwnProperty(target, P)\n  assert (? %6: Completion)\n  if (? %6: Abrupt) return %6\n  else %6 = %6.Value\n  let targetDesc = %6\n  if (&& (! (= targetDesc undefined)) (= targetDesc.Configurable false)) {\n    call %7 = clo<\"IsDataDescriptor\">(targetDesc)\n    if (&& (= %7 true) (= targetDesc.Writable false)) {\n      call %8 = clo<\"SameValue\">(V, targetDesc.Value)\n      if (= %8 false) {\n        call %9 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n        call %10 = clo<\"ThrowCompletion\">(%9)\n        return %10\n      }\n    }\n    call %11 = clo<\"IsAccessorDescriptor\">(targetDesc)\n    if (= %11 true) {\n      if (= targetDesc.Set undefined) {\n        call %12 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n        call %13 = clo<\"ThrowCompletion\">(%12)\n        return %13\n      }\n    }\n  }\n  call %14 = clo<\"NormalCompletion\">(true)\n  return %14\n}","def <INTERNAL>:Record[ProxyExoticObject].Delete(\n  O: Record[ProxyExoticObject],\n  P: Record[Symbol] | String,\n): Normal[Boolean] | Throw = {\n  call %0 = clo<\"ValidateNonRevokedProxy\">(O)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let target = O.ProxyTarget\n  let handler = O.ProxyHandler\n  assert (? handler: Record[Object])\n  call %1 = clo<\"GetMethod\">(handler, \"deleteProperty\")\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let trap = %1\n  if (= trap undefined) {\n    call %2 = target.Delete(target, P)\n    assert (? %2: Completion)\n    return %2\n  }\n  call %3 = clo<\"Call\">(trap, handler, (list [target, P])[#464])\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  call %4 = clo<\"ToBoolean\">(%3)\n  let booleanTrapResult = %4\n  if (= booleanTrapResult false) {\n    call %5 = clo<\"NormalCompletion\">(false)\n    return %5\n  }\n  call %6 = target.GetOwnProperty(target, P)\n  assert (? %6: Completion)\n  if (? %6: Abrupt) return %6\n  else %6 = %6.Value\n  let targetDesc = %6\n  if (= targetDesc undefined) {\n    call %7 = clo<\"NormalCompletion\">(true)\n    return %7\n  }\n  if (= targetDesc.Configurable false) {\n    call %8 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %9 = clo<\"ThrowCompletion\">(%8)\n    return %9\n  }\n  call %10 = clo<\"IsExtensible\">(target)\n  assert (? %10: Completion)\n  if (? %10: Abrupt) return %10\n  else %10 = %10.Value\n  let extensibleTarget = %10\n  if (= extensibleTarget false) {\n    call %11 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %12 = clo<\"ThrowCompletion\">(%11)\n    return %12\n  }\n  call %13 = clo<\"NormalCompletion\">(true)\n  return %13\n}","def <INTERNAL>:Record[ProxyExoticObject].OwnPropertyKeys(\n  O: Record[ProxyExoticObject],\n): Normal[List[Record[Symbol] | String]] | Throw = {\n  call %0 = clo<\"ValidateNonRevokedProxy\">(O)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let target = O.ProxyTarget\n  let handler = O.ProxyHandler\n  assert (? handler: Record[Object])\n  call %1 = clo<\"GetMethod\">(handler, \"ownKeys\")\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let trap = %1\n  if (= trap undefined) {\n    call %2 = target.OwnPropertyKeys(target)\n    assert (? %2: Completion)\n    return %2\n  }\n  call %3 = clo<\"Call\">(trap, handler, (list [target])[#465])\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let trapResultArray = %3\n  call %4 = clo<\"CreateListFromArrayLike\">(trapResultArray, (list [@String, @Symbol])[#466])\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let trapResult = %4\n  call %5 = clo<\"__HAS_DUPLICATE__\">(trapResult)\n  if %5 {\n    call %6 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %7 = clo<\"ThrowCompletion\">(%6)\n    return %7\n  }\n  call %8 = clo<\"IsExtensible\">(target)\n  assert (? %8: Completion)\n  if (? %8: Abrupt) return %8\n  else %8 = %8.Value\n  let extensibleTarget = %8\n  call %9 = target.OwnPropertyKeys(target)\n  assert (? %9: Completion)\n  if (? %9: Abrupt) return %9\n  else %9 = %9.Value\n  let targetKeys = %9\n  assert (? targetKeys: List[Record[Symbol] | String])\n  call %10 = clo<\"__HAS_DUPLICATE__\">(targetKeys)\n  assert (! %10)\n  let targetConfigurableKeys = (list [])[#467]\n  let targetNonconfigurableKeys = (list [])[#468]\n  %12 = targetKeys\n  %11 = 0\n  while (< %11 (sizeof %12)) {\n    let key = %12[%11]\n    call %13 = target.GetOwnProperty(target, key)\n    assert (? %13: Completion)\n    if (? %13: Abrupt) return %13\n    else %13 = %13.Value\n    let desc = %13\n    if (&& (! (= desc undefined)) (= desc.Configurable false)) {\n      push targetNonconfigurableKeys < key\n    } else {\n      push targetConfigurableKeys < key\n    }\n    %11 = (+ %11 1)\n  }\n  if (&& (= extensibleTarget true) (= (sizeof targetNonconfigurableKeys) 0)) {\n    if (? trapResult: Completion) return trapResult\n    call %14 = clo<\"NormalCompletion\">(trapResult)\n    return %14\n  }\n  let uncheckedResultKeys = (copy trapResult)[#469]\n  %16 = targetNonconfigurableKeys\n  %15 = 0\n  while (< %15 (sizeof %16)) {\n    let key = %16[%15]\n    if (! (contains uncheckedResultKeys key)) {\n      call %17 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %18 = clo<\"ThrowCompletion\">(%17)\n      return %18\n    }\n    call %19 = clo<\"__REMOVE_ELEM__\">(key, uncheckedResultKeys)\n    %15 = (+ %15 1)\n  }\n  if (= extensibleTarget true) {\n    if (? trapResult: Completion) return trapResult\n    call %20 = clo<\"NormalCompletion\">(trapResult)\n    return %20\n  }\n  %22 = targetConfigurableKeys\n  %21 = 0\n  while (< %21 (sizeof %22)) {\n    let key = %22[%21]\n    if (! (contains uncheckedResultKeys key)) {\n      call %23 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %24 = clo<\"ThrowCompletion\">(%23)\n      return %24\n    }\n    call %25 = clo<\"__REMOVE_ELEM__\">(key, uncheckedResultKeys)\n    %21 = (+ %21 1)\n  }\n  if (! (= (sizeof uncheckedResultKeys) 0)) {\n    call %26 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %27 = clo<\"ThrowCompletion\">(%26)\n    return %27\n  }\n  if (? trapResult: Completion) return trapResult\n  call %28 = clo<\"NormalCompletion\">(trapResult)\n  return %28\n}","def <INTERNAL>:Record[ProxyExoticObject].Call(\n  O: Record[ProxyExoticObject],\n  thisArgument: ESValue,\n  argumentsList: List[ESValue],\n): Normal[ESValue] | Throw = {\n  call %0 = clo<\"ValidateNonRevokedProxy\">(O)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let target = O.ProxyTarget\n  let handler = O.ProxyHandler\n  assert (? handler: Record[Object])\n  call %1 = clo<\"GetMethod\">(handler, \"apply\")\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let trap = %1\n  if (= trap undefined) {\n    call %2 = clo<\"Call\">(target, thisArgument, argumentsList)\n    assert (? %2: Completion)\n    return %2\n  }\n  call %3 = clo<\"CreateArrayFromList\">(argumentsList)\n  let argArray = %3\n  call %4 = clo<\"Call\">(trap, handler, (list [target, thisArgument, argArray])[#470])\n  assert (? %4: Completion)\n  return %4\n}","def <INTERNAL>:Record[ProxyExoticObject].Construct(\n  O: Record[ProxyExoticObject],\n  argumentsList: List[ESValue],\n  newTarget: Record[Constructor],\n): Normal[Record[Object]] | Throw = {\n  call %0 = clo<\"ValidateNonRevokedProxy\">(O)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let target = O.ProxyTarget\n  call %1 = clo<\"IsConstructor\">(target)\n  assert (= %1 true)\n  let handler = O.ProxyHandler\n  assert (? handler: Record[Object])\n  call %2 = clo<\"GetMethod\">(handler, \"construct\")\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let trap = %2\n  if (= trap undefined) {\n    call %3 = clo<\"Construct\">(target, argumentsList, newTarget)\n    assert (? %3: Completion)\n    return %3\n  }\n  call %4 = clo<\"CreateArrayFromList\">(argumentsList)\n  let argArray = %4\n  call %5 = clo<\"Call\">(trap, handler, (list [target, argArray, newTarget])[#471])\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  let newObj = %5\n  if (! (? newObj: Record[Object])) {\n    call %6 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %7 = clo<\"ThrowCompletion\">(%6)\n    return %7\n  }\n  if (? newObj: Completion) return newObj\n  call %8 = clo<\"NormalCompletion\">(newObj)\n  return %8\n}","def ValidateNonRevokedProxy(\n  proxy: Record[ProxyExoticObject],\n): Normal[Enum[~unused~]] | Throw = {\n  if (= proxy.ProxyTarget null) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  assert (! (= proxy.ProxyHandler null))\n  call %2 = clo<\"NormalCompletion\">(~unused~)\n  return %2\n}","def ProxyCreate(\n  target: ESValue,\n  handler: ESValue,\n): Normal[Record[ProxyExoticObject]] | Throw = {\n  if (! (? target: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  if (! (? handler: Record[Object])) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  call %4 = clo<\"MakeBasicObject\">((list [\"ProxyHandler\", \"ProxyTarget\"])[#472])\n  let P = %4\n  P.GetPrototypeOf = clo<\"Record[ProxyExoticObject].GetPrototypeOf\">\n  P.SetPrototypeOf = clo<\"Record[ProxyExoticObject].SetPrototypeOf\">\n  P.IsExtensible = clo<\"Record[ProxyExoticObject].IsExtensible\">\n  P.PreventExtensions = clo<\"Record[ProxyExoticObject].PreventExtensions\">\n  P.GetOwnProperty = clo<\"Record[ProxyExoticObject].GetOwnProperty\">\n  P.DefineOwnProperty = clo<\"Record[ProxyExoticObject].DefineOwnProperty\">\n  P.HasProperty = clo<\"Record[ProxyExoticObject].HasProperty\">\n  P.Get = clo<\"Record[ProxyExoticObject].Get\">\n  P.Set = clo<\"Record[ProxyExoticObject].Set\">\n  P.Delete = clo<\"Record[ProxyExoticObject].Delete\">\n  P.OwnPropertyKeys = clo<\"Record[ProxyExoticObject].OwnPropertyKeys\">\n  call %5 = clo<\"IsCallable\">(target)\n  if (= %5 true) {\n    P.Call = clo<\"Record[ProxyExoticObject].Call\">\n    call %6 = clo<\"IsConstructor\">(target)\n    if (= %6 true) {\n      P.Construct = clo<\"Record[ProxyExoticObject].Construct\">\n    }\n  }\n  P.ProxyTarget = target\n  P.ProxyHandler = handler\n  if (? P: Completion) return P\n  call %7 = clo<\"NormalCompletion\">(P)\n  return %7\n}","def UTF16EncodeCodePoint(\n  cp: Unknown[\"UnicodeCodePoint\"],\n): String = {\n  assert (yet \"0 ‚â§ _cp_ ‚â§ 0x10FFFF.\")\n  if (! (< 65535 cp)) {\n    (yet \"return the String value consisting of the code unit whose numeric value is _cp_.\")\n  }\n  (yet \"Let _cu1_ be the code unit whose numeric value is floor((_cp_ - 0x10000) / 0x400) + 0xD800.\")\n  (yet \"Let _cu2_ be the code unit whose numeric value is ((_cp_ - 0x10000) modulo 0x400) + 0xDC00.\")\n  return (concat cu1 cu2)\n}","def CodePointsToString(\n  text: Unknown[\"SequenceOfUnicodeCodePoint\"],\n): String = {\n  let result = \"\"\n  (yet \"For each code point _cp_ of _text_, do\\n  1. Set _result_ to the string-concatenation of _result_ and UTF16EncodeCodePoint(_cp_).\")\n  return result\n}","def UTF16SurrogatePairToCodePoint(\n  lead: Unknown[\"CodeUnit\"],\n  trail: Unknown[\"CodeUnit\"],\n): Unknown[\"CodePoint\"] = {\n  assert (yet \"_lead_ is a leading surrogate and _trail_ is a trailing surrogate.\")\n  let cp = (+ (+ (* (- lead 55296) 1024) (- trail 56320)) 65536)\n  (yet \"Return the code point _cp_.\")\n}","def CodePointAt(\n  string: String,\n  position: NonNegInt,\n): Unknown[\"RecordWithFields[[CodePoint]](aCodePoint),[[CodeUnitCount]](aPositiveInteger),And[[IsUnpairedSurrogate]](aBoolean)\"] = {\n  let size = (sizeof string)\n  assert (&& (! (< position 0)) (< position size))\n  let first = string[position]\n  (yet \"Let _cp_ be the code point whose numeric value is the numeric value of _first_.\")\n  (yet \"If _first_ is neither a leading surrogate nor a trailing surrogate, then\\n  1. Return Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *false* }.\")\n  (yet \"If _first_ is a trailing surrogate or _position_ + 1 = _size_, then\\n  1. Return Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *true* }.\")\n  let second = string[(+ position 1)]\n  (yet \"If _second_ is not a trailing surrogate, then\\n  1. Return Record { [[CodePoint]]: _cp_, [[CodeUnitCount]]: 1, [[IsUnpairedSurrogate]]: *true* }.\")\n  call %0 = clo<\"UTF16SurrogatePairToCodePoint\">(first, second)\n  cp = %0\n  return (record {\n    \"CodePoint\" : cp,\n    \"CodeUnitCount\" : 2,\n    \"IsUnpairedSurrogate\" : false,\n  })[#473]\n}","def ParseText(\n  sourceText: Unknown[\"SequenceOfUnicodeCodePoint\"],\n  goalSymbol: Unknown[\"NonterminalInOneOfTheECMAScriptGrammar\"],\n): Unknown[\"ParseNodeOrANonemptyListOf*SyntaxError*Object\"] = {\n  (yet \"Attempt to parse _sourceText_ using _goalSymbol_ as the goal symbol, and analyse the parse result for any early error conditions. Parsing and early error detection may be interleaved in an implementation-defined manner.\")\n  (yet \"If the parse succeeded and no early errors were found, return the Parse Node (an instance of _goalSymbol_) at the root of the parse tree resulting from the parse.\")\n  (yet \"Otherwise, return a List of one or more *SyntaxError* objects representing the parsing errors and/or early errors. If more than one parsing error or early error is present, the number and ordering of error objects in the list is implementation-defined, but at least one must be present.\")\n}","def <SYNTAX>:IdentifierName[0,0].IdentifierCodePoints(\n  this: Ast[IdentifierName[0]],\n): Unknown[\"ListOfCodePoint\"] = {\n  sdo-call %0 = this[0]->IdentifierCodePoint()\n  let cp = %0\n  return (list [cp])[#474]\n}","def <SYNTAX>:IdentifierName[1,0].IdentifierCodePoints(\n  this: Ast[IdentifierName[1]],\n): Unknown[\"ListOfCodePoint\"] = {\n  (yet \"Let _cps_ be IdentifierCodePoints of the derived |IdentifierName|.\")\n  sdo-call %0 = this[1]->IdentifierCodePoint()\n  let cp = %0\n  call %1 = clo<\"__FLAT_LIST__\">((list [cps, (list [cp])[#476]])[#475])\n  return %1\n}","def <SYNTAX>:IdentifierStart[0,0].IdentifierCodePoint(\n  this: Ast[IdentifierStart[0]],\n): Unknown[\"CodePoint\"] = {\n  (yet \"Return the code point matched by |IdentifierStartChar|.\")\n}","def <SYNTAX>:IdentifierPart[0,0].IdentifierCodePoint(\n  this: Ast[IdentifierPart[0]],\n): Unknown[\"CodePoint\"] = {\n  (yet \"Return the code point matched by |IdentifierPartChar|.\")\n}","def <SYNTAX>:UnicodeEscapeSequence[0,0].IdentifierCodePoint(\n  this: Ast[UnicodeEscapeSequence[0]],\n): Unknown[\"CodePoint\"] = {\n  (yet \"Return the code point whose numeric value is the MV of |Hex4Digits|.\")\n}","def <SYNTAX>:UnicodeEscapeSequence[1,0].IdentifierCodePoint(\n  this: Ast[UnicodeEscapeSequence[1]],\n): Unknown[\"CodePoint\"] = {\n  (yet \"Return the code point whose numeric value is the MV of |CodePoint|.\")\n}","def <SYNTAX>:NumericLiteral[0,0].NumericValue(\n  this: Ast[NumericLiteral[0]],\n): Number | BigInt = {\n  sdo-call %0 = this[0]->MV()\n  call %1 = clo<\"RoundMVResult\">(%0)\n  return %1\n}","def <SYNTAX>:NumericLiteral[2,0].NumericValue(\n  this: Ast[NumericLiteral[2]],\n): Number | BigInt = {\n  sdo-call %0 = this[0]->MV()\n  return ([number] %0)\n}","def <SYNTAX>:NumericLiteral[4,0].NumericValue(\n  this: Ast[NumericLiteral[4]],\n): Number | BigInt = {\n  sdo-call %0 = this[0]->MV()\n  return ([number] %0)\n}","def <SYNTAX>:NumericLiteral[3,0].NumericValue(\n  this: Ast[NumericLiteral[3]],\n): Number | BigInt = {\n  sdo-call %0 = this[0]->MV()\n  return ([bigInt] %0)\n}","def <SYNTAX>:DecimalBigIntegerLiteral[0,0].NumericValue(\n  this: Ast[DecimalBigIntegerLiteral[0]],\n): Number | BigInt = {\n  return 0n\n}","def <SYNTAX>:DecimalBigIntegerLiteral[1,0].NumericValue(\n  this: Ast[DecimalBigIntegerLiteral[1]],\n): Number | BigInt = {\n  sdo-call %0 = this[0]->MV()\n  return ([bigInt] %0)\n}","def <SYNTAX>:DecimalBigIntegerLiteral[1,1].NumericValue(\n  this: Ast[DecimalBigIntegerLiteral[1]],\n): Number | BigInt = {\n  (yet \"Let _n_ be the number of code points in |DecimalDigits|, excluding all occurrences of |NumericLiteralSeparator|.\")\n  (yet \"Let _mv_ be (the MV of |NonZeroDigit| √ó 10<sup>_n_</sup>) plus the MV of |DecimalDigits|.\")\n  return ([bigInt] mv)\n}","def <SYNTAX>:DecimalBigIntegerLiteral[2,0].NumericValue(\n  this: Ast[DecimalBigIntegerLiteral[2]],\n): Number | BigInt = {\n  (yet \"Let _n_ be the number of code points in |DecimalDigits|, excluding all occurrences of |NumericLiteralSeparator|.\")\n  (yet \"Let _mv_ be (the MV of |NonZeroDigit| √ó 10<sup>_n_</sup>) plus the MV of |DecimalDigits|.\")\n  return ([bigInt] mv)\n}","def <SYNTAX>:RegularExpressionLiteral[0,0].BodyText(\n  this: Ast[RegularExpressionLiteral[0]],\n): Unknown[\"SourceText\"] = {\n  (yet \"Return the source text that was recognized as |RegularExpressionBody|.\")\n}","def <SYNTAX>:RegularExpressionLiteral[0,0].FlagText(\n  this: Ast[RegularExpressionLiteral[0]],\n): Unknown[\"SourceText\"] = {\n  (yet \"Return the source text that was recognized as |RegularExpressionFlags|.\")\n}","def <SYNTAX>:IdentifierName[0,0].StringValue(\n  this: Ast[IdentifierName[0]],\n): String = {\n  sdo-call %0 = this->IdentifierCodePoints()\n  let idTextUnescaped = %0\n  call %1 = clo<\"CodePointsToString\">(idTextUnescaped)\n  return %1\n}","def <SYNTAX>:IdentifierName[1,0].StringValue(\n  this: Ast[IdentifierName[1]],\n): String = {\n  sdo-call %0 = this[0]->IdentifierCodePoints()\n  let idTextUnescaped = %0\n  call %1 = clo<\"CodePointsToString\">(idTextUnescaped)\n  return %1\n}","def <SYNTAX>:IdentifierReference[1,0].StringValue(\n  this: Ast[IdentifierReference[1]],\n): String = {\n  return \"yield\"\n}","def <SYNTAX>:BindingIdentifier[1,0].StringValue(\n  this: Ast[BindingIdentifier[1]],\n): String = {\n  return \"yield\"\n}","def <SYNTAX>:LabelIdentifier[1,0].StringValue(\n  this: Ast[LabelIdentifier[1]],\n): String = {\n  return \"yield\"\n}","def <SYNTAX>:IdentifierReference[2,0].StringValue(\n  this: Ast[IdentifierReference[2]],\n): String = {\n  return \"await\"\n}","def <SYNTAX>:BindingIdentifier[2,0].StringValue(\n  this: Ast[BindingIdentifier[2]],\n): String = {\n  return \"await\"\n}","def <SYNTAX>:LabelIdentifier[2,0].StringValue(\n  this: Ast[LabelIdentifier[2]],\n): String = {\n  return \"await\"\n}","def <SYNTAX>:Identifier[0,0].StringValue(\n  this: Ast[Identifier[0]],\n): String = {\n  sdo-call %0 = this[0]->StringValue()\n  return %0\n}","def <SYNTAX>:PrivateIdentifier[0,0].StringValue(\n  this: Ast[PrivateIdentifier[0]],\n): String = {\n  sdo-call %0 = this[0]->StringValue()\n  return (concat 35cu %0)\n}","def <SYNTAX>:ModuleExportName[1,0].StringValue(\n  this: Ast[ModuleExportName[1]],\n): String = {\n  sdo-call %0 = this[0]->SV()\n  return %0\n}","def <SYNTAX>:IdentifierReference[0,0].Evaluation(\n  this: Ast[IdentifierReference[0]],\n): Unknown = {\n  sdo-call %0 = this[0]->StringValue()\n  call %1 = clo<\"ResolveBinding\">(%0)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:IdentifierReference[1,0].Evaluation(\n  this: Ast[IdentifierReference[1]],\n): Unknown = {\n  call %0 = clo<\"ResolveBinding\">(\"yield\")\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:IdentifierReference[2,0].Evaluation(\n  this: Ast[IdentifierReference[2]],\n): Unknown = {\n  call %0 = clo<\"ResolveBinding\">(\"await\")\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:PrimaryExpression[0,0].Evaluation(\n  this: Ast[PrimaryExpression[0]],\n): Unknown = {\n  call %0 = clo<\"ResolveThisBinding\">()\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:Literal[0,0].Evaluation(\n  this: Ast[Literal[0]],\n): Unknown = {\n  call %0 = clo<\"NormalCompletion\">(null)\n  return %0\n}","def <SYNTAX>:Literal[1,0].Evaluation(\n  this: Ast[Literal[1]],\n): Unknown = {\n  if (= (source-text this[0]) \"false\") {\n    call %0 = clo<\"NormalCompletion\">(false)\n    return %0\n  }\n  if (= (source-text this[0]) \"true\") {\n    call %1 = clo<\"NormalCompletion\">(true)\n    return %1\n  }\n}","def <SYNTAX>:Literal[2,0].Evaluation(\n  this: Ast[Literal[2]],\n): Unknown = {\n  sdo-call %0 = this[0]->NumericValue()\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:Literal[3,0].Evaluation(\n  this: Ast[Literal[3]],\n): Unknown = {\n  sdo-call %0 = this[0]->SV()\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:Elision[0,0].ArrayAccumulation(\n  this: Ast[Elision[0]],\n  array: Record[Array],\n  nextIndex: Int,\n): Normal[Int] | Abrupt = {\n  let len = (+ nextIndex 1)\n  call %0 = clo<\"Set\">(array, \"length\", ([number] len), true)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  nop\n  if (? len: Completion) return len\n  call %1 = clo<\"NormalCompletion\">(len)\n  return %1\n}","def <SYNTAX>:Elision[1,0].ArrayAccumulation(\n  this: Ast[Elision[1]],\n  array: Record[Array],\n  nextIndex: Int,\n): Normal[Int] | Abrupt = {\n  sdo-call %0 = this[0]->ArrayAccumulation(array, (+ nextIndex 1))\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:ElementList[0,0].ArrayAccumulation(\n  this: Ast[ElementList[0]],\n  array: Record[Array],\n  nextIndex: Int,\n): Normal[Int] | Abrupt = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->ArrayAccumulation(array, nextIndex)\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    nextIndex = %0\n  }\n  sdo-call %1 = this[1]->Evaluation()\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let initResult = %1\n  call %2 = clo<\"GetValue\">(initResult)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let initValue = %2\n  call %3 = clo<\"ToString\">(([number] nextIndex))\n  assert (? %3: Normal)\n  %3 = %3.Value\n  call %4 = clo<\"CreateDataPropertyOrThrow\">(array, %3, initValue)\n  assert (? %4: Normal)\n  %4 = %4.Value\n  %5 = (+ nextIndex 1)\n  if (? %5: Completion) return %5\n  call %6 = clo<\"NormalCompletion\">(%5)\n  return %6\n}","def <SYNTAX>:ElementList[0,1].ArrayAccumulation(\n  this: Ast[ElementList[0]],\n  array: Record[Array],\n  nextIndex: Int,\n): Normal[Int] | Abrupt = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->ArrayAccumulation(array, nextIndex)\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    nextIndex = %0\n  }\n  sdo-call %1 = this[1]->Evaluation()\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let initResult = %1\n  call %2 = clo<\"GetValue\">(initResult)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let initValue = %2\n  call %3 = clo<\"ToString\">(([number] nextIndex))\n  assert (? %3: Normal)\n  %3 = %3.Value\n  call %4 = clo<\"CreateDataPropertyOrThrow\">(array, %3, initValue)\n  assert (? %4: Normal)\n  %4 = %4.Value\n  %5 = (+ nextIndex 1)\n  if (? %5: Completion) return %5\n  call %6 = clo<\"NormalCompletion\">(%5)\n  return %6\n}","def <SYNTAX>:ElementList[1,0].ArrayAccumulation(\n  this: Ast[ElementList[1]],\n  array: Record[Array],\n  nextIndex: Int,\n): Normal[Int] | Abrupt = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->ArrayAccumulation(array, nextIndex)\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    nextIndex = %0\n  }\n  sdo-call %1 = this[1]->ArrayAccumulation(array, nextIndex)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:ElementList[1,1].ArrayAccumulation(\n  this: Ast[ElementList[1]],\n  array: Record[Array],\n  nextIndex: Int,\n): Normal[Int] | Abrupt = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->ArrayAccumulation(array, nextIndex)\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    nextIndex = %0\n  }\n  sdo-call %1 = this[1]->ArrayAccumulation(array, nextIndex)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:ElementList[2,0].ArrayAccumulation(\n  this: Ast[ElementList[2]],\n  array: Record[Array],\n  nextIndex: Int,\n): Normal[Int] | Abrupt = {\n  sdo-call %0 = this[0]->ArrayAccumulation(array, nextIndex)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  nextIndex = %0\n  if (exists this[1]) {\n    sdo-call %1 = this[1]->ArrayAccumulation(array, nextIndex)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    nextIndex = %1\n  }\n  sdo-call %2 = this[2]->Evaluation()\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let initResult = %2\n  call %3 = clo<\"GetValue\">(initResult)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let initValue = %3\n  call %4 = clo<\"ToString\">(([number] nextIndex))\n  assert (? %4: Normal)\n  %4 = %4.Value\n  call %5 = clo<\"CreateDataPropertyOrThrow\">(array, %4, initValue)\n  assert (? %5: Normal)\n  %5 = %5.Value\n  %6 = (+ nextIndex 1)\n  if (? %6: Completion) return %6\n  call %7 = clo<\"NormalCompletion\">(%6)\n  return %7\n}","def <SYNTAX>:ElementList[2,1].ArrayAccumulation(\n  this: Ast[ElementList[2]],\n  array: Record[Array],\n  nextIndex: Int,\n): Normal[Int] | Abrupt = {\n  sdo-call %0 = this[0]->ArrayAccumulation(array, nextIndex)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  nextIndex = %0\n  if (exists this[1]) {\n    sdo-call %1 = this[1]->ArrayAccumulation(array, nextIndex)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    nextIndex = %1\n  }\n  sdo-call %2 = this[2]->Evaluation()\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let initResult = %2\n  call %3 = clo<\"GetValue\">(initResult)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let initValue = %3\n  call %4 = clo<\"ToString\">(([number] nextIndex))\n  assert (? %4: Normal)\n  %4 = %4.Value\n  call %5 = clo<\"CreateDataPropertyOrThrow\">(array, %4, initValue)\n  assert (? %5: Normal)\n  %5 = %5.Value\n  %6 = (+ nextIndex 1)\n  if (? %6: Completion) return %6\n  call %7 = clo<\"NormalCompletion\">(%6)\n  return %7\n}","def <SYNTAX>:ElementList[3,0].ArrayAccumulation(\n  this: Ast[ElementList[3]],\n  array: Record[Array],\n  nextIndex: Int,\n): Normal[Int] | Abrupt = {\n  sdo-call %0 = this[0]->ArrayAccumulation(array, nextIndex)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  nextIndex = %0\n  if (exists this[1]) {\n    sdo-call %1 = this[1]->ArrayAccumulation(array, nextIndex)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    nextIndex = %1\n  }\n  sdo-call %2 = this[2]->ArrayAccumulation(array, nextIndex)\n  assert (? %2: Completion)\n  return %2\n}","def <SYNTAX>:ElementList[3,1].ArrayAccumulation(\n  this: Ast[ElementList[3]],\n  array: Record[Array],\n  nextIndex: Int,\n): Normal[Int] | Abrupt = {\n  sdo-call %0 = this[0]->ArrayAccumulation(array, nextIndex)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  nextIndex = %0\n  if (exists this[1]) {\n    sdo-call %1 = this[1]->ArrayAccumulation(array, nextIndex)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    nextIndex = %1\n  }\n  sdo-call %2 = this[2]->ArrayAccumulation(array, nextIndex)\n  assert (? %2: Completion)\n  return %2\n}","def <SYNTAX>:SpreadElement[0,0].ArrayAccumulation(\n  this: Ast[SpreadElement[0]],\n  array: Record[Array],\n  nextIndex: Int,\n): Normal[Int] | Abrupt = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let spreadRef = %0\n  call %1 = clo<\"GetValue\">(spreadRef)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let spreadObj = %1\n  call %2 = clo<\"GetIterator\">(spreadObj, ~sync~)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let iteratorRecord = %2\n  while true {\n    call %3 = clo<\"IteratorStepValue\">(iteratorRecord)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let next = %3\n    if (= next ~done~) {\n      if (? nextIndex: Completion) return nextIndex\n      call %4 = clo<\"NormalCompletion\">(nextIndex)\n      return %4\n    }\n    call %5 = clo<\"ToString\">(([number] nextIndex))\n    assert (? %5: Normal)\n    %5 = %5.Value\n    call %6 = clo<\"CreateDataPropertyOrThrow\">(array, %5, next)\n    assert (? %6: Normal)\n    %6 = %6.Value\n    nextIndex = (+ nextIndex 1)\n  }\n}","def <SYNTAX>:ArrayLiteral[0,0].Evaluation(\n  this: Ast[ArrayLiteral[0]],\n): Unknown = {\n  call %0 = clo<\"ArrayCreate\">(0)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let array = %0\n  if (exists this[0]) {\n    sdo-call %1 = this[0]->ArrayAccumulation(array, 0)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n  }\n  if (? array: Completion) return array\n  call %2 = clo<\"NormalCompletion\">(array)\n  return %2\n}","def <SYNTAX>:ArrayLiteral[0,1].Evaluation(\n  this: Ast[ArrayLiteral[0]],\n): Unknown = {\n  call %0 = clo<\"ArrayCreate\">(0)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let array = %0\n  if (exists this[0]) {\n    sdo-call %1 = this[0]->ArrayAccumulation(array, 0)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n  }\n  if (? array: Completion) return array\n  call %2 = clo<\"NormalCompletion\">(array)\n  return %2\n}","def <SYNTAX>:ArrayLiteral[1,0].Evaluation(\n  this: Ast[ArrayLiteral[1]],\n): Unknown = {\n  call %0 = clo<\"ArrayCreate\">(0)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let array = %0\n  sdo-call %1 = this[0]->ArrayAccumulation(array, 0)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  if (? array: Completion) return array\n  call %2 = clo<\"NormalCompletion\">(array)\n  return %2\n}","def <SYNTAX>:ArrayLiteral[2,0].Evaluation(\n  this: Ast[ArrayLiteral[2]],\n): Unknown = {\n  call %0 = clo<\"ArrayCreate\">(0)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let array = %0\n  sdo-call %1 = this[0]->ArrayAccumulation(array, 0)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let nextIndex = %1\n  if (exists this[1]) {\n    sdo-call %2 = this[1]->ArrayAccumulation(array, nextIndex)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n  }\n  if (? array: Completion) return array\n  call %3 = clo<\"NormalCompletion\">(array)\n  return %3\n}","def <SYNTAX>:ArrayLiteral[2,1].Evaluation(\n  this: Ast[ArrayLiteral[2]],\n): Unknown = {\n  call %0 = clo<\"ArrayCreate\">(0)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let array = %0\n  sdo-call %1 = this[0]->ArrayAccumulation(array, 0)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let nextIndex = %1\n  if (exists this[1]) {\n    sdo-call %2 = this[1]->ArrayAccumulation(array, nextIndex)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n  }\n  if (? array: Completion) return array\n  call %3 = clo<\"NormalCompletion\">(array)\n  return %3\n}","def <SYNTAX>:PropertyName[0,0].IsComputedPropertyKey(\n  this: Ast[PropertyName[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PropertyName[1,0].IsComputedPropertyKey(\n  this: Ast[PropertyName[1]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:PropertyDefinitionList[0,0].PropertyNameList(\n  this: Ast[PropertyDefinitionList[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->PropName()\n  let propName = %0\n  if (= propName ~empty~) {\n    return (list [])[#477]\n  }\n  return (list [propName])[#478]\n}","def <SYNTAX>:PropertyDefinitionList[1,0].PropertyNameList(\n  this: Ast[PropertyDefinitionList[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->PropertyNameList()\n  let list = %0\n  sdo-call %1 = this[1]->PropName()\n  let propName = %1\n  if (= propName ~empty~) {\n    return list\n  }\n  call %2 = clo<\"__FLAT_LIST__\">((list [list, (list [propName])[#480]])[#479])\n  return %2\n}","def <SYNTAX>:ObjectLiteral[0,0].Evaluation(\n  this: Ast[ObjectLiteral[0]],\n): Unknown = {\n  call %0 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Object.prototype%\"])\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:ObjectLiteral[1,0].Evaluation(\n  this: Ast[ObjectLiteral[1]],\n): Unknown = {\n  call %0 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Object.prototype%\"])\n  let obj = %0\n  sdo-call %1 = this[0]->PropertyDefinitionEvaluation(obj)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  if (? obj: Completion) return obj\n  call %2 = clo<\"NormalCompletion\">(obj)\n  return %2\n}","def <SYNTAX>:ObjectLiteral[2,0].Evaluation(\n  this: Ast[ObjectLiteral[2]],\n): Unknown = {\n  call %0 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Object.prototype%\"])\n  let obj = %0\n  sdo-call %1 = this[0]->PropertyDefinitionEvaluation(obj)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  if (? obj: Completion) return obj\n  call %2 = clo<\"NormalCompletion\">(obj)\n  return %2\n}","def <SYNTAX>:LiteralPropertyName[0,0].Evaluation(\n  this: Ast[LiteralPropertyName[0]],\n): Unknown = {\n  sdo-call %0 = this[0]->StringValue()\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:LiteralPropertyName[1,0].Evaluation(\n  this: Ast[LiteralPropertyName[1]],\n): Unknown = {\n  sdo-call %0 = this[0]->SV()\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:LiteralPropertyName[2,0].Evaluation(\n  this: Ast[LiteralPropertyName[2]],\n): Unknown = {\n  sdo-call %0 = this[0]->NumericValue()\n  let nbr = %0\n  call %1 = clo<\"ToString\">(nbr)\n  assert (? %1: Normal)\n  return %1\n}","def <SYNTAX>:ComputedPropertyName[0,0].Evaluation(\n  this: Ast[ComputedPropertyName[0]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let exprValue = %0\n  call %1 = clo<\"GetValue\">(exprValue)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let propName = %1\n  call %2 = clo<\"ToPropertyKey\">(propName)\n  assert (? %2: Completion)\n  return %2\n}","def <SYNTAX>:PropertyDefinitionList[1,0].PropertyDefinitionEvaluation(\n  this: Ast[PropertyDefinitionList[1]],\n  object: Record[Object],\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->PropertyDefinitionEvaluation(object)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  sdo-call %1 = this[1]->PropertyDefinitionEvaluation(object)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  call %2 = clo<\"NormalCompletion\">(~unused~)\n  return %2\n}","def <SYNTAX>:PropertyDefinition[4,0].PropertyDefinitionEvaluation(\n  this: Ast[PropertyDefinition[4]],\n  object: Record[Object],\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let exprValue = %0\n  call %1 = clo<\"GetValue\">(exprValue)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let fromValue = %1\n  let excludedNames = (list [])[#481]\n  call %2 = clo<\"CopyDataProperties\">(object, fromValue, excludedNames)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  call %3 = clo<\"NormalCompletion\">(~unused~)\n  return %3\n}","def <SYNTAX>:PropertyDefinition[0,0].PropertyDefinitionEvaluation(\n  this: Ast[PropertyDefinition[0]],\n  object: Record[Object],\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->StringValue()\n  let propName = %0\n  sdo-call %1 = this[0]->Evaluation()\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let exprValue = %1\n  call %2 = clo<\"GetValue\">(exprValue)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let propValue = %2\n  assert (yet \"_object_ is an ordinary, extensible object with no non-configurable properties.\")\n  call %3 = clo<\"CreateDataPropertyOrThrow\">(object, propName, propValue)\n  assert (? %3: Normal)\n  %3 = %3.Value\n  call %4 = clo<\"NormalCompletion\">(~unused~)\n  return %4\n}","def <SYNTAX>:PropertyDefinition[2,0].PropertyDefinitionEvaluation(\n  this: Ast[PropertyDefinition[2]],\n  object: Record[Object],\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let propKey = %0\n  if false {\n    let isProtoSetter = false\n  } else {\n    %1 = (= propKey \"__proto__\")\n    if %1 {\n      sdo-call %2 = this[0]->IsComputedPropertyKey()\n      %1 = (= %2 false)\n    }\n    if %1 {\n      let isProtoSetter = true\n    } else {\n      let isProtoSetter = false\n    }\n  }\n  call %3 = clo<\"IsAnonymousFunctionDefinition\">(this[1])\n  if (&& (= %3 true) (= isProtoSetter false)) {\n    sdo-call %4 = this[1]->NamedEvaluation(propKey)\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    let propValue = %4\n  } else {\n    sdo-call %5 = this[1]->Evaluation()\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n    let exprValueRef = %5\n    call %6 = clo<\"GetValue\">(exprValueRef)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    let propValue = %6\n  }\n  if (= isProtoSetter true) {\n    if (|| (? propValue: Record[Object]) (= propValue null)) {\n      call %7 = object.SetPrototypeOf(object, propValue)\n      assert (? %7: Normal)\n      %7 = %7.Value\n    }\n    call %8 = clo<\"NormalCompletion\">(~unused~)\n    return %8\n  }\n  assert (yet \"_object_ is an ordinary, extensible object with no non-configurable properties.\")\n  call %9 = clo<\"CreateDataPropertyOrThrow\">(object, propKey, propValue)\n  assert (? %9: Normal)\n  %9 = %9.Value\n  call %10 = clo<\"NormalCompletion\">(~unused~)\n  return %10\n}","def <SYNTAX>:PropertyDefinition[3,0].PropertyDefinitionEvaluation(\n  this: Ast[PropertyDefinition[3]],\n  object: Record[Object],\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->MethodDefinitionEvaluation(object, true)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"NormalCompletion\">(~unused~)\n  return %1\n}","def IsValidRegularExpressionLiteral(\n  literal: Unknown[\"RegularExpressionLiteralParseNode\"],\n): Boolean = {\n  sdo-call %0 = literal->FlagText()\n  let flags = %0\n  (yet \"If _flags_ contains any code points other than `d`, `g`, `i`, `m`, `s`, `u`, `v`, or `y`, or if _flags_ contains any code point more than once, return *false*.\")\n  if (contains flags \"u\") {\n    let u = true\n  } else {\n    let u = false\n  }\n  if (contains flags \"v\") {\n    let v = true\n  } else {\n    let v = false\n  }\n  sdo-call %1 = literal->BodyText()\n  let patternText = %1\n  if (&& (= u false) (= v false)) {\n    call %2 = clo<\"CodePointsToString\">(patternText)\n    let stringValue = %2\n    (yet \"Set _patternText_ to the sequence of code points resulting from interpreting each of the 16-bit elements of _stringValue_ as a Unicode BMP code point. UTF-16 decoding is not applied to the elements.\")\n  }\n  call %3 = clo<\"ParsePattern\">(patternText, u, v)\n  let parseResult = %3\n  if (? parseResult: Ast) {\n    return true\n  } else {\n    return false\n  }\n}","def <SYNTAX>:PrimaryExpression[10,0].Evaluation(\n  this: Ast[PrimaryExpression[10]],\n): Unknown = {\n  sdo-call %0 = this[0]->BodyText()\n  call %1 = clo<\"CodePointsToString\">(%0)\n  let pattern = %1\n  sdo-call %2 = this[0]->FlagText()\n  call %3 = clo<\"CodePointsToString\">(%2)\n  let flags = %3\n  call %4 = clo<\"RegExpCreate\">(pattern, flags)\n  assert (? %4: Normal)\n  return %4\n}","def <SYNTAX>:TemplateLiteral[0,0].TemplateStrings(\n  this: Ast[TemplateLiteral[0]],\n  raw: Boolean,\n): List[String | Undefined] = {\n  call %0 = clo<\"TemplateString\">(this[0], raw)\n  return (list [%0])[#482]\n}","def <SYNTAX>:SubstitutionTemplate[0,0].TemplateStrings(\n  this: Ast[SubstitutionTemplate[0]],\n  raw: Boolean,\n): List[String | Undefined] = {\n  call %0 = clo<\"TemplateString\">(this[0], raw)\n  let head = (list [%0])[#483]\n  sdo-call %1 = this[2]->TemplateStrings(raw)\n  let tail = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [head, tail])[#484])\n  return %2\n}","def <SYNTAX>:TemplateSpans[0,0].TemplateStrings(\n  this: Ast[TemplateSpans[0]],\n  raw: Boolean,\n): List[String | Undefined] = {\n  call %0 = clo<\"TemplateString\">(this[0], raw)\n  return (list [%0])[#485]\n}","def <SYNTAX>:TemplateSpans[1,0].TemplateStrings(\n  this: Ast[TemplateSpans[1]],\n  raw: Boolean,\n): List[String | Undefined] = {\n  sdo-call %0 = this[0]->TemplateStrings(raw)\n  let middle = %0\n  call %1 = clo<\"TemplateString\">(this[1], raw)\n  let tail = (list [%1])[#486]\n  call %2 = clo<\"__FLAT_LIST__\">((list [middle, tail])[#487])\n  return %2\n}","def <SYNTAX>:TemplateMiddleList[0,0].TemplateStrings(\n  this: Ast[TemplateMiddleList[0]],\n  raw: Boolean,\n): List[String | Undefined] = {\n  call %0 = clo<\"TemplateString\">(this[0], raw)\n  return (list [%0])[#488]\n}","def <SYNTAX>:TemplateMiddleList[1,0].TemplateStrings(\n  this: Ast[TemplateMiddleList[1]],\n  raw: Boolean,\n): List[String | Undefined] = {\n  sdo-call %0 = this[0]->TemplateStrings(raw)\n  let front = %0\n  call %1 = clo<\"TemplateString\">(this[1], raw)\n  let last = (list [%1])[#489]\n  call %2 = clo<\"__FLAT_LIST__\">((list [front, last])[#490])\n  return %2\n}","def TemplateString(\n  templateToken: Unknown[\"NoSubstitutionTemplateParseNode,ATemplateHeadParseNode,ATemplateMiddleParseNode,OrATemplateTailParseNode\"],\n  raw: Boolean,\n): String | Undefined = {\n  if (= raw true) {\n    sdo-call %0 = templateToken->TRV()\n    let string = %0\n  } else {\n    sdo-call %1 = templateToken->TV()\n    let string = %1\n  }\n  return string\n}","def GetTemplateObject(\n  templateLiteral: Ast,\n): Record[Array] = {\n  let realm = @EXECUTION_STACK[0].Realm\n  let templateRegistry = realm.TemplateMap\n  %1 = templateRegistry\n  %0 = 0\n  while (< %0 (sizeof %1)) {\n    let e = %1[%0]\n    if (= e.Site templateLiteral) {\n      return e.Array\n    }\n    %0 = (+ %0 1)\n  }\n  sdo-call %2 = templateLiteral->TemplateStrings(true)\n  let rawStrings = %2\n  assert (? rawStrings: List[String])\n  sdo-call %3 = templateLiteral->TemplateStrings(false)\n  let cookedStrings = %3\n  let count = (sizeof cookedStrings)\n  assert (! (< (- (** 2 32) 1) count))\n  call %4 = clo<\"ArrayCreate\">(count)\n  assert (? %4: Normal)\n  %4 = %4.Value\n  let template = %4\n  call %5 = clo<\"ArrayCreate\">(count)\n  assert (? %5: Normal)\n  %5 = %5.Value\n  let rawObj = %5\n  let index = 0\n  while (< index count) {\n    call %6 = clo<\"ToString\">(([number] index))\n    assert (? %6: Normal)\n    %6 = %6.Value\n    let prop = %6\n    let cookedValue = cookedStrings[index]\n    call %7 = clo<\"DefinePropertyOrThrow\">(template, prop, (record [PropertyDescriptor] {\n      \"Value\" : cookedValue,\n      \"Writable\" : false,\n      \"Enumerable\" : true,\n      \"Configurable\" : false,\n    })[#491])\n    assert (? %7: Normal)\n    %7 = %7.Value\n    let rawValue = rawStrings[index]\n    call %8 = clo<\"DefinePropertyOrThrow\">(rawObj, prop, (record [PropertyDescriptor] {\n      \"Value\" : rawValue,\n      \"Writable\" : false,\n      \"Enumerable\" : true,\n      \"Configurable\" : false,\n    })[#492])\n    assert (? %8: Normal)\n    %8 = %8.Value\n    index = (+ index 1)\n  }\n  call %9 = clo<\"SetIntegrityLevel\">(rawObj, ~frozen~)\n  assert (? %9: Normal)\n  %9 = %9.Value\n  call %10 = clo<\"DefinePropertyOrThrow\">(template, \"raw\", (record [PropertyDescriptor] {\n    \"Value\" : rawObj,\n    \"Writable\" : false,\n    \"Enumerable\" : false,\n    \"Configurable\" : false,\n  })[#493])\n  assert (? %10: Normal)\n  %10 = %10.Value\n  call %11 = clo<\"SetIntegrityLevel\">(template, ~frozen~)\n  assert (? %11: Normal)\n  %11 = %11.Value\n  push realm.TemplateMap < (record {\n    \"Site\" : templateLiteral,\n    \"Array\" : template,\n  })[#494]\n  return template\n}","def <SYNTAX>:TemplateSpans[0,0].SubstitutionEvaluation(\n  this: Ast[TemplateSpans[0]],\n): Normal[List[ESValue]] | Abrupt = {\n  %0 = (list [])[#495]\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:TemplateSpans[1,0].SubstitutionEvaluation(\n  this: Ast[TemplateSpans[1]],\n): Normal[List[ESValue]] | Abrupt = {\n  sdo-call %0 = this[0]->SubstitutionEvaluation()\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:TemplateMiddleList[0,0].SubstitutionEvaluation(\n  this: Ast[TemplateMiddleList[0]],\n): Normal[List[ESValue]] | Abrupt = {\n  sdo-call %0 = this[1]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let subRef = %0\n  call %1 = clo<\"GetValue\">(subRef)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let sub = %1\n  %2 = (list [sub])[#496]\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <SYNTAX>:TemplateMiddleList[1,0].SubstitutionEvaluation(\n  this: Ast[TemplateMiddleList[1]],\n): Normal[List[ESValue]] | Abrupt = {\n  sdo-call %0 = this[0]->SubstitutionEvaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let preceding = %0\n  sdo-call %1 = this[2]->Evaluation()\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let nextRef = %1\n  call %2 = clo<\"GetValue\">(nextRef)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let next = %2\n  call %3 = clo<\"__FLAT_LIST__\">((list [preceding, (list [next])[#498]])[#497])\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <SYNTAX>:TemplateLiteral[0,0].Evaluation(\n  this: Ast[TemplateLiteral[0]],\n): Unknown = {\n  sdo-call %0 = this[0]->TV()\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:SubstitutionTemplate[0,0].Evaluation(\n  this: Ast[SubstitutionTemplate[0]],\n): Unknown = {\n  sdo-call %0 = this[0]->TV()\n  let head = %0\n  sdo-call %1 = this[1]->Evaluation()\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let subRef = %1\n  call %2 = clo<\"GetValue\">(subRef)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let sub = %2\n  call %3 = clo<\"ToString\">(sub)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let middle = %3\n  sdo-call %4 = this[2]->Evaluation()\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let tail = %4\n  %5 = (concat head middle tail)\n  if (? %5: Completion) return %5\n  call %6 = clo<\"NormalCompletion\">(%5)\n  return %6\n}","def <SYNTAX>:TemplateSpans[0,0].Evaluation(\n  this: Ast[TemplateSpans[0]],\n): Unknown = {\n  sdo-call %0 = this[0]->TV()\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:TemplateSpans[1,0].Evaluation(\n  this: Ast[TemplateSpans[1]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let head = %0\n  sdo-call %1 = this[1]->TV()\n  let tail = %1\n  %2 = (concat head tail)\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <SYNTAX>:TemplateMiddleList[0,0].Evaluation(\n  this: Ast[TemplateMiddleList[0]],\n): Unknown = {\n  sdo-call %0 = this[0]->TV()\n  let head = %0\n  sdo-call %1 = this[1]->Evaluation()\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let subRef = %1\n  call %2 = clo<\"GetValue\">(subRef)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let sub = %2\n  call %3 = clo<\"ToString\">(sub)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let middle = %3\n  %4 = (concat head middle)\n  if (? %4: Completion) return %4\n  call %5 = clo<\"NormalCompletion\">(%4)\n  return %5\n}","def <SYNTAX>:TemplateMiddleList[1,0].Evaluation(\n  this: Ast[TemplateMiddleList[1]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let rest = %0\n  sdo-call %1 = this[1]->TV()\n  let middle = %1\n  sdo-call %2 = this[2]->Evaluation()\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let subRef = %2\n  call %3 = clo<\"GetValue\">(subRef)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let sub = %3\n  call %4 = clo<\"ToString\">(sub)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let last = %4\n  %5 = (concat rest middle last)\n  if (? %5: Completion) return %5\n  call %6 = clo<\"NormalCompletion\">(%5)\n  return %6\n}","def <SYNTAX>:PrimaryExpression[12,0].Evaluation(\n  this: Ast[PrimaryExpression[12]],\n): Unknown = {\n  let expr = (parse this[0] (grammar-symbol |ParenthesizedExpression|))\n  sdo-call %0 = expr->Evaluation()\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:ParenthesizedExpression[0,0].Evaluation(\n  this: Ast[ParenthesizedExpression[0]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:MemberExpression[1,0].Evaluation(\n  this: Ast[MemberExpression[1]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let baseReference = %0\n  call %1 = clo<\"GetValue\">(baseReference)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let baseValue = %1\n  if true {\n    let strict = true\n  } else {\n    let strict = false\n  }\n  call %2 = clo<\"EvaluatePropertyAccessWithExpressionKey\">(baseValue, this[1], strict)\n  assert (? %2: Completion)\n  return %2\n}","def <SYNTAX>:MemberExpression[2,0].Evaluation(\n  this: Ast[MemberExpression[2]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let baseReference = %0\n  call %1 = clo<\"GetValue\">(baseReference)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let baseValue = %1\n  if true {\n    let strict = true\n  } else {\n    let strict = false\n  }\n  call %2 = clo<\"EvaluatePropertyAccessWithIdentifierKey\">(baseValue, this[1], strict)\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <SYNTAX>:MemberExpression[7,0].Evaluation(\n  this: Ast[MemberExpression[7]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let baseReference = %0\n  call %1 = clo<\"GetValue\">(baseReference)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let baseValue = %1\n  sdo-call %2 = this[1]->StringValue()\n  let fieldNameString = %2\n  call %3 = clo<\"MakePrivateReference\">(baseValue, fieldNameString)\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <SYNTAX>:CallExpression[4,0].Evaluation(\n  this: Ast[CallExpression[4]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let baseReference = %0\n  call %1 = clo<\"GetValue\">(baseReference)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let baseValue = %1\n  if true {\n    let strict = true\n  } else {\n    let strict = false\n  }\n  call %2 = clo<\"EvaluatePropertyAccessWithExpressionKey\">(baseValue, this[1], strict)\n  assert (? %2: Completion)\n  return %2\n}","def <SYNTAX>:CallExpression[5,0].Evaluation(\n  this: Ast[CallExpression[5]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let baseReference = %0\n  call %1 = clo<\"GetValue\">(baseReference)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let baseValue = %1\n  if true {\n    let strict = true\n  } else {\n    let strict = false\n  }\n  call %2 = clo<\"EvaluatePropertyAccessWithIdentifierKey\">(baseValue, this[1], strict)\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <SYNTAX>:CallExpression[7,0].Evaluation(\n  this: Ast[CallExpression[7]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let baseReference = %0\n  call %1 = clo<\"GetValue\">(baseReference)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let baseValue = %1\n  sdo-call %2 = this[1]->StringValue()\n  let fieldNameString = %2\n  call %3 = clo<\"MakePrivateReference\">(baseValue, fieldNameString)\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def EvaluatePropertyAccessWithExpressionKey(\n  baseValue: ESValue,\n  expression: Unknown[\"ExpressionParseNode\"],\n  strict: Boolean,\n): Normal[Record[ReferenceRecord]] | Abrupt = {\n  sdo-call %0 = expression->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let propertyNameReference = %0\n  call %1 = clo<\"GetValue\">(propertyNameReference)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let propertyNameValue = %1\n  call %2 = clo<\"ToPropertyKey\">(propertyNameValue)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let propertyKey = %2\n  %3 = (record [ReferenceRecord] {\n    \"Base\" : baseValue,\n    \"ReferencedName\" : propertyKey,\n    \"Strict\" : strict,\n    \"ThisValue\" : ~empty~,\n  })[#499]\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def EvaluatePropertyAccessWithIdentifierKey(\n  baseValue: ESValue,\n  identifierName: Unknown[\"IdentifierNameParseNode\"],\n  strict: Boolean,\n): Record[ReferenceRecord] = {\n  sdo-call %0 = identifierName->StringValue()\n  let propertyNameString = %0\n  return (record [ReferenceRecord] {\n    \"Base\" : baseValue,\n    \"ReferencedName\" : propertyNameString,\n    \"Strict\" : strict,\n    \"ThisValue\" : ~empty~,\n  })[#500]\n}","def <SYNTAX>:NewExpression[1,0].Evaluation(\n  this: Ast[NewExpression[1]],\n): Unknown = {\n  call %0 = clo<\"EvaluateNew\">(this[0], ~empty~)\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:MemberExpression[6,0].Evaluation(\n  this: Ast[MemberExpression[6]],\n): Unknown = {\n  call %0 = clo<\"EvaluateNew\">(this[0], this[1])\n  assert (? %0: Completion)\n  return %0\n}","def EvaluateNew(\n  constructExpr: Unknown[\"NewExpressionParseNodeOrAMemberExpressionParseNode\"],\n  arguments: Unknown[\"~empty~OrAnArgumentsParseNode\"],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = constructExpr->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let ref = %0\n  call %1 = clo<\"GetValue\">(ref)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let constructor = %1\n  if (= arguments ~empty~) {\n    let argList = (list [])[#501]\n  } else {\n    sdo-call %2 = arguments->ArgumentListEvaluation()\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let argList = %2\n  }\n  call %3 = clo<\"IsConstructor\">(constructor)\n  if (= %3 false) {\n    call %4 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %5 = clo<\"ThrowCompletion\">(%4)\n    return %5\n  }\n  call %6 = clo<\"Construct\">(constructor, argList)\n  assert (? %6: Completion)\n  return %6\n}","def <SYNTAX>:CallExpression[0,0].Evaluation(\n  this: Ast[CallExpression[0]],\n): Unknown = {\n  let expr = (parse this[0] (grammar-symbol |CallMemberExpression|))\n  let memberExpr = expr.MemberExpression\n  let arguments = expr.Arguments\n  sdo-call %0 = memberExpr->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let ref = %0\n  call %1 = clo<\"GetValue\">(ref)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let func = %1\n  %2 = (? ref: Record[ReferenceRecord])\n  if %2 {\n    call %3 = clo<\"IsPropertyReference\">(ref)\n    %2 = (= %3 false)\n    if %2 {\n      %2 = (= ref.ReferencedName \"eval\")\n    }\n  }\n  if %2 {\n    call %4 = clo<\"SameValue\">(func, @EXECUTION_STACK[0].Realm.Intrinsics[\"%eval%\"])\n    if (= %4 true) {\n      sdo-call %5 = arguments->ArgumentListEvaluation()\n      assert (? %5: Completion)\n      if (? %5: Abrupt) return %5\n      else %5 = %5.Value\n      let argList = %5\n      if (= (sizeof argList) 0) {\n        call %6 = clo<\"NormalCompletion\">(undefined)\n        return %6\n      }\n      let evalArg = argList[0]\n      if true {\n        let strictCaller = true\n      } else {\n        let strictCaller = false\n      }\n      call %7 = clo<\"PerformEval\">(evalArg, strictCaller, true)\n      assert (? %7: Completion)\n      return %7\n    }\n  }\n  let thisCall = this\n  call %8 = clo<\"IsInTailPosition\">(thisCall)\n  let tailCall = %8\n  call %9 = clo<\"EvaluateCall\">(func, ref, arguments, tailCall)\n  assert (? %9: Completion)\n  return %9\n}","def <SYNTAX>:CallExpression[3,0].Evaluation(\n  this: Ast[CallExpression[3]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let ref = %0\n  call %1 = clo<\"GetValue\">(ref)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let func = %1\n  let thisCall = this\n  call %2 = clo<\"IsInTailPosition\">(thisCall)\n  let tailCall = %2\n  call %3 = clo<\"EvaluateCall\">(func, ref, this[1], tailCall)\n  assert (? %3: Completion)\n  return %3\n}","def EvaluateCall(\n  func: ESValue,\n  ref: ESValue | Record[ReferenceRecord],\n  arguments: Ast,\n  tailPosition: Boolean,\n): Normal[ESValue] | Abrupt = {\n  if (? ref: Record[ReferenceRecord]) {\n    call %0 = clo<\"IsPropertyReference\">(ref)\n    if (= %0 true) {\n      call %1 = clo<\"GetThisValue\">(ref)\n      let thisValue = %1\n    } else {\n      let refEnv = ref.Base\n      assert (? refEnv: Record[EnvironmentRecord])\n      call %2 = refEnv.WithBaseObject(refEnv)\n      let thisValue = %2\n    }\n  } else {\n    let thisValue = undefined\n  }\n  sdo-call %3 = arguments->ArgumentListEvaluation()\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let argList = %3\n  if (! (? func: Record[Object])) {\n    call %4 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %5 = clo<\"ThrowCompletion\">(%4)\n    return %5\n  }\n  call %6 = clo<\"IsCallable\">(func)\n  if (= %6 false) {\n    call %7 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %8 = clo<\"ThrowCompletion\">(%7)\n    return %8\n  }\n  if (= tailPosition true) {\n    call %9 = clo<\"PrepareForTailCall\">()\n  }\n  call %10 = clo<\"Call\">(func, thisValue, argList)\n  assert (? %10: Completion)\n  return %10\n}","def <SYNTAX>:SuperProperty[0,0].Evaluation(\n  this: Ast[SuperProperty[0]],\n): Unknown = {\n  call %0 = clo<\"GetThisEnvironment\">()\n  let env = %0\n  call %1 = env.GetThisBinding(env)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let actualThis = %1\n  sdo-call %2 = this[0]->Evaluation()\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let propertyNameReference = %2\n  call %3 = clo<\"GetValue\">(propertyNameReference)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let propertyNameValue = %3\n  call %4 = clo<\"ToPropertyKey\">(propertyNameValue)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let propertyKey = %4\n  if true {\n    let strict = true\n  } else {\n    let strict = false\n  }\n  call %5 = clo<\"MakeSuperPropertyReference\">(actualThis, propertyKey, strict)\n  assert (? %5: Completion)\n  return %5\n}","def <SYNTAX>:SuperProperty[1,0].Evaluation(\n  this: Ast[SuperProperty[1]],\n): Unknown = {\n  call %0 = clo<\"GetThisEnvironment\">()\n  let env = %0\n  call %1 = env.GetThisBinding(env)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let actualThis = %1\n  sdo-call %2 = this[0]->StringValue()\n  let propertyKey = %2\n  if true {\n    let strict = true\n  } else {\n    let strict = false\n  }\n  call %3 = clo<\"MakeSuperPropertyReference\">(actualThis, propertyKey, strict)\n  assert (? %3: Completion)\n  return %3\n}","def <SYNTAX>:SuperCall[0,0].Evaluation(\n  this: Ast[SuperCall[0]],\n): Unknown = {\n  call %0 = clo<\"GetNewTarget\">()\n  let newTarget = %0\n  assert (? newTarget: Record[Object])\n  call %1 = clo<\"GetSuperConstructor\">()\n  let func = %1\n  sdo-call %2 = this[0]->ArgumentListEvaluation()\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let argList = %2\n  call %3 = clo<\"IsConstructor\">(func)\n  if (= %3 false) {\n    call %4 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %5 = clo<\"ThrowCompletion\">(%4)\n    return %5\n  }\n  call %6 = clo<\"Construct\">(func, argList, newTarget)\n  assert (? %6: Completion)\n  if (? %6: Abrupt) return %6\n  else %6 = %6.Value\n  let result = %6\n  call %7 = clo<\"GetThisEnvironment\">()\n  let thisER = %7\n  call %8 = thisER.BindThisValue(thisER, result)\n  assert (? %8: Completion)\n  if (? %8: Abrupt) return %8\n  else %8 = %8.Value\n  let F = thisER.FunctionObject\n  assert (? F: Record[ECMAScriptFunctionObject])\n  call %9 = clo<\"InitializeInstanceElements\">(result, F)\n  assert (? %9: Completion)\n  if (? %9: Abrupt) return %9\n  else %9 = %9.Value\n  if (? result: Completion) return result\n  call %10 = clo<\"NormalCompletion\">(result)\n  return %10\n}","def GetSuperConstructor(\n): ESValue = {\n  call %0 = clo<\"GetThisEnvironment\">()\n  let envRec = %0\n  assert (? envRec: Record[FunctionEnvironmentRecord])\n  let activeFunction = envRec.FunctionObject\n  assert (? activeFunction: Record[ECMAScriptFunctionObject])\n  call %1 = activeFunction.GetPrototypeOf(activeFunction)\n  assert (? %1: Normal)\n  %1 = %1.Value\n  let superConstructor = %1\n  return superConstructor\n}","def MakeSuperPropertyReference(\n  actualThis: ESValue,\n  propertyKey: Record[Symbol] | String,\n  strict: Boolean,\n): Normal[Record[SuperReferenceRecord]] | Throw = {\n  call %0 = clo<\"GetThisEnvironment\">()\n  let env = %0\n  call %1 = env.HasSuperBinding(env)\n  assert (= %1 true)\n  call %2 = env.GetSuperBase(env)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let baseValue = %2\n  %3 = (record [ReferenceRecord] {\n    \"Base\" : baseValue,\n    \"ReferencedName\" : propertyKey,\n    \"Strict\" : strict,\n    \"ThisValue\" : actualThis,\n  })[#502]\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <SYNTAX>:Arguments[0,0].ArgumentListEvaluation(\n  this: Ast[Arguments[0]],\n): Normal[List[ESValue]] | Abrupt = {\n  %0 = (list [])[#503]\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:ArgumentList[0,0].ArgumentListEvaluation(\n  this: Ast[ArgumentList[0]],\n): Normal[List[ESValue]] | Abrupt = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let ref = %0\n  call %1 = clo<\"GetValue\">(ref)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let arg = %1\n  %2 = (list [arg])[#504]\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <SYNTAX>:ArgumentList[1,0].ArgumentListEvaluation(\n  this: Ast[ArgumentList[1]],\n): Normal[List[ESValue]] | Abrupt = {\n  let list = (list [])[#505]\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let spreadRef = %0\n  call %1 = clo<\"GetValue\">(spreadRef)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let spreadObj = %1\n  call %2 = clo<\"GetIterator\">(spreadObj, ~sync~)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let iteratorRecord = %2\n  while true {\n    call %3 = clo<\"IteratorStepValue\">(iteratorRecord)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let next = %3\n    if (= next ~done~) {\n      if (? list: Completion) return list\n      call %4 = clo<\"NormalCompletion\">(list)\n      return %4\n    }\n    push list < next\n  }\n}","def <SYNTAX>:ArgumentList[2,0].ArgumentListEvaluation(\n  this: Ast[ArgumentList[2]],\n): Normal[List[ESValue]] | Abrupt = {\n  sdo-call %0 = this[0]->ArgumentListEvaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let precedingArgs = %0\n  sdo-call %1 = this[1]->Evaluation()\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let ref = %1\n  call %2 = clo<\"GetValue\">(ref)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let arg = %2\n  call %3 = clo<\"__FLAT_LIST__\">((list [precedingArgs, (list [arg])[#507]])[#506])\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <SYNTAX>:ArgumentList[3,0].ArgumentListEvaluation(\n  this: Ast[ArgumentList[3]],\n): Normal[List[ESValue]] | Abrupt = {\n  sdo-call %0 = this[0]->ArgumentListEvaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let precedingArgs = %0\n  sdo-call %1 = this[1]->Evaluation()\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let spreadRef = %1\n  call %2 = clo<\"GetValue\">(spreadRef)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  call %3 = clo<\"GetIterator\">(%2, ~sync~)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let iteratorRecord = %3\n  while true {\n    call %4 = clo<\"IteratorStepValue\">(iteratorRecord)\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    let next = %4\n    if (= next ~done~) {\n      if (? precedingArgs: Completion) return precedingArgs\n      call %5 = clo<\"NormalCompletion\">(precedingArgs)\n      return %5\n    }\n    push precedingArgs < next\n  }\n}","def <SYNTAX>:TemplateLiteral[0,0].ArgumentListEvaluation(\n  this: Ast[TemplateLiteral[0]],\n): Normal[List[ESValue]] | Abrupt = {\n  let templateLiteral = this\n  call %0 = clo<\"GetTemplateObject\">(templateLiteral)\n  let siteObj = %0\n  %1 = (list [siteObj])[#508]\n  if (? %1: Completion) return %1\n  call %2 = clo<\"NormalCompletion\">(%1)\n  return %2\n}","def <SYNTAX>:TemplateLiteral[1,0].ArgumentListEvaluation(\n  this: Ast[TemplateLiteral[1]],\n): Normal[List[ESValue]] | Abrupt = {\n  let templateLiteral = this\n  call %0 = clo<\"GetTemplateObject\">(templateLiteral)\n  let siteObj = %0\n  sdo-call %1 = this[0]->ArgumentListEvaluation()\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let remaining = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [(list [siteObj])[#510], remaining])[#509])\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <SYNTAX>:SubstitutionTemplate[0,0].ArgumentListEvaluation(\n  this: Ast[SubstitutionTemplate[0]],\n): Normal[List[ESValue]] | Abrupt = {\n  sdo-call %0 = this[1]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let firstSubRef = %0\n  call %1 = clo<\"GetValue\">(firstSubRef)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let firstSub = %1\n  sdo-call %2 = this[2]->SubstitutionEvaluation()\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let restSub = %2\n  assert (yet \"_restSub_ is a possibly empty List.\")\n  call %3 = clo<\"__FLAT_LIST__\">((list [(list [firstSub])[#512], restSub])[#511])\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <SYNTAX>:OptionalExpression[0,0].Evaluation(\n  this: Ast[OptionalExpression[0]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let baseReference = %0\n  call %1 = clo<\"GetValue\">(baseReference)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let baseValue = %1\n  if (|| (= baseValue undefined) (= baseValue null)) {\n    call %2 = clo<\"NormalCompletion\">(undefined)\n    return %2\n  }\n  sdo-call %3 = this[1]->ChainEvaluation(baseValue, baseReference)\n  assert (? %3: Completion)\n  return %3\n}","def <SYNTAX>:OptionalExpression[1,0].Evaluation(\n  this: Ast[OptionalExpression[1]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let baseReference = %0\n  call %1 = clo<\"GetValue\">(baseReference)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let baseValue = %1\n  if (|| (= baseValue undefined) (= baseValue null)) {\n    call %2 = clo<\"NormalCompletion\">(undefined)\n    return %2\n  }\n  sdo-call %3 = this[1]->ChainEvaluation(baseValue, baseReference)\n  assert (? %3: Completion)\n  return %3\n}","def <SYNTAX>:OptionalExpression[2,0].Evaluation(\n  this: Ast[OptionalExpression[2]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let baseReference = %0\n  call %1 = clo<\"GetValue\">(baseReference)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let baseValue = %1\n  if (|| (= baseValue undefined) (= baseValue null)) {\n    call %2 = clo<\"NormalCompletion\">(undefined)\n    return %2\n  }\n  sdo-call %3 = this[1]->ChainEvaluation(baseValue, baseReference)\n  assert (? %3: Completion)\n  return %3\n}","def <SYNTAX>:OptionalChain[0,0].ChainEvaluation(\n  this: Ast[OptionalChain[0]],\n  baseValue: ESValue,\n  baseReference: ESValue | Record[ReferenceRecord],\n): Normal[ESValue | Record[ReferenceRecord]] | Abrupt = {\n  let thisChain = this\n  call %0 = clo<\"IsInTailPosition\">(thisChain)\n  let tailCall = %0\n  call %1 = clo<\"EvaluateCall\">(baseValue, baseReference, this[0], tailCall)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:OptionalChain[1,0].ChainEvaluation(\n  this: Ast[OptionalChain[1]],\n  baseValue: ESValue,\n  baseReference: ESValue | Record[ReferenceRecord],\n): Normal[ESValue | Record[ReferenceRecord]] | Abrupt = {\n  if true {\n    let strict = true\n  } else {\n    let strict = false\n  }\n  call %0 = clo<\"EvaluatePropertyAccessWithExpressionKey\">(baseValue, this[0], strict)\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:OptionalChain[2,0].ChainEvaluation(\n  this: Ast[OptionalChain[2]],\n  baseValue: ESValue,\n  baseReference: ESValue | Record[ReferenceRecord],\n): Normal[ESValue | Record[ReferenceRecord]] | Abrupt = {\n  if true {\n    let strict = true\n  } else {\n    let strict = false\n  }\n  call %0 = clo<\"EvaluatePropertyAccessWithIdentifierKey\">(baseValue, this[0], strict)\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:OptionalChain[4,0].ChainEvaluation(\n  this: Ast[OptionalChain[4]],\n  baseValue: ESValue,\n  baseReference: ESValue | Record[ReferenceRecord],\n): Normal[ESValue | Record[ReferenceRecord]] | Abrupt = {\n  sdo-call %0 = this[0]->StringValue()\n  let fieldNameString = %0\n  call %1 = clo<\"MakePrivateReference\">(baseValue, fieldNameString)\n  if (? %1: Completion) return %1\n  call %2 = clo<\"NormalCompletion\">(%1)\n  return %2\n}","def <SYNTAX>:OptionalChain[5,0].ChainEvaluation(\n  this: Ast[OptionalChain[5]],\n  baseValue: ESValue,\n  baseReference: ESValue | Record[ReferenceRecord],\n): Normal[ESValue | Record[ReferenceRecord]] | Abrupt = {\n  let optionalChain = this[0]\n  sdo-call %0 = optionalChain->ChainEvaluation(baseValue, baseReference)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let newReference = %0\n  call %1 = clo<\"GetValue\">(newReference)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let newValue = %1\n  let thisChain = this\n  call %2 = clo<\"IsInTailPosition\">(thisChain)\n  let tailCall = %2\n  call %3 = clo<\"EvaluateCall\">(newValue, newReference, this[1], tailCall)\n  assert (? %3: Completion)\n  return %3\n}","def <SYNTAX>:OptionalChain[6,0].ChainEvaluation(\n  this: Ast[OptionalChain[6]],\n  baseValue: ESValue,\n  baseReference: ESValue | Record[ReferenceRecord],\n): Normal[ESValue | Record[ReferenceRecord]] | Abrupt = {\n  let optionalChain = this[0]\n  sdo-call %0 = optionalChain->ChainEvaluation(baseValue, baseReference)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let newReference = %0\n  call %1 = clo<\"GetValue\">(newReference)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let newValue = %1\n  if true {\n    let strict = true\n  } else {\n    let strict = false\n  }\n  call %2 = clo<\"EvaluatePropertyAccessWithExpressionKey\">(newValue, this[1], strict)\n  assert (? %2: Completion)\n  return %2\n}","def <SYNTAX>:OptionalChain[7,0].ChainEvaluation(\n  this: Ast[OptionalChain[7]],\n  baseValue: ESValue,\n  baseReference: ESValue | Record[ReferenceRecord],\n): Normal[ESValue | Record[ReferenceRecord]] | Abrupt = {\n  let optionalChain = this[0]\n  sdo-call %0 = optionalChain->ChainEvaluation(baseValue, baseReference)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let newReference = %0\n  call %1 = clo<\"GetValue\">(newReference)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let newValue = %1\n  if true {\n    let strict = true\n  } else {\n    let strict = false\n  }\n  call %2 = clo<\"EvaluatePropertyAccessWithIdentifierKey\">(newValue, this[1], strict)\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <SYNTAX>:OptionalChain[9,0].ChainEvaluation(\n  this: Ast[OptionalChain[9]],\n  baseValue: ESValue,\n  baseReference: ESValue | Record[ReferenceRecord],\n): Normal[ESValue | Record[ReferenceRecord]] | Abrupt = {\n  let optionalChain = this[0]\n  sdo-call %0 = optionalChain->ChainEvaluation(baseValue, baseReference)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let newReference = %0\n  call %1 = clo<\"GetValue\">(newReference)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let newValue = %1\n  sdo-call %2 = this[1]->StringValue()\n  let fieldNameString = %2\n  call %3 = clo<\"MakePrivateReference\">(newValue, fieldNameString)\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <SYNTAX>:ImportCall[0,0].Evaluation(\n  this: Ast[ImportCall[0]],\n): Unknown = {\n  call %0 = clo<\"GetActiveScriptOrModule\">()\n  let referrer = %0\n  if (= referrer null) {\n    referrer = @EXECUTION_STACK[0].Realm\n  }\n  sdo-call %1 = this[0]->Evaluation()\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let argRef = %1\n  call %2 = clo<\"GetValue\">(argRef)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let specifier = %2\n  call %3 = clo<\"NewPromiseCapability\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Promise%\"])\n  assert (? %3: Normal)\n  %3 = %3.Value\n  let promiseCapability = %3\n  call %4 = clo<\"ToString\">(specifier)\n  call %5 = clo<\"Completion\">(%4)\n  let specifierString = %5\n  assert (? specifierString: Completion)\n  if (&& (? specifierString: Completion) (! (= specifierString.Type ~normal~))) {\n    call %6 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [specifierString.Value])[#513])\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    %7 = promiseCapability.Promise\n    if (? %7: Completion) return %7\n    call %8 = clo<\"NormalCompletion\">(%7)\n    return %8\n  } else {\n    assert (? specifierString: Normal)\n    specifierString = specifierString.Value\n    specifierString = specifierString\n  }\n  call %9 = clo<\"HostLoadImportedModule\">(referrer, specifierString, ~empty~, promiseCapability)\n  %10 = promiseCapability.Promise\n  if (? %10: Completion) return %10\n  call %11 = clo<\"NormalCompletion\">(%10)\n  return %11\n}","def <CLO>:ContinueDynamicImport:clo0(\n  reason: Unknown,\n): Unknown = {\n  call %0 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [reason])[#514])\n  assert (? %0: Normal)\n  %0 = %0.Value\n  call %1 = clo<\"NormalCompletion\">(~unused~)\n  return %1\n}","def <CLO>:ContinueDynamicImport:clo1:clo0(\n): Unknown = {\n  call %0 = clo<\"GetModuleNamespace\">(module)\n  let namespace = %0\n  call %1 = clo<\"Call\">(promiseCapability.Resolve, undefined, (list [namespace])[#515])\n  assert (? %1: Normal)\n  %1 = %1.Value\n  call %2 = clo<\"NormalCompletion\">(~unused~)\n  return %2\n}","def <CLO>:ContinueDynamicImport:clo1(\n): Unknown = {\n  call %0 = module.Link(module)\n  call %1 = clo<\"Completion\">(%0)\n  let link = %1\n  if (&& (? link: Completion) (! (= link.Type ~normal~))) {\n    call %2 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [link.Value])[#516])\n    assert (? %2: Normal)\n    %2 = %2.Value\n    call %3 = clo<\"NormalCompletion\">(~unused~)\n    return %3\n  }\n  call %4 = module.Evaluate(module)\n  let evaluatePromise = %4\n  let fulfilledClosure = clo<\"ContinueDynamicImport:clo1:clo0\", [module, promiseCapability]>\n  call %5 = clo<\"CreateBuiltinFunction\">(fulfilledClosure, 0, \"\", (list [])[#517])\n  let onFulfilled = %5\n  call %6 = clo<\"PerformPromiseThen\">(evaluatePromise, onFulfilled, onRejected)\n  call %7 = clo<\"NormalCompletion\">(~unused~)\n  return %7\n}","def ContinueDynamicImport(\n  promiseCapability: Record[PromiseCapabilityRecord],\n  moduleCompletion: Normal[Record[ModuleRecord]] | Throw,\n): Enum[~unused~] = {\n  if (&& (? moduleCompletion: Completion) (! (= moduleCompletion.Type ~normal~))) {\n    call %0 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [moduleCompletion.Value])[#518])\n    assert (? %0: Normal)\n    %0 = %0.Value\n    return ~unused~\n  }\n  let module = moduleCompletion.Value\n  call %1 = module.LoadRequestedModules(module)\n  let loadPromise = %1\n  let rejectedClosure = clo<\"ContinueDynamicImport:clo0\", [promiseCapability]>\n  call %2 = clo<\"CreateBuiltinFunction\">(rejectedClosure, 1, \"\", (list [])[#519])\n  let onRejected = %2\n  let linkAndEvaluateClosure = clo<\"ContinueDynamicImport:clo1\", [module, promiseCapability, onRejected]>\n  call %3 = clo<\"CreateBuiltinFunction\">(linkAndEvaluateClosure, 0, \"\", (list [])[#520])\n  let linkAndEvaluate = %3\n  call %4 = clo<\"PerformPromiseThen\">(loadPromise, linkAndEvaluate, onRejected)\n  return ~unused~\n}","def <SYNTAX>:MemberExpression[3,0].Evaluation(\n  this: Ast[MemberExpression[3]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let tagRef = %0\n  call %1 = clo<\"GetValue\">(tagRef)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let tagFunc = %1\n  let thisCall = this\n  call %2 = clo<\"IsInTailPosition\">(thisCall)\n  let tailCall = %2\n  call %3 = clo<\"EvaluateCall\">(tagFunc, tagRef, this[1], tailCall)\n  assert (? %3: Completion)\n  return %3\n}","def <SYNTAX>:CallExpression[6,0].Evaluation(\n  this: Ast[CallExpression[6]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let tagRef = %0\n  call %1 = clo<\"GetValue\">(tagRef)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let tagFunc = %1\n  let thisCall = this\n  call %2 = clo<\"IsInTailPosition\">(thisCall)\n  let tailCall = %2\n  call %3 = clo<\"EvaluateCall\">(tagFunc, tagRef, this[1], tailCall)\n  assert (? %3: Completion)\n  return %3\n}","def <SYNTAX>:NewTarget[0,0].Evaluation(\n  this: Ast[NewTarget[0]],\n): Unknown = {\n  call %0 = clo<\"GetNewTarget\">()\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:ImportMeta[0,0].Evaluation(\n  this: Ast[ImportMeta[0]],\n): Unknown = {\n  call %0 = clo<\"GetActiveScriptOrModule\">()\n  let module = %0\n  assert (? module: Record[SourceTextModuleRecord])\n  let importMeta = module.ImportMeta\n  if (= importMeta ~empty~) {\n    call %1 = clo<\"OrdinaryObjectCreate\">(null)\n    importMeta = %1\n    call %2 = clo<\"HostGetImportMetaProperties\">(module)\n    let importMetaValues = %2\n    %4 = importMetaValues\n    %3 = 0\n    while (< %3 (sizeof %4)) {\n      let p = %4[%3]\n      if (? p: Record[{ Key, Value }]) {\n        call %5 = clo<\"CreateDataPropertyOrThrow\">(importMeta, p.Key, p.Value)\n        assert (? %5: Normal)\n        %5 = %5.Value\n      }\n      %3 = (+ %3 1)\n    }\n    call %6 = clo<\"HostFinalizeImportMeta\">(importMeta, module)\n    module.ImportMeta = importMeta\n    if (? importMeta: Completion) return importMeta\n    call %7 = clo<\"NormalCompletion\">(importMeta)\n    return %7\n  } else {\n    assert (? importMeta: Record[Object])\n    if (? importMeta: Completion) return importMeta\n    call %8 = clo<\"NormalCompletion\">(importMeta)\n    return %8\n  }\n}","def <SYNTAX>:UpdateExpression[1,0].Evaluation(\n  this: Ast[UpdateExpression[1]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let lhs = %0\n  call %1 = clo<\"GetValue\">(lhs)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  call %2 = clo<\"ToNumeric\">(%1)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let oldValue = %2\n  if (? oldValue: Number) {\n    call %3 = clo<\"Number::add\">(oldValue, 1.0f)\n    let newValue = %3\n  } else {\n    assert (? oldValue: BigInt)\n    call %4 = clo<\"BigInt::add\">(oldValue, 1n)\n    let newValue = %4\n  }\n  call %5 = clo<\"PutValue\">(lhs, newValue)\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  if (? oldValue: Completion) return oldValue\n  call %6 = clo<\"NormalCompletion\">(oldValue)\n  return %6\n}","def <SYNTAX>:UpdateExpression[2,0].Evaluation(\n  this: Ast[UpdateExpression[2]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let lhs = %0\n  call %1 = clo<\"GetValue\">(lhs)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  call %2 = clo<\"ToNumeric\">(%1)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let oldValue = %2\n  if (? oldValue: Number) {\n    call %3 = clo<\"Number::subtract\">(oldValue, 1.0f)\n    let newValue = %3\n  } else {\n    assert (? oldValue: BigInt)\n    call %4 = clo<\"BigInt::subtract\">(oldValue, 1n)\n    let newValue = %4\n  }\n  call %5 = clo<\"PutValue\">(lhs, newValue)\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  if (? oldValue: Completion) return oldValue\n  call %6 = clo<\"NormalCompletion\">(oldValue)\n  return %6\n}","def <SYNTAX>:UpdateExpression[3,0].Evaluation(\n  this: Ast[UpdateExpression[3]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let expr = %0\n  call %1 = clo<\"GetValue\">(expr)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  call %2 = clo<\"ToNumeric\">(%1)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let oldValue = %2\n  if (? oldValue: Number) {\n    call %3 = clo<\"Number::add\">(oldValue, 1.0f)\n    let newValue = %3\n  } else {\n    assert (? oldValue: BigInt)\n    call %4 = clo<\"BigInt::add\">(oldValue, 1n)\n    let newValue = %4\n  }\n  call %5 = clo<\"PutValue\">(expr, newValue)\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  if (? newValue: Completion) return newValue\n  call %6 = clo<\"NormalCompletion\">(newValue)\n  return %6\n}","def <SYNTAX>:UpdateExpression[4,0].Evaluation(\n  this: Ast[UpdateExpression[4]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let expr = %0\n  call %1 = clo<\"GetValue\">(expr)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  call %2 = clo<\"ToNumeric\">(%1)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let oldValue = %2\n  if (? oldValue: Number) {\n    call %3 = clo<\"Number::subtract\">(oldValue, 1.0f)\n    let newValue = %3\n  } else {\n    assert (? oldValue: BigInt)\n    call %4 = clo<\"BigInt::subtract\">(oldValue, 1n)\n    let newValue = %4\n  }\n  call %5 = clo<\"PutValue\">(expr, newValue)\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  if (? newValue: Completion) return newValue\n  call %6 = clo<\"NormalCompletion\">(newValue)\n  return %6\n}","def <SYNTAX>:UnaryExpression[1,0].Evaluation(\n  this: Ast[UnaryExpression[1]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let ref = %0\n  if (! (? ref: Record[ReferenceRecord])) {\n    call %1 = clo<\"NormalCompletion\">(true)\n    return %1\n  }\n  call %2 = clo<\"IsUnresolvableReference\">(ref)\n  if (= %2 true) {\n    assert (= ref.Strict false)\n    call %3 = clo<\"NormalCompletion\">(true)\n    return %3\n  }\n  call %4 = clo<\"IsPropertyReference\">(ref)\n  if (= %4 true) {\n    call %5 = clo<\"IsPrivateReference\">(ref)\n    assert (= %5 false)\n    call %6 = clo<\"IsSuperReference\">(ref)\n    if (= %6 true) {\n      call %7 = clo<\"__NEW_ERROR_OBJ__\">(\"%ReferenceError.prototype%\")\n      call %8 = clo<\"ThrowCompletion\">(%7)\n      return %8\n    }\n    call %9 = clo<\"ToObject\">(ref.Base)\n    assert (? %9: Completion)\n    if (? %9: Abrupt) return %9\n    else %9 = %9.Value\n    let baseObj = %9\n    call %10 = baseObj.Delete(baseObj, ref.ReferencedName)\n    assert (? %10: Completion)\n    if (? %10: Abrupt) return %10\n    else %10 = %10.Value\n    let deleteStatus = %10\n    if (&& (= deleteStatus false) (= ref.Strict true)) {\n      call %11 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %12 = clo<\"ThrowCompletion\">(%11)\n      return %12\n    }\n    if (? deleteStatus: Completion) return deleteStatus\n    call %13 = clo<\"NormalCompletion\">(deleteStatus)\n    return %13\n  } else {\n    let base = ref.Base\n    assert (? base: Record[EnvironmentRecord])\n    call %14 = base.DeleteBinding(base, ref.ReferencedName)\n    assert (? %14: Completion)\n    return %14\n  }\n}","def <SYNTAX>:UnaryExpression[2,0].Evaluation(\n  this: Ast[UnaryExpression[2]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let expr = %0\n  call %1 = clo<\"GetValue\">(expr)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  call %2 = clo<\"NormalCompletion\">(undefined)\n  return %2\n}","def <SYNTAX>:UnaryExpression[3,0].Evaluation(\n  this: Ast[UnaryExpression[3]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let val = %0\n  if (? val: Record[ReferenceRecord]) {\n    call %1 = clo<\"IsUnresolvableReference\">(val)\n    if (= %1 true) {\n      call %2 = clo<\"NormalCompletion\">(\"undefined\")\n      return %2\n    }\n  }\n  call %3 = clo<\"GetValue\">(val)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  val = %3\n  if (= val undefined) {\n    call %4 = clo<\"NormalCompletion\">(\"undefined\")\n    return %4\n  }\n  if (= val null) {\n    call %5 = clo<\"NormalCompletion\">(\"object\")\n    return %5\n  }\n  if (? val: String) {\n    call %6 = clo<\"NormalCompletion\">(\"string\")\n    return %6\n  }\n  if (? val: Record[Symbol]) {\n    call %7 = clo<\"NormalCompletion\">(\"symbol\")\n    return %7\n  }\n  if (? val: Boolean) {\n    call %8 = clo<\"NormalCompletion\">(\"boolean\")\n    return %8\n  }\n  if (? val: Number) {\n    call %9 = clo<\"NormalCompletion\">(\"number\")\n    return %9\n  }\n  if (? val: BigInt) {\n    call %10 = clo<\"NormalCompletion\">(\"bigint\")\n    return %10\n  }\n  assert (? val: Record[Object])\n  nop\n  if (exists val.Call) {\n    call %11 = clo<\"NormalCompletion\">(\"function\")\n    return %11\n  }\n  call %12 = clo<\"NormalCompletion\">(\"object\")\n  return %12\n}","def <SYNTAX>:UnaryExpression[4,0].Evaluation(\n  this: Ast[UnaryExpression[4]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let expr = %0\n  call %1 = clo<\"GetValue\">(expr)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  call %2 = clo<\"ToNumber\">(%1)\n  assert (? %2: Completion)\n  return %2\n}","def <SYNTAX>:UnaryExpression[5,0].Evaluation(\n  this: Ast[UnaryExpression[5]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let expr = %0\n  call %1 = clo<\"GetValue\">(expr)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  call %2 = clo<\"ToNumeric\">(%1)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let oldValue = %2\n  if (? oldValue: Number) {\n    call %3 = clo<\"Number::unaryMinus\">(oldValue)\n    if (? %3: Completion) return %3\n    call %4 = clo<\"NormalCompletion\">(%3)\n    return %4\n  } else {\n    assert (? oldValue: BigInt)\n    call %5 = clo<\"BigInt::unaryMinus\">(oldValue)\n    if (? %5: Completion) return %5\n    call %6 = clo<\"NormalCompletion\">(%5)\n    return %6\n  }\n}","def <SYNTAX>:UnaryExpression[6,0].Evaluation(\n  this: Ast[UnaryExpression[6]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let expr = %0\n  call %1 = clo<\"GetValue\">(expr)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  call %2 = clo<\"ToNumeric\">(%1)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let oldValue = %2\n  if (? oldValue: Number) {\n    call %3 = clo<\"Number::bitwiseNOT\">(oldValue)\n    if (? %3: Completion) return %3\n    call %4 = clo<\"NormalCompletion\">(%3)\n    return %4\n  } else {\n    assert (? oldValue: BigInt)\n    call %5 = clo<\"BigInt::bitwiseNOT\">(oldValue)\n    if (? %5: Completion) return %5\n    call %6 = clo<\"NormalCompletion\">(%5)\n    return %6\n  }\n}","def <SYNTAX>:UnaryExpression[7,0].Evaluation(\n  this: Ast[UnaryExpression[7]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let expr = %0\n  call %1 = clo<\"GetValue\">(expr)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  call %2 = clo<\"ToBoolean\">(%1)\n  let oldValue = %2\n  if (= oldValue true) {\n    call %3 = clo<\"NormalCompletion\">(false)\n    return %3\n  }\n  call %4 = clo<\"NormalCompletion\">(true)\n  return %4\n}","def <SYNTAX>:ExponentiationExpression[1,0].Evaluation(\n  this: Ast[ExponentiationExpression[1]],\n): Unknown = {\n  call %0 = clo<\"EvaluateStringOrNumericBinaryExpression\">(this[0], \"**\", this[1])\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:MultiplicativeExpression[1,0].Evaluation(\n  this: Ast[MultiplicativeExpression[1]],\n): Unknown = {\n  let opText = (source-text this[1])\n  call %0 = clo<\"EvaluateStringOrNumericBinaryExpression\">(this[0], opText, this[2])\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:AdditiveExpression[1,0].Evaluation(\n  this: Ast[AdditiveExpression[1]],\n): Unknown = {\n  call %0 = clo<\"EvaluateStringOrNumericBinaryExpression\">(this[0], \"+\", this[1])\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:AdditiveExpression[2,0].Evaluation(\n  this: Ast[AdditiveExpression[2]],\n): Unknown = {\n  call %0 = clo<\"EvaluateStringOrNumericBinaryExpression\">(this[0], \"-\", this[1])\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:ShiftExpression[1,0].Evaluation(\n  this: Ast[ShiftExpression[1]],\n): Unknown = {\n  call %0 = clo<\"EvaluateStringOrNumericBinaryExpression\">(this[0], \"<<\", this[1])\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:ShiftExpression[2,0].Evaluation(\n  this: Ast[ShiftExpression[2]],\n): Unknown = {\n  call %0 = clo<\"EvaluateStringOrNumericBinaryExpression\">(this[0], \">>\", this[1])\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:ShiftExpression[3,0].Evaluation(\n  this: Ast[ShiftExpression[3]],\n): Unknown = {\n  call %0 = clo<\"EvaluateStringOrNumericBinaryExpression\">(this[0], \">>>\", this[1])\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:RelationalExpression[1,0].Evaluation(\n  this: Ast[RelationalExpression[1]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let lref = %0\n  call %1 = clo<\"GetValue\">(lref)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let lval = %1\n  sdo-call %2 = this[1]->Evaluation()\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let rref = %2\n  call %3 = clo<\"GetValue\">(rref)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let rval = %3\n  call %4 = clo<\"IsLessThan\">(lval, rval, true)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let r = %4\n  if (= r undefined) {\n    call %5 = clo<\"NormalCompletion\">(false)\n    return %5\n  } else {\n    if (? r: Completion) return r\n    call %6 = clo<\"NormalCompletion\">(r)\n    return %6\n  }\n}","def <SYNTAX>:RelationalExpression[2,0].Evaluation(\n  this: Ast[RelationalExpression[2]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let lref = %0\n  call %1 = clo<\"GetValue\">(lref)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let lval = %1\n  sdo-call %2 = this[1]->Evaluation()\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let rref = %2\n  call %3 = clo<\"GetValue\">(rref)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let rval = %3\n  call %4 = clo<\"IsLessThan\">(rval, lval, false)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let r = %4\n  if (= r undefined) {\n    call %5 = clo<\"NormalCompletion\">(false)\n    return %5\n  } else {\n    if (? r: Completion) return r\n    call %6 = clo<\"NormalCompletion\">(r)\n    return %6\n  }\n}","def <SYNTAX>:RelationalExpression[3,0].Evaluation(\n  this: Ast[RelationalExpression[3]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let lref = %0\n  call %1 = clo<\"GetValue\">(lref)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let lval = %1\n  sdo-call %2 = this[1]->Evaluation()\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let rref = %2\n  call %3 = clo<\"GetValue\">(rref)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let rval = %3\n  call %4 = clo<\"IsLessThan\">(rval, lval, false)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let r = %4\n  if (|| (= r true) (= r undefined)) {\n    call %5 = clo<\"NormalCompletion\">(false)\n    return %5\n  } else {\n    call %6 = clo<\"NormalCompletion\">(true)\n    return %6\n  }\n}","def <SYNTAX>:RelationalExpression[4,0].Evaluation(\n  this: Ast[RelationalExpression[4]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let lref = %0\n  call %1 = clo<\"GetValue\">(lref)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let lval = %1\n  sdo-call %2 = this[1]->Evaluation()\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let rref = %2\n  call %3 = clo<\"GetValue\">(rref)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let rval = %3\n  call %4 = clo<\"IsLessThan\">(lval, rval, true)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let r = %4\n  if (|| (= r true) (= r undefined)) {\n    call %5 = clo<\"NormalCompletion\">(false)\n    return %5\n  } else {\n    call %6 = clo<\"NormalCompletion\">(true)\n    return %6\n  }\n}","def <SYNTAX>:RelationalExpression[5,0].Evaluation(\n  this: Ast[RelationalExpression[5]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let lref = %0\n  call %1 = clo<\"GetValue\">(lref)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let lval = %1\n  sdo-call %2 = this[1]->Evaluation()\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let rref = %2\n  call %3 = clo<\"GetValue\">(rref)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let rval = %3\n  call %4 = clo<\"InstanceofOperator\">(lval, rval)\n  assert (? %4: Completion)\n  return %4\n}","def <SYNTAX>:RelationalExpression[6,0].Evaluation(\n  this: Ast[RelationalExpression[6]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let lref = %0\n  call %1 = clo<\"GetValue\">(lref)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let lval = %1\n  sdo-call %2 = this[1]->Evaluation()\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let rref = %2\n  call %3 = clo<\"GetValue\">(rref)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let rval = %3\n  if (! (? rval: Record[Object])) {\n    call %4 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %5 = clo<\"ThrowCompletion\">(%4)\n    return %5\n  }\n  call %6 = clo<\"ToPropertyKey\">(lval)\n  assert (? %6: Completion)\n  if (? %6: Abrupt) return %6\n  else %6 = %6.Value\n  call %7 = clo<\"HasProperty\">(rval, %6)\n  assert (? %7: Completion)\n  return %7\n}","def <SYNTAX>:RelationalExpression[7,0].Evaluation(\n  this: Ast[RelationalExpression[7]],\n): Unknown = {\n  sdo-call %0 = this[0]->StringValue()\n  let privateIdentifier = %0\n  sdo-call %1 = this[1]->Evaluation()\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let rref = %1\n  call %2 = clo<\"GetValue\">(rref)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let rval = %2\n  if (! (? rval: Record[Object])) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  let privateEnv = @EXECUTION_STACK[0].PrivateEnvironment\n  call %5 = clo<\"ResolvePrivateIdentifier\">(privateEnv, privateIdentifier)\n  let privateName = %5\n  call %6 = clo<\"PrivateElementFind\">(rval, privateName)\n  if (! (= %6 ~empty~)) {\n    call %7 = clo<\"NormalCompletion\">(true)\n    return %7\n  }\n  call %8 = clo<\"NormalCompletion\">(false)\n  return %8\n}","def InstanceofOperator(\n  V: ESValue,\n  target: ESValue,\n): Normal[Boolean] | Throw = {\n  if (! (? target: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"GetMethod\">(target, @SYMBOL.hasInstance)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let instOfHandler = %2\n  if (! (= instOfHandler undefined)) {\n    call %3 = clo<\"Call\">(instOfHandler, target, (list [V])[#521])\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    call %4 = clo<\"ToBoolean\">(%3)\n    if (? %4: Completion) return %4\n    call %5 = clo<\"NormalCompletion\">(%4)\n    return %5\n  }\n  call %6 = clo<\"IsCallable\">(target)\n  if (= %6 false) {\n    call %7 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %8 = clo<\"ThrowCompletion\">(%7)\n    return %8\n  }\n  call %9 = clo<\"OrdinaryHasInstance\">(target, V)\n  assert (? %9: Completion)\n  return %9\n}","def <SYNTAX>:EqualityExpression[1,0].Evaluation(\n  this: Ast[EqualityExpression[1]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let lref = %0\n  call %1 = clo<\"GetValue\">(lref)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let lval = %1\n  sdo-call %2 = this[1]->Evaluation()\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let rref = %2\n  call %3 = clo<\"GetValue\">(rref)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let rval = %3\n  call %4 = clo<\"IsLooselyEqual\">(rval, lval)\n  assert (? %4: Completion)\n  return %4\n}","def <SYNTAX>:EqualityExpression[2,0].Evaluation(\n  this: Ast[EqualityExpression[2]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let lref = %0\n  call %1 = clo<\"GetValue\">(lref)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let lval = %1\n  sdo-call %2 = this[1]->Evaluation()\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let rref = %2\n  call %3 = clo<\"GetValue\">(rref)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let rval = %3\n  call %4 = clo<\"IsLooselyEqual\">(rval, lval)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let r = %4\n  if (= r true) {\n    call %5 = clo<\"NormalCompletion\">(false)\n    return %5\n  } else {\n    call %6 = clo<\"NormalCompletion\">(true)\n    return %6\n  }\n}","def <SYNTAX>:EqualityExpression[3,0].Evaluation(\n  this: Ast[EqualityExpression[3]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let lref = %0\n  call %1 = clo<\"GetValue\">(lref)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let lval = %1\n  sdo-call %2 = this[1]->Evaluation()\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let rref = %2\n  call %3 = clo<\"GetValue\">(rref)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let rval = %3\n  call %4 = clo<\"IsStrictlyEqual\">(rval, lval)\n  if (? %4: Completion) return %4\n  call %5 = clo<\"NormalCompletion\">(%4)\n  return %5\n}","def <SYNTAX>:EqualityExpression[4,0].Evaluation(\n  this: Ast[EqualityExpression[4]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let lref = %0\n  call %1 = clo<\"GetValue\">(lref)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let lval = %1\n  sdo-call %2 = this[1]->Evaluation()\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let rref = %2\n  call %3 = clo<\"GetValue\">(rref)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let rval = %3\n  call %4 = clo<\"IsStrictlyEqual\">(rval, lval)\n  let r = %4\n  if (= r true) {\n    call %5 = clo<\"NormalCompletion\">(false)\n    return %5\n  } else {\n    call %6 = clo<\"NormalCompletion\">(true)\n    return %6\n  }\n}","def <SYNTAX>:BitwiseANDExpression[1,0].Evaluation(\n  this: Ast[BitwiseANDExpression[1]],\n): Unknown = {\n  call %0 = clo<\"EvaluateStringOrNumericBinaryExpression\">(this[0], \"&\", this[1])\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:BitwiseXORExpression[1,0].Evaluation(\n  this: Ast[BitwiseXORExpression[1]],\n): Unknown = {\n  call %0 = clo<\"EvaluateStringOrNumericBinaryExpression\">(this[0], \"^\", this[1])\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:BitwiseORExpression[1,0].Evaluation(\n  this: Ast[BitwiseORExpression[1]],\n): Unknown = {\n  call %0 = clo<\"EvaluateStringOrNumericBinaryExpression\">(this[0], \"|\", this[1])\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:LogicalANDExpression[1,0].Evaluation(\n  this: Ast[LogicalANDExpression[1]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let lref = %0\n  call %1 = clo<\"GetValue\">(lref)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let lval = %1\n  call %2 = clo<\"ToBoolean\">(lval)\n  let lbool = %2\n  if (= lbool false) {\n    if (? lval: Completion) return lval\n    call %3 = clo<\"NormalCompletion\">(lval)\n    return %3\n  }\n  sdo-call %4 = this[1]->Evaluation()\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let rref = %4\n  call %5 = clo<\"GetValue\">(rref)\n  assert (? %5: Completion)\n  return %5\n}","def <SYNTAX>:LogicalORExpression[1,0].Evaluation(\n  this: Ast[LogicalORExpression[1]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let lref = %0\n  call %1 = clo<\"GetValue\">(lref)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let lval = %1\n  call %2 = clo<\"ToBoolean\">(lval)\n  let lbool = %2\n  if (= lbool true) {\n    if (? lval: Completion) return lval\n    call %3 = clo<\"NormalCompletion\">(lval)\n    return %3\n  }\n  sdo-call %4 = this[1]->Evaluation()\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let rref = %4\n  call %5 = clo<\"GetValue\">(rref)\n  assert (? %5: Completion)\n  return %5\n}","def <SYNTAX>:CoalesceExpression[0,0].Evaluation(\n  this: Ast[CoalesceExpression[0]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let lref = %0\n  call %1 = clo<\"GetValue\">(lref)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let lval = %1\n  if (|| (= lval undefined) (= lval null)) {\n    sdo-call %2 = this[1]->Evaluation()\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let rref = %2\n    call %3 = clo<\"GetValue\">(rref)\n    assert (? %3: Completion)\n    return %3\n  } else {\n    if (? lval: Completion) return lval\n    call %4 = clo<\"NormalCompletion\">(lval)\n    return %4\n  }\n}","def <SYNTAX>:ConditionalExpression[1,0].Evaluation(\n  this: Ast[ConditionalExpression[1]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let lref = %0\n  call %1 = clo<\"GetValue\">(lref)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  call %2 = clo<\"ToBoolean\">(%1)\n  let lval = %2\n  if (= lval true) {\n    sdo-call %3 = this[1]->Evaluation()\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let trueRef = %3\n    call %4 = clo<\"GetValue\">(trueRef)\n    assert (? %4: Completion)\n    return %4\n  } else {\n    sdo-call %5 = this[2]->Evaluation()\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n    let falseRef = %5\n    call %6 = clo<\"GetValue\">(falseRef)\n    assert (? %6: Completion)\n    return %6\n  }\n}","def <SYNTAX>:AssignmentExpression[4,0].Evaluation(\n  this: Ast[AssignmentExpression[4]],\n): Unknown = {\n  if (! (|| (? this[0]: Ast[ObjectLiteral]) (? this[0]: Ast[ArrayLiteral]))) {\n    sdo-call %0 = this[0]->Evaluation()\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let lref = %0\n    call %1 = clo<\"IsAnonymousFunctionDefinition\">(this[1])\n    sdo-call %2 = this[0]->IsIdentifierRef()\n    if (&& (= %1 true) (= %2 true)) {\n      sdo-call %3 = this[1]->NamedEvaluation(lref.ReferencedName)\n      assert (? %3: Completion)\n      if (? %3: Abrupt) return %3\n      else %3 = %3.Value\n      let rval = %3\n    } else {\n      sdo-call %4 = this[1]->Evaluation()\n      assert (? %4: Completion)\n      if (? %4: Abrupt) return %4\n      else %4 = %4.Value\n      let rref = %4\n      call %5 = clo<\"GetValue\">(rref)\n      assert (? %5: Completion)\n      if (? %5: Abrupt) return %5\n      else %5 = %5.Value\n      let rval = %5\n    }\n    call %6 = clo<\"PutValue\">(lref, rval)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    if (? rval: Completion) return rval\n    call %7 = clo<\"NormalCompletion\">(rval)\n    return %7\n  }\n  let assignmentPattern = (parse this[0] (grammar-symbol |AssignmentPattern|))\n  sdo-call %8 = this[1]->Evaluation()\n  assert (? %8: Completion)\n  if (? %8: Abrupt) return %8\n  else %8 = %8.Value\n  let rref = %8\n  call %9 = clo<\"GetValue\">(rref)\n  assert (? %9: Completion)\n  if (? %9: Abrupt) return %9\n  else %9 = %9.Value\n  let rval = %9\n  sdo-call %10 = assignmentPattern->DestructuringAssignmentEvaluation(rval)\n  assert (? %10: Completion)\n  if (? %10: Abrupt) return %10\n  else %10 = %10.Value\n  if (? rval: Completion) return rval\n  call %11 = clo<\"NormalCompletion\">(rval)\n  return %11\n}","def <SYNTAX>:AssignmentExpression[5,0].Evaluation(\n  this: Ast[AssignmentExpression[5]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let lref = %0\n  call %1 = clo<\"GetValue\">(lref)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let lval = %1\n  sdo-call %2 = this[2]->Evaluation()\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let rref = %2\n  call %3 = clo<\"GetValue\">(rref)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let rval = %3\n  let assignmentOpText = (source-text this[1])\n  if (= assignmentOpText \"**=\") let opText = \"**\"\n  if (= assignmentOpText \"*=\") let opText = \"*\"\n  if (= assignmentOpText \"/=\") let opText = \"/\"\n  if (= assignmentOpText \"%=\") let opText = \"%\"\n  if (= assignmentOpText \"+=\") let opText = \"+\"\n  if (= assignmentOpText \"-=\") let opText = \"-\"\n  if (= assignmentOpText \"<<=\") let opText = \"<<\"\n  if (= assignmentOpText \">>=\") let opText = \">>\"\n  if (= assignmentOpText \">>>=\") let opText = \">>>\"\n  if (= assignmentOpText \"&=\") let opText = \"&\"\n  if (= assignmentOpText \"^=\") let opText = \"^\"\n  if (= assignmentOpText \"|=\") let opText = \"|\"\n  call %4 = clo<\"ApplyStringOrNumericBinaryOperator\">(lval, opText, rval)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let r = %4\n  call %5 = clo<\"PutValue\">(lref, r)\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  if (? r: Completion) return r\n  call %6 = clo<\"NormalCompletion\">(r)\n  return %6\n}","def <SYNTAX>:AssignmentExpression[6,0].Evaluation(\n  this: Ast[AssignmentExpression[6]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let lref = %0\n  call %1 = clo<\"GetValue\">(lref)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let lval = %1\n  call %2 = clo<\"ToBoolean\">(lval)\n  let lbool = %2\n  if (= lbool false) {\n    if (? lval: Completion) return lval\n    call %3 = clo<\"NormalCompletion\">(lval)\n    return %3\n  }\n  call %5 = clo<\"IsAnonymousFunctionDefinition\">(this[1])\n  %4 = (= %5 true)\n  if %4 {\n    sdo-call %6 = this[0]->IsIdentifierRef()\n    %4 = (= %6 true)\n  }\n  if %4 {\n    sdo-call %7 = this[1]->NamedEvaluation(lref.ReferencedName)\n    assert (? %7: Completion)\n    if (? %7: Abrupt) return %7\n    else %7 = %7.Value\n    let rval = %7\n  } else {\n    sdo-call %8 = this[1]->Evaluation()\n    assert (? %8: Completion)\n    if (? %8: Abrupt) return %8\n    else %8 = %8.Value\n    let rref = %8\n    call %9 = clo<\"GetValue\">(rref)\n    assert (? %9: Completion)\n    if (? %9: Abrupt) return %9\n    else %9 = %9.Value\n    let rval = %9\n  }\n  call %10 = clo<\"PutValue\">(lref, rval)\n  assert (? %10: Completion)\n  if (? %10: Abrupt) return %10\n  else %10 = %10.Value\n  if (? rval: Completion) return rval\n  call %11 = clo<\"NormalCompletion\">(rval)\n  return %11\n}","def <SYNTAX>:AssignmentExpression[7,0].Evaluation(\n  this: Ast[AssignmentExpression[7]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let lref = %0\n  call %1 = clo<\"GetValue\">(lref)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let lval = %1\n  call %2 = clo<\"ToBoolean\">(lval)\n  let lbool = %2\n  if (= lbool true) {\n    if (? lval: Completion) return lval\n    call %3 = clo<\"NormalCompletion\">(lval)\n    return %3\n  }\n  call %5 = clo<\"IsAnonymousFunctionDefinition\">(this[1])\n  %4 = (= %5 true)\n  if %4 {\n    sdo-call %6 = this[0]->IsIdentifierRef()\n    %4 = (= %6 true)\n  }\n  if %4 {\n    sdo-call %7 = this[1]->NamedEvaluation(lref.ReferencedName)\n    assert (? %7: Completion)\n    if (? %7: Abrupt) return %7\n    else %7 = %7.Value\n    let rval = %7\n  } else {\n    sdo-call %8 = this[1]->Evaluation()\n    assert (? %8: Completion)\n    if (? %8: Abrupt) return %8\n    else %8 = %8.Value\n    let rref = %8\n    call %9 = clo<\"GetValue\">(rref)\n    assert (? %9: Completion)\n    if (? %9: Abrupt) return %9\n    else %9 = %9.Value\n    let rval = %9\n  }\n  call %10 = clo<\"PutValue\">(lref, rval)\n  assert (? %10: Completion)\n  if (? %10: Abrupt) return %10\n  else %10 = %10.Value\n  if (? rval: Completion) return rval\n  call %11 = clo<\"NormalCompletion\">(rval)\n  return %11\n}","def <SYNTAX>:AssignmentExpression[8,0].Evaluation(\n  this: Ast[AssignmentExpression[8]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let lref = %0\n  call %1 = clo<\"GetValue\">(lref)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let lval = %1\n  if (! (|| (= lval undefined) (= lval null))) {\n    if (? lval: Completion) return lval\n    call %2 = clo<\"NormalCompletion\">(lval)\n    return %2\n  }\n  call %4 = clo<\"IsAnonymousFunctionDefinition\">(this[1])\n  %3 = (= %4 true)\n  if %3 {\n    sdo-call %5 = this[0]->IsIdentifierRef()\n    %3 = (= %5 true)\n  }\n  if %3 {\n    sdo-call %6 = this[1]->NamedEvaluation(lref.ReferencedName)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    let rval = %6\n  } else {\n    sdo-call %7 = this[1]->Evaluation()\n    assert (? %7: Completion)\n    if (? %7: Abrupt) return %7\n    else %7 = %7.Value\n    let rref = %7\n    call %8 = clo<\"GetValue\">(rref)\n    assert (? %8: Completion)\n    if (? %8: Abrupt) return %8\n    else %8 = %8.Value\n    let rval = %8\n  }\n  call %9 = clo<\"PutValue\">(lref, rval)\n  assert (? %9: Completion)\n  if (? %9: Abrupt) return %9\n  else %9 = %9.Value\n  if (? rval: Completion) return rval\n  call %10 = clo<\"NormalCompletion\">(rval)\n  return %10\n}","def ApplyStringOrNumericBinaryOperator(\n  lval: ESValue,\n  opText: Unknown[\"`**`,`*`,`/`,`%`,`+`,``,`<<`,`>>`,`>>>`,`&`,`^`,Or``\"],\n  rval: ESValue,\n): Normal[Number | BigInt | String] | Throw = {\n  if (= opText \"+\") {\n    call %0 = clo<\"ToPrimitive\">(lval)\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let lprim = %0\n    call %1 = clo<\"ToPrimitive\">(rval)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let rprim = %1\n    if (|| (? lprim: String) (? rprim: String)) {\n      call %2 = clo<\"ToString\">(lprim)\n      assert (? %2: Completion)\n      if (? %2: Abrupt) return %2\n      else %2 = %2.Value\n      let lstr = %2\n      call %3 = clo<\"ToString\">(rprim)\n      assert (? %3: Completion)\n      if (? %3: Abrupt) return %3\n      else %3 = %3.Value\n      let rstr = %3\n      %4 = (concat lstr rstr)\n      if (? %4: Completion) return %4\n      call %5 = clo<\"NormalCompletion\">(%4)\n      return %5\n    }\n    lval = lprim\n    rval = rprim\n  }\n  nop\n  call %6 = clo<\"ToNumeric\">(lval)\n  assert (? %6: Completion)\n  if (? %6: Abrupt) return %6\n  else %6 = %6.Value\n  let lnum = %6\n  call %7 = clo<\"ToNumeric\">(rval)\n  assert (? %7: Completion)\n  if (? %7: Abrupt) return %7\n  else %7 = %7.Value\n  let rnum = %7\n  if (! (= (typeof lnum) (typeof rnum))) {\n    call %8 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %9 = clo<\"ThrowCompletion\">(%8)\n    return %9\n  }\n  if (? lnum: BigInt) {\n    if (= opText \"**\") {\n      call %10 = clo<\"BigInt::exponentiate\">(lnum, rnum)\n      assert (? %10: Completion)\n      return %10\n    }\n    if (= opText \"/\") {\n      call %11 = clo<\"BigInt::divide\">(lnum, rnum)\n      assert (? %11: Completion)\n      return %11\n    }\n    if (= opText \"%\") {\n      call %12 = clo<\"BigInt::remainder\">(lnum, rnum)\n      assert (? %12: Completion)\n      return %12\n    }\n    if (= opText \">>>\") {\n      call %13 = clo<\"BigInt::unsignedRightShift\">(lnum, rnum)\n      assert (? %13: Completion)\n      return %13\n    }\n  }\n  if (? lnum: Number) {\n    if (= opText \"**\") let operation = clo<\"Number::exponentiate\">\n    if (= opText \"*\") let operation = clo<\"Number::multiply\">\n    if (= opText \"/\") let operation = clo<\"Number::divide\">\n    if (= opText \"%\") let operation = clo<\"Number::remainder\">\n    if (= opText \"+\") let operation = clo<\"Number::add\">\n    if (= opText \"-\") let operation = clo<\"Number::subtract\">\n    if (= opText \"<<\") let operation = clo<\"Number::leftShift\">\n    if (= opText \">>\") let operation = clo<\"Number::signedRightShift\">\n    if (= opText \">>>\") let operation = clo<\"Number::unsignedRightShift\">\n    if (= opText \"&\") let operation = clo<\"Number::bitwiseAND\">\n    if (= opText \"^\") let operation = clo<\"Number::bitwiseXOR\">\n    if (= opText \"|\") let operation = clo<\"Number::bitwiseOR\">\n    call __result__ = operation(lnum, rnum)\n    {\n      if (? __result__: Completion) return __result__\n      call %14 = clo<\"NormalCompletion\">(__result__)\n      return %14\n    }\n  } else if (? lnum: BigInt) {\n    if (= opText \"*\") let operation = clo<\"BigInt::multiply\">\n    if (= opText \"+\") let operation = clo<\"BigInt::add\">\n    if (= opText \"-\") let operation = clo<\"BigInt::subtract\">\n    if (= opText \"<<\") let operation = clo<\"BigInt::leftShift\">\n    if (= opText \">>\") let operation = clo<\"BigInt::signedRightShift\">\n    if (= opText \"&\") let operation = clo<\"BigInt::bitwiseAND\">\n    if (= opText \"^\") let operation = clo<\"BigInt::bitwiseXOR\">\n    if (= opText \"|\") let operation = clo<\"BigInt::bitwiseOR\">\n    call __result__ = operation(lnum, rnum)\n    {\n      if (? __result__: Completion) return __result__\n      call %15 = clo<\"NormalCompletion\">(__result__)\n      return %15\n    }\n  }\n  call %16 = operation(lnum, rnum)\n  if (? %16: Completion) return %16\n  call %17 = clo<\"NormalCompletion\">(%16)\n  return %17\n}","def EvaluateStringOrNumericBinaryExpression(\n  leftOperand: Ast,\n  opText: Unknown[\"SequenceOfUnicodeCodePoint\"],\n  rightOperand: Ast,\n): Normal[Number | BigInt | String] | Abrupt = {\n  sdo-call %0 = leftOperand->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let lref = %0\n  call %1 = clo<\"GetValue\">(lref)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let lval = %1\n  sdo-call %2 = rightOperand->Evaluation()\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let rref = %2\n  call %3 = clo<\"GetValue\">(rref)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let rval = %3\n  call %4 = clo<\"ApplyStringOrNumericBinaryOperator\">(lval, opText, rval)\n  assert (? %4: Completion)\n  return %4\n}","def <SYNTAX>:ObjectAssignmentPattern[0,0].DestructuringAssignmentEvaluation(\n  this: Ast[ObjectAssignmentPattern[0]],\n  value: ESValue,\n): Normal[Enum[~unused~]] | Abrupt = {\n  call %0 = clo<\"RequireObjectCoercible\">(value)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"NormalCompletion\">(~unused~)\n  return %1\n}","def <SYNTAX>:ObjectAssignmentPattern[2,0].DestructuringAssignmentEvaluation(\n  this: Ast[ObjectAssignmentPattern[2]],\n  value: ESValue,\n): Normal[Enum[~unused~]] | Abrupt = {\n  call %0 = clo<\"RequireObjectCoercible\">(value)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  sdo-call %1 = this[0]->PropertyDestructuringAssignmentEvaluation(value)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  call %2 = clo<\"NormalCompletion\">(~unused~)\n  return %2\n}","def <SYNTAX>:ObjectAssignmentPattern[3,0].DestructuringAssignmentEvaluation(\n  this: Ast[ObjectAssignmentPattern[3]],\n  value: ESValue,\n): Normal[Enum[~unused~]] | Abrupt = {\n  call %0 = clo<\"RequireObjectCoercible\">(value)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  sdo-call %1 = this[0]->PropertyDestructuringAssignmentEvaluation(value)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  call %2 = clo<\"NormalCompletion\">(~unused~)\n  return %2\n}","def <SYNTAX>:ObjectAssignmentPattern[1,0].DestructuringAssignmentEvaluation(\n  this: Ast[ObjectAssignmentPattern[1]],\n  value: ESValue,\n): Normal[Enum[~unused~]] | Abrupt = {\n  call %0 = clo<\"RequireObjectCoercible\">(value)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let excludedNames = (list [])[#522]\n  sdo-call %1 = this[0]->RestDestructuringAssignmentEvaluation(value, excludedNames)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:ObjectAssignmentPattern[3,1].DestructuringAssignmentEvaluation(\n  this: Ast[ObjectAssignmentPattern[3]],\n  value: ESValue,\n): Normal[Enum[~unused~]] | Abrupt = {\n  call %0 = clo<\"RequireObjectCoercible\">(value)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  sdo-call %1 = this[0]->PropertyDestructuringAssignmentEvaluation(value)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let excludedNames = %1\n  sdo-call %2 = this[1]->RestDestructuringAssignmentEvaluation(value, excludedNames)\n  assert (? %2: Completion)\n  return %2\n}","def <SYNTAX>:ArrayAssignmentPattern[0,0].DestructuringAssignmentEvaluation(\n  this: Ast[ArrayAssignmentPattern[0]],\n  value: ESValue,\n): Normal[Enum[~unused~]] | Abrupt = {\n  call %0 = clo<\"GetIterator\">(value, ~sync~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let iteratorRecord = %0\n  call %1 = clo<\"NormalCompletion\">(~unused~)\n  call %2 = clo<\"IteratorClose\">(iteratorRecord, %1)\n  assert (? %2: Completion)\n  return %2\n}","def <SYNTAX>:ArrayAssignmentPattern[0,2].DestructuringAssignmentEvaluation(\n  this: Ast[ArrayAssignmentPattern[0]],\n  value: ESValue,\n): Normal[Enum[~unused~]] | Abrupt = {\n  call %0 = clo<\"GetIterator\">(value, ~sync~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let iteratorRecord = %0\n  sdo-call %1 = this[0]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n  call %2 = clo<\"Completion\">(%1)\n  let result = %2\n  if (= iteratorRecord.Done false) {\n    call %3 = clo<\"IteratorClose\">(iteratorRecord, result)\n    assert (? %3: Completion)\n    return %3\n  }\n  if (? result: Completion) return result\n  call %4 = clo<\"NormalCompletion\">(result)\n  return %4\n}","def <SYNTAX>:ArrayAssignmentPattern[0,1].DestructuringAssignmentEvaluation(\n  this: Ast[ArrayAssignmentPattern[0]],\n  value: ESValue,\n): Normal[Enum[~unused~]] | Abrupt = {\n  call %0 = clo<\"GetIterator\">(value, ~sync~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let iteratorRecord = %0\n  if (exists this[0]) {\n    sdo-call %1 = this[0]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n    call %2 = clo<\"Completion\">(%1)\n    let status = %2\n    if (&& (? status: Completion) (! (= status.Type ~normal~))) {\n      assert (= iteratorRecord.Done true)\n      assert (? status: Completion)\n      return status\n    }\n  }\n  sdo-call %3 = this[1]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n  call %4 = clo<\"Completion\">(%3)\n  let result = %4\n  if (= iteratorRecord.Done false) {\n    call %5 = clo<\"IteratorClose\">(iteratorRecord, result)\n    assert (? %5: Completion)\n    return %5\n  }\n  if (? result: Completion) return result\n  call %6 = clo<\"NormalCompletion\">(result)\n  return %6\n}","def <SYNTAX>:ArrayAssignmentPattern[0,3].DestructuringAssignmentEvaluation(\n  this: Ast[ArrayAssignmentPattern[0]],\n  value: ESValue,\n): Normal[Enum[~unused~]] | Abrupt = {\n  call %0 = clo<\"GetIterator\">(value, ~sync~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let iteratorRecord = %0\n  if (exists this[0]) {\n    sdo-call %1 = this[0]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n    call %2 = clo<\"Completion\">(%1)\n    let status = %2\n    if (&& (? status: Completion) (! (= status.Type ~normal~))) {\n      assert (= iteratorRecord.Done true)\n      assert (? status: Completion)\n      return status\n    }\n  }\n  sdo-call %3 = this[1]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n  call %4 = clo<\"Completion\">(%3)\n  let result = %4\n  if (= iteratorRecord.Done false) {\n    call %5 = clo<\"IteratorClose\">(iteratorRecord, result)\n    assert (? %5: Completion)\n    return %5\n  }\n  if (? result: Completion) return result\n  call %6 = clo<\"NormalCompletion\">(result)\n  return %6\n}","def <SYNTAX>:ArrayAssignmentPattern[1,0].DestructuringAssignmentEvaluation(\n  this: Ast[ArrayAssignmentPattern[1]],\n  value: ESValue,\n): Normal[Enum[~unused~]] | Abrupt = {\n  call %0 = clo<\"GetIterator\">(value, ~sync~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let iteratorRecord = %0\n  sdo-call %1 = this[0]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n  call %2 = clo<\"Completion\">(%1)\n  let result = %2\n  if (= iteratorRecord.Done false) {\n    call %3 = clo<\"IteratorClose\">(iteratorRecord, result)\n    assert (? %3: Completion)\n    return %3\n  }\n  if (? result: Completion) return result\n  call %4 = clo<\"NormalCompletion\">(result)\n  return %4\n}","def <SYNTAX>:ArrayAssignmentPattern[2,0].DestructuringAssignmentEvaluation(\n  this: Ast[ArrayAssignmentPattern[2]],\n  value: ESValue,\n): Normal[Enum[~unused~]] | Abrupt = {\n  call %0 = clo<\"GetIterator\">(value, ~sync~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let iteratorRecord = %0\n  sdo-call %1 = this[0]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n  call %2 = clo<\"Completion\">(%1)\n  let status = %2\n  if (&& (? status: Completion) (! (= status.Type ~normal~))) {\n    if (= iteratorRecord.Done false) {\n      call %3 = clo<\"IteratorClose\">(iteratorRecord, status)\n      assert (? %3: Completion)\n      return %3\n    }\n    assert (? status: Completion)\n    return status\n  }\n  if (exists this[1]) {\n    sdo-call %4 = this[1]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n    call %5 = clo<\"Completion\">(%4)\n    status = %5\n    if (&& (? status: Completion) (! (= status.Type ~normal~))) {\n      assert (= iteratorRecord.Done true)\n      assert (? status: Completion)\n      return status\n    }\n  }\n  if (exists this[2]) {\n    sdo-call %6 = this[2]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n    call %7 = clo<\"Completion\">(%6)\n    status = %7\n  }\n  if (= iteratorRecord.Done false) {\n    call %8 = clo<\"IteratorClose\">(iteratorRecord, status)\n    assert (? %8: Completion)\n    return %8\n  }\n  assert (? status: Completion)\n  return status\n}","def <SYNTAX>:ArrayAssignmentPattern[2,1].DestructuringAssignmentEvaluation(\n  this: Ast[ArrayAssignmentPattern[2]],\n  value: ESValue,\n): Normal[Enum[~unused~]] | Abrupt = {\n  call %0 = clo<\"GetIterator\">(value, ~sync~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let iteratorRecord = %0\n  sdo-call %1 = this[0]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n  call %2 = clo<\"Completion\">(%1)\n  let status = %2\n  if (&& (? status: Completion) (! (= status.Type ~normal~))) {\n    if (= iteratorRecord.Done false) {\n      call %3 = clo<\"IteratorClose\">(iteratorRecord, status)\n      assert (? %3: Completion)\n      return %3\n    }\n    assert (? status: Completion)\n    return status\n  }\n  if (exists this[1]) {\n    sdo-call %4 = this[1]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n    call %5 = clo<\"Completion\">(%4)\n    status = %5\n    if (&& (? status: Completion) (! (= status.Type ~normal~))) {\n      assert (= iteratorRecord.Done true)\n      assert (? status: Completion)\n      return status\n    }\n  }\n  if (exists this[2]) {\n    sdo-call %6 = this[2]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n    call %7 = clo<\"Completion\">(%6)\n    status = %7\n  }\n  if (= iteratorRecord.Done false) {\n    call %8 = clo<\"IteratorClose\">(iteratorRecord, status)\n    assert (? %8: Completion)\n    return %8\n  }\n  assert (? status: Completion)\n  return status\n}","def <SYNTAX>:ArrayAssignmentPattern[2,2].DestructuringAssignmentEvaluation(\n  this: Ast[ArrayAssignmentPattern[2]],\n  value: ESValue,\n): Normal[Enum[~unused~]] | Abrupt = {\n  call %0 = clo<\"GetIterator\">(value, ~sync~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let iteratorRecord = %0\n  sdo-call %1 = this[0]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n  call %2 = clo<\"Completion\">(%1)\n  let status = %2\n  if (&& (? status: Completion) (! (= status.Type ~normal~))) {\n    if (= iteratorRecord.Done false) {\n      call %3 = clo<\"IteratorClose\">(iteratorRecord, status)\n      assert (? %3: Completion)\n      return %3\n    }\n    assert (? status: Completion)\n    return status\n  }\n  if (exists this[1]) {\n    sdo-call %4 = this[1]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n    call %5 = clo<\"Completion\">(%4)\n    status = %5\n    if (&& (? status: Completion) (! (= status.Type ~normal~))) {\n      assert (= iteratorRecord.Done true)\n      assert (? status: Completion)\n      return status\n    }\n  }\n  if (exists this[2]) {\n    sdo-call %6 = this[2]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n    call %7 = clo<\"Completion\">(%6)\n    status = %7\n  }\n  if (= iteratorRecord.Done false) {\n    call %8 = clo<\"IteratorClose\">(iteratorRecord, status)\n    assert (? %8: Completion)\n    return %8\n  }\n  assert (? status: Completion)\n  return status\n}","def <SYNTAX>:ArrayAssignmentPattern[2,3].DestructuringAssignmentEvaluation(\n  this: Ast[ArrayAssignmentPattern[2]],\n  value: ESValue,\n): Normal[Enum[~unused~]] | Abrupt = {\n  call %0 = clo<\"GetIterator\">(value, ~sync~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let iteratorRecord = %0\n  sdo-call %1 = this[0]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n  call %2 = clo<\"Completion\">(%1)\n  let status = %2\n  if (&& (? status: Completion) (! (= status.Type ~normal~))) {\n    if (= iteratorRecord.Done false) {\n      call %3 = clo<\"IteratorClose\">(iteratorRecord, status)\n      assert (? %3: Completion)\n      return %3\n    }\n    assert (? status: Completion)\n    return status\n  }\n  if (exists this[1]) {\n    sdo-call %4 = this[1]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n    call %5 = clo<\"Completion\">(%4)\n    status = %5\n    if (&& (? status: Completion) (! (= status.Type ~normal~))) {\n      assert (= iteratorRecord.Done true)\n      assert (? status: Completion)\n      return status\n    }\n  }\n  if (exists this[2]) {\n    sdo-call %6 = this[2]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n    call %7 = clo<\"Completion\">(%6)\n    status = %7\n  }\n  if (= iteratorRecord.Done false) {\n    call %8 = clo<\"IteratorClose\">(iteratorRecord, status)\n    assert (? %8: Completion)\n    return %8\n  }\n  assert (? status: Completion)\n  return status\n}","def <SYNTAX>:AssignmentPropertyList[1,0].PropertyDestructuringAssignmentEvaluation(\n  this: Ast[AssignmentPropertyList[1]],\n  value: ESValue,\n): Normal[List[Record[Symbol] | String]] | Abrupt = {\n  sdo-call %0 = this[0]->PropertyDestructuringAssignmentEvaluation(value)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let propertyNames = %0\n  sdo-call %1 = this[1]->PropertyDestructuringAssignmentEvaluation(value)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let nextNames = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [propertyNames, nextNames])[#523])\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <SYNTAX>:AssignmentProperty[0,0].PropertyDestructuringAssignmentEvaluation(\n  this: Ast[AssignmentProperty[0]],\n  value: ESValue,\n): Normal[List[Record[Symbol] | String]] | Abrupt = {\n  sdo-call %0 = this[0]->StringValue()\n  let P = %0\n  call %1 = clo<\"ResolveBinding\">(P)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let lref = %1\n  call %2 = clo<\"GetV\">(value, P)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let v = %2\n  if (&& (exists this[1]) (= v undefined)) {\n    call %3 = clo<\"IsAnonymousFunctionDefinition\">(this[1])\n    if (= %3 true) {\n      sdo-call %4 = this[1]->NamedEvaluation(P)\n      assert (? %4: Completion)\n      if (? %4: Abrupt) return %4\n      else %4 = %4.Value\n      v = %4\n    } else {\n      sdo-call %5 = this[1]->Evaluation()\n      assert (? %5: Completion)\n      if (? %5: Abrupt) return %5\n      else %5 = %5.Value\n      let defaultValue = %5\n      call %6 = clo<\"GetValue\">(defaultValue)\n      assert (? %6: Completion)\n      if (? %6: Abrupt) return %6\n      else %6 = %6.Value\n      v = %6\n    }\n  }\n  call %7 = clo<\"PutValue\">(lref, v)\n  assert (? %7: Completion)\n  if (? %7: Abrupt) return %7\n  else %7 = %7.Value\n  %8 = (list [P])[#524]\n  if (? %8: Completion) return %8\n  call %9 = clo<\"NormalCompletion\">(%8)\n  return %9\n}","def <SYNTAX>:AssignmentProperty[0,1].PropertyDestructuringAssignmentEvaluation(\n  this: Ast[AssignmentProperty[0]],\n  value: ESValue,\n): Normal[List[Record[Symbol] | String]] | Abrupt = {\n  sdo-call %0 = this[0]->StringValue()\n  let P = %0\n  call %1 = clo<\"ResolveBinding\">(P)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let lref = %1\n  call %2 = clo<\"GetV\">(value, P)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let v = %2\n  if (&& (exists this[1]) (= v undefined)) {\n    call %3 = clo<\"IsAnonymousFunctionDefinition\">(this[1])\n    if (= %3 true) {\n      sdo-call %4 = this[1]->NamedEvaluation(P)\n      assert (? %4: Completion)\n      if (? %4: Abrupt) return %4\n      else %4 = %4.Value\n      v = %4\n    } else {\n      sdo-call %5 = this[1]->Evaluation()\n      assert (? %5: Completion)\n      if (? %5: Abrupt) return %5\n      else %5 = %5.Value\n      let defaultValue = %5\n      call %6 = clo<\"GetValue\">(defaultValue)\n      assert (? %6: Completion)\n      if (? %6: Abrupt) return %6\n      else %6 = %6.Value\n      v = %6\n    }\n  }\n  call %7 = clo<\"PutValue\">(lref, v)\n  assert (? %7: Completion)\n  if (? %7: Abrupt) return %7\n  else %7 = %7.Value\n  %8 = (list [P])[#525]\n  if (? %8: Completion) return %8\n  call %9 = clo<\"NormalCompletion\">(%8)\n  return %9\n}","def <SYNTAX>:AssignmentProperty[1,0].PropertyDestructuringAssignmentEvaluation(\n  this: Ast[AssignmentProperty[1]],\n  value: ESValue,\n): Normal[List[Record[Symbol] | String]] | Abrupt = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let name = %0\n  sdo-call %1 = this[1]->KeyedDestructuringAssignmentEvaluation(value, name)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  %2 = (list [name])[#526]\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <SYNTAX>:AssignmentRestProperty[0,0].RestDestructuringAssignmentEvaluation(\n  this: Ast[AssignmentRestProperty[0]],\n  value: ESValue,\n  excludedNames: List[Record[Symbol] | String],\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let lref = %0\n  call %1 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Object.prototype%\"])\n  let restObj = %1\n  call %2 = clo<\"CopyDataProperties\">(restObj, value, excludedNames)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  call %3 = clo<\"PutValue\">(lref, restObj)\n  assert (? %3: Completion)\n  return %3\n}","def <SYNTAX>:AssignmentElementList[0,0].IteratorDestructuringAssignmentEvaluation(\n  this: Ast[AssignmentElementList[0]],\n  iteratorRecord: Record[IteratorRecord],\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:AssignmentElementList[1,0].IteratorDestructuringAssignmentEvaluation(\n  this: Ast[AssignmentElementList[1]],\n  iteratorRecord: Record[IteratorRecord],\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  sdo-call %1 = this[1]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:AssignmentElisionElement[0,0].IteratorDestructuringAssignmentEvaluation(\n  this: Ast[AssignmentElisionElement[0]],\n  iteratorRecord: Record[IteratorRecord],\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[1]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:AssignmentElisionElement[0,1].IteratorDestructuringAssignmentEvaluation(\n  this: Ast[AssignmentElisionElement[0]],\n  iteratorRecord: Record[IteratorRecord],\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  sdo-call %1 = this[1]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:Elision[0,0].IteratorDestructuringAssignmentEvaluation(\n  this: Ast[Elision[0]],\n  iteratorRecord: Record[IteratorRecord],\n): Normal[Enum[~unused~]] | Abrupt = {\n  if (= iteratorRecord.Done false) {\n    call %0 = clo<\"IteratorStep\">(iteratorRecord)\n    call %1 = clo<\"Completion\">(%0)\n    let next = %1\n    if (&& (? next: Completion) (! (= next.Type ~normal~))) {\n      iteratorRecord.Done = true\n    }\n    assert (? next: Completion)\n    if (? next: Abrupt) return next\n    else next = next.Value\n    if (= next false) {\n      iteratorRecord.Done = true\n    }\n  }\n  call %2 = clo<\"NormalCompletion\">(~unused~)\n  return %2\n}","def <SYNTAX>:Elision[1,0].IteratorDestructuringAssignmentEvaluation(\n  this: Ast[Elision[1]],\n  iteratorRecord: Record[IteratorRecord],\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->IteratorDestructuringAssignmentEvaluation(iteratorRecord)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  if (= iteratorRecord.Done false) {\n    call %1 = clo<\"IteratorStep\">(iteratorRecord)\n    call %2 = clo<\"Completion\">(%1)\n    let next = %2\n    if (&& (? next: Completion) (! (= next.Type ~normal~))) {\n      iteratorRecord.Done = true\n    }\n    assert (? next: Completion)\n    if (? next: Abrupt) return next\n    else next = next.Value\n    if (= next false) {\n      iteratorRecord.Done = true\n    }\n  }\n  call %3 = clo<\"NormalCompletion\">(~unused~)\n  return %3\n}","def <SYNTAX>:AssignmentElement[0,0].IteratorDestructuringAssignmentEvaluation(\n  this: Ast[AssignmentElement[0]],\n  iteratorRecord: Record[IteratorRecord],\n): Normal[Enum[~unused~]] | Abrupt = {\n  if (! (|| (? this[0]: Ast[ObjectLiteral]) (? this[0]: Ast[ArrayLiteral]))) {\n    sdo-call %0 = this[0]->Evaluation()\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let lref = %0\n  }\n  let value = undefined\n  if (= iteratorRecord.Done false) {\n    call %1 = clo<\"IteratorStepValue\">(iteratorRecord)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let next = %1\n    if (! (= next ~done~)) {\n      value = next\n    }\n  }\n  if (&& (exists this[1]) (= value undefined)) {\n    call %3 = clo<\"IsAnonymousFunctionDefinition\">(this[1])\n    %2 = (= %3 true)\n    if %2 {\n      sdo-call %4 = this[0]->IsIdentifierRef()\n      %2 = (= %4 true)\n    }\n    if %2 {\n      sdo-call %5 = this[1]->NamedEvaluation(lref.ReferencedName)\n      assert (? %5: Completion)\n      if (? %5: Abrupt) return %5\n      else %5 = %5.Value\n      let v = %5\n    } else {\n      sdo-call %6 = this[1]->Evaluation()\n      assert (? %6: Completion)\n      if (? %6: Abrupt) return %6\n      else %6 = %6.Value\n      let defaultValue = %6\n      call %7 = clo<\"GetValue\">(defaultValue)\n      assert (? %7: Completion)\n      if (? %7: Abrupt) return %7\n      else %7 = %7.Value\n      let v = %7\n    }\n  } else {\n    let v = value\n  }\n  if (? this[0]: Ast[ArrayLiteral | ObjectLiteral]) {\n    let nestedAssignmentPattern = (parse this[0] (grammar-symbol |AssignmentPattern|))\n    sdo-call %8 = nestedAssignmentPattern->DestructuringAssignmentEvaluation(v)\n    assert (? %8: Completion)\n    return %8\n  }\n  call %9 = clo<\"PutValue\">(lref, v)\n  assert (? %9: Completion)\n  return %9\n}","def <SYNTAX>:AssignmentElement[0,1].IteratorDestructuringAssignmentEvaluation(\n  this: Ast[AssignmentElement[0]],\n  iteratorRecord: Record[IteratorRecord],\n): Normal[Enum[~unused~]] | Abrupt = {\n  if (! (|| (? this[0]: Ast[ObjectLiteral]) (? this[0]: Ast[ArrayLiteral]))) {\n    sdo-call %0 = this[0]->Evaluation()\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let lref = %0\n  }\n  let value = undefined\n  if (= iteratorRecord.Done false) {\n    call %1 = clo<\"IteratorStepValue\">(iteratorRecord)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let next = %1\n    if (! (= next ~done~)) {\n      value = next\n    }\n  }\n  if (&& (exists this[1]) (= value undefined)) {\n    call %3 = clo<\"IsAnonymousFunctionDefinition\">(this[1])\n    %2 = (= %3 true)\n    if %2 {\n      sdo-call %4 = this[0]->IsIdentifierRef()\n      %2 = (= %4 true)\n    }\n    if %2 {\n      sdo-call %5 = this[1]->NamedEvaluation(lref.ReferencedName)\n      assert (? %5: Completion)\n      if (? %5: Abrupt) return %5\n      else %5 = %5.Value\n      let v = %5\n    } else {\n      sdo-call %6 = this[1]->Evaluation()\n      assert (? %6: Completion)\n      if (? %6: Abrupt) return %6\n      else %6 = %6.Value\n      let defaultValue = %6\n      call %7 = clo<\"GetValue\">(defaultValue)\n      assert (? %7: Completion)\n      if (? %7: Abrupt) return %7\n      else %7 = %7.Value\n      let v = %7\n    }\n  } else {\n    let v = value\n  }\n  if (? this[0]: Ast[ArrayLiteral | ObjectLiteral]) {\n    let nestedAssignmentPattern = (parse this[0] (grammar-symbol |AssignmentPattern|))\n    sdo-call %8 = nestedAssignmentPattern->DestructuringAssignmentEvaluation(v)\n    assert (? %8: Completion)\n    return %8\n  }\n  call %9 = clo<\"PutValue\">(lref, v)\n  assert (? %9: Completion)\n  return %9\n}","def <SYNTAX>:AssignmentRestElement[0,0].IteratorDestructuringAssignmentEvaluation(\n  this: Ast[AssignmentRestElement[0]],\n  iteratorRecord: Record[IteratorRecord],\n): Normal[Enum[~unused~]] | Abrupt = {\n  if (! (|| (? this[0]: Ast[ObjectLiteral]) (? this[0]: Ast[ArrayLiteral]))) {\n    sdo-call %0 = this[0]->Evaluation()\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let lref = %0\n  }\n  call %1 = clo<\"ArrayCreate\">(0)\n  assert (? %1: Normal)\n  %1 = %1.Value\n  let A = %1\n  let n = 0\n  while (= iteratorRecord.Done false) {\n    call %2 = clo<\"IteratorStepValue\">(iteratorRecord)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let next = %2\n    if (! (= next ~done~)) {\n      call %3 = clo<\"ToString\">(([number] n))\n      assert (? %3: Normal)\n      %3 = %3.Value\n      call %4 = clo<\"CreateDataPropertyOrThrow\">(A, %3, next)\n      assert (? %4: Normal)\n      %4 = %4.Value\n      n = (+ n 1)\n    }\n  }\n  if (! (|| (? this[0]: Ast[ObjectLiteral]) (? this[0]: Ast[ArrayLiteral]))) {\n    call %5 = clo<\"PutValue\">(lref, A)\n    assert (? %5: Completion)\n    return %5\n  }\n  let nestedAssignmentPattern = (parse this[0] (grammar-symbol |AssignmentPattern|))\n  sdo-call %6 = nestedAssignmentPattern->DestructuringAssignmentEvaluation(A)\n  assert (? %6: Completion)\n  return %6\n}","def <SYNTAX>:AssignmentElement[0,0].KeyedDestructuringAssignmentEvaluation(\n  this: Ast[AssignmentElement[0]],\n  value: ESValue,\n  propertyName: Record[Symbol] | String,\n): Normal[Enum[~unused~]] | Abrupt = {\n  if (! (|| (? this[0]: Ast[ObjectLiteral]) (? this[0]: Ast[ArrayLiteral]))) {\n    sdo-call %0 = this[0]->Evaluation()\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let lref = %0\n  }\n  call %1 = clo<\"GetV\">(value, propertyName)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let v = %1\n  if (&& (exists this[1]) (= v undefined)) {\n    call %2 = clo<\"IsAnonymousFunctionDefinition\">(this[1])\n    sdo-call %3 = this[0]->IsIdentifierRef()\n    if (&& (= %2 true) (= %3 true)) {\n      sdo-call %4 = this[1]->NamedEvaluation(lref.ReferencedName)\n      assert (? %4: Completion)\n      if (? %4: Abrupt) return %4\n      else %4 = %4.Value\n      let rhsValue = %4\n    } else {\n      sdo-call %5 = this[1]->Evaluation()\n      assert (? %5: Completion)\n      if (? %5: Abrupt) return %5\n      else %5 = %5.Value\n      let defaultValue = %5\n      call %6 = clo<\"GetValue\">(defaultValue)\n      assert (? %6: Completion)\n      if (? %6: Abrupt) return %6\n      else %6 = %6.Value\n      let rhsValue = %6\n    }\n  } else {\n    let rhsValue = v\n  }\n  if (? this[0]: Ast[ArrayLiteral | ObjectLiteral]) {\n    let assignmentPattern = (parse this[0] (grammar-symbol |AssignmentPattern|))\n    sdo-call %7 = assignmentPattern->DestructuringAssignmentEvaluation(rhsValue)\n    assert (? %7: Completion)\n    return %7\n  }\n  call %8 = clo<\"PutValue\">(lref, rhsValue)\n  assert (? %8: Completion)\n  return %8\n}","def <SYNTAX>:AssignmentElement[0,1].KeyedDestructuringAssignmentEvaluation(\n  this: Ast[AssignmentElement[0]],\n  value: ESValue,\n  propertyName: Record[Symbol] | String,\n): Normal[Enum[~unused~]] | Abrupt = {\n  if (! (|| (? this[0]: Ast[ObjectLiteral]) (? this[0]: Ast[ArrayLiteral]))) {\n    sdo-call %0 = this[0]->Evaluation()\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let lref = %0\n  }\n  call %1 = clo<\"GetV\">(value, propertyName)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let v = %1\n  if (&& (exists this[1]) (= v undefined)) {\n    call %2 = clo<\"IsAnonymousFunctionDefinition\">(this[1])\n    sdo-call %3 = this[0]->IsIdentifierRef()\n    if (&& (= %2 true) (= %3 true)) {\n      sdo-call %4 = this[1]->NamedEvaluation(lref.ReferencedName)\n      assert (? %4: Completion)\n      if (? %4: Abrupt) return %4\n      else %4 = %4.Value\n      let rhsValue = %4\n    } else {\n      sdo-call %5 = this[1]->Evaluation()\n      assert (? %5: Completion)\n      if (? %5: Abrupt) return %5\n      else %5 = %5.Value\n      let defaultValue = %5\n      call %6 = clo<\"GetValue\">(defaultValue)\n      assert (? %6: Completion)\n      if (? %6: Abrupt) return %6\n      else %6 = %6.Value\n      let rhsValue = %6\n    }\n  } else {\n    let rhsValue = v\n  }\n  if (? this[0]: Ast[ArrayLiteral | ObjectLiteral]) {\n    let assignmentPattern = (parse this[0] (grammar-symbol |AssignmentPattern|))\n    sdo-call %7 = assignmentPattern->DestructuringAssignmentEvaluation(rhsValue)\n    assert (? %7: Completion)\n    return %7\n  }\n  call %8 = clo<\"PutValue\">(lref, rhsValue)\n  assert (? %8: Completion)\n  return %8\n}","def <SYNTAX>:Expression[1,0].Evaluation(\n  this: Ast[Expression[1]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let lref = %0\n  call %1 = clo<\"GetValue\">(lref)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  sdo-call %2 = this[1]->Evaluation()\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let rref = %2\n  call %3 = clo<\"GetValue\">(rref)\n  assert (? %3: Completion)\n  return %3\n}","def <SYNTAX>:HoistableDeclaration[1,0].Evaluation(\n  this: Ast[HoistableDeclaration[1]],\n): Unknown = {\n  call %0 = clo<\"NormalCompletion\">(~empty~)\n  return %0\n}","def <SYNTAX>:HoistableDeclaration[2,0].Evaluation(\n  this: Ast[HoistableDeclaration[2]],\n): Unknown = {\n  call %0 = clo<\"NormalCompletion\">(~empty~)\n  return %0\n}","def <SYNTAX>:HoistableDeclaration[3,0].Evaluation(\n  this: Ast[HoistableDeclaration[3]],\n): Unknown = {\n  call %0 = clo<\"NormalCompletion\">(~empty~)\n  return %0\n}","def <SYNTAX>:HoistableDeclaration[0,0].Evaluation(\n  this: Ast[HoistableDeclaration[0]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:BreakableStatement[0,0].Evaluation(\n  this: Ast[BreakableStatement[0]],\n): Unknown = {\n  let newLabelSet = (list [])[#527]\n  sdo-call %0 = this->LabelledEvaluation(newLabelSet)\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:BreakableStatement[1,0].Evaluation(\n  this: Ast[BreakableStatement[1]],\n): Unknown = {\n  let newLabelSet = (list [])[#528]\n  sdo-call %0 = this->LabelledEvaluation(newLabelSet)\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:Block[0,0].Evaluation(\n  this: Ast[Block[0]],\n): Unknown = {\n  call %0 = clo<\"NormalCompletion\">(~empty~)\n  return %0\n}","def <SYNTAX>:Block[0,1].Evaluation(\n  this: Ast[Block[0]],\n): Unknown = {\n  let oldEnv = @EXECUTION_STACK[0].LexicalEnvironment\n  call %0 = clo<\"NewDeclarativeEnvironment\">(oldEnv)\n  let blockEnv = %0\n  call %1 = clo<\"BlockDeclarationInstantiation\">(this[0], blockEnv)\n  @EXECUTION_STACK[0].LexicalEnvironment = blockEnv\n  sdo-call %2 = this[0]->Evaluation()\n  call %3 = clo<\"Completion\">(%2)\n  let blockValue = %3\n  @EXECUTION_STACK[0].LexicalEnvironment = oldEnv\n  assert (? blockValue: Completion)\n  return blockValue\n}","def <SYNTAX>:StatementList[1,0].Evaluation(\n  this: Ast[StatementList[1]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let sl = %0\n  sdo-call %1 = this[1]->Evaluation()\n  call %2 = clo<\"Completion\">(%1)\n  let s = %2\n  call %3 = clo<\"UpdateEmpty\">(s, sl)\n  assert (? %3: Completion)\n  return %3\n}","def BlockDeclarationInstantiation(\n  code: Ast,\n  env: Record[DeclarativeEnvironmentRecord],\n): Enum[~unused~] = {\n  sdo-call %0 = code->LexicallyScopedDeclarations()\n  let declarations = %0\n  let privateEnv = @EXECUTION_STACK[0].PrivateEnvironment\n  %2 = declarations\n  %1 = 0\n  while (< %1 (sizeof %2)) {\n    let d = %2[%1]\n    sdo-call %5 = d->BoundNames()\n    %4 = %5\n    %3 = 0\n    while (< %3 (sizeof %4)) {\n      let dn = %4[%3]\n      sdo-call %6 = d->IsConstantDeclaration()\n      if (= %6 true) {\n        call %7 = env.CreateImmutableBinding(env, dn, true)\n        assert (? %7: Normal)\n        %7 = %7.Value\n      } else {\n        call %8 = env.CreateMutableBinding(env, dn, false)\n        assert (? %8: Normal)\n        %8 = %8.Value\n      }\n      %3 = (+ %3 1)\n    }\n    if (? d: Ast[AsyncFunctionDeclaration | AsyncGeneratorDeclaration | FunctionDeclaration | GeneratorDeclaration]) {\n      sdo-call %9 = d->BoundNames()\n      let fn = %9[0]\n      sdo-call %10 = d->InstantiateFunctionObject(env, privateEnv)\n      let fo = %10\n      call %11 = env.InitializeBinding(env, fn, fo)\n      assert (? %11: Normal)\n      %11 = %11.Value\n    }\n    %1 = (+ %1 1)\n  }\n  return ~unused~\n}","def <SYNTAX>:LexicalDeclaration[0,0].Evaluation(\n  this: Ast[LexicalDeclaration[0]],\n): Unknown = {\n  sdo-call %0 = this[1]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"NormalCompletion\">(~empty~)\n  return %1\n}","def <SYNTAX>:BindingList[1,0].Evaluation(\n  this: Ast[BindingList[1]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  sdo-call %1 = this[1]->Evaluation()\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:LexicalBinding[0,0].Evaluation(\n  this: Ast[LexicalBinding[0]],\n): Unknown = {\n  sdo-call %0 = this[0]->StringValue()\n  call %1 = clo<\"ResolveBinding\">(%0)\n  assert (? %1: Normal)\n  %1 = %1.Value\n  let lhs = %1\n  call %2 = clo<\"InitializeReferencedBinding\">(lhs, undefined)\n  assert (? %2: Normal)\n  %2 = %2.Value\n  call %3 = clo<\"NormalCompletion\">(~empty~)\n  return %3\n}","def <SYNTAX>:LexicalBinding[0,1].Evaluation(\n  this: Ast[LexicalBinding[0]],\n): Unknown = {\n  sdo-call %0 = this[0]->StringValue()\n  let bindingId = %0\n  call %1 = clo<\"ResolveBinding\">(bindingId)\n  assert (? %1: Normal)\n  %1 = %1.Value\n  let lhs = %1\n  call %2 = clo<\"IsAnonymousFunctionDefinition\">(this[1])\n  if (= %2 true) {\n    sdo-call %3 = this[1]->NamedEvaluation(bindingId)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let value = %3\n  } else {\n    sdo-call %4 = this[1]->Evaluation()\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    let rhs = %4\n    call %5 = clo<\"GetValue\">(rhs)\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n    let value = %5\n  }\n  call %6 = clo<\"InitializeReferencedBinding\">(lhs, value)\n  assert (? %6: Normal)\n  %6 = %6.Value\n  call %7 = clo<\"NormalCompletion\">(~empty~)\n  return %7\n}","def <SYNTAX>:LexicalBinding[1,0].Evaluation(\n  this: Ast[LexicalBinding[1]],\n): Unknown = {\n  sdo-call %0 = this[1]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let rhs = %0\n  call %1 = clo<\"GetValue\">(rhs)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let value = %1\n  let env = @EXECUTION_STACK[0].LexicalEnvironment\n  sdo-call %2 = this[0]->BindingInitialization(value, env)\n  assert (? %2: Completion)\n  return %2\n}","def <SYNTAX>:VariableStatement[0,0].Evaluation(\n  this: Ast[VariableStatement[0]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"NormalCompletion\">(~empty~)\n  return %1\n}","def <SYNTAX>:VariableDeclarationList[1,0].Evaluation(\n  this: Ast[VariableDeclarationList[1]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  sdo-call %1 = this[1]->Evaluation()\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:VariableDeclaration[0,0].Evaluation(\n  this: Ast[VariableDeclaration[0]],\n): Unknown = {\n  call %0 = clo<\"NormalCompletion\">(~empty~)\n  return %0\n}","def <SYNTAX>:VariableDeclaration[0,1].Evaluation(\n  this: Ast[VariableDeclaration[0]],\n): Unknown = {\n  sdo-call %0 = this[0]->StringValue()\n  let bindingId = %0\n  call %1 = clo<\"ResolveBinding\">(bindingId)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let lhs = %1\n  call %2 = clo<\"IsAnonymousFunctionDefinition\">(this[1])\n  if (= %2 true) {\n    sdo-call %3 = this[1]->NamedEvaluation(bindingId)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let value = %3\n  } else {\n    sdo-call %4 = this[1]->Evaluation()\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    let rhs = %4\n    call %5 = clo<\"GetValue\">(rhs)\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n    let value = %5\n  }\n  call %6 = clo<\"PutValue\">(lhs, value)\n  assert (? %6: Completion)\n  if (? %6: Abrupt) return %6\n  else %6 = %6.Value\n  call %7 = clo<\"NormalCompletion\">(~empty~)\n  return %7\n}","def <SYNTAX>:VariableDeclaration[1,0].Evaluation(\n  this: Ast[VariableDeclaration[1]],\n): Unknown = {\n  sdo-call %0 = this[1]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let rhs = %0\n  call %1 = clo<\"GetValue\">(rhs)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let rval = %1\n  sdo-call %2 = this[0]->BindingInitialization(rval, undefined)\n  assert (? %2: Completion)\n  return %2\n}","def <SYNTAX>:BindingPropertyList[1,0].PropertyBindingInitialization(\n  this: Ast[BindingPropertyList[1]],\n  value: ESValue,\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[List[Record[Symbol] | String]] | Abrupt = {\n  sdo-call %0 = this[0]->PropertyBindingInitialization(value, environment)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let boundNames = %0\n  sdo-call %1 = this[1]->PropertyBindingInitialization(value, environment)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let nextNames = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [boundNames, nextNames])[#529])\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <SYNTAX>:BindingProperty[0,0].PropertyBindingInitialization(\n  this: Ast[BindingProperty[0]],\n  value: ESValue,\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[List[Record[Symbol] | String]] | Abrupt = {\n  sdo-call %0 = this[0]->BoundNames()\n  let name = %0[0]\n  sdo-call %1 = this[0]->KeyedBindingInitialization(value, environment, name)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  %2 = (list [name])[#530]\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <SYNTAX>:BindingProperty[1,0].PropertyBindingInitialization(\n  this: Ast[BindingProperty[1]],\n  value: ESValue,\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[List[Record[Symbol] | String]] | Abrupt = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let P = %0\n  sdo-call %1 = this[1]->KeyedBindingInitialization(value, environment, P)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  %2 = (list [P])[#531]\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <SYNTAX>:BindingRestProperty[0,0].RestBindingInitialization(\n  this: Ast[BindingRestProperty[0]],\n  value: ESValue,\n  environment: Record[EnvironmentRecord] | Undefined,\n  excludedNames: List[Record[Symbol] | String],\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->StringValue()\n  call %1 = clo<\"ResolveBinding\">(%0, environment)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let lhs = %1\n  call %2 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Object.prototype%\"])\n  let restObj = %2\n  call %3 = clo<\"CopyDataProperties\">(restObj, value, excludedNames)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  if (= environment undefined) {\n    call %4 = clo<\"PutValue\">(lhs, restObj)\n    assert (? %4: Completion)\n    return %4\n  }\n  call %5 = clo<\"InitializeReferencedBinding\">(lhs, restObj)\n  assert (? %5: Completion)\n  return %5\n}","def <SYNTAX>:BindingElement[1,0].KeyedBindingInitialization(\n  this: Ast[BindingElement[1]],\n  value: ESValue,\n  environment: Record[EnvironmentRecord] | Undefined,\n  propertyName: Record[Symbol] | String,\n): Normal[Enum[~unused~]] | Abrupt = {\n  call %0 = clo<\"GetV\">(value, propertyName)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let v = %0\n  if (&& (exists this[1]) (= v undefined)) {\n    sdo-call %1 = this[1]->Evaluation()\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let defaultValue = %1\n    call %2 = clo<\"GetValue\">(defaultValue)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    v = %2\n  }\n  sdo-call %3 = this[0]->BindingInitialization(v, environment)\n  assert (? %3: Completion)\n  return %3\n}","def <SYNTAX>:BindingElement[1,1].KeyedBindingInitialization(\n  this: Ast[BindingElement[1]],\n  value: ESValue,\n  environment: Record[EnvironmentRecord] | Undefined,\n  propertyName: Record[Symbol] | String,\n): Normal[Enum[~unused~]] | Abrupt = {\n  call %0 = clo<\"GetV\">(value, propertyName)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let v = %0\n  if (&& (exists this[1]) (= v undefined)) {\n    sdo-call %1 = this[1]->Evaluation()\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let defaultValue = %1\n    call %2 = clo<\"GetValue\">(defaultValue)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    v = %2\n  }\n  sdo-call %3 = this[0]->BindingInitialization(v, environment)\n  assert (? %3: Completion)\n  return %3\n}","def <SYNTAX>:SingleNameBinding[0,0].KeyedBindingInitialization(\n  this: Ast[SingleNameBinding[0]],\n  value: ESValue,\n  environment: Record[EnvironmentRecord] | Undefined,\n  propertyName: Record[Symbol] | String,\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->StringValue()\n  let bindingId = %0\n  call %1 = clo<\"ResolveBinding\">(bindingId, environment)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let lhs = %1\n  call %2 = clo<\"GetV\">(value, propertyName)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let v = %2\n  if (&& (exists this[1]) (= v undefined)) {\n    call %3 = clo<\"IsAnonymousFunctionDefinition\">(this[1])\n    if (= %3 true) {\n      sdo-call %4 = this[1]->NamedEvaluation(bindingId)\n      assert (? %4: Completion)\n      if (? %4: Abrupt) return %4\n      else %4 = %4.Value\n      v = %4\n    } else {\n      sdo-call %5 = this[1]->Evaluation()\n      assert (? %5: Completion)\n      if (? %5: Abrupt) return %5\n      else %5 = %5.Value\n      let defaultValue = %5\n      call %6 = clo<\"GetValue\">(defaultValue)\n      assert (? %6: Completion)\n      if (? %6: Abrupt) return %6\n      else %6 = %6.Value\n      v = %6\n    }\n  }\n  if (= environment undefined) {\n    call %7 = clo<\"PutValue\">(lhs, v)\n    assert (? %7: Completion)\n    return %7\n  }\n  call %8 = clo<\"InitializeReferencedBinding\">(lhs, v)\n  assert (? %8: Completion)\n  return %8\n}","def <SYNTAX>:SingleNameBinding[0,1].KeyedBindingInitialization(\n  this: Ast[SingleNameBinding[0]],\n  value: ESValue,\n  environment: Record[EnvironmentRecord] | Undefined,\n  propertyName: Record[Symbol] | String,\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->StringValue()\n  let bindingId = %0\n  call %1 = clo<\"ResolveBinding\">(bindingId, environment)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let lhs = %1\n  call %2 = clo<\"GetV\">(value, propertyName)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let v = %2\n  if (&& (exists this[1]) (= v undefined)) {\n    call %3 = clo<\"IsAnonymousFunctionDefinition\">(this[1])\n    if (= %3 true) {\n      sdo-call %4 = this[1]->NamedEvaluation(bindingId)\n      assert (? %4: Completion)\n      if (? %4: Abrupt) return %4\n      else %4 = %4.Value\n      v = %4\n    } else {\n      sdo-call %5 = this[1]->Evaluation()\n      assert (? %5: Completion)\n      if (? %5: Abrupt) return %5\n      else %5 = %5.Value\n      let defaultValue = %5\n      call %6 = clo<\"GetValue\">(defaultValue)\n      assert (? %6: Completion)\n      if (? %6: Abrupt) return %6\n      else %6 = %6.Value\n      v = %6\n    }\n  }\n  if (= environment undefined) {\n    call %7 = clo<\"PutValue\">(lhs, v)\n    assert (? %7: Completion)\n    return %7\n  }\n  call %8 = clo<\"InitializeReferencedBinding\">(lhs, v)\n  assert (? %8: Completion)\n  return %8\n}","def <SYNTAX>:EmptyStatement[0,0].Evaluation(\n  this: Ast[EmptyStatement[0]],\n): Unknown = {\n  call %0 = clo<\"NormalCompletion\">(~empty~)\n  return %0\n}","def <SYNTAX>:ExpressionStatement[0,0].Evaluation(\n  this: Ast[ExpressionStatement[0]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let exprRef = %0\n  call %1 = clo<\"GetValue\">(exprRef)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:IfStatement[0,0].Evaluation(\n  this: Ast[IfStatement[0]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let exprRef = %0\n  call %1 = clo<\"GetValue\">(exprRef)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  call %2 = clo<\"ToBoolean\">(%1)\n  let exprValue = %2\n  if (= exprValue true) {\n    sdo-call %3 = this[1]->Evaluation()\n    call %4 = clo<\"Completion\">(%3)\n    let stmtCompletion = %4\n  } else {\n    sdo-call %5 = this[2]->Evaluation()\n    call %6 = clo<\"Completion\">(%5)\n    let stmtCompletion = %6\n  }\n  call %7 = clo<\"UpdateEmpty\">(stmtCompletion, undefined)\n  assert (? %7: Completion)\n  return %7\n}","def <SYNTAX>:IfStatement[1,0].Evaluation(\n  this: Ast[IfStatement[1]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let exprRef = %0\n  call %1 = clo<\"GetValue\">(exprRef)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  call %2 = clo<\"ToBoolean\">(%1)\n  let exprValue = %2\n  if (= exprValue false) {\n    call %3 = clo<\"NormalCompletion\">(undefined)\n    return %3\n  } else {\n    sdo-call %4 = this[1]->Evaluation()\n    call %5 = clo<\"Completion\">(%4)\n    let stmtCompletion = %5\n    call %6 = clo<\"UpdateEmpty\">(stmtCompletion, undefined)\n    assert (? %6: Completion)\n    return %6\n  }\n}","def LoopContinues(\n  completion: Completion,\n  labelSet: List[String],\n): Boolean = {\n  if (&& (? completion: Completion) (= completion.Type ~normal~)) {\n    return true\n  }\n  if (! (&& (? completion: Completion) (= completion.Type ~continue~))) {\n    return false\n  }\n  if (= completion.Target ~empty~) {\n    return true\n  }\n  if (contains labelSet completion.Target) {\n    return true\n  }\n  return false\n}","def <SYNTAX>:IterationStatement[0,0].LoopEvaluation(\n  this: Ast[IterationStatement[0]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this[0]->DoWhileLoopEvaluation(labelSet)\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:IterationStatement[1,0].LoopEvaluation(\n  this: Ast[IterationStatement[1]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this[0]->WhileLoopEvaluation(labelSet)\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:IterationStatement[2,0].LoopEvaluation(\n  this: Ast[IterationStatement[2]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this[0]->ForLoopEvaluation(labelSet)\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:IterationStatement[3,0].LoopEvaluation(\n  this: Ast[IterationStatement[3]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this[0]->ForInOfLoopEvaluation(labelSet)\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:DoWhileStatement[0,0].DoWhileLoopEvaluation(\n  this: Ast[DoWhileStatement[0]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  let V = undefined\n  while true {\n    sdo-call %0 = this[0]->Evaluation()\n    call %1 = clo<\"Completion\">(%0)\n    let stmtResult = %1\n    call %2 = clo<\"LoopContinues\">(stmtResult, labelSet)\n    if (= %2 false) {\n      call %3 = clo<\"UpdateEmpty\">(stmtResult, V)\n      assert (? %3: Completion)\n      return %3\n    }\n    if (! (= stmtResult.Value ~empty~)) {\n      V = stmtResult.Value\n    }\n    sdo-call %4 = this[1]->Evaluation()\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    let exprRef = %4\n    call %5 = clo<\"GetValue\">(exprRef)\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n    let exprValue = %5\n    call %6 = clo<\"ToBoolean\">(exprValue)\n    if (= %6 false) {\n      if (? V: Completion) return V\n      call %7 = clo<\"NormalCompletion\">(V)\n      return %7\n    }\n  }\n}","def <SYNTAX>:WhileStatement[0,0].WhileLoopEvaluation(\n  this: Ast[WhileStatement[0]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  let V = undefined\n  while true {\n    sdo-call %0 = this[0]->Evaluation()\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let exprRef = %0\n    call %1 = clo<\"GetValue\">(exprRef)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let exprValue = %1\n    call %2 = clo<\"ToBoolean\">(exprValue)\n    if (= %2 false) {\n      if (? V: Completion) return V\n      call %3 = clo<\"NormalCompletion\">(V)\n      return %3\n    }\n    sdo-call %4 = this[1]->Evaluation()\n    call %5 = clo<\"Completion\">(%4)\n    let stmtResult = %5\n    call %6 = clo<\"LoopContinues\">(stmtResult, labelSet)\n    if (= %6 false) {\n      call %7 = clo<\"UpdateEmpty\">(stmtResult, V)\n      assert (? %7: Completion)\n      return %7\n    }\n    if (! (= stmtResult.Value ~empty~)) {\n      V = stmtResult.Value\n    }\n  }\n}","def <SYNTAX>:ForStatement[0,0].ForLoopEvaluation(\n  this: Ast[ForStatement[0]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->Evaluation()\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let exprRef = %0\n    call %1 = clo<\"GetValue\">(exprRef)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n  }\n  if (exists this[1]) {\n    let test = this[1]\n  } else {\n    let test = ~empty~\n  }\n  if (exists this[2]) {\n    let increment = this[2]\n  } else {\n    let increment = ~empty~\n  }\n  call %2 = clo<\"ForBodyEvaluation\">(test, increment, this[3], (list [])[#532], labelSet)\n  assert (? %2: Completion)\n  return %2\n}","def <SYNTAX>:ForStatement[0,1].ForLoopEvaluation(\n  this: Ast[ForStatement[0]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->Evaluation()\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let exprRef = %0\n    call %1 = clo<\"GetValue\">(exprRef)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n  }\n  if (exists this[1]) {\n    let test = this[1]\n  } else {\n    let test = ~empty~\n  }\n  if (exists this[2]) {\n    let increment = this[2]\n  } else {\n    let increment = ~empty~\n  }\n  call %2 = clo<\"ForBodyEvaluation\">(test, increment, this[3], (list [])[#533], labelSet)\n  assert (? %2: Completion)\n  return %2\n}","def <SYNTAX>:ForStatement[0,2].ForLoopEvaluation(\n  this: Ast[ForStatement[0]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->Evaluation()\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let exprRef = %0\n    call %1 = clo<\"GetValue\">(exprRef)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n  }\n  if (exists this[1]) {\n    let test = this[1]\n  } else {\n    let test = ~empty~\n  }\n  if (exists this[2]) {\n    let increment = this[2]\n  } else {\n    let increment = ~empty~\n  }\n  call %2 = clo<\"ForBodyEvaluation\">(test, increment, this[3], (list [])[#534], labelSet)\n  assert (? %2: Completion)\n  return %2\n}","def <SYNTAX>:ForStatement[0,3].ForLoopEvaluation(\n  this: Ast[ForStatement[0]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->Evaluation()\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let exprRef = %0\n    call %1 = clo<\"GetValue\">(exprRef)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n  }\n  if (exists this[1]) {\n    let test = this[1]\n  } else {\n    let test = ~empty~\n  }\n  if (exists this[2]) {\n    let increment = this[2]\n  } else {\n    let increment = ~empty~\n  }\n  call %2 = clo<\"ForBodyEvaluation\">(test, increment, this[3], (list [])[#535], labelSet)\n  assert (? %2: Completion)\n  return %2\n}","def <SYNTAX>:ForStatement[0,4].ForLoopEvaluation(\n  this: Ast[ForStatement[0]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->Evaluation()\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let exprRef = %0\n    call %1 = clo<\"GetValue\">(exprRef)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n  }\n  if (exists this[1]) {\n    let test = this[1]\n  } else {\n    let test = ~empty~\n  }\n  if (exists this[2]) {\n    let increment = this[2]\n  } else {\n    let increment = ~empty~\n  }\n  call %2 = clo<\"ForBodyEvaluation\">(test, increment, this[3], (list [])[#536], labelSet)\n  assert (? %2: Completion)\n  return %2\n}","def <SYNTAX>:ForStatement[0,5].ForLoopEvaluation(\n  this: Ast[ForStatement[0]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->Evaluation()\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let exprRef = %0\n    call %1 = clo<\"GetValue\">(exprRef)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n  }\n  if (exists this[1]) {\n    let test = this[1]\n  } else {\n    let test = ~empty~\n  }\n  if (exists this[2]) {\n    let increment = this[2]\n  } else {\n    let increment = ~empty~\n  }\n  call %2 = clo<\"ForBodyEvaluation\">(test, increment, this[3], (list [])[#537], labelSet)\n  assert (? %2: Completion)\n  return %2\n}","def <SYNTAX>:ForStatement[0,6].ForLoopEvaluation(\n  this: Ast[ForStatement[0]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->Evaluation()\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let exprRef = %0\n    call %1 = clo<\"GetValue\">(exprRef)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n  }\n  if (exists this[1]) {\n    let test = this[1]\n  } else {\n    let test = ~empty~\n  }\n  if (exists this[2]) {\n    let increment = this[2]\n  } else {\n    let increment = ~empty~\n  }\n  call %2 = clo<\"ForBodyEvaluation\">(test, increment, this[3], (list [])[#538], labelSet)\n  assert (? %2: Completion)\n  return %2\n}","def <SYNTAX>:ForStatement[0,7].ForLoopEvaluation(\n  this: Ast[ForStatement[0]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->Evaluation()\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let exprRef = %0\n    call %1 = clo<\"GetValue\">(exprRef)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n  }\n  if (exists this[1]) {\n    let test = this[1]\n  } else {\n    let test = ~empty~\n  }\n  if (exists this[2]) {\n    let increment = this[2]\n  } else {\n    let increment = ~empty~\n  }\n  call %2 = clo<\"ForBodyEvaluation\">(test, increment, this[3], (list [])[#539], labelSet)\n  assert (? %2: Completion)\n  return %2\n}","def <SYNTAX>:ForStatement[1,0].ForLoopEvaluation(\n  this: Ast[ForStatement[1]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  if (exists this[1]) {\n    let test = this[1]\n  } else {\n    let test = ~empty~\n  }\n  if (exists this[2]) {\n    let increment = this[2]\n  } else {\n    let increment = ~empty~\n  }\n  call %1 = clo<\"ForBodyEvaluation\">(test, increment, this[3], (list [])[#540], labelSet)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:ForStatement[1,1].ForLoopEvaluation(\n  this: Ast[ForStatement[1]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  if (exists this[1]) {\n    let test = this[1]\n  } else {\n    let test = ~empty~\n  }\n  if (exists this[2]) {\n    let increment = this[2]\n  } else {\n    let increment = ~empty~\n  }\n  call %1 = clo<\"ForBodyEvaluation\">(test, increment, this[3], (list [])[#541], labelSet)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:ForStatement[1,2].ForLoopEvaluation(\n  this: Ast[ForStatement[1]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  if (exists this[1]) {\n    let test = this[1]\n  } else {\n    let test = ~empty~\n  }\n  if (exists this[2]) {\n    let increment = this[2]\n  } else {\n    let increment = ~empty~\n  }\n  call %1 = clo<\"ForBodyEvaluation\">(test, increment, this[3], (list [])[#542], labelSet)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:ForStatement[1,3].ForLoopEvaluation(\n  this: Ast[ForStatement[1]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  if (exists this[1]) {\n    let test = this[1]\n  } else {\n    let test = ~empty~\n  }\n  if (exists this[2]) {\n    let increment = this[2]\n  } else {\n    let increment = ~empty~\n  }\n  call %1 = clo<\"ForBodyEvaluation\">(test, increment, this[3], (list [])[#543], labelSet)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:ForStatement[2,0].ForLoopEvaluation(\n  this: Ast[ForStatement[2]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  let oldEnv = @EXECUTION_STACK[0].LexicalEnvironment\n  call %0 = clo<\"NewDeclarativeEnvironment\">(oldEnv)\n  let loopEnv = %0\n  sdo-call %1 = this[0]->IsConstantDeclaration()\n  let isConst = %1\n  sdo-call %2 = this[0]->BoundNames()\n  let boundNames = %2\n  %4 = boundNames\n  %3 = 0\n  while (< %3 (sizeof %4)) {\n    let dn = %4[%3]\n    if (= isConst true) {\n      call %5 = loopEnv.CreateImmutableBinding(loopEnv, dn, true)\n      assert (? %5: Normal)\n      %5 = %5.Value\n    } else {\n      call %6 = loopEnv.CreateMutableBinding(loopEnv, dn, false)\n      assert (? %6: Normal)\n      %6 = %6.Value\n    }\n    %3 = (+ %3 1)\n  }\n  @EXECUTION_STACK[0].LexicalEnvironment = loopEnv\n  sdo-call %7 = this[0]->Evaluation()\n  call %8 = clo<\"Completion\">(%7)\n  let forDcl = %8\n  if (&& (? forDcl: Completion) (! (= forDcl.Type ~normal~))) {\n    @EXECUTION_STACK[0].LexicalEnvironment = oldEnv\n    assert (? forDcl: Completion)\n    return forDcl\n  }\n  if (= isConst false) {\n    let perIterationLets = boundNames\n  } else {\n    let perIterationLets = (list [])[#544]\n  }\n  if (exists this[1]) {\n    let test = this[1]\n  } else {\n    let test = ~empty~\n  }\n  if (exists this[2]) {\n    let increment = this[2]\n  } else {\n    let increment = ~empty~\n  }\n  call %9 = clo<\"ForBodyEvaluation\">(test, increment, this[3], perIterationLets, labelSet)\n  call %10 = clo<\"Completion\">(%9)\n  let bodyResult = %10\n  @EXECUTION_STACK[0].LexicalEnvironment = oldEnv\n  assert (? bodyResult: Completion)\n  return bodyResult\n}","def <SYNTAX>:ForStatement[2,1].ForLoopEvaluation(\n  this: Ast[ForStatement[2]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  let oldEnv = @EXECUTION_STACK[0].LexicalEnvironment\n  call %0 = clo<\"NewDeclarativeEnvironment\">(oldEnv)\n  let loopEnv = %0\n  sdo-call %1 = this[0]->IsConstantDeclaration()\n  let isConst = %1\n  sdo-call %2 = this[0]->BoundNames()\n  let boundNames = %2\n  %4 = boundNames\n  %3 = 0\n  while (< %3 (sizeof %4)) {\n    let dn = %4[%3]\n    if (= isConst true) {\n      call %5 = loopEnv.CreateImmutableBinding(loopEnv, dn, true)\n      assert (? %5: Normal)\n      %5 = %5.Value\n    } else {\n      call %6 = loopEnv.CreateMutableBinding(loopEnv, dn, false)\n      assert (? %6: Normal)\n      %6 = %6.Value\n    }\n    %3 = (+ %3 1)\n  }\n  @EXECUTION_STACK[0].LexicalEnvironment = loopEnv\n  sdo-call %7 = this[0]->Evaluation()\n  call %8 = clo<\"Completion\">(%7)\n  let forDcl = %8\n  if (&& (? forDcl: Completion) (! (= forDcl.Type ~normal~))) {\n    @EXECUTION_STACK[0].LexicalEnvironment = oldEnv\n    assert (? forDcl: Completion)\n    return forDcl\n  }\n  if (= isConst false) {\n    let perIterationLets = boundNames\n  } else {\n    let perIterationLets = (list [])[#545]\n  }\n  if (exists this[1]) {\n    let test = this[1]\n  } else {\n    let test = ~empty~\n  }\n  if (exists this[2]) {\n    let increment = this[2]\n  } else {\n    let increment = ~empty~\n  }\n  call %9 = clo<\"ForBodyEvaluation\">(test, increment, this[3], perIterationLets, labelSet)\n  call %10 = clo<\"Completion\">(%9)\n  let bodyResult = %10\n  @EXECUTION_STACK[0].LexicalEnvironment = oldEnv\n  assert (? bodyResult: Completion)\n  return bodyResult\n}","def <SYNTAX>:ForStatement[2,2].ForLoopEvaluation(\n  this: Ast[ForStatement[2]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  let oldEnv = @EXECUTION_STACK[0].LexicalEnvironment\n  call %0 = clo<\"NewDeclarativeEnvironment\">(oldEnv)\n  let loopEnv = %0\n  sdo-call %1 = this[0]->IsConstantDeclaration()\n  let isConst = %1\n  sdo-call %2 = this[0]->BoundNames()\n  let boundNames = %2\n  %4 = boundNames\n  %3 = 0\n  while (< %3 (sizeof %4)) {\n    let dn = %4[%3]\n    if (= isConst true) {\n      call %5 = loopEnv.CreateImmutableBinding(loopEnv, dn, true)\n      assert (? %5: Normal)\n      %5 = %5.Value\n    } else {\n      call %6 = loopEnv.CreateMutableBinding(loopEnv, dn, false)\n      assert (? %6: Normal)\n      %6 = %6.Value\n    }\n    %3 = (+ %3 1)\n  }\n  @EXECUTION_STACK[0].LexicalEnvironment = loopEnv\n  sdo-call %7 = this[0]->Evaluation()\n  call %8 = clo<\"Completion\">(%7)\n  let forDcl = %8\n  if (&& (? forDcl: Completion) (! (= forDcl.Type ~normal~))) {\n    @EXECUTION_STACK[0].LexicalEnvironment = oldEnv\n    assert (? forDcl: Completion)\n    return forDcl\n  }\n  if (= isConst false) {\n    let perIterationLets = boundNames\n  } else {\n    let perIterationLets = (list [])[#546]\n  }\n  if (exists this[1]) {\n    let test = this[1]\n  } else {\n    let test = ~empty~\n  }\n  if (exists this[2]) {\n    let increment = this[2]\n  } else {\n    let increment = ~empty~\n  }\n  call %9 = clo<\"ForBodyEvaluation\">(test, increment, this[3], perIterationLets, labelSet)\n  call %10 = clo<\"Completion\">(%9)\n  let bodyResult = %10\n  @EXECUTION_STACK[0].LexicalEnvironment = oldEnv\n  assert (? bodyResult: Completion)\n  return bodyResult\n}","def <SYNTAX>:ForStatement[2,3].ForLoopEvaluation(\n  this: Ast[ForStatement[2]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  let oldEnv = @EXECUTION_STACK[0].LexicalEnvironment\n  call %0 = clo<\"NewDeclarativeEnvironment\">(oldEnv)\n  let loopEnv = %0\n  sdo-call %1 = this[0]->IsConstantDeclaration()\n  let isConst = %1\n  sdo-call %2 = this[0]->BoundNames()\n  let boundNames = %2\n  %4 = boundNames\n  %3 = 0\n  while (< %3 (sizeof %4)) {\n    let dn = %4[%3]\n    if (= isConst true) {\n      call %5 = loopEnv.CreateImmutableBinding(loopEnv, dn, true)\n      assert (? %5: Normal)\n      %5 = %5.Value\n    } else {\n      call %6 = loopEnv.CreateMutableBinding(loopEnv, dn, false)\n      assert (? %6: Normal)\n      %6 = %6.Value\n    }\n    %3 = (+ %3 1)\n  }\n  @EXECUTION_STACK[0].LexicalEnvironment = loopEnv\n  sdo-call %7 = this[0]->Evaluation()\n  call %8 = clo<\"Completion\">(%7)\n  let forDcl = %8\n  if (&& (? forDcl: Completion) (! (= forDcl.Type ~normal~))) {\n    @EXECUTION_STACK[0].LexicalEnvironment = oldEnv\n    assert (? forDcl: Completion)\n    return forDcl\n  }\n  if (= isConst false) {\n    let perIterationLets = boundNames\n  } else {\n    let perIterationLets = (list [])[#547]\n  }\n  if (exists this[1]) {\n    let test = this[1]\n  } else {\n    let test = ~empty~\n  }\n  if (exists this[2]) {\n    let increment = this[2]\n  } else {\n    let increment = ~empty~\n  }\n  call %9 = clo<\"ForBodyEvaluation\">(test, increment, this[3], perIterationLets, labelSet)\n  call %10 = clo<\"Completion\">(%9)\n  let bodyResult = %10\n  @EXECUTION_STACK[0].LexicalEnvironment = oldEnv\n  assert (? bodyResult: Completion)\n  return bodyResult\n}","def ForBodyEvaluation(\n  test: Unknown[\"ExpressionParseNodeOr~empty~\"],\n  increment: Unknown[\"ExpressionParseNodeOr~empty~\"],\n  stmt: Unknown[\"StatementParseNode\"],\n  perIterationBindings: List[String],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  let V = undefined\n  call %0 = clo<\"CreatePerIterationEnvironment\">(perIterationBindings)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  while true {\n    if (! (= test ~empty~)) {\n      sdo-call %1 = test->Evaluation()\n      assert (? %1: Completion)\n      if (? %1: Abrupt) return %1\n      else %1 = %1.Value\n      let testRef = %1\n      call %2 = clo<\"GetValue\">(testRef)\n      assert (? %2: Completion)\n      if (? %2: Abrupt) return %2\n      else %2 = %2.Value\n      let testValue = %2\n      call %3 = clo<\"ToBoolean\">(testValue)\n      if (= %3 false) {\n        if (? V: Completion) return V\n        call %4 = clo<\"NormalCompletion\">(V)\n        return %4\n      }\n    }\n    sdo-call %5 = stmt->Evaluation()\n    call %6 = clo<\"Completion\">(%5)\n    let result = %6\n    call %7 = clo<\"LoopContinues\">(result, labelSet)\n    if (= %7 false) {\n      call %8 = clo<\"UpdateEmpty\">(result, V)\n      assert (? %8: Completion)\n      return %8\n    }\n    if (! (= result.Value ~empty~)) {\n      V = result.Value\n    }\n    call %9 = clo<\"CreatePerIterationEnvironment\">(perIterationBindings)\n    assert (? %9: Completion)\n    if (? %9: Abrupt) return %9\n    else %9 = %9.Value\n    if (! (= increment ~empty~)) {\n      sdo-call %10 = increment->Evaluation()\n      assert (? %10: Completion)\n      if (? %10: Abrupt) return %10\n      else %10 = %10.Value\n      let incRef = %10\n      call %11 = clo<\"GetValue\">(incRef)\n      assert (? %11: Completion)\n      if (? %11: Abrupt) return %11\n      else %11 = %11.Value\n    }\n  }\n}","def CreatePerIterationEnvironment(\n  perIterationBindings: List[String],\n): Normal[Enum[~unused~]] | Throw = {\n  if (! (= (sizeof perIterationBindings) 0)) {\n    let lastIterationEnv = @EXECUTION_STACK[0].LexicalEnvironment\n    let outer = lastIterationEnv.OuterEnv\n    assert (! (= outer null))\n    call %0 = clo<\"NewDeclarativeEnvironment\">(outer)\n    let thisIterationEnv = %0\n    %2 = perIterationBindings\n    %1 = 0\n    while (< %1 (sizeof %2)) {\n      let bn = %2[%1]\n      call %3 = thisIterationEnv.CreateMutableBinding(thisIterationEnv, bn, false)\n      assert (? %3: Normal)\n      %3 = %3.Value\n      call %4 = lastIterationEnv.GetBindingValue(lastIterationEnv, bn, true)\n      assert (? %4: Completion)\n      if (? %4: Abrupt) return %4\n      else %4 = %4.Value\n      let lastValue = %4\n      call %5 = thisIterationEnv.InitializeBinding(thisIterationEnv, bn, lastValue)\n      assert (? %5: Normal)\n      %5 = %5.Value\n      %1 = (+ %1 1)\n    }\n    @EXECUTION_STACK[0].LexicalEnvironment = thisIterationEnv\n  }\n  call %6 = clo<\"NormalCompletion\">(~unused~)\n  return %6\n}","def <SYNTAX>:MemberExpression[0,0].IsDestructuring(\n  this: Ast[MemberExpression[0]],\n): Boolean = {\n  if (? this[0]: Ast[ArrayLiteral | ObjectLiteral]) {\n    return true\n  }\n  return false\n}","def <SYNTAX>:MemberExpression[1,0].IsDestructuring(\n  this: Ast[MemberExpression[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MemberExpression[2,0].IsDestructuring(\n  this: Ast[MemberExpression[2]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MemberExpression[3,0].IsDestructuring(\n  this: Ast[MemberExpression[3]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MemberExpression[4,0].IsDestructuring(\n  this: Ast[MemberExpression[4]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MemberExpression[5,0].IsDestructuring(\n  this: Ast[MemberExpression[5]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MemberExpression[6,0].IsDestructuring(\n  this: Ast[MemberExpression[6]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MemberExpression[7,0].IsDestructuring(\n  this: Ast[MemberExpression[7]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:NewExpression[1,0].IsDestructuring(\n  this: Ast[NewExpression[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:LeftHandSideExpression[1,0].IsDestructuring(\n  this: Ast[LeftHandSideExpression[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:LeftHandSideExpression[2,0].IsDestructuring(\n  this: Ast[LeftHandSideExpression[2]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ForDeclaration[0,0].IsDestructuring(\n  this: Ast[ForDeclaration[0]],\n): Boolean = {\n  sdo-call %0 = this[1]->IsDestructuring()\n  return %0\n}","def <SYNTAX>:ForBinding[0,0].IsDestructuring(\n  this: Ast[ForBinding[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ForBinding[1,0].IsDestructuring(\n  this: Ast[ForBinding[1]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:ForDeclaration[0,0].ForDeclarationBindingInitialization(\n  this: Ast[ForDeclaration[0]],\n  value: ESValue,\n  environment: Record[EnvironmentRecord] | Undefined,\n): Normal[Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[1]->BindingInitialization(value, environment)\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:ForDeclaration[0,0].ForDeclarationBindingInstantiation(\n  this: Ast[ForDeclaration[0]],\n  environment: Record[DeclarativeEnvironmentRecord],\n): Enum[~unused~] = {\n  sdo-call %2 = this[1]->BoundNames()\n  %1 = %2\n  %0 = 0\n  while (< %0 (sizeof %1)) {\n    let name = %1[%0]\n    sdo-call %3 = this[0]->IsConstantDeclaration()\n    if (= %3 true) {\n      call %4 = environment.CreateImmutableBinding(environment, name, true)\n      assert (? %4: Normal)\n      %4 = %4.Value\n    } else {\n      call %5 = environment.CreateMutableBinding(environment, name, false)\n      assert (? %5: Normal)\n      %5 = %5.Value\n    }\n    %0 = (+ %0 1)\n  }\n  return ~unused~\n}","def <SYNTAX>:ForInOfStatement[0,0].ForInOfLoopEvaluation(\n  this: Ast[ForInOfStatement[0]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  call %0 = clo<\"ForIn/OfHeadEvaluation\">((list [])[#548], this[1], ~enumerate~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let keyResult = %0\n  call %1 = clo<\"ForIn/OfBodyEvaluation\">(this[0], this[2], keyResult, ~enumerate~, ~assignment~, labelSet)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:ForInOfStatement[1,0].ForInOfLoopEvaluation(\n  this: Ast[ForInOfStatement[1]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  call %0 = clo<\"ForIn/OfHeadEvaluation\">((list [])[#549], this[1], ~enumerate~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let keyResult = %0\n  call %1 = clo<\"ForIn/OfBodyEvaluation\">(this[0], this[2], keyResult, ~enumerate~, ~var-binding~, labelSet)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:ForInOfStatement[2,0].ForInOfLoopEvaluation(\n  this: Ast[ForInOfStatement[2]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this[0]->BoundNames()\n  call %1 = clo<\"ForIn/OfHeadEvaluation\">(%0, this[1], ~enumerate~)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let keyResult = %1\n  call %2 = clo<\"ForIn/OfBodyEvaluation\">(this[0], this[2], keyResult, ~enumerate~, ~lexical-binding~, labelSet)\n  assert (? %2: Completion)\n  return %2\n}","def <SYNTAX>:ForInOfStatement[3,0].ForInOfLoopEvaluation(\n  this: Ast[ForInOfStatement[3]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  call %0 = clo<\"ForIn/OfHeadEvaluation\">((list [])[#550], this[1], ~iterate~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let keyResult = %0\n  call %1 = clo<\"ForIn/OfBodyEvaluation\">(this[0], this[2], keyResult, ~iterate~, ~assignment~, labelSet)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:ForInOfStatement[4,0].ForInOfLoopEvaluation(\n  this: Ast[ForInOfStatement[4]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  call %0 = clo<\"ForIn/OfHeadEvaluation\">((list [])[#551], this[1], ~iterate~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let keyResult = %0\n  call %1 = clo<\"ForIn/OfBodyEvaluation\">(this[0], this[2], keyResult, ~iterate~, ~var-binding~, labelSet)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:ForInOfStatement[5,0].ForInOfLoopEvaluation(\n  this: Ast[ForInOfStatement[5]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this[0]->BoundNames()\n  call %1 = clo<\"ForIn/OfHeadEvaluation\">(%0, this[1], ~iterate~)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let keyResult = %1\n  call %2 = clo<\"ForIn/OfBodyEvaluation\">(this[0], this[2], keyResult, ~iterate~, ~lexical-binding~, labelSet)\n  assert (? %2: Completion)\n  return %2\n}","def <SYNTAX>:ForInOfStatement[6,0].ForInOfLoopEvaluation(\n  this: Ast[ForInOfStatement[6]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  call %0 = clo<\"ForIn/OfHeadEvaluation\">((list [])[#552], this[1], ~async-iterate~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let keyResult = %0\n  call %1 = clo<\"ForIn/OfBodyEvaluation\">(this[0], this[2], keyResult, ~iterate~, ~assignment~, labelSet, ~async~)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:ForInOfStatement[7,0].ForInOfLoopEvaluation(\n  this: Ast[ForInOfStatement[7]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  call %0 = clo<\"ForIn/OfHeadEvaluation\">((list [])[#553], this[1], ~async-iterate~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let keyResult = %0\n  call %1 = clo<\"ForIn/OfBodyEvaluation\">(this[0], this[2], keyResult, ~iterate~, ~var-binding~, labelSet, ~async~)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:ForInOfStatement[8,0].ForInOfLoopEvaluation(\n  this: Ast[ForInOfStatement[8]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this[0]->BoundNames()\n  call %1 = clo<\"ForIn/OfHeadEvaluation\">(%0, this[1], ~async-iterate~)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let keyResult = %1\n  call %2 = clo<\"ForIn/OfBodyEvaluation\">(this[0], this[2], keyResult, ~iterate~, ~lexical-binding~, labelSet, ~async~)\n  assert (? %2: Completion)\n  return %2\n}","def ForIn/OfHeadEvaluation(\n  uninitializedBoundNames: List[String],\n  expr: Unknown[\"ExpressionParseNodeOrAnAssignmentExpressionParseNode\"],\n  iterationKind: Enum[~async-iterate~, ~enumerate~, ~iterate~],\n): Normal[Record[IteratorRecord]] | Abrupt = {\n  let oldEnv = @EXECUTION_STACK[0].LexicalEnvironment\n  if (! (= (sizeof uninitializedBoundNames) 0)) {\n    call %0 = clo<\"__HAS_DUPLICATE__\">(uninitializedBoundNames)\n    assert (! %0)\n    call %1 = clo<\"NewDeclarativeEnvironment\">(oldEnv)\n    let newEnv = %1\n    %3 = uninitializedBoundNames\n    %2 = 0\n    while (< %2 (sizeof %3)) {\n      let name = %3[%2]\n      if (? name: String) {\n        call %4 = newEnv.CreateMutableBinding(newEnv, name, false)\n        assert (? %4: Normal)\n        %4 = %4.Value\n      }\n      %2 = (+ %2 1)\n    }\n    @EXECUTION_STACK[0].LexicalEnvironment = newEnv\n  }\n  sdo-call %5 = expr->Evaluation()\n  call %6 = clo<\"Completion\">(%5)\n  let exprRef = %6\n  @EXECUTION_STACK[0].LexicalEnvironment = oldEnv\n  assert (? exprRef: Completion)\n  if (? exprRef: Abrupt) return exprRef\n  else exprRef = exprRef.Value\n  call %7 = clo<\"GetValue\">(exprRef)\n  assert (? %7: Completion)\n  if (? %7: Abrupt) return %7\n  else %7 = %7.Value\n  let exprValue = %7\n  if (= iterationKind ~enumerate~) {\n    if (|| (= exprValue undefined) (= exprValue null)) {\n      %8 = (record [CompletionRecord] {\n        \"Type\" : ~break~,\n        \"Value\" : ~empty~,\n        \"Target\" : ~empty~,\n      })[#554]\n      if (? %8: Completion) return %8\n      call %9 = clo<\"NormalCompletion\">(%8)\n      return %9\n    }\n    call %10 = clo<\"ToObject\">(exprValue)\n    assert (? %10: Normal)\n    %10 = %10.Value\n    let obj = %10\n    call %11 = clo<\"EnumerateObjectProperties\">(obj)\n    let iterator = %11\n    call %12 = clo<\"GetV\">(iterator, \"next\")\n    assert (? %12: Normal)\n    %12 = %12.Value\n    let nextMethod = %12\n    %13 = (record [IteratorRecord] {\n      \"Iterator\" : iterator,\n      \"NextMethod\" : nextMethod,\n      \"Done\" : false,\n    })[#555]\n    if (? %13: Completion) return %13\n    call %14 = clo<\"NormalCompletion\">(%13)\n    return %14\n  } else {\n    assert (|| (= iterationKind ~iterate~) (= iterationKind ~async-iterate~))\n    if (= iterationKind ~async-iterate~) {\n      let iteratorKind = ~async~\n    } else {\n      let iteratorKind = ~sync~\n    }\n    call %15 = clo<\"GetIterator\">(exprValue, iteratorKind)\n    assert (? %15: Completion)\n    return %15\n  }\n}","def ForIn/OfBodyEvaluation(\n  lhs: Ast,\n  stmt: Unknown[\"StatementParseNode\"],\n  iteratorRecord: Record[IteratorRecord],\n  iterationKind: Enum[~enumerate~, ~iterate~],\n  lhsKind: Enum[~assignment~, ~lexical-binding~, ~var-binding~],\n  labelSet: List[String],\n  iteratorKind?: Enum[~async~, ~sync~],\n): Normal[ESValue] | Abrupt = {\n  if (! (exists iteratorKind)) {\n    iteratorKind = ~sync~\n  }\n  let oldEnv = @EXECUTION_STACK[0].LexicalEnvironment\n  let V = undefined\n  sdo-call %0 = lhs->IsDestructuring()\n  let destructuring = %0\n  if (&& (= destructuring true) (= lhsKind ~assignment~)) {\n    assert (? lhs: Ast[LeftHandSideExpression])\n    let assignmentPattern = (parse lhs (grammar-symbol |AssignmentPattern|))\n  }\n  while true {\n    call %1 = clo<\"Call\">(iteratorRecord.NextMethod, iteratorRecord.Iterator)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let nextResult = %1\n    if (= iteratorKind ~async~) {\n      call %2 = clo<\"Await\">(nextResult)\n      assert (? %2: Completion)\n      if (? %2: Abrupt) return %2\n      else %2 = %2.Value\n      nextResult = %2\n    }\n    if (! (? nextResult: Record[Object])) {\n      call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %4 = clo<\"ThrowCompletion\">(%3)\n      return %4\n    }\n    call %5 = clo<\"IteratorComplete\">(nextResult)\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n    let done = %5\n    if (= done true) {\n      if (? V: Completion) return V\n      call %6 = clo<\"NormalCompletion\">(V)\n      return %6\n    }\n    call %7 = clo<\"IteratorValue\">(nextResult)\n    assert (? %7: Completion)\n    if (? %7: Abrupt) return %7\n    else %7 = %7.Value\n    let nextValue = %7\n    if (|| (= lhsKind ~assignment~) (= lhsKind ~var-binding~)) {\n      if (= destructuring true) {\n        if (= lhsKind ~assignment~) {\n          sdo-call %8 = assignmentPattern->DestructuringAssignmentEvaluation(nextValue)\n          call %9 = clo<\"Completion\">(%8)\n          let status = %9\n        } else {\n          assert (= lhsKind ~var-binding~)\n          assert (? lhs: Ast[ForBinding])\n          sdo-call %10 = lhs->BindingInitialization(nextValue, undefined)\n          call %11 = clo<\"Completion\">(%10)\n          let status = %11\n        }\n      } else {\n        sdo-call %12 = lhs->Evaluation()\n        call %13 = clo<\"Completion\">(%12)\n        let lhsRef = %13\n        if (&& (? lhsRef: Completion) (! (= lhsRef.Type ~normal~))) {\n          let status = lhsRef\n        } else {\n          call %14 = clo<\"PutValue\">(lhsRef.Value, nextValue)\n          call %15 = clo<\"Completion\">(%14)\n          let status = %15\n        }\n      }\n    } else {\n      assert (= lhsKind ~lexical-binding~)\n      assert (? lhs: Ast[ForDeclaration])\n      call %16 = clo<\"NewDeclarativeEnvironment\">(oldEnv)\n      let iterationEnv = %16\n      sdo-call %17 = lhs->ForDeclarationBindingInstantiation(iterationEnv)\n      @EXECUTION_STACK[0].LexicalEnvironment = iterationEnv\n      if (= destructuring true) {\n        sdo-call %18 = lhs->ForDeclarationBindingInitialization(nextValue, iterationEnv)\n        call %19 = clo<\"Completion\">(%18)\n        let status = %19\n      } else {\n        assert (yet \"_lhs_ binds a single name.\")\n        sdo-call %20 = lhs->BoundNames()\n        let lhsName = %20[0]\n        call %21 = clo<\"ResolveBinding\">(lhsName)\n        assert (? %21: Normal)\n        %21 = %21.Value\n        let lhsRef = %21\n        call %22 = clo<\"InitializeReferencedBinding\">(lhsRef, nextValue)\n        call %23 = clo<\"Completion\">(%22)\n        let status = %23\n      }\n    }\n    if (&& (? status: Completion) (! (= status.Type ~normal~))) {\n      @EXECUTION_STACK[0].LexicalEnvironment = oldEnv\n      if (= iteratorKind ~async~) {\n        call %24 = clo<\"AsyncIteratorClose\">(iteratorRecord, status)\n        assert (? %24: Completion)\n        return %24\n      }\n      if (= iterationKind ~enumerate~) {\n        assert (? status: Completion)\n        return status\n      } else {\n        assert (= iterationKind ~iterate~)\n        call %25 = clo<\"IteratorClose\">(iteratorRecord, status)\n        assert (? %25: Completion)\n        return %25\n      }\n    }\n    sdo-call %26 = stmt->Evaluation()\n    call %27 = clo<\"Completion\">(%26)\n    let result = %27\n    @EXECUTION_STACK[0].LexicalEnvironment = oldEnv\n    call %28 = clo<\"LoopContinues\">(result, labelSet)\n    if (= %28 false) {\n      if (= iterationKind ~enumerate~) {\n        call %29 = clo<\"UpdateEmpty\">(result, V)\n        assert (? %29: Completion)\n        return %29\n      } else {\n        assert (= iterationKind ~iterate~)\n        call %30 = clo<\"UpdateEmpty\">(result, V)\n        call %31 = clo<\"Completion\">(%30)\n        status = %31\n        if (= iteratorKind ~async~) {\n          call %32 = clo<\"AsyncIteratorClose\">(iteratorRecord, status)\n          assert (? %32: Completion)\n          return %32\n        }\n        call %33 = clo<\"IteratorClose\">(iteratorRecord, status)\n        assert (? %33: Completion)\n        return %33\n      }\n    }\n    if (! (= result.Value ~empty~)) {\n      V = result.Value\n    }\n  }\n}","def <SYNTAX>:BindingIdentifier[0,0].Evaluation(\n  this: Ast[BindingIdentifier[0]],\n): Unknown = {\n  sdo-call %0 = this->StringValue()\n  let bindingId = %0\n  call %1 = clo<\"ResolveBinding\">(bindingId)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:BindingIdentifier[1,0].Evaluation(\n  this: Ast[BindingIdentifier[1]],\n): Unknown = {\n  sdo-call %0 = this->StringValue()\n  let bindingId = %0\n  call %1 = clo<\"ResolveBinding\">(bindingId)\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:BindingIdentifier[2,0].Evaluation(\n  this: Ast[BindingIdentifier[2]],\n): Unknown = {\n  sdo-call %0 = this->StringValue()\n  let bindingId = %0\n  call %1 = clo<\"ResolveBinding\">(bindingId)\n  assert (? %1: Completion)\n  return %1\n}","def EnumerateObjectProperties(\n  O: Record[Object],\n): Record[Iterator] = {\n  call %0 = clo<\"CreateForInIterator\">(O)\n  return %0\n}","def CreateForInIterator(\n  object: Record[Object],\n): Unknown[\"ForInIterator\"] = {\n  call %0 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%ForInIteratorPrototype%\"], (list [\"Object\", \"ObjectWasVisited\", \"VisitedKeys\", \"RemainingKeys\"])[#556])\n  let iterator = %0\n  iterator.Object = object\n  iterator.ObjectWasVisited = false\n  iterator.VisitedKeys = (list [])[#557]\n  iterator.RemainingKeys = (list [])[#558]\n  return iterator\n}","def <BUILTIN>:INTRINSICS.ForInIteratorPrototype.next(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#559]\n  let O = this\n  assert (? O: Record[Object])\n  assert (? O: Record[ForInIterator])\n  let object = O.Object\n  while true {\n    if (= O.ObjectWasVisited false) {\n      call %0 = object.OwnPropertyKeys(object)\n      assert (? %0: Completion)\n      if (? %0: Abrupt) return %0\n      else %0 = %0.Value\n      let keys = %0\n      %2 = keys\n      %1 = 0\n      while (< %1 (sizeof %2)) {\n        let key = %2[%1]\n        if (? key: String) {\n          push O.RemainingKeys < key\n        }\n        %1 = (+ %1 1)\n      }\n      O.ObjectWasVisited = true\n    }\n    while (! (= (sizeof O.RemainingKeys) 0)) {\n      let r = O.RemainingKeys[0]\n      pop %3 < O.RemainingKeys\n      %4 = O.VisitedKeys\n      %5 = 0\n      %6 = false\n      while (&& (! %6) (< %5 (sizeof %4))) {\n        let v = %4[%5]\n        call %7 = clo<\"SameValue\">(r, v)\n        %6 = (= %7 true)\n        %5 = (+ %5 1)\n      }\n      if (! %6) {\n        call %8 = object.GetOwnProperty(object, r)\n        assert (? %8: Completion)\n        if (? %8: Abrupt) return %8\n        else %8 = %8.Value\n        let desc = %8\n        if (! (= desc undefined)) {\n          push O.VisitedKeys < r\n          if (= desc.Enumerable true) {\n            call %9 = clo<\"CreateIterResultObject\">(r, false)\n            if (? %9: Completion) return %9\n            call %10 = clo<\"NormalCompletion\">(%9)\n            return %10\n          }\n        }\n      }\n    }\n    call %11 = object.GetPrototypeOf(object)\n    assert (? %11: Completion)\n    if (? %11: Abrupt) return %11\n    else %11 = %11.Value\n    object = %11\n    O.Object = object\n    O.ObjectWasVisited = false\n    if (= object null) {\n      call %12 = clo<\"CreateIterResultObject\">(undefined, true)\n      if (? %12: Completion) return %12\n      call %13 = clo<\"NormalCompletion\">(%12)\n      return %13\n    }\n  }\n}","def <SYNTAX>:ContinueStatement[0,0].Evaluation(\n  this: Ast[ContinueStatement[0]],\n): Unknown = {\n  %0 = (record [CompletionRecord] {\n    \"Type\" : ~continue~,\n    \"Value\" : ~empty~,\n    \"Target\" : ~empty~,\n  })[#560]\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:ContinueStatement[1,0].Evaluation(\n  this: Ast[ContinueStatement[1]],\n): Unknown = {\n  sdo-call %0 = this[0]->StringValue()\n  let label = %0\n  %1 = (record [CompletionRecord] {\n    \"Type\" : ~continue~,\n    \"Value\" : ~empty~,\n    \"Target\" : label,\n  })[#561]\n  if (? %1: Completion) return %1\n  call %2 = clo<\"NormalCompletion\">(%1)\n  return %2\n}","def <SYNTAX>:BreakStatement[0,0].Evaluation(\n  this: Ast[BreakStatement[0]],\n): Unknown = {\n  %0 = (record [CompletionRecord] {\n    \"Type\" : ~break~,\n    \"Value\" : ~empty~,\n    \"Target\" : ~empty~,\n  })[#562]\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:BreakStatement[1,0].Evaluation(\n  this: Ast[BreakStatement[1]],\n): Unknown = {\n  sdo-call %0 = this[0]->StringValue()\n  let label = %0\n  %1 = (record [CompletionRecord] {\n    \"Type\" : ~break~,\n    \"Value\" : ~empty~,\n    \"Target\" : label,\n  })[#563]\n  if (? %1: Completion) return %1\n  call %2 = clo<\"NormalCompletion\">(%1)\n  return %2\n}","def <SYNTAX>:ReturnStatement[0,0].Evaluation(\n  this: Ast[ReturnStatement[0]],\n): Unknown = {\n  %0 = (record [CompletionRecord] {\n    \"Type\" : ~return~,\n    \"Value\" : undefined,\n    \"Target\" : ~empty~,\n  })[#564]\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:ReturnStatement[1,0].Evaluation(\n  this: Ast[ReturnStatement[1]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let exprRef = %0\n  call %1 = clo<\"GetValue\">(exprRef)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let exprValue = %1\n  call %2 = clo<\"GetGeneratorKind\">()\n  if (= %2 ~async~) {\n    call %3 = clo<\"Await\">(exprValue)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    exprValue = %3\n  }\n  %4 = (record [CompletionRecord] {\n    \"Type\" : ~return~,\n    \"Value\" : exprValue,\n    \"Target\" : ~empty~,\n  })[#565]\n  if (? %4: Completion) return %4\n  call %5 = clo<\"NormalCompletion\">(%4)\n  return %5\n}","def <SYNTAX>:WithStatement[0,0].Evaluation(\n  this: Ast[WithStatement[0]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let val = %0\n  call %1 = clo<\"GetValue\">(val)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  call %2 = clo<\"ToObject\">(%1)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let obj = %2\n  let oldEnv = @EXECUTION_STACK[0].LexicalEnvironment\n  call %3 = clo<\"NewObjectEnvironment\">(obj, true, oldEnv)\n  let newEnv = %3\n  @EXECUTION_STACK[0].LexicalEnvironment = newEnv\n  sdo-call %4 = this[1]->Evaluation()\n  call %5 = clo<\"Completion\">(%4)\n  let C = %5\n  @EXECUTION_STACK[0].LexicalEnvironment = oldEnv\n  call %6 = clo<\"UpdateEmpty\">(C, undefined)\n  assert (? %6: Completion)\n  return %6\n}","def <SYNTAX>:CaseBlock[0,0].CaseBlockEvaluation(\n  this: Ast[CaseBlock[0]],\n  input: ESValue,\n): Normal[ESValue] | Abrupt = {\n  call %0 = clo<\"NormalCompletion\">(undefined)\n  return %0\n}","def <SYNTAX>:CaseBlock[0,1].CaseBlockEvaluation(\n  this: Ast[CaseBlock[0]],\n  input: ESValue,\n): Normal[ESValue] | Abrupt = {\n  let V = undefined\n  call %0 = clo<\"__GET_ITEMS__\">(this[0], (grammar-symbol |CaseClause|), (grammar-symbol |CaseClauses|))\n  let A = %0\n  let found = false\n  %2 = A\n  %1 = 0\n  while (< %1 (sizeof %2)) {\n    let C = %2[%1]\n    if (? C: Ast[CaseClause]) {\n      if (= found false) {\n        call %3 = clo<\"CaseClauseIsSelected\">(C, input)\n        assert (? %3: Completion)\n        if (? %3: Abrupt) return %3\n        else %3 = %3.Value\n        found = %3\n      }\n      if (= found true) {\n        sdo-call %4 = C->Evaluation()\n        call %5 = clo<\"Completion\">(%4)\n        let R = %5\n        if (! (= R.Value ~empty~)) {\n          V = R.Value\n        }\n        if (&& (? R: Completion) (! (= R.Type ~normal~))) {\n          call %6 = clo<\"UpdateEmpty\">(R, V)\n          assert (? %6: Completion)\n          return %6\n        }\n      }\n    }\n    %1 = (+ %1 1)\n  }\n  if (? V: Completion) return V\n  call %7 = clo<\"NormalCompletion\">(V)\n  return %7\n}","def <SYNTAX>:CaseBlock[1,0].CaseBlockEvaluation(\n  this: Ast[CaseBlock[1]],\n  input: ESValue,\n): Normal[ESValue] | Abrupt = {\n  let V = undefined\n  if (exists this[0]) {\n    call %0 = clo<\"__GET_ITEMS__\">(this[0], (grammar-symbol |CaseClause|), (grammar-symbol |CaseClauses|))\n    let A = %0\n  } else {\n    let A = (list [])[#566]\n  }\n  let found = false\n  %2 = A\n  %1 = 0\n  while (< %1 (sizeof %2)) {\n    let C = %2[%1]\n    if (? C: Ast[CaseClause]) {\n      if (= found false) {\n        call %3 = clo<\"CaseClauseIsSelected\">(C, input)\n        assert (? %3: Completion)\n        if (? %3: Abrupt) return %3\n        else %3 = %3.Value\n        found = %3\n      }\n      if (= found true) {\n        sdo-call %4 = C->Evaluation()\n        call %5 = clo<\"Completion\">(%4)\n        let R = %5\n        if (! (= R.Value ~empty~)) {\n          V = R.Value\n        }\n        if (&& (? R: Completion) (! (= R.Type ~normal~))) {\n          call %6 = clo<\"UpdateEmpty\">(R, V)\n          assert (? %6: Completion)\n          return %6\n        }\n      }\n    }\n    %1 = (+ %1 1)\n  }\n  let foundInB = false\n  if (exists this[2]) {\n    call %7 = clo<\"__GET_ITEMS__\">(this[2], (grammar-symbol |CaseClause|), (grammar-symbol |CaseClauses|))\n    let B = %7\n  } else {\n    let B = (list [])[#567]\n  }\n  if (= found false) {\n    %9 = B\n    %8 = 0\n    while (< %8 (sizeof %9)) {\n      let C = %9[%8]\n      if (? C: Ast[CaseClause]) {\n        if (= foundInB false) {\n          call %10 = clo<\"CaseClauseIsSelected\">(C, input)\n          assert (? %10: Completion)\n          if (? %10: Abrupt) return %10\n          else %10 = %10.Value\n          foundInB = %10\n        }\n        if (= foundInB true) {\n          sdo-call %11 = C->Evaluation()\n          call %12 = clo<\"Completion\">(%11)\n          let R = %12\n          if (! (= R.Value ~empty~)) {\n            V = R.Value\n          }\n          if (&& (? R: Completion) (! (= R.Type ~normal~))) {\n            call %13 = clo<\"UpdateEmpty\">(R, V)\n            assert (? %13: Completion)\n            return %13\n          }\n        }\n      }\n      %8 = (+ %8 1)\n    }\n  }\n  if (= foundInB true) {\n    if (? V: Completion) return V\n    call %14 = clo<\"NormalCompletion\">(V)\n    return %14\n  }\n  sdo-call %15 = this[1]->Evaluation()\n  call %16 = clo<\"Completion\">(%15)\n  let defaultR = %16\n  if (! (= defaultR.Value ~empty~)) {\n    V = defaultR.Value\n  }\n  if (&& (? defaultR: Completion) (! (= defaultR.Type ~normal~))) {\n    call %17 = clo<\"UpdateEmpty\">(defaultR, V)\n    assert (? %17: Completion)\n    return %17\n  }\n  nop\n  %19 = B\n  %18 = 0\n  while (< %18 (sizeof %19)) {\n    let C = %19[%18]\n    if (? C: Ast[CaseClause]) {\n      sdo-call %20 = C->Evaluation()\n      call %21 = clo<\"Completion\">(%20)\n      let R = %21\n      if (! (= R.Value ~empty~)) {\n        V = R.Value\n      }\n      if (&& (? R: Completion) (! (= R.Type ~normal~))) {\n        call %22 = clo<\"UpdateEmpty\">(R, V)\n        assert (? %22: Completion)\n        return %22\n      }\n    }\n    %18 = (+ %18 1)\n  }\n  if (? V: Completion) return V\n  call %23 = clo<\"NormalCompletion\">(V)\n  return %23\n}","def <SYNTAX>:CaseBlock[1,1].CaseBlockEvaluation(\n  this: Ast[CaseBlock[1]],\n  input: ESValue,\n): Normal[ESValue] | Abrupt = {\n  let V = undefined\n  if (exists this[0]) {\n    call %0 = clo<\"__GET_ITEMS__\">(this[0], (grammar-symbol |CaseClause|), (grammar-symbol |CaseClauses|))\n    let A = %0\n  } else {\n    let A = (list [])[#568]\n  }\n  let found = false\n  %2 = A\n  %1 = 0\n  while (< %1 (sizeof %2)) {\n    let C = %2[%1]\n    if (? C: Ast[CaseClause]) {\n      if (= found false) {\n        call %3 = clo<\"CaseClauseIsSelected\">(C, input)\n        assert (? %3: Completion)\n        if (? %3: Abrupt) return %3\n        else %3 = %3.Value\n        found = %3\n      }\n      if (= found true) {\n        sdo-call %4 = C->Evaluation()\n        call %5 = clo<\"Completion\">(%4)\n        let R = %5\n        if (! (= R.Value ~empty~)) {\n          V = R.Value\n        }\n        if (&& (? R: Completion) (! (= R.Type ~normal~))) {\n          call %6 = clo<\"UpdateEmpty\">(R, V)\n          assert (? %6: Completion)\n          return %6\n        }\n      }\n    }\n    %1 = (+ %1 1)\n  }\n  let foundInB = false\n  if (exists this[2]) {\n    call %7 = clo<\"__GET_ITEMS__\">(this[2], (grammar-symbol |CaseClause|), (grammar-symbol |CaseClauses|))\n    let B = %7\n  } else {\n    let B = (list [])[#569]\n  }\n  if (= found false) {\n    %9 = B\n    %8 = 0\n    while (< %8 (sizeof %9)) {\n      let C = %9[%8]\n      if (? C: Ast[CaseClause]) {\n        if (= foundInB false) {\n          call %10 = clo<\"CaseClauseIsSelected\">(C, input)\n          assert (? %10: Completion)\n          if (? %10: Abrupt) return %10\n          else %10 = %10.Value\n          foundInB = %10\n        }\n        if (= foundInB true) {\n          sdo-call %11 = C->Evaluation()\n          call %12 = clo<\"Completion\">(%11)\n          let R = %12\n          if (! (= R.Value ~empty~)) {\n            V = R.Value\n          }\n          if (&& (? R: Completion) (! (= R.Type ~normal~))) {\n            call %13 = clo<\"UpdateEmpty\">(R, V)\n            assert (? %13: Completion)\n            return %13\n          }\n        }\n      }\n      %8 = (+ %8 1)\n    }\n  }\n  if (= foundInB true) {\n    if (? V: Completion) return V\n    call %14 = clo<\"NormalCompletion\">(V)\n    return %14\n  }\n  sdo-call %15 = this[1]->Evaluation()\n  call %16 = clo<\"Completion\">(%15)\n  let defaultR = %16\n  if (! (= defaultR.Value ~empty~)) {\n    V = defaultR.Value\n  }\n  if (&& (? defaultR: Completion) (! (= defaultR.Type ~normal~))) {\n    call %17 = clo<\"UpdateEmpty\">(defaultR, V)\n    assert (? %17: Completion)\n    return %17\n  }\n  nop\n  %19 = B\n  %18 = 0\n  while (< %18 (sizeof %19)) {\n    let C = %19[%18]\n    if (? C: Ast[CaseClause]) {\n      sdo-call %20 = C->Evaluation()\n      call %21 = clo<\"Completion\">(%20)\n      let R = %21\n      if (! (= R.Value ~empty~)) {\n        V = R.Value\n      }\n      if (&& (? R: Completion) (! (= R.Type ~normal~))) {\n        call %22 = clo<\"UpdateEmpty\">(R, V)\n        assert (? %22: Completion)\n        return %22\n      }\n    }\n    %18 = (+ %18 1)\n  }\n  if (? V: Completion) return V\n  call %23 = clo<\"NormalCompletion\">(V)\n  return %23\n}","def <SYNTAX>:CaseBlock[1,2].CaseBlockEvaluation(\n  this: Ast[CaseBlock[1]],\n  input: ESValue,\n): Normal[ESValue] | Abrupt = {\n  let V = undefined\n  if (exists this[0]) {\n    call %0 = clo<\"__GET_ITEMS__\">(this[0], (grammar-symbol |CaseClause|), (grammar-symbol |CaseClauses|))\n    let A = %0\n  } else {\n    let A = (list [])[#570]\n  }\n  let found = false\n  %2 = A\n  %1 = 0\n  while (< %1 (sizeof %2)) {\n    let C = %2[%1]\n    if (? C: Ast[CaseClause]) {\n      if (= found false) {\n        call %3 = clo<\"CaseClauseIsSelected\">(C, input)\n        assert (? %3: Completion)\n        if (? %3: Abrupt) return %3\n        else %3 = %3.Value\n        found = %3\n      }\n      if (= found true) {\n        sdo-call %4 = C->Evaluation()\n        call %5 = clo<\"Completion\">(%4)\n        let R = %5\n        if (! (= R.Value ~empty~)) {\n          V = R.Value\n        }\n        if (&& (? R: Completion) (! (= R.Type ~normal~))) {\n          call %6 = clo<\"UpdateEmpty\">(R, V)\n          assert (? %6: Completion)\n          return %6\n        }\n      }\n    }\n    %1 = (+ %1 1)\n  }\n  let foundInB = false\n  if (exists this[2]) {\n    call %7 = clo<\"__GET_ITEMS__\">(this[2], (grammar-symbol |CaseClause|), (grammar-symbol |CaseClauses|))\n    let B = %7\n  } else {\n    let B = (list [])[#571]\n  }\n  if (= found false) {\n    %9 = B\n    %8 = 0\n    while (< %8 (sizeof %9)) {\n      let C = %9[%8]\n      if (? C: Ast[CaseClause]) {\n        if (= foundInB false) {\n          call %10 = clo<\"CaseClauseIsSelected\">(C, input)\n          assert (? %10: Completion)\n          if (? %10: Abrupt) return %10\n          else %10 = %10.Value\n          foundInB = %10\n        }\n        if (= foundInB true) {\n          sdo-call %11 = C->Evaluation()\n          call %12 = clo<\"Completion\">(%11)\n          let R = %12\n          if (! (= R.Value ~empty~)) {\n            V = R.Value\n          }\n          if (&& (? R: Completion) (! (= R.Type ~normal~))) {\n            call %13 = clo<\"UpdateEmpty\">(R, V)\n            assert (? %13: Completion)\n            return %13\n          }\n        }\n      }\n      %8 = (+ %8 1)\n    }\n  }\n  if (= foundInB true) {\n    if (? V: Completion) return V\n    call %14 = clo<\"NormalCompletion\">(V)\n    return %14\n  }\n  sdo-call %15 = this[1]->Evaluation()\n  call %16 = clo<\"Completion\">(%15)\n  let defaultR = %16\n  if (! (= defaultR.Value ~empty~)) {\n    V = defaultR.Value\n  }\n  if (&& (? defaultR: Completion) (! (= defaultR.Type ~normal~))) {\n    call %17 = clo<\"UpdateEmpty\">(defaultR, V)\n    assert (? %17: Completion)\n    return %17\n  }\n  nop\n  %19 = B\n  %18 = 0\n  while (< %18 (sizeof %19)) {\n    let C = %19[%18]\n    if (? C: Ast[CaseClause]) {\n      sdo-call %20 = C->Evaluation()\n      call %21 = clo<\"Completion\">(%20)\n      let R = %21\n      if (! (= R.Value ~empty~)) {\n        V = R.Value\n      }\n      if (&& (? R: Completion) (! (= R.Type ~normal~))) {\n        call %22 = clo<\"UpdateEmpty\">(R, V)\n        assert (? %22: Completion)\n        return %22\n      }\n    }\n    %18 = (+ %18 1)\n  }\n  if (? V: Completion) return V\n  call %23 = clo<\"NormalCompletion\">(V)\n  return %23\n}","def <SYNTAX>:CaseBlock[1,3].CaseBlockEvaluation(\n  this: Ast[CaseBlock[1]],\n  input: ESValue,\n): Normal[ESValue] | Abrupt = {\n  let V = undefined\n  if (exists this[0]) {\n    call %0 = clo<\"__GET_ITEMS__\">(this[0], (grammar-symbol |CaseClause|), (grammar-symbol |CaseClauses|))\n    let A = %0\n  } else {\n    let A = (list [])[#572]\n  }\n  let found = false\n  %2 = A\n  %1 = 0\n  while (< %1 (sizeof %2)) {\n    let C = %2[%1]\n    if (? C: Ast[CaseClause]) {\n      if (= found false) {\n        call %3 = clo<\"CaseClauseIsSelected\">(C, input)\n        assert (? %3: Completion)\n        if (? %3: Abrupt) return %3\n        else %3 = %3.Value\n        found = %3\n      }\n      if (= found true) {\n        sdo-call %4 = C->Evaluation()\n        call %5 = clo<\"Completion\">(%4)\n        let R = %5\n        if (! (= R.Value ~empty~)) {\n          V = R.Value\n        }\n        if (&& (? R: Completion) (! (= R.Type ~normal~))) {\n          call %6 = clo<\"UpdateEmpty\">(R, V)\n          assert (? %6: Completion)\n          return %6\n        }\n      }\n    }\n    %1 = (+ %1 1)\n  }\n  let foundInB = false\n  if (exists this[2]) {\n    call %7 = clo<\"__GET_ITEMS__\">(this[2], (grammar-symbol |CaseClause|), (grammar-symbol |CaseClauses|))\n    let B = %7\n  } else {\n    let B = (list [])[#573]\n  }\n  if (= found false) {\n    %9 = B\n    %8 = 0\n    while (< %8 (sizeof %9)) {\n      let C = %9[%8]\n      if (? C: Ast[CaseClause]) {\n        if (= foundInB false) {\n          call %10 = clo<\"CaseClauseIsSelected\">(C, input)\n          assert (? %10: Completion)\n          if (? %10: Abrupt) return %10\n          else %10 = %10.Value\n          foundInB = %10\n        }\n        if (= foundInB true) {\n          sdo-call %11 = C->Evaluation()\n          call %12 = clo<\"Completion\">(%11)\n          let R = %12\n          if (! (= R.Value ~empty~)) {\n            V = R.Value\n          }\n          if (&& (? R: Completion) (! (= R.Type ~normal~))) {\n            call %13 = clo<\"UpdateEmpty\">(R, V)\n            assert (? %13: Completion)\n            return %13\n          }\n        }\n      }\n      %8 = (+ %8 1)\n    }\n  }\n  if (= foundInB true) {\n    if (? V: Completion) return V\n    call %14 = clo<\"NormalCompletion\">(V)\n    return %14\n  }\n  sdo-call %15 = this[1]->Evaluation()\n  call %16 = clo<\"Completion\">(%15)\n  let defaultR = %16\n  if (! (= defaultR.Value ~empty~)) {\n    V = defaultR.Value\n  }\n  if (&& (? defaultR: Completion) (! (= defaultR.Type ~normal~))) {\n    call %17 = clo<\"UpdateEmpty\">(defaultR, V)\n    assert (? %17: Completion)\n    return %17\n  }\n  nop\n  %19 = B\n  %18 = 0\n  while (< %18 (sizeof %19)) {\n    let C = %19[%18]\n    if (? C: Ast[CaseClause]) {\n      sdo-call %20 = C->Evaluation()\n      call %21 = clo<\"Completion\">(%20)\n      let R = %21\n      if (! (= R.Value ~empty~)) {\n        V = R.Value\n      }\n      if (&& (? R: Completion) (! (= R.Type ~normal~))) {\n        call %22 = clo<\"UpdateEmpty\">(R, V)\n        assert (? %22: Completion)\n        return %22\n      }\n    }\n    %18 = (+ %18 1)\n  }\n  if (? V: Completion) return V\n  call %23 = clo<\"NormalCompletion\">(V)\n  return %23\n}","def CaseClauseIsSelected(\n  C: Unknown[\"CaseClauseParseNode\"],\n  input: ESValue,\n): Normal[Boolean] | Abrupt = {\n  assert (yet \"_C_ is an instance of the production <emu-grammar>CaseClause : `case` Expression `:` StatementList?</emu-grammar>.\")\n  sdo-call %0 = C.Expression->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let exprRef = %0\n  call %1 = clo<\"GetValue\">(exprRef)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let clauseSelector = %1\n  call %2 = clo<\"IsStrictlyEqual\">(input, clauseSelector)\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <SYNTAX>:SwitchStatement[0,0].Evaluation(\n  this: Ast[SwitchStatement[0]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let exprRef = %0\n  call %1 = clo<\"GetValue\">(exprRef)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let switchValue = %1\n  let oldEnv = @EXECUTION_STACK[0].LexicalEnvironment\n  call %2 = clo<\"NewDeclarativeEnvironment\">(oldEnv)\n  let blockEnv = %2\n  call %3 = clo<\"BlockDeclarationInstantiation\">(this[1], blockEnv)\n  @EXECUTION_STACK[0].LexicalEnvironment = blockEnv\n  sdo-call %4 = this[1]->CaseBlockEvaluation(switchValue)\n  call %5 = clo<\"Completion\">(%4)\n  let R = %5\n  @EXECUTION_STACK[0].LexicalEnvironment = oldEnv\n  if (? R: Completion) return R\n  call %6 = clo<\"NormalCompletion\">(R)\n  return %6\n}","def <SYNTAX>:CaseClause[0,0].Evaluation(\n  this: Ast[CaseClause[0]],\n): Unknown = {\n  call %0 = clo<\"NormalCompletion\">(~empty~)\n  return %0\n}","def <SYNTAX>:CaseClause[0,1].Evaluation(\n  this: Ast[CaseClause[0]],\n): Unknown = {\n  sdo-call %0 = this[1]->Evaluation()\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:DefaultClause[0,0].Evaluation(\n  this: Ast[DefaultClause[0]],\n): Unknown = {\n  call %0 = clo<\"NormalCompletion\">(~empty~)\n  return %0\n}","def <SYNTAX>:DefaultClause[0,1].Evaluation(\n  this: Ast[DefaultClause[0]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  return %0\n}","def IsLabelledFunction(\n  stmt: Unknown[\"StatementParseNode\"],\n): Boolean = {\n  if (! (? stmt: Ast[LabelledStatement])) {\n    return false\n  }\n  let item = stmt.LabelledItem\n  if (? item: Ast[LabelledItem[1]]) {\n    return true\n  }\n  let subStmt = item.Statement\n  call %0 = clo<\"IsLabelledFunction\">(subStmt)\n  return %0\n}","def <SYNTAX>:LabelledStatement[0,0].Evaluation(\n  this: Ast[LabelledStatement[0]],\n): Unknown = {\n  sdo-call %0 = this->LabelledEvaluation((list [])[#574])\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:BreakableStatement[0,0].LabelledEvaluation(\n  this: Ast[BreakableStatement[0]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this[0]->LoopEvaluation(labelSet)\n  call %1 = clo<\"Completion\">(%0)\n  let stmtResult = %1\n  if (&& (? stmtResult: Completion) (= stmtResult.Type ~break~)) {\n    if (= stmtResult.Target ~empty~) {\n      if (= stmtResult.Value ~empty~) {\n        call %2 = clo<\"NormalCompletion\">(undefined)\n        stmtResult = %2\n      } else {\n        call %3 = clo<\"NormalCompletion\">(stmtResult.Value)\n        stmtResult = %3\n      }\n    }\n  }\n  assert (? stmtResult: Completion)\n  return stmtResult\n}","def <SYNTAX>:BreakableStatement[1,0].LabelledEvaluation(\n  this: Ast[BreakableStatement[1]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this[0]->Evaluation()\n  call %1 = clo<\"Completion\">(%0)\n  let stmtResult = %1\n  if (&& (? stmtResult: Completion) (= stmtResult.Type ~break~)) {\n    if (= stmtResult.Target ~empty~) {\n      if (= stmtResult.Value ~empty~) {\n        call %2 = clo<\"NormalCompletion\">(undefined)\n        stmtResult = %2\n      } else {\n        call %3 = clo<\"NormalCompletion\">(stmtResult.Value)\n        stmtResult = %3\n      }\n    }\n  }\n  assert (? stmtResult: Completion)\n  return stmtResult\n}","def <SYNTAX>:LabelledStatement[0,0].LabelledEvaluation(\n  this: Ast[LabelledStatement[0]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this[0]->StringValue()\n  let label = %0\n  call %1 = clo<\"__FLAT_LIST__\">((list [labelSet, (list [label])[#576]])[#575])\n  let newLabelSet = %1\n  sdo-call %2 = this[1]->LabelledEvaluation(newLabelSet)\n  call %3 = clo<\"Completion\">(%2)\n  let stmtResult = %3\n  if (&& (&& (? stmtResult: Completion) (= stmtResult.Type ~break~)) (= stmtResult.Target label)) {\n    call %4 = clo<\"NormalCompletion\">(stmtResult.Value)\n    stmtResult = %4\n  }\n  assert (? stmtResult: Completion)\n  return stmtResult\n}","def <SYNTAX>:LabelledItem[1,0].LabelledEvaluation(\n  this: Ast[LabelledItem[1]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:Statement[0,0].LabelledEvaluation(\n  this: Ast[Statement[0]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this->Evaluation()\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:Statement[1,0].LabelledEvaluation(\n  this: Ast[Statement[1]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this->Evaluation()\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:Statement[2,0].LabelledEvaluation(\n  this: Ast[Statement[2]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this->Evaluation()\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:Statement[3,0].LabelledEvaluation(\n  this: Ast[Statement[3]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this->Evaluation()\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:Statement[4,0].LabelledEvaluation(\n  this: Ast[Statement[4]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this->Evaluation()\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:Statement[6,0].LabelledEvaluation(\n  this: Ast[Statement[6]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this->Evaluation()\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:Statement[7,0].LabelledEvaluation(\n  this: Ast[Statement[7]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this->Evaluation()\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:Statement[8,0].LabelledEvaluation(\n  this: Ast[Statement[8]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this->Evaluation()\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:Statement[9,0].LabelledEvaluation(\n  this: Ast[Statement[9]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this->Evaluation()\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:Statement[11,0].LabelledEvaluation(\n  this: Ast[Statement[11]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this->Evaluation()\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:Statement[12,0].LabelledEvaluation(\n  this: Ast[Statement[12]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this->Evaluation()\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:Statement[13,0].LabelledEvaluation(\n  this: Ast[Statement[13]],\n  labelSet: List[String],\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this->Evaluation()\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:ThrowStatement[0,0].Evaluation(\n  this: Ast[ThrowStatement[0]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let exprRef = %0\n  call %1 = clo<\"GetValue\">(exprRef)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let exprValue = %1\n  call %2 = clo<\"ThrowCompletion\">(exprValue)\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <SYNTAX>:Catch[0,0].CatchClauseEvaluation(\n  this: Ast[Catch[0]],\n  thrownValue: ESValue,\n): Normal[ESValue] | Abrupt = {\n  let oldEnv = @EXECUTION_STACK[0].LexicalEnvironment\n  call %0 = clo<\"NewDeclarativeEnvironment\">(oldEnv)\n  let catchEnv = %0\n  sdo-call %3 = this[0]->BoundNames()\n  %2 = %3\n  %1 = 0\n  while (< %1 (sizeof %2)) {\n    let argName = %2[%1]\n    call %4 = catchEnv.CreateMutableBinding(catchEnv, argName, false)\n    assert (? %4: Normal)\n    %4 = %4.Value\n    %1 = (+ %1 1)\n  }\n  @EXECUTION_STACK[0].LexicalEnvironment = catchEnv\n  sdo-call %5 = this[0]->BindingInitialization(thrownValue, catchEnv)\n  call %6 = clo<\"Completion\">(%5)\n  let status = %6\n  if (&& (? status: Completion) (! (= status.Type ~normal~))) {\n    @EXECUTION_STACK[0].LexicalEnvironment = oldEnv\n    assert (? status: Completion)\n    return status\n  }\n  sdo-call %7 = this[1]->Evaluation()\n  call %8 = clo<\"Completion\">(%7)\n  let B = %8\n  @EXECUTION_STACK[0].LexicalEnvironment = oldEnv\n  assert (? B: Completion)\n  return B\n}","def <SYNTAX>:Catch[1,0].CatchClauseEvaluation(\n  this: Ast[Catch[1]],\n  thrownValue: ESValue,\n): Normal[ESValue] | Abrupt = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:TryStatement[0,0].Evaluation(\n  this: Ast[TryStatement[0]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  call %1 = clo<\"Completion\">(%0)\n  let B = %1\n  if (&& (? B: Completion) (= B.Type ~throw~)) {\n    sdo-call %2 = this[1]->CatchClauseEvaluation(B.Value)\n    call %3 = clo<\"Completion\">(%2)\n    let C = %3\n  } else {\n    let C = B\n  }\n  call %4 = clo<\"UpdateEmpty\">(C, undefined)\n  assert (? %4: Completion)\n  return %4\n}","def <SYNTAX>:TryStatement[1,0].Evaluation(\n  this: Ast[TryStatement[1]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  call %1 = clo<\"Completion\">(%0)\n  let B = %1\n  sdo-call %2 = this[1]->Evaluation()\n  call %3 = clo<\"Completion\">(%2)\n  let F = %3\n  if (&& (? F: Completion) (= F.Type ~normal~)) {\n    F = B\n  }\n  call %4 = clo<\"UpdateEmpty\">(F, undefined)\n  assert (? %4: Completion)\n  return %4\n}","def <SYNTAX>:TryStatement[2,0].Evaluation(\n  this: Ast[TryStatement[2]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  call %1 = clo<\"Completion\">(%0)\n  let B = %1\n  if (&& (? B: Completion) (= B.Type ~throw~)) {\n    sdo-call %2 = this[1]->CatchClauseEvaluation(B.Value)\n    call %3 = clo<\"Completion\">(%2)\n    let C = %3\n  } else {\n    let C = B\n  }\n  sdo-call %4 = this[2]->Evaluation()\n  call %5 = clo<\"Completion\">(%4)\n  let F = %5\n  if (&& (? F: Completion) (= F.Type ~normal~)) {\n    F = C\n  }\n  call %6 = clo<\"UpdateEmpty\">(F, undefined)\n  assert (? %6: Completion)\n  return %6\n}","def <SYNTAX>:DebuggerStatement[0,0].Evaluation(\n  this: Ast[DebuggerStatement[0]],\n): Unknown = {\n  (yet \"If an implementation-defined debugging facility is available and enabled, then\\n  1. Perform an implementation-defined debugging action.\\n  1. Return a new implementation-defined Completion Record.\")\n  (yet \"Else,\\n  1. Return ~empty~.\")\n}","def <SYNTAX>:ObjectBindingPattern[0,0].ContainsExpression(\n  this: Ast[ObjectBindingPattern[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ObjectBindingPattern[1,0].ContainsExpression(\n  this: Ast[ObjectBindingPattern[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ObjectBindingPattern[3,1].ContainsExpression(\n  this: Ast[ObjectBindingPattern[3]],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsExpression()\n  return %0\n}","def <SYNTAX>:ArrayBindingPattern[0,0].ContainsExpression(\n  this: Ast[ArrayBindingPattern[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ArrayBindingPattern[0,2].ContainsExpression(\n  this: Ast[ArrayBindingPattern[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ArrayBindingPattern[0,1].ContainsExpression(\n  this: Ast[ArrayBindingPattern[0]],\n): Boolean = {\n  sdo-call %0 = this[1]->ContainsExpression()\n  return %0\n}","def <SYNTAX>:ArrayBindingPattern[0,3].ContainsExpression(\n  this: Ast[ArrayBindingPattern[0]],\n): Boolean = {\n  sdo-call %0 = this[1]->ContainsExpression()\n  return %0\n}","def <SYNTAX>:ArrayBindingPattern[2,0].ContainsExpression(\n  this: Ast[ArrayBindingPattern[2]],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsExpression()\n  return %0\n}","def <SYNTAX>:ArrayBindingPattern[2,2].ContainsExpression(\n  this: Ast[ArrayBindingPattern[2]],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsExpression()\n  return %0\n}","def <SYNTAX>:ArrayBindingPattern[2,1].ContainsExpression(\n  this: Ast[ArrayBindingPattern[2]],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsExpression()\n  let has = %0\n  if (= has true) {\n    return true\n  }\n  sdo-call %1 = this[2]->ContainsExpression()\n  return %1\n}","def <SYNTAX>:ArrayBindingPattern[2,3].ContainsExpression(\n  this: Ast[ArrayBindingPattern[2]],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsExpression()\n  let has = %0\n  if (= has true) {\n    return true\n  }\n  sdo-call %1 = this[2]->ContainsExpression()\n  return %1\n}","def <SYNTAX>:BindingPropertyList[1,0].ContainsExpression(\n  this: Ast[BindingPropertyList[1]],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsExpression()\n  let has = %0\n  if (= has true) {\n    return true\n  }\n  sdo-call %1 = this[1]->ContainsExpression()\n  return %1\n}","def <SYNTAX>:BindingElementList[1,0].ContainsExpression(\n  this: Ast[BindingElementList[1]],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsExpression()\n  let has = %0\n  if (= has true) {\n    return true\n  }\n  sdo-call %1 = this[1]->ContainsExpression()\n  return %1\n}","def <SYNTAX>:BindingElisionElement[0,0].ContainsExpression(\n  this: Ast[BindingElisionElement[0]],\n): Boolean = {\n  sdo-call %0 = this[1]->ContainsExpression()\n  return %0\n}","def <SYNTAX>:BindingElisionElement[0,1].ContainsExpression(\n  this: Ast[BindingElisionElement[0]],\n): Boolean = {\n  sdo-call %0 = this[1]->ContainsExpression()\n  return %0\n}","def <SYNTAX>:BindingProperty[1,0].ContainsExpression(\n  this: Ast[BindingProperty[1]],\n): Boolean = {\n  sdo-call %0 = this[0]->IsComputedPropertyKey()\n  let has = %0\n  if (= has true) {\n    return true\n  }\n  sdo-call %1 = this[1]->ContainsExpression()\n  return %1\n}","def <SYNTAX>:BindingElement[1,1].ContainsExpression(\n  this: Ast[BindingElement[1]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:SingleNameBinding[0,0].ContainsExpression(\n  this: Ast[SingleNameBinding[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:SingleNameBinding[0,1].ContainsExpression(\n  this: Ast[SingleNameBinding[0]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:BindingRestElement[0,0].ContainsExpression(\n  this: Ast[BindingRestElement[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:BindingRestElement[1,0].ContainsExpression(\n  this: Ast[BindingRestElement[1]],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsExpression()\n  return %0\n}","def <SYNTAX>:FormalParameters[0,0].ContainsExpression(\n  this: Ast[FormalParameters[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:FormalParameters[4,0].ContainsExpression(\n  this: Ast[FormalParameters[4]],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsExpression()\n  if (= %0 true) {\n    return true\n  }\n  sdo-call %1 = this[1]->ContainsExpression()\n  return %1\n}","def <SYNTAX>:FormalParameterList[1,0].ContainsExpression(\n  this: Ast[FormalParameterList[1]],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsExpression()\n  if (= %0 true) {\n    return true\n  }\n  sdo-call %1 = this[1]->ContainsExpression()\n  return %1\n}","def <SYNTAX>:ArrowParameters[0,0].ContainsExpression(\n  this: Ast[ArrowParameters[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ArrowParameters[1,0].ContainsExpression(\n  this: Ast[ArrowParameters[1]],\n): Boolean = {\n  let formals = (parse this[0] (grammar-symbol |ArrowFormalParameters|))\n  sdo-call %0 = formals->ContainsExpression()\n  return %0\n}","def <SYNTAX>:AsyncArrowBindingIdentifier[0,0].ContainsExpression(\n  this: Ast[AsyncArrowBindingIdentifier[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:BindingElement[1,0].IsSimpleParameterList(\n  this: Ast[BindingElement[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:BindingElement[1,1].IsSimpleParameterList(\n  this: Ast[BindingElement[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:SingleNameBinding[0,0].IsSimpleParameterList(\n  this: Ast[SingleNameBinding[0]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:SingleNameBinding[0,1].IsSimpleParameterList(\n  this: Ast[SingleNameBinding[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:FormalParameters[0,0].IsSimpleParameterList(\n  this: Ast[FormalParameters[0]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:FormalParameters[1,0].IsSimpleParameterList(\n  this: Ast[FormalParameters[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:FormalParameters[4,0].IsSimpleParameterList(\n  this: Ast[FormalParameters[4]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:FormalParameterList[1,0].IsSimpleParameterList(\n  this: Ast[FormalParameterList[1]],\n): Boolean = {\n  sdo-call %0 = this[0]->IsSimpleParameterList()\n  if (= %0 false) {\n    return false\n  }\n  sdo-call %1 = this[1]->IsSimpleParameterList()\n  return %1\n}","def <SYNTAX>:FormalParameter[0,0].IsSimpleParameterList(\n  this: Ast[FormalParameter[0]],\n): Boolean = {\n  sdo-call %0 = this[0]->IsSimpleParameterList()\n  return %0\n}","def <SYNTAX>:ArrowParameters[0,0].IsSimpleParameterList(\n  this: Ast[ArrowParameters[0]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:ArrowParameters[1,0].IsSimpleParameterList(\n  this: Ast[ArrowParameters[1]],\n): Boolean = {\n  let formals = (parse this[0] (grammar-symbol |ArrowFormalParameters|))\n  sdo-call %0 = formals->IsSimpleParameterList()\n  return %0\n}","def <SYNTAX>:AsyncArrowBindingIdentifier[0,0].IsSimpleParameterList(\n  this: Ast[AsyncArrowBindingIdentifier[0]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:CoverCallExpressionAndAsyncArrowHead[0,0].IsSimpleParameterList(\n  this: Ast[CoverCallExpressionAndAsyncArrowHead[0]],\n): Boolean = {\n  let head = (parse this (grammar-symbol |AsyncArrowHead|))\n  sdo-call %0 = head->IsSimpleParameterList()\n  return %0\n}","def <SYNTAX>:BindingElement[1,0].HasInitializer(\n  this: Ast[BindingElement[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:BindingElement[1,1].HasInitializer(\n  this: Ast[BindingElement[1]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:SingleNameBinding[0,0].HasInitializer(\n  this: Ast[SingleNameBinding[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:SingleNameBinding[0,1].HasInitializer(\n  this: Ast[SingleNameBinding[0]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:FormalParameterList[1,0].HasInitializer(\n  this: Ast[FormalParameterList[1]],\n): Boolean = {\n  sdo-call %0 = this[0]->HasInitializer()\n  if (= %0 true) {\n    return true\n  }\n  sdo-call %1 = this[1]->HasInitializer()\n  return %1\n}","def <SYNTAX>:FormalParameters[0,0].ExpectedArgumentCount(\n  this: Ast[FormalParameters[0]],\n): Int = {\n  return 0\n}","def <SYNTAX>:FormalParameters[1,0].ExpectedArgumentCount(\n  this: Ast[FormalParameters[1]],\n): Int = {\n  return 0\n}","def <SYNTAX>:FormalParameters[4,0].ExpectedArgumentCount(\n  this: Ast[FormalParameters[4]],\n): Int = {\n  sdo-call %0 = this[0]->ExpectedArgumentCount()\n  return %0\n}","def <SYNTAX>:FormalParameterList[0,0].ExpectedArgumentCount(\n  this: Ast[FormalParameterList[0]],\n): Int = {\n  sdo-call %0 = this[0]->HasInitializer()\n  if (= %0 true) {\n    return 0\n  }\n  return 1\n}","def <SYNTAX>:FormalParameterList[1,0].ExpectedArgumentCount(\n  this: Ast[FormalParameterList[1]],\n): Int = {\n  sdo-call %0 = this[0]->ExpectedArgumentCount()\n  let count = %0\n  sdo-call %2 = this[0]->HasInitializer()\n  %1 = (= %2 true)\n  if %1 {} else {\n    sdo-call %3 = this[1]->HasInitializer()\n    %1 = (= %3 true)\n  }\n  if %1 {\n    return count\n  }\n  return (+ count 1)\n}","def <SYNTAX>:ArrowParameters[0,0].ExpectedArgumentCount(\n  this: Ast[ArrowParameters[0]],\n): Int = {\n  return 1\n}","def <SYNTAX>:ArrowParameters[1,0].ExpectedArgumentCount(\n  this: Ast[ArrowParameters[1]],\n): Int = {\n  let formals = (parse this[0] (grammar-symbol |ArrowFormalParameters|))\n  sdo-call %0 = formals->ExpectedArgumentCount()\n  return %0\n}","def <SYNTAX>:PropertySetParameterList[0,0].ExpectedArgumentCount(\n  this: Ast[PropertySetParameterList[0]],\n): Int = {\n  sdo-call %0 = this[0]->HasInitializer()\n  if (= %0 true) {\n    return 0\n  }\n  return 1\n}","def <SYNTAX>:AsyncArrowBindingIdentifier[0,0].ExpectedArgumentCount(\n  this: Ast[AsyncArrowBindingIdentifier[0]],\n): Int = {\n  return 1\n}","def <SYNTAX>:FunctionBody[0,0].FunctionBodyContainsUseStrict(\n  this: Ast[FunctionBody[0]],\n): Boolean = {\n  (yet \"If the Directive Prologue of |FunctionBody| contains a Use Strict Directive, return *true*; otherwise, return *false*.\")\n}","def <SYNTAX>:FunctionBody[0,0].EvaluateFunctionBody(\n  this: Ast[FunctionBody[0]],\n  functionObject: Record[ECMAScriptFunctionObject],\n  argumentsList: List[ESValue],\n): Normal[ESValue] | Abrupt = {\n  call %0 = clo<\"FunctionDeclarationInstantiation\">(functionObject, argumentsList)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  sdo-call %1 = this[0]->Evaluation()\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:FunctionDeclaration[0,0].InstantiateOrdinaryFunctionObject(\n  this: Ast[FunctionDeclaration[0]],\n  env: Record[EnvironmentRecord],\n  privateEnv: Record[PrivateEnvironmentRecord] | Null,\n): Record[ECMAScriptFunctionObject] = {\n  sdo-call %0 = this[0]->StringValue()\n  let name = %0\n  let sourceText = (source-text this)\n  call %1 = clo<\"OrdinaryFunctionCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Function.prototype%\"], sourceText, this[1], this[2], ~non-lexical-this~, env, privateEnv)\n  let F = %1\n  call %2 = clo<\"SetFunctionName\">(F, name)\n  call %3 = clo<\"MakeConstructor\">(F)\n  return F\n}","def <SYNTAX>:FunctionDeclaration[1,0].InstantiateOrdinaryFunctionObject(\n  this: Ast[FunctionDeclaration[1]],\n  env: Record[EnvironmentRecord],\n  privateEnv: Record[PrivateEnvironmentRecord] | Null,\n): Record[ECMAScriptFunctionObject] = {\n  let sourceText = (source-text this)\n  call %0 = clo<\"OrdinaryFunctionCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Function.prototype%\"], sourceText, this[0], this[1], ~non-lexical-this~, env, privateEnv)\n  let F = %0\n  call %1 = clo<\"SetFunctionName\">(F, \"default\")\n  call %2 = clo<\"MakeConstructor\">(F)\n  return F\n}","def <SYNTAX>:FunctionExpression[0,0].InstantiateOrdinaryFunctionExpression(\n  this: Ast[FunctionExpression[0]],\n  name?: Record[PrivateName | Symbol] | String,\n): Record[ECMAScriptFunctionObject] = {\n  if (! (exists name)) {\n    name = \"\"\n  }\n  let env = @EXECUTION_STACK[0].LexicalEnvironment\n  let privateEnv = @EXECUTION_STACK[0].PrivateEnvironment\n  let sourceText = (source-text this)\n  call %0 = clo<\"OrdinaryFunctionCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Function.prototype%\"], sourceText, this[1], this[2], ~non-lexical-this~, env, privateEnv)\n  let closure = %0\n  call %1 = clo<\"SetFunctionName\">(closure, name)\n  call %2 = clo<\"MakeConstructor\">(closure)\n  return closure\n}","def <SYNTAX>:FunctionExpression[0,1].InstantiateOrdinaryFunctionExpression(\n  this: Ast[FunctionExpression[0]],\n  name?: Record[PrivateName | Symbol] | String,\n): Record[ECMAScriptFunctionObject] = {\n  assert (! (exists name))\n  sdo-call %0 = this[0]->StringValue()\n  name = %0\n  let outerEnv = @EXECUTION_STACK[0].LexicalEnvironment\n  call %1 = clo<\"NewDeclarativeEnvironment\">(outerEnv)\n  let funcEnv = %1\n  call %2 = funcEnv.CreateImmutableBinding(funcEnv, name, false)\n  assert (? %2: Normal)\n  %2 = %2.Value\n  let privateEnv = @EXECUTION_STACK[0].PrivateEnvironment\n  let sourceText = (source-text this)\n  call %3 = clo<\"OrdinaryFunctionCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Function.prototype%\"], sourceText, this[1], this[2], ~non-lexical-this~, funcEnv, privateEnv)\n  let closure = %3\n  call %4 = clo<\"SetFunctionName\">(closure, name)\n  call %5 = clo<\"MakeConstructor\">(closure)\n  call %6 = funcEnv.InitializeBinding(funcEnv, name, closure)\n  assert (? %6: Normal)\n  %6 = %6.Value\n  return closure\n}","def <SYNTAX>:FunctionDeclaration[0,0].Evaluation(\n  this: Ast[FunctionDeclaration[0]],\n): Unknown = {\n  call %0 = clo<\"NormalCompletion\">(~empty~)\n  return %0\n}","def <SYNTAX>:FunctionDeclaration[1,0].Evaluation(\n  this: Ast[FunctionDeclaration[1]],\n): Unknown = {\n  call %0 = clo<\"NormalCompletion\">(~empty~)\n  return %0\n}","def <SYNTAX>:FunctionExpression[0,0].Evaluation(\n  this: Ast[FunctionExpression[0]],\n): Unknown = {\n  sdo-call %0 = this->InstantiateOrdinaryFunctionExpression()\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:FunctionExpression[0,1].Evaluation(\n  this: Ast[FunctionExpression[0]],\n): Unknown = {\n  sdo-call %0 = this->InstantiateOrdinaryFunctionExpression()\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:FunctionStatementList[0,0].Evaluation(\n  this: Ast[FunctionStatementList[0]],\n): Unknown = {\n  call %0 = clo<\"NormalCompletion\">(undefined)\n  return %0\n}","def <SYNTAX>:ConciseBody[0,0].ConciseBodyContainsUseStrict(\n  this: Ast[ConciseBody[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ConciseBody[1,0].ConciseBodyContainsUseStrict(\n  this: Ast[ConciseBody[1]],\n): Boolean = {\n  (yet \"Return FunctionBodyContainsUseStrict of |FunctionBody|.\")\n}","def <SYNTAX>:ConciseBody[0,0].EvaluateConciseBody(\n  this: Ast[ConciseBody[0]],\n  functionObject: Record[ECMAScriptFunctionObject],\n  argumentsList: List[ESValue],\n): Normal[ESValue] | Abrupt = {\n  call %0 = clo<\"FunctionDeclarationInstantiation\">(functionObject, argumentsList)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  sdo-call %1 = this[0]->Evaluation()\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:ArrowFunction[0,0].InstantiateArrowFunctionExpression(\n  this: Ast[ArrowFunction[0]],\n  name?: Record[PrivateName | Symbol] | String,\n): Record[ECMAScriptFunctionObject] = {\n  if (! (exists name)) {\n    name = \"\"\n  }\n  let env = @EXECUTION_STACK[0].LexicalEnvironment\n  let privateEnv = @EXECUTION_STACK[0].PrivateEnvironment\n  let sourceText = (source-text this)\n  call %0 = clo<\"OrdinaryFunctionCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Function.prototype%\"], sourceText, this[0], this[1], ~lexical-this~, env, privateEnv)\n  let closure = %0\n  call %1 = clo<\"SetFunctionName\">(closure, name)\n  return closure\n}","def <SYNTAX>:ArrowFunction[0,0].Evaluation(\n  this: Ast[ArrowFunction[0]],\n): Unknown = {\n  sdo-call %0 = this->InstantiateArrowFunctionExpression()\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:ExpressionBody[0,0].Evaluation(\n  this: Ast[ExpressionBody[0]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let exprRef = %0\n  call %1 = clo<\"GetValue\">(exprRef)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let exprValue = %1\n  %2 = (record [CompletionRecord] {\n    \"Type\" : ~return~,\n    \"Value\" : exprValue,\n    \"Target\" : ~empty~,\n  })[#577]\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <SYNTAX>:MethodDefinition[0,0].HasDirectSuper(\n  this: Ast[MethodDefinition[0]],\n): Boolean = {\n  sdo-call %0 = this[1]->Contains((grammar-symbol |SuperCall|))\n  if (= %0 true) {\n    return true\n  }\n  sdo-call %1 = this[2]->Contains((grammar-symbol |SuperCall|))\n  return %1\n}","def <SYNTAX>:MethodDefinition[4,0].HasDirectSuper(\n  this: Ast[MethodDefinition[4]],\n): Boolean = {\n  sdo-call %0 = this[1]->Contains((grammar-symbol |SuperCall|))\n  return %0\n}","def <SYNTAX>:MethodDefinition[5,0].HasDirectSuper(\n  this: Ast[MethodDefinition[5]],\n): Boolean = {\n  sdo-call %0 = this[1]->Contains((grammar-symbol |SuperCall|))\n  if (= %0 true) {\n    return true\n  }\n  sdo-call %1 = this[2]->Contains((grammar-symbol |SuperCall|))\n  return %1\n}","def <SYNTAX>:GeneratorMethod[0,0].HasDirectSuper(\n  this: Ast[GeneratorMethod[0]],\n): Boolean = {\n  sdo-call %0 = this[1]->Contains((grammar-symbol |SuperCall|))\n  if (= %0 true) {\n    return true\n  }\n  sdo-call %1 = this[2]->Contains((grammar-symbol |SuperCall|))\n  return %1\n}","def <SYNTAX>:AsyncGeneratorMethod[0,0].HasDirectSuper(\n  this: Ast[AsyncGeneratorMethod[0]],\n): Boolean = {\n  sdo-call %0 = this[1]->Contains((grammar-symbol |SuperCall|))\n  if (= %0 true) {\n    return true\n  }\n  sdo-call %1 = this[2]->Contains((grammar-symbol |SuperCall|))\n  return %1\n}","def <SYNTAX>:AsyncMethod[0,0].HasDirectSuper(\n  this: Ast[AsyncMethod[0]],\n): Boolean = {\n  sdo-call %0 = this[1]->Contains((grammar-symbol |SuperCall|))\n  if (= %0 true) {\n    return true\n  }\n  sdo-call %1 = this[2]->Contains((grammar-symbol |SuperCall|))\n  return %1\n}","def <SYNTAX>:MethodDefinition[0,0].SpecialMethod(\n  this: Ast[MethodDefinition[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MethodDefinition[1,0].SpecialMethod(\n  this: Ast[MethodDefinition[1]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:MethodDefinition[2,0].SpecialMethod(\n  this: Ast[MethodDefinition[2]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:MethodDefinition[3,0].SpecialMethod(\n  this: Ast[MethodDefinition[3]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:MethodDefinition[4,0].SpecialMethod(\n  this: Ast[MethodDefinition[4]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:MethodDefinition[5,0].SpecialMethod(\n  this: Ast[MethodDefinition[5]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:MethodDefinition[0,0].DefineMethod(\n  this: Ast[MethodDefinition[0]],\n  object: Record[Object],\n  functionPrototype?: Record[Object],\n): Unknown[\"EitherANormalCompletionContainingARecordWithFields[[Key]](aPropertyKey)And[[Closure]](anECMAScriptFunctionObject)OrAnAbruptCompletion\"] = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let propKey = %0\n  let env = @EXECUTION_STACK[0].LexicalEnvironment\n  let privateEnv = @EXECUTION_STACK[0].PrivateEnvironment\n  if (exists functionPrototype) {\n    let prototype = functionPrototype\n  } else {\n    let prototype = @EXECUTION_STACK[0].Realm.Intrinsics[\"%Function.prototype%\"]\n  }\n  let sourceText = (source-text this)\n  call %1 = clo<\"OrdinaryFunctionCreate\">(prototype, sourceText, this[1], this[2], ~non-lexical-this~, env, privateEnv)\n  let closure = %1\n  call %2 = clo<\"MakeMethod\">(closure, object)\n  %3 = (record {\n    \"Key\" : propKey,\n    \"Closure\" : closure,\n  })[#578]\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <SYNTAX>:MethodDefinition[0,0].MethodDefinitionEvaluation(\n  this: Ast[MethodDefinition[0]],\n  object: Record[Object],\n  enumerable: Boolean,\n): Normal[Record[PrivateElement] | Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this->DefineMethod(object)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let methodDef = %0\n  call %1 = clo<\"SetFunctionName\">(methodDef.Closure, methodDef.Key)\n  call %2 = clo<\"DefineMethodProperty\">(object, methodDef.Key, methodDef.Closure, enumerable)\n  assert (? %2: Completion)\n  return %2\n}","def <SYNTAX>:MethodDefinition[4,0].MethodDefinitionEvaluation(\n  this: Ast[MethodDefinition[4]],\n  object: Record[Object],\n  enumerable: Boolean,\n): Normal[Record[PrivateElement] | Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let propKey = %0\n  let env = @EXECUTION_STACK[0].LexicalEnvironment\n  let privateEnv = @EXECUTION_STACK[0].PrivateEnvironment\n  let sourceText = (source-text this)\n  let formalParameterList = |FormalParameters|[TT]<0>\n  call %1 = clo<\"OrdinaryFunctionCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Function.prototype%\"], sourceText, formalParameterList, this[1], ~non-lexical-this~, env, privateEnv)\n  let closure = %1\n  call %2 = clo<\"MakeMethod\">(closure, object)\n  call %3 = clo<\"SetFunctionName\">(closure, propKey, \"get\")\n  if (? propKey: Record[PrivateName]) {\n    %4 = (record [PrivateElement] {\n      \"Key\" : propKey,\n      \"Kind\" : ~accessor~,\n      \"Get\" : closure,\n      \"Set\" : undefined,\n    })[#579]\n    if (? %4: Completion) return %4\n    call %5 = clo<\"NormalCompletion\">(%4)\n    return %5\n  } else {\n    let desc = (record [PropertyDescriptor] {\n      \"Get\" : closure,\n      \"Enumerable\" : enumerable,\n      \"Configurable\" : true,\n    })[#580]\n    call %6 = clo<\"DefinePropertyOrThrow\">(object, propKey, desc)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    call %7 = clo<\"NormalCompletion\">(~unused~)\n    return %7\n  }\n}","def <SYNTAX>:MethodDefinition[5,0].MethodDefinitionEvaluation(\n  this: Ast[MethodDefinition[5]],\n  object: Record[Object],\n  enumerable: Boolean,\n): Normal[Record[PrivateElement] | Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let propKey = %0\n  let env = @EXECUTION_STACK[0].LexicalEnvironment\n  let privateEnv = @EXECUTION_STACK[0].PrivateEnvironment\n  let sourceText = (source-text this)\n  call %1 = clo<\"OrdinaryFunctionCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Function.prototype%\"], sourceText, this[1], this[2], ~non-lexical-this~, env, privateEnv)\n  let closure = %1\n  call %2 = clo<\"MakeMethod\">(closure, object)\n  call %3 = clo<\"SetFunctionName\">(closure, propKey, \"set\")\n  if (? propKey: Record[PrivateName]) {\n    %4 = (record [PrivateElement] {\n      \"Key\" : propKey,\n      \"Kind\" : ~accessor~,\n      \"Get\" : undefined,\n      \"Set\" : closure,\n    })[#581]\n    if (? %4: Completion) return %4\n    call %5 = clo<\"NormalCompletion\">(%4)\n    return %5\n  } else {\n    let desc = (record [PropertyDescriptor] {\n      \"Set\" : closure,\n      \"Enumerable\" : enumerable,\n      \"Configurable\" : true,\n    })[#582]\n    call %6 = clo<\"DefinePropertyOrThrow\">(object, propKey, desc)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    call %7 = clo<\"NormalCompletion\">(~unused~)\n    return %7\n  }\n}","def <SYNTAX>:GeneratorMethod[0,0].MethodDefinitionEvaluation(\n  this: Ast[GeneratorMethod[0]],\n  object: Record[Object],\n  enumerable: Boolean,\n): Normal[Record[PrivateElement] | Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let propKey = %0\n  let env = @EXECUTION_STACK[0].LexicalEnvironment\n  let privateEnv = @EXECUTION_STACK[0].PrivateEnvironment\n  let sourceText = (source-text this)\n  call %1 = clo<\"OrdinaryFunctionCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%GeneratorFunction.prototype%\"], sourceText, this[1], this[2], ~non-lexical-this~, env, privateEnv)\n  let closure = %1\n  call %2 = clo<\"MakeMethod\">(closure, object)\n  call %3 = clo<\"SetFunctionName\">(closure, propKey)\n  call %4 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%GeneratorFunction.prototype.prototype%\"])\n  let prototype = %4\n  call %5 = clo<\"DefinePropertyOrThrow\">(closure, \"prototype\", (record [PropertyDescriptor] {\n    \"Value\" : prototype,\n    \"Writable\" : true,\n    \"Enumerable\" : false,\n    \"Configurable\" : false,\n  })[#583])\n  assert (? %5: Normal)\n  %5 = %5.Value\n  call %6 = clo<\"DefineMethodProperty\">(object, propKey, closure, enumerable)\n  assert (? %6: Completion)\n  return %6\n}","def <SYNTAX>:AsyncGeneratorMethod[0,0].MethodDefinitionEvaluation(\n  this: Ast[AsyncGeneratorMethod[0]],\n  object: Record[Object],\n  enumerable: Boolean,\n): Normal[Record[PrivateElement] | Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let propKey = %0\n  let env = @EXECUTION_STACK[0].LexicalEnvironment\n  let privateEnv = @EXECUTION_STACK[0].PrivateEnvironment\n  let sourceText = (source-text this)\n  call %1 = clo<\"OrdinaryFunctionCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%AsyncGeneratorFunction.prototype%\"], sourceText, this[1], this[2], ~non-lexical-this~, env, privateEnv)\n  let closure = %1\n  call %2 = clo<\"MakeMethod\">(closure, object)\n  call %3 = clo<\"SetFunctionName\">(closure, propKey)\n  call %4 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%AsyncGeneratorFunction.prototype.prototype%\"])\n  let prototype = %4\n  call %5 = clo<\"DefinePropertyOrThrow\">(closure, \"prototype\", (record [PropertyDescriptor] {\n    \"Value\" : prototype,\n    \"Writable\" : true,\n    \"Enumerable\" : false,\n    \"Configurable\" : false,\n  })[#584])\n  assert (? %5: Normal)\n  %5 = %5.Value\n  call %6 = clo<\"DefineMethodProperty\">(object, propKey, closure, enumerable)\n  assert (? %6: Completion)\n  return %6\n}","def <SYNTAX>:AsyncMethod[0,0].MethodDefinitionEvaluation(\n  this: Ast[AsyncMethod[0]],\n  object: Record[Object],\n  enumerable: Boolean,\n): Normal[Record[PrivateElement] | Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let propKey = %0\n  let env = @EXECUTION_STACK[0].LexicalEnvironment\n  let privateEnv = @EXECUTION_STACK[0].PrivateEnvironment\n  let sourceText = (source-text this)\n  call %1 = clo<\"OrdinaryFunctionCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%AsyncFunction.prototype%\"], sourceText, this[1], this[2], ~non-lexical-this~, env, privateEnv)\n  let closure = %1\n  call %2 = clo<\"MakeMethod\">(closure, object)\n  call %3 = clo<\"SetFunctionName\">(closure, propKey)\n  call %4 = clo<\"DefineMethodProperty\">(object, propKey, closure, enumerable)\n  assert (? %4: Completion)\n  return %4\n}","def <SYNTAX>:GeneratorBody[0,0].EvaluateGeneratorBody(\n  this: Ast[GeneratorBody[0]],\n  functionObject: Record[ECMAScriptFunctionObject],\n  argumentsList: List[ESValue],\n): Return | Throw = {\n  call %0 = clo<\"FunctionDeclarationInstantiation\">(functionObject, argumentsList)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"OrdinaryCreateFromConstructor\">(functionObject, \"%GeneratorFunction.prototype.prototype%\", (list [\"GeneratorState\", \"GeneratorContext\", \"GeneratorBrand\"])[#585])\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let G = %1\n  G.GeneratorBrand = ~empty~\n  G.GeneratorState = undefined\n  call %2 = clo<\"GeneratorStart\">(G, this[0])\n  %3 = (record [CompletionRecord] {\n    \"Type\" : ~return~,\n    \"Value\" : G,\n    \"Target\" : ~empty~,\n  })[#586]\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <SYNTAX>:GeneratorDeclaration[0,0].InstantiateGeneratorFunctionObject(\n  this: Ast[GeneratorDeclaration[0]],\n  env: Record[EnvironmentRecord],\n  privateEnv: Record[PrivateEnvironmentRecord] | Null,\n): Record[ECMAScriptFunctionObject] = {\n  sdo-call %0 = this[0]->StringValue()\n  let name = %0\n  let sourceText = (source-text this)\n  call %1 = clo<\"OrdinaryFunctionCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%GeneratorFunction.prototype%\"], sourceText, this[1], this[2], ~non-lexical-this~, env, privateEnv)\n  let F = %1\n  call %2 = clo<\"SetFunctionName\">(F, name)\n  call %3 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%GeneratorFunction.prototype.prototype%\"])\n  let prototype = %3\n  call %4 = clo<\"DefinePropertyOrThrow\">(F, \"prototype\", (record [PropertyDescriptor] {\n    \"Value\" : prototype,\n    \"Writable\" : true,\n    \"Enumerable\" : false,\n    \"Configurable\" : false,\n  })[#587])\n  assert (? %4: Normal)\n  %4 = %4.Value\n  return F\n}","def <SYNTAX>:GeneratorDeclaration[1,0].InstantiateGeneratorFunctionObject(\n  this: Ast[GeneratorDeclaration[1]],\n  env: Record[EnvironmentRecord],\n  privateEnv: Record[PrivateEnvironmentRecord] | Null,\n): Record[ECMAScriptFunctionObject] = {\n  let sourceText = (source-text this)\n  call %0 = clo<\"OrdinaryFunctionCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%GeneratorFunction.prototype%\"], sourceText, this[0], this[1], ~non-lexical-this~, env, privateEnv)\n  let F = %0\n  call %1 = clo<\"SetFunctionName\">(F, \"default\")\n  call %2 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%GeneratorFunction.prototype.prototype%\"])\n  let prototype = %2\n  call %3 = clo<\"DefinePropertyOrThrow\">(F, \"prototype\", (record [PropertyDescriptor] {\n    \"Value\" : prototype,\n    \"Writable\" : true,\n    \"Enumerable\" : false,\n    \"Configurable\" : false,\n  })[#588])\n  assert (? %3: Normal)\n  %3 = %3.Value\n  return F\n}","def <SYNTAX>:GeneratorExpression[0,0].InstantiateGeneratorFunctionExpression(\n  this: Ast[GeneratorExpression[0]],\n  name?: Record[PrivateName | Symbol] | String,\n): Record[ECMAScriptFunctionObject] = {\n  if (! (exists name)) {\n    name = \"\"\n  }\n  let env = @EXECUTION_STACK[0].LexicalEnvironment\n  let privateEnv = @EXECUTION_STACK[0].PrivateEnvironment\n  let sourceText = (source-text this)\n  call %0 = clo<\"OrdinaryFunctionCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%GeneratorFunction.prototype%\"], sourceText, this[1], this[2], ~non-lexical-this~, env, privateEnv)\n  let closure = %0\n  call %1 = clo<\"SetFunctionName\">(closure, name)\n  call %2 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%GeneratorFunction.prototype.prototype%\"])\n  let prototype = %2\n  call %3 = clo<\"DefinePropertyOrThrow\">(closure, \"prototype\", (record [PropertyDescriptor] {\n    \"Value\" : prototype,\n    \"Writable\" : true,\n    \"Enumerable\" : false,\n    \"Configurable\" : false,\n  })[#589])\n  assert (? %3: Normal)\n  %3 = %3.Value\n  return closure\n}","def <SYNTAX>:GeneratorExpression[0,1].InstantiateGeneratorFunctionExpression(\n  this: Ast[GeneratorExpression[0]],\n  name?: Record[PrivateName | Symbol] | String,\n): Record[ECMAScriptFunctionObject] = {\n  assert (! (exists name))\n  sdo-call %0 = this[0]->StringValue()\n  name = %0\n  let outerEnv = @EXECUTION_STACK[0].LexicalEnvironment\n  call %1 = clo<\"NewDeclarativeEnvironment\">(outerEnv)\n  let funcEnv = %1\n  call %2 = funcEnv.CreateImmutableBinding(funcEnv, name, false)\n  assert (? %2: Normal)\n  %2 = %2.Value\n  let privateEnv = @EXECUTION_STACK[0].PrivateEnvironment\n  let sourceText = (source-text this)\n  call %3 = clo<\"OrdinaryFunctionCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%GeneratorFunction.prototype%\"], sourceText, this[1], this[2], ~non-lexical-this~, funcEnv, privateEnv)\n  let closure = %3\n  call %4 = clo<\"SetFunctionName\">(closure, name)\n  call %5 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%GeneratorFunction.prototype.prototype%\"])\n  let prototype = %5\n  call %6 = clo<\"DefinePropertyOrThrow\">(closure, \"prototype\", (record [PropertyDescriptor] {\n    \"Value\" : prototype,\n    \"Writable\" : true,\n    \"Enumerable\" : false,\n    \"Configurable\" : false,\n  })[#590])\n  assert (? %6: Normal)\n  %6 = %6.Value\n  call %7 = funcEnv.InitializeBinding(funcEnv, name, closure)\n  assert (? %7: Normal)\n  %7 = %7.Value\n  return closure\n}","def <SYNTAX>:GeneratorExpression[0,0].Evaluation(\n  this: Ast[GeneratorExpression[0]],\n): Unknown = {\n  sdo-call %0 = this->InstantiateGeneratorFunctionExpression()\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:GeneratorExpression[0,1].Evaluation(\n  this: Ast[GeneratorExpression[0]],\n): Unknown = {\n  sdo-call %0 = this->InstantiateGeneratorFunctionExpression()\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:YieldExpression[0,0].Evaluation(\n  this: Ast[YieldExpression[0]],\n): Unknown = {\n  call %0 = clo<\"Yield\">(undefined)\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:YieldExpression[1,0].Evaluation(\n  this: Ast[YieldExpression[1]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let exprRef = %0\n  call %1 = clo<\"GetValue\">(exprRef)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let value = %1\n  call %2 = clo<\"Yield\">(value)\n  assert (? %2: Completion)\n  return %2\n}","def <SYNTAX>:YieldExpression[2,0].Evaluation(\n  this: Ast[YieldExpression[2]],\n): Unknown = {\n  call %0 = clo<\"GetGeneratorKind\">()\n  let generatorKind = %0\n  sdo-call %1 = this[0]->Evaluation()\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let exprRef = %1\n  call %2 = clo<\"GetValue\">(exprRef)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let value = %2\n  call %3 = clo<\"GetIterator\">(value, generatorKind)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let iteratorRecord = %3\n  let iterator = iteratorRecord.Iterator\n  call %4 = clo<\"NormalCompletion\">(undefined)\n  let received = %4\n  while true {\n    if (&& (? received: Completion) (= received.Type ~normal~)) {\n      call %5 = clo<\"Call\">(iteratorRecord.NextMethod, iteratorRecord.Iterator, (list [received.Value])[#591])\n      assert (? %5: Completion)\n      if (? %5: Abrupt) return %5\n      else %5 = %5.Value\n      let innerResult = %5\n      if (= generatorKind ~async~) {\n        call %6 = clo<\"Await\">(innerResult)\n        assert (? %6: Completion)\n        if (? %6: Abrupt) return %6\n        else %6 = %6.Value\n        innerResult = %6\n      }\n      if (! (? innerResult: Record[Object])) {\n        call %7 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n        call %8 = clo<\"ThrowCompletion\">(%7)\n        return %8\n      }\n      call %9 = clo<\"IteratorComplete\">(innerResult)\n      assert (? %9: Completion)\n      if (? %9: Abrupt) return %9\n      else %9 = %9.Value\n      let done = %9\n      if (= done true) {\n        call %10 = clo<\"IteratorValue\">(innerResult)\n        assert (? %10: Completion)\n        return %10\n      }\n      if (= generatorKind ~async~) {\n        call %11 = clo<\"IteratorValue\">(innerResult)\n        assert (? %11: Completion)\n        if (? %11: Abrupt) return %11\n        else %11 = %11.Value\n        call %12 = clo<\"AsyncGeneratorYield\">(%11)\n        call %13 = clo<\"Completion\">(%12)\n        received = %13\n      } else {\n        call %14 = clo<\"GeneratorYield\">(innerResult)\n        call %15 = clo<\"Completion\">(%14)\n        received = %15\n      }\n    } else {\n      if (&& (? received: Completion) (= received.Type ~throw~)) {\n        call %16 = clo<\"GetMethod\">(iterator, \"throw\")\n        assert (? %16: Completion)\n        if (? %16: Abrupt) return %16\n        else %16 = %16.Value\n        let throw = %16\n        if (! (= throw undefined)) {\n          call %17 = clo<\"Call\">(throw, iterator, (list [received.Value])[#592])\n          assert (? %17: Completion)\n          if (? %17: Abrupt) return %17\n          else %17 = %17.Value\n          let innerResult = %17\n          if (= generatorKind ~async~) {\n            call %18 = clo<\"Await\">(innerResult)\n            assert (? %18: Completion)\n            if (? %18: Abrupt) return %18\n            else %18 = %18.Value\n            innerResult = %18\n          }\n          nop\n          if (! (? innerResult: Record[Object])) {\n            call %19 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n            call %20 = clo<\"ThrowCompletion\">(%19)\n            return %20\n          }\n          call %21 = clo<\"IteratorComplete\">(innerResult)\n          assert (? %21: Completion)\n          if (? %21: Abrupt) return %21\n          else %21 = %21.Value\n          let done = %21\n          if (= done true) {\n            call %22 = clo<\"IteratorValue\">(innerResult)\n            assert (? %22: Completion)\n            return %22\n          }\n          if (= generatorKind ~async~) {\n            call %23 = clo<\"IteratorValue\">(innerResult)\n            assert (? %23: Completion)\n            if (? %23: Abrupt) return %23\n            else %23 = %23.Value\n            call %24 = clo<\"AsyncGeneratorYield\">(%23)\n            call %25 = clo<\"Completion\">(%24)\n            received = %25\n          } else {\n            call %26 = clo<\"GeneratorYield\">(innerResult)\n            call %27 = clo<\"Completion\">(%26)\n            received = %27\n          }\n        } else {\n          nop\n          let closeCompletion = (record [CompletionRecord] {\n            \"Type\" : ~normal~,\n            \"Value\" : ~empty~,\n            \"Target\" : ~empty~,\n          })[#593]\n          if (= generatorKind ~async~) {\n            call %28 = clo<\"AsyncIteratorClose\">(iteratorRecord, closeCompletion)\n            assert (? %28: Completion)\n            if (? %28: Abrupt) return %28\n            else %28 = %28.Value\n          } else {\n            call %29 = clo<\"IteratorClose\">(iteratorRecord, closeCompletion)\n            assert (? %29: Completion)\n            if (? %29: Abrupt) return %29\n            else %29 = %29.Value\n          }\n          nop\n          call %30 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n          call %31 = clo<\"ThrowCompletion\">(%30)\n          return %31\n        }\n      } else {\n        assert (&& (? received: Completion) (= received.Type ~return~))\n        call %32 = clo<\"GetMethod\">(iterator, \"return\")\n        assert (? %32: Completion)\n        if (? %32: Abrupt) return %32\n        else %32 = %32.Value\n        let return = %32\n        if (= return undefined) {\n          value = received.Value\n          if (= generatorKind ~async~) {\n            call %33 = clo<\"Await\">(value)\n            assert (? %33: Completion)\n            if (? %33: Abrupt) return %33\n            else %33 = %33.Value\n            value = %33\n          }\n          %34 = (record [CompletionRecord] {\n            \"Type\" : ~return~,\n            \"Value\" : value,\n            \"Target\" : ~empty~,\n          })[#594]\n          if (? %34: Completion) return %34\n          call %35 = clo<\"NormalCompletion\">(%34)\n          return %35\n        }\n        call %36 = clo<\"Call\">(return, iterator, (list [received.Value])[#595])\n        assert (? %36: Completion)\n        if (? %36: Abrupt) return %36\n        else %36 = %36.Value\n        let innerReturnResult = %36\n        if (= generatorKind ~async~) {\n          call %37 = clo<\"Await\">(innerReturnResult)\n          assert (? %37: Completion)\n          if (? %37: Abrupt) return %37\n          else %37 = %37.Value\n          innerReturnResult = %37\n        }\n        if (! (? innerReturnResult: Record[Object])) {\n          call %38 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n          call %39 = clo<\"ThrowCompletion\">(%38)\n          return %39\n        }\n        call %40 = clo<\"IteratorComplete\">(innerReturnResult)\n        assert (? %40: Completion)\n        if (? %40: Abrupt) return %40\n        else %40 = %40.Value\n        let done = %40\n        if (= done true) {\n          call %41 = clo<\"IteratorValue\">(innerReturnResult)\n          assert (? %41: Completion)\n          if (? %41: Abrupt) return %41\n          else %41 = %41.Value\n          value = %41\n          %42 = (record [CompletionRecord] {\n            \"Type\" : ~return~,\n            \"Value\" : value,\n            \"Target\" : ~empty~,\n          })[#596]\n          if (? %42: Completion) return %42\n          call %43 = clo<\"NormalCompletion\">(%42)\n          return %43\n        }\n        if (= generatorKind ~async~) {\n          call %44 = clo<\"IteratorValue\">(innerReturnResult)\n          assert (? %44: Completion)\n          if (? %44: Abrupt) return %44\n          else %44 = %44.Value\n          call %45 = clo<\"AsyncGeneratorYield\">(%44)\n          call %46 = clo<\"Completion\">(%45)\n          received = %46\n        } else {\n          call %47 = clo<\"GeneratorYield\">(innerReturnResult)\n          call %48 = clo<\"Completion\">(%47)\n          received = %48\n        }\n      }\n    }\n  }\n}","def <SYNTAX>:AsyncGeneratorBody[0,0].EvaluateAsyncGeneratorBody(\n  this: Ast[AsyncGeneratorBody[0]],\n  functionObject: Record[ECMAScriptFunctionObject],\n  argumentsList: List[ESValue],\n): Return | Throw = {\n  call %0 = clo<\"FunctionDeclarationInstantiation\">(functionObject, argumentsList)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"OrdinaryCreateFromConstructor\">(functionObject, \"%AsyncGeneratorFunction.prototype.prototype%\", (list [\"AsyncGeneratorState\", \"AsyncGeneratorContext\", \"AsyncGeneratorQueue\", \"GeneratorBrand\"])[#597])\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let generator = %1\n  generator.GeneratorBrand = ~empty~\n  generator.AsyncGeneratorState = undefined\n  call %2 = clo<\"AsyncGeneratorStart\">(generator, this[0])\n  %3 = (record [CompletionRecord] {\n    \"Type\" : ~return~,\n    \"Value\" : generator,\n    \"Target\" : ~empty~,\n  })[#598]\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <SYNTAX>:AsyncGeneratorDeclaration[0,0].InstantiateAsyncGeneratorFunctionObject(\n  this: Ast[AsyncGeneratorDeclaration[0]],\n  env: Record[EnvironmentRecord],\n  privateEnv: Record[PrivateEnvironmentRecord] | Null,\n): Record[ECMAScriptFunctionObject] = {\n  sdo-call %0 = this[0]->StringValue()\n  let name = %0\n  let sourceText = (source-text this)\n  call %1 = clo<\"OrdinaryFunctionCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%AsyncGeneratorFunction.prototype%\"], sourceText, this[1], this[2], ~non-lexical-this~, env, privateEnv)\n  let F = %1\n  call %2 = clo<\"SetFunctionName\">(F, name)\n  call %3 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%AsyncGeneratorFunction.prototype.prototype%\"])\n  let prototype = %3\n  call %4 = clo<\"DefinePropertyOrThrow\">(F, \"prototype\", (record [PropertyDescriptor] {\n    \"Value\" : prototype,\n    \"Writable\" : true,\n    \"Enumerable\" : false,\n    \"Configurable\" : false,\n  })[#599])\n  assert (? %4: Normal)\n  %4 = %4.Value\n  return F\n}","def <SYNTAX>:AsyncGeneratorDeclaration[1,0].InstantiateAsyncGeneratorFunctionObject(\n  this: Ast[AsyncGeneratorDeclaration[1]],\n  env: Record[EnvironmentRecord],\n  privateEnv: Record[PrivateEnvironmentRecord] | Null,\n): Record[ECMAScriptFunctionObject] = {\n  let sourceText = (source-text this)\n  call %0 = clo<\"OrdinaryFunctionCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%AsyncGeneratorFunction.prototype%\"], sourceText, this[0], this[1], ~non-lexical-this~, env, privateEnv)\n  let F = %0\n  call %1 = clo<\"SetFunctionName\">(F, \"default\")\n  call %2 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%AsyncGeneratorFunction.prototype.prototype%\"])\n  let prototype = %2\n  call %3 = clo<\"DefinePropertyOrThrow\">(F, \"prototype\", (record [PropertyDescriptor] {\n    \"Value\" : prototype,\n    \"Writable\" : true,\n    \"Enumerable\" : false,\n    \"Configurable\" : false,\n  })[#600])\n  assert (? %3: Normal)\n  %3 = %3.Value\n  return F\n}","def <SYNTAX>:AsyncGeneratorExpression[0,0].InstantiateAsyncGeneratorFunctionExpression(\n  this: Ast[AsyncGeneratorExpression[0]],\n  name?: Record[PrivateName | Symbol] | String,\n): Record[ECMAScriptFunctionObject] = {\n  if (! (exists name)) {\n    name = \"\"\n  }\n  let env = @EXECUTION_STACK[0].LexicalEnvironment\n  let privateEnv = @EXECUTION_STACK[0].PrivateEnvironment\n  let sourceText = (source-text this)\n  call %0 = clo<\"OrdinaryFunctionCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%AsyncGeneratorFunction.prototype%\"], sourceText, this[1], this[2], ~non-lexical-this~, env, privateEnv)\n  let closure = %0\n  call %1 = clo<\"SetFunctionName\">(closure, name)\n  call %2 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%AsyncGeneratorFunction.prototype.prototype%\"])\n  let prototype = %2\n  call %3 = clo<\"DefinePropertyOrThrow\">(closure, \"prototype\", (record [PropertyDescriptor] {\n    \"Value\" : prototype,\n    \"Writable\" : true,\n    \"Enumerable\" : false,\n    \"Configurable\" : false,\n  })[#601])\n  assert (? %3: Normal)\n  %3 = %3.Value\n  return closure\n}","def <SYNTAX>:AsyncGeneratorExpression[0,1].InstantiateAsyncGeneratorFunctionExpression(\n  this: Ast[AsyncGeneratorExpression[0]],\n  name?: Record[PrivateName | Symbol] | String,\n): Record[ECMAScriptFunctionObject] = {\n  assert (! (exists name))\n  sdo-call %0 = this[0]->StringValue()\n  name = %0\n  let outerEnv = @EXECUTION_STACK[0].LexicalEnvironment\n  call %1 = clo<\"NewDeclarativeEnvironment\">(outerEnv)\n  let funcEnv = %1\n  call %2 = funcEnv.CreateImmutableBinding(funcEnv, name, false)\n  assert (? %2: Normal)\n  %2 = %2.Value\n  let privateEnv = @EXECUTION_STACK[0].PrivateEnvironment\n  let sourceText = (source-text this)\n  call %3 = clo<\"OrdinaryFunctionCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%AsyncGeneratorFunction.prototype%\"], sourceText, this[1], this[2], ~non-lexical-this~, funcEnv, privateEnv)\n  let closure = %3\n  call %4 = clo<\"SetFunctionName\">(closure, name)\n  call %5 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%AsyncGeneratorFunction.prototype.prototype%\"])\n  let prototype = %5\n  call %6 = clo<\"DefinePropertyOrThrow\">(closure, \"prototype\", (record [PropertyDescriptor] {\n    \"Value\" : prototype,\n    \"Writable\" : true,\n    \"Enumerable\" : false,\n    \"Configurable\" : false,\n  })[#602])\n  assert (? %6: Normal)\n  %6 = %6.Value\n  call %7 = funcEnv.InitializeBinding(funcEnv, name, closure)\n  assert (? %7: Normal)\n  %7 = %7.Value\n  return closure\n}","def <SYNTAX>:AsyncGeneratorExpression[0,0].Evaluation(\n  this: Ast[AsyncGeneratorExpression[0]],\n): Unknown = {\n  sdo-call %0 = this->InstantiateAsyncGeneratorFunctionExpression()\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:AsyncGeneratorExpression[0,1].Evaluation(\n  this: Ast[AsyncGeneratorExpression[0]],\n): Unknown = {\n  sdo-call %0 = this->InstantiateAsyncGeneratorFunctionExpression()\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:ClassElement[0,0].ClassElementKind(\n  this: Ast[ClassElement[0]],\n): Enum[~constructor-method~, ~empty~, ~non-constructor-method~] = {\n  sdo-call %0 = this[0]->PropName()\n  if (= %0 \"constructor\") {\n    return ~constructor-method~\n  }\n  return ~non-constructor-method~\n}","def <SYNTAX>:ClassElement[1,0].ClassElementKind(\n  this: Ast[ClassElement[1]],\n): Enum[~constructor-method~, ~empty~, ~non-constructor-method~] = {\n  return ~non-constructor-method~\n}","def <SYNTAX>:ClassElement[2,0].ClassElementKind(\n  this: Ast[ClassElement[2]],\n): Enum[~constructor-method~, ~empty~, ~non-constructor-method~] = {\n  return ~non-constructor-method~\n}","def <SYNTAX>:ClassElement[3,0].ClassElementKind(\n  this: Ast[ClassElement[3]],\n): Enum[~constructor-method~, ~empty~, ~non-constructor-method~] = {\n  return ~non-constructor-method~\n}","def <SYNTAX>:ClassElement[4,0].ClassElementKind(\n  this: Ast[ClassElement[4]],\n): Enum[~constructor-method~, ~empty~, ~non-constructor-method~] = {\n  return ~non-constructor-method~\n}","def <SYNTAX>:ClassElement[5,0].ClassElementKind(\n  this: Ast[ClassElement[5]],\n): Enum[~constructor-method~, ~empty~, ~non-constructor-method~] = {\n  return ~empty~\n}","def <SYNTAX>:ClassElementList[0,0].ConstructorMethod(\n  this: Ast[ClassElementList[0]],\n): Unknown[\"ClassElementParseNodeOr~empty~\"] = {\n  sdo-call %0 = this[0]->ClassElementKind()\n  if (= %0 ~constructor-method~) {\n    return this[0]\n  }\n  return ~empty~\n}","def <SYNTAX>:ClassElementList[1,0].ConstructorMethod(\n  this: Ast[ClassElementList[1]],\n): Unknown[\"ClassElementParseNodeOr~empty~\"] = {\n  sdo-call %0 = this[0]->ConstructorMethod()\n  let head = %0\n  if (! (= head ~empty~)) {\n    return head\n  }\n  sdo-call %1 = this[1]->ClassElementKind()\n  if (= %1 ~constructor-method~) {\n    return this[1]\n  }\n  return ~empty~\n}","def <SYNTAX>:ClassElement[0,0].IsStatic(\n  this: Ast[ClassElement[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ClassElement[1,0].IsStatic(\n  this: Ast[ClassElement[1]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:ClassElement[2,0].IsStatic(\n  this: Ast[ClassElement[2]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ClassElement[3,0].IsStatic(\n  this: Ast[ClassElement[3]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:ClassElement[4,0].IsStatic(\n  this: Ast[ClassElement[4]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:ClassElement[5,0].IsStatic(\n  this: Ast[ClassElement[5]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ClassElementList[0,0].NonConstructorElements(\n  this: Ast[ClassElementList[0]],\n): Unknown[\"ListOfClassElementParseNode\"] = {\n  sdo-call %0 = this[0]->ClassElementKind()\n  if (= %0 ~non-constructor-method~) {\n    return (list [this[0]])[#603]\n  }\n  return (list [])[#604]\n}","def <SYNTAX>:ClassElementList[1,0].NonConstructorElements(\n  this: Ast[ClassElementList[1]],\n): Unknown[\"ListOfClassElementParseNode\"] = {\n  sdo-call %0 = this[0]->NonConstructorElements()\n  let list = %0\n  sdo-call %1 = this[1]->ClassElementKind()\n  if (= %1 ~non-constructor-method~) {\n    push list < this[1]\n  }\n  return list\n}","def <SYNTAX>:ClassElementList[0,0].PrototypePropertyNameList(\n  this: Ast[ClassElementList[0]],\n): List[Record[Symbol] | String] = {\n  sdo-call %0 = this[0]->PropName()\n  let propName = %0\n  if (= propName ~empty~) {\n    return (list [])[#605]\n  }\n  sdo-call %1 = this[0]->IsStatic()\n  if (= %1 true) {\n    return (list [])[#606]\n  }\n  return (list [propName])[#607]\n}","def <SYNTAX>:ClassElementList[1,0].PrototypePropertyNameList(\n  this: Ast[ClassElementList[1]],\n): List[Record[Symbol] | String] = {\n  sdo-call %0 = this[0]->PrototypePropertyNameList()\n  let list = %0\n  sdo-call %1 = this[1]->PropName()\n  let propName = %1\n  if (= propName ~empty~) {\n    return list\n  }\n  sdo-call %2 = this[1]->IsStatic()\n  if (= %2 true) {\n    return list\n  }\n  call %3 = clo<\"__FLAT_LIST__\">((list [list, (list [propName])[#609]])[#608])\n  return %3\n}","def <SYNTAX>:<DEFAULT>.AllPrivateIdentifiersValid(\n  this: Ast,\n  names: List[String],\n): Boolean = {\n  %1 = this\n  %0 = 0\n  %2 = (sizeof %1)\n  while (< %0 %2) {\n    if (exists %1[%0]) {\n      let child = %1[%0]\n      if (instanceof child (grammar-symbol ||)) {\n        sdo-call %3 = child->AllPrivateIdentifiersValid(names)\n        if (= %3 false) {\n          return false\n        }\n      }\n    }\n    %0 = (+ %0 1)\n  }\n  return true\n}","def <SYNTAX>:MemberExpression[7,0].AllPrivateIdentifiersValid(\n  this: Ast[MemberExpression[7]],\n  names: List[String],\n): Boolean = {\n  sdo-call %0 = this[1]->StringValue()\n  if (contains names %0) {\n    sdo-call %1 = this[0]->AllPrivateIdentifiersValid(names)\n    return %1\n  }\n  return false\n}","def <SYNTAX>:CallExpression[7,0].AllPrivateIdentifiersValid(\n  this: Ast[CallExpression[7]],\n  names: List[String],\n): Boolean = {\n  sdo-call %0 = this[1]->StringValue()\n  if (contains names %0) {\n    sdo-call %1 = this[0]->AllPrivateIdentifiersValid(names)\n    return %1\n  }\n  return false\n}","def <SYNTAX>:OptionalChain[4,0].AllPrivateIdentifiersValid(\n  this: Ast[OptionalChain[4]],\n  names: List[String],\n): Boolean = {\n  sdo-call %0 = this[0]->StringValue()\n  if (contains names %0) {\n    return true\n  }\n  return false\n}","def <SYNTAX>:OptionalChain[9,0].AllPrivateIdentifiersValid(\n  this: Ast[OptionalChain[9]],\n  names: List[String],\n): Boolean = {\n  sdo-call %0 = this[1]->StringValue()\n  if (contains names %0) {\n    sdo-call %1 = this[0]->AllPrivateIdentifiersValid(names)\n    return %1\n  }\n  return false\n}","def <SYNTAX>:ClassBody[0,0].AllPrivateIdentifiersValid(\n  this: Ast[ClassBody[0]],\n  names: List[String],\n): Boolean = {\n  sdo-call %1 = this->PrivateBoundIdentifiers()\n  call %0 = clo<\"__FLAT_LIST__\">((list [names, %1])[#610])\n  let newNames = %0\n  sdo-call %2 = this[0]->AllPrivateIdentifiersValid(newNames)\n  return %2\n}","def <SYNTAX>:RelationalExpression[7,0].AllPrivateIdentifiersValid(\n  this: Ast[RelationalExpression[7]],\n  names: List[String],\n): Boolean = {\n  sdo-call %0 = this[0]->StringValue()\n  if (contains names %0) {\n    sdo-call %1 = this[1]->AllPrivateIdentifiersValid(names)\n    return %1\n  }\n  return false\n}","def <SYNTAX>:FieldDefinition[0,0].PrivateBoundIdentifiers(\n  this: Ast[FieldDefinition[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->PrivateBoundIdentifiers()\n  return %0\n}","def <SYNTAX>:FieldDefinition[0,1].PrivateBoundIdentifiers(\n  this: Ast[FieldDefinition[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->PrivateBoundIdentifiers()\n  return %0\n}","def <SYNTAX>:ClassElementName[1,0].PrivateBoundIdentifiers(\n  this: Ast[ClassElementName[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->StringValue()\n  return (list [%0])[#611]\n}","def <SYNTAX>:ClassElementName[0,0].PrivateBoundIdentifiers(\n  this: Ast[ClassElementName[0]],\n): List[String] = {\n  return (list [])[#612]\n}","def <SYNTAX>:ClassElement[4,0].PrivateBoundIdentifiers(\n  this: Ast[ClassElement[4]],\n): List[String] = {\n  return (list [])[#613]\n}","def <SYNTAX>:ClassElement[5,0].PrivateBoundIdentifiers(\n  this: Ast[ClassElement[5]],\n): List[String] = {\n  return (list [])[#614]\n}","def <SYNTAX>:ClassElementList[1,0].PrivateBoundIdentifiers(\n  this: Ast[ClassElementList[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->PrivateBoundIdentifiers()\n  let names1 = %0\n  sdo-call %1 = this[1]->PrivateBoundIdentifiers()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#615])\n  return %2\n}","def <SYNTAX>:MethodDefinition[0,0].PrivateBoundIdentifiers(\n  this: Ast[MethodDefinition[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->PrivateBoundIdentifiers()\n  return %0\n}","def <SYNTAX>:MethodDefinition[4,0].PrivateBoundIdentifiers(\n  this: Ast[MethodDefinition[4]],\n): List[String] = {\n  sdo-call %0 = this[0]->PrivateBoundIdentifiers()\n  return %0\n}","def <SYNTAX>:MethodDefinition[5,0].PrivateBoundIdentifiers(\n  this: Ast[MethodDefinition[5]],\n): List[String] = {\n  sdo-call %0 = this[0]->PrivateBoundIdentifiers()\n  return %0\n}","def <SYNTAX>:GeneratorMethod[0,0].PrivateBoundIdentifiers(\n  this: Ast[GeneratorMethod[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->PrivateBoundIdentifiers()\n  return %0\n}","def <SYNTAX>:AsyncMethod[0,0].PrivateBoundIdentifiers(\n  this: Ast[AsyncMethod[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->PrivateBoundIdentifiers()\n  return %0\n}","def <SYNTAX>:AsyncGeneratorMethod[0,0].PrivateBoundIdentifiers(\n  this: Ast[AsyncGeneratorMethod[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->PrivateBoundIdentifiers()\n  return %0\n}","def <SYNTAX>:<DEFAULT>.ContainsArguments(\n  this: Ast,\n): Boolean = {\n  %1 = this\n  %0 = 0\n  %2 = (sizeof %1)\n  while (< %0 %2) {\n    if (exists %1[%0]) {\n      let child = %1[%0]\n      if (instanceof child (grammar-symbol ||)) {\n        sdo-call %3 = child->ContainsArguments()\n        if (= %3 true) {\n          return true\n        }\n      }\n    }\n    %0 = (+ %0 1)\n  }\n  return false\n}","def <SYNTAX>:IdentifierReference[0,0].ContainsArguments(\n  this: Ast[IdentifierReference[0]],\n): Boolean = {\n  sdo-call %0 = this[0]->StringValue()\n  if (= %0 \"arguments\") {\n    return true\n  }\n  return false\n}","def <SYNTAX>:FunctionDeclaration[0,0].ContainsArguments(\n  this: Ast[FunctionDeclaration[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:FunctionDeclaration[1,0].ContainsArguments(\n  this: Ast[FunctionDeclaration[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:FunctionExpression[0,0].ContainsArguments(\n  this: Ast[FunctionExpression[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:FunctionExpression[0,1].ContainsArguments(\n  this: Ast[FunctionExpression[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:GeneratorDeclaration[0,0].ContainsArguments(\n  this: Ast[GeneratorDeclaration[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:GeneratorDeclaration[1,0].ContainsArguments(\n  this: Ast[GeneratorDeclaration[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:GeneratorExpression[0,0].ContainsArguments(\n  this: Ast[GeneratorExpression[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:GeneratorExpression[0,1].ContainsArguments(\n  this: Ast[GeneratorExpression[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AsyncGeneratorDeclaration[0,0].ContainsArguments(\n  this: Ast[AsyncGeneratorDeclaration[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AsyncGeneratorDeclaration[1,0].ContainsArguments(\n  this: Ast[AsyncGeneratorDeclaration[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AsyncGeneratorExpression[0,0].ContainsArguments(\n  this: Ast[AsyncGeneratorExpression[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AsyncGeneratorExpression[0,1].ContainsArguments(\n  this: Ast[AsyncGeneratorExpression[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AsyncFunctionDeclaration[0,0].ContainsArguments(\n  this: Ast[AsyncFunctionDeclaration[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AsyncFunctionDeclaration[1,0].ContainsArguments(\n  this: Ast[AsyncFunctionDeclaration[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AsyncFunctionExpression[0,0].ContainsArguments(\n  this: Ast[AsyncFunctionExpression[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AsyncFunctionExpression[0,1].ContainsArguments(\n  this: Ast[AsyncFunctionExpression[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MethodDefinition[0,0].ContainsArguments(\n  this: Ast[MethodDefinition[0]],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsArguments()\n  return %0\n}","def <SYNTAX>:MethodDefinition[4,0].ContainsArguments(\n  this: Ast[MethodDefinition[4]],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsArguments()\n  return %0\n}","def <SYNTAX>:MethodDefinition[5,0].ContainsArguments(\n  this: Ast[MethodDefinition[5]],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsArguments()\n  return %0\n}","def <SYNTAX>:GeneratorMethod[0,0].ContainsArguments(\n  this: Ast[GeneratorMethod[0]],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsArguments()\n  return %0\n}","def <SYNTAX>:AsyncGeneratorMethod[0,0].ContainsArguments(\n  this: Ast[AsyncGeneratorMethod[0]],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsArguments()\n  return %0\n}","def <SYNTAX>:AsyncMethod[0,0].ContainsArguments(\n  this: Ast[AsyncMethod[0]],\n): Boolean = {\n  sdo-call %0 = this[0]->ContainsArguments()\n  return %0\n}","def <SYNTAX>:FieldDefinition[0,0].ClassFieldDefinitionEvaluation(\n  this: Ast[FieldDefinition[0]],\n  homeObject: Record[Object],\n): Normal[Record[ClassFieldDefinitionRecord]] | Abrupt = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let name = %0\n  if (exists this[1]) {\n    let formalParameterList = |FormalParameters|[TT]<0>\n    let env = @EXECUTION_STACK[0].LexicalEnvironment\n    let privateEnv = @EXECUTION_STACK[0].PrivateEnvironment\n    let sourceText = \"\"\n    call %1 = clo<\"OrdinaryFunctionCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Function.prototype%\"], sourceText, formalParameterList, this[1], ~non-lexical-this~, env, privateEnv)\n    let initializer = %1\n    call %2 = clo<\"MakeMethod\">(initializer, homeObject)\n    initializer.ClassFieldInitializerName = name\n  } else {\n    let initializer = ~empty~\n  }\n  %3 = (record [ClassFieldDefinitionRecord] {\n    \"Name\" : name,\n    \"Initializer\" : initializer,\n  })[#616]\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <SYNTAX>:FieldDefinition[0,1].ClassFieldDefinitionEvaluation(\n  this: Ast[FieldDefinition[0]],\n  homeObject: Record[Object],\n): Normal[Record[ClassFieldDefinitionRecord]] | Abrupt = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let name = %0\n  if (exists this[1]) {\n    let formalParameterList = |FormalParameters|[TT]<0>\n    let env = @EXECUTION_STACK[0].LexicalEnvironment\n    let privateEnv = @EXECUTION_STACK[0].PrivateEnvironment\n    let sourceText = \"\"\n    call %1 = clo<\"OrdinaryFunctionCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Function.prototype%\"], sourceText, formalParameterList, this[1], ~non-lexical-this~, env, privateEnv)\n    let initializer = %1\n    call %2 = clo<\"MakeMethod\">(initializer, homeObject)\n    initializer.ClassFieldInitializerName = name\n  } else {\n    let initializer = ~empty~\n  }\n  %3 = (record [ClassFieldDefinitionRecord] {\n    \"Name\" : name,\n    \"Initializer\" : initializer,\n  })[#617]\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <SYNTAX>:ClassStaticBlock[0,0].ClassStaticBlockDefinitionEvaluation(\n  this: Ast[ClassStaticBlock[0]],\n  homeObject: Record[Object],\n): Record[ClassStaticBlockDefinitionRecord] = {\n  let lex = @EXECUTION_STACK[0].LexicalEnvironment\n  let privateEnv = @EXECUTION_STACK[0].PrivateEnvironment\n  let sourceText = \"\"\n  let formalParameters = |FormalParameters|[TT]<0>\n  call %0 = clo<\"OrdinaryFunctionCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Function.prototype%\"], sourceText, formalParameters, this[0], ~non-lexical-this~, lex, privateEnv)\n  let bodyFunction = %0\n  call %1 = clo<\"MakeMethod\">(bodyFunction, homeObject)\n  return (record [ClassStaticBlockDefinitionRecord] {\n    \"BodyFunction\" : bodyFunction,\n  })[#618]\n}","def <SYNTAX>:ClassStaticBlockBody[0,0].EvaluateClassStaticBlockBody(\n  this: Ast[ClassStaticBlockBody[0]],\n  functionObject: Record[ECMAScriptFunctionObject],\n): Normal[ESValue] | Abrupt = {\n  assert (yet \"_functionObject_ is a synthetic function created by ClassStaticBlockDefinitionEvaluation step <emu-xref href=\\\"#step-synthetic-class-static-block-fn\\\"></emu-xref>.\")\n  call %0 = clo<\"FunctionDeclarationInstantiation\">(functionObject, (list [])[#619])\n  assert (? %0: Normal)\n  %0 = %0.Value\n  sdo-call %1 = this[0]->Evaluation()\n  assert (? %1: Completion)\n  return %1\n}","def <SYNTAX>:ClassElement[2,0].ClassElementEvaluation(\n  this: Ast[ClassElement[2]],\n  object: Record[Object],\n): Normal[Record[ClassFieldDefinitionRecord | ClassStaticBlockDefinitionRecord | PrivateElement] | Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->ClassFieldDefinitionEvaluation(object)\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:ClassElement[3,0].ClassElementEvaluation(\n  this: Ast[ClassElement[3]],\n  object: Record[Object],\n): Normal[Record[ClassFieldDefinitionRecord | ClassStaticBlockDefinitionRecord | PrivateElement] | Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->ClassFieldDefinitionEvaluation(object)\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:ClassElement[0,0].ClassElementEvaluation(\n  this: Ast[ClassElement[0]],\n  object: Record[Object],\n): Normal[Record[ClassFieldDefinitionRecord | ClassStaticBlockDefinitionRecord | PrivateElement] | Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->MethodDefinitionEvaluation(object, false)\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:ClassElement[1,0].ClassElementEvaluation(\n  this: Ast[ClassElement[1]],\n  object: Record[Object],\n): Normal[Record[ClassFieldDefinitionRecord | ClassStaticBlockDefinitionRecord | PrivateElement] | Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->MethodDefinitionEvaluation(object, false)\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:ClassElement[4,0].ClassElementEvaluation(\n  this: Ast[ClassElement[4]],\n  object: Record[Object],\n): Normal[Record[ClassFieldDefinitionRecord | ClassStaticBlockDefinitionRecord | PrivateElement] | Enum[~unused~]] | Abrupt = {\n  sdo-call %0 = this[0]->ClassStaticBlockDefinitionEvaluation(object)\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:ClassElement[5,0].ClassElementEvaluation(\n  this: Ast[ClassElement[5]],\n  object: Record[Object],\n): Normal[Record[ClassFieldDefinitionRecord | ClassStaticBlockDefinitionRecord | PrivateElement] | Enum[~unused~]] | Abrupt = {\n  call %0 = clo<\"NormalCompletion\">(~unused~)\n  return %0\n}","def <CLO>:ClassTail[0,0].ClassDefinitionEvaluation:clo0(\n  this: Unknown,\n  ArgumentsList: Unknown,\n  NewTarget: Unknown,\n): Unknown = {\n  let __args__ = (record)[#620]\n  let args = ArgumentsList\n  if (= NewTarget undefined) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  let F = @EXECUTION_STACK[0].Function\n  if (= F.ConstructorKind ~derived~) {\n    nop\n    call %2 = F.GetPrototypeOf(F)\n    assert (? %2: Normal)\n    %2 = %2.Value\n    let func = %2\n    call %3 = clo<\"IsConstructor\">(func)\n    if (= %3 false) {\n      call %4 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %5 = clo<\"ThrowCompletion\">(%4)\n      return %5\n    }\n    call %6 = clo<\"Construct\">(func, args, NewTarget)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    let result = %6\n  } else {\n    nop\n    call %7 = clo<\"OrdinaryCreateFromConstructor\">(NewTarget, \"%Object.prototype%\")\n    assert (? %7: Completion)\n    if (? %7: Abrupt) return %7\n    else %7 = %7.Value\n    let result = %7\n  }\n  call %8 = clo<\"InitializeInstanceElements\">(result, F)\n  assert (? %8: Completion)\n  if (? %8: Abrupt) return %8\n  else %8 = %8.Value\n  if (? result: Completion) return result\n  call %9 = clo<\"NormalCompletion\">(result)\n  return %9\n}","def <SYNTAX>:ClassTail[0,0].ClassDefinitionEvaluation(\n  this: Ast[ClassTail[0]],\n  classBinding: String | Undefined,\n  className: Record[PrivateName | Symbol] | String,\n): Normal[Record[FunctionObject]] | Abrupt = {\n  let env = @EXECUTION_STACK[0].LexicalEnvironment\n  call %0 = clo<\"NewDeclarativeEnvironment\">(env)\n  let classEnv = %0\n  if (! (= classBinding undefined)) {\n    call %1 = classEnv.CreateImmutableBinding(classEnv, classBinding, true)\n    assert (? %1: Normal)\n    %1 = %1.Value\n  }\n  let outerPrivateEnvironment = @EXECUTION_STACK[0].PrivateEnvironment\n  call %2 = clo<\"NewPrivateEnvironment\">(outerPrivateEnvironment)\n  let classPrivateEnvironment = %2\n  if (exists this[1]) {\n    sdo-call %5 = this[1]->PrivateBoundIdentifiers()\n    %4 = %5\n    %3 = 0\n    while (< %3 (sizeof %4)) {\n      let dn = %4[%3]\n      if (? dn: String) {\n        %6 = classPrivateEnvironment.Names\n        %7 = 0\n        %8 = false\n        while (&& (! %8) (< %7 (sizeof %6))) {\n          let pn = %6[%7]\n          %8 = (&& (? pn: Record[PrivateName]) (= pn.Description dn))\n          %7 = (+ %7 1)\n        }\n        if %8 {\n          assert (yet \"This is only possible for getter/setter pairs.\")\n        } else {\n          let name = (record [PrivateName] {\n            \"Description\" : dn,\n          })[#621]\n          push classPrivateEnvironment.Names < name\n        }\n      }\n      %3 = (+ %3 1)\n    }\n  }\n  if (! (exists this[0])) {\n    let protoParent = @EXECUTION_STACK[0].Realm.Intrinsics[\"%Object.prototype%\"]\n    let constructorParent = @EXECUTION_STACK[0].Realm.Intrinsics[\"%Function.prototype%\"]\n  } else {\n    @EXECUTION_STACK[0].LexicalEnvironment = classEnv\n    nop\n    sdo-call %9 = this[0]->Evaluation()\n    call %10 = clo<\"Completion\">(%9)\n    let superclassRef = %10\n    @EXECUTION_STACK[0].LexicalEnvironment = env\n    assert (? superclassRef: Completion)\n    if (? superclassRef: Abrupt) return superclassRef\n    else superclassRef = superclassRef.Value\n    call %11 = clo<\"GetValue\">(superclassRef)\n    assert (? %11: Completion)\n    if (? %11: Abrupt) return %11\n    else %11 = %11.Value\n    let superclass = %11\n    if (= superclass null) {\n      let protoParent = null\n      let constructorParent = @EXECUTION_STACK[0].Realm.Intrinsics[\"%Function.prototype%\"]\n    } else {\n      call %12 = clo<\"IsConstructor\">(superclass)\n      if (= %12 false) {\n        call %13 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n        call %14 = clo<\"ThrowCompletion\">(%13)\n        return %14\n      } else {\n        call %15 = clo<\"Get\">(superclass, \"prototype\")\n        assert (? %15: Completion)\n        if (? %15: Abrupt) return %15\n        else %15 = %15.Value\n        let protoParent = %15\n        if (&& (! (? protoParent: Record[Object])) (! (= protoParent null))) {\n          call %16 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n          call %17 = clo<\"ThrowCompletion\">(%16)\n          return %17\n        }\n        let constructorParent = superclass\n      }\n    }\n  }\n  call %18 = clo<\"OrdinaryObjectCreate\">(protoParent)\n  let proto = %18\n  if (! (exists this[1])) {\n    let constructor = ~empty~\n  } else {\n    sdo-call %19 = this[1]->ConstructorMethod()\n    let constructor = %19\n  }\n  @EXECUTION_STACK[0].LexicalEnvironment = classEnv\n  @EXECUTION_STACK[0].PrivateEnvironment = classPrivateEnvironment\n  if (= constructor ~empty~) {\n    let defaultConstructor = clo<\"ClassTail[0,0].ClassDefinitionEvaluation:clo0\">\n    call %20 = clo<\"CreateBuiltinFunction\">(defaultConstructor, 0, className, (list [\"ConstructorKind\", \"SourceText\"])[#622], @EXECUTION_STACK[0].Realm, constructorParent)\n    let F = %20\n  } else {\n    sdo-call %21 = constructor->DefineMethod(proto, constructorParent)\n    assert (? %21: Normal)\n    %21 = %21.Value\n    let constructorInfo = %21\n    let F = constructorInfo.Closure\n    call %22 = clo<\"MakeClassConstructor\">(F)\n    call %23 = clo<\"SetFunctionName\">(F, className)\n  }\n  call %24 = clo<\"MakeConstructor\">(F, false, proto)\n  if (exists this[0]) {\n    F.ConstructorKind = ~derived~\n  }\n  call %25 = clo<\"DefineMethodProperty\">(proto, \"constructor\", F, false)\n  assert (? %25: Normal)\n  %25 = %25.Value\n  if (! (exists this[1])) {\n    let elements = (list [])[#623]\n  } else {\n    sdo-call %26 = this[1]->NonConstructorElements()\n    let elements = %26\n  }\n  let instancePrivateMethods = (list [])[#624]\n  let staticPrivateMethods = (list [])[#625]\n  let instanceFields = (list [])[#626]\n  let staticElements = (list [])[#627]\n  %28 = elements\n  %27 = 0\n  while (< %27 (sizeof %28)) {\n    let e = %28[%27]\n    if (? e: Ast[ClassElement]) {\n      sdo-call %29 = e->IsStatic()\n      if (= %29 false) {\n        sdo-call %30 = e->ClassElementEvaluation(proto)\n        call %31 = clo<\"Completion\">(%30)\n        let element = %31\n      } else {\n        sdo-call %32 = e->ClassElementEvaluation(F)\n        call %33 = clo<\"Completion\">(%32)\n        let element = %33\n      }\n      if (&& (? element: Completion) (! (= element.Type ~normal~))) {\n        @EXECUTION_STACK[0].LexicalEnvironment = env\n        @EXECUTION_STACK[0].PrivateEnvironment = outerPrivateEnvironment\n        assert (? element: Completion)\n        return element\n      }\n      assert (? element: Normal)\n      element = element.Value\n      element = element\n      if (? element: Record[PrivateElement]) {\n        assert (|| (= element.Kind ~method~) (= element.Kind ~accessor~))\n        sdo-call %34 = e->IsStatic()\n        if (= %34 false) {\n          let container = instancePrivateMethods\n        } else {\n          let container = staticPrivateMethods\n        }\n        %35 = container\n        %36 = 0\n        %37 = false\n        while (&& (! %37) (< %36 (sizeof %35))) {\n          let pe = %35[%36]\n          %37 = (&& (? pe: Record[PrivateElement]) (= pe.Key element.Key))\n          %36 = (+ %36 1)\n        }\n        if %37 {\n          assert (&& (= element.Kind ~accessor~) (= pe.Kind ~accessor~))\n          if (= element.Get undefined) {\n            let combined = (record [PrivateElement] {\n              \"Key\" : element.Key,\n              \"Kind\" : ~accessor~,\n              \"Get\" : pe.Get,\n              \"Set\" : element.Set,\n            })[#628]\n          } else {\n            let combined = (record [PrivateElement] {\n              \"Key\" : element.Key,\n              \"Kind\" : ~accessor~,\n              \"Get\" : element.Get,\n              \"Set\" : pe.Set,\n            })[#629]\n          }\n          (yet \"Replace _pe_ in _container_ with _combined_.\")\n        } else {\n          push container < element\n        }\n      } else {\n        if (? element: Record[ClassFieldDefinitionRecord]) {\n          sdo-call %38 = e->IsStatic()\n          if (= %38 false) {\n            push instanceFields < element\n          } else {\n            push staticElements < element\n          }\n        } else {\n          if (? element: Record[ClassStaticBlockDefinitionRecord]) {\n            push staticElements < element\n          }\n        }\n      }\n    }\n    %27 = (+ %27 1)\n  }\n  @EXECUTION_STACK[0].LexicalEnvironment = env\n  if (! (= classBinding undefined)) {\n    call %39 = classEnv.InitializeBinding(classEnv, classBinding, F)\n    assert (? %39: Normal)\n    %39 = %39.Value\n  }\n  F.PrivateMethods = instancePrivateMethods\n  F.Fields = instanceFields\n  %41 = staticPrivateMethods\n  %40 = 0\n  while (< %40 (sizeof %41)) {\n    let method = %41[%40]\n    if (? method: Record[PrivateElement]) {\n      call %42 = clo<\"PrivateMethodOrAccessorAdd\">(F, method)\n      assert (? %42: Normal)\n      %42 = %42.Value\n    }\n    %40 = (+ %40 1)\n  }\n  %44 = staticElements\n  %43 = 0\n  while (< %43 (sizeof %44)) {\n    let elementRecord = %44[%43]\n    if (? elementRecord: Record[ClassFieldDefinitionRecord]) {\n      call %45 = clo<\"DefineField\">(F, elementRecord)\n      call %46 = clo<\"Completion\">(%45)\n      let result = %46\n    } else {\n      assert (? elementRecord: Record[ClassStaticBlockDefinitionRecord])\n      call %47 = clo<\"Call\">(elementRecord.BodyFunction, F)\n      call %48 = clo<\"Completion\">(%47)\n      let result = %48\n    }\n    if (&& (? result: Completion) (! (= result.Type ~normal~))) {\n      @EXECUTION_STACK[0].PrivateEnvironment = outerPrivateEnvironment\n      assert (? result: Completion)\n      return result\n    }\n    %43 = (+ %43 1)\n  }\n  @EXECUTION_STACK[0].PrivateEnvironment = outerPrivateEnvironment\n  if (? F: Completion) return F\n  call %49 = clo<\"NormalCompletion\">(F)\n  return %49\n}","def <CLO>:ClassTail[0,1].ClassDefinitionEvaluation:clo0(\n  this: Unknown,\n  ArgumentsList: Unknown,\n  NewTarget: Unknown,\n): Unknown = {\n  let __args__ = (record)[#630]\n  let args = ArgumentsList\n  if (= NewTarget undefined) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  let F = @EXECUTION_STACK[0].Function\n  if (= F.ConstructorKind ~derived~) {\n    nop\n    call %2 = F.GetPrototypeOf(F)\n    assert (? %2: Normal)\n    %2 = %2.Value\n    let func = %2\n    call %3 = clo<\"IsConstructor\">(func)\n    if (= %3 false) {\n      call %4 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %5 = clo<\"ThrowCompletion\">(%4)\n      return %5\n    }\n    call %6 = clo<\"Construct\">(func, args, NewTarget)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    let result = %6\n  } else {\n    nop\n    call %7 = clo<\"OrdinaryCreateFromConstructor\">(NewTarget, \"%Object.prototype%\")\n    assert (? %7: Completion)\n    if (? %7: Abrupt) return %7\n    else %7 = %7.Value\n    let result = %7\n  }\n  call %8 = clo<\"InitializeInstanceElements\">(result, F)\n  assert (? %8: Completion)\n  if (? %8: Abrupt) return %8\n  else %8 = %8.Value\n  if (? result: Completion) return result\n  call %9 = clo<\"NormalCompletion\">(result)\n  return %9\n}","def <SYNTAX>:ClassTail[0,1].ClassDefinitionEvaluation(\n  this: Ast[ClassTail[0]],\n  classBinding: String | Undefined,\n  className: Record[PrivateName | Symbol] | String,\n): Normal[Record[FunctionObject]] | Abrupt = {\n  let env = @EXECUTION_STACK[0].LexicalEnvironment\n  call %0 = clo<\"NewDeclarativeEnvironment\">(env)\n  let classEnv = %0\n  if (! (= classBinding undefined)) {\n    call %1 = classEnv.CreateImmutableBinding(classEnv, classBinding, true)\n    assert (? %1: Normal)\n    %1 = %1.Value\n  }\n  let outerPrivateEnvironment = @EXECUTION_STACK[0].PrivateEnvironment\n  call %2 = clo<\"NewPrivateEnvironment\">(outerPrivateEnvironment)\n  let classPrivateEnvironment = %2\n  if (exists this[1]) {\n    sdo-call %5 = this[1]->PrivateBoundIdentifiers()\n    %4 = %5\n    %3 = 0\n    while (< %3 (sizeof %4)) {\n      let dn = %4[%3]\n      if (? dn: String) {\n        %6 = classPrivateEnvironment.Names\n        %7 = 0\n        %8 = false\n        while (&& (! %8) (< %7 (sizeof %6))) {\n          let pn = %6[%7]\n          %8 = (&& (? pn: Record[PrivateName]) (= pn.Description dn))\n          %7 = (+ %7 1)\n        }\n        if %8 {\n          assert (yet \"This is only possible for getter/setter pairs.\")\n        } else {\n          let name = (record [PrivateName] {\n            \"Description\" : dn,\n          })[#631]\n          push classPrivateEnvironment.Names < name\n        }\n      }\n      %3 = (+ %3 1)\n    }\n  }\n  if (! (exists this[0])) {\n    let protoParent = @EXECUTION_STACK[0].Realm.Intrinsics[\"%Object.prototype%\"]\n    let constructorParent = @EXECUTION_STACK[0].Realm.Intrinsics[\"%Function.prototype%\"]\n  } else {\n    @EXECUTION_STACK[0].LexicalEnvironment = classEnv\n    nop\n    sdo-call %9 = this[0]->Evaluation()\n    call %10 = clo<\"Completion\">(%9)\n    let superclassRef = %10\n    @EXECUTION_STACK[0].LexicalEnvironment = env\n    assert (? superclassRef: Completion)\n    if (? superclassRef: Abrupt) return superclassRef\n    else superclassRef = superclassRef.Value\n    call %11 = clo<\"GetValue\">(superclassRef)\n    assert (? %11: Completion)\n    if (? %11: Abrupt) return %11\n    else %11 = %11.Value\n    let superclass = %11\n    if (= superclass null) {\n      let protoParent = null\n      let constructorParent = @EXECUTION_STACK[0].Realm.Intrinsics[\"%Function.prototype%\"]\n    } else {\n      call %12 = clo<\"IsConstructor\">(superclass)\n      if (= %12 false) {\n        call %13 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n        call %14 = clo<\"ThrowCompletion\">(%13)\n        return %14\n      } else {\n        call %15 = clo<\"Get\">(superclass, \"prototype\")\n        assert (? %15: Completion)\n        if (? %15: Abrupt) return %15\n        else %15 = %15.Value\n        let protoParent = %15\n        if (&& (! (? protoParent: Record[Object])) (! (= protoParent null))) {\n          call %16 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n          call %17 = clo<\"ThrowCompletion\">(%16)\n          return %17\n        }\n        let constructorParent = superclass\n      }\n    }\n  }\n  call %18 = clo<\"OrdinaryObjectCreate\">(protoParent)\n  let proto = %18\n  if (! (exists this[1])) {\n    let constructor = ~empty~\n  } else {\n    sdo-call %19 = this[1]->ConstructorMethod()\n    let constructor = %19\n  }\n  @EXECUTION_STACK[0].LexicalEnvironment = classEnv\n  @EXECUTION_STACK[0].PrivateEnvironment = classPrivateEnvironment\n  if (= constructor ~empty~) {\n    let defaultConstructor = clo<\"ClassTail[0,1].ClassDefinitionEvaluation:clo0\">\n    call %20 = clo<\"CreateBuiltinFunction\">(defaultConstructor, 0, className, (list [\"ConstructorKind\", \"SourceText\"])[#632], @EXECUTION_STACK[0].Realm, constructorParent)\n    let F = %20\n  } else {\n    sdo-call %21 = constructor->DefineMethod(proto, constructorParent)\n    assert (? %21: Normal)\n    %21 = %21.Value\n    let constructorInfo = %21\n    let F = constructorInfo.Closure\n    call %22 = clo<\"MakeClassConstructor\">(F)\n    call %23 = clo<\"SetFunctionName\">(F, className)\n  }\n  call %24 = clo<\"MakeConstructor\">(F, false, proto)\n  if (exists this[0]) {\n    F.ConstructorKind = ~derived~\n  }\n  call %25 = clo<\"DefineMethodProperty\">(proto, \"constructor\", F, false)\n  assert (? %25: Normal)\n  %25 = %25.Value\n  if (! (exists this[1])) {\n    let elements = (list [])[#633]\n  } else {\n    sdo-call %26 = this[1]->NonConstructorElements()\n    let elements = %26\n  }\n  let instancePrivateMethods = (list [])[#634]\n  let staticPrivateMethods = (list [])[#635]\n  let instanceFields = (list [])[#636]\n  let staticElements = (list [])[#637]\n  %28 = elements\n  %27 = 0\n  while (< %27 (sizeof %28)) {\n    let e = %28[%27]\n    if (? e: Ast[ClassElement]) {\n      sdo-call %29 = e->IsStatic()\n      if (= %29 false) {\n        sdo-call %30 = e->ClassElementEvaluation(proto)\n        call %31 = clo<\"Completion\">(%30)\n        let element = %31\n      } else {\n        sdo-call %32 = e->ClassElementEvaluation(F)\n        call %33 = clo<\"Completion\">(%32)\n        let element = %33\n      }\n      if (&& (? element: Completion) (! (= element.Type ~normal~))) {\n        @EXECUTION_STACK[0].LexicalEnvironment = env\n        @EXECUTION_STACK[0].PrivateEnvironment = outerPrivateEnvironment\n        assert (? element: Completion)\n        return element\n      }\n      assert (? element: Normal)\n      element = element.Value\n      element = element\n      if (? element: Record[PrivateElement]) {\n        assert (|| (= element.Kind ~method~) (= element.Kind ~accessor~))\n        sdo-call %34 = e->IsStatic()\n        if (= %34 false) {\n          let container = instancePrivateMethods\n        } else {\n          let container = staticPrivateMethods\n        }\n        %35 = container\n        %36 = 0\n        %37 = false\n        while (&& (! %37) (< %36 (sizeof %35))) {\n          let pe = %35[%36]\n          %37 = (&& (? pe: Record[PrivateElement]) (= pe.Key element.Key))\n          %36 = (+ %36 1)\n        }\n        if %37 {\n          assert (&& (= element.Kind ~accessor~) (= pe.Kind ~accessor~))\n          if (= element.Get undefined) {\n            let combined = (record [PrivateElement] {\n              \"Key\" : element.Key,\n              \"Kind\" : ~accessor~,\n              \"Get\" : pe.Get,\n              \"Set\" : element.Set,\n            })[#638]\n          } else {\n            let combined = (record [PrivateElement] {\n              \"Key\" : element.Key,\n              \"Kind\" : ~accessor~,\n              \"Get\" : element.Get,\n              \"Set\" : pe.Set,\n            })[#639]\n          }\n          (yet \"Replace _pe_ in _container_ with _combined_.\")\n        } else {\n          push container < element\n        }\n      } else {\n        if (? element: Record[ClassFieldDefinitionRecord]) {\n          sdo-call %38 = e->IsStatic()\n          if (= %38 false) {\n            push instanceFields < element\n          } else {\n            push staticElements < element\n          }\n        } else {\n          if (? element: Record[ClassStaticBlockDefinitionRecord]) {\n            push staticElements < element\n          }\n        }\n      }\n    }\n    %27 = (+ %27 1)\n  }\n  @EXECUTION_STACK[0].LexicalEnvironment = env\n  if (! (= classBinding undefined)) {\n    call %39 = classEnv.InitializeBinding(classEnv, classBinding, F)\n    assert (? %39: Normal)\n    %39 = %39.Value\n  }\n  F.PrivateMethods = instancePrivateMethods\n  F.Fields = instanceFields\n  %41 = staticPrivateMethods\n  %40 = 0\n  while (< %40 (sizeof %41)) {\n    let method = %41[%40]\n    if (? method: Record[PrivateElement]) {\n      call %42 = clo<\"PrivateMethodOrAccessorAdd\">(F, method)\n      assert (? %42: Normal)\n      %42 = %42.Value\n    }\n    %40 = (+ %40 1)\n  }\n  %44 = staticElements\n  %43 = 0\n  while (< %43 (sizeof %44)) {\n    let elementRecord = %44[%43]\n    if (? elementRecord: Record[ClassFieldDefinitionRecord]) {\n      call %45 = clo<\"DefineField\">(F, elementRecord)\n      call %46 = clo<\"Completion\">(%45)\n      let result = %46\n    } else {\n      assert (? elementRecord: Record[ClassStaticBlockDefinitionRecord])\n      call %47 = clo<\"Call\">(elementRecord.BodyFunction, F)\n      call %48 = clo<\"Completion\">(%47)\n      let result = %48\n    }\n    if (&& (? result: Completion) (! (= result.Type ~normal~))) {\n      @EXECUTION_STACK[0].PrivateEnvironment = outerPrivateEnvironment\n      assert (? result: Completion)\n      return result\n    }\n    %43 = (+ %43 1)\n  }\n  @EXECUTION_STACK[0].PrivateEnvironment = outerPrivateEnvironment\n  if (? F: Completion) return F\n  call %49 = clo<\"NormalCompletion\">(F)\n  return %49\n}","def <CLO>:ClassTail[0,2].ClassDefinitionEvaluation:clo0(\n  this: Unknown,\n  ArgumentsList: Unknown,\n  NewTarget: Unknown,\n): Unknown = {\n  let __args__ = (record)[#640]\n  let args = ArgumentsList\n  if (= NewTarget undefined) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  let F = @EXECUTION_STACK[0].Function\n  if (= F.ConstructorKind ~derived~) {\n    nop\n    call %2 = F.GetPrototypeOf(F)\n    assert (? %2: Normal)\n    %2 = %2.Value\n    let func = %2\n    call %3 = clo<\"IsConstructor\">(func)\n    if (= %3 false) {\n      call %4 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %5 = clo<\"ThrowCompletion\">(%4)\n      return %5\n    }\n    call %6 = clo<\"Construct\">(func, args, NewTarget)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    let result = %6\n  } else {\n    nop\n    call %7 = clo<\"OrdinaryCreateFromConstructor\">(NewTarget, \"%Object.prototype%\")\n    assert (? %7: Completion)\n    if (? %7: Abrupt) return %7\n    else %7 = %7.Value\n    let result = %7\n  }\n  call %8 = clo<\"InitializeInstanceElements\">(result, F)\n  assert (? %8: Completion)\n  if (? %8: Abrupt) return %8\n  else %8 = %8.Value\n  if (? result: Completion) return result\n  call %9 = clo<\"NormalCompletion\">(result)\n  return %9\n}","def <SYNTAX>:ClassTail[0,2].ClassDefinitionEvaluation(\n  this: Ast[ClassTail[0]],\n  classBinding: String | Undefined,\n  className: Record[PrivateName | Symbol] | String,\n): Normal[Record[FunctionObject]] | Abrupt = {\n  let env = @EXECUTION_STACK[0].LexicalEnvironment\n  call %0 = clo<\"NewDeclarativeEnvironment\">(env)\n  let classEnv = %0\n  if (! (= classBinding undefined)) {\n    call %1 = classEnv.CreateImmutableBinding(classEnv, classBinding, true)\n    assert (? %1: Normal)\n    %1 = %1.Value\n  }\n  let outerPrivateEnvironment = @EXECUTION_STACK[0].PrivateEnvironment\n  call %2 = clo<\"NewPrivateEnvironment\">(outerPrivateEnvironment)\n  let classPrivateEnvironment = %2\n  if (exists this[1]) {\n    sdo-call %5 = this[1]->PrivateBoundIdentifiers()\n    %4 = %5\n    %3 = 0\n    while (< %3 (sizeof %4)) {\n      let dn = %4[%3]\n      if (? dn: String) {\n        %6 = classPrivateEnvironment.Names\n        %7 = 0\n        %8 = false\n        while (&& (! %8) (< %7 (sizeof %6))) {\n          let pn = %6[%7]\n          %8 = (&& (? pn: Record[PrivateName]) (= pn.Description dn))\n          %7 = (+ %7 1)\n        }\n        if %8 {\n          assert (yet \"This is only possible for getter/setter pairs.\")\n        } else {\n          let name = (record [PrivateName] {\n            \"Description\" : dn,\n          })[#641]\n          push classPrivateEnvironment.Names < name\n        }\n      }\n      %3 = (+ %3 1)\n    }\n  }\n  if (! (exists this[0])) {\n    let protoParent = @EXECUTION_STACK[0].Realm.Intrinsics[\"%Object.prototype%\"]\n    let constructorParent = @EXECUTION_STACK[0].Realm.Intrinsics[\"%Function.prototype%\"]\n  } else {\n    @EXECUTION_STACK[0].LexicalEnvironment = classEnv\n    nop\n    sdo-call %9 = this[0]->Evaluation()\n    call %10 = clo<\"Completion\">(%9)\n    let superclassRef = %10\n    @EXECUTION_STACK[0].LexicalEnvironment = env\n    assert (? superclassRef: Completion)\n    if (? superclassRef: Abrupt) return superclassRef\n    else superclassRef = superclassRef.Value\n    call %11 = clo<\"GetValue\">(superclassRef)\n    assert (? %11: Completion)\n    if (? %11: Abrupt) return %11\n    else %11 = %11.Value\n    let superclass = %11\n    if (= superclass null) {\n      let protoParent = null\n      let constructorParent = @EXECUTION_STACK[0].Realm.Intrinsics[\"%Function.prototype%\"]\n    } else {\n      call %12 = clo<\"IsConstructor\">(superclass)\n      if (= %12 false) {\n        call %13 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n        call %14 = clo<\"ThrowCompletion\">(%13)\n        return %14\n      } else {\n        call %15 = clo<\"Get\">(superclass, \"prototype\")\n        assert (? %15: Completion)\n        if (? %15: Abrupt) return %15\n        else %15 = %15.Value\n        let protoParent = %15\n        if (&& (! (? protoParent: Record[Object])) (! (= protoParent null))) {\n          call %16 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n          call %17 = clo<\"ThrowCompletion\">(%16)\n          return %17\n        }\n        let constructorParent = superclass\n      }\n    }\n  }\n  call %18 = clo<\"OrdinaryObjectCreate\">(protoParent)\n  let proto = %18\n  if (! (exists this[1])) {\n    let constructor = ~empty~\n  } else {\n    sdo-call %19 = this[1]->ConstructorMethod()\n    let constructor = %19\n  }\n  @EXECUTION_STACK[0].LexicalEnvironment = classEnv\n  @EXECUTION_STACK[0].PrivateEnvironment = classPrivateEnvironment\n  if (= constructor ~empty~) {\n    let defaultConstructor = clo<\"ClassTail[0,2].ClassDefinitionEvaluation:clo0\">\n    call %20 = clo<\"CreateBuiltinFunction\">(defaultConstructor, 0, className, (list [\"ConstructorKind\", \"SourceText\"])[#642], @EXECUTION_STACK[0].Realm, constructorParent)\n    let F = %20\n  } else {\n    sdo-call %21 = constructor->DefineMethod(proto, constructorParent)\n    assert (? %21: Normal)\n    %21 = %21.Value\n    let constructorInfo = %21\n    let F = constructorInfo.Closure\n    call %22 = clo<\"MakeClassConstructor\">(F)\n    call %23 = clo<\"SetFunctionName\">(F, className)\n  }\n  call %24 = clo<\"MakeConstructor\">(F, false, proto)\n  if (exists this[0]) {\n    F.ConstructorKind = ~derived~\n  }\n  call %25 = clo<\"DefineMethodProperty\">(proto, \"constructor\", F, false)\n  assert (? %25: Normal)\n  %25 = %25.Value\n  if (! (exists this[1])) {\n    let elements = (list [])[#643]\n  } else {\n    sdo-call %26 = this[1]->NonConstructorElements()\n    let elements = %26\n  }\n  let instancePrivateMethods = (list [])[#644]\n  let staticPrivateMethods = (list [])[#645]\n  let instanceFields = (list [])[#646]\n  let staticElements = (list [])[#647]\n  %28 = elements\n  %27 = 0\n  while (< %27 (sizeof %28)) {\n    let e = %28[%27]\n    if (? e: Ast[ClassElement]) {\n      sdo-call %29 = e->IsStatic()\n      if (= %29 false) {\n        sdo-call %30 = e->ClassElementEvaluation(proto)\n        call %31 = clo<\"Completion\">(%30)\n        let element = %31\n      } else {\n        sdo-call %32 = e->ClassElementEvaluation(F)\n        call %33 = clo<\"Completion\">(%32)\n        let element = %33\n      }\n      if (&& (? element: Completion) (! (= element.Type ~normal~))) {\n        @EXECUTION_STACK[0].LexicalEnvironment = env\n        @EXECUTION_STACK[0].PrivateEnvironment = outerPrivateEnvironment\n        assert (? element: Completion)\n        return element\n      }\n      assert (? element: Normal)\n      element = element.Value\n      element = element\n      if (? element: Record[PrivateElement]) {\n        assert (|| (= element.Kind ~method~) (= element.Kind ~accessor~))\n        sdo-call %34 = e->IsStatic()\n        if (= %34 false) {\n          let container = instancePrivateMethods\n        } else {\n          let container = staticPrivateMethods\n        }\n        %35 = container\n        %36 = 0\n        %37 = false\n        while (&& (! %37) (< %36 (sizeof %35))) {\n          let pe = %35[%36]\n          %37 = (&& (? pe: Record[PrivateElement]) (= pe.Key element.Key))\n          %36 = (+ %36 1)\n        }\n        if %37 {\n          assert (&& (= element.Kind ~accessor~) (= pe.Kind ~accessor~))\n          if (= element.Get undefined) {\n            let combined = (record [PrivateElement] {\n              \"Key\" : element.Key,\n              \"Kind\" : ~accessor~,\n              \"Get\" : pe.Get,\n              \"Set\" : element.Set,\n            })[#648]\n          } else {\n            let combined = (record [PrivateElement] {\n              \"Key\" : element.Key,\n              \"Kind\" : ~accessor~,\n              \"Get\" : element.Get,\n              \"Set\" : pe.Set,\n            })[#649]\n          }\n          (yet \"Replace _pe_ in _container_ with _combined_.\")\n        } else {\n          push container < element\n        }\n      } else {\n        if (? element: Record[ClassFieldDefinitionRecord]) {\n          sdo-call %38 = e->IsStatic()\n          if (= %38 false) {\n            push instanceFields < element\n          } else {\n            push staticElements < element\n          }\n        } else {\n          if (? element: Record[ClassStaticBlockDefinitionRecord]) {\n            push staticElements < element\n          }\n        }\n      }\n    }\n    %27 = (+ %27 1)\n  }\n  @EXECUTION_STACK[0].LexicalEnvironment = env\n  if (! (= classBinding undefined)) {\n    call %39 = classEnv.InitializeBinding(classEnv, classBinding, F)\n    assert (? %39: Normal)\n    %39 = %39.Value\n  }\n  F.PrivateMethods = instancePrivateMethods\n  F.Fields = instanceFields\n  %41 = staticPrivateMethods\n  %40 = 0\n  while (< %40 (sizeof %41)) {\n    let method = %41[%40]\n    if (? method: Record[PrivateElement]) {\n      call %42 = clo<\"PrivateMethodOrAccessorAdd\">(F, method)\n      assert (? %42: Normal)\n      %42 = %42.Value\n    }\n    %40 = (+ %40 1)\n  }\n  %44 = staticElements\n  %43 = 0\n  while (< %43 (sizeof %44)) {\n    let elementRecord = %44[%43]\n    if (? elementRecord: Record[ClassFieldDefinitionRecord]) {\n      call %45 = clo<\"DefineField\">(F, elementRecord)\n      call %46 = clo<\"Completion\">(%45)\n      let result = %46\n    } else {\n      assert (? elementRecord: Record[ClassStaticBlockDefinitionRecord])\n      call %47 = clo<\"Call\">(elementRecord.BodyFunction, F)\n      call %48 = clo<\"Completion\">(%47)\n      let result = %48\n    }\n    if (&& (? result: Completion) (! (= result.Type ~normal~))) {\n      @EXECUTION_STACK[0].PrivateEnvironment = outerPrivateEnvironment\n      assert (? result: Completion)\n      return result\n    }\n    %43 = (+ %43 1)\n  }\n  @EXECUTION_STACK[0].PrivateEnvironment = outerPrivateEnvironment\n  if (? F: Completion) return F\n  call %49 = clo<\"NormalCompletion\">(F)\n  return %49\n}","def <CLO>:ClassTail[0,3].ClassDefinitionEvaluation:clo0(\n  this: Unknown,\n  ArgumentsList: Unknown,\n  NewTarget: Unknown,\n): Unknown = {\n  let __args__ = (record)[#650]\n  let args = ArgumentsList\n  if (= NewTarget undefined) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  let F = @EXECUTION_STACK[0].Function\n  if (= F.ConstructorKind ~derived~) {\n    nop\n    call %2 = F.GetPrototypeOf(F)\n    assert (? %2: Normal)\n    %2 = %2.Value\n    let func = %2\n    call %3 = clo<\"IsConstructor\">(func)\n    if (= %3 false) {\n      call %4 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %5 = clo<\"ThrowCompletion\">(%4)\n      return %5\n    }\n    call %6 = clo<\"Construct\">(func, args, NewTarget)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    let result = %6\n  } else {\n    nop\n    call %7 = clo<\"OrdinaryCreateFromConstructor\">(NewTarget, \"%Object.prototype%\")\n    assert (? %7: Completion)\n    if (? %7: Abrupt) return %7\n    else %7 = %7.Value\n    let result = %7\n  }\n  call %8 = clo<\"InitializeInstanceElements\">(result, F)\n  assert (? %8: Completion)\n  if (? %8: Abrupt) return %8\n  else %8 = %8.Value\n  if (? result: Completion) return result\n  call %9 = clo<\"NormalCompletion\">(result)\n  return %9\n}","def <SYNTAX>:ClassTail[0,3].ClassDefinitionEvaluation(\n  this: Ast[ClassTail[0]],\n  classBinding: String | Undefined,\n  className: Record[PrivateName | Symbol] | String,\n): Normal[Record[FunctionObject]] | Abrupt = {\n  let env = @EXECUTION_STACK[0].LexicalEnvironment\n  call %0 = clo<\"NewDeclarativeEnvironment\">(env)\n  let classEnv = %0\n  if (! (= classBinding undefined)) {\n    call %1 = classEnv.CreateImmutableBinding(classEnv, classBinding, true)\n    assert (? %1: Normal)\n    %1 = %1.Value\n  }\n  let outerPrivateEnvironment = @EXECUTION_STACK[0].PrivateEnvironment\n  call %2 = clo<\"NewPrivateEnvironment\">(outerPrivateEnvironment)\n  let classPrivateEnvironment = %2\n  if (exists this[1]) {\n    sdo-call %5 = this[1]->PrivateBoundIdentifiers()\n    %4 = %5\n    %3 = 0\n    while (< %3 (sizeof %4)) {\n      let dn = %4[%3]\n      if (? dn: String) {\n        %6 = classPrivateEnvironment.Names\n        %7 = 0\n        %8 = false\n        while (&& (! %8) (< %7 (sizeof %6))) {\n          let pn = %6[%7]\n          %8 = (&& (? pn: Record[PrivateName]) (= pn.Description dn))\n          %7 = (+ %7 1)\n        }\n        if %8 {\n          assert (yet \"This is only possible for getter/setter pairs.\")\n        } else {\n          let name = (record [PrivateName] {\n            \"Description\" : dn,\n          })[#651]\n          push classPrivateEnvironment.Names < name\n        }\n      }\n      %3 = (+ %3 1)\n    }\n  }\n  if (! (exists this[0])) {\n    let protoParent = @EXECUTION_STACK[0].Realm.Intrinsics[\"%Object.prototype%\"]\n    let constructorParent = @EXECUTION_STACK[0].Realm.Intrinsics[\"%Function.prototype%\"]\n  } else {\n    @EXECUTION_STACK[0].LexicalEnvironment = classEnv\n    nop\n    sdo-call %9 = this[0]->Evaluation()\n    call %10 = clo<\"Completion\">(%9)\n    let superclassRef = %10\n    @EXECUTION_STACK[0].LexicalEnvironment = env\n    assert (? superclassRef: Completion)\n    if (? superclassRef: Abrupt) return superclassRef\n    else superclassRef = superclassRef.Value\n    call %11 = clo<\"GetValue\">(superclassRef)\n    assert (? %11: Completion)\n    if (? %11: Abrupt) return %11\n    else %11 = %11.Value\n    let superclass = %11\n    if (= superclass null) {\n      let protoParent = null\n      let constructorParent = @EXECUTION_STACK[0].Realm.Intrinsics[\"%Function.prototype%\"]\n    } else {\n      call %12 = clo<\"IsConstructor\">(superclass)\n      if (= %12 false) {\n        call %13 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n        call %14 = clo<\"ThrowCompletion\">(%13)\n        return %14\n      } else {\n        call %15 = clo<\"Get\">(superclass, \"prototype\")\n        assert (? %15: Completion)\n        if (? %15: Abrupt) return %15\n        else %15 = %15.Value\n        let protoParent = %15\n        if (&& (! (? protoParent: Record[Object])) (! (= protoParent null))) {\n          call %16 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n          call %17 = clo<\"ThrowCompletion\">(%16)\n          return %17\n        }\n        let constructorParent = superclass\n      }\n    }\n  }\n  call %18 = clo<\"OrdinaryObjectCreate\">(protoParent)\n  let proto = %18\n  if (! (exists this[1])) {\n    let constructor = ~empty~\n  } else {\n    sdo-call %19 = this[1]->ConstructorMethod()\n    let constructor = %19\n  }\n  @EXECUTION_STACK[0].LexicalEnvironment = classEnv\n  @EXECUTION_STACK[0].PrivateEnvironment = classPrivateEnvironment\n  if (= constructor ~empty~) {\n    let defaultConstructor = clo<\"ClassTail[0,3].ClassDefinitionEvaluation:clo0\">\n    call %20 = clo<\"CreateBuiltinFunction\">(defaultConstructor, 0, className, (list [\"ConstructorKind\", \"SourceText\"])[#652], @EXECUTION_STACK[0].Realm, constructorParent)\n    let F = %20\n  } else {\n    sdo-call %21 = constructor->DefineMethod(proto, constructorParent)\n    assert (? %21: Normal)\n    %21 = %21.Value\n    let constructorInfo = %21\n    let F = constructorInfo.Closure\n    call %22 = clo<\"MakeClassConstructor\">(F)\n    call %23 = clo<\"SetFunctionName\">(F, className)\n  }\n  call %24 = clo<\"MakeConstructor\">(F, false, proto)\n  if (exists this[0]) {\n    F.ConstructorKind = ~derived~\n  }\n  call %25 = clo<\"DefineMethodProperty\">(proto, \"constructor\", F, false)\n  assert (? %25: Normal)\n  %25 = %25.Value\n  if (! (exists this[1])) {\n    let elements = (list [])[#653]\n  } else {\n    sdo-call %26 = this[1]->NonConstructorElements()\n    let elements = %26\n  }\n  let instancePrivateMethods = (list [])[#654]\n  let staticPrivateMethods = (list [])[#655]\n  let instanceFields = (list [])[#656]\n  let staticElements = (list [])[#657]\n  %28 = elements\n  %27 = 0\n  while (< %27 (sizeof %28)) {\n    let e = %28[%27]\n    if (? e: Ast[ClassElement]) {\n      sdo-call %29 = e->IsStatic()\n      if (= %29 false) {\n        sdo-call %30 = e->ClassElementEvaluation(proto)\n        call %31 = clo<\"Completion\">(%30)\n        let element = %31\n      } else {\n        sdo-call %32 = e->ClassElementEvaluation(F)\n        call %33 = clo<\"Completion\">(%32)\n        let element = %33\n      }\n      if (&& (? element: Completion) (! (= element.Type ~normal~))) {\n        @EXECUTION_STACK[0].LexicalEnvironment = env\n        @EXECUTION_STACK[0].PrivateEnvironment = outerPrivateEnvironment\n        assert (? element: Completion)\n        return element\n      }\n      assert (? element: Normal)\n      element = element.Value\n      element = element\n      if (? element: Record[PrivateElement]) {\n        assert (|| (= element.Kind ~method~) (= element.Kind ~accessor~))\n        sdo-call %34 = e->IsStatic()\n        if (= %34 false) {\n          let container = instancePrivateMethods\n        } else {\n          let container = staticPrivateMethods\n        }\n        %35 = container\n        %36 = 0\n        %37 = false\n        while (&& (! %37) (< %36 (sizeof %35))) {\n          let pe = %35[%36]\n          %37 = (&& (? pe: Record[PrivateElement]) (= pe.Key element.Key))\n          %36 = (+ %36 1)\n        }\n        if %37 {\n          assert (&& (= element.Kind ~accessor~) (= pe.Kind ~accessor~))\n          if (= element.Get undefined) {\n            let combined = (record [PrivateElement] {\n              \"Key\" : element.Key,\n              \"Kind\" : ~accessor~,\n              \"Get\" : pe.Get,\n              \"Set\" : element.Set,\n            })[#658]\n          } else {\n            let combined = (record [PrivateElement] {\n              \"Key\" : element.Key,\n              \"Kind\" : ~accessor~,\n              \"Get\" : element.Get,\n              \"Set\" : pe.Set,\n            })[#659]\n          }\n          (yet \"Replace _pe_ in _container_ with _combined_.\")\n        } else {\n          push container < element\n        }\n      } else {\n        if (? element: Record[ClassFieldDefinitionRecord]) {\n          sdo-call %38 = e->IsStatic()\n          if (= %38 false) {\n            push instanceFields < element\n          } else {\n            push staticElements < element\n          }\n        } else {\n          if (? element: Record[ClassStaticBlockDefinitionRecord]) {\n            push staticElements < element\n          }\n        }\n      }\n    }\n    %27 = (+ %27 1)\n  }\n  @EXECUTION_STACK[0].LexicalEnvironment = env\n  if (! (= classBinding undefined)) {\n    call %39 = classEnv.InitializeBinding(classEnv, classBinding, F)\n    assert (? %39: Normal)\n    %39 = %39.Value\n  }\n  F.PrivateMethods = instancePrivateMethods\n  F.Fields = instanceFields\n  %41 = staticPrivateMethods\n  %40 = 0\n  while (< %40 (sizeof %41)) {\n    let method = %41[%40]\n    if (? method: Record[PrivateElement]) {\n      call %42 = clo<\"PrivateMethodOrAccessorAdd\">(F, method)\n      assert (? %42: Normal)\n      %42 = %42.Value\n    }\n    %40 = (+ %40 1)\n  }\n  %44 = staticElements\n  %43 = 0\n  while (< %43 (sizeof %44)) {\n    let elementRecord = %44[%43]\n    if (? elementRecord: Record[ClassFieldDefinitionRecord]) {\n      call %45 = clo<\"DefineField\">(F, elementRecord)\n      call %46 = clo<\"Completion\">(%45)\n      let result = %46\n    } else {\n      assert (? elementRecord: Record[ClassStaticBlockDefinitionRecord])\n      call %47 = clo<\"Call\">(elementRecord.BodyFunction, F)\n      call %48 = clo<\"Completion\">(%47)\n      let result = %48\n    }\n    if (&& (? result: Completion) (! (= result.Type ~normal~))) {\n      @EXECUTION_STACK[0].PrivateEnvironment = outerPrivateEnvironment\n      assert (? result: Completion)\n      return result\n    }\n    %43 = (+ %43 1)\n  }\n  @EXECUTION_STACK[0].PrivateEnvironment = outerPrivateEnvironment\n  if (? F: Completion) return F\n  call %49 = clo<\"NormalCompletion\">(F)\n  return %49\n}","def <SYNTAX>:ClassDeclaration[0,0].BindingClassDeclarationEvaluation(\n  this: Ast[ClassDeclaration[0]],\n): Normal[Record[FunctionObject]] | Abrupt = {\n  sdo-call %0 = this[0]->StringValue()\n  let className = %0\n  sdo-call %1 = this[1]->ClassDefinitionEvaluation(className, className)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let value = %1\n  value.SourceText = (source-text this)\n  let env = @EXECUTION_STACK[0].LexicalEnvironment\n  call %2 = clo<\"InitializeBoundName\">(className, value, env)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  if (? value: Completion) return value\n  call %3 = clo<\"NormalCompletion\">(value)\n  return %3\n}","def <SYNTAX>:ClassDeclaration[1,0].BindingClassDeclarationEvaluation(\n  this: Ast[ClassDeclaration[1]],\n): Normal[Record[FunctionObject]] | Abrupt = {\n  sdo-call %0 = this[0]->ClassDefinitionEvaluation(undefined, \"default\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let value = %0\n  value.SourceText = (source-text this)\n  if (? value: Completion) return value\n  call %1 = clo<\"NormalCompletion\">(value)\n  return %1\n}","def <SYNTAX>:ClassDeclaration[0,0].Evaluation(\n  this: Ast[ClassDeclaration[0]],\n): Unknown = {\n  sdo-call %0 = this->BindingClassDeclarationEvaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"NormalCompletion\">(~empty~)\n  return %1\n}","def <SYNTAX>:ClassExpression[0,0].Evaluation(\n  this: Ast[ClassExpression[0]],\n): Unknown = {\n  sdo-call %0 = this[1]->ClassDefinitionEvaluation(undefined, \"\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let value = %0\n  value.SourceText = (source-text this)\n  if (? value: Completion) return value\n  call %1 = clo<\"NormalCompletion\">(value)\n  return %1\n}","def <SYNTAX>:ClassExpression[0,1].Evaluation(\n  this: Ast[ClassExpression[0]],\n): Unknown = {\n  sdo-call %0 = this[0]->StringValue()\n  let className = %0\n  sdo-call %1 = this[1]->ClassDefinitionEvaluation(className, className)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let value = %1\n  value.SourceText = (source-text this)\n  if (? value: Completion) return value\n  call %2 = clo<\"NormalCompletion\">(value)\n  return %2\n}","def <SYNTAX>:ClassElementName[1,0].Evaluation(\n  this: Ast[ClassElementName[1]],\n): Unknown = {\n  sdo-call %0 = this[0]->StringValue()\n  let privateIdentifier = %0\n  let privateEnvRec = @EXECUTION_STACK[0].PrivateEnvironment\n  let names = privateEnvRec.Names\n  assert (yet \"Exactly one element of _names_ is a Private Name whose [[Description]] is _privateIdentifier_.\")\n  let idx = 0\n  while (< idx (sizeof names)) {\n    let elem = names[idx]\n    if (= elem.Description privateIdentifier) let privateName = elem\n    idx = (+ idx 1)\n  }\n  if (? privateName: Completion) return privateName\n  call %1 = clo<\"NormalCompletion\">(privateName)\n  return %1\n}","def <SYNTAX>:ClassStaticBlockStatementList[0,0].Evaluation(\n  this: Ast[ClassStaticBlockStatementList[0]],\n): Unknown = {\n  call %0 = clo<\"NormalCompletion\">(undefined)\n  return %0\n}","def <SYNTAX>:AsyncFunctionDeclaration[0,0].InstantiateAsyncFunctionObject(\n  this: Ast[AsyncFunctionDeclaration[0]],\n  env: Record[EnvironmentRecord],\n  privateEnv: Record[PrivateEnvironmentRecord] | Null,\n): Record[ECMAScriptFunctionObject] = {\n  sdo-call %0 = this[0]->StringValue()\n  let name = %0\n  let sourceText = (source-text this)\n  call %1 = clo<\"OrdinaryFunctionCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%AsyncFunction.prototype%\"], sourceText, this[1], this[2], ~non-lexical-this~, env, privateEnv)\n  let F = %1\n  call %2 = clo<\"SetFunctionName\">(F, name)\n  return F\n}","def <SYNTAX>:AsyncFunctionDeclaration[1,0].InstantiateAsyncFunctionObject(\n  this: Ast[AsyncFunctionDeclaration[1]],\n  env: Record[EnvironmentRecord],\n  privateEnv: Record[PrivateEnvironmentRecord] | Null,\n): Record[ECMAScriptFunctionObject] = {\n  let sourceText = (source-text this)\n  call %0 = clo<\"OrdinaryFunctionCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%AsyncFunction.prototype%\"], sourceText, this[0], this[1], ~non-lexical-this~, env, privateEnv)\n  let F = %0\n  call %1 = clo<\"SetFunctionName\">(F, \"default\")\n  return F\n}","def <SYNTAX>:AsyncFunctionExpression[0,0].InstantiateAsyncFunctionExpression(\n  this: Ast[AsyncFunctionExpression[0]],\n  name?: Record[PrivateName | Symbol] | String,\n): Record[ECMAScriptFunctionObject] = {\n  if (! (exists name)) {\n    name = \"\"\n  }\n  let env = @EXECUTION_STACK[0].LexicalEnvironment\n  let privateEnv = @EXECUTION_STACK[0].PrivateEnvironment\n  let sourceText = (source-text this)\n  call %0 = clo<\"OrdinaryFunctionCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%AsyncFunction.prototype%\"], sourceText, this[1], this[2], ~non-lexical-this~, env, privateEnv)\n  let closure = %0\n  call %1 = clo<\"SetFunctionName\">(closure, name)\n  return closure\n}","def <SYNTAX>:AsyncFunctionExpression[0,1].InstantiateAsyncFunctionExpression(\n  this: Ast[AsyncFunctionExpression[0]],\n  name?: Record[PrivateName | Symbol] | String,\n): Record[ECMAScriptFunctionObject] = {\n  assert (! (exists name))\n  sdo-call %0 = this[0]->StringValue()\n  name = %0\n  let outerEnv = @EXECUTION_STACK[0].LexicalEnvironment\n  call %1 = clo<\"NewDeclarativeEnvironment\">(outerEnv)\n  let funcEnv = %1\n  call %2 = funcEnv.CreateImmutableBinding(funcEnv, name, false)\n  assert (? %2: Normal)\n  %2 = %2.Value\n  let privateEnv = @EXECUTION_STACK[0].PrivateEnvironment\n  let sourceText = (source-text this)\n  call %3 = clo<\"OrdinaryFunctionCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%AsyncFunction.prototype%\"], sourceText, this[1], this[2], ~non-lexical-this~, funcEnv, privateEnv)\n  let closure = %3\n  call %4 = clo<\"SetFunctionName\">(closure, name)\n  call %5 = funcEnv.InitializeBinding(funcEnv, name, closure)\n  assert (? %5: Normal)\n  %5 = %5.Value\n  return closure\n}","def <SYNTAX>:AsyncFunctionBody[0,0].EvaluateAsyncFunctionBody(\n  this: Ast[AsyncFunctionBody[0]],\n  functionObject: Record[ECMAScriptFunctionObject],\n  argumentsList: List[ESValue],\n): Return = {\n  call %0 = clo<\"NewPromiseCapability\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Promise%\"])\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let promiseCapability = %0\n  call %1 = clo<\"FunctionDeclarationInstantiation\">(functionObject, argumentsList)\n  call %2 = clo<\"Completion\">(%1)\n  let declResult = %2\n  if (&& (? declResult: Completion) (! (= declResult.Type ~normal~))) {\n    call %3 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [declResult.Value])[#660])\n    assert (? %3: Normal)\n    %3 = %3.Value\n  } else {\n    call %4 = clo<\"AsyncFunctionStart\">(promiseCapability, this[0])\n  }\n  %5 = (record [CompletionRecord] {\n    \"Type\" : ~return~,\n    \"Value\" : promiseCapability.Promise,\n    \"Target\" : ~empty~,\n  })[#661]\n  if (? %5: Completion) return %5\n  call %6 = clo<\"NormalCompletion\">(%5)\n  return %6\n}","def <SYNTAX>:AsyncFunctionExpression[0,0].Evaluation(\n  this: Ast[AsyncFunctionExpression[0]],\n): Unknown = {\n  sdo-call %0 = this->InstantiateAsyncFunctionExpression()\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:AsyncFunctionExpression[0,1].Evaluation(\n  this: Ast[AsyncFunctionExpression[0]],\n): Unknown = {\n  sdo-call %0 = this->InstantiateAsyncFunctionExpression()\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:AwaitExpression[0,0].Evaluation(\n  this: Ast[AwaitExpression[0]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let exprRef = %0\n  call %1 = clo<\"GetValue\">(exprRef)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let value = %1\n  call %2 = clo<\"Await\">(value)\n  assert (? %2: Completion)\n  return %2\n}","def <SYNTAX>:AsyncConciseBody[0,0].AsyncConciseBodyContainsUseStrict(\n  this: Ast[AsyncConciseBody[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AsyncConciseBody[1,0].AsyncConciseBodyContainsUseStrict(\n  this: Ast[AsyncConciseBody[1]],\n): Boolean = {\n  (yet \"Return FunctionBodyContainsUseStrict of |AsyncFunctionBody|.\")\n}","def <SYNTAX>:AsyncConciseBody[0,0].EvaluateAsyncConciseBody(\n  this: Ast[AsyncConciseBody[0]],\n  functionObject: Record[ECMAScriptFunctionObject],\n  argumentsList: List[ESValue],\n): Return = {\n  call %0 = clo<\"NewPromiseCapability\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Promise%\"])\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let promiseCapability = %0\n  call %1 = clo<\"FunctionDeclarationInstantiation\">(functionObject, argumentsList)\n  call %2 = clo<\"Completion\">(%1)\n  let declResult = %2\n  if (&& (? declResult: Completion) (! (= declResult.Type ~normal~))) {\n    call %3 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [declResult.Value])[#662])\n    assert (? %3: Normal)\n    %3 = %3.Value\n  } else {\n    call %4 = clo<\"AsyncFunctionStart\">(promiseCapability, this[0])\n  }\n  %5 = (record [CompletionRecord] {\n    \"Type\" : ~return~,\n    \"Value\" : promiseCapability.Promise,\n    \"Target\" : ~empty~,\n  })[#663]\n  if (? %5: Completion) return %5\n  call %6 = clo<\"NormalCompletion\">(%5)\n  return %6\n}","def <SYNTAX>:AsyncArrowFunction[0,0].InstantiateAsyncArrowFunctionExpression(\n  this: Ast[AsyncArrowFunction[0]],\n  name?: Record[PrivateName | Symbol] | String,\n): Record[ECMAScriptFunctionObject] = {\n  if (! (exists name)) {\n    name = \"\"\n  }\n  let env = @EXECUTION_STACK[0].LexicalEnvironment\n  let privateEnv = @EXECUTION_STACK[0].PrivateEnvironment\n  let sourceText = (source-text this)\n  let parameters = this[0]\n  call %0 = clo<\"OrdinaryFunctionCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%AsyncFunction.prototype%\"], sourceText, parameters, this[1], ~lexical-this~, env, privateEnv)\n  let closure = %0\n  call %1 = clo<\"SetFunctionName\">(closure, name)\n  return closure\n}","def <SYNTAX>:AsyncArrowFunction[1,0].InstantiateAsyncArrowFunctionExpression(\n  this: Ast[AsyncArrowFunction[1]],\n  name?: Record[PrivateName | Symbol] | String,\n): Record[ECMAScriptFunctionObject] = {\n  if (! (exists name)) {\n    name = \"\"\n  }\n  let env = @EXECUTION_STACK[0].LexicalEnvironment\n  let privateEnv = @EXECUTION_STACK[0].PrivateEnvironment\n  let sourceText = (source-text this)\n  let head = (parse this[0] (grammar-symbol |AsyncArrowHead|))\n  let parameters = head.ArrowFormalParameters\n  call %0 = clo<\"OrdinaryFunctionCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%AsyncFunction.prototype%\"], sourceText, parameters, this[1], ~lexical-this~, env, privateEnv)\n  let closure = %0\n  call %1 = clo<\"SetFunctionName\">(closure, name)\n  return closure\n}","def <SYNTAX>:AsyncArrowFunction[0,0].Evaluation(\n  this: Ast[AsyncArrowFunction[0]],\n): Unknown = {\n  sdo-call %0 = this->InstantiateAsyncArrowFunctionExpression()\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:AsyncArrowFunction[1,0].Evaluation(\n  this: Ast[AsyncArrowFunction[1]],\n): Unknown = {\n  sdo-call %0 = this->InstantiateAsyncArrowFunctionExpression()\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:StatementList[1,0].HasCallInTailPosition(\n  this: Ast[StatementList[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[0]->HasCallInTailPosition(call)\n  let has = %0\n  if (= has true) {\n    return true\n  }\n  sdo-call %1 = this[1]->HasCallInTailPosition(call)\n  return %1\n}","def <SYNTAX>:FunctionStatementList[0,0].HasCallInTailPosition(\n  this: Ast[FunctionStatementList[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:StatementListItem[1,0].HasCallInTailPosition(\n  this: Ast[StatementListItem[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Statement[1,0].HasCallInTailPosition(\n  this: Ast[Statement[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Statement[2,0].HasCallInTailPosition(\n  this: Ast[Statement[2]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Statement[3,0].HasCallInTailPosition(\n  this: Ast[Statement[3]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Statement[6,0].HasCallInTailPosition(\n  this: Ast[Statement[6]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Statement[7,0].HasCallInTailPosition(\n  this: Ast[Statement[7]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Statement[11,0].HasCallInTailPosition(\n  this: Ast[Statement[11]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Statement[13,0].HasCallInTailPosition(\n  this: Ast[Statement[13]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Block[0,0].HasCallInTailPosition(\n  this: Ast[Block[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ReturnStatement[0,0].HasCallInTailPosition(\n  this: Ast[ReturnStatement[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:LabelledItem[1,0].HasCallInTailPosition(\n  this: Ast[LabelledItem[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ForInOfStatement[3,0].HasCallInTailPosition(\n  this: Ast[ForInOfStatement[3]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ForInOfStatement[4,0].HasCallInTailPosition(\n  this: Ast[ForInOfStatement[4]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ForInOfStatement[5,0].HasCallInTailPosition(\n  this: Ast[ForInOfStatement[5]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:CaseBlock[0,0].HasCallInTailPosition(\n  this: Ast[CaseBlock[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:IfStatement[0,0].HasCallInTailPosition(\n  this: Ast[IfStatement[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[1]->HasCallInTailPosition(call)\n  let has = %0\n  if (= has true) {\n    return true\n  }\n  sdo-call %1 = this[2]->HasCallInTailPosition(call)\n  return %1\n}","def <SYNTAX>:IfStatement[1,0].HasCallInTailPosition(\n  this: Ast[IfStatement[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[1]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:DoWhileStatement[0,0].HasCallInTailPosition(\n  this: Ast[DoWhileStatement[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[0]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:WhileStatement[0,0].HasCallInTailPosition(\n  this: Ast[WhileStatement[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[1]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:ForStatement[0,0].HasCallInTailPosition(\n  this: Ast[ForStatement[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[3]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:ForStatement[0,1].HasCallInTailPosition(\n  this: Ast[ForStatement[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[3]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:ForStatement[0,2].HasCallInTailPosition(\n  this: Ast[ForStatement[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[3]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:ForStatement[0,3].HasCallInTailPosition(\n  this: Ast[ForStatement[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[3]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:ForStatement[0,4].HasCallInTailPosition(\n  this: Ast[ForStatement[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[3]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:ForStatement[0,5].HasCallInTailPosition(\n  this: Ast[ForStatement[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[3]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:ForStatement[0,6].HasCallInTailPosition(\n  this: Ast[ForStatement[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[3]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:ForStatement[0,7].HasCallInTailPosition(\n  this: Ast[ForStatement[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[3]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:ForStatement[1,0].HasCallInTailPosition(\n  this: Ast[ForStatement[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[3]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:ForStatement[1,1].HasCallInTailPosition(\n  this: Ast[ForStatement[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[3]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:ForStatement[1,2].HasCallInTailPosition(\n  this: Ast[ForStatement[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[3]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:ForStatement[1,3].HasCallInTailPosition(\n  this: Ast[ForStatement[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[3]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:ForStatement[2,0].HasCallInTailPosition(\n  this: Ast[ForStatement[2]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[3]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:ForStatement[2,1].HasCallInTailPosition(\n  this: Ast[ForStatement[2]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[3]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:ForStatement[2,2].HasCallInTailPosition(\n  this: Ast[ForStatement[2]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[3]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:ForStatement[2,3].HasCallInTailPosition(\n  this: Ast[ForStatement[2]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[3]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:ForInOfStatement[0,0].HasCallInTailPosition(\n  this: Ast[ForInOfStatement[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[2]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:ForInOfStatement[1,0].HasCallInTailPosition(\n  this: Ast[ForInOfStatement[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[2]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:ForInOfStatement[2,0].HasCallInTailPosition(\n  this: Ast[ForInOfStatement[2]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[2]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:WithStatement[0,0].HasCallInTailPosition(\n  this: Ast[WithStatement[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[1]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:LabelledStatement[0,0].HasCallInTailPosition(\n  this: Ast[LabelledStatement[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[1]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:ReturnStatement[1,0].HasCallInTailPosition(\n  this: Ast[ReturnStatement[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[0]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:SwitchStatement[0,0].HasCallInTailPosition(\n  this: Ast[SwitchStatement[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[1]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:CaseBlock[1,0].HasCallInTailPosition(\n  this: Ast[CaseBlock[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  let has = false\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->HasCallInTailPosition(call)\n    has = %0\n  }\n  if (= has true) {\n    return true\n  }\n  sdo-call %1 = this[1]->HasCallInTailPosition(call)\n  has = %1\n  if (= has true) {\n    return true\n  }\n  if (exists this[2]) {\n    sdo-call %2 = this[2]->HasCallInTailPosition(call)\n    has = %2\n  }\n  return has\n}","def <SYNTAX>:CaseBlock[1,1].HasCallInTailPosition(\n  this: Ast[CaseBlock[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  let has = false\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->HasCallInTailPosition(call)\n    has = %0\n  }\n  if (= has true) {\n    return true\n  }\n  sdo-call %1 = this[1]->HasCallInTailPosition(call)\n  has = %1\n  if (= has true) {\n    return true\n  }\n  if (exists this[2]) {\n    sdo-call %2 = this[2]->HasCallInTailPosition(call)\n    has = %2\n  }\n  return has\n}","def <SYNTAX>:CaseBlock[1,2].HasCallInTailPosition(\n  this: Ast[CaseBlock[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  let has = false\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->HasCallInTailPosition(call)\n    has = %0\n  }\n  if (= has true) {\n    return true\n  }\n  sdo-call %1 = this[1]->HasCallInTailPosition(call)\n  has = %1\n  if (= has true) {\n    return true\n  }\n  if (exists this[2]) {\n    sdo-call %2 = this[2]->HasCallInTailPosition(call)\n    has = %2\n  }\n  return has\n}","def <SYNTAX>:CaseBlock[1,3].HasCallInTailPosition(\n  this: Ast[CaseBlock[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  let has = false\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->HasCallInTailPosition(call)\n    has = %0\n  }\n  if (= has true) {\n    return true\n  }\n  sdo-call %1 = this[1]->HasCallInTailPosition(call)\n  has = %1\n  if (= has true) {\n    return true\n  }\n  if (exists this[2]) {\n    sdo-call %2 = this[2]->HasCallInTailPosition(call)\n    has = %2\n  }\n  return has\n}","def <SYNTAX>:CaseClauses[1,0].HasCallInTailPosition(\n  this: Ast[CaseClauses[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[0]->HasCallInTailPosition(call)\n  let has = %0\n  if (= has true) {\n    return true\n  }\n  sdo-call %1 = this[1]->HasCallInTailPosition(call)\n  return %1\n}","def <SYNTAX>:CaseClause[0,0].HasCallInTailPosition(\n  this: Ast[CaseClause[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  if (exists this[1]) {\n    sdo-call %0 = this[1]->HasCallInTailPosition(call)\n    return %0\n  }\n  return false\n}","def <SYNTAX>:CaseClause[0,1].HasCallInTailPosition(\n  this: Ast[CaseClause[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  if (exists this[1]) {\n    sdo-call %0 = this[1]->HasCallInTailPosition(call)\n    return %0\n  }\n  return false\n}","def <SYNTAX>:DefaultClause[0,0].HasCallInTailPosition(\n  this: Ast[DefaultClause[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->HasCallInTailPosition(call)\n    return %0\n  }\n  return false\n}","def <SYNTAX>:DefaultClause[0,1].HasCallInTailPosition(\n  this: Ast[DefaultClause[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  if (exists this[0]) {\n    sdo-call %0 = this[0]->HasCallInTailPosition(call)\n    return %0\n  }\n  return false\n}","def <SYNTAX>:TryStatement[0,0].HasCallInTailPosition(\n  this: Ast[TryStatement[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[1]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:TryStatement[1,0].HasCallInTailPosition(\n  this: Ast[TryStatement[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[1]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:TryStatement[2,0].HasCallInTailPosition(\n  this: Ast[TryStatement[2]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[2]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:Catch[0,0].HasCallInTailPosition(\n  this: Ast[Catch[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[1]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:AssignmentExpression[1,0].HasCallInTailPosition(\n  this: Ast[AssignmentExpression[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AssignmentExpression[2,0].HasCallInTailPosition(\n  this: Ast[AssignmentExpression[2]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AssignmentExpression[3,0].HasCallInTailPosition(\n  this: Ast[AssignmentExpression[3]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AssignmentExpression[4,0].HasCallInTailPosition(\n  this: Ast[AssignmentExpression[4]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AssignmentExpression[5,0].HasCallInTailPosition(\n  this: Ast[AssignmentExpression[5]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AssignmentExpression[6,0].HasCallInTailPosition(\n  this: Ast[AssignmentExpression[6]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AssignmentExpression[7,0].HasCallInTailPosition(\n  this: Ast[AssignmentExpression[7]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AssignmentExpression[8,0].HasCallInTailPosition(\n  this: Ast[AssignmentExpression[8]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:BitwiseANDExpression[1,0].HasCallInTailPosition(\n  this: Ast[BitwiseANDExpression[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:BitwiseXORExpression[1,0].HasCallInTailPosition(\n  this: Ast[BitwiseXORExpression[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:BitwiseORExpression[1,0].HasCallInTailPosition(\n  this: Ast[BitwiseORExpression[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:EqualityExpression[1,0].HasCallInTailPosition(\n  this: Ast[EqualityExpression[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:EqualityExpression[2,0].HasCallInTailPosition(\n  this: Ast[EqualityExpression[2]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:EqualityExpression[3,0].HasCallInTailPosition(\n  this: Ast[EqualityExpression[3]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:EqualityExpression[4,0].HasCallInTailPosition(\n  this: Ast[EqualityExpression[4]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:RelationalExpression[1,0].HasCallInTailPosition(\n  this: Ast[RelationalExpression[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:RelationalExpression[2,0].HasCallInTailPosition(\n  this: Ast[RelationalExpression[2]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:RelationalExpression[3,0].HasCallInTailPosition(\n  this: Ast[RelationalExpression[3]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:RelationalExpression[4,0].HasCallInTailPosition(\n  this: Ast[RelationalExpression[4]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:RelationalExpression[5,0].HasCallInTailPosition(\n  this: Ast[RelationalExpression[5]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:RelationalExpression[6,0].HasCallInTailPosition(\n  this: Ast[RelationalExpression[6]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:RelationalExpression[7,0].HasCallInTailPosition(\n  this: Ast[RelationalExpression[7]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ShiftExpression[1,0].HasCallInTailPosition(\n  this: Ast[ShiftExpression[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ShiftExpression[2,0].HasCallInTailPosition(\n  this: Ast[ShiftExpression[2]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ShiftExpression[3,0].HasCallInTailPosition(\n  this: Ast[ShiftExpression[3]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AdditiveExpression[1,0].HasCallInTailPosition(\n  this: Ast[AdditiveExpression[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:AdditiveExpression[2,0].HasCallInTailPosition(\n  this: Ast[AdditiveExpression[2]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MultiplicativeExpression[1,0].HasCallInTailPosition(\n  this: Ast[MultiplicativeExpression[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ExponentiationExpression[1,0].HasCallInTailPosition(\n  this: Ast[ExponentiationExpression[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:UpdateExpression[1,0].HasCallInTailPosition(\n  this: Ast[UpdateExpression[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:UpdateExpression[2,0].HasCallInTailPosition(\n  this: Ast[UpdateExpression[2]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:UpdateExpression[3,0].HasCallInTailPosition(\n  this: Ast[UpdateExpression[3]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:UpdateExpression[4,0].HasCallInTailPosition(\n  this: Ast[UpdateExpression[4]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:UnaryExpression[1,0].HasCallInTailPosition(\n  this: Ast[UnaryExpression[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:UnaryExpression[2,0].HasCallInTailPosition(\n  this: Ast[UnaryExpression[2]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:UnaryExpression[3,0].HasCallInTailPosition(\n  this: Ast[UnaryExpression[3]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:UnaryExpression[4,0].HasCallInTailPosition(\n  this: Ast[UnaryExpression[4]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:UnaryExpression[5,0].HasCallInTailPosition(\n  this: Ast[UnaryExpression[5]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:UnaryExpression[6,0].HasCallInTailPosition(\n  this: Ast[UnaryExpression[6]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:UnaryExpression[7,0].HasCallInTailPosition(\n  this: Ast[UnaryExpression[7]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:UnaryExpression[8,0].HasCallInTailPosition(\n  this: Ast[UnaryExpression[8]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:CallExpression[1,0].HasCallInTailPosition(\n  this: Ast[CallExpression[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:CallExpression[2,0].HasCallInTailPosition(\n  this: Ast[CallExpression[2]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:CallExpression[4,0].HasCallInTailPosition(\n  this: Ast[CallExpression[4]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:CallExpression[5,0].HasCallInTailPosition(\n  this: Ast[CallExpression[5]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:CallExpression[7,0].HasCallInTailPosition(\n  this: Ast[CallExpression[7]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:NewExpression[1,0].HasCallInTailPosition(\n  this: Ast[NewExpression[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MemberExpression[1,0].HasCallInTailPosition(\n  this: Ast[MemberExpression[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MemberExpression[2,0].HasCallInTailPosition(\n  this: Ast[MemberExpression[2]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MemberExpression[4,0].HasCallInTailPosition(\n  this: Ast[MemberExpression[4]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MemberExpression[5,0].HasCallInTailPosition(\n  this: Ast[MemberExpression[5]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MemberExpression[6,0].HasCallInTailPosition(\n  this: Ast[MemberExpression[6]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:MemberExpression[7,0].HasCallInTailPosition(\n  this: Ast[MemberExpression[7]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[0,0].HasCallInTailPosition(\n  this: Ast[PrimaryExpression[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[1,0].HasCallInTailPosition(\n  this: Ast[PrimaryExpression[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[2,0].HasCallInTailPosition(\n  this: Ast[PrimaryExpression[2]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[3,0].HasCallInTailPosition(\n  this: Ast[PrimaryExpression[3]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[4,0].HasCallInTailPosition(\n  this: Ast[PrimaryExpression[4]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[5,0].HasCallInTailPosition(\n  this: Ast[PrimaryExpression[5]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[6,0].HasCallInTailPosition(\n  this: Ast[PrimaryExpression[6]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[7,0].HasCallInTailPosition(\n  this: Ast[PrimaryExpression[7]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[8,0].HasCallInTailPosition(\n  this: Ast[PrimaryExpression[8]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[9,0].HasCallInTailPosition(\n  this: Ast[PrimaryExpression[9]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[10,0].HasCallInTailPosition(\n  this: Ast[PrimaryExpression[10]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:PrimaryExpression[11,0].HasCallInTailPosition(\n  this: Ast[PrimaryExpression[11]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:Expression[0,0].HasCallInTailPosition(\n  this: Ast[Expression[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[0]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:Expression[1,0].HasCallInTailPosition(\n  this: Ast[Expression[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[1]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:ConditionalExpression[1,0].HasCallInTailPosition(\n  this: Ast[ConditionalExpression[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[1]->HasCallInTailPosition(call)\n  let has = %0\n  if (= has true) {\n    return true\n  }\n  sdo-call %1 = this[2]->HasCallInTailPosition(call)\n  return %1\n}","def <SYNTAX>:LogicalANDExpression[1,0].HasCallInTailPosition(\n  this: Ast[LogicalANDExpression[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[1]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:LogicalORExpression[1,0].HasCallInTailPosition(\n  this: Ast[LogicalORExpression[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[1]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:CoalesceExpression[0,0].HasCallInTailPosition(\n  this: Ast[CoalesceExpression[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[1]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:CallExpression[0,0].HasCallInTailPosition(\n  this: Ast[CallExpression[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  if (= this call) {\n    return true\n  }\n  return false\n}","def <SYNTAX>:CallExpression[3,0].HasCallInTailPosition(\n  this: Ast[CallExpression[3]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  if (= this call) {\n    return true\n  }\n  return false\n}","def <SYNTAX>:CallExpression[6,0].HasCallInTailPosition(\n  this: Ast[CallExpression[6]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  if (= this call) {\n    return true\n  }\n  return false\n}","def <SYNTAX>:OptionalExpression[0,0].HasCallInTailPosition(\n  this: Ast[OptionalExpression[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[1]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:OptionalExpression[1,0].HasCallInTailPosition(\n  this: Ast[OptionalExpression[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[1]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:OptionalExpression[2,0].HasCallInTailPosition(\n  this: Ast[OptionalExpression[2]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[1]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:OptionalChain[1,0].HasCallInTailPosition(\n  this: Ast[OptionalChain[1]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:OptionalChain[2,0].HasCallInTailPosition(\n  this: Ast[OptionalChain[2]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:OptionalChain[4,0].HasCallInTailPosition(\n  this: Ast[OptionalChain[4]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:OptionalChain[6,0].HasCallInTailPosition(\n  this: Ast[OptionalChain[6]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:OptionalChain[7,0].HasCallInTailPosition(\n  this: Ast[OptionalChain[7]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:OptionalChain[9,0].HasCallInTailPosition(\n  this: Ast[OptionalChain[9]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  return false\n}","def <SYNTAX>:OptionalChain[0,0].HasCallInTailPosition(\n  this: Ast[OptionalChain[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  if (= this call) {\n    return true\n  }\n  return false\n}","def <SYNTAX>:OptionalChain[5,0].HasCallInTailPosition(\n  this: Ast[OptionalChain[5]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  if (= this call) {\n    return true\n  }\n  return false\n}","def <SYNTAX>:MemberExpression[3,0].HasCallInTailPosition(\n  this: Ast[MemberExpression[3]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  if (= this call) {\n    return true\n  }\n  return false\n}","def <SYNTAX>:PrimaryExpression[12,0].HasCallInTailPosition(\n  this: Ast[PrimaryExpression[12]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  let expr = (parse this[0] (grammar-symbol |ParenthesizedExpression|))\n  sdo-call %0 = expr->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:ParenthesizedExpression[0,0].HasCallInTailPosition(\n  this: Ast[ParenthesizedExpression[0]],\n  call: Unknown[\"CallExpressionParseNode,AMemberExpressionParseNode,OrAnOptionalChainParseNode\"],\n): Boolean = {\n  sdo-call %0 = this[0]->HasCallInTailPosition(call)\n  return %0\n}","def <SYNTAX>:Script[0,0].IsStrict(\n  this: Ast[Script[0]],\n): Boolean = {\n  if (&& (exists this[0]) true) {\n    return true\n  } else {\n    return false\n  }\n}","def <SYNTAX>:Script[0,1].IsStrict(\n  this: Ast[Script[0]],\n): Boolean = {\n  if (&& (exists this[0]) true) {\n    return true\n  } else {\n    return false\n  }\n}","def <SYNTAX>:Script[0,0].Evaluation(\n  this: Ast[Script[0]],\n): Unknown = {\n  call %0 = clo<\"NormalCompletion\">(undefined)\n  return %0\n}","def ParseScript(\n  sourceText: Unknown[\"ECMAScriptSourceText\"],\n  realm: Record[RealmRecord] | Undefined,\n  hostDefined: Unknown[\"Anything\"],\n): Unknown[\"ScriptRecordOrANonemptyListOf*SyntaxError*Object\"] = {\n  let script = (parse sourceText (grammar-symbol |Script|))\n  if (? script: List[Record[Error]]) {\n    return script\n  }\n  return (record [ScriptRecord] {\n    \"Realm\" : realm,\n    \"ECMAScriptCode\" : script,\n    \"LoadedModules\" : (list [])[#665],\n    \"HostDefined\" : hostDefined,\n  })[#664]\n}","def ScriptEvaluation(\n  scriptRecord: Record[ScriptRecord],\n): Normal[ESValue] | Abrupt = {\n  let globalEnv = scriptRecord.Realm.GlobalEnv\n  let scriptContext = (record [ExecutionContext])[#666]\n  scriptContext.Function = null\n  scriptContext.Realm = scriptRecord.Realm\n  scriptContext.ScriptOrModule = scriptRecord\n  scriptContext.VariableEnvironment = globalEnv\n  scriptContext.LexicalEnvironment = globalEnv\n  scriptContext.PrivateEnvironment = null\n  nop\n  push scriptContext > @EXECUTION_STACK\n  let script = scriptRecord.ECMAScriptCode\n  call %0 = clo<\"GlobalDeclarationInstantiation\">(script, globalEnv)\n  call %1 = clo<\"Completion\">(%0)\n  let result = %1\n  if (&& (? result: Completion) (= result.Type ~normal~)) {\n    sdo-call %2 = script->Evaluation()\n    call %3 = clo<\"Completion\">(%2)\n    result = %3\n    if (&& (&& (? result: Completion) (= result.Type ~normal~)) (= result.Value ~empty~)) {\n      call %4 = clo<\"NormalCompletion\">(undefined)\n      result = %4\n    }\n  }\n  pop %5 < @EXECUTION_STACK\n  assert (! (= (sizeof @EXECUTION_STACK) 0))\n  nop\n  assert (? result: Completion)\n  return result\n}","def GlobalDeclarationInstantiation(\n  script: Unknown[\"ScriptParseNode\"],\n  env: Record[GlobalEnvironmentRecord],\n): Normal[Enum[~unused~]] | Throw = {\n  sdo-call %0 = script->LexicallyDeclaredNames()\n  let lexNames = %0\n  sdo-call %1 = script->VarDeclaredNames()\n  let varNames = %1\n  %3 = lexNames\n  %2 = 0\n  while (< %2 (sizeof %3)) {\n    let name = %3[%2]\n    call %4 = env.HasVarDeclaration(env, name)\n    if (= %4 true) {\n      call %5 = clo<\"__NEW_ERROR_OBJ__\">(\"%SyntaxError.prototype%\")\n      call %6 = clo<\"ThrowCompletion\">(%5)\n      return %6\n    }\n    call %7 = env.HasLexicalDeclaration(env, name)\n    if (= %7 true) {\n      call %8 = clo<\"__NEW_ERROR_OBJ__\">(\"%SyntaxError.prototype%\")\n      call %9 = clo<\"ThrowCompletion\">(%8)\n      return %9\n    }\n    call %10 = env.HasRestrictedGlobalProperty(env, name)\n    assert (? %10: Completion)\n    if (? %10: Abrupt) return %10\n    else %10 = %10.Value\n    let hasRestrictedGlobal = %10\n    if (= hasRestrictedGlobal true) {\n      call %11 = clo<\"__NEW_ERROR_OBJ__\">(\"%SyntaxError.prototype%\")\n      call %12 = clo<\"ThrowCompletion\">(%11)\n      return %12\n    }\n    %2 = (+ %2 1)\n  }\n  %14 = varNames\n  %13 = 0\n  while (< %13 (sizeof %14)) {\n    let name = %14[%13]\n    call %15 = env.HasLexicalDeclaration(env, name)\n    if (= %15 true) {\n      call %16 = clo<\"__NEW_ERROR_OBJ__\">(\"%SyntaxError.prototype%\")\n      call %17 = clo<\"ThrowCompletion\">(%16)\n      return %17\n    }\n    %13 = (+ %13 1)\n  }\n  sdo-call %18 = script->VarScopedDeclarations()\n  let varDeclarations = %18\n  let functionsToInitialize = (list [])[#667]\n  let declaredFunctionNames = (list [])[#668]\n  %20 = varDeclarations\n  %19 = (sizeof %20)\n  while (< 0 %19) {\n    %19 = (- %19 1)\n    let d = %20[%19]\n    if (! (? d: Ast[BindingIdentifier | ForBinding | VariableDeclaration])) {\n      assert (? d: Ast[AsyncFunctionDeclaration | AsyncGeneratorDeclaration | FunctionDeclaration | GeneratorDeclaration])\n      nop\n      sdo-call %21 = d->BoundNames()\n      let fn = %21[0]\n      if (! (contains declaredFunctionNames fn)) {\n        call %22 = env.CanDeclareGlobalFunction(env, fn)\n        assert (? %22: Completion)\n        if (? %22: Abrupt) return %22\n        else %22 = %22.Value\n        let fnDefinable = %22\n        if (= fnDefinable false) {\n          call %23 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n          call %24 = clo<\"ThrowCompletion\">(%23)\n          return %24\n        }\n        push declaredFunctionNames < fn\n        push d > functionsToInitialize\n      }\n    }\n  }\n  let declaredVarNames = (list [])[#669]\n  %26 = varDeclarations\n  %25 = 0\n  while (< %25 (sizeof %26)) {\n    let d = %26[%25]\n    if (? d: Ast[BindingIdentifier | ForBinding | VariableDeclaration]) {\n      sdo-call %29 = d->BoundNames()\n      %28 = %29\n      %27 = 0\n      while (< %27 (sizeof %28)) {\n        let vn = %28[%27]\n        if (? vn: String) {\n          if (! (contains declaredFunctionNames vn)) {\n            call %30 = env.CanDeclareGlobalVar(env, vn)\n            assert (? %30: Completion)\n            if (? %30: Abrupt) return %30\n            else %30 = %30.Value\n            let vnDefinable = %30\n            if (= vnDefinable false) {\n              call %31 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n              call %32 = clo<\"ThrowCompletion\">(%31)\n              return %32\n            }\n            if (! (contains declaredVarNames vn)) {\n              push declaredVarNames < vn\n            }\n          }\n        }\n        %27 = (+ %27 1)\n      }\n    }\n    %25 = (+ %25 1)\n  }\n  nop\n  nop\n  sdo-call %33 = script->LexicallyScopedDeclarations()\n  let lexDeclarations = %33\n  let privateEnv = null\n  %35 = lexDeclarations\n  %34 = 0\n  while (< %34 (sizeof %35)) {\n    let d = %35[%34]\n    nop\n    sdo-call %38 = d->BoundNames()\n    %37 = %38\n    %36 = 0\n    while (< %36 (sizeof %37)) {\n      let dn = %37[%36]\n      sdo-call %39 = d->IsConstantDeclaration()\n      if (= %39 true) {\n        call %40 = env.CreateImmutableBinding(env, dn, true)\n        assert (? %40: Completion)\n        if (? %40: Abrupt) return %40\n        else %40 = %40.Value\n      } else {\n        call %41 = env.CreateMutableBinding(env, dn, false)\n        assert (? %41: Completion)\n        if (? %41: Abrupt) return %41\n        else %41 = %41.Value\n      }\n      %36 = (+ %36 1)\n    }\n    %34 = (+ %34 1)\n  }\n  %43 = functionsToInitialize\n  %42 = 0\n  while (< %42 (sizeof %43)) {\n    let f = %43[%42]\n    if (? f: Ast) {\n      sdo-call %44 = f->BoundNames()\n      let fn = %44[0]\n      sdo-call %45 = f->InstantiateFunctionObject(env, privateEnv)\n      let fo = %45\n      call %46 = env.CreateGlobalFunctionBinding(env, fn, fo, false)\n      assert (? %46: Completion)\n      if (? %46: Abrupt) return %46\n      else %46 = %46.Value\n    }\n    %42 = (+ %42 1)\n  }\n  %48 = declaredVarNames\n  %47 = 0\n  while (< %47 (sizeof %48)) {\n    let vn = %48[%47]\n    if (? vn: String) {\n      call %49 = env.CreateGlobalVarBinding(env, vn, false)\n      assert (? %49: Completion)\n      if (? %49: Abrupt) return %49\n      else %49 = %49.Value\n    }\n    %47 = (+ %47 1)\n  }\n  call %50 = clo<\"NormalCompletion\">(~unused~)\n  return %50\n}","def ImportedLocalNames(\n  importEntries: List[Record[ImportEntryRecord]],\n): List[String] = {\n  let localNames = (list [])[#670]\n  %1 = importEntries\n  %0 = 0\n  while (< %0 (sizeof %1)) {\n    let i = %1[%0]\n    if (? i: Record[ImportEntryRecord]) {\n      push localNames < i.LocalName\n    }\n    %0 = (+ %0 1)\n  }\n  return localNames\n}","def <SYNTAX>:Module[0,0].ModuleRequests(\n  this: Ast[Module[0]],\n): List[String] = {\n  return (list [])[#671]\n}","def <SYNTAX>:ModuleItemList[0,0].ModuleRequests(\n  this: Ast[ModuleItemList[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->ModuleRequests()\n  return %0\n}","def <SYNTAX>:ModuleItemList[1,0].ModuleRequests(\n  this: Ast[ModuleItemList[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->ModuleRequests()\n  let moduleNames = %0\n  sdo-call %1 = this[1]->ModuleRequests()\n  let additionalNames = %1\n  %3 = additionalNames\n  %2 = 0\n  while (< %2 (sizeof %3)) {\n    let name = %3[%2]\n    if (? name: String) {\n      if (! (contains moduleNames name)) {\n        push moduleNames < name\n      }\n    }\n    %2 = (+ %2 1)\n  }\n  return moduleNames\n}","def <SYNTAX>:ModuleItem[2,0].ModuleRequests(\n  this: Ast[ModuleItem[2]],\n): List[String] = {\n  return (list [])[#672]\n}","def <SYNTAX>:ImportDeclaration[0,0].ModuleRequests(\n  this: Ast[ImportDeclaration[0]],\n): List[String] = {\n  sdo-call %0 = this[1]->ModuleRequests()\n  return %0\n}","def <SYNTAX>:ModuleSpecifier[0,0].ModuleRequests(\n  this: Ast[ModuleSpecifier[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->SV()\n  return (list [%0])[#673]\n}","def <SYNTAX>:ExportDeclaration[0,0].ModuleRequests(\n  this: Ast[ExportDeclaration[0]],\n): List[String] = {\n  sdo-call %0 = this[1]->ModuleRequests()\n  return %0\n}","def <SYNTAX>:ExportDeclaration[1,0].ModuleRequests(\n  this: Ast[ExportDeclaration[1]],\n): List[String] = {\n  return (list [])[#674]\n}","def <SYNTAX>:ExportDeclaration[2,0].ModuleRequests(\n  this: Ast[ExportDeclaration[2]],\n): List[String] = {\n  return (list [])[#675]\n}","def <SYNTAX>:ExportDeclaration[3,0].ModuleRequests(\n  this: Ast[ExportDeclaration[3]],\n): List[String] = {\n  return (list [])[#676]\n}","def <SYNTAX>:ExportDeclaration[4,0].ModuleRequests(\n  this: Ast[ExportDeclaration[4]],\n): List[String] = {\n  return (list [])[#677]\n}","def <SYNTAX>:ExportDeclaration[5,0].ModuleRequests(\n  this: Ast[ExportDeclaration[5]],\n): List[String] = {\n  return (list [])[#678]\n}","def <SYNTAX>:ExportDeclaration[6,0].ModuleRequests(\n  this: Ast[ExportDeclaration[6]],\n): List[String] = {\n  return (list [])[#679]\n}","def <CONC>:Record[CyclicModuleRecord].LoadRequestedModules(\n  module: Record[CyclicModuleRecord],\n  hostDefined?: Unknown[\"Anything\"],\n): Record[Promise] = {\n  if (! (exists hostDefined)) {\n    let hostDefined = ~empty~\n  }\n  call %0 = clo<\"NewPromiseCapability\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Promise%\"])\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let pc = %0\n  let state = (record [GraphLoadingStateRecord] {\n    \"IsLoading\" : true,\n    \"PendingModulesCount\" : 1,\n    \"Visited\" : (list [])[#681],\n    \"PromiseCapability\" : pc,\n    \"HostDefined\" : hostDefined,\n  })[#680]\n  call %1 = clo<\"InnerModuleLoading\">(state, module)\n  return pc.Promise\n}","def InnerModuleLoading(\n  state: Record[GraphLoadingStateRecord],\n  module: Record[ModuleRecord],\n): Enum[~unused~] = {\n  assert (= state.IsLoading true)\n  if (&& (? module: Record[CyclicModuleRecord]) (&& (= module.Status ~new~) (! (contains state.Visited module)))) {\n    push state.Visited < module\n    let requestedModulesCount = (sizeof module.RequestedModules)\n    state.PendingModulesCount = (+ state.PendingModulesCount requestedModulesCount)\n    %1 = module.RequestedModules\n    %0 = 0\n    while (< %0 (sizeof %1)) {\n      let required = %1[%0]\n      if (? required: String) {\n        %3 = module.LoadedModules\n        %4 = 0\n        %5 = false\n        while (&& (! %5) (< %4 (sizeof %3))) {\n          %2 = %3[%4]\n          %5 = (&& (? %2: Record[Record]) (= %2.Specifier required))\n          %4 = (+ %4 1)\n        }\n        if %5 {\n          (yet \"Let _record_ be that Record.\")\n          call %6 = clo<\"InnerModuleLoading\">(state, record.Module)\n        } else {\n          call %7 = clo<\"HostLoadImportedModule\">(module, required, state.HostDefined, state)\n          nop\n        }\n        if (= state.IsLoading false) {\n          return ~unused~\n        }\n      }\n      %0 = (+ %0 1)\n    }\n  }\n  assert (! (< state.PendingModulesCount 1))\n  state.PendingModulesCount = (- state.PendingModulesCount 1)\n  if (== state.PendingModulesCount 0) {\n    state.IsLoading = false\n    %9 = state.Visited\n    %8 = 0\n    while (< %8 (sizeof %9)) {\n      let loaded = %9[%8]\n      if (? loaded: Record[CyclicModuleRecord]) {\n        if (= loaded.Status ~new~) {\n          loaded.Status = ~unlinked~\n        }\n      }\n      %8 = (+ %8 1)\n    }\n    call %10 = clo<\"Call\">(state.PromiseCapability.Resolve, undefined, (list [undefined])[#682])\n    assert (? %10: Normal)\n    %10 = %10.Value\n  }\n  return ~unused~\n}","def ContinueModuleLoading(\n  state: Record[GraphLoadingStateRecord],\n  moduleCompletion: Normal[Record[ModuleRecord]] | Throw,\n): Enum[~unused~] = {\n  if (= state.IsLoading false) {\n    return ~unused~\n  }\n  if (&& (? moduleCompletion: Completion) (= moduleCompletion.Type ~normal~)) {\n    call %0 = clo<\"InnerModuleLoading\">(state, moduleCompletion.Value)\n  } else {\n    state.IsLoading = false\n    call %1 = clo<\"Call\">(state.PromiseCapability.Reject, undefined, (list [moduleCompletion.Value])[#683])\n    assert (? %1: Normal)\n    %1 = %1.Value\n  }\n  return ~unused~\n}","def <CONC>:Record[CyclicModuleRecord].Link(\n  module: Record[CyclicModuleRecord],\n): Normal[Enum[~unused~]] | Throw = {\n  assert (|| (|| (|| (= module.Status ~unlinked~) (= module.Status ~linked~)) (= module.Status ~evaluating-async~)) (= module.Status ~evaluated~))\n  let stack = (list [])[#684]\n  call %0 = clo<\"InnerModuleLinking\">(module, stack, 0)\n  call %1 = clo<\"Completion\">(%0)\n  let result = %1\n  if (&& (? result: Completion) (! (= result.Type ~normal~))) {\n    %3 = stack\n    %2 = 0\n    while (< %2 (sizeof %3)) {\n      let m = %3[%2]\n      if (? m: Record[CyclicModuleRecord]) {\n        assert (= m.Status ~linking~)\n        m.Status = ~unlinked~\n      }\n      %2 = (+ %2 1)\n    }\n    assert (= module.Status ~unlinked~)\n    assert (? result: Completion)\n    return result\n  }\n  assert (|| (|| (= module.Status ~linked~) (= module.Status ~evaluating-async~)) (= module.Status ~evaluated~))\n  assert (= (sizeof stack) 0)\n  call %4 = clo<\"NormalCompletion\">(~unused~)\n  return %4\n}","def InnerModuleLinking(\n  module: Record[ModuleRecord],\n  stack: List[Record[CyclicModuleRecord]],\n  index: NonNegInt,\n): Normal[NonNegInt] | Throw = {\n  if (! (? module: Record[CyclicModuleRecord])) {\n    call %0 = module.Link(module)\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    if (? index: Completion) return index\n    call %1 = clo<\"NormalCompletion\">(index)\n    return %1\n  }\n  if (|| (|| (|| (= module.Status ~linking~) (= module.Status ~linked~)) (= module.Status ~evaluating-async~)) (= module.Status ~evaluated~)) {\n    if (? index: Completion) return index\n    call %2 = clo<\"NormalCompletion\">(index)\n    return %2\n  }\n  assert (= module.Status ~unlinked~)\n  module.Status = ~linking~\n  module.DFSIndex = index\n  module.DFSAncestorIndex = index\n  index = (+ index 1)\n  push stack < module\n  %4 = module.RequestedModules\n  %3 = 0\n  while (< %3 (sizeof %4)) {\n    let required = %4[%3]\n    if (? required: String) {\n      call %5 = clo<\"GetImportedModule\">(module, required)\n      let requiredModule = %5\n      call %6 = clo<\"InnerModuleLinking\">(requiredModule, stack, index)\n      assert (? %6: Completion)\n      if (? %6: Abrupt) return %6\n      else %6 = %6.Value\n      index = %6\n      if (? requiredModule: Record[CyclicModuleRecord]) {\n        assert (|| (|| (|| (= requiredModule.Status ~linking~) (= requiredModule.Status ~linked~)) (= requiredModule.Status ~evaluating-async~)) (= requiredModule.Status ~evaluated~))\n        assert (yet \"_requiredModule_.[[Status]] is ~linking~ if and only if _stack_ contains _requiredModule_.\")\n        if (= requiredModule.Status ~linking~) {\n          module.DFSAncestorIndex = (min module.DFSAncestorIndex requiredModule.DFSAncestorIndex)\n        }\n      }\n    }\n    %3 = (+ %3 1)\n  }\n  call %7 = module.InitializeEnvironment(module)\n  assert (? %7: Completion)\n  if (? %7: Abrupt) return %7\n  else %7 = %7.Value\n  assert (yet \"_module_ occurs exactly once in _stack_.\")\n  assert (! (< module.DFSIndex module.DFSAncestorIndex))\n  if (== module.DFSAncestorIndex module.DFSIndex) {\n    let done = false\n    while (= done false) {\n      (yet \"Let _requiredModule_ be the last element of _stack_.\")\n      (yet \"Remove the last element of _stack_.\")\n      assert (? requiredModule: Record[CyclicModuleRecord])\n      requiredModule.Status = ~linked~\n      if (= requiredModule module) {\n        done = true\n      }\n    }\n  }\n  if (? index: Completion) return index\n  call %8 = clo<\"NormalCompletion\">(index)\n  return %8\n}","def <CONC>:Record[CyclicModuleRecord].Evaluate(\n  module: Record[CyclicModuleRecord],\n): Record[Promise] = {\n  assert (yet \"This call to Evaluate is not happening at the same time as another call to Evaluate within the surrounding agent.\")\n  assert (|| (|| (= module.Status ~linked~) (= module.Status ~evaluating-async~)) (= module.Status ~evaluated~))\n  if (|| (= module.Status ~evaluating-async~) (= module.Status ~evaluated~)) {\n    module = module.CycleRoot\n  }\n  if (! (= module.TopLevelCapability ~empty~)) {\n    return module.TopLevelCapability.Promise\n  }\n  let stack = (list [])[#685]\n  call %0 = clo<\"NewPromiseCapability\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Promise%\"])\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let capability = %0\n  module.TopLevelCapability = capability\n  call %1 = clo<\"InnerModuleEvaluation\">(module, stack, 0)\n  call %2 = clo<\"Completion\">(%1)\n  let result = %2\n  if (&& (? result: Completion) (! (= result.Type ~normal~))) {\n    %4 = stack\n    %3 = 0\n    while (< %3 (sizeof %4)) {\n      let m = %4[%3]\n      if (? m: Record[CyclicModuleRecord]) {\n        assert (= m.Status ~evaluating~)\n        m.Status = ~evaluated~\n        m.EvaluationError = result\n      }\n      %3 = (+ %3 1)\n    }\n    assert (= module.Status ~evaluated~)\n    assert (= module.EvaluationError result)\n    call %5 = clo<\"Call\">(capability.Reject, undefined, (list [result.Value])[#686])\n    assert (? %5: Normal)\n    %5 = %5.Value\n  } else {\n    assert (|| (= module.Status ~evaluating-async~) (= module.Status ~evaluated~))\n    assert (= module.EvaluationError ~empty~)\n    if (= module.AsyncEvaluation false) {\n      assert (= module.Status ~evaluated~)\n      call %6 = clo<\"Call\">(capability.Resolve, undefined, (list [undefined])[#687])\n      assert (? %6: Normal)\n      %6 = %6.Value\n    }\n    assert (= (sizeof stack) 0)\n  }\n  return capability.Promise\n}","def InnerModuleEvaluation(\n  module: Record[ModuleRecord],\n  stack: List[Record[CyclicModuleRecord]],\n  index: NonNegInt,\n): Normal[NonNegInt] | Throw = {\n  if (! (? module: Record[CyclicModuleRecord])) {\n    call %0 = module.Evaluate(module)\n    assert (? %0: Normal)\n    %0 = %0.Value\n    let promise = %0\n    assert (! (= promise.PromiseState ~pending~))\n    if (= promise.PromiseState ~rejected~) {\n      call %1 = clo<\"ThrowCompletion\">(promise.PromiseResult)\n      if (? %1: Completion) return %1\n      call %2 = clo<\"NormalCompletion\">(%1)\n      return %2\n    }\n    if (? index: Completion) return index\n    call %3 = clo<\"NormalCompletion\">(index)\n    return %3\n  }\n  if (|| (= module.Status ~evaluating-async~) (= module.Status ~evaluated~)) {\n    if (= module.EvaluationError ~empty~) {\n      if (? index: Completion) return index\n      call %4 = clo<\"NormalCompletion\">(index)\n      return %4\n    } else {\n      assert (? %5: Completion)\n      return %5\n    }\n  }\n  if (= module.Status ~evaluating~) {\n    if (? index: Completion) return index\n    call %6 = clo<\"NormalCompletion\">(index)\n    return %6\n  }\n  assert (= module.Status ~linked~)\n  module.Status = ~evaluating~\n  module.DFSIndex = index\n  module.DFSAncestorIndex = index\n  module.PendingAsyncDependencies = 0\n  index = (+ index 1)\n  push stack < module\n  %8 = module.RequestedModules\n  %7 = 0\n  while (< %7 (sizeof %8)) {\n    let required = %8[%7]\n    if (? required: String) {\n      call %9 = clo<\"GetImportedModule\">(module, required)\n      let requiredModule = %9\n      call %10 = clo<\"InnerModuleEvaluation\">(requiredModule, stack, index)\n      assert (? %10: Completion)\n      if (? %10: Abrupt) return %10\n      else %10 = %10.Value\n      index = %10\n      if (? requiredModule: Record[CyclicModuleRecord]) {\n        assert (|| (|| (= requiredModule.Status ~evaluating~) (= requiredModule.Status ~evaluating-async~)) (= requiredModule.Status ~evaluated~))\n        assert (yet \"_requiredModule_.[[Status]] is ~evaluating~ if and only if _stack_ contains _requiredModule_.\")\n        if (= requiredModule.Status ~evaluating~) {\n          module.DFSAncestorIndex = (min module.DFSAncestorIndex requiredModule.DFSAncestorIndex)\n        } else {\n          requiredModule = requiredModule.CycleRoot\n          assert (|| (= requiredModule.Status ~evaluating-async~) (= requiredModule.Status ~evaluated~))\n          if (! (= requiredModule.EvaluationError ~empty~)) {\n            assert (? %11: Completion)\n            return %11\n          }\n        }\n        if (= requiredModule.AsyncEvaluation true) {\n          module.PendingAsyncDependencies = (+ module.PendingAsyncDependencies 1)\n          push requiredModule.AsyncParentModules < module\n        }\n      }\n    }\n    %7 = (+ %7 1)\n  }\n  if (|| (< 0 module.PendingAsyncDependencies) (= module.HasTLA true)) {\n    assert (yet \"_module_.[[AsyncEvaluation]] is *false* and was never previously set to *true*.\")\n    module.AsyncEvaluation = true\n    nop\n    if (== module.PendingAsyncDependencies 0) {\n      call %12 = clo<\"ExecuteAsyncModule\">(module)\n    }\n  } else {\n    call %13 = module.ExecuteModule(module)\n    assert (? %13: Completion)\n    if (? %13: Abrupt) return %13\n    else %13 = %13.Value\n  }\n  assert (yet \"_module_ occurs exactly once in _stack_.\")\n  assert (! (< module.DFSIndex module.DFSAncestorIndex))\n  if (== module.DFSAncestorIndex module.DFSIndex) {\n    let done = false\n    while (= done false) {\n      (yet \"Let _requiredModule_ be the last element of _stack_.\")\n      (yet \"Remove the last element of _stack_.\")\n      assert (? requiredModule: Record[CyclicModuleRecord])\n      if (= requiredModule.AsyncEvaluation false) {\n        requiredModule.Status = ~evaluated~\n      } else {\n        requiredModule.Status = ~evaluating-async~\n      }\n      if (= requiredModule module) {\n        done = true\n      }\n      requiredModule.CycleRoot = module\n    }\n  }\n  if (? index: Completion) return index\n  call %14 = clo<\"NormalCompletion\">(index)\n  return %14\n}","def <CLO>:ExecuteAsyncModule:clo0(\n  this: Unknown,\n  ArgumentsList: Unknown,\n  NewTarget: Unknown,\n): Unknown = {\n  let __args__ = (record)[#688]\n  call %0 = clo<\"AsyncModuleExecutionFulfilled\">(module)\n  call %1 = clo<\"NormalCompletion\">(undefined)\n  return %1\n}","def <CLO>:ExecuteAsyncModule:clo1(\n  this: Unknown,\n  ArgumentsList: Unknown,\n  NewTarget: Unknown,\n): Unknown = {\n  let __args__ = (record)[#689]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop error < ArgumentsList\n    expand __args__.error\n  } else let error = undefined\n  call %0 = clo<\"AsyncModuleExecutionRejected\">(module, error)\n  call %1 = clo<\"NormalCompletion\">(undefined)\n  return %1\n}","def ExecuteAsyncModule(\n  module: Record[CyclicModuleRecord],\n): Enum[~unused~] = {\n  assert (|| (= module.Status ~evaluating~) (= module.Status ~evaluating-async~))\n  assert (= module.HasTLA true)\n  call %0 = clo<\"NewPromiseCapability\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Promise%\"])\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let capability = %0\n  let fulfilledClosure = clo<\"ExecuteAsyncModule:clo0\", [module]>\n  call %1 = clo<\"CreateBuiltinFunction\">(fulfilledClosure, 0, \"\", (list [])[#690])\n  let onFulfilled = %1\n  let rejectedClosure = clo<\"ExecuteAsyncModule:clo1\", [module]>\n  call %2 = clo<\"CreateBuiltinFunction\">(rejectedClosure, 0, \"\", (list [])[#691])\n  let onRejected = %2\n  call %3 = clo<\"PerformPromiseThen\">(capability.Promise, onFulfilled, onRejected)\n  call %4 = module.ExecuteModule(module, capability)\n  assert (? %4: Normal)\n  %4 = %4.Value\n  return ~unused~\n}","def GatherAvailableAncestors(\n  module: Record[CyclicModuleRecord],\n  execList: List[Record[CyclicModuleRecord]],\n): Enum[~unused~] = {\n  %1 = module.AsyncParentModules\n  %0 = 0\n  while (< %0 (sizeof %1)) {\n    let m = %1[%0]\n    if (? m: Record[CyclicModuleRecord]) {\n      if (&& (! (contains execList m)) (= m.CycleRoot.EvaluationError ~empty~)) {\n        assert (= m.Status ~evaluating-async~)\n        assert (= m.EvaluationError ~empty~)\n        assert (= m.AsyncEvaluation true)\n        assert (< 0 m.PendingAsyncDependencies)\n        m.PendingAsyncDependencies = (- m.PendingAsyncDependencies 1)\n        if (== m.PendingAsyncDependencies 0) {\n          push execList < m\n          if (= m.HasTLA false) {\n            call %2 = clo<\"GatherAvailableAncestors\">(m, execList)\n          }\n        }\n      }\n    }\n    %0 = (+ %0 1)\n  }\n  return ~unused~\n}","def AsyncModuleExecutionFulfilled(\n  module: Record[CyclicModuleRecord],\n): Enum[~unused~] = {\n  if (= module.Status ~evaluated~) {\n    assert (! (= module.EvaluationError ~empty~))\n    return ~unused~\n  }\n  assert (= module.Status ~evaluating-async~)\n  assert (= module.AsyncEvaluation true)\n  assert (= module.EvaluationError ~empty~)\n  module.AsyncEvaluation = false\n  module.Status = ~evaluated~\n  if (! (= module.TopLevelCapability ~empty~)) {\n    assert (= module.CycleRoot module)\n    call %0 = clo<\"Call\">(module.TopLevelCapability.Resolve, undefined, (list [undefined])[#692])\n    assert (? %0: Normal)\n    %0 = %0.Value\n  }\n  let execList = (list [])[#693]\n  call %1 = clo<\"GatherAvailableAncestors\">(module, execList)\n  (yet \"Let _sortedExecList_ be a List whose elements are the elements of _execList_, in the order in which they had their [[AsyncEvaluation]] fields set to *true* in InnerModuleEvaluation.\")\n  assert (yet \"All elements of _sortedExecList_ have their [[AsyncEvaluation]] field set to *true*, [[PendingAsyncDependencies]] field set to 0, and [[EvaluationError]] field set to ~empty~.\")\n  %3 = sortedExecList\n  %2 = 0\n  while (< %2 (sizeof %3)) {\n    let m = %3[%2]\n    if (? m: Record[CyclicModuleRecord]) {\n      if (= m.Status ~evaluated~) {\n        assert (! (= m.EvaluationError ~empty~))\n      } else {\n        if (= m.HasTLA true) {\n          call %4 = clo<\"ExecuteAsyncModule\">(m)\n        } else {\n          call %5 = m.ExecuteModule(m)\n          let result = %5\n          if (&& (? result: Completion) (! (= result.Type ~normal~))) {\n            call %6 = clo<\"AsyncModuleExecutionRejected\">(m, result.Value)\n          } else {\n            m.Status = ~evaluated~\n            if (! (= m.TopLevelCapability ~empty~)) {\n              assert (= m.CycleRoot m)\n              call %7 = clo<\"Call\">(m.TopLevelCapability.Resolve, undefined, (list [undefined])[#694])\n              assert (? %7: Normal)\n              %7 = %7.Value\n            }\n          }\n        }\n      }\n    }\n    %2 = (+ %2 1)\n  }\n  return ~unused~\n}","def AsyncModuleExecutionRejected(\n  module: Record[CyclicModuleRecord],\n  error: ESValue,\n): Enum[~unused~] = {\n  if (= module.Status ~evaluated~) {\n    assert (! (= module.EvaluationError ~empty~))\n    return ~unused~\n  }\n  assert (= module.Status ~evaluating-async~)\n  assert (= module.AsyncEvaluation true)\n  assert (= module.EvaluationError ~empty~)\n  call %0 = clo<\"ThrowCompletion\">(error)\n  module.EvaluationError = %0\n  module.Status = ~evaluated~\n  %2 = module.AsyncParentModules\n  %1 = 0\n  while (< %1 (sizeof %2)) {\n    let m = %2[%1]\n    if (? m: Record[CyclicModuleRecord]) {\n      call %3 = clo<\"AsyncModuleExecutionRejected\">(m, error)\n    }\n    %1 = (+ %1 1)\n  }\n  if (! (= module.TopLevelCapability ~empty~)) {\n    assert (= module.CycleRoot module)\n    call %4 = clo<\"Call\">(module.TopLevelCapability.Reject, undefined, (list [error])[#695])\n    assert (? %4: Normal)\n    %4 = %4.Value\n  }\n  return ~unused~\n}","def ParseModule(\n  sourceText: Unknown[\"ECMAScriptSourceText\"],\n  realm: Record[RealmRecord],\n  hostDefined: Unknown[\"Anything\"],\n): Unknown[\"SourceTextModuleRecordOrANonemptyListOf*SyntaxError*Object\"] = {\n  let body = (parse sourceText (grammar-symbol |Module|))\n  if (? body: List[Record[Error]]) {\n    return body\n  }\n  sdo-call %0 = body->ModuleRequests()\n  let requestedModules = %0\n  sdo-call %1 = body->ImportEntries()\n  let importEntries = %1\n  call %2 = clo<\"ImportedLocalNames\">(importEntries)\n  let importedBoundNames = %2\n  let indirectExportEntries = (list [])[#696]\n  let localExportEntries = (list [])[#697]\n  let starExportEntries = (list [])[#698]\n  sdo-call %3 = body->ExportEntries()\n  let exportEntries = %3\n  %5 = exportEntries\n  %4 = 0\n  while (< %4 (sizeof %5)) {\n    let ee = %5[%4]\n    if (? ee: Record[ExportEntryRecord]) {\n      if (= ee.ModuleRequest null) {\n        if (! (contains importedBoundNames ee.LocalName)) {\n          push localExportEntries < ee\n        } else {\n          (yet \"Let _ie_ be the element of _importEntries_ whose [[LocalName]] is _ee_.[[LocalName]].\")\n          if (= ie.ImportName ~namespace-object~) {\n            nop\n            push localExportEntries < ee\n          } else {\n            nop\n            push indirectExportEntries < (record [ExportEntryRecord] {\n              \"ModuleRequest\" : ie.ModuleRequest,\n              \"ImportName\" : ie.ImportName,\n              \"LocalName\" : null,\n              \"ExportName\" : ee.ExportName,\n            })[#699]\n          }\n        }\n      } else {\n        if (= ee.ImportName ~all-but-default~) {\n          assert (= ee.ExportName null)\n          push starExportEntries < ee\n        } else {\n          push indirectExportEntries < ee\n        }\n      }\n    }\n    %4 = (+ %4 1)\n  }\n  sdo-call %6 = body->Contains(\"await\")\n  let async = %6\n  return (record [SourceTextModuleRecord] {\n    \"Evaluate\" : clo<\"Record[CyclicModuleRecord].Evaluate\">,\n    \"ExecuteModule\" : clo<\"Record[SourceTextModuleRecord].ExecuteModule\">,\n    \"GetExportedNames\" : clo<\"Record[SourceTextModuleRecord].GetExportedNames\">,\n    \"InitializeEnvironment\" : clo<\"Record[SourceTextModuleRecord].InitializeEnvironment\">,\n    \"Link\" : clo<\"Record[CyclicModuleRecord].Link\">,\n    \"LoadRequestedModules\" : clo<\"Record[CyclicModuleRecord].LoadRequestedModules\">,\n    \"ResolveExport\" : clo<\"Record[SourceTextModuleRecord].ResolveExport\">,\n    \"Realm\" : realm,\n    \"Environment\" : ~empty~,\n    \"Namespace\" : ~empty~,\n    \"CycleRoot\" : ~empty~,\n    \"HasTLA\" : async,\n    \"AsyncEvaluation\" : false,\n    \"TopLevelCapability\" : ~empty~,\n    \"AsyncParentModules\" : (list [])[#701],\n    \"PendingAsyncDependencies\" : ~empty~,\n    \"Status\" : ~new~,\n    \"EvaluationError\" : ~empty~,\n    \"HostDefined\" : hostDefined,\n    \"ECMAScriptCode\" : body,\n    \"Context\" : ~empty~,\n    \"ImportMeta\" : ~empty~,\n    \"RequestedModules\" : requestedModules,\n    \"LoadedModules\" : (list [])[#702],\n    \"ImportEntries\" : importEntries,\n    \"LocalExportEntries\" : localExportEntries,\n    \"IndirectExportEntries\" : indirectExportEntries,\n    \"StarExportEntries\" : starExportEntries,\n    \"DFSIndex\" : ~empty~,\n    \"DFSAncestorIndex\" : ~empty~,\n  })[#700]\n}","def <CONC>:Record[SourceTextModuleRecord].GetExportedNames(\n  module: Record[SourceTextModuleRecord],\n  exportStarSet?: List[Record[SourceTextModuleRecord]],\n): List[String] = {\n  assert (! (= module.Status ~new~))\n  if (! (exists exportStarSet)) {\n    exportStarSet = (list [])[#703]\n  }\n  if (contains exportStarSet module) {\n    assert (yet \"We've reached the starting point of an `export *` circularity.\")\n    return (list [])[#704]\n  }\n  push exportStarSet < module\n  let exportedNames = (list [])[#705]\n  %1 = module.LocalExportEntries\n  %0 = 0\n  while (< %0 (sizeof %1)) {\n    let e = %1[%0]\n    if (? e: Record[ExportEntryRecord]) {\n      assert (yet \"_module_ provides the direct binding for this export.\")\n      assert (! (= e.ExportName null))\n      push exportedNames < e.ExportName\n    }\n    %0 = (+ %0 1)\n  }\n  %3 = module.IndirectExportEntries\n  %2 = 0\n  while (< %2 (sizeof %3)) {\n    let e = %3[%2]\n    if (? e: Record[ExportEntryRecord]) {\n      assert (yet \"_module_ imports a specific binding for this export.\")\n      assert (! (= e.ExportName null))\n      push exportedNames < e.ExportName\n    }\n    %2 = (+ %2 1)\n  }\n  %5 = module.StarExportEntries\n  %4 = 0\n  while (< %4 (sizeof %5)) {\n    let e = %5[%4]\n    if (? e: Record[ExportEntryRecord]) {\n      assert (! (= e.ModuleRequest null))\n      call %6 = clo<\"GetImportedModule\">(module, e.ModuleRequest)\n      let requestedModule = %6\n      call %7 = requestedModule.GetExportedNames(requestedModule, exportStarSet)\n      let starNames = %7\n      %9 = starNames\n      %8 = 0\n      while (< %8 (sizeof %9)) {\n        let n = %9[%8]\n        call %10 = clo<\"SameValue\">(n, \"default\")\n        if (= %10 false) {\n          if (! (contains exportedNames n)) {\n            push exportedNames < n\n          }\n        }\n        %8 = (+ %8 1)\n      }\n    }\n    %4 = (+ %4 1)\n  }\n  return exportedNames\n}","def <CONC>:Record[SourceTextModuleRecord].ResolveExport(\n  module: Record[SourceTextModuleRecord],\n  exportName: String,\n  resolveSet?: Unknown[\"ListOfRecordsWithFields[[Module]](aModuleRecord)And[[ExportName]](aString)\"],\n): Record[ResolvedBindingRecord] | Enum[~ambiguous~] | Null = {\n  assert (! (= module.Status ~new~))\n  if (! (exists resolveSet)) {\n    resolveSet = (list [])[#706]\n  }\n  %1 = resolveSet\n  %0 = 0\n  while (< %0 (sizeof %1)) {\n    let r = %1[%0]\n    if (? r: Record[{ ExportName, Module }]) {\n      %2 = (= module r.Module)\n      if %2 {\n        call %3 = clo<\"SameValue\">(exportName, r.ExportName)\n        %2 = (= %3 true)\n      }\n      if %2 {\n        assert (yet \"This is a circular import request.\")\n        return null\n      }\n    }\n    %0 = (+ %0 1)\n  }\n  push resolveSet < (record {\n    \"Module\" : module,\n    \"ExportName\" : exportName,\n  })[#707]\n  %5 = module.LocalExportEntries\n  %4 = 0\n  while (< %4 (sizeof %5)) {\n    let e = %5[%4]\n    if (? e: Record[ExportEntryRecord]) {\n      call %6 = clo<\"SameValue\">(exportName, e.ExportName)\n      if (= %6 true) {\n        assert (yet \"_module_ provides the direct binding for this export.\")\n        return (record [ResolvedBindingRecord] {\n          \"Module\" : module,\n          \"BindingName\" : e.LocalName,\n        })[#708]\n      }\n    }\n    %4 = (+ %4 1)\n  }\n  %8 = module.IndirectExportEntries\n  %7 = 0\n  while (< %7 (sizeof %8)) {\n    let e = %8[%7]\n    if (? e: Record[ExportEntryRecord]) {\n      call %9 = clo<\"SameValue\">(exportName, e.ExportName)\n      if (= %9 true) {\n        assert (! (= e.ModuleRequest null))\n        call %10 = clo<\"GetImportedModule\">(module, e.ModuleRequest)\n        let importedModule = %10\n        if (= e.ImportName ~all~) {\n          assert (yet \"_module_ does not provide the direct binding for this export.\")\n          return (record [ResolvedBindingRecord] {\n            \"Module\" : importedModule,\n            \"BindingName\" : ~namespace~,\n          })[#709]\n        } else {\n          assert (yet \"_module_ imports a specific binding for this export.\")\n          call %11 = importedModule.ResolveExport(importedModule, e.ImportName, resolveSet)\n          return %11\n        }\n      }\n    }\n    %7 = (+ %7 1)\n  }\n  call %12 = clo<\"SameValue\">(exportName, \"default\")\n  if (= %12 true) {\n    assert (yet \"A `default` export was not explicitly defined by this module.\")\n    return null\n    nop\n  }\n  let starResolution = null\n  %14 = module.StarExportEntries\n  %13 = 0\n  while (< %13 (sizeof %14)) {\n    let e = %14[%13]\n    if (? e: Record[ExportEntryRecord]) {\n      assert (! (= e.ModuleRequest null))\n      call %15 = clo<\"GetImportedModule\">(module, e.ModuleRequest)\n      let importedModule = %15\n      call %16 = importedModule.ResolveExport(importedModule, exportName, resolveSet)\n      let resolution = %16\n      if (= resolution ~ambiguous~) {\n        return ~ambiguous~\n      }\n      if (! (= resolution null)) {\n        assert (? resolution: Record[ResolvedBindingRecord])\n        if (= starResolution null) {\n          starResolution = resolution\n        } else {\n          assert (yet \"There is more than one `*` import that includes the requested name.\")\n          if (! (= resolution.Module starResolution.Module)) {\n            return ~ambiguous~\n          }\n          (yet \"If _resolution_.[[BindingName]] is not _starResolution_.[[BindingName]] and either _resolution_.[[BindingName]] or _starResolution_.[[BindingName]] is ~namespace~, return ~ambiguous~.\")\n          %17 = (? resolution.BindingName: String)\n          if %17 {\n            %17 = (? starResolution.BindingName: String)\n            if %17 {\n              call %18 = clo<\"SameValue\">(resolution.BindingName, starResolution.BindingName)\n              %17 = (= %18 false)\n            }\n          }\n          if %17 {\n            return ~ambiguous~\n          }\n        }\n      }\n    }\n    %13 = (+ %13 1)\n  }\n  return starResolution\n}","def <CONC>:Record[SourceTextModuleRecord].InitializeEnvironment(\n  module: Record[SourceTextModuleRecord],\n): Normal[Enum[~unused~]] | Throw = {\n  %1 = module.IndirectExportEntries\n  %0 = 0\n  while (< %0 (sizeof %1)) {\n    let e = %1[%0]\n    if (? e: Record[ExportEntryRecord]) {\n      assert (! (= e.ExportName null))\n      call %2 = module.ResolveExport(module, e.ExportName)\n      let resolution = %2\n      if (|| (= resolution null) (= resolution ~ambiguous~)) {\n        call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%SyntaxError.prototype%\")\n        call %4 = clo<\"ThrowCompletion\">(%3)\n        return %4\n      }\n      assert (? resolution: Record[ResolvedBindingRecord])\n    }\n    %0 = (+ %0 1)\n  }\n  assert (yet \"All named exports from _module_ are resolvable.\")\n  let realm = module.Realm\n  assert (! (= realm undefined))\n  call %5 = clo<\"NewModuleEnvironment\">(realm.GlobalEnv)\n  let env = %5\n  module.Environment = env\n  %7 = module.ImportEntries\n  %6 = 0\n  while (< %6 (sizeof %7)) {\n    let in = %7[%6]\n    if (? in: Record[ImportEntryRecord]) {\n      call %8 = clo<\"GetImportedModule\">(module, in.ModuleRequest)\n      let importedModule = %8\n      if (= in.ImportName ~namespace-object~) {\n        call %9 = clo<\"GetModuleNamespace\">(importedModule)\n        let namespace = %9\n        call %10 = env.CreateImmutableBinding(env, in.LocalName, true)\n        assert (? %10: Normal)\n        %10 = %10.Value\n        call %11 = env.InitializeBinding(env, in.LocalName, namespace)\n        assert (? %11: Normal)\n        %11 = %11.Value\n      } else {\n        call %12 = importedModule.ResolveExport(importedModule, in.ImportName)\n        let resolution = %12\n        if (|| (= resolution null) (= resolution ~ambiguous~)) {\n          call %13 = clo<\"__NEW_ERROR_OBJ__\">(\"%SyntaxError.prototype%\")\n          call %14 = clo<\"ThrowCompletion\">(%13)\n          return %14\n        }\n        if (= resolution.BindingName ~namespace~) {\n          call %15 = clo<\"GetModuleNamespace\">(resolution.Module)\n          let namespace = %15\n          call %16 = env.CreateImmutableBinding(env, in.LocalName, true)\n          assert (? %16: Normal)\n          %16 = %16.Value\n          call %17 = env.InitializeBinding(env, in.LocalName, namespace)\n          assert (? %17: Normal)\n          %17 = %17.Value\n        } else {\n          call %18 = env.CreateImportBinding(env, in.LocalName, resolution.Module, resolution.BindingName)\n        }\n      }\n    }\n    %6 = (+ %6 1)\n  }\n  let moduleContext = (record [ExecutionContext])[#710]\n  moduleContext.Function = null\n  assert (! (= module.Realm undefined))\n  moduleContext.Realm = module.Realm\n  moduleContext.ScriptOrModule = module\n  moduleContext.VariableEnvironment = module.Environment\n  moduleContext.LexicalEnvironment = module.Environment\n  moduleContext.PrivateEnvironment = null\n  module.Context = moduleContext\n  push moduleContext > @EXECUTION_STACK\n  let code = module.ECMAScriptCode\n  sdo-call %19 = code->VarScopedDeclarations()\n  let varDeclarations = %19\n  let declaredVarNames = (list [])[#711]\n  %21 = varDeclarations\n  %20 = 0\n  while (< %20 (sizeof %21)) {\n    let d = %21[%20]\n    sdo-call %24 = d->BoundNames()\n    %23 = %24\n    %22 = 0\n    while (< %22 (sizeof %23)) {\n      let dn = %23[%22]\n      if (! (contains declaredVarNames dn)) {\n        call %25 = env.CreateMutableBinding(env, dn, false)\n        assert (? %25: Normal)\n        %25 = %25.Value\n        call %26 = env.InitializeBinding(env, dn, undefined)\n        assert (? %26: Normal)\n        %26 = %26.Value\n        push declaredVarNames < dn\n      }\n      %22 = (+ %22 1)\n    }\n    %20 = (+ %20 1)\n  }\n  sdo-call %27 = code->LexicallyScopedDeclarations()\n  let lexDeclarations = %27\n  let privateEnv = null\n  %29 = lexDeclarations\n  %28 = 0\n  while (< %28 (sizeof %29)) {\n    let d = %29[%28]\n    sdo-call %32 = d->BoundNames()\n    %31 = %32\n    %30 = 0\n    while (< %30 (sizeof %31)) {\n      let dn = %31[%30]\n      sdo-call %33 = d->IsConstantDeclaration()\n      if (= %33 true) {\n        call %34 = env.CreateImmutableBinding(env, dn, true)\n        assert (? %34: Normal)\n        %34 = %34.Value\n      } else {\n        call %35 = env.CreateMutableBinding(env, dn, false)\n        assert (? %35: Normal)\n        %35 = %35.Value\n      }\n      if (? d: Ast[AsyncFunctionDeclaration | AsyncGeneratorDeclaration | FunctionDeclaration | GeneratorDeclaration]) {\n        sdo-call %36 = d->InstantiateFunctionObject(env, privateEnv)\n        let fo = %36\n        call %37 = env.InitializeBinding(env, dn, fo)\n        assert (? %37: Normal)\n        %37 = %37.Value\n      }\n      %30 = (+ %30 1)\n    }\n    %28 = (+ %28 1)\n  }\n  (yet \"Remove _moduleContext_ from the execution context stack.\")\n  call %38 = clo<\"NormalCompletion\">(~unused~)\n  return %38\n}","def <CONC>:Record[SourceTextModuleRecord].ExecuteModule(\n  module: Record[SourceTextModuleRecord],\n  capability?: Record[PromiseCapabilityRecord],\n): Normal[Enum[~unused~]] | Throw = {\n  let moduleContext = (record [ExecutionContext])[#712]\n  moduleContext.Function = null\n  moduleContext.Realm = module.Realm\n  moduleContext.ScriptOrModule = module\n  assert (yet \"_module_ has been linked and declarations in its module environment have been instantiated.\")\n  moduleContext.VariableEnvironment = module.Environment\n  moduleContext.LexicalEnvironment = module.Environment\n  nop\n  if (= module.HasTLA false) {\n    assert (! (exists capability))\n    push moduleContext > @EXECUTION_STACK\n    sdo-call %0 = module.ECMAScriptCode->Evaluation()\n    call %1 = clo<\"Completion\">(%0)\n    let result = %1\n    pop %2 < @EXECUTION_STACK\n    nop\n    if (&& (? result: Completion) (! (= result.Type ~normal~))) {\n      assert (? result: Completion)\n      return result\n    }\n  } else {\n    assert (? capability: Record[PromiseCapabilityRecord])\n    call %3 = clo<\"AsyncBlockStart\">(capability, module.ECMAScriptCode, moduleContext)\n  }\n  call %4 = clo<\"NormalCompletion\">(~unused~)\n  return %4\n}","def GetImportedModule(\n  referrer: Record[CyclicModuleRecord],\n  specifier: String,\n): Record[ModuleRecord] = {\n  assert (yet \"Exactly one element of _referrer_.[[LoadedModules]] is a Record whose [[Specifier]] is _specifier_, since LoadRequestedModules has completed successfully on _referrer_ prior to invoking this abstract operation.\")\n  (yet \"Let _record_ be the Record in _referrer_.[[LoadedModules]] whose [[Specifier]] is _specifier_.\")\n  return record.Module\n}","def FinishLoadingImportedModule(\n  referrer: Record[CyclicModuleRecord | RealmRecord | ScriptRecord],\n  specifier: String,\n  payload: Record[GraphLoadingStateRecord | PromiseCapabilityRecord],\n  result: Normal[Record[ModuleRecord]] | Throw,\n): Enum[~unused~] = {\n  if (&& (? result: Completion) (= result.Type ~normal~)) {\n    %1 = referrer.LoadedModules\n    %2 = 0\n    %3 = false\n    while (&& (! %3) (< %2 (sizeof %1))) {\n      %0 = %1[%2]\n      %3 = (&& (? %0: Record[Record]) (= %0.Specifier specifier))\n      %2 = (+ %2 1)\n    }\n    if %3 {\n      assert (yet \"That Record's [[Module]] is _result_.[[Value]].\")\n    } else {\n      push referrer.LoadedModules < (record {\n        \"Specifier\" : specifier,\n        \"Module\" : result.Value,\n      })[#713]\n    }\n  }\n  if (? payload: Record[GraphLoadingStateRecord]) {\n    call %4 = clo<\"ContinueModuleLoading\">(payload, result)\n  } else {\n    call %5 = clo<\"ContinueDynamicImport\">(payload, result)\n  }\n  return ~unused~\n}","def GetModuleNamespace(\n  module: Unknown[\"InstanceOfAConcreteSubclassOfModuleRecord\"],\n): Record[ModuleNamespaceExoticObject] | Enum[~empty~] = {\n  assert (|| (! (? module: Record[CyclicModuleRecord])) (! (|| (= module.Status ~new~) (= module.Status ~unlinked~))))\n  let namespace = module.Namespace\n  if (= namespace ~empty~) {\n    call %0 = module.GetExportedNames(module)\n    let exportedNames = %0\n    let unambiguousNames = (list [])[#714]\n    %2 = exportedNames\n    %1 = 0\n    while (< %1 (sizeof %2)) {\n      let name = %2[%1]\n      call %3 = module.ResolveExport(module, name)\n      let resolution = %3\n      if (? resolution: Record[ResolvedBindingRecord]) {\n        push unambiguousNames < name\n      }\n      %1 = (+ %1 1)\n    }\n    call %4 = clo<\"ModuleNamespaceCreate\">(module, unambiguousNames)\n    namespace = %4\n  }\n  return namespace\n}","def <SYNTAX>:Module[0,0].Evaluation(\n  this: Ast[Module[0]],\n): Unknown = {\n  call %0 = clo<\"NormalCompletion\">(undefined)\n  return %0\n}","def <SYNTAX>:ModuleBody[0,0].Evaluation(\n  this: Ast[ModuleBody[0]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  call %1 = clo<\"Completion\">(%0)\n  let result = %1\n  if (&& (&& (? result: Completion) (= result.Type ~normal~)) (= result.Value ~empty~)) {\n    call %2 = clo<\"NormalCompletion\">(undefined)\n    return %2\n  }\n  assert (? result: Completion)\n  return result\n}","def <SYNTAX>:ModuleItemList[1,0].Evaluation(\n  this: Ast[ModuleItemList[1]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let sl = %0\n  sdo-call %1 = this[1]->Evaluation()\n  call %2 = clo<\"Completion\">(%1)\n  let s = %2\n  call %3 = clo<\"UpdateEmpty\">(s, sl)\n  assert (? %3: Completion)\n  return %3\n}","def <SYNTAX>:ModuleItem[0,0].Evaluation(\n  this: Ast[ModuleItem[0]],\n): Unknown = {\n  call %0 = clo<\"NormalCompletion\">(~empty~)\n  return %0\n}","def <SYNTAX>:Module[0,0].ImportEntries(\n  this: Ast[Module[0]],\n): List[Record[ImportEntryRecord]] = {\n  return (list [])[#715]\n}","def <SYNTAX>:ModuleItemList[1,0].ImportEntries(\n  this: Ast[ModuleItemList[1]],\n): List[Record[ImportEntryRecord]] = {\n  sdo-call %0 = this[0]->ImportEntries()\n  let entries1 = %0\n  sdo-call %1 = this[1]->ImportEntries()\n  let entries2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [entries1, entries2])[#716])\n  return %2\n}","def <SYNTAX>:ModuleItem[1,0].ImportEntries(\n  this: Ast[ModuleItem[1]],\n): List[Record[ImportEntryRecord]] = {\n  return (list [])[#717]\n}","def <SYNTAX>:ModuleItem[2,0].ImportEntries(\n  this: Ast[ModuleItem[2]],\n): List[Record[ImportEntryRecord]] = {\n  return (list [])[#718]\n}","def <SYNTAX>:ImportDeclaration[0,0].ImportEntries(\n  this: Ast[ImportDeclaration[0]],\n): List[Record[ImportEntryRecord]] = {\n  sdo-call %0 = this[1]->ModuleRequests()\n  let module = %0[0]\n  sdo-call %1 = this[0]->ImportEntriesForModule(module)\n  return %1\n}","def <SYNTAX>:ImportDeclaration[1,0].ImportEntries(\n  this: Ast[ImportDeclaration[1]],\n): List[Record[ImportEntryRecord]] = {\n  return (list [])[#719]\n}","def <SYNTAX>:ImportClause[3,0].ImportEntriesForModule(\n  this: Ast[ImportClause[3]],\n  module: String,\n): List[Record[ImportEntryRecord]] = {\n  sdo-call %0 = this[0]->ImportEntriesForModule(module)\n  let entries1 = %0\n  sdo-call %1 = this[1]->ImportEntriesForModule(module)\n  let entries2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [entries1, entries2])[#720])\n  return %2\n}","def <SYNTAX>:ImportClause[4,0].ImportEntriesForModule(\n  this: Ast[ImportClause[4]],\n  module: String,\n): List[Record[ImportEntryRecord]] = {\n  sdo-call %0 = this[0]->ImportEntriesForModule(module)\n  let entries1 = %0\n  sdo-call %1 = this[1]->ImportEntriesForModule(module)\n  let entries2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [entries1, entries2])[#721])\n  return %2\n}","def <SYNTAX>:ImportedDefaultBinding[0,0].ImportEntriesForModule(\n  this: Ast[ImportedDefaultBinding[0]],\n  module: String,\n): List[Record[ImportEntryRecord]] = {\n  sdo-call %0 = this[0]->BoundNames()\n  let localName = %0[0]\n  let defaultEntry = (record [ImportEntryRecord] {\n    \"ModuleRequest\" : module,\n    \"ImportName\" : \"default\",\n    \"LocalName\" : localName,\n  })[#722]\n  return (list [defaultEntry])[#723]\n}","def <SYNTAX>:NameSpaceImport[0,0].ImportEntriesForModule(\n  this: Ast[NameSpaceImport[0]],\n  module: String,\n): List[Record[ImportEntryRecord]] = {\n  sdo-call %0 = this[0]->StringValue()\n  let localName = %0\n  let entry = (record [ImportEntryRecord] {\n    \"ModuleRequest\" : module,\n    \"ImportName\" : ~namespace-object~,\n    \"LocalName\" : localName,\n  })[#724]\n  return (list [entry])[#725]\n}","def <SYNTAX>:NamedImports[0,0].ImportEntriesForModule(\n  this: Ast[NamedImports[0]],\n  module: String,\n): List[Record[ImportEntryRecord]] = {\n  return (list [])[#726]\n}","def <SYNTAX>:ImportsList[1,0].ImportEntriesForModule(\n  this: Ast[ImportsList[1]],\n  module: String,\n): List[Record[ImportEntryRecord]] = {\n  sdo-call %0 = this[0]->ImportEntriesForModule(module)\n  let specs1 = %0\n  sdo-call %1 = this[1]->ImportEntriesForModule(module)\n  let specs2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [specs1, specs2])[#727])\n  return %2\n}","def <SYNTAX>:ImportSpecifier[0,0].ImportEntriesForModule(\n  this: Ast[ImportSpecifier[0]],\n  module: String,\n): List[Record[ImportEntryRecord]] = {\n  sdo-call %0 = this[0]->BoundNames()\n  let localName = %0[0]\n  let entry = (record [ImportEntryRecord] {\n    \"ModuleRequest\" : module,\n    \"ImportName\" : localName,\n    \"LocalName\" : localName,\n  })[#728]\n  return (list [entry])[#729]\n}","def <SYNTAX>:ImportSpecifier[1,0].ImportEntriesForModule(\n  this: Ast[ImportSpecifier[1]],\n  module: String,\n): List[Record[ImportEntryRecord]] = {\n  sdo-call %0 = this[0]->StringValue()\n  let importName = %0\n  sdo-call %1 = this[1]->StringValue()\n  let localName = %1\n  let entry = (record [ImportEntryRecord] {\n    \"ModuleRequest\" : module,\n    \"ImportName\" : importName,\n    \"LocalName\" : localName,\n  })[#730]\n  return (list [entry])[#731]\n}","def <SYNTAX>:ModuleItemList[1,0].ExportedBindings(\n  this: Ast[ModuleItemList[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->ExportedBindings()\n  let names1 = %0\n  sdo-call %1 = this[1]->ExportedBindings()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#732])\n  return %2\n}","def <SYNTAX>:ModuleItem[0,0].ExportedBindings(\n  this: Ast[ModuleItem[0]],\n): List[String] = {\n  return (list [])[#733]\n}","def <SYNTAX>:ModuleItem[2,0].ExportedBindings(\n  this: Ast[ModuleItem[2]],\n): List[String] = {\n  return (list [])[#734]\n}","def <SYNTAX>:ExportDeclaration[0,0].ExportedBindings(\n  this: Ast[ExportDeclaration[0]],\n): List[String] = {\n  return (list [])[#735]\n}","def <SYNTAX>:ExportDeclaration[1,0].ExportedBindings(\n  this: Ast[ExportDeclaration[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->ExportedBindings()\n  return %0\n}","def <SYNTAX>:ExportDeclaration[2,0].ExportedBindings(\n  this: Ast[ExportDeclaration[2]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:ExportDeclaration[3,0].ExportedBindings(\n  this: Ast[ExportDeclaration[3]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:ExportDeclaration[4,0].ExportedBindings(\n  this: Ast[ExportDeclaration[4]],\n): List[String] = {\n  sdo-call %0 = this->BoundNames()\n  return %0\n}","def <SYNTAX>:ExportDeclaration[5,0].ExportedBindings(\n  this: Ast[ExportDeclaration[5]],\n): List[String] = {\n  sdo-call %0 = this->BoundNames()\n  return %0\n}","def <SYNTAX>:ExportDeclaration[6,0].ExportedBindings(\n  this: Ast[ExportDeclaration[6]],\n): List[String] = {\n  sdo-call %0 = this->BoundNames()\n  return %0\n}","def <SYNTAX>:NamedExports[0,0].ExportedBindings(\n  this: Ast[NamedExports[0]],\n): List[String] = {\n  return (list [])[#736]\n}","def <SYNTAX>:ExportsList[1,0].ExportedBindings(\n  this: Ast[ExportsList[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->ExportedBindings()\n  let names1 = %0\n  sdo-call %1 = this[1]->ExportedBindings()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#737])\n  return %2\n}","def <SYNTAX>:ExportSpecifier[0,0].ExportedBindings(\n  this: Ast[ExportSpecifier[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->StringValue()\n  return (list [%0])[#738]\n}","def <SYNTAX>:ExportSpecifier[1,0].ExportedBindings(\n  this: Ast[ExportSpecifier[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->StringValue()\n  return (list [%0])[#739]\n}","def <SYNTAX>:ModuleItemList[1,0].ExportedNames(\n  this: Ast[ModuleItemList[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->ExportedNames()\n  let names1 = %0\n  sdo-call %1 = this[1]->ExportedNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#740])\n  return %2\n}","def <SYNTAX>:ModuleItem[1,0].ExportedNames(\n  this: Ast[ModuleItem[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->ExportedNames()\n  return %0\n}","def <SYNTAX>:ModuleItem[0,0].ExportedNames(\n  this: Ast[ModuleItem[0]],\n): List[String] = {\n  return (list [])[#741]\n}","def <SYNTAX>:ModuleItem[2,0].ExportedNames(\n  this: Ast[ModuleItem[2]],\n): List[String] = {\n  return (list [])[#742]\n}","def <SYNTAX>:ExportDeclaration[0,0].ExportedNames(\n  this: Ast[ExportDeclaration[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->ExportedNames()\n  return %0\n}","def <SYNTAX>:ExportFromClause[0,0].ExportedNames(\n  this: Ast[ExportFromClause[0]],\n): List[String] = {\n  return (list [])[#743]\n}","def <SYNTAX>:ExportFromClause[1,0].ExportedNames(\n  this: Ast[ExportFromClause[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->StringValue()\n  return (list [%0])[#744]\n}","def <SYNTAX>:ExportFromClause[2,0].ExportedNames(\n  this: Ast[ExportFromClause[2]],\n): List[String] = {\n  sdo-call %0 = this[0]->ExportedNames()\n  return %0\n}","def <SYNTAX>:ExportDeclaration[2,0].ExportedNames(\n  this: Ast[ExportDeclaration[2]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:ExportDeclaration[3,0].ExportedNames(\n  this: Ast[ExportDeclaration[3]],\n): List[String] = {\n  sdo-call %0 = this[0]->BoundNames()\n  return %0\n}","def <SYNTAX>:ExportDeclaration[4,0].ExportedNames(\n  this: Ast[ExportDeclaration[4]],\n): List[String] = {\n  return (list [\"default\"])[#745]\n}","def <SYNTAX>:ExportDeclaration[5,0].ExportedNames(\n  this: Ast[ExportDeclaration[5]],\n): List[String] = {\n  return (list [\"default\"])[#746]\n}","def <SYNTAX>:ExportDeclaration[6,0].ExportedNames(\n  this: Ast[ExportDeclaration[6]],\n): List[String] = {\n  return (list [\"default\"])[#747]\n}","def <SYNTAX>:NamedExports[0,0].ExportedNames(\n  this: Ast[NamedExports[0]],\n): List[String] = {\n  return (list [])[#748]\n}","def <SYNTAX>:ExportsList[1,0].ExportedNames(\n  this: Ast[ExportsList[1]],\n): List[String] = {\n  sdo-call %0 = this[0]->ExportedNames()\n  let names1 = %0\n  sdo-call %1 = this[1]->ExportedNames()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#749])\n  return %2\n}","def <SYNTAX>:ExportSpecifier[0,0].ExportedNames(\n  this: Ast[ExportSpecifier[0]],\n): List[String] = {\n  sdo-call %0 = this[0]->StringValue()\n  return (list [%0])[#750]\n}","def <SYNTAX>:ExportSpecifier[1,0].ExportedNames(\n  this: Ast[ExportSpecifier[1]],\n): List[String] = {\n  sdo-call %0 = this[1]->StringValue()\n  return (list [%0])[#751]\n}","def <SYNTAX>:Module[0,0].ExportEntries(\n  this: Ast[Module[0]],\n): List[Record[ExportEntryRecord]] = {\n  return (list [])[#752]\n}","def <SYNTAX>:ModuleItemList[1,0].ExportEntries(\n  this: Ast[ModuleItemList[1]],\n): List[Record[ExportEntryRecord]] = {\n  sdo-call %0 = this[0]->ExportEntries()\n  let entries1 = %0\n  sdo-call %1 = this[1]->ExportEntries()\n  let entries2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [entries1, entries2])[#753])\n  return %2\n}","def <SYNTAX>:ModuleItem[0,0].ExportEntries(\n  this: Ast[ModuleItem[0]],\n): List[Record[ExportEntryRecord]] = {\n  return (list [])[#754]\n}","def <SYNTAX>:ModuleItem[2,0].ExportEntries(\n  this: Ast[ModuleItem[2]],\n): List[Record[ExportEntryRecord]] = {\n  return (list [])[#755]\n}","def <SYNTAX>:ExportDeclaration[0,0].ExportEntries(\n  this: Ast[ExportDeclaration[0]],\n): List[Record[ExportEntryRecord]] = {\n  sdo-call %0 = this[1]->ModuleRequests()\n  let module = %0[0]\n  sdo-call %1 = this[0]->ExportEntriesForModule(module)\n  return %1\n}","def <SYNTAX>:ExportDeclaration[1,0].ExportEntries(\n  this: Ast[ExportDeclaration[1]],\n): List[Record[ExportEntryRecord]] = {\n  sdo-call %0 = this[0]->ExportEntriesForModule(null)\n  return %0\n}","def <SYNTAX>:ExportDeclaration[2,0].ExportEntries(\n  this: Ast[ExportDeclaration[2]],\n): List[Record[ExportEntryRecord]] = {\n  let entries = (list [])[#756]\n  sdo-call %0 = this[0]->BoundNames()\n  let names = %0\n  %2 = names\n  %1 = 0\n  while (< %1 (sizeof %2)) {\n    let name = %2[%1]\n    push entries < (record [ExportEntryRecord] {\n      \"ModuleRequest\" : null,\n      \"ImportName\" : null,\n      \"LocalName\" : name,\n      \"ExportName\" : name,\n    })[#757]\n    %1 = (+ %1 1)\n  }\n  return entries\n}","def <SYNTAX>:ExportDeclaration[3,0].ExportEntries(\n  this: Ast[ExportDeclaration[3]],\n): List[Record[ExportEntryRecord]] = {\n  let entries = (list [])[#758]\n  sdo-call %0 = this[0]->BoundNames()\n  let names = %0\n  %2 = names\n  %1 = 0\n  while (< %1 (sizeof %2)) {\n    let name = %2[%1]\n    push entries < (record [ExportEntryRecord] {\n      \"ModuleRequest\" : null,\n      \"ImportName\" : null,\n      \"LocalName\" : name,\n      \"ExportName\" : name,\n    })[#759]\n    %1 = (+ %1 1)\n  }\n  return entries\n}","def <SYNTAX>:ExportDeclaration[4,0].ExportEntries(\n  this: Ast[ExportDeclaration[4]],\n): List[Record[ExportEntryRecord]] = {\n  sdo-call %0 = this[0]->BoundNames()\n  let names = %0\n  let localName = names[0]\n  (yet \"Return a List whose sole element is a new ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _localName_, [[ExportName]]: *\\\"default\\\"* }.\")\n}","def <SYNTAX>:ExportDeclaration[5,0].ExportEntries(\n  this: Ast[ExportDeclaration[5]],\n): List[Record[ExportEntryRecord]] = {\n  sdo-call %0 = this[0]->BoundNames()\n  let names = %0\n  let localName = names[0]\n  (yet \"Return a List whose sole element is a new ExportEntry Record { [[ModuleRequest]]: *null*, [[ImportName]]: *null*, [[LocalName]]: _localName_, [[ExportName]]: *\\\"default\\\"* }.\")\n}","def <SYNTAX>:ExportDeclaration[6,0].ExportEntries(\n  this: Ast[ExportDeclaration[6]],\n): List[Record[ExportEntryRecord]] = {\n  let entry = (record [ExportEntryRecord] {\n    \"ModuleRequest\" : null,\n    \"ImportName\" : null,\n    \"LocalName\" : \"*default*\",\n    \"ExportName\" : \"default\",\n  })[#760]\n  return (list [entry])[#761]\n}","def <SYNTAX>:ExportFromClause[0,0].ExportEntriesForModule(\n  this: Ast[ExportFromClause[0]],\n  module: String | Null,\n): List[Record[ExportEntryRecord]] = {\n  let entry = (record [ExportEntryRecord] {\n    \"ModuleRequest\" : module,\n    \"ImportName\" : ~all-but-default~,\n    \"LocalName\" : null,\n    \"ExportName\" : null,\n  })[#762]\n  return (list [entry])[#763]\n}","def <SYNTAX>:ExportFromClause[1,0].ExportEntriesForModule(\n  this: Ast[ExportFromClause[1]],\n  module: String | Null,\n): List[Record[ExportEntryRecord]] = {\n  sdo-call %0 = this[0]->StringValue()\n  let exportName = %0\n  let entry = (record [ExportEntryRecord] {\n    \"ModuleRequest\" : module,\n    \"ImportName\" : ~all~,\n    \"LocalName\" : null,\n    \"ExportName\" : exportName,\n  })[#764]\n  return (list [entry])[#765]\n}","def <SYNTAX>:NamedExports[0,0].ExportEntriesForModule(\n  this: Ast[NamedExports[0]],\n  module: String | Null,\n): List[Record[ExportEntryRecord]] = {\n  return (list [])[#766]\n}","def <SYNTAX>:ExportsList[1,0].ExportEntriesForModule(\n  this: Ast[ExportsList[1]],\n  module: String | Null,\n): List[Record[ExportEntryRecord]] = {\n  sdo-call %0 = this[0]->ExportEntriesForModule(module)\n  let specs1 = %0\n  sdo-call %1 = this[1]->ExportEntriesForModule(module)\n  let specs2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [specs1, specs2])[#767])\n  return %2\n}","def <SYNTAX>:ExportSpecifier[0,0].ExportEntriesForModule(\n  this: Ast[ExportSpecifier[0]],\n  module: String | Null,\n): List[Record[ExportEntryRecord]] = {\n  sdo-call %0 = this[0]->StringValue()\n  let sourceName = %0\n  if (= module null) {\n    let localName = sourceName\n    let importName = null\n  } else {\n    let localName = null\n    let importName = sourceName\n  }\n  (yet \"Return a List whose sole element is a new ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_, [[ExportName]]: _sourceName_ }.\")\n}","def <SYNTAX>:ExportSpecifier[1,0].ExportEntriesForModule(\n  this: Ast[ExportSpecifier[1]],\n  module: String | Null,\n): List[Record[ExportEntryRecord]] = {\n  sdo-call %0 = this[0]->StringValue()\n  let sourceName = %0\n  sdo-call %1 = this[1]->StringValue()\n  let exportName = %1\n  if (= module null) {\n    let localName = sourceName\n    let importName = null\n  } else {\n    let localName = null\n    let importName = sourceName\n  }\n  (yet \"Return a List whose sole element is a new ExportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: _importName_, [[LocalName]]: _localName_, [[ExportName]]: _exportName_ }.\")\n}","def <SYNTAX>:NamedExports[0,0].ReferencedBindings(\n  this: Ast[NamedExports[0]],\n): List[Ast] = {\n  return (list [])[#768]\n}","def <SYNTAX>:ExportsList[1,0].ReferencedBindings(\n  this: Ast[ExportsList[1]],\n): List[Ast] = {\n  sdo-call %0 = this[0]->ReferencedBindings()\n  let names1 = %0\n  sdo-call %1 = this[1]->ReferencedBindings()\n  let names2 = %1\n  call %2 = clo<\"__FLAT_LIST__\">((list [names1, names2])[#769])\n  return %2\n}","def <SYNTAX>:ExportSpecifier[1,0].ReferencedBindings(\n  this: Ast[ExportSpecifier[1]],\n): List[Ast] = {\n  sdo-call %0 = this[0]->ReferencedBindings()\n  return %0\n}","def <SYNTAX>:ModuleExportName[0,0].ReferencedBindings(\n  this: Ast[ModuleExportName[0]],\n): List[Ast] = {\n  return (list [this[0]])[#770]\n}","def <SYNTAX>:ModuleExportName[1,0].ReferencedBindings(\n  this: Ast[ModuleExportName[1]],\n): List[Ast] = {\n  return (list [this[0]])[#771]\n}","def <SYNTAX>:ExportDeclaration[0,0].Evaluation(\n  this: Ast[ExportDeclaration[0]],\n): Unknown = {\n  call %0 = clo<\"NormalCompletion\">(~empty~)\n  return %0\n}","def <SYNTAX>:ExportDeclaration[1,0].Evaluation(\n  this: Ast[ExportDeclaration[1]],\n): Unknown = {\n  call %0 = clo<\"NormalCompletion\">(~empty~)\n  return %0\n}","def <SYNTAX>:ExportDeclaration[2,0].Evaluation(\n  this: Ast[ExportDeclaration[2]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:ExportDeclaration[3,0].Evaluation(\n  this: Ast[ExportDeclaration[3]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:ExportDeclaration[4,0].Evaluation(\n  this: Ast[ExportDeclaration[4]],\n): Unknown = {\n  sdo-call %0 = this[0]->Evaluation()\n  assert (? %0: Completion)\n  return %0\n}","def <SYNTAX>:ExportDeclaration[5,0].Evaluation(\n  this: Ast[ExportDeclaration[5]],\n): Unknown = {\n  sdo-call %0 = this[0]->BindingClassDeclarationEvaluation()\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let value = %0\n  sdo-call %1 = this[0]->BoundNames()\n  let className = %1[0]\n  if (= className \"*default*\") {\n    let env = @EXECUTION_STACK[0].LexicalEnvironment\n    call %2 = clo<\"InitializeBoundName\">(\"*default*\", value, env)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n  }\n  call %3 = clo<\"NormalCompletion\">(~empty~)\n  return %3\n}","def <SYNTAX>:ExportDeclaration[6,0].Evaluation(\n  this: Ast[ExportDeclaration[6]],\n): Unknown = {\n  call %0 = clo<\"IsAnonymousFunctionDefinition\">(this[0])\n  if (= %0 true) {\n    sdo-call %1 = this[0]->NamedEvaluation(\"default\")\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let value = %1\n  } else {\n    sdo-call %2 = this[0]->Evaluation()\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let rhs = %2\n    call %3 = clo<\"GetValue\">(rhs)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let value = %3\n  }\n  let env = @EXECUTION_STACK[0].LexicalEnvironment\n  call %4 = clo<\"InitializeBoundName\">(\"*default*\", value, env)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  call %5 = clo<\"NormalCompletion\">(~empty~)\n  return %5\n}","def <BUILTIN>:INTRINSICS.eval(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#772]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"PerformEval\">(x, false, false)\n  assert (? %0: Completion)\n  return %0\n}","def PerformEval(\n  x: ESValue,\n  strictCaller: Boolean,\n  direct: Boolean,\n): Normal[ESValue] | Throw = {\n  assert (yet \"If _direct_ is *false*, then _strictCaller_ is also *false*.\")\n  if (! (? x: String)) {\n    if (? x: Completion) return x\n    call %0 = clo<\"NormalCompletion\">(x)\n    return %0\n  }\n  let evalRealm = @EXECUTION_STACK[0].Realm\n  nop\n  call %1 = clo<\"HostEnsureCanCompileStrings\">(evalRealm, (list [])[#773], x, direct)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let inFunction = false\n  let inMethod = false\n  let inDerivedConstructor = false\n  let inClassFieldInitializer = false\n  if (= direct true) {\n    call %2 = clo<\"GetThisEnvironment\">()\n    let thisEnvRec = %2\n    if (? thisEnvRec: Record[FunctionEnvironmentRecord]) {\n      let F = thisEnvRec.FunctionObject\n      inFunction = true\n      call %3 = thisEnvRec.HasSuperBinding(thisEnvRec)\n      inMethod = %3\n      call %4 = clo<\"IsConstructor\">(F)\n      if (&& (= %4 true) (= F.ConstructorKind ~derived~)) {\n        inDerivedConstructor = true\n      }\n      let classFieldInitializerName = F.ClassFieldInitializerName\n      if (! (= classFieldInitializerName ~empty~)) {\n        inClassFieldInitializer = true\n      }\n    }\n  }\n  call %5 = clo<\"StringToCodePoints\">(x)\n  let script = (parse %5 (grammar-symbol |Script|))\n  if (? script: List[Record[Error]]) {\n    call %6 = clo<\"__NEW_ERROR_OBJ__\">(\"%SyntaxError.prototype%\")\n    call %7 = clo<\"ThrowCompletion\">(%6)\n    return %7\n  }\n  sdo-call %8 = script->Contains((grammar-symbol |ScriptBody|))\n  if (= %8 false) {\n    call %9 = clo<\"NormalCompletion\">(undefined)\n    return %9\n  }\n  let body = script.ScriptBody\n  %10 = (= inFunction false)\n  if %10 {\n    sdo-call %11 = body->Contains((grammar-symbol |NewTarget|))\n    %10 = %11\n  }\n  if %10 {\n    call %12 = clo<\"__NEW_ERROR_OBJ__\">(\"%SyntaxError.prototype%\")\n    call %13 = clo<\"ThrowCompletion\">(%12)\n    return %13\n  }\n  %14 = (= inMethod false)\n  if %14 {\n    sdo-call %15 = body->Contains((grammar-symbol |SuperProperty|))\n    %14 = %15\n  }\n  if %14 {\n    call %16 = clo<\"__NEW_ERROR_OBJ__\">(\"%SyntaxError.prototype%\")\n    call %17 = clo<\"ThrowCompletion\">(%16)\n    return %17\n  }\n  %18 = (= inDerivedConstructor false)\n  if %18 {\n    sdo-call %19 = body->Contains((grammar-symbol |SuperCall|))\n    %18 = %19\n  }\n  if %18 {\n    call %20 = clo<\"__NEW_ERROR_OBJ__\">(\"%SyntaxError.prototype%\")\n    call %21 = clo<\"ThrowCompletion\">(%20)\n    return %21\n  }\n  %22 = (= inClassFieldInitializer true)\n  if %22 {\n    sdo-call %23 = body->ContainsArguments()\n    %22 = (= %23 true)\n  }\n  if %22 {\n    call %24 = clo<\"__NEW_ERROR_OBJ__\">(\"%SyntaxError.prototype%\")\n    call %25 = clo<\"ThrowCompletion\">(%24)\n    return %25\n  }\n  if (= strictCaller true) {\n    let strictEval = true\n  } else {\n    sdo-call %26 = script->IsStrict()\n    let strictEval = %26\n  }\n  let runningContext = @EXECUTION_STACK[0]\n  nop\n  if (= direct true) {\n    call %27 = clo<\"NewDeclarativeEnvironment\">(runningContext.LexicalEnvironment)\n    let lexEnv = %27\n    let varEnv = runningContext.VariableEnvironment\n    let privateEnv = runningContext.PrivateEnvironment\n  } else {\n    call %28 = clo<\"NewDeclarativeEnvironment\">(evalRealm.GlobalEnv)\n    let lexEnv = %28\n    let varEnv = evalRealm.GlobalEnv\n    let privateEnv = null\n  }\n  if (= strictEval true) {\n    varEnv = lexEnv\n  }\n  nop\n  let evalContext = (record [ExecutionContext])[#774]\n  evalContext.Function = null\n  evalContext.Realm = evalRealm\n  evalContext.ScriptOrModule = runningContext.ScriptOrModule\n  evalContext.VariableEnvironment = varEnv\n  evalContext.LexicalEnvironment = lexEnv\n  evalContext.PrivateEnvironment = privateEnv\n  push evalContext > @EXECUTION_STACK\n  call %29 = clo<\"EvalDeclarationInstantiation\">(body, varEnv, lexEnv, privateEnv, strictEval)\n  call %30 = clo<\"Completion\">(%29)\n  let result = %30\n  if (&& (? result: Completion) (= result.Type ~normal~)) {\n    sdo-call %31 = body->Evaluation()\n    call %32 = clo<\"Completion\">(%31)\n    result = %32\n  }\n  if (&& (&& (? result: Completion) (= result.Type ~normal~)) (= result.Value ~empty~)) {\n    call %33 = clo<\"NormalCompletion\">(undefined)\n    result = %33\n  }\n  pop %34 < @EXECUTION_STACK\n  nop\n  assert (? result: Completion)\n  return result\n}","def EvalDeclarationInstantiation(\n  body: Unknown[\"ScriptBodyParseNode\"],\n  varEnv: Record[EnvironmentRecord],\n  lexEnv: Record[DeclarativeEnvironmentRecord],\n  privateEnv: Record[PrivateEnvironmentRecord] | Null,\n  strict: Boolean,\n): Normal[Enum[~unused~]] | Throw = {\n  sdo-call %0 = body->VarDeclaredNames()\n  let varNames = %0\n  sdo-call %1 = body->VarScopedDeclarations()\n  let varDeclarations = %1\n  if (= strict false) {\n    if (? varEnv: Record[GlobalEnvironmentRecord]) {\n      %3 = varNames\n      %2 = 0\n      while (< %2 (sizeof %3)) {\n        let name = %3[%2]\n        call %4 = varEnv.HasLexicalDeclaration(varEnv, name)\n        if (= %4 true) {\n          call %5 = clo<\"__NEW_ERROR_OBJ__\">(\"%SyntaxError.prototype%\")\n          call %6 = clo<\"ThrowCompletion\">(%5)\n          return %6\n        }\n        nop\n        %2 = (+ %2 1)\n      }\n    }\n    let thisEnv = lexEnv\n    assert (yet \"The following loop will terminate.\")\n    while (! (= thisEnv varEnv)) {\n      if (! (? thisEnv: Record[ObjectEnvironmentRecord])) {\n        nop\n        %8 = varNames\n        %7 = 0\n        while (< %7 (sizeof %8)) {\n          let name = %8[%7]\n          call %9 = thisEnv.HasBinding(thisEnv, name)\n          assert (? %9: Normal)\n          %9 = %9.Value\n          if (= %9 true) {\n            call %10 = clo<\"__NEW_ERROR_OBJ__\">(\"%SyntaxError.prototype%\")\n            call %11 = clo<\"ThrowCompletion\">(%10)\n            return %11\n            nop\n          }\n          nop\n          %7 = (+ %7 1)\n        }\n      }\n      thisEnv = thisEnv.OuterEnv\n    }\n  }\n  let privateIdentifiers = (list [])[#775]\n  let pointer = privateEnv\n  while (! (= pointer null)) {\n    %13 = pointer.Names\n    %12 = 0\n    while (< %12 (sizeof %13)) {\n      let binding = %13[%12]\n      if (? binding: Record[PrivateName]) {\n        if (! (contains privateIdentifiers binding.Description)) {\n          push privateIdentifiers < binding.Description\n        }\n      }\n      %12 = (+ %12 1)\n    }\n    pointer = pointer.OuterPrivateEnvironment\n  }\n  sdo-call %14 = body->AllPrivateIdentifiersValid(privateIdentifiers)\n  if (= %14 false) {\n    call %15 = clo<\"__NEW_ERROR_OBJ__\">(\"%SyntaxError.prototype%\")\n    call %16 = clo<\"ThrowCompletion\">(%15)\n    return %16\n  }\n  let functionsToInitialize = (list [])[#776]\n  let declaredFunctionNames = (list [])[#777]\n  %18 = varDeclarations\n  %17 = (sizeof %18)\n  while (< 0 %17) {\n    %17 = (- %17 1)\n    let d = %18[%17]\n    if (! (? d: Ast[BindingIdentifier | ForBinding | VariableDeclaration])) {\n      assert (? d: Ast[AsyncFunctionDeclaration | AsyncGeneratorDeclaration | FunctionDeclaration | GeneratorDeclaration])\n      nop\n      sdo-call %19 = d->BoundNames()\n      let fn = %19[0]\n      if (! (contains declaredFunctionNames fn)) {\n        if (? varEnv: Record[GlobalEnvironmentRecord]) {\n          call %20 = varEnv.CanDeclareGlobalFunction(varEnv, fn)\n          assert (? %20: Completion)\n          if (? %20: Abrupt) return %20\n          else %20 = %20.Value\n          let fnDefinable = %20\n          if (= fnDefinable false) {\n            call %21 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n            call %22 = clo<\"ThrowCompletion\">(%21)\n            return %22\n          }\n        }\n        push declaredFunctionNames < fn\n        push d > functionsToInitialize\n      }\n    }\n  }\n  let declaredVarNames = (list [])[#778]\n  %24 = varDeclarations\n  %23 = 0\n  while (< %23 (sizeof %24)) {\n    let d = %24[%23]\n    if (? d: Ast[BindingIdentifier | ForBinding | VariableDeclaration]) {\n      sdo-call %27 = d->BoundNames()\n      %26 = %27\n      %25 = 0\n      while (< %25 (sizeof %26)) {\n        let vn = %26[%25]\n        if (? vn: String) {\n          if (! (contains declaredFunctionNames vn)) {\n            if (? varEnv: Record[GlobalEnvironmentRecord]) {\n              call %28 = varEnv.CanDeclareGlobalVar(varEnv, vn)\n              assert (? %28: Completion)\n              if (? %28: Abrupt) return %28\n              else %28 = %28.Value\n              let vnDefinable = %28\n              if (= vnDefinable false) {\n                call %29 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n                call %30 = clo<\"ThrowCompletion\">(%29)\n                return %30\n              }\n            }\n            if (! (contains declaredVarNames vn)) {\n              push declaredVarNames < vn\n            }\n          }\n        }\n        %25 = (+ %25 1)\n      }\n    }\n    %23 = (+ %23 1)\n  }\n  nop\n  nop\n  sdo-call %31 = body->LexicallyScopedDeclarations()\n  let lexDeclarations = %31\n  %33 = lexDeclarations\n  %32 = 0\n  while (< %32 (sizeof %33)) {\n    let d = %33[%32]\n    nop\n    sdo-call %36 = d->BoundNames()\n    %35 = %36\n    %34 = 0\n    while (< %34 (sizeof %35)) {\n      let dn = %35[%34]\n      sdo-call %37 = d->IsConstantDeclaration()\n      if (= %37 true) {\n        call %38 = lexEnv.CreateImmutableBinding(lexEnv, dn, true)\n        assert (? %38: Completion)\n        if (? %38: Abrupt) return %38\n        else %38 = %38.Value\n      } else {\n        call %39 = lexEnv.CreateMutableBinding(lexEnv, dn, false)\n        assert (? %39: Completion)\n        if (? %39: Abrupt) return %39\n        else %39 = %39.Value\n      }\n      %34 = (+ %34 1)\n    }\n    %32 = (+ %32 1)\n  }\n  %41 = functionsToInitialize\n  %40 = 0\n  while (< %40 (sizeof %41)) {\n    let f = %41[%40]\n    if (? f: Ast) {\n      sdo-call %42 = f->BoundNames()\n      let fn = %42[0]\n      sdo-call %43 = f->InstantiateFunctionObject(lexEnv, privateEnv)\n      let fo = %43\n      if (? varEnv: Record[GlobalEnvironmentRecord]) {\n        call %44 = varEnv.CreateGlobalFunctionBinding(varEnv, fn, fo, true)\n        assert (? %44: Completion)\n        if (? %44: Abrupt) return %44\n        else %44 = %44.Value\n      } else {\n        call %45 = varEnv.HasBinding(varEnv, fn)\n        assert (? %45: Normal)\n        %45 = %45.Value\n        let bindingExists = %45\n        if (= bindingExists false) {\n          nop\n          call %46 = varEnv.CreateMutableBinding(varEnv, fn, true)\n          assert (? %46: Normal)\n          %46 = %46.Value\n          call %47 = varEnv.InitializeBinding(varEnv, fn, fo)\n          assert (? %47: Normal)\n          %47 = %47.Value\n        } else {\n          call %48 = varEnv.SetMutableBinding(varEnv, fn, fo, false)\n          assert (? %48: Normal)\n          %48 = %48.Value\n        }\n      }\n    }\n    %40 = (+ %40 1)\n  }\n  %50 = declaredVarNames\n  %49 = 0\n  while (< %49 (sizeof %50)) {\n    let vn = %50[%49]\n    if (? vn: String) {\n      if (? varEnv: Record[GlobalEnvironmentRecord]) {\n        call %51 = varEnv.CreateGlobalVarBinding(varEnv, vn, true)\n        assert (? %51: Completion)\n        if (? %51: Abrupt) return %51\n        else %51 = %51.Value\n      } else {\n        call %52 = varEnv.HasBinding(varEnv, vn)\n        assert (? %52: Normal)\n        %52 = %52.Value\n        let bindingExists = %52\n        if (= bindingExists false) {\n          nop\n          call %53 = varEnv.CreateMutableBinding(varEnv, vn, true)\n          assert (? %53: Normal)\n          %53 = %53.Value\n          call %54 = varEnv.InitializeBinding(varEnv, vn, undefined)\n          assert (? %54: Normal)\n          %54 = %54.Value\n        }\n      }\n    }\n    %49 = (+ %49 1)\n  }\n  call %55 = clo<\"NormalCompletion\">(~unused~)\n  return %55\n}","def <BUILTIN>:INTRINSICS.isFinite(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#779]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop number < ArgumentsList\n    expand __args__.number\n  } else let number = undefined\n  call %0 = clo<\"ToNumber\">(number)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let num = %0\n  if (|| (= num NaN) (|| (= num +NUM_INF) (= num -NUM_INF))) {\n    call %1 = clo<\"NormalCompletion\">(false)\n    return %1\n  } else {\n    call %2 = clo<\"NormalCompletion\">(true)\n    return %2\n  }\n}","def <BUILTIN>:INTRINSICS.isNaN(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#780]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop number < ArgumentsList\n    expand __args__.number\n  } else let number = undefined\n  call %0 = clo<\"ToNumber\">(number)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let num = %0\n  if (= num NaN) {\n    call %1 = clo<\"NormalCompletion\">(true)\n    return %1\n  } else {\n    call %2 = clo<\"NormalCompletion\">(false)\n    return %2\n  }\n}","def <BUILTIN>:INTRINSICS.parseFloat(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#781]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop string < ArgumentsList\n    expand __args__.string\n  } else let string = undefined\n  call %0 = clo<\"ToString\">(string)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let inputString = %0\n  call %1 = clo<\"TrimString\">(inputString, ~start~)\n  assert (? %1: Normal)\n  %1 = %1.Value\n  let trimmedString = %1\n  call %2 = clo<\"StringToCodePoints\">(trimmedString)\n  let trimmed = %2\n  (yet \"Let _trimmedPrefix_ be the longest prefix of _trimmed_ that satisfies the syntax of a |StrDecimalLiteral|, which might be _trimmed_ itself. If there is no such prefix, return *NaN*.\")\n  let parsedNumber = (parse trimmedPrefix (grammar-symbol |StrDecimalLiteral|))\n  assert (? parsedNumber: Ast)\n  sdo-call %3 = parsedNumber->StringNumericValue()\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.parseInt(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#782]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop string < ArgumentsList\n    expand __args__.string\n  } else let string = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop radix < ArgumentsList\n    expand __args__.radix\n  } else let radix = undefined\n  call %0 = clo<\"ToString\">(string)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let inputString = %0\n  call %1 = clo<\"TrimString\">(inputString, ~start~)\n  assert (? %1: Normal)\n  %1 = %1.Value\n  let S = %1\n  let sign = 1\n  (yet \"If _S_ is not empty and the first code unit of _S_ is the code unit 0x002D (HYPHEN-MINUS), set _sign_ to -1.\")\n  (yet \"If _S_ is not empty and the first code unit of _S_ is either the code unit 0x002B (PLUS SIGN) or the code unit 0x002D (HYPHEN-MINUS), set _S_ to the substring of _S_ from index 1.\")\n  call %2 = clo<\"ToInt32\">(radix)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let R = ([math] %2)\n  let stripPrefix = true\n  if (! (== R 0)) {\n    if (|| (< R 2) (< 36 R)) {\n      call %3 = clo<\"NormalCompletion\">(NaN)\n      return %3\n    }\n    if (! (== R 16)) {\n      stripPrefix = false\n    }\n  } else {\n    R = 10\n  }\n  if (= stripPrefix true) {\n    (yet \"If the length of _S_ is at least 2 and the first two code units of _S_ are either *\\\"0x\\\"* or *\\\"0X\\\"*, then\\n  1. Set _S_ to the substring of _S_ from index 2.\\n  1. Set _R_ to 16.\")\n  }\n  (yet \"If _S_ contains a code unit that is not a radix-_R_ digit, let _end_ be the index within _S_ of the first such code unit; otherwise, let _end_ be the length of _S_.\")\n  let Z = (substring S 0 end)\n  if (= (sizeof Z) 0) {\n    call %4 = clo<\"NormalCompletion\">(NaN)\n    return %4\n  }\n  (yet \"Let _mathInt_ be the integer value that is represented by _Z_ in radix-_R_ notation, using the letters <b>A</b> through <b>Z</b> and <b>a</b> through <b>z</b> for digits with values 10 through 35. (However, if _R_ = 10 and _Z_ contains more than 20 significant digits, every significant digit after the 20th may be replaced by a 0 digit, at the option of the implementation; and if _R_ is not one of 2, 4, 8, 10, 16, or 32, then _mathInt_ may be an implementation-approximated integer representing the integer value denoted by _Z_ in radix-_R_ notation.)\")\n  if (== mathInt 0) {\n    if (== sign (- 1)) {\n      call %5 = clo<\"NormalCompletion\">(-0.0f)\n      return %5\n    }\n    call %6 = clo<\"NormalCompletion\">(0.0f)\n    return %6\n  }\n  %7 = ([number] (* sign mathInt))\n  if (? %7: Completion) return %7\n  call %8 = clo<\"NormalCompletion\">(%7)\n  return %8\n}","def <BUILTIN>:INTRINSICS.decodeURI(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#783]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop encodedURI < ArgumentsList\n    expand __args__.encodedURI\n  } else let encodedURI = undefined\n  call %0 = clo<\"ToString\">(encodedURI)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let uriString = %0\n  let preserveEscapeSet = \";/?:@&=+$,#\"\n  call %1 = clo<\"Decode\">(uriString, preserveEscapeSet)\n  assert (? %1: Completion)\n  return %1\n}","def <BUILTIN>:INTRINSICS.decodeURIComponent(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#784]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop encodedURIComponent < ArgumentsList\n    expand __args__.encodedURIComponent\n  } else let encodedURIComponent = undefined\n  call %0 = clo<\"ToString\">(encodedURIComponent)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let componentString = %0\n  let preserveEscapeSet = \"\"\n  call %1 = clo<\"Decode\">(componentString, preserveEscapeSet)\n  assert (? %1: Completion)\n  return %1\n}","def <BUILTIN>:INTRINSICS.encodeURI(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#785]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop uri < ArgumentsList\n    expand __args__.uri\n  } else let uri = undefined\n  call %0 = clo<\"ToString\">(uri)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let uriString = %0\n  let extraUnescaped = \";/?:@&=+$,#\"\n  call %1 = clo<\"Encode\">(uriString, extraUnescaped)\n  assert (? %1: Completion)\n  return %1\n}","def <BUILTIN>:INTRINSICS.encodeURIComponent(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#786]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop uriComponent < ArgumentsList\n    expand __args__.uriComponent\n  } else let uriComponent = undefined\n  call %0 = clo<\"ToString\">(uriComponent)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let componentString = %0\n  let extraUnescaped = \"\"\n  call %1 = clo<\"Encode\">(componentString, extraUnescaped)\n  assert (? %1: Completion)\n  return %1\n}","def Encode(\n  string: String,\n  extraUnescaped: String,\n): Normal[String] | Throw = {\n  let len = (sizeof string)\n  let R = \"\"\n  (yet \"Let _alwaysUnescaped_ be the string-concatenation of the ASCII word characters and *\\\"-.!~\\\\*'()\\\"*.\")\n  let unescapedSet = (concat alwaysUnescaped extraUnescaped)\n  let k = 0\n  while (< k len) {\n    let C = string[k]\n    if (contains unescapedSet C) {\n      k = (+ k 1)\n      R = (concat R C)\n    } else {\n      call %0 = clo<\"CodePointAt\">(string, k)\n      let cp = %0\n      if (= cp.IsUnpairedSurrogate true) {\n        call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%URIError.prototype%\")\n        call %2 = clo<\"ThrowCompletion\">(%1)\n        return %2\n      }\n      k = (+ k cp.CodeUnitCount)\n      (yet \"Let _Octets_ be the List of octets resulting by applying the UTF-8 transformation to _cp_.[[CodePoint]].\")\n      %4 = Octets\n      %3 = 0\n      while (< %3 (sizeof %4)) {\n        let octet = %4[%3]\n        (yet \"Let _hex_ be the String representation of _octet_, formatted as an uppercase hexadecimal number.\")\n        call %5 = clo<\"StringPad\">(hex, 2, \"0\", ~start~)\n        R = (concat R \"%\" %5)\n        %3 = (+ %3 1)\n      }\n    }\n  }\n  if (? R: Completion) return R\n  call %6 = clo<\"NormalCompletion\">(R)\n  return %6\n}","def Decode(\n  string: String,\n  preserveEscapeSet: String,\n): Normal[String] | Throw = {\n  let len = (sizeof string)\n  let R = \"\"\n  let k = 0\n  while (< k len) {\n    let C = string[k]\n    let S = C\n    if (= C 37cu) {\n      if (< len (+ k 3)) {\n        call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%URIError.prototype%\")\n        call %1 = clo<\"ThrowCompletion\">(%0)\n        return %1\n      }\n      let escape = (substring string k (+ k 3))\n      call %2 = clo<\"ParseHexOctet\">(string, (+ k 1))\n      let B = %2\n      if (! (? B: Int)) {\n        call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%URIError.prototype%\")\n        call %4 = clo<\"ThrowCompletion\">(%3)\n        return %4\n      }\n      k = (+ k 2)\n      (yet \"Let _n_ be the number of leading 1 bits in _B_.\")\n      if (== n 0) {\n        (yet \"Let _asciiChar_ be the code unit whose numeric value is _B_.\")\n        if (contains preserveEscapeSet asciiChar) {\n          (yet \"set _S_ to _escape_. Otherwise, set _S_ to _asciiChar_.\")\n        }\n      } else {\n        if (|| (== n 1) (< 4 n)) {\n          call %5 = clo<\"__NEW_ERROR_OBJ__\">(\"%URIError.prototype%\")\n          call %6 = clo<\"ThrowCompletion\">(%5)\n          return %6\n        }\n        let Octets = (list [B])[#787]\n        let j = 1\n        while (< j n) {\n          k = (+ k 1)\n          if (< len (+ k 3)) {\n            call %7 = clo<\"__NEW_ERROR_OBJ__\">(\"%URIError.prototype%\")\n            call %8 = clo<\"ThrowCompletion\">(%7)\n            return %8\n          }\n          if (! (= string[k] 37cu)) {\n            call %9 = clo<\"__NEW_ERROR_OBJ__\">(\"%URIError.prototype%\")\n            call %10 = clo<\"ThrowCompletion\">(%9)\n            return %10\n          }\n          call %11 = clo<\"ParseHexOctet\">(string, (+ k 1))\n          let continuationByte = %11\n          if (! (? continuationByte: Int)) {\n            call %12 = clo<\"__NEW_ERROR_OBJ__\">(\"%URIError.prototype%\")\n            call %13 = clo<\"ThrowCompletion\">(%12)\n            return %13\n          }\n          push Octets < continuationByte\n          k = (+ k 2)\n          j = (+ j 1)\n        }\n        assert (= (sizeof Octets) n)\n        (yet \"If _Octets_ does not contain a valid UTF-8 encoding of a Unicode code point, throw a *URIError* exception.\")\n        (yet \"Let _V_ be the code point obtained by applying the UTF-8 transformation to _Octets_, that is, from a List of octets into a 21-bit value.\")\n        call %14 = clo<\"UTF16EncodeCodePoint\">(V)\n        S = %14\n      }\n    }\n    R = (concat R S)\n    k = (+ k 1)\n  }\n  if (? R: Completion) return R\n  call %15 = clo<\"NormalCompletion\">(R)\n  return %15\n}","def ParseHexOctet(\n  string: String,\n  position: NonNegInt,\n): Unknown[\"EitherANonnegativeIntegerOrANonemptyListOf*SyntaxError*Object\"] = {\n  let len = (sizeof string)\n  assert (! (< len (+ position 2)))\n  let hexDigits = (substring string position (+ position 2))\n  call %0 = clo<\"StringToCodePoints\">(hexDigits)\n  let parseResult = (parse %0 (grammar-symbol |HexDigits|[F]))\n  if (! (? parseResult: Ast)) {\n    return parseResult\n  }\n  sdo-call %1 = parseResult->MV()\n  let n = %1\n  assert (! (|| (< n 0) (< 255 n)))\n  return n\n}","def <BUILTIN>:INTRINSICS.Object(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#788]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  if (! (|| (= NewTarget undefined) (= NewTarget @EXECUTION_STACK[0].Function))) {\n    call %0 = clo<\"OrdinaryCreateFromConstructor\">(NewTarget, \"%Object.prototype%\")\n    assert (? %0: Completion)\n    return %0\n  }\n  if (|| (= value undefined) (= value null)) {\n    call %1 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Object.prototype%\"])\n    if (? %1: Completion) return %1\n    call %2 = clo<\"NormalCompletion\">(%1)\n    return %2\n  }\n  call %3 = clo<\"ToObject\">(value)\n  assert (? %3: Normal)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Object.assign(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#789]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop target < ArgumentsList\n    expand __args__.target\n  } else let target = undefined\n  let sources = ArgumentsList\n  call %0 = clo<\"ToObject\">(target)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let to = %0\n  if (= (sizeof ArgumentsList) 0) {\n    if (? to: Completion) return to\n    call %1 = clo<\"NormalCompletion\">(to)\n    return %1\n  }\n  %3 = sources\n  %2 = 0\n  while (< %2 (sizeof %3)) {\n    let nextSource = %3[%2]\n    if (! (|| (= nextSource undefined) (= nextSource null))) {\n      call %4 = clo<\"ToObject\">(nextSource)\n      assert (? %4: Normal)\n      %4 = %4.Value\n      let from = %4\n      call %5 = from.OwnPropertyKeys(from)\n      assert (? %5: Completion)\n      if (? %5: Abrupt) return %5\n      else %5 = %5.Value\n      let keys = %5\n      %7 = keys\n      %6 = 0\n      while (< %6 (sizeof %7)) {\n        let nextKey = %7[%6]\n        call %8 = from.GetOwnProperty(from, nextKey)\n        assert (? %8: Completion)\n        if (? %8: Abrupt) return %8\n        else %8 = %8.Value\n        let desc = %8\n        if (&& (! (= desc undefined)) (= desc.Enumerable true)) {\n          call %9 = clo<\"Get\">(from, nextKey)\n          assert (? %9: Completion)\n          if (? %9: Abrupt) return %9\n          else %9 = %9.Value\n          let propValue = %9\n          call %10 = clo<\"Set\">(to, nextKey, propValue, true)\n          assert (? %10: Completion)\n          if (? %10: Abrupt) return %10\n          else %10 = %10.Value\n        }\n        %6 = (+ %6 1)\n      }\n    }\n    %2 = (+ %2 1)\n  }\n  if (? to: Completion) return to\n  call %11 = clo<\"NormalCompletion\">(to)\n  return %11\n}","def <BUILTIN>:INTRINSICS.Object.create(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#790]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop O < ArgumentsList\n    expand __args__.O\n  } else let O = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop Properties < ArgumentsList\n    expand __args__.Properties\n  } else let Properties = undefined\n  if (&& (! (? O: Record[Object])) (! (= O null))) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"OrdinaryObjectCreate\">(O)\n  let obj = %2\n  if (! (= Properties undefined)) {\n    call %3 = clo<\"ObjectDefineProperties\">(obj, Properties)\n    assert (? %3: Completion)\n    return %3\n  }\n  if (? obj: Completion) return obj\n  call %4 = clo<\"NormalCompletion\">(obj)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Object.defineProperties(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#791]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop O < ArgumentsList\n    expand __args__.O\n  } else let O = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop Properties < ArgumentsList\n    expand __args__.Properties\n  } else let Properties = undefined\n  if (! (? O: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"ObjectDefineProperties\">(O, Properties)\n  assert (? %2: Completion)\n  return %2\n}","def ObjectDefineProperties(\n  O: Record[Object],\n  Properties: ESValue,\n): Normal[Record[Object]] | Throw = {\n  call %0 = clo<\"ToObject\">(Properties)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let props = %0\n  call %1 = props.OwnPropertyKeys(props)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let keys = %1\n  let descriptors = (list [])[#792]\n  %3 = keys\n  %2 = 0\n  while (< %2 (sizeof %3)) {\n    let nextKey = %3[%2]\n    call %4 = props.GetOwnProperty(props, nextKey)\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    let propDesc = %4\n    if (&& (! (= propDesc undefined)) (= propDesc.Enumerable true)) {\n      call %5 = clo<\"Get\">(props, nextKey)\n      assert (? %5: Completion)\n      if (? %5: Abrupt) return %5\n      else %5 = %5.Value\n      let descObj = %5\n      call %6 = clo<\"ToPropertyDescriptor\">(descObj)\n      assert (? %6: Completion)\n      if (? %6: Abrupt) return %6\n      else %6 = %6.Value\n      let desc = %6\n      push descriptors < (record {\n        \"Key\" : nextKey,\n        \"Descriptor\" : desc,\n      })[#793]\n    }\n    %2 = (+ %2 1)\n  }\n  %8 = descriptors\n  %7 = 0\n  while (< %7 (sizeof %8)) {\n    let property = %8[%7]\n    call %9 = clo<\"DefinePropertyOrThrow\">(O, property.Key, property.Descriptor)\n    assert (? %9: Completion)\n    if (? %9: Abrupt) return %9\n    else %9 = %9.Value\n    %7 = (+ %7 1)\n  }\n  if (? O: Completion) return O\n  call %10 = clo<\"NormalCompletion\">(O)\n  return %10\n}","def <BUILTIN>:INTRINSICS.Object.defineProperty(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#794]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop O < ArgumentsList\n    expand __args__.O\n  } else let O = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop P < ArgumentsList\n    expand __args__.P\n  } else let P = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop Attributes < ArgumentsList\n    expand __args__.Attributes\n  } else let Attributes = undefined\n  if (! (? O: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"ToPropertyKey\">(P)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let key = %2\n  call %3 = clo<\"ToPropertyDescriptor\">(Attributes)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let desc = %3\n  call %4 = clo<\"DefinePropertyOrThrow\">(O, key, desc)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  if (? O: Completion) return O\n  call %5 = clo<\"NormalCompletion\">(O)\n  return %5\n}","def <BUILTIN>:INTRINSICS.Object.entries(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#795]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop O < ArgumentsList\n    expand __args__.O\n  } else let O = undefined\n  call %0 = clo<\"ToObject\">(O)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let obj = %0\n  call %1 = clo<\"EnumerableOwnProperties\">(obj, ~key+value~)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let entryList = %1\n  call %2 = clo<\"CreateArrayFromList\">(entryList)\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Object.freeze(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#796]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop O < ArgumentsList\n    expand __args__.O\n  } else let O = undefined\n  if (! (? O: Record[Object])) {\n    if (? O: Completion) return O\n    call %0 = clo<\"NormalCompletion\">(O)\n    return %0\n  }\n  call %1 = clo<\"SetIntegrityLevel\">(O, ~frozen~)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let status = %1\n  if (= status false) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  if (? O: Completion) return O\n  call %4 = clo<\"NormalCompletion\">(O)\n  return %4\n}","def <CLO>:INTRINSICS.Object.fromEntries:clo0(\n  this: Unknown,\n  ArgumentsList: Unknown,\n  NewTarget: Unknown,\n): Unknown = {\n  let __args__ = (record)[#797]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop key < ArgumentsList\n    expand __args__.key\n  } else let key = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  call %0 = clo<\"ToPropertyKey\">(key)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let propertyKey = %0\n  call %1 = clo<\"CreateDataPropertyOrThrow\">(obj, propertyKey, value)\n  assert (? %1: Normal)\n  %1 = %1.Value\n  call %2 = clo<\"NormalCompletion\">(undefined)\n  return %2\n}","def <BUILTIN>:INTRINSICS.Object.fromEntries(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#798]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop iterable < ArgumentsList\n    expand __args__.iterable\n  } else let iterable = undefined\n  call %0 = clo<\"RequireObjectCoercible\">(iterable)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Object.prototype%\"])\n  let obj = %1\n  assert (yet \"_obj_ is an extensible ordinary object with no own properties.\")\n  let closure = clo<\"INTRINSICS.Object.fromEntries:clo0\", [obj]>\n  call %2 = clo<\"CreateBuiltinFunction\">(closure, 2, \"\", (list [])[#799])\n  let adder = %2\n  call %3 = clo<\"AddEntriesFromIterable\">(obj, iterable, adder)\n  assert (? %3: Completion)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Object.getOwnPropertyDescriptor(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#800]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop O < ArgumentsList\n    expand __args__.O\n  } else let O = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop P < ArgumentsList\n    expand __args__.P\n  } else let P = undefined\n  call %0 = clo<\"ToObject\">(O)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let obj = %0\n  call %1 = clo<\"ToPropertyKey\">(P)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let key = %1\n  call %2 = obj.GetOwnProperty(obj, key)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let desc = %2\n  call %3 = clo<\"FromPropertyDescriptor\">(desc)\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Object.getOwnPropertyDescriptors(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#801]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop O < ArgumentsList\n    expand __args__.O\n  } else let O = undefined\n  call %0 = clo<\"ToObject\">(O)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let obj = %0\n  call %1 = obj.OwnPropertyKeys(obj)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let ownKeys = %1\n  call %2 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Object.prototype%\"])\n  let descriptors = %2\n  %4 = ownKeys\n  %3 = 0\n  while (< %3 (sizeof %4)) {\n    let key = %4[%3]\n    call %5 = obj.GetOwnProperty(obj, key)\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n    let desc = %5\n    call %6 = clo<\"FromPropertyDescriptor\">(desc)\n    let descriptor = %6\n    if (! (= descriptor undefined)) {\n      call %7 = clo<\"CreateDataPropertyOrThrow\">(descriptors, key, descriptor)\n      assert (? %7: Normal)\n      %7 = %7.Value\n    }\n    %3 = (+ %3 1)\n  }\n  if (? descriptors: Completion) return descriptors\n  call %8 = clo<\"NormalCompletion\">(descriptors)\n  return %8\n}","def <BUILTIN>:INTRINSICS.Object.getOwnPropertyNames(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#802]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop O < ArgumentsList\n    expand __args__.O\n  } else let O = undefined\n  call %0 = clo<\"GetOwnPropertyKeys\">(O, ~string~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"CreateArrayFromList\">(%0)\n  if (? %1: Completion) return %1\n  call %2 = clo<\"NormalCompletion\">(%1)\n  return %2\n}","def <BUILTIN>:INTRINSICS.Object.getOwnPropertySymbols(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#803]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop O < ArgumentsList\n    expand __args__.O\n  } else let O = undefined\n  call %0 = clo<\"GetOwnPropertyKeys\">(O, ~symbol~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"CreateArrayFromList\">(%0)\n  if (? %1: Completion) return %1\n  call %2 = clo<\"NormalCompletion\">(%1)\n  return %2\n}","def GetOwnPropertyKeys(\n  O: ESValue,\n  type: Enum[~string~, ~symbol~],\n): Normal[List[Record[Symbol] | String]] | Throw = {\n  call %0 = clo<\"ToObject\">(O)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let obj = %0\n  call %1 = obj.OwnPropertyKeys(obj)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let keys = %1\n  let nameList = (list [])[#804]\n  %3 = keys\n  %2 = 0\n  while (< %2 (sizeof %3)) {\n    let nextKey = %3[%2]\n    if (|| (&& (? nextKey: Record[Symbol]) (= type ~symbol~)) (&& (? nextKey: String) (= type ~string~))) {\n      push nameList < nextKey\n    }\n    %2 = (+ %2 1)\n  }\n  if (? nameList: Completion) return nameList\n  call %4 = clo<\"NormalCompletion\">(nameList)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Object.getPrototypeOf(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#805]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop O < ArgumentsList\n    expand __args__.O\n  } else let O = undefined\n  call %0 = clo<\"ToObject\">(O)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let obj = %0\n  call %1 = obj.GetPrototypeOf(obj)\n  assert (? %1: Completion)\n  return %1\n}","def <BUILTIN>:INTRINSICS.Object.groupBy(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#806]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop items < ArgumentsList\n    expand __args__.items\n  } else let items = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop callbackfn < ArgumentsList\n    expand __args__.callbackfn\n  } else let callbackfn = undefined\n  call %0 = clo<\"GroupBy\">(items, callbackfn, ~property~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let groups = %0\n  call %1 = clo<\"OrdinaryObjectCreate\">(null)\n  let obj = %1\n  %3 = groups\n  %2 = 0\n  while (< %2 (sizeof %3)) {\n    let g = %3[%2]\n    if (? g: Record[{ Elements, Key }]) {\n      call %4 = clo<\"CreateArrayFromList\">(g.Elements)\n      let elements = %4\n      call %5 = clo<\"CreateDataPropertyOrThrow\">(obj, g.Key, elements)\n      assert (? %5: Normal)\n      %5 = %5.Value\n    }\n    %2 = (+ %2 1)\n  }\n  if (? obj: Completion) return obj\n  call %6 = clo<\"NormalCompletion\">(obj)\n  return %6\n}","def <BUILTIN>:INTRINSICS.Object.hasOwn(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#807]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop O < ArgumentsList\n    expand __args__.O\n  } else let O = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop P < ArgumentsList\n    expand __args__.P\n  } else let P = undefined\n  call %0 = clo<\"ToObject\">(O)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let obj = %0\n  call %1 = clo<\"ToPropertyKey\">(P)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let key = %1\n  call %2 = clo<\"HasOwnProperty\">(obj, key)\n  assert (? %2: Completion)\n  return %2\n}","def <BUILTIN>:INTRINSICS.Object.is(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#808]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value1 < ArgumentsList\n    expand __args__.value1\n  } else let value1 = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value2 < ArgumentsList\n    expand __args__.value2\n  } else let value2 = undefined\n  call %0 = clo<\"SameValue\">(value1, value2)\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <BUILTIN>:INTRINSICS.Object.isExtensible(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#809]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop O < ArgumentsList\n    expand __args__.O\n  } else let O = undefined\n  if (! (? O: Record[Object])) {\n    call %0 = clo<\"NormalCompletion\">(false)\n    return %0\n  }\n  call %1 = clo<\"IsExtensible\">(O)\n  assert (? %1: Completion)\n  return %1\n}","def <BUILTIN>:INTRINSICS.Object.isFrozen(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#810]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop O < ArgumentsList\n    expand __args__.O\n  } else let O = undefined\n  if (! (? O: Record[Object])) {\n    call %0 = clo<\"NormalCompletion\">(true)\n    return %0\n  }\n  call %1 = clo<\"TestIntegrityLevel\">(O, ~frozen~)\n  assert (? %1: Completion)\n  return %1\n}","def <BUILTIN>:INTRINSICS.Object.isSealed(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#811]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop O < ArgumentsList\n    expand __args__.O\n  } else let O = undefined\n  if (! (? O: Record[Object])) {\n    call %0 = clo<\"NormalCompletion\">(true)\n    return %0\n  }\n  call %1 = clo<\"TestIntegrityLevel\">(O, ~sealed~)\n  assert (? %1: Completion)\n  return %1\n}","def <BUILTIN>:INTRINSICS.Object.keys(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#812]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop O < ArgumentsList\n    expand __args__.O\n  } else let O = undefined\n  call %0 = clo<\"ToObject\">(O)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let obj = %0\n  call %1 = clo<\"EnumerableOwnProperties\">(obj, ~key~)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let keyList = %1\n  call %2 = clo<\"CreateArrayFromList\">(keyList)\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Object.preventExtensions(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#813]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop O < ArgumentsList\n    expand __args__.O\n  } else let O = undefined\n  if (! (? O: Record[Object])) {\n    if (? O: Completion) return O\n    call %0 = clo<\"NormalCompletion\">(O)\n    return %0\n  }\n  call %1 = O.PreventExtensions(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let status = %1\n  if (= status false) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  if (? O: Completion) return O\n  call %4 = clo<\"NormalCompletion\">(O)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Object.seal(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#814]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop O < ArgumentsList\n    expand __args__.O\n  } else let O = undefined\n  if (! (? O: Record[Object])) {\n    if (? O: Completion) return O\n    call %0 = clo<\"NormalCompletion\">(O)\n    return %0\n  }\n  call %1 = clo<\"SetIntegrityLevel\">(O, ~sealed~)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let status = %1\n  if (= status false) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  if (? O: Completion) return O\n  call %4 = clo<\"NormalCompletion\">(O)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Object.setPrototypeOf(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#815]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop O < ArgumentsList\n    expand __args__.O\n  } else let O = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop proto < ArgumentsList\n    expand __args__.proto\n  } else let proto = undefined\n  call %0 = clo<\"RequireObjectCoercible\">(O)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  O = %0\n  if (&& (! (? proto: Record[Object])) (! (= proto null))) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  if (! (? O: Record[Object])) {\n    if (? O: Completion) return O\n    call %3 = clo<\"NormalCompletion\">(O)\n    return %3\n  }\n  call %4 = O.SetPrototypeOf(O, proto)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let status = %4\n  if (= status false) {\n    call %5 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %6 = clo<\"ThrowCompletion\">(%5)\n    return %6\n  }\n  if (? O: Completion) return O\n  call %7 = clo<\"NormalCompletion\">(O)\n  return %7\n}","def <BUILTIN>:INTRINSICS.Object.values(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#816]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop O < ArgumentsList\n    expand __args__.O\n  } else let O = undefined\n  call %0 = clo<\"ToObject\">(O)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let obj = %0\n  call %1 = clo<\"EnumerableOwnProperties\">(obj, ~value~)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let valueList = %1\n  call %2 = clo<\"CreateArrayFromList\">(valueList)\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Object.prototype.hasOwnProperty(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#817]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop V < ArgumentsList\n    expand __args__.V\n  } else let V = undefined\n  call %0 = clo<\"ToPropertyKey\">(V)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let P = %0\n  call %1 = clo<\"ToObject\">(this)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let O = %1\n  call %2 = clo<\"HasOwnProperty\">(O, P)\n  assert (? %2: Completion)\n  return %2\n}","def <BUILTIN>:INTRINSICS.Object.prototype.isPrototypeOf(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#818]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop V < ArgumentsList\n    expand __args__.V\n  } else let V = undefined\n  if (! (? V: Record[Object])) {\n    call %0 = clo<\"NormalCompletion\">(false)\n    return %0\n  }\n  call %1 = clo<\"ToObject\">(this)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let O = %1\n  while true {\n    call %2 = V.GetPrototypeOf(V)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    V = %2\n    if (= V null) {\n      call %3 = clo<\"NormalCompletion\">(false)\n      return %3\n    }\n    call %4 = clo<\"SameValue\">(O, V)\n    if (= %4 true) {\n      call %5 = clo<\"NormalCompletion\">(true)\n      return %5\n    }\n  }\n}","def <BUILTIN>:INTRINSICS.Object.prototype.propertyIsEnumerable(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#819]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop V < ArgumentsList\n    expand __args__.V\n  } else let V = undefined\n  call %0 = clo<\"ToPropertyKey\">(V)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let P = %0\n  call %1 = clo<\"ToObject\">(this)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let O = %1\n  call %2 = O.GetOwnProperty(O, P)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let desc = %2\n  if (= desc undefined) {\n    call %3 = clo<\"NormalCompletion\">(false)\n    return %3\n  }\n  %4 = desc.Enumerable\n  if (? %4: Completion) return %4\n  call %5 = clo<\"NormalCompletion\">(%4)\n  return %5\n}","def <BUILTIN>:INTRINSICS.Object.prototype.toLocaleString(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#820]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop reserved1 < ArgumentsList\n    expand __args__.reserved1\n  } else let reserved1 = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop reserved2 < ArgumentsList\n    expand __args__.reserved2\n  } else let reserved2 = undefined\n  let O = this\n  call %0 = clo<\"Invoke\">(O, \"toString\")\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.Object.prototype.toString(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#821]\n  if (= this undefined) {\n    call %0 = clo<\"NormalCompletion\">(\"[object Undefined]\")\n    return %0\n  }\n  if (= this null) {\n    call %1 = clo<\"NormalCompletion\">(\"[object Null]\")\n    return %1\n  }\n  call %2 = clo<\"ToObject\">(this)\n  assert (? %2: Normal)\n  %2 = %2.Value\n  let O = %2\n  call %3 = clo<\"IsArray\">(O)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let isArray = %3\n  if (= isArray true) {\n    let builtinTag = \"Array\"\n  } else {\n    if (exists O.ParameterMap) {\n      let builtinTag = \"Arguments\"\n    } else {\n      if (exists O.Call) {\n        let builtinTag = \"Function\"\n      } else {\n        if (exists O.ErrorData) {\n          let builtinTag = \"Error\"\n        } else {\n          if (exists O.BooleanData) {\n            let builtinTag = \"Boolean\"\n          } else {\n            if (exists O.NumberData) {\n              let builtinTag = \"Number\"\n            } else {\n              if (exists O.StringData) {\n                let builtinTag = \"String\"\n              } else {\n                if (exists O.DateValue) {\n                  let builtinTag = \"Date\"\n                } else {\n                  if (exists O.RegExpMatcher) {\n                    let builtinTag = \"RegExp\"\n                  } else {\n                    let builtinTag = \"Object\"\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  call %4 = clo<\"Get\">(O, @SYMBOL.toStringTag)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let tag = %4\n  if (! (? tag: String)) {\n    tag = builtinTag\n  }\n  %5 = (concat \"[object \" tag \"]\")\n  if (? %5: Completion) return %5\n  call %6 = clo<\"NormalCompletion\">(%5)\n  return %6\n}","def <BUILTIN>:INTRINSICS.Object.prototype.valueOf(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#822]\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.get Object.prototype.__proto__(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#823]\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = O.GetPrototypeOf(O)\n  assert (? %1: Completion)\n  return %1\n}","def <BUILTIN>:INTRINSICS.set Object.prototype.__proto__(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#824]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop proto < ArgumentsList\n    expand __args__.proto\n  } else let proto = undefined\n  call %0 = clo<\"RequireObjectCoercible\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  if (&& (! (? proto: Record[Object])) (! (= proto null))) {\n    call %1 = clo<\"NormalCompletion\">(undefined)\n    return %1\n  }\n  if (! (? O: Record[Object])) {\n    call %2 = clo<\"NormalCompletion\">(undefined)\n    return %2\n  }\n  call %3 = O.SetPrototypeOf(O, proto)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let status = %3\n  if (= status false) {\n    call %4 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %5 = clo<\"ThrowCompletion\">(%4)\n    return %5\n  }\n  call %6 = clo<\"NormalCompletion\">(undefined)\n  return %6\n}","def <BUILTIN>:INTRINSICS.Object.prototype.__defineGetter__(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#825]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop P < ArgumentsList\n    expand __args__.P\n  } else let P = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop getter < ArgumentsList\n    expand __args__.getter\n  } else let getter = undefined\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"IsCallable\">(getter)\n  if (= %1 false) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  let desc = (record [PropertyDescriptor] {\n    \"Get\" : getter,\n    \"Enumerable\" : true,\n    \"Configurable\" : true,\n  })[#826]\n  call %4 = clo<\"ToPropertyKey\">(P)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let key = %4\n  call %5 = clo<\"DefinePropertyOrThrow\">(O, key, desc)\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  call %6 = clo<\"NormalCompletion\">(undefined)\n  return %6\n}","def <BUILTIN>:INTRINSICS.Object.prototype.__defineSetter__(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#827]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop P < ArgumentsList\n    expand __args__.P\n  } else let P = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop setter < ArgumentsList\n    expand __args__.setter\n  } else let setter = undefined\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"IsCallable\">(setter)\n  if (= %1 false) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  let desc = (record [PropertyDescriptor] {\n    \"Set\" : setter,\n    \"Enumerable\" : true,\n    \"Configurable\" : true,\n  })[#828]\n  call %4 = clo<\"ToPropertyKey\">(P)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let key = %4\n  call %5 = clo<\"DefinePropertyOrThrow\">(O, key, desc)\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  call %6 = clo<\"NormalCompletion\">(undefined)\n  return %6\n}","def <BUILTIN>:INTRINSICS.Object.prototype.__lookupGetter__(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#829]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop P < ArgumentsList\n    expand __args__.P\n  } else let P = undefined\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"ToPropertyKey\">(P)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let key = %1\n  while true {\n    call %2 = O.GetOwnProperty(O, key)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let desc = %2\n    if (! (= desc undefined)) {\n      call %3 = clo<\"IsAccessorDescriptor\">(desc)\n      if (= %3 true) {\n        %4 = desc.Get\n        if (? %4: Completion) return %4\n        call %5 = clo<\"NormalCompletion\">(%4)\n        return %5\n      }\n      call %6 = clo<\"NormalCompletion\">(undefined)\n      return %6\n    }\n    call %7 = O.GetPrototypeOf(O)\n    assert (? %7: Completion)\n    if (? %7: Abrupt) return %7\n    else %7 = %7.Value\n    O = %7\n    if (= O null) {\n      call %8 = clo<\"NormalCompletion\">(undefined)\n      return %8\n    }\n  }\n}","def <BUILTIN>:INTRINSICS.Object.prototype.__lookupSetter__(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#830]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop P < ArgumentsList\n    expand __args__.P\n  } else let P = undefined\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"ToPropertyKey\">(P)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let key = %1\n  while true {\n    call %2 = O.GetOwnProperty(O, key)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let desc = %2\n    if (! (= desc undefined)) {\n      call %3 = clo<\"IsAccessorDescriptor\">(desc)\n      if (= %3 true) {\n        %4 = desc.Set\n        if (? %4: Completion) return %4\n        call %5 = clo<\"NormalCompletion\">(%4)\n        return %5\n      }\n      call %6 = clo<\"NormalCompletion\">(undefined)\n      return %6\n    }\n    call %7 = O.GetPrototypeOf(O)\n    assert (? %7: Completion)\n    if (? %7: Abrupt) return %7\n    else %7 = %7.Value\n    O = %7\n    if (= O null) {\n      call %8 = clo<\"NormalCompletion\">(undefined)\n      return %8\n    }\n  }\n}","def <BUILTIN>:INTRINSICS.Function(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#831]\n  let parameterArgs = (list [])[#832]\n  while (< 1 (sizeof ArgumentsList)) {\n    pop %0 < ArgumentsList\n    push parameterArgs < %0\n  }\n  if (< 0 (sizeof ArgumentsList)) {\n    pop bodyArg < ArgumentsList\n    expand __args__.bodyArg\n  } else let bodyArg = undefined\n  let C = @EXECUTION_STACK[0].Function\n  if (! (exists __args__.bodyArg)) {\n    bodyArg = \"\"\n  }\n  call %1 = clo<\"CreateDynamicFunction\">(C, NewTarget, ~normal~, parameterArgs, bodyArg)\n  assert (? %1: Completion)\n  return %1\n}","def CreateDynamicFunction(\n  constructor: Record[Constructor],\n  newTarget: Record[Constructor],\n  kind: Enum[~async-generator~, ~async~, ~generator~, ~normal~],\n  parameterArgs: List[ESValue],\n  bodyArg: ESValue,\n): Normal[Record[ECMAScriptFunctionObject]] | Throw = {\n  if (= newTarget undefined) {\n    newTarget = constructor\n  }\n  if (= kind ~normal~) {\n    let prefix = \"function\"\n    let exprSym = (grammar-symbol |FunctionExpression|)\n    let bodySym = (grammar-symbol |FunctionBody|[FF])\n    let parameterSym = (grammar-symbol |FormalParameters|[FF])\n    let fallbackProto = \"%Function.prototype%\"\n  } else {\n    if (= kind ~generator~) {\n      let prefix = \"function*\"\n      let exprSym = (grammar-symbol |GeneratorExpression|)\n      let bodySym = (grammar-symbol |GeneratorBody|)\n      let parameterSym = (grammar-symbol |FormalParameters|[TF])\n      let fallbackProto = \"%GeneratorFunction.prototype%\"\n    } else {\n      if (= kind ~async~) {\n        let prefix = \"async function\"\n        let exprSym = (grammar-symbol |AsyncFunctionExpression|)\n        let bodySym = (grammar-symbol |AsyncFunctionBody|)\n        let parameterSym = (grammar-symbol |FormalParameters|[FT])\n        let fallbackProto = \"%AsyncFunction.prototype%\"\n      } else {\n        assert (= kind ~async-generator~)\n        let prefix = \"async function*\"\n        let exprSym = (grammar-symbol |AsyncGeneratorExpression|)\n        let bodySym = (grammar-symbol |AsyncGeneratorBody|)\n        let parameterSym = (grammar-symbol |FormalParameters|[TT])\n        let fallbackProto = \"%AsyncGeneratorFunction.prototype%\"\n      }\n    }\n  }\n  let argCount = (sizeof parameterArgs)\n  let parameterStrings = (list [])[#833]\n  %1 = parameterArgs\n  %0 = 0\n  while (< %0 (sizeof %1)) {\n    let arg = %1[%0]\n    call %2 = clo<\"ToString\">(arg)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    push parameterStrings < %2\n    %0 = (+ %0 1)\n  }\n  call %3 = clo<\"ToString\">(bodyArg)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let bodyString = %3\n  let currentRealm = @EXECUTION_STACK[0].Realm\n  call %4 = clo<\"HostEnsureCanCompileStrings\">(currentRealm, parameterStrings, bodyString, false)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let P = \"\"\n  if (< 0 argCount) {\n    P = parameterStrings[0]\n    let k = 1\n    while (< k argCount) {\n      let nextArgString = parameterStrings[k]\n      P = (concat P \",\" nextArgString)\n      k = (+ k 1)\n    }\n  }\n  let bodyParseString = (concat 10cu bodyString 10cu)\n  let sourceString = (concat prefix \" anonymous(\" P 10cu \") {\" bodyParseString \"}\")\n  call %5 = clo<\"StringToCodePoints\">(sourceString)\n  let sourceText = %5\n  call %6 = clo<\"StringToCodePoints\">(P)\n  let parameters = (parse %6 parameterSym)\n  if (? parameters: List[Record[Error]]) {\n    call %7 = clo<\"__NEW_ERROR_OBJ__\">(\"%SyntaxError.prototype%\")\n    call %8 = clo<\"ThrowCompletion\">(%7)\n    return %8\n  }\n  call %9 = clo<\"StringToCodePoints\">(bodyParseString)\n  let body = (parse %9 bodySym)\n  if (? body: List[Record[Error]]) {\n    call %10 = clo<\"__NEW_ERROR_OBJ__\">(\"%SyntaxError.prototype%\")\n    call %11 = clo<\"ThrowCompletion\">(%10)\n    return %11\n  }\n  nop\n  nop\n  let expr = (parse sourceText exprSym)\n  if (? expr: List[Record[Error]]) {\n    call %12 = clo<\"__NEW_ERROR_OBJ__\">(\"%SyntaxError.prototype%\")\n    call %13 = clo<\"ThrowCompletion\">(%12)\n    return %13\n  }\n  call %14 = clo<\"GetPrototypeFromConstructor\">(newTarget, fallbackProto)\n  assert (? %14: Completion)\n  if (? %14: Abrupt) return %14\n  else %14 = %14.Value\n  let proto = %14\n  let env = currentRealm.GlobalEnv\n  let privateEnv = null\n  call %15 = clo<\"OrdinaryFunctionCreate\">(proto, sourceText, parameters, body, ~non-lexical-this~, env, privateEnv)\n  let F = %15\n  call %16 = clo<\"SetFunctionName\">(F, \"anonymous\")\n  if (= kind ~generator~) {\n    call %17 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%GeneratorFunction.prototype.prototype%\"])\n    let prototype = %17\n    call %18 = clo<\"DefinePropertyOrThrow\">(F, \"prototype\", (record [PropertyDescriptor] {\n      \"Value\" : prototype,\n      \"Writable\" : true,\n      \"Enumerable\" : false,\n      \"Configurable\" : false,\n    })[#834])\n    assert (? %18: Normal)\n    %18 = %18.Value\n  } else {\n    if (= kind ~async-generator~) {\n      call %19 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%AsyncGeneratorFunction.prototype.prototype%\"])\n      let prototype = %19\n      call %20 = clo<\"DefinePropertyOrThrow\">(F, \"prototype\", (record [PropertyDescriptor] {\n        \"Value\" : prototype,\n        \"Writable\" : true,\n        \"Enumerable\" : false,\n        \"Configurable\" : false,\n      })[#835])\n      assert (? %20: Normal)\n      %20 = %20.Value\n    } else {\n      if (= kind ~normal~) {\n        call %21 = clo<\"MakeConstructor\">(F)\n      }\n    }\n  }\n  nop\n  if (? F: Completion) return F\n  call %22 = clo<\"NormalCompletion\">(F)\n  return %22\n}","def <BUILTIN>:INTRINSICS.Function.prototype.apply(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#836]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop thisArg < ArgumentsList\n    expand __args__.thisArg\n  } else let thisArg = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop argArray < ArgumentsList\n    expand __args__.argArray\n  } else let argArray = undefined\n  let func = this\n  call %0 = clo<\"IsCallable\">(func)\n  if (= %0 false) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  if (|| (= argArray undefined) (= argArray null)) {\n    call %3 = clo<\"PrepareForTailCall\">()\n    call %4 = clo<\"Call\">(func, thisArg)\n    assert (? %4: Completion)\n    return %4\n  }\n  call %5 = clo<\"CreateListFromArrayLike\">(argArray)\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  let argList = %5\n  call %6 = clo<\"PrepareForTailCall\">()\n  call %7 = clo<\"Call\">(func, thisArg, argList)\n  assert (? %7: Completion)\n  return %7\n}","def <BUILTIN>:INTRINSICS.Function.prototype.bind(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#837]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop thisArg < ArgumentsList\n    expand __args__.thisArg\n  } else let thisArg = undefined\n  let args = ArgumentsList\n  let Target = this\n  call %0 = clo<\"IsCallable\">(Target)\n  if (= %0 false) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  call %3 = clo<\"BoundFunctionCreate\">(Target, thisArg, args)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let F = %3\n  let L = 0\n  call %4 = clo<\"HasOwnProperty\">(Target, \"length\")\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let targetHasLength = %4\n  if (= targetHasLength true) {\n    call %5 = clo<\"Get\">(Target, \"length\")\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n    let targetLen = %5\n    if (? targetLen: Number) {\n      if (= targetLen +NUM_INF) {\n        L = +INF\n      } else {\n        if (= targetLen -NUM_INF) {\n          L = 0\n        } else {\n          call %6 = clo<\"ToIntegerOrInfinity\">(targetLen)\n          assert (? %6: Normal)\n          %6 = %6.Value\n          let targetLenAsInt = %6\n          assert (! (|| (= targetLenAsInt NaN) (|| (= targetLenAsInt +NUM_INF) (= targetLenAsInt -NUM_INF))))\n          let argCount = (sizeof args)\n          L = (max (- targetLenAsInt argCount) 0)\n        }\n      }\n    }\n  }\n  call %7 = clo<\"SetFunctionLength\">(F, L)\n  call %8 = clo<\"Get\">(Target, \"name\")\n  assert (? %8: Completion)\n  if (? %8: Abrupt) return %8\n  else %8 = %8.Value\n  let targetName = %8\n  if (! (? targetName: String)) {\n    targetName = \"\"\n  }\n  call %9 = clo<\"SetFunctionName\">(F, targetName, \"bound\")\n  if (? F: Completion) return F\n  call %10 = clo<\"NormalCompletion\">(F)\n  return %10\n}","def <BUILTIN>:INTRINSICS.Function.prototype.call(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#838]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop thisArg < ArgumentsList\n    expand __args__.thisArg\n  } else let thisArg = undefined\n  let args = ArgumentsList\n  let func = this\n  call %0 = clo<\"IsCallable\">(func)\n  if (= %0 false) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  call %3 = clo<\"PrepareForTailCall\">()\n  call %4 = clo<\"Call\">(func, thisArg, args)\n  assert (? %4: Completion)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Function.prototype[@@hasInstance](\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#839]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop V < ArgumentsList\n    expand __args__.V\n  } else let V = undefined\n  let F = this\n  call %0 = clo<\"OrdinaryHasInstance\">(F, V)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.Boolean(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#840]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  call %0 = clo<\"ToBoolean\">(value)\n  let b = %0\n  if (= NewTarget undefined) {\n    if (? b: Completion) return b\n    call %1 = clo<\"NormalCompletion\">(b)\n    return %1\n  }\n  call %2 = clo<\"OrdinaryCreateFromConstructor\">(NewTarget, \"%Boolean.prototype%\", (list [\"BooleanData\"])[#841])\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let O = %2\n  O.BooleanData = b\n  if (? O: Completion) return O\n  call %3 = clo<\"NormalCompletion\">(O)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Boolean.prototype.toString(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#842]\n  call %0 = clo<\"ThisBooleanValue\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let b = %0\n  if (= b true) {\n    call %1 = clo<\"NormalCompletion\">(\"true\")\n    return %1\n  } else {\n    call %2 = clo<\"NormalCompletion\">(\"false\")\n    return %2\n  }\n}","def <BUILTIN>:INTRINSICS.Boolean.prototype.valueOf(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#843]\n  call %0 = clo<\"ThisBooleanValue\">(this)\n  assert (? %0: Completion)\n  return %0\n}","def ThisBooleanValue(\n  value: ESValue,\n): Normal[Boolean] | Throw = {\n  if (? value: Boolean) {\n    if (? value: Completion) return value\n    call %0 = clo<\"NormalCompletion\">(value)\n    return %0\n  }\n  if (&& (? value: Record[Object]) (exists value.BooleanData)) {\n    let b = value.BooleanData\n    assert (? b: Boolean)\n    if (? b: Completion) return b\n    call %1 = clo<\"NormalCompletion\">(b)\n    return %1\n  }\n  call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n  call %3 = clo<\"ThrowCompletion\">(%2)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Symbol(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#844]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop description < ArgumentsList\n    expand __args__.description\n  } else let description = undefined\n  if (! (= NewTarget undefined)) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  if (= description undefined) {\n    let descString = undefined\n  } else {\n    call %2 = clo<\"ToString\">(description)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let descString = %2\n  }\n  %3 = (record [Symbol] {\n    \"Description\" : descString,\n  })[#845]\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Symbol.for(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#846]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop key < ArgumentsList\n    expand __args__.key\n  } else let key = undefined\n  call %0 = clo<\"ToString\">(key)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let stringKey = %0\n  (yet \"For each element _e_ of the GlobalSymbolRegistry List, do\\n  1. If SameValue(_e_.[[Key]], _stringKey_) is *true*, return _e_.[[Symbol]].\")\n  assert (yet \"GlobalSymbolRegistry does not currently contain an entry for _stringKey_.\")\n  let newSymbol = (record [Symbol] {\n    \"Description\" : stringKey,\n  })[#847]\n  (yet \"Append the Record { [[Key]]: _stringKey_, [[Symbol]]: _newSymbol_ } to the GlobalSymbolRegistry List.\")\n  if (? newSymbol: Completion) return newSymbol\n  call %1 = clo<\"NormalCompletion\">(newSymbol)\n  return %1\n}","def <BUILTIN>:INTRINSICS.Symbol.keyFor(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#848]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop sym < ArgumentsList\n    expand __args__.sym\n  } else let sym = undefined\n  if (! (? sym: Record[Symbol])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"KeyForSymbol\">(sym)\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <BUILTIN>:INTRINSICS.get Symbol.prototype.description(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#849]\n  let s = this\n  call %0 = clo<\"ThisSymbolValue\">(s)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let sym = %0\n  %1 = sym.Description\n  if (? %1: Completion) return %1\n  call %2 = clo<\"NormalCompletion\">(%1)\n  return %2\n}","def <BUILTIN>:INTRINSICS.Symbol.prototype.toString(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#850]\n  call %0 = clo<\"ThisSymbolValue\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let sym = %0\n  call %1 = clo<\"SymbolDescriptiveString\">(sym)\n  if (? %1: Completion) return %1\n  call %2 = clo<\"NormalCompletion\">(%1)\n  return %2\n}","def SymbolDescriptiveString(\n  sym: Record[Symbol],\n): String = {\n  let desc = sym.Description\n  if (= desc undefined) {\n    desc = \"\"\n  }\n  assert (? desc: String)\n  return (concat \"Symbol(\" desc \")\")\n}","def <BUILTIN>:INTRINSICS.Symbol.prototype.valueOf(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#851]\n  call %0 = clo<\"ThisSymbolValue\">(this)\n  assert (? %0: Completion)\n  return %0\n}","def ThisSymbolValue(\n  value: ESValue,\n): Normal[Record[Symbol]] | Throw = {\n  if (? value: Record[Symbol]) {\n    if (? value: Completion) return value\n    call %0 = clo<\"NormalCompletion\">(value)\n    return %0\n  }\n  if (&& (? value: Record[Object]) (exists value.SymbolData)) {\n    let s = value.SymbolData\n    assert (? s: Record[Symbol])\n    if (? s: Completion) return s\n    call %1 = clo<\"NormalCompletion\">(s)\n    return %1\n  }\n  call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n  call %3 = clo<\"ThrowCompletion\">(%2)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Symbol.prototype[@@toPrimitive](\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#852]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop hint < ArgumentsList\n    expand __args__.hint\n  } else let hint = undefined\n  call %0 = clo<\"ThisSymbolValue\">(this)\n  assert (? %0: Completion)\n  return %0\n}","def KeyForSymbol(\n  sym: Record[Symbol],\n): String | Undefined = {\n  (yet \"For each element _e_ of the GlobalSymbolRegistry List, do\\n  1. If SameValue(_e_.[[Symbol]], _sym_) is *true*, return _e_.[[Key]].\")\n  assert (yet \"GlobalSymbolRegistry does not currently contain an entry for _sym_.\")\n  return undefined\n}","def <BUILTIN>:INTRINSICS.Error(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#853]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop message < ArgumentsList\n    expand __args__.message\n  } else let message = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop options < ArgumentsList\n    expand __args__.options\n  } else let options = undefined\n  if (= NewTarget undefined) {\n    let newTarget = @EXECUTION_STACK[0].Function\n  } else {\n    let newTarget = NewTarget\n  }\n  call %0 = clo<\"OrdinaryCreateFromConstructor\">(newTarget, \"%Error.prototype%\", (list [\"ErrorData\"])[#854])\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  if (! (= message undefined)) {\n    call %1 = clo<\"ToString\">(message)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let msg = %1\n    call %2 = clo<\"CreateNonEnumerableDataPropertyOrThrow\">(O, \"message\", msg)\n  }\n  call %3 = clo<\"InstallErrorCause\">(O, options)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  if (? O: Completion) return O\n  call %4 = clo<\"NormalCompletion\">(O)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Error.prototype.toString(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#855]\n  let O = this\n  if (! (? O: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"Get\">(O, \"name\")\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let name = %2\n  if (= name undefined) {\n    name = \"Error\"\n  } else {\n    call %3 = clo<\"ToString\">(name)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    name = %3\n  }\n  call %4 = clo<\"Get\">(O, \"message\")\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let msg = %4\n  if (= msg undefined) {\n    msg = \"\"\n  } else {\n    call %5 = clo<\"ToString\">(msg)\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n    msg = %5\n  }\n  if (= name \"\") {\n    if (? msg: Completion) return msg\n    call %6 = clo<\"NormalCompletion\">(msg)\n    return %6\n  }\n  if (= msg \"\") {\n    if (? name: Completion) return name\n    call %7 = clo<\"NormalCompletion\">(name)\n    return %7\n  }\n  %8 = (concat name 58cu 32cu msg)\n  if (? %8: Completion) return %8\n  call %9 = clo<\"NormalCompletion\">(%8)\n  return %9\n}","def <BUILTIN>:INTRINSICS._NativeError_(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#856]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop message < ArgumentsList\n    expand __args__.message\n  } else let message = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop options < ArgumentsList\n    expand __args__.options\n  } else let options = undefined\n  if (= NewTarget undefined) {\n    let newTarget = @EXECUTION_STACK[0].Function\n  } else {\n    let newTarget = NewTarget\n  }\n  (yet \"Let _O_ be ? OrdinaryCreateFromConstructor(_newTarget_, <code>\\\"%<var>NativeError</var>.prototype%\\\"</code>, ¬´ [[ErrorData]] ¬ª).\")\n  if (! (= message undefined)) {\n    call %0 = clo<\"ToString\">(message)\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let msg = %0\n    call %1 = clo<\"CreateNonEnumerableDataPropertyOrThrow\">(O, \"message\", msg)\n  }\n  call %2 = clo<\"InstallErrorCause\">(O, options)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  if (? O: Completion) return O\n  call %3 = clo<\"NormalCompletion\">(O)\n  return %3\n}","def <BUILTIN>:INTRINSICS.AggregateError(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#857]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop errors < ArgumentsList\n    expand __args__.errors\n  } else let errors = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop message < ArgumentsList\n    expand __args__.message\n  } else let message = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop options < ArgumentsList\n    expand __args__.options\n  } else let options = undefined\n  if (= NewTarget undefined) {\n    let newTarget = @EXECUTION_STACK[0].Function\n  } else {\n    let newTarget = NewTarget\n  }\n  call %0 = clo<\"OrdinaryCreateFromConstructor\">(newTarget, \"%AggregateError.prototype%\", (list [\"ErrorData\"])[#858])\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  if (! (= message undefined)) {\n    call %1 = clo<\"ToString\">(message)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let msg = %1\n    call %2 = clo<\"CreateNonEnumerableDataPropertyOrThrow\">(O, \"message\", msg)\n  }\n  call %3 = clo<\"InstallErrorCause\">(O, options)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  call %4 = clo<\"GetIterator\">(errors, ~sync~)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  call %5 = clo<\"IteratorToList\">(%4)\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  let errorsList = %5\n  call %6 = clo<\"CreateArrayFromList\">(errorsList)\n  call %7 = clo<\"DefinePropertyOrThrow\">(O, \"errors\", (record [PropertyDescriptor] {\n    \"Configurable\" : true,\n    \"Enumerable\" : false,\n    \"Writable\" : true,\n    \"Value\" : %6,\n  })[#859])\n  assert (? %7: Normal)\n  %7 = %7.Value\n  if (? O: Completion) return O\n  call %8 = clo<\"NormalCompletion\">(O)\n  return %8\n}","def InstallErrorCause(\n  O: Record[Object],\n  options: ESValue,\n): Normal[Enum[~unused~]] | Throw = {\n  %0 = (? options: Record[Object])\n  if %0 {\n    call %1 = clo<\"HasProperty\">(options, \"cause\")\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    %0 = (= %1 true)\n  }\n  if %0 {\n    call %2 = clo<\"Get\">(options, \"cause\")\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let cause = %2\n    call %3 = clo<\"CreateNonEnumerableDataPropertyOrThrow\">(O, \"cause\", cause)\n  }\n  call %4 = clo<\"NormalCompletion\">(~unused~)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Number(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#860]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  if (exists __args__.value) {\n    call %0 = clo<\"ToNumeric\">(value)\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let prim = %0\n    if (? prim: BigInt) {\n      let n = ([number] ([math] prim))\n    } else {\n      let n = prim\n    }\n  } else {\n    let n = 0.0f\n  }\n  if (= NewTarget undefined) {\n    if (? n: Completion) return n\n    call %1 = clo<\"NormalCompletion\">(n)\n    return %1\n  }\n  call %2 = clo<\"OrdinaryCreateFromConstructor\">(NewTarget, \"%Number.prototype%\", (list [\"NumberData\"])[#861])\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let O = %2\n  O.NumberData = n\n  if (? O: Completion) return O\n  call %3 = clo<\"NormalCompletion\">(O)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Number.isFinite(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#862]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop number < ArgumentsList\n    expand __args__.number\n  } else let number = undefined\n  if (! (? number: Number)) {\n    call %0 = clo<\"NormalCompletion\">(false)\n    return %0\n  }\n  if (|| (= number NaN) (|| (= number +NUM_INF) (= number -NUM_INF))) {\n    call %1 = clo<\"NormalCompletion\">(false)\n    return %1\n  } else {\n    call %2 = clo<\"NormalCompletion\">(true)\n    return %2\n  }\n}","def <BUILTIN>:INTRINSICS.Number.isInteger(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#863]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop number < ArgumentsList\n    expand __args__.number\n  } else let number = undefined\n  call %0 = clo<\"IsIntegralNumber\">(number)\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <BUILTIN>:INTRINSICS.Number.isNaN(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#864]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop number < ArgumentsList\n    expand __args__.number\n  } else let number = undefined\n  if (! (? number: Number)) {\n    call %0 = clo<\"NormalCompletion\">(false)\n    return %0\n  }\n  if (= number NaN) {\n    call %1 = clo<\"NormalCompletion\">(true)\n    return %1\n  } else {\n    call %2 = clo<\"NormalCompletion\">(false)\n    return %2\n  }\n}","def <BUILTIN>:INTRINSICS.Number.isSafeInteger(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#865]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop number < ArgumentsList\n    expand __args__.number\n  } else let number = undefined\n  call %0 = clo<\"IsIntegralNumber\">(number)\n  if (= %0 true) {\n    if (! (< (- (** 2 53) 1) (abs ([math] number)))) {\n      call %1 = clo<\"NormalCompletion\">(true)\n      return %1\n    }\n  }\n  call %2 = clo<\"NormalCompletion\">(false)\n  return %2\n}","def <BUILTIN>:INTRINSICS.Number.prototype.toExponential(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#866]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop fractionDigits < ArgumentsList\n    expand __args__.fractionDigits\n  } else let fractionDigits = undefined\n  call %0 = clo<\"ThisNumberValue\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let x = %0\n  call %1 = clo<\"ToIntegerOrInfinity\">(fractionDigits)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let f = %1\n  assert (|| (! (= fractionDigits undefined)) (= f 0))\n  if (|| (= x NaN) (|| (= x +NUM_INF) (= x -NUM_INF))) {\n    call %2 = clo<\"Number::toString\">(x, 10)\n    if (? %2: Completion) return %2\n    call %3 = clo<\"NormalCompletion\">(%2)\n    return %3\n  }\n  if (|| (< f 0) (< 100 f)) {\n    call %4 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %5 = clo<\"ThrowCompletion\">(%4)\n    return %5\n  }\n  x = ([math] x)\n  let s = \"\"\n  if (< x 0) {\n    s = \"-\"\n    x = (- x)\n  }\n  if (== x 0) {\n    (yet \"Let _m_ be the String value consisting of _f_ + 1 occurrences of the code unit 0x0030 (DIGIT ZERO).\")\n    let e = 0\n  } else {\n    if (! (= fractionDigits undefined)) {\n      (yet \"Let _e_ and _n_ be integers such that 10<sup>_f_</sup> ‚â§ _n_ < 10<sup>_f_ + 1</sup> and for which _n_ √ó 10<sup>_e_ - _f_</sup> - _x_ is as close to zero as possible. If there are two such sets of _e_ and _n_, pick the _e_ and _n_ for which _n_ √ó 10<sup>_e_ - _f_</sup> is larger.\")\n    } else {\n      (yet \"Let _e_, _n_, and _ff_ be integers such that _ff_ ‚â• 0, 10<sup>_ff_</sup> ‚â§ _n_ < 10<sup>_ff_ + 1</sup>, ùîΩ(_n_ √ó 10<sup>_e_ - _ff_</sup>) is ùîΩ(_x_), and _ff_ is as small as possible. Note that the decimal representation of _n_ has _ff_ + 1 digits, _n_ is not divisible by 10, and the least significant digit of _n_ is not necessarily uniquely determined by these criteria.\")\n      f = ff\n    }\n    (yet \"Let _m_ be the String value consisting of the digits of the decimal representation of _n_ (in order, with no leading zeroes).\")\n  }\n  if (! (== f 0)) {\n    (yet \"Let _a_ be the first code unit of _m_.\")\n    (yet \"Let _b_ be the other _f_ code units of _m_.\")\n    m = (concat a \".\" b)\n  }\n  if (== e 0) {\n    let c = \"+\"\n    let d = \"0\"\n  } else {\n    if (< 0 e) {\n      let c = \"+\"\n    } else {\n      assert (< e 0)\n      let c = \"-\"\n      e = (- e)\n    }\n    (yet \"Let _d_ be the String value consisting of the digits of the decimal representation of _e_ (in order, with no leading zeroes).\")\n  }\n  m = (concat m \"e\" c d)\n  %6 = (concat s m)\n  if (? %6: Completion) return %6\n  call %7 = clo<\"NormalCompletion\">(%6)\n  return %7\n}","def <BUILTIN>:INTRINSICS.Number.prototype.toFixed(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#867]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop fractionDigits < ArgumentsList\n    expand __args__.fractionDigits\n  } else let fractionDigits = undefined\n  call %0 = clo<\"ThisNumberValue\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let x = %0\n  call %1 = clo<\"ToIntegerOrInfinity\">(fractionDigits)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let f = %1\n  assert (|| (! (= fractionDigits undefined)) (= f 0))\n  if (|| (= f NaN) (|| (= f +NUM_INF) (= f -NUM_INF))) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  if (|| (< f 0) (< 100 f)) {\n    call %4 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %5 = clo<\"ThrowCompletion\">(%4)\n    return %5\n  }\n  if (|| (= x NaN) (|| (= x +NUM_INF) (= x -NUM_INF))) {\n    call %6 = clo<\"Number::toString\">(x, 10)\n    if (? %6: Completion) return %6\n    call %7 = clo<\"NormalCompletion\">(%6)\n    return %7\n  }\n  x = ([math] x)\n  let s = \"\"\n  if (< x 0) {\n    s = \"-\"\n    x = (- x)\n  }\n  if (! (< x (** 10 21))) {\n    call %8 = clo<\"ToString\">(([number] x))\n    assert (? %8: Normal)\n    %8 = %8.Value\n    let m = %8\n  } else {\n    (yet \"Let _n_ be an integer for which _n_ / 10<sup>_f_</sup> - _x_ is as close to zero as possible. If there are two such _n_, pick the larger _n_.\")\n    if (== n 0) {\n      let m = \"0\"\n    } else {\n      (yet \"let _m_ be the String value consisting of the digits of the decimal representation of _n_ (in order, with no leading zeroes).\")\n    }\n    if (! (== f 0)) {\n      let k = (sizeof m)\n      if (! (< f k)) {\n        (yet \"Let _z_ be the String value consisting of _f_ + 1 - _k_ occurrences of the code unit 0x0030 (DIGIT ZERO).\")\n        m = (concat z m)\n        k = (+ f 1)\n      }\n      (yet \"Let _a_ be the first _k_ - _f_ code units of _m_.\")\n      (yet \"Let _b_ be the other _f_ code units of _m_.\")\n      m = (concat a \".\" b)\n    }\n  }\n  %9 = (concat s m)\n  if (? %9: Completion) return %9\n  call %10 = clo<\"NormalCompletion\">(%9)\n  return %10\n}","def <BUILTIN>:INTRINSICS.Number.prototype.toPrecision(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#868]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop precision < ArgumentsList\n    expand __args__.precision\n  } else let precision = undefined\n  call %0 = clo<\"ThisNumberValue\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let x = %0\n  if (= precision undefined) {\n    call %1 = clo<\"ToString\">(x)\n    assert (? %1: Normal)\n    return %1\n  }\n  call %2 = clo<\"ToIntegerOrInfinity\">(precision)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let p = %2\n  if (|| (= x NaN) (|| (= x +NUM_INF) (= x -NUM_INF))) {\n    call %3 = clo<\"Number::toString\">(x, 10)\n    if (? %3: Completion) return %3\n    call %4 = clo<\"NormalCompletion\">(%3)\n    return %4\n  }\n  if (|| (< p 1) (< 100 p)) {\n    call %5 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %6 = clo<\"ThrowCompletion\">(%5)\n    return %6\n  }\n  x = ([math] x)\n  let s = \"\"\n  if (< x 0) {\n    (yet \"Set _s_ to the code unit 0x002D (HYPHEN-MINUS).\")\n    x = (- x)\n  }\n  if (== x 0) {\n    (yet \"Let _m_ be the String value consisting of _p_ occurrences of the code unit 0x0030 (DIGIT ZERO).\")\n    let e = 0\n  } else {\n    (yet \"Let _e_ and _n_ be integers such that 10<sup>_p_ - 1</sup> ‚â§ _n_ < 10<sup>_p_</sup> and for which _n_ √ó 10<sup>_e_ - _p_ + 1</sup> - _x_ is as close to zero as possible. If there are two such sets of _e_ and _n_, pick the _e_ and _n_ for which _n_ √ó 10<sup>_e_ - _p_ + 1</sup> is larger.\")\n    (yet \"Let _m_ be the String value consisting of the digits of the decimal representation of _n_ (in order, with no leading zeroes).\")\n    if (|| (< e (- 6)) (! (< e p))) {\n      assert (! (== e 0))\n      if (! (== p 1)) {\n        (yet \"Let _a_ be the first code unit of _m_.\")\n        (yet \"Let _b_ be the other _p_ - 1 code units of _m_.\")\n        m = (concat a \".\" b)\n      }\n      if (< 0 e) {\n        let c = 43cu\n      } else {\n        assert (< e 0)\n        (yet \"Let _c_ be the code unit 0x002D (HYPHEN-MINUS).\")\n        e = (- e)\n      }\n      (yet \"Let _d_ be the String value consisting of the digits of the decimal representation of _e_ (in order, with no leading zeroes).\")\n      %7 = (concat s m 101cu c d)\n      if (? %7: Completion) return %7\n      call %8 = clo<\"NormalCompletion\">(%7)\n      return %8\n    }\n  }\n  if (== e (- p 1)) {\n    %9 = (concat s m)\n    if (? %9: Completion) return %9\n    call %10 = clo<\"NormalCompletion\">(%9)\n    return %10\n  }\n  if (! (< e 0)) {\n    (yet \"Set _m_ to the string-concatenation of the first _e_ + 1 code units of _m_, the code unit 0x002E (FULL STOP), and the remaining _p_ - (_e_ + 1) code units of _m_.\")\n  } else {\n    (yet \"Set _m_ to the string-concatenation of the code unit 0x0030 (DIGIT ZERO), the code unit 0x002E (FULL STOP), -(_e_ + 1) occurrences of the code unit 0x0030 (DIGIT ZERO), and the String _m_.\")\n  }\n  %11 = (concat s m)\n  if (? %11: Completion) return %11\n  call %12 = clo<\"NormalCompletion\">(%11)\n  return %12\n}","def <BUILTIN>:INTRINSICS.Number.prototype.toString(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#869]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop radix < ArgumentsList\n    expand __args__.radix\n  } else let radix = undefined\n  call %0 = clo<\"ThisNumberValue\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let x = %0\n  if (= radix undefined) {\n    let radixMV = 10\n  } else {\n    call %1 = clo<\"ToIntegerOrInfinity\">(radix)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let radixMV = %1\n  }\n  if (|| (< radixMV 2) (< 36 radixMV)) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  call %4 = clo<\"Number::toString\">(x, radixMV)\n  if (? %4: Completion) return %4\n  call %5 = clo<\"NormalCompletion\">(%4)\n  return %5\n}","def <BUILTIN>:INTRINSICS.Number.prototype.valueOf(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#870]\n  call %0 = clo<\"ThisNumberValue\">(this)\n  assert (? %0: Completion)\n  return %0\n}","def ThisNumberValue(\n  value: ESValue,\n): Normal[Number] | Throw = {\n  if (? value: Number) {\n    if (? value: Completion) return value\n    call %0 = clo<\"NormalCompletion\">(value)\n    return %0\n  }\n  if (&& (? value: Record[Object]) (exists value.NumberData)) {\n    let n = value.NumberData\n    assert (? n: Number)\n    if (? n: Completion) return n\n    call %1 = clo<\"NormalCompletion\">(n)\n    return %1\n  }\n  call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n  call %3 = clo<\"ThrowCompletion\">(%2)\n  return %3\n}","def <BUILTIN>:INTRINSICS.BigInt(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#871]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  if (! (= NewTarget undefined)) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"ToPrimitive\">(value, ~number~)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let prim = %2\n  if (? prim: Number) {\n    call %3 = clo<\"NumberToBigInt\">(prim)\n    assert (? %3: Completion)\n    return %3\n  } else {\n    call %4 = clo<\"ToBigInt\">(prim)\n    assert (? %4: Completion)\n    return %4\n  }\n}","def NumberToBigInt(\n  number: Number,\n): Normal[BigInt] | Throw = {\n  call %0 = clo<\"IsIntegralNumber\">(number)\n  if (= %0 false) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  %3 = ([bigInt] ([math] number))\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.BigInt.asIntN(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#872]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop bits < ArgumentsList\n    expand __args__.bits\n  } else let bits = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop bigint < ArgumentsList\n    expand __args__.bigint\n  } else let bigint = undefined\n  call %0 = clo<\"ToIndex\">(bits)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  bits = %0\n  call %1 = clo<\"ToBigInt\">(bigint)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  bigint = %1\n  let mod = (% ([math] bigint) (** 2 bits))\n  if (! (< mod (** 2 (- bits 1)))) {\n    %2 = ([bigInt] (- mod (** 2 bits)))\n    if (? %2: Completion) return %2\n    call %3 = clo<\"NormalCompletion\">(%2)\n    return %3\n  } else {\n    %4 = ([bigInt] mod)\n    if (? %4: Completion) return %4\n    call %5 = clo<\"NormalCompletion\">(%4)\n    return %5\n  }\n}","def <BUILTIN>:INTRINSICS.BigInt.asUintN(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#873]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop bits < ArgumentsList\n    expand __args__.bits\n  } else let bits = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop bigint < ArgumentsList\n    expand __args__.bigint\n  } else let bigint = undefined\n  call %0 = clo<\"ToIndex\">(bits)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  bits = %0\n  call %1 = clo<\"ToBigInt\">(bigint)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  bigint = %1\n  %2 = ([bigInt] (% ([math] bigint) (** 2 bits)))\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <BUILTIN>:INTRINSICS.BigInt.prototype.toString(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#874]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop radix < ArgumentsList\n    expand __args__.radix\n  } else let radix = undefined\n  call %0 = clo<\"ThisBigIntValue\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let x = %0\n  if (= radix undefined) {\n    let radixMV = 10\n  } else {\n    call %1 = clo<\"ToIntegerOrInfinity\">(radix)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let radixMV = %1\n  }\n  if (|| (< radixMV 2) (< 36 radixMV)) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  call %4 = clo<\"BigInt::toString\">(x, radixMV)\n  if (? %4: Completion) return %4\n  call %5 = clo<\"NormalCompletion\">(%4)\n  return %5\n}","def <BUILTIN>:INTRINSICS.BigInt.prototype.valueOf(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#875]\n  call %0 = clo<\"ThisBigIntValue\">(this)\n  assert (? %0: Completion)\n  return %0\n}","def ThisBigIntValue(\n  value: ESValue,\n): Normal[BigInt] | Throw = {\n  if (? value: BigInt) {\n    if (? value: Completion) return value\n    call %0 = clo<\"NormalCompletion\">(value)\n    return %0\n  }\n  if (&& (? value: Record[Object]) (exists value.BigIntData)) {\n    assert (? value.BigIntData: BigInt)\n    %1 = value.BigIntData\n    if (? %1: Completion) return %1\n    call %2 = clo<\"NormalCompletion\">(%1)\n    return %2\n  }\n  call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n  call %4 = clo<\"ThrowCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Math.abs(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#876]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"ToNumber\">(x)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  if (= n NaN) {\n    call %1 = clo<\"NormalCompletion\">(NaN)\n    return %1\n  }\n  if (= n -0.0f) {\n    call %2 = clo<\"NormalCompletion\">(0.0f)\n    return %2\n  }\n  if (= n -NUM_INF) {\n    call %3 = clo<\"NormalCompletion\">(+NUM_INF)\n    return %3\n  }\n  if (< n -0.0f) {\n    %4 = (- n)\n    if (? %4: Completion) return %4\n    call %5 = clo<\"NormalCompletion\">(%4)\n    return %5\n  }\n  if (? n: Completion) return n\n  call %6 = clo<\"NormalCompletion\">(n)\n  return %6\n}","def <BUILTIN>:INTRINSICS.Math.acos(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#877]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"ToNumber\">(x)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  if (|| (= n NaN) (|| (< 1.0f n) (< n -1.0f))) {\n    call %1 = clo<\"NormalCompletion\">(NaN)\n    return %1\n  }\n  if (= n 1.0f) {\n    call %2 = clo<\"NormalCompletion\">(0.0f)\n    return %2\n  }\n  %3 = ([approx-number] ([math:acos] ([math] n)))\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Math.acosh(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#878]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"ToNumber\">(x)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  if (|| (= n NaN) (= n +NUM_INF)) {\n    if (? n: Completion) return n\n    call %1 = clo<\"NormalCompletion\">(n)\n    return %1\n  }\n  if (= n 1.0f) {\n    call %2 = clo<\"NormalCompletion\">(0.0f)\n    return %2\n  }\n  if (< n 1.0f) {\n    call %3 = clo<\"NormalCompletion\">(NaN)\n    return %3\n  }\n  %4 = ([approx-number] ([math:acosh] ([math] n)))\n  if (? %4: Completion) return %4\n  call %5 = clo<\"NormalCompletion\">(%4)\n  return %5\n}","def <BUILTIN>:INTRINSICS.Math.asin(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#879]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"ToNumber\">(x)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  if (|| (|| (= n NaN) (= n 0.0f)) (= n -0.0f)) {\n    if (? n: Completion) return n\n    call %1 = clo<\"NormalCompletion\">(n)\n    return %1\n  }\n  if (|| (< 1.0f n) (< n -1.0f)) {\n    call %2 = clo<\"NormalCompletion\">(NaN)\n    return %2\n  }\n  %3 = ([approx-number] ([math:asin] ([math] n)))\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Math.asinh(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#880]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"ToNumber\">(x)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  if (|| (|| (= n NaN) (|| (= n +NUM_INF) (= n -NUM_INF))) (|| (= n 0.0f) (= n -0.0f))) {\n    if (? n: Completion) return n\n    call %1 = clo<\"NormalCompletion\">(n)\n    return %1\n  }\n  %2 = ([approx-number] ([math:asinh] ([math] n)))\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Math.atan(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#881]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"ToNumber\">(x)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  if (|| (|| (= n NaN) (= n 0.0f)) (= n -0.0f)) {\n    if (? n: Completion) return n\n    call %1 = clo<\"NormalCompletion\">(n)\n    return %1\n  }\n  if (= n +NUM_INF) {\n    %2 = ([approx-number] (/ @MATH_PI 2))\n    if (? %2: Completion) return %2\n    call %3 = clo<\"NormalCompletion\">(%2)\n    return %3\n  }\n  if (= n -NUM_INF) {\n    %4 = ([approx-number] (/ (- @MATH_PI) 2))\n    if (? %4: Completion) return %4\n    call %5 = clo<\"NormalCompletion\">(%4)\n    return %5\n  }\n  %6 = ([approx-number] ([math:atan] ([math] n)))\n  if (? %6: Completion) return %6\n  call %7 = clo<\"NormalCompletion\">(%6)\n  return %7\n}","def <BUILTIN>:INTRINSICS.Math.atanh(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#882]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"ToNumber\">(x)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  if (|| (|| (= n NaN) (= n 0.0f)) (= n -0.0f)) {\n    if (? n: Completion) return n\n    call %1 = clo<\"NormalCompletion\">(n)\n    return %1\n  }\n  if (|| (< 1.0f n) (< n -1.0f)) {\n    call %2 = clo<\"NormalCompletion\">(NaN)\n    return %2\n  }\n  if (= n 1.0f) {\n    call %3 = clo<\"NormalCompletion\">(+NUM_INF)\n    return %3\n  }\n  if (= n -1.0f) {\n    call %4 = clo<\"NormalCompletion\">(-NUM_INF)\n    return %4\n  }\n  %5 = ([approx-number] ([math:atanh] ([math] n)))\n  if (? %5: Completion) return %5\n  call %6 = clo<\"NormalCompletion\">(%5)\n  return %6\n}","def <BUILTIN>:INTRINSICS.Math.atan2(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#883]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop y < ArgumentsList\n    expand __args__.y\n  } else let y = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"ToNumber\">(y)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let ny = %0\n  call %1 = clo<\"ToNumber\">(x)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let nx = %1\n  if (|| (= ny NaN) (= nx NaN)) {\n    call %2 = clo<\"NormalCompletion\">(NaN)\n    return %2\n  }\n  if (= ny +NUM_INF) {\n    if (= nx +NUM_INF) {\n      %3 = ([approx-number] (/ @MATH_PI 4))\n      if (? %3: Completion) return %3\n      call %4 = clo<\"NormalCompletion\">(%3)\n      return %4\n    }\n    if (= nx -NUM_INF) {\n      %5 = ([approx-number] (/ (* 3 @MATH_PI) 4))\n      if (? %5: Completion) return %5\n      call %6 = clo<\"NormalCompletion\">(%5)\n      return %6\n    }\n    %7 = ([approx-number] (/ @MATH_PI 2))\n    if (? %7: Completion) return %7\n    call %8 = clo<\"NormalCompletion\">(%7)\n    return %8\n  }\n  if (= ny -NUM_INF) {\n    if (= nx +NUM_INF) {\n      %9 = ([approx-number] (/ (- @MATH_PI) 4))\n      if (? %9: Completion) return %9\n      call %10 = clo<\"NormalCompletion\">(%9)\n      return %10\n    }\n    if (= nx -NUM_INF) {\n      %11 = ([approx-number] (/ (- (* 3 @MATH_PI)) 4))\n      if (? %11: Completion) return %11\n      call %12 = clo<\"NormalCompletion\">(%11)\n      return %12\n    }\n    %13 = ([approx-number] (/ (- @MATH_PI) 2))\n    if (? %13: Completion) return %13\n    call %14 = clo<\"NormalCompletion\">(%13)\n    return %14\n  }\n  if (= ny 0.0f) {\n    if (|| (< 0.0f nx) (= nx 0.0f)) {\n      call %15 = clo<\"NormalCompletion\">(0.0f)\n      return %15\n    }\n    %16 = ([approx-number] @MATH_PI)\n    if (? %16: Completion) return %16\n    call %17 = clo<\"NormalCompletion\">(%16)\n    return %17\n  }\n  if (= ny -0.0f) {\n    if (|| (< 0.0f nx) (= nx 0.0f)) {\n      call %18 = clo<\"NormalCompletion\">(-0.0f)\n      return %18\n    }\n    %19 = ([approx-number] (- @MATH_PI))\n    if (? %19: Completion) return %19\n    call %20 = clo<\"NormalCompletion\">(%19)\n    return %20\n  }\n  assert (yet \"_ny_ is finite and is neither *+0*<sub>ùîΩ</sub> nor *-0*<sub>ùîΩ</sub>.\")\n  if (< 0.0f ny) {\n    if (= nx +NUM_INF) {\n      call %21 = clo<\"NormalCompletion\">(0.0f)\n      return %21\n    }\n    if (= nx -NUM_INF) {\n      %22 = ([approx-number] @MATH_PI)\n      if (? %22: Completion) return %22\n      call %23 = clo<\"NormalCompletion\">(%22)\n      return %23\n    }\n    if (|| (= nx 0.0f) (= nx -0.0f)) {\n      %24 = ([approx-number] (/ @MATH_PI 2))\n      if (? %24: Completion) return %24\n      call %25 = clo<\"NormalCompletion\">(%24)\n      return %25\n    }\n  }\n  if (< ny -0.0f) {\n    if (= nx +NUM_INF) {\n      call %26 = clo<\"NormalCompletion\">(-0.0f)\n      return %26\n    }\n    if (= nx -NUM_INF) {\n      %27 = ([approx-number] (- @MATH_PI))\n      if (? %27: Completion) return %27\n      call %28 = clo<\"NormalCompletion\">(%27)\n      return %28\n    }\n    if (|| (= nx 0.0f) (= nx -0.0f)) {\n      %29 = ([approx-number] (/ (- @MATH_PI) 2))\n      if (? %29: Completion) return %29\n      call %30 = clo<\"NormalCompletion\">(%29)\n      return %30\n    }\n  }\n  assert (yet \"_nx_ is finite and is neither *+0*<sub>ùîΩ</sub> nor *-0*<sub>ùîΩ</sub>.\")\n  let r = ([math:atan] (abs (/ ([math] ny) ([math] nx))))\n  if (< nx -0.0f) {\n    if (< 0.0f ny) {\n      r = (- @MATH_PI r)\n    } else {\n      r = (+ (- @MATH_PI) r)\n    }\n  } else {\n    if (< ny -0.0f) {\n      r = (- r)\n    }\n  }\n  %31 = ([approx-number] r)\n  if (? %31: Completion) return %31\n  call %32 = clo<\"NormalCompletion\">(%31)\n  return %32\n}","def <BUILTIN>:INTRINSICS.Math.cbrt(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#884]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"ToNumber\">(x)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  if (|| (|| (= n NaN) (|| (= n +NUM_INF) (= n -NUM_INF))) (|| (= n 0.0f) (= n -0.0f))) {\n    if (? n: Completion) return n\n    call %1 = clo<\"NormalCompletion\">(n)\n    return %1\n  }\n  %2 = ([approx-number] ([math:cbrt] ([math] n)))\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Math.ceil(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#885]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"ToNumber\">(x)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  if (|| (|| (= n NaN) (|| (= n +NUM_INF) (= n -NUM_INF))) (|| (= n 0.0f) (= n -0.0f))) {\n    if (? n: Completion) return n\n    call %1 = clo<\"NormalCompletion\">(n)\n    return %1\n  }\n  if (&& (< n -0.0f) (< -1.0f n)) {\n    call %2 = clo<\"NormalCompletion\">(-0.0f)\n    return %2\n  }\n  if (? n: Number[Int]) {\n    if (? n: Completion) return n\n    call %3 = clo<\"NormalCompletion\">(n)\n    return %3\n  }\n  (yet \"Return the smallest (closest to -‚àû) integral Number value that is not less than _n_.\")\n}","def <BUILTIN>:INTRINSICS.Math.clz32(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#886]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"ToUint32\">(x)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  (yet \"Let _p_ be the number of leading zero bits in the unsigned 32-bit binary representation of _n_.\")\n  %1 = ([number] p)\n  if (? %1: Completion) return %1\n  call %2 = clo<\"NormalCompletion\">(%1)\n  return %2\n}","def <BUILTIN>:INTRINSICS.Math.cos(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#887]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"ToNumber\">(x)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  if (|| (= n NaN) (|| (= n +NUM_INF) (= n -NUM_INF))) {\n    call %1 = clo<\"NormalCompletion\">(NaN)\n    return %1\n  }\n  if (|| (= n 0.0f) (= n -0.0f)) {\n    call %2 = clo<\"NormalCompletion\">(1.0f)\n    return %2\n  }\n  %3 = ([approx-number] ([math:cos] ([math] n)))\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Math.cosh(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#888]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"ToNumber\">(x)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  if (= n NaN) {\n    call %1 = clo<\"NormalCompletion\">(NaN)\n    return %1\n  }\n  if (|| (= n +NUM_INF) (= n -NUM_INF)) {\n    call %2 = clo<\"NormalCompletion\">(+NUM_INF)\n    return %2\n  }\n  if (|| (= n 0.0f) (= n -0.0f)) {\n    call %3 = clo<\"NormalCompletion\">(1.0f)\n    return %3\n  }\n  %4 = ([approx-number] ([math:cosh] ([math] n)))\n  if (? %4: Completion) return %4\n  call %5 = clo<\"NormalCompletion\">(%4)\n  return %5\n}","def <BUILTIN>:INTRINSICS.Math.exp(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#889]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"ToNumber\">(x)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  if (|| (= n NaN) (= n +NUM_INF)) {\n    if (? n: Completion) return n\n    call %1 = clo<\"NormalCompletion\">(n)\n    return %1\n  }\n  if (|| (= n 0.0f) (= n -0.0f)) {\n    call %2 = clo<\"NormalCompletion\">(1.0f)\n    return %2\n  }\n  if (= n -NUM_INF) {\n    call %3 = clo<\"NormalCompletion\">(0.0f)\n    return %3\n  }\n  %4 = ([approx-number] ([math:exp] ([math] n)))\n  if (? %4: Completion) return %4\n  call %5 = clo<\"NormalCompletion\">(%4)\n  return %5\n}","def <BUILTIN>:INTRINSICS.Math.expm1(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#890]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"ToNumber\">(x)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  if (|| (|| (|| (= n NaN) (= n 0.0f)) (= n -0.0f)) (= n +NUM_INF)) {\n    if (? n: Completion) return n\n    call %1 = clo<\"NormalCompletion\">(n)\n    return %1\n  }\n  if (= n -NUM_INF) {\n    call %2 = clo<\"NormalCompletion\">(-1.0f)\n    return %2\n  }\n  %3 = ([approx-number] ([math:expm1] ([math] n)))\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Math.floor(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#891]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"ToNumber\">(x)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  if (|| (|| (= n NaN) (|| (= n +NUM_INF) (= n -NUM_INF))) (|| (= n 0.0f) (= n -0.0f))) {\n    if (? n: Completion) return n\n    call %1 = clo<\"NormalCompletion\">(n)\n    return %1\n  }\n  if (&& (< n 1.0f) (< 0.0f n)) {\n    call %2 = clo<\"NormalCompletion\">(0.0f)\n    return %2\n  }\n  if (? n: Number[Int]) {\n    if (? n: Completion) return n\n    call %3 = clo<\"NormalCompletion\">(n)\n    return %3\n  }\n  (yet \"Return the greatest (closest to +‚àû) integral Number value that is not greater than _n_.\")\n}","def <BUILTIN>:INTRINSICS.Math.fround(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#892]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"ToNumber\">(x)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  if (= n NaN) {\n    call %1 = clo<\"NormalCompletion\">(NaN)\n    return %1\n  }\n  if (|| (|| (|| (= n 0.0f) (= n -0.0f)) (= n +NUM_INF)) (= n -NUM_INF)) {\n    if (? n: Completion) return n\n    call %2 = clo<\"NormalCompletion\">(n)\n    return %2\n  }\n  (yet \"Let _n32_ be the result of converting _n_ to IEEE 754-2019 binary32 format using roundTiesToEven mode.\")\n  (yet \"Let _n64_ be the result of converting _n32_ to IEEE 754-2019 binary64 format.\")\n  (yet \"Return the ECMAScript Number value corresponding to _n64_.\")\n}","def <BUILTIN>:INTRINSICS.Math.hypot(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#893]\n  let args = ArgumentsList\n  let coerced = (list [])[#894]\n  %1 = args\n  %0 = 0\n  while (< %0 (sizeof %1)) {\n    let arg = %1[%0]\n    call %2 = clo<\"ToNumber\">(arg)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let n = %2\n    push coerced < n\n    %0 = (+ %0 1)\n  }\n  %4 = coerced\n  %3 = 0\n  while (< %3 (sizeof %4)) {\n    let number = %4[%3]\n    if (|| (= number +NUM_INF) (= number -NUM_INF)) {\n      call %5 = clo<\"NormalCompletion\">(+NUM_INF)\n      return %5\n    }\n    %3 = (+ %3 1)\n  }\n  let onlyZero = true\n  %7 = coerced\n  %6 = 0\n  while (< %6 (sizeof %7)) {\n    let number = %7[%6]\n    if (= number NaN) {\n      call %8 = clo<\"NormalCompletion\">(NaN)\n      return %8\n    }\n    if (! (|| (= number 0.0f) (= number -0.0f))) {\n      onlyZero = false\n    }\n    %6 = (+ %6 1)\n  }\n  if (= onlyZero true) {\n    call %9 = clo<\"NormalCompletion\">(0.0f)\n    return %9\n  }\n  (yet \"Return an implementation-approximated Number value representing the square root of the sum of squares of the mathematical values of the elements of _coerced_.\")\n}","def <BUILTIN>:INTRINSICS.Math.imul(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#895]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop y < ArgumentsList\n    expand __args__.y\n  } else let y = undefined\n  call %0 = clo<\"ToUint32\">(x)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let a = ([math] %0)\n  call %1 = clo<\"ToUint32\">(y)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let b = ([math] %1)\n  let product = (% (* a b) (** 2 32))\n  if (! (< product (** 2 31))) {\n    %2 = ([number] (- product (** 2 32)))\n    if (? %2: Completion) return %2\n    call %3 = clo<\"NormalCompletion\">(%2)\n    return %3\n  } else {\n    %4 = ([number] product)\n    if (? %4: Completion) return %4\n    call %5 = clo<\"NormalCompletion\">(%4)\n    return %5\n  }\n}","def <BUILTIN>:INTRINSICS.Math.log(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#896]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"ToNumber\">(x)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  if (|| (= n NaN) (= n +NUM_INF)) {\n    if (? n: Completion) return n\n    call %1 = clo<\"NormalCompletion\">(n)\n    return %1\n  }\n  if (= n 1.0f) {\n    call %2 = clo<\"NormalCompletion\">(0.0f)\n    return %2\n  }\n  if (|| (= n 0.0f) (= n -0.0f)) {\n    call %3 = clo<\"NormalCompletion\">(-NUM_INF)\n    return %3\n  }\n  if (< n -0.0f) {\n    call %4 = clo<\"NormalCompletion\">(NaN)\n    return %4\n  }\n  %5 = ([approx-number] ([math:log] ([math] n)))\n  if (? %5: Completion) return %5\n  call %6 = clo<\"NormalCompletion\">(%5)\n  return %6\n}","def <BUILTIN>:INTRINSICS.Math.log1p(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#897]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"ToNumber\">(x)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  if (|| (|| (|| (= n NaN) (= n 0.0f)) (= n -0.0f)) (= n +NUM_INF)) {\n    if (? n: Completion) return n\n    call %1 = clo<\"NormalCompletion\">(n)\n    return %1\n  }\n  if (= n -1.0f) {\n    call %2 = clo<\"NormalCompletion\">(-NUM_INF)\n    return %2\n  }\n  if (< n -1.0f) {\n    call %3 = clo<\"NormalCompletion\">(NaN)\n    return %3\n  }\n  %4 = ([approx-number] ([math:log1p] ([math] n)))\n  if (? %4: Completion) return %4\n  call %5 = clo<\"NormalCompletion\">(%4)\n  return %5\n}","def <BUILTIN>:INTRINSICS.Math.log10(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#898]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"ToNumber\">(x)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  if (|| (= n NaN) (= n +NUM_INF)) {\n    if (? n: Completion) return n\n    call %1 = clo<\"NormalCompletion\">(n)\n    return %1\n  }\n  if (= n 1.0f) {\n    call %2 = clo<\"NormalCompletion\">(0.0f)\n    return %2\n  }\n  if (|| (= n 0.0f) (= n -0.0f)) {\n    call %3 = clo<\"NormalCompletion\">(-NUM_INF)\n    return %3\n  }\n  if (< n -0.0f) {\n    call %4 = clo<\"NormalCompletion\">(NaN)\n    return %4\n  }\n  %5 = ([approx-number] ([math:log10] ([math] n)))\n  if (? %5: Completion) return %5\n  call %6 = clo<\"NormalCompletion\">(%5)\n  return %6\n}","def <BUILTIN>:INTRINSICS.Math.log2(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#899]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"ToNumber\">(x)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  if (|| (= n NaN) (= n +NUM_INF)) {\n    if (? n: Completion) return n\n    call %1 = clo<\"NormalCompletion\">(n)\n    return %1\n  }\n  if (= n 1.0f) {\n    call %2 = clo<\"NormalCompletion\">(0.0f)\n    return %2\n  }\n  if (|| (= n 0.0f) (= n -0.0f)) {\n    call %3 = clo<\"NormalCompletion\">(-NUM_INF)\n    return %3\n  }\n  if (< n -0.0f) {\n    call %4 = clo<\"NormalCompletion\">(NaN)\n    return %4\n  }\n  %5 = ([approx-number] ([math:log2] ([math] n)))\n  if (? %5: Completion) return %5\n  call %6 = clo<\"NormalCompletion\">(%5)\n  return %6\n}","def <BUILTIN>:INTRINSICS.Math.max(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#900]\n  let args = ArgumentsList\n  let coerced = (list [])[#901]\n  %1 = args\n  %0 = 0\n  while (< %0 (sizeof %1)) {\n    let arg = %1[%0]\n    call %2 = clo<\"ToNumber\">(arg)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let n = %2\n    push coerced < n\n    %0 = (+ %0 1)\n  }\n  let highest = -NUM_INF\n  %4 = coerced\n  %3 = 0\n  while (< %3 (sizeof %4)) {\n    let number = %4[%3]\n    if (= number NaN) {\n      call %5 = clo<\"NormalCompletion\">(NaN)\n      return %5\n    }\n    if (&& (= number 0.0f) (= highest -0.0f)) {\n      highest = 0.0f\n    }\n    if (< highest number) {\n      highest = number\n    }\n    %3 = (+ %3 1)\n  }\n  if (? highest: Completion) return highest\n  call %6 = clo<\"NormalCompletion\">(highest)\n  return %6\n}","def <BUILTIN>:INTRINSICS.Math.min(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#902]\n  let args = ArgumentsList\n  let coerced = (list [])[#903]\n  %1 = args\n  %0 = 0\n  while (< %0 (sizeof %1)) {\n    let arg = %1[%0]\n    call %2 = clo<\"ToNumber\">(arg)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let n = %2\n    push coerced < n\n    %0 = (+ %0 1)\n  }\n  let lowest = +NUM_INF\n  %4 = coerced\n  %3 = 0\n  while (< %3 (sizeof %4)) {\n    let number = %4[%3]\n    if (= number NaN) {\n      call %5 = clo<\"NormalCompletion\">(NaN)\n      return %5\n    }\n    if (&& (= number -0.0f) (= lowest 0.0f)) {\n      lowest = -0.0f\n    }\n    if (< number lowest) {\n      lowest = number\n    }\n    %3 = (+ %3 1)\n  }\n  if (? lowest: Completion) return lowest\n  call %6 = clo<\"NormalCompletion\">(lowest)\n  return %6\n}","def <BUILTIN>:INTRINSICS.Math.pow(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#904]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop base < ArgumentsList\n    expand __args__.base\n  } else let base = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop exponent < ArgumentsList\n    expand __args__.exponent\n  } else let exponent = undefined\n  call %0 = clo<\"ToNumber\">(base)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  base = %0\n  call %1 = clo<\"ToNumber\">(exponent)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  exponent = %1\n  call %2 = clo<\"Number::exponentiate\">(base, exponent)\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Math.round(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#905]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"ToNumber\">(x)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  if (|| (|| (= n NaN) (|| (= n +NUM_INF) (= n -NUM_INF))) (? n: Number[Int])) {\n    if (? n: Completion) return n\n    call %1 = clo<\"NormalCompletion\">(n)\n    return %1\n  }\n  if (&& (< n 0.5f) (< 0.0f n)) {\n    call %2 = clo<\"NormalCompletion\">(0.0f)\n    return %2\n  }\n  if (&& (< n -0.0f) (! (< n -0.5f))) {\n    call %3 = clo<\"NormalCompletion\">(-0.0f)\n    return %3\n  }\n  (yet \"Return the integral Number closest to _n_, preferring the Number closer to +‚àû in the case of a tie.\")\n}","def <BUILTIN>:INTRINSICS.Math.sign(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#906]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"ToNumber\">(x)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  if (|| (|| (= n NaN) (= n 0.0f)) (= n -0.0f)) {\n    if (? n: Completion) return n\n    call %1 = clo<\"NormalCompletion\">(n)\n    return %1\n  }\n  if (< n -0.0f) {\n    call %2 = clo<\"NormalCompletion\">(-1.0f)\n    return %2\n  }\n  call %3 = clo<\"NormalCompletion\">(1.0f)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Math.sin(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#907]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"ToNumber\">(x)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  if (|| (|| (= n NaN) (= n 0.0f)) (= n -0.0f)) {\n    if (? n: Completion) return n\n    call %1 = clo<\"NormalCompletion\">(n)\n    return %1\n  }\n  if (|| (= n +NUM_INF) (= n -NUM_INF)) {\n    call %2 = clo<\"NormalCompletion\">(NaN)\n    return %2\n  }\n  %3 = ([approx-number] ([math:sin] ([math] n)))\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Math.sinh(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#908]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"ToNumber\">(x)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  if (|| (|| (= n NaN) (|| (= n +NUM_INF) (= n -NUM_INF))) (|| (= n 0.0f) (= n -0.0f))) {\n    if (? n: Completion) return n\n    call %1 = clo<\"NormalCompletion\">(n)\n    return %1\n  }\n  %2 = ([approx-number] ([math:sinh] ([math] n)))\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Math.sqrt(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#909]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"ToNumber\">(x)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  if (|| (|| (|| (= n NaN) (= n 0.0f)) (= n -0.0f)) (= n +NUM_INF)) {\n    if (? n: Completion) return n\n    call %1 = clo<\"NormalCompletion\">(n)\n    return %1\n  }\n  if (< n -0.0f) {\n    call %2 = clo<\"NormalCompletion\">(NaN)\n    return %2\n  }\n  %3 = ([approx-number] ([math:sqrt] ([math] n)))\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Math.tan(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#910]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"ToNumber\">(x)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  if (|| (|| (= n NaN) (= n 0.0f)) (= n -0.0f)) {\n    if (? n: Completion) return n\n    call %1 = clo<\"NormalCompletion\">(n)\n    return %1\n  }\n  if (|| (= n +NUM_INF) (= n -NUM_INF)) {\n    call %2 = clo<\"NormalCompletion\">(NaN)\n    return %2\n  }\n  %3 = ([approx-number] ([math:tan] ([math] n)))\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Math.tanh(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#911]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"ToNumber\">(x)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  if (|| (|| (= n NaN) (= n 0.0f)) (= n -0.0f)) {\n    if (? n: Completion) return n\n    call %1 = clo<\"NormalCompletion\">(n)\n    return %1\n  }\n  if (= n +NUM_INF) {\n    call %2 = clo<\"NormalCompletion\">(1.0f)\n    return %2\n  }\n  if (= n -NUM_INF) {\n    call %3 = clo<\"NormalCompletion\">(-1.0f)\n    return %3\n  }\n  %4 = ([approx-number] ([math:tanh] ([math] n)))\n  if (? %4: Completion) return %4\n  call %5 = clo<\"NormalCompletion\">(%4)\n  return %5\n}","def <BUILTIN>:INTRINSICS.Math.trunc(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#912]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  call %0 = clo<\"ToNumber\">(x)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  if (|| (|| (= n NaN) (|| (= n +NUM_INF) (= n -NUM_INF))) (|| (= n 0.0f) (= n -0.0f))) {\n    if (? n: Completion) return n\n    call %1 = clo<\"NormalCompletion\">(n)\n    return %1\n  }\n  if (&& (< n 1.0f) (< 0.0f n)) {\n    call %2 = clo<\"NormalCompletion\">(0.0f)\n    return %2\n  }\n  if (&& (< n -0.0f) (< -1.0f n)) {\n    call %3 = clo<\"NormalCompletion\">(-0.0f)\n    return %3\n  }\n  (yet \"Return the integral Number nearest _n_ in the direction of *+0*<sub>ùîΩ</sub>.\")\n}","def Day(\n  t: Unknown[\"FiniteTimeValue\"],\n): Number[Int] = {\n  (yet \"Return ùîΩ(floor(‚Ñù(_t_ / msPerDay))).\")\n}","def TimeWithinDay(\n  t: Unknown[\"FiniteTimeValue\"],\n): Unknown[\"IntegralNumberInTheIntervalFrom*+0*<sub>ùîΩ</sub>(inclusive)ToMsPerDay(exclusive)\"] = {\n  (yet \"Return ùîΩ(‚Ñù(_t_) modulo ‚Ñù(msPerDay)).\")\n}","def DaysInYear(\n  y: Number[Int],\n): Unknown[\"*365*<sub>ùîΩ</sub>Or*366*<sub>ùîΩ</sub>\"] = {\n  let ry = ([math] y)\n  if (== (% ry 400) 0) {\n    return 366.0f\n  }\n  if (== (% ry 100) 0) {\n    return 365.0f\n  }\n  if (== (% ry 4) 0) {\n    return 366.0f\n  }\n  return 365.0f\n}","def DayFromYear(\n  y: Number[Int],\n): Number[Int] = {\n  let ry = ([math] y)\n  nop\n  let numYears1 = (- ry 1970)\n  let numYears4 = (floor (/ (- ry 1969) 4))\n  let numYears100 = (floor (/ (- ry 1901) 100))\n  let numYears400 = (floor (/ (- ry 1601) 400))\n  return ([number] (+ (- (+ (* 365 numYears1) numYears4) numYears100) numYears400))\n}","def TimeFromYear(\n  y: Number[Int],\n): Unknown[\"TimeValue\"] = {\n  (yet \"Return msPerDay √ó DayFromYear(_y_).\")\n}","def YearFromTime(\n  t: Unknown[\"FiniteTimeValue\"],\n): Number[Int] = {\n  (yet \"Return the largest integral Number _y_ (closest to +‚àû) such that TimeFromYear(_y_) ‚â§ _t_.\")\n}","def DayWithinYear(\n  t: Unknown[\"FiniteTimeValue\"],\n): Unknown[\"IntegralNumberInTheInclusiveIntervalFrom*+0*<sub>ùîΩ</sub>To*365*<sub>ùîΩ</sub>\"] = {\n  (yet \"Return Day(_t_) - DayFromYear(YearFromTime(_t_)).\")\n}","def InLeapYear(\n  t: Unknown[\"FiniteTimeValue\"],\n): Unknown[\"*+0*<sub>ùîΩ</sub>Or*1*<sub>ùîΩ</sub>\"] = {\n  call %0 = clo<\"YearFromTime\">(t)\n  call %1 = clo<\"DaysInYear\">(%0)\n  if (= %1 366.0f) {\n    return 1.0f\n  } else {\n    return 0.0f\n  }\n}","def MonthFromTime(\n  t: Unknown[\"FiniteTimeValue\"],\n): Unknown[\"IntegralNumberInTheInclusiveIntervalFrom*+0*<sub>ùîΩ</sub>To*11*<sub>ùîΩ</sub>\"] = {\n  call %0 = clo<\"InLeapYear\">(t)\n  let inLeapYear = %0\n  call %1 = clo<\"DayWithinYear\">(t)\n  let dayWithinYear = %1\n  if (< dayWithinYear 31.0f) {\n    return 0.0f\n  }\n  if (< dayWithinYear (+ 59.0f inLeapYear)) {\n    return 1.0f\n  }\n  if (< dayWithinYear (+ 90.0f inLeapYear)) {\n    return 2.0f\n  }\n  if (< dayWithinYear (+ 120.0f inLeapYear)) {\n    return 3.0f\n  }\n  if (< dayWithinYear (+ 151.0f inLeapYear)) {\n    return 4.0f\n  }\n  if (< dayWithinYear (+ 181.0f inLeapYear)) {\n    return 5.0f\n  }\n  if (< dayWithinYear (+ 212.0f inLeapYear)) {\n    return 6.0f\n  }\n  if (< dayWithinYear (+ 243.0f inLeapYear)) {\n    return 7.0f\n  }\n  if (< dayWithinYear (+ 273.0f inLeapYear)) {\n    return 8.0f\n  }\n  if (< dayWithinYear (+ 304.0f inLeapYear)) {\n    return 9.0f\n  }\n  if (< dayWithinYear (+ 334.0f inLeapYear)) {\n    return 10.0f\n  }\n  assert (< dayWithinYear (+ 365.0f inLeapYear))\n  return 11.0f\n}","def DateFromTime(\n  t: Unknown[\"FiniteTimeValue\"],\n): Unknown[\"IntegralNumberInTheInclusiveIntervalFrom*1*<sub>ùîΩ</sub>To*31*<sub>ùîΩ</sub>\"] = {\n  call %0 = clo<\"InLeapYear\">(t)\n  let inLeapYear = %0\n  call %1 = clo<\"DayWithinYear\">(t)\n  let dayWithinYear = %1\n  call %2 = clo<\"MonthFromTime\">(t)\n  let month = %2\n  if (= month 0.0f) {\n    return (+ dayWithinYear 1.0f)\n  }\n  if (= month 1.0f) {\n    return (- dayWithinYear 30.0f)\n  }\n  if (= month 2.0f) {\n    return (- (- dayWithinYear 58.0f) inLeapYear)\n  }\n  if (= month 3.0f) {\n    return (- (- dayWithinYear 89.0f) inLeapYear)\n  }\n  if (= month 4.0f) {\n    return (- (- dayWithinYear 119.0f) inLeapYear)\n  }\n  if (= month 5.0f) {\n    return (- (- dayWithinYear 150.0f) inLeapYear)\n  }\n  if (= month 6.0f) {\n    return (- (- dayWithinYear 180.0f) inLeapYear)\n  }\n  if (= month 7.0f) {\n    return (- (- dayWithinYear 211.0f) inLeapYear)\n  }\n  if (= month 8.0f) {\n    return (- (- dayWithinYear 242.0f) inLeapYear)\n  }\n  if (= month 9.0f) {\n    return (- (- dayWithinYear 272.0f) inLeapYear)\n  }\n  if (= month 10.0f) {\n    return (- (- dayWithinYear 303.0f) inLeapYear)\n  }\n  assert (= month 11.0f)\n  return (- (- dayWithinYear 333.0f) inLeapYear)\n}","def WeekDay(\n  t: Unknown[\"FiniteTimeValue\"],\n): Unknown[\"IntegralNumberInTheInclusiveIntervalFrom*+0*<sub>ùîΩ</sub>To*6*<sub>ùîΩ</sub>\"] = {\n  (yet \"Return ùîΩ(‚Ñù(Day(_t_) + *4*<sub>ùîΩ</sub>) modulo 7).\")\n}","def HourFromTime(\n  t: Unknown[\"FiniteTimeValue\"],\n): Unknown[\"IntegralNumberInTheInclusiveIntervalFrom*+0*<sub>ùîΩ</sub>To*23*<sub>ùîΩ</sub>\"] = {\n  (yet \"Return ùîΩ(floor(‚Ñù(_t_ / msPerHour)) modulo HoursPerDay).\")\n}","def MinFromTime(\n  t: Unknown[\"FiniteTimeValue\"],\n): Unknown[\"IntegralNumberInTheInclusiveIntervalFrom*+0*<sub>ùîΩ</sub>To*59*<sub>ùîΩ</sub>\"] = {\n  (yet \"Return ùîΩ(floor(‚Ñù(_t_ / msPerMinute)) modulo MinutesPerHour).\")\n}","def SecFromTime(\n  t: Unknown[\"FiniteTimeValue\"],\n): Unknown[\"IntegralNumberInTheInclusiveIntervalFrom*+0*<sub>ùîΩ</sub>To*59*<sub>ùîΩ</sub>\"] = {\n  (yet \"Return ùîΩ(floor(‚Ñù(_t_ / msPerSecond)) modulo SecondsPerMinute).\")\n}","def msFromTime(\n  t: Unknown[\"FiniteTimeValue\"],\n): Unknown[\"IntegralNumberInTheInclusiveIntervalFrom*+0*<sub>ùîΩ</sub>To*999*<sub>ùîΩ</sub>\"] = {\n  (yet \"Return ùîΩ(‚Ñù(_t_) modulo ‚Ñù(msPerSecond)).\")\n}","def GetUTCEpochNanoseconds(\n  year: Int,\n  month: Unknown[\"IntegerInTheInclusiveIntervalFrom1To12\"],\n  day: Unknown[\"IntegerInTheInclusiveIntervalFrom1To31\"],\n  hour: Unknown[\"IntegerInTheInclusiveIntervalFrom0To23\"],\n  minute: Unknown[\"IntegerInTheInclusiveIntervalFrom0To59\"],\n  second: Unknown[\"IntegerInTheInclusiveIntervalFrom0To59\"],\n  millisecond: Unknown[\"IntegerInTheInclusiveIntervalFrom0To999\"],\n  microsecond: Unknown[\"IntegerInTheInclusiveIntervalFrom0To999\"],\n  nanosecond: Unknown[\"IntegerInTheInclusiveIntervalFrom0To999\"],\n): BigInt = {\n  call %0 = clo<\"MakeDay\">(([number] year), ([number] (- month 1)), ([number] day))\n  let date = %0\n  call %1 = clo<\"MakeTime\">(([number] hour), ([number] minute), ([number] second), ([number] millisecond))\n  let time = %1\n  call %2 = clo<\"MakeDate\">(date, time)\n  let ms = %2\n  assert (? ms: Number[Int])\n  return ([bigInt] (+ (+ (* ([math] ms) (** 10 6)) (* microsecond (** 10 3))) nanosecond))\n}","def GetNamedTimeZoneEpochNanoseconds(\n  timeZoneIdentifier: String,\n  year: Int,\n  month: Unknown[\"IntegerInTheInclusiveIntervalFrom1To12\"],\n  day: Unknown[\"IntegerInTheInclusiveIntervalFrom1To31\"],\n  hour: Unknown[\"IntegerInTheInclusiveIntervalFrom0To23\"],\n  minute: Unknown[\"IntegerInTheInclusiveIntervalFrom0To59\"],\n  second: Unknown[\"IntegerInTheInclusiveIntervalFrom0To59\"],\n  millisecond: Unknown[\"IntegerInTheInclusiveIntervalFrom0To999\"],\n  microsecond: Unknown[\"IntegerInTheInclusiveIntervalFrom0To999\"],\n  nanosecond: Unknown[\"IntegerInTheInclusiveIntervalFrom0To999\"],\n): List[BigInt] = {\n  assert (= timeZoneIdentifier \"UTC\")\n  call %0 = clo<\"GetUTCEpochNanoseconds\">(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond)\n  let epochNanoseconds = %0\n  return (list [epochNanoseconds])[#913]\n}","def GetNamedTimeZoneOffsetNanoseconds(\n  timeZoneIdentifier: String,\n  epochNanoseconds: BigInt,\n): Int = {\n  assert (= timeZoneIdentifier \"UTC\")\n  return 0\n}","def AvailableNamedTimeZoneIdentifiers(\n): List[Record[TimeZoneIdentifierRecord]] = {\n  (yet \"If the implementation does not include local political rules for any time zones, then\\n  1. Return ¬´ Time Zone Identifier Record { [[Identifier]]: *\\\"UTC\\\"*, [[PrimaryIdentifier]]: *\\\"UTC\\\"* } ¬ª.\")\n  (yet \"Let _identifiers_ be the List of unique available named time zone identifiers.\")\n  (yet \"Sort _identifiers_ into the same order as if an Array of the same values had been sorted using %Array.prototype.sort% with *undefined* as _comparefn_.\")\n  let result = (list [])[#914]\n  %1 = identifiers\n  %0 = 0\n  while (< %0 (sizeof %1)) {\n    let identifier = %1[%0]\n    let primary = identifier\n    (yet \"If _identifier_ is a non-primary time zone identifier in this implementation and _identifier_ is not *\\\"UTC\\\"*, then\\n  1. Set _primary_ to the primary time zone identifier associated with _identifier_.\\n  1. NOTE: An implementation may need to resolve _identifier_ iteratively to obtain the primary time zone identifier.\")\n    let record = (record [TimeZoneIdentifierRecord] {\n      \"Identifier\" : identifier,\n      \"PrimaryIdentifier\" : primary,\n    })[#915]\n    push result < record\n    %0 = (+ %0 1)\n  }\n  %2 = result\n  %3 = 0\n  %4 = false\n  while (&& (! %4) (< %3 (sizeof %2))) {\n    let r = %2[%3]\n    %4 = (&& (? r: Record[TimeZoneIdentifierRecord]) (&& (= r.Identifier \"UTC\") (= r.PrimaryIdentifier \"UTC\")))\n    %3 = (+ %3 1)\n  }\n  assert %4\n  return result\n}","def SystemTimeZoneIdentifier(\n): String = {\n  (yet \"If the implementation only supports the UTC time zone, return *\\\"UTC\\\"*.\")\n  (yet \"Let _systemTimeZoneString_ be the String representing the host environment's current time zone, either a primary time zone identifier or an offset time zone identifier.\")\n  return systemTimeZoneString\n}","def LocalTime(\n  t: Unknown[\"FiniteTimeValue\"],\n): Number[Int] = {\n  call %0 = clo<\"SystemTimeZoneIdentifier\">()\n  let systemTimeZoneIdentifier = %0\n  call %1 = clo<\"IsTimeZoneOffsetString\">(systemTimeZoneIdentifier)\n  if (= %1 true) {\n    call %2 = clo<\"ParseTimeZoneOffsetString\">(systemTimeZoneIdentifier)\n    let offsetNs = %2\n  } else {\n    call %3 = clo<\"GetNamedTimeZoneOffsetNanoseconds\">(systemTimeZoneIdentifier, ([bigInt] (* ([math] t) (** 10 6))))\n    let offsetNs = %3\n  }\n  %4 = (/ offsetNs (** 10 6))\n  if (< %4 0) %4 = (- (floor (- %4)))\n  else %4 = (floor %4)\n  let offsetMs = %4\n  return (+ t ([number] offsetMs))\n}","def UTC(\n  t: Number,\n): Unknown[\"TimeValue\"] = {\n  if (|| (= t NaN) (|| (= t +NUM_INF) (= t -NUM_INF))) {\n    return NaN\n  }\n  call %0 = clo<\"SystemTimeZoneIdentifier\">()\n  let systemTimeZoneIdentifier = %0\n  call %1 = clo<\"IsTimeZoneOffsetString\">(systemTimeZoneIdentifier)\n  if (= %1 true) {\n    call %2 = clo<\"ParseTimeZoneOffsetString\">(systemTimeZoneIdentifier)\n    let offsetNs = %2\n  } else {\n    (yet \"Let _possibleInstants_ be GetNamedTimeZoneEpochNanoseconds(_systemTimeZoneIdentifier_, ‚Ñù(YearFromTime(_t_)), ‚Ñù(MonthFromTime(_t_)) + 1, ‚Ñù(DateFromTime(_t_)), ‚Ñù(HourFromTime(_t_)), ‚Ñù(MinFromTime(_t_)), ‚Ñù(SecFromTime(_t_)), ‚Ñù(msFromTime(_t_)), 0, 0).\")\n    nop\n    if (! (= (sizeof possibleInstants) 0)) {\n      let disambiguatedInstant = possibleInstants[0]\n    } else {\n      nop\n      (yet \"Let _possibleInstantsBefore_ be GetNamedTimeZoneEpochNanoseconds(_systemTimeZoneIdentifier_, ‚Ñù(YearFromTime(_tBefore_)), ‚Ñù(MonthFromTime(_tBefore_)) + 1, ‚Ñù(DateFromTime(_tBefore_)), ‚Ñù(HourFromTime(_tBefore_)), ‚Ñù(MinFromTime(_tBefore_)), ‚Ñù(SecFromTime(_tBefore_)), ‚Ñù(msFromTime(_tBefore_)), 0, 0), where _tBefore_ is the largest integral Number < _t_ for which _possibleInstantsBefore_ is not empty (i.e., _tBefore_ represents the last local time before the transition).\")\n      (yet \"Let _disambiguatedInstant_ be the last element of _possibleInstantsBefore_.\")\n    }\n    call %3 = clo<\"GetNamedTimeZoneOffsetNanoseconds\">(systemTimeZoneIdentifier, disambiguatedInstant)\n    let offsetNs = %3\n  }\n  %4 = (/ offsetNs (** 10 6))\n  if (< %4 0) %4 = (- (floor (- %4)))\n  else %4 = (floor %4)\n  let offsetMs = %4\n  return (- t ([number] offsetMs))\n}","def MakeTime(\n  hour: Number,\n  min: Number,\n  sec: Number,\n  ms: Number,\n): Number = {\n  if (|| (|| (= hour NaN) (|| (= hour +NUM_INF) (= hour -NUM_INF))) (|| (|| (= min NaN) (|| (= min +NUM_INF) (= min -NUM_INF))) (|| (|| (= sec NaN) (|| (= sec +NUM_INF) (= sec -NUM_INF))) (|| (= ms NaN) (|| (= ms +NUM_INF) (= ms -NUM_INF)))))) {\n    return NaN\n  }\n  call %0 = clo<\"ToIntegerOrInfinity\">(hour)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let h = ([number] %0)\n  call %1 = clo<\"ToIntegerOrInfinity\">(min)\n  assert (? %1: Normal)\n  %1 = %1.Value\n  let m = ([number] %1)\n  call %2 = clo<\"ToIntegerOrInfinity\">(sec)\n  assert (? %2: Normal)\n  %2 = %2.Value\n  let s = ([number] %2)\n  call %3 = clo<\"ToIntegerOrInfinity\">(ms)\n  assert (? %3: Normal)\n  %3 = %3.Value\n  let milli = ([number] %3)\n  (yet \"Return ((_h_ √ó msPerHour + _m_ √ó msPerMinute) + _s_ √ó msPerSecond) + _milli_.\")\n}","def MakeDay(\n  year: Number,\n  month: Number,\n  date: Number,\n): Number = {\n  if (|| (|| (= year NaN) (|| (= year +NUM_INF) (= year -NUM_INF))) (|| (|| (= month NaN) (|| (= month +NUM_INF) (= month -NUM_INF))) (|| (= date NaN) (|| (= date +NUM_INF) (= date -NUM_INF))))) {\n    return NaN\n  }\n  call %0 = clo<\"ToIntegerOrInfinity\">(year)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let y = ([number] %0)\n  call %1 = clo<\"ToIntegerOrInfinity\">(month)\n  assert (? %1: Normal)\n  %1 = %1.Value\n  let m = ([number] %1)\n  call %2 = clo<\"ToIntegerOrInfinity\">(date)\n  assert (? %2: Normal)\n  %2 = %2.Value\n  let dt = ([number] %2)\n  let ym = (+ y ([number] (floor (/ ([math] m) 12))))\n  if (|| (= ym NaN) (|| (= ym +NUM_INF) (= ym -NUM_INF))) {\n    return NaN\n  }\n  let mn = ([number] (% ([math] m) 12))\n  (yet \"Find a finite time value _t_ such that YearFromTime(_t_) is _ym_, MonthFromTime(_t_) is _mn_, and DateFromTime(_t_) is *1*<sub>ùîΩ</sub>; but if this is not possible (because some argument is out of range), return *NaN*.\")\n  (yet \"Return Day(_t_) + _dt_ - *1*<sub>ùîΩ</sub>.\")\n}","def MakeDate(\n  day: Number,\n  time: Number,\n): Number = {\n  if (|| (|| (= day NaN) (|| (= day +NUM_INF) (= day -NUM_INF))) (|| (= time NaN) (|| (= time +NUM_INF) (= time -NUM_INF)))) {\n    return NaN\n  }\n  (yet \"Let _tv_ be _day_ √ó msPerDay + _time_.\")\n  if (|| (= tv NaN) (|| (= tv +NUM_INF) (= tv -NUM_INF))) {\n    return NaN\n  }\n  return tv\n}","def MakeFullYear(\n  year: Number,\n): Number[Int, NaN] = {\n  if (= year NaN) {\n    return NaN\n  }\n  call %0 = clo<\"ToIntegerOrInfinity\">(year)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let truncated = %0\n  if (! (|| (< truncated 0) (< 99 truncated))) {\n    return (+ 1900.0f ([number] truncated))\n  }\n  return ([number] truncated)\n}","def TimeClip(\n  time: Number,\n): Number = {\n  if (|| (= time NaN) (|| (= time +NUM_INF) (= time -NUM_INF))) {\n    return NaN\n  }\n  if (< (* 8.64 (** 10 15)) (abs ([math] time))) {\n    return NaN\n  }\n  call %0 = clo<\"ToIntegerOrInfinity\">(time)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  return ([number] %0)\n}","def IsTimeZoneOffsetString(\n  offsetString: String,\n): Boolean = {\n  call %0 = clo<\"StringToCodePoints\">(offsetString)\n  let parseResult = (parse %0 (grammar-symbol |UTCOffset|))\n  if (? parseResult: List[Record[Error]]) {\n    return false\n  }\n  return true\n}","def ParseTimeZoneOffsetString(\n  offsetString: String,\n): Int = {\n  call %0 = clo<\"StringToCodePoints\">(offsetString)\n  let parseResult = (parse %0 (grammar-symbol |UTCOffset|))\n  assert (! (? parseResult: List[Record[Error]]))\n  assert (yet \"_parseResult_ contains a |TemporalSign| Parse Node.\")\n  (yet \"Let _parsedSign_ be the source text matched by the |TemporalSign| Parse Node contained within _parseResult_.\")\n  (yet \"If _parsedSign_ is the single code point U+002D (HYPHEN-MINUS) or U+2212 (MINUS SIGN), then\\n  1. Let _sign_ be -1.\")\n  (yet \"Else,\\n  1. Let _sign_ be 1.\")\n  nop\n  assert (yet \"_parseResult_ contains an |Hour| Parse Node.\")\n  (yet \"Let _parsedHours_ be the source text matched by the |Hour| Parse Node contained within _parseResult_.\")\n  call %1 = clo<\"CodePointsToString\">(parsedHours)\n  call %2 = clo<\"StringToNumber\">(%1)\n  let hours = ([math] %2)\n  (yet \"If _parseResult_ does not contain a |MinuteSecond| Parse Node, then\\n  1. Let _minutes_ be 0.\")\n  (yet \"Else,\\n  1. Let _parsedMinutes_ be the source text matched by the first |MinuteSecond| Parse Node contained within _parseResult_.\\n  1. Let _minutes_ be ‚Ñù(StringToNumber(CodePointsToString(_parsedMinutes_))).\")\n  (yet \"If _parseResult_ does not contain two |MinuteSecond| Parse Nodes, then\\n  1. Let _seconds_ be 0.\")\n  (yet \"Else,\\n  1. Let _parsedSeconds_ be the source text matched by the second |MinuteSecond| Parse Node contained within _parseResult_.\\n  1. Let _seconds_ be ‚Ñù(StringToNumber(CodePointsToString(_parsedSeconds_))).\")\n  (yet \"If _parseResult_ does not contain a |TemporalDecimalFraction| Parse Node, then\\n  1. Let _nanoseconds_ be 0.\")\n  (yet \"Else,\\n  1. Let _parsedFraction_ be the source text matched by the |TemporalDecimalFraction| Parse Node contained within _parseResult_.\\n  1. Let _fraction_ be the string-concatenation of CodePointsToString(_parsedFraction_) and *\\\"000000000\\\"*.\\n  1. Let _nanosecondsString_ be the substring of _fraction_ from 1 to 10.\\n  1. Let _nanoseconds_ be ‚Ñù(StringToNumber(_nanosecondsString_)).\")\n  return (* sign (+ (* (+ (* (+ (* hours 60) minutes) 60) seconds) (** 10 9)) nanoseconds))\n}","def <BUILTIN>:INTRINSICS.Date(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#916]\n  let values = ArgumentsList\n  if (= NewTarget undefined) {\n    (yet \"Let _now_ be the time value (UTC) identifying the current time.\")\n    call %0 = clo<\"ToDateString\">(now)\n    if (? %0: Completion) return %0\n    call %1 = clo<\"NormalCompletion\">(%0)\n    return %1\n  }\n  let numberOfArgs = (sizeof values)\n  if (== numberOfArgs 0) {\n    (yet \"Let _dv_ be the time value (UTC) identifying the current time.\")\n  } else {\n    if (== numberOfArgs 1) {\n      let value = values[0]\n      if (&& (? value: Record[Object]) (exists value.DateValue)) {\n        let tv = value.DateValue\n      } else {\n        call %2 = clo<\"ToPrimitive\">(value)\n        assert (? %2: Completion)\n        if (? %2: Abrupt) return %2\n        else %2 = %2.Value\n        let v = %2\n        if (? v: String) {\n          assert (yet \"The next step never returns an abrupt completion because _v_ is a String.\")\n          (yet \"Let _tv_ be the result of parsing _v_ as a date, in exactly the same manner as for the `parse` method (<emu-xref href=\\\"#sec-date.parse\\\"></emu-xref>).\")\n        } else {\n          call %3 = clo<\"ToNumber\">(v)\n          assert (? %3: Completion)\n          if (? %3: Abrupt) return %3\n          else %3 = %3.Value\n          let tv = %3\n        }\n      }\n      call %4 = clo<\"TimeClip\">(tv)\n      let dv = %4\n    } else {\n      assert (! (< numberOfArgs 2))\n      call %5 = clo<\"ToNumber\">(values[0])\n      assert (? %5: Completion)\n      if (? %5: Abrupt) return %5\n      else %5 = %5.Value\n      let y = %5\n      call %6 = clo<\"ToNumber\">(values[1])\n      assert (? %6: Completion)\n      if (? %6: Abrupt) return %6\n      else %6 = %6.Value\n      let m = %6\n      if (< 2 numberOfArgs) {\n        call %7 = clo<\"ToNumber\">(values[2])\n        assert (? %7: Completion)\n        if (? %7: Abrupt) return %7\n        else %7 = %7.Value\n        let dt = %7\n      } else {\n        let dt = 1.0f\n      }\n      if (< 3 numberOfArgs) {\n        call %8 = clo<\"ToNumber\">(values[3])\n        assert (? %8: Completion)\n        if (? %8: Abrupt) return %8\n        else %8 = %8.Value\n        let h = %8\n      } else {\n        let h = 0.0f\n      }\n      if (< 4 numberOfArgs) {\n        call %9 = clo<\"ToNumber\">(values[4])\n        assert (? %9: Completion)\n        if (? %9: Abrupt) return %9\n        else %9 = %9.Value\n        let min = %9\n      } else {\n        let min = 0.0f\n      }\n      if (< 5 numberOfArgs) {\n        call %10 = clo<\"ToNumber\">(values[5])\n        assert (? %10: Completion)\n        if (? %10: Abrupt) return %10\n        else %10 = %10.Value\n        let s = %10\n      } else {\n        let s = 0.0f\n      }\n      if (< 6 numberOfArgs) {\n        call %11 = clo<\"ToNumber\">(values[6])\n        assert (? %11: Completion)\n        if (? %11: Abrupt) return %11\n        else %11 = %11.Value\n        let milli = %11\n      } else {\n        let milli = 0.0f\n      }\n      call %12 = clo<\"MakeFullYear\">(y)\n      let yr = %12\n      call %13 = clo<\"MakeDay\">(yr, m, dt)\n      call %14 = clo<\"MakeTime\">(h, min, s, milli)\n      call %15 = clo<\"MakeDate\">(%13, %14)\n      let finalDate = %15\n      call %16 = clo<\"UTC\">(finalDate)\n      call %17 = clo<\"TimeClip\">(%16)\n      let dv = %17\n    }\n  }\n  call %18 = clo<\"OrdinaryCreateFromConstructor\">(NewTarget, \"%Date.prototype%\", (list [\"DateValue\"])[#917])\n  assert (? %18: Completion)\n  if (? %18: Abrupt) return %18\n  else %18 = %18.Value\n  let O = %18\n  O.DateValue = dv\n  if (? O: Completion) return O\n  call %19 = clo<\"NormalCompletion\">(O)\n  return %19\n}","def <BUILTIN>:INTRINSICS.Date.UTC(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#918]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop year < ArgumentsList\n    expand __args__.year\n  } else let year = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop month < ArgumentsList\n    expand __args__.month\n  } else let month = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop date < ArgumentsList\n    expand __args__.date\n  } else let date = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop hours < ArgumentsList\n    expand __args__.hours\n  } else let hours = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop minutes < ArgumentsList\n    expand __args__.minutes\n  } else let minutes = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop seconds < ArgumentsList\n    expand __args__.seconds\n  } else let seconds = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop ms < ArgumentsList\n    expand __args__.ms\n  } else let ms = undefined\n  call %0 = clo<\"ToNumber\">(year)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let y = %0\n  if (exists __args__.month) {\n    call %1 = clo<\"ToNumber\">(month)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let m = %1\n  } else {\n    let m = 0.0f\n  }\n  if (exists __args__.date) {\n    call %2 = clo<\"ToNumber\">(date)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let dt = %2\n  } else {\n    let dt = 1.0f\n  }\n  if (exists __args__.hours) {\n    call %3 = clo<\"ToNumber\">(hours)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let h = %3\n  } else {\n    let h = 0.0f\n  }\n  if (exists __args__.minutes) {\n    call %4 = clo<\"ToNumber\">(minutes)\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    let min = %4\n  } else {\n    let min = 0.0f\n  }\n  if (exists __args__.seconds) {\n    call %5 = clo<\"ToNumber\">(seconds)\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n    let s = %5\n  } else {\n    let s = 0.0f\n  }\n  if (exists __args__.ms) {\n    call %6 = clo<\"ToNumber\">(ms)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    let milli = %6\n  } else {\n    let milli = 0.0f\n  }\n  call %7 = clo<\"MakeFullYear\">(y)\n  let yr = %7\n  call %8 = clo<\"MakeDay\">(yr, m, dt)\n  call %9 = clo<\"MakeTime\">(h, min, s, milli)\n  call %10 = clo<\"MakeDate\">(%8, %9)\n  call %11 = clo<\"TimeClip\">(%10)\n  if (? %11: Completion) return %11\n  call %12 = clo<\"NormalCompletion\">(%11)\n  return %12\n}","def <BUILTIN>:INTRINSICS.Date.prototype.getDate(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#919]\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  if (= t NaN) {\n    call %1 = clo<\"NormalCompletion\">(NaN)\n    return %1\n  }\n  call %2 = clo<\"LocalTime\">(t)\n  call %3 = clo<\"DateFromTime\">(%2)\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Date.prototype.getDay(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#920]\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  if (= t NaN) {\n    call %1 = clo<\"NormalCompletion\">(NaN)\n    return %1\n  }\n  call %2 = clo<\"LocalTime\">(t)\n  call %3 = clo<\"WeekDay\">(%2)\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Date.prototype.getFullYear(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#921]\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  if (= t NaN) {\n    call %1 = clo<\"NormalCompletion\">(NaN)\n    return %1\n  }\n  call %2 = clo<\"LocalTime\">(t)\n  call %3 = clo<\"YearFromTime\">(%2)\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Date.prototype.getHours(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#922]\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  if (= t NaN) {\n    call %1 = clo<\"NormalCompletion\">(NaN)\n    return %1\n  }\n  call %2 = clo<\"LocalTime\">(t)\n  call %3 = clo<\"HourFromTime\">(%2)\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Date.prototype.getMilliseconds(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#923]\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  if (= t NaN) {\n    call %1 = clo<\"NormalCompletion\">(NaN)\n    return %1\n  }\n  (yet \"Return msFromTime(LocalTime(_t_)).\")\n}","def <BUILTIN>:INTRINSICS.Date.prototype.getMinutes(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#924]\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  if (= t NaN) {\n    call %1 = clo<\"NormalCompletion\">(NaN)\n    return %1\n  }\n  call %2 = clo<\"LocalTime\">(t)\n  call %3 = clo<\"MinFromTime\">(%2)\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Date.prototype.getMonth(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#925]\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  if (= t NaN) {\n    call %1 = clo<\"NormalCompletion\">(NaN)\n    return %1\n  }\n  call %2 = clo<\"LocalTime\">(t)\n  call %3 = clo<\"MonthFromTime\">(%2)\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Date.prototype.getSeconds(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#926]\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  if (= t NaN) {\n    call %1 = clo<\"NormalCompletion\">(NaN)\n    return %1\n  }\n  call %2 = clo<\"LocalTime\">(t)\n  call %3 = clo<\"SecFromTime\">(%2)\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Date.prototype.getTime(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#927]\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  %1 = dateObject.DateValue\n  if (? %1: Completion) return %1\n  call %2 = clo<\"NormalCompletion\">(%1)\n  return %2\n}","def <BUILTIN>:INTRINSICS.Date.prototype.getTimezoneOffset(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#928]\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  if (= t NaN) {\n    call %1 = clo<\"NormalCompletion\">(NaN)\n    return %1\n  }\n  (yet \"Return (_t_ - LocalTime(_t_)) / msPerMinute.\")\n}","def <BUILTIN>:INTRINSICS.Date.prototype.getUTCDate(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#929]\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  if (= t NaN) {\n    call %1 = clo<\"NormalCompletion\">(NaN)\n    return %1\n  }\n  call %2 = clo<\"DateFromTime\">(t)\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Date.prototype.getUTCDay(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#930]\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  if (= t NaN) {\n    call %1 = clo<\"NormalCompletion\">(NaN)\n    return %1\n  }\n  call %2 = clo<\"WeekDay\">(t)\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Date.prototype.getUTCFullYear(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#931]\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  if (= t NaN) {\n    call %1 = clo<\"NormalCompletion\">(NaN)\n    return %1\n  }\n  call %2 = clo<\"YearFromTime\">(t)\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Date.prototype.getUTCHours(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#932]\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  if (= t NaN) {\n    call %1 = clo<\"NormalCompletion\">(NaN)\n    return %1\n  }\n  call %2 = clo<\"HourFromTime\">(t)\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Date.prototype.getUTCMilliseconds(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#933]\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  if (= t NaN) {\n    call %1 = clo<\"NormalCompletion\">(NaN)\n    return %1\n  }\n  (yet \"Return msFromTime(_t_).\")\n}","def <BUILTIN>:INTRINSICS.Date.prototype.getUTCMinutes(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#934]\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  if (= t NaN) {\n    call %1 = clo<\"NormalCompletion\">(NaN)\n    return %1\n  }\n  call %2 = clo<\"MinFromTime\">(t)\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Date.prototype.getUTCMonth(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#935]\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  if (= t NaN) {\n    call %1 = clo<\"NormalCompletion\">(NaN)\n    return %1\n  }\n  call %2 = clo<\"MonthFromTime\">(t)\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Date.prototype.getUTCSeconds(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#936]\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  if (= t NaN) {\n    call %1 = clo<\"NormalCompletion\">(NaN)\n    return %1\n  }\n  call %2 = clo<\"SecFromTime\">(t)\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Date.prototype.setDate(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#937]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop date < ArgumentsList\n    expand __args__.date\n  } else let date = undefined\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  call %1 = clo<\"ToNumber\">(date)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let dt = %1\n  if (= t NaN) {\n    call %2 = clo<\"NormalCompletion\">(NaN)\n    return %2\n  }\n  call %3 = clo<\"LocalTime\">(t)\n  t = %3\n  call %4 = clo<\"YearFromTime\">(t)\n  call %5 = clo<\"MonthFromTime\">(t)\n  call %6 = clo<\"MakeDay\">(%4, %5, dt)\n  call %7 = clo<\"TimeWithinDay\">(t)\n  call %8 = clo<\"MakeDate\">(%6, %7)\n  let newDate = %8\n  call %9 = clo<\"UTC\">(newDate)\n  call %10 = clo<\"TimeClip\">(%9)\n  let u = %10\n  dateObject.DateValue = u\n  if (? u: Completion) return u\n  call %11 = clo<\"NormalCompletion\">(u)\n  return %11\n}","def <BUILTIN>:INTRINSICS.Date.prototype.setFullYear(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#938]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop year < ArgumentsList\n    expand __args__.year\n  } else let year = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop month < ArgumentsList\n    expand __args__.month\n  } else let month = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop date < ArgumentsList\n    expand __args__.date\n  } else let date = undefined\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  call %1 = clo<\"ToNumber\">(year)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let y = %1\n  if (= t NaN) {\n    t = 0.0f\n  } else {\n    call %2 = clo<\"LocalTime\">(t)\n    t = %2\n  }\n  if (! (exists __args__.month)) {\n    call %3 = clo<\"MonthFromTime\">(t)\n    let m = %3\n  } else {\n    call %4 = clo<\"ToNumber\">(month)\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    let m = %4\n  }\n  if (! (exists __args__.date)) {\n    call %5 = clo<\"DateFromTime\">(t)\n    let dt = %5\n  } else {\n    call %6 = clo<\"ToNumber\">(date)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    let dt = %6\n  }\n  call %7 = clo<\"MakeDay\">(y, m, dt)\n  call %8 = clo<\"TimeWithinDay\">(t)\n  call %9 = clo<\"MakeDate\">(%7, %8)\n  let newDate = %9\n  call %10 = clo<\"UTC\">(newDate)\n  call %11 = clo<\"TimeClip\">(%10)\n  let u = %11\n  dateObject.DateValue = u\n  if (? u: Completion) return u\n  call %12 = clo<\"NormalCompletion\">(u)\n  return %12\n}","def <BUILTIN>:INTRINSICS.Date.prototype.setHours(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#939]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop hour < ArgumentsList\n    expand __args__.hour\n  } else let hour = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop min < ArgumentsList\n    expand __args__.min\n  } else let min = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop sec < ArgumentsList\n    expand __args__.sec\n  } else let sec = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop ms < ArgumentsList\n    expand __args__.ms\n  } else let ms = undefined\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  call %1 = clo<\"ToNumber\">(hour)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let h = %1\n  if (exists __args__.min) {\n    call %2 = clo<\"ToNumber\">(min)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let m = %2\n  }\n  if (exists __args__.sec) {\n    call %3 = clo<\"ToNumber\">(sec)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let s = %3\n  }\n  if (exists __args__.ms) {\n    call %4 = clo<\"ToNumber\">(ms)\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    let milli = %4\n  }\n  if (= t NaN) {\n    call %5 = clo<\"NormalCompletion\">(NaN)\n    return %5\n  }\n  call %6 = clo<\"LocalTime\">(t)\n  t = %6\n  if (! (exists __args__.min)) {\n    call %7 = clo<\"MinFromTime\">(t)\n    let m = %7\n  }\n  if (! (exists __args__.sec)) {\n    call %8 = clo<\"SecFromTime\">(t)\n    let s = %8\n  }\n  if (! (exists __args__.ms)) {\n    (yet \"let _milli_ be msFromTime(_t_).\")\n  }\n  call %9 = clo<\"Day\">(t)\n  call %10 = clo<\"MakeTime\">(h, m, s, milli)\n  call %11 = clo<\"MakeDate\">(%9, %10)\n  let date = %11\n  call %12 = clo<\"UTC\">(date)\n  call %13 = clo<\"TimeClip\">(%12)\n  let u = %13\n  dateObject.DateValue = u\n  if (? u: Completion) return u\n  call %14 = clo<\"NormalCompletion\">(u)\n  return %14\n}","def <BUILTIN>:INTRINSICS.Date.prototype.setMilliseconds(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#940]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop ms < ArgumentsList\n    expand __args__.ms\n  } else let ms = undefined\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  call %1 = clo<\"ToNumber\">(ms)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  ms = %1\n  if (= t NaN) {\n    call %2 = clo<\"NormalCompletion\">(NaN)\n    return %2\n  }\n  call %3 = clo<\"LocalTime\">(t)\n  t = %3\n  call %4 = clo<\"HourFromTime\">(t)\n  call %5 = clo<\"MinFromTime\">(t)\n  call %6 = clo<\"SecFromTime\">(t)\n  call %7 = clo<\"MakeTime\">(%4, %5, %6, ms)\n  let time = %7\n  call %8 = clo<\"Day\">(t)\n  call %9 = clo<\"MakeDate\">(%8, time)\n  call %10 = clo<\"UTC\">(%9)\n  call %11 = clo<\"TimeClip\">(%10)\n  let u = %11\n  dateObject.DateValue = u\n  if (? u: Completion) return u\n  call %12 = clo<\"NormalCompletion\">(u)\n  return %12\n}","def <BUILTIN>:INTRINSICS.Date.prototype.setMinutes(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#941]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop min < ArgumentsList\n    expand __args__.min\n  } else let min = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop sec < ArgumentsList\n    expand __args__.sec\n  } else let sec = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop ms < ArgumentsList\n    expand __args__.ms\n  } else let ms = undefined\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  call %1 = clo<\"ToNumber\">(min)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let m = %1\n  if (exists __args__.sec) {\n    call %2 = clo<\"ToNumber\">(sec)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let s = %2\n  }\n  if (exists __args__.ms) {\n    call %3 = clo<\"ToNumber\">(ms)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let milli = %3\n  }\n  if (= t NaN) {\n    call %4 = clo<\"NormalCompletion\">(NaN)\n    return %4\n  }\n  call %5 = clo<\"LocalTime\">(t)\n  t = %5\n  if (! (exists __args__.sec)) {\n    call %6 = clo<\"SecFromTime\">(t)\n    let s = %6\n  }\n  if (! (exists __args__.ms)) {\n    (yet \"let _milli_ be msFromTime(_t_).\")\n  }\n  call %7 = clo<\"Day\">(t)\n  call %8 = clo<\"HourFromTime\">(t)\n  call %9 = clo<\"MakeTime\">(%8, m, s, milli)\n  call %10 = clo<\"MakeDate\">(%7, %9)\n  let date = %10\n  call %11 = clo<\"UTC\">(date)\n  call %12 = clo<\"TimeClip\">(%11)\n  let u = %12\n  dateObject.DateValue = u\n  if (? u: Completion) return u\n  call %13 = clo<\"NormalCompletion\">(u)\n  return %13\n}","def <BUILTIN>:INTRINSICS.Date.prototype.setMonth(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#942]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop month < ArgumentsList\n    expand __args__.month\n  } else let month = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop date < ArgumentsList\n    expand __args__.date\n  } else let date = undefined\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  call %1 = clo<\"ToNumber\">(month)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let m = %1\n  if (exists __args__.date) {\n    call %2 = clo<\"ToNumber\">(date)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let dt = %2\n  }\n  if (= t NaN) {\n    call %3 = clo<\"NormalCompletion\">(NaN)\n    return %3\n  }\n  call %4 = clo<\"LocalTime\">(t)\n  t = %4\n  if (! (exists __args__.date)) {\n    call %5 = clo<\"DateFromTime\">(t)\n    let dt = %5\n  }\n  call %6 = clo<\"YearFromTime\">(t)\n  call %7 = clo<\"MakeDay\">(%6, m, dt)\n  call %8 = clo<\"TimeWithinDay\">(t)\n  call %9 = clo<\"MakeDate\">(%7, %8)\n  let newDate = %9\n  call %10 = clo<\"UTC\">(newDate)\n  call %11 = clo<\"TimeClip\">(%10)\n  let u = %11\n  dateObject.DateValue = u\n  if (? u: Completion) return u\n  call %12 = clo<\"NormalCompletion\">(u)\n  return %12\n}","def <BUILTIN>:INTRINSICS.Date.prototype.setSeconds(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#943]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop sec < ArgumentsList\n    expand __args__.sec\n  } else let sec = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop ms < ArgumentsList\n    expand __args__.ms\n  } else let ms = undefined\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  call %1 = clo<\"ToNumber\">(sec)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let s = %1\n  if (exists __args__.ms) {\n    call %2 = clo<\"ToNumber\">(ms)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let milli = %2\n  }\n  if (= t NaN) {\n    call %3 = clo<\"NormalCompletion\">(NaN)\n    return %3\n  }\n  call %4 = clo<\"LocalTime\">(t)\n  t = %4\n  if (! (exists __args__.ms)) {\n    (yet \"let _milli_ be msFromTime(_t_).\")\n  }\n  call %5 = clo<\"Day\">(t)\n  call %6 = clo<\"HourFromTime\">(t)\n  call %7 = clo<\"MinFromTime\">(t)\n  call %8 = clo<\"MakeTime\">(%6, %7, s, milli)\n  call %9 = clo<\"MakeDate\">(%5, %8)\n  let date = %9\n  call %10 = clo<\"UTC\">(date)\n  call %11 = clo<\"TimeClip\">(%10)\n  let u = %11\n  dateObject.DateValue = u\n  if (? u: Completion) return u\n  call %12 = clo<\"NormalCompletion\">(u)\n  return %12\n}","def <BUILTIN>:INTRINSICS.Date.prototype.setTime(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#944]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop time < ArgumentsList\n    expand __args__.time\n  } else let time = undefined\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"ToNumber\">(time)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let t = %1\n  call %2 = clo<\"TimeClip\">(t)\n  let v = %2\n  dateObject.DateValue = v\n  if (? v: Completion) return v\n  call %3 = clo<\"NormalCompletion\">(v)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Date.prototype.setUTCDate(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#945]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop date < ArgumentsList\n    expand __args__.date\n  } else let date = undefined\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  call %1 = clo<\"ToNumber\">(date)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let dt = %1\n  if (= t NaN) {\n    call %2 = clo<\"NormalCompletion\">(NaN)\n    return %2\n  }\n  call %3 = clo<\"YearFromTime\">(t)\n  call %4 = clo<\"MonthFromTime\">(t)\n  call %5 = clo<\"MakeDay\">(%3, %4, dt)\n  call %6 = clo<\"TimeWithinDay\">(t)\n  call %7 = clo<\"MakeDate\">(%5, %6)\n  let newDate = %7\n  call %8 = clo<\"TimeClip\">(newDate)\n  let v = %8\n  dateObject.DateValue = v\n  if (? v: Completion) return v\n  call %9 = clo<\"NormalCompletion\">(v)\n  return %9\n}","def <BUILTIN>:INTRINSICS.Date.prototype.setUTCFullYear(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#946]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop year < ArgumentsList\n    expand __args__.year\n  } else let year = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop month < ArgumentsList\n    expand __args__.month\n  } else let month = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop date < ArgumentsList\n    expand __args__.date\n  } else let date = undefined\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  if (= t NaN) {\n    t = 0.0f\n  }\n  call %1 = clo<\"ToNumber\">(year)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let y = %1\n  if (! (exists __args__.month)) {\n    call %2 = clo<\"MonthFromTime\">(t)\n    let m = %2\n  } else {\n    call %3 = clo<\"ToNumber\">(month)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let m = %3\n  }\n  if (! (exists __args__.date)) {\n    call %4 = clo<\"DateFromTime\">(t)\n    let dt = %4\n  } else {\n    call %5 = clo<\"ToNumber\">(date)\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n    let dt = %5\n  }\n  call %6 = clo<\"MakeDay\">(y, m, dt)\n  call %7 = clo<\"TimeWithinDay\">(t)\n  call %8 = clo<\"MakeDate\">(%6, %7)\n  let newDate = %8\n  call %9 = clo<\"TimeClip\">(newDate)\n  let v = %9\n  dateObject.DateValue = v\n  if (? v: Completion) return v\n  call %10 = clo<\"NormalCompletion\">(v)\n  return %10\n}","def <BUILTIN>:INTRINSICS.Date.prototype.setUTCHours(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#947]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop hour < ArgumentsList\n    expand __args__.hour\n  } else let hour = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop min < ArgumentsList\n    expand __args__.min\n  } else let min = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop sec < ArgumentsList\n    expand __args__.sec\n  } else let sec = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop ms < ArgumentsList\n    expand __args__.ms\n  } else let ms = undefined\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  call %1 = clo<\"ToNumber\">(hour)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let h = %1\n  if (exists __args__.min) {\n    call %2 = clo<\"ToNumber\">(min)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let m = %2\n  }\n  if (exists __args__.sec) {\n    call %3 = clo<\"ToNumber\">(sec)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let s = %3\n  }\n  if (exists __args__.ms) {\n    call %4 = clo<\"ToNumber\">(ms)\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    let milli = %4\n  }\n  if (= t NaN) {\n    call %5 = clo<\"NormalCompletion\">(NaN)\n    return %5\n  }\n  if (! (exists __args__.min)) {\n    call %6 = clo<\"MinFromTime\">(t)\n    let m = %6\n  }\n  if (! (exists __args__.sec)) {\n    call %7 = clo<\"SecFromTime\">(t)\n    let s = %7\n  }\n  if (! (exists __args__.ms)) {\n    (yet \"let _milli_ be msFromTime(_t_).\")\n  }\n  call %8 = clo<\"Day\">(t)\n  call %9 = clo<\"MakeTime\">(h, m, s, milli)\n  call %10 = clo<\"MakeDate\">(%8, %9)\n  let date = %10\n  call %11 = clo<\"TimeClip\">(date)\n  let v = %11\n  dateObject.DateValue = v\n  if (? v: Completion) return v\n  call %12 = clo<\"NormalCompletion\">(v)\n  return %12\n}","def <BUILTIN>:INTRINSICS.Date.prototype.setUTCMilliseconds(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#948]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop ms < ArgumentsList\n    expand __args__.ms\n  } else let ms = undefined\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  call %1 = clo<\"ToNumber\">(ms)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  ms = %1\n  if (= t NaN) {\n    call %2 = clo<\"NormalCompletion\">(NaN)\n    return %2\n  }\n  call %3 = clo<\"HourFromTime\">(t)\n  call %4 = clo<\"MinFromTime\">(t)\n  call %5 = clo<\"SecFromTime\">(t)\n  call %6 = clo<\"MakeTime\">(%3, %4, %5, ms)\n  let time = %6\n  call %7 = clo<\"Day\">(t)\n  call %8 = clo<\"MakeDate\">(%7, time)\n  call %9 = clo<\"TimeClip\">(%8)\n  let v = %9\n  dateObject.DateValue = v\n  if (? v: Completion) return v\n  call %10 = clo<\"NormalCompletion\">(v)\n  return %10\n}","def <BUILTIN>:INTRINSICS.Date.prototype.setUTCMinutes(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#949]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop min < ArgumentsList\n    expand __args__.min\n  } else let min = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop sec < ArgumentsList\n    expand __args__.sec\n  } else let sec = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop ms < ArgumentsList\n    expand __args__.ms\n  } else let ms = undefined\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  call %1 = clo<\"ToNumber\">(min)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let m = %1\n  if (exists __args__.sec) {\n    call %2 = clo<\"ToNumber\">(sec)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let s = %2\n  }\n  if (exists __args__.ms) {\n    call %3 = clo<\"ToNumber\">(ms)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let milli = %3\n  }\n  if (= t NaN) {\n    call %4 = clo<\"NormalCompletion\">(NaN)\n    return %4\n  }\n  if (! (exists __args__.sec)) {\n    call %5 = clo<\"SecFromTime\">(t)\n    let s = %5\n  }\n  if (! (exists __args__.ms)) {\n    (yet \"let _milli_ be msFromTime(_t_).\")\n  }\n  call %6 = clo<\"Day\">(t)\n  call %7 = clo<\"HourFromTime\">(t)\n  call %8 = clo<\"MakeTime\">(%7, m, s, milli)\n  call %9 = clo<\"MakeDate\">(%6, %8)\n  let date = %9\n  call %10 = clo<\"TimeClip\">(date)\n  let v = %10\n  dateObject.DateValue = v\n  if (? v: Completion) return v\n  call %11 = clo<\"NormalCompletion\">(v)\n  return %11\n}","def <BUILTIN>:INTRINSICS.Date.prototype.setUTCMonth(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#950]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop month < ArgumentsList\n    expand __args__.month\n  } else let month = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop date < ArgumentsList\n    expand __args__.date\n  } else let date = undefined\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  call %1 = clo<\"ToNumber\">(month)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let m = %1\n  if (exists __args__.date) {\n    call %2 = clo<\"ToNumber\">(date)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let dt = %2\n  }\n  if (= t NaN) {\n    call %3 = clo<\"NormalCompletion\">(NaN)\n    return %3\n  }\n  if (! (exists __args__.date)) {\n    call %4 = clo<\"DateFromTime\">(t)\n    let dt = %4\n  }\n  call %5 = clo<\"YearFromTime\">(t)\n  call %6 = clo<\"MakeDay\">(%5, m, dt)\n  call %7 = clo<\"TimeWithinDay\">(t)\n  call %8 = clo<\"MakeDate\">(%6, %7)\n  let newDate = %8\n  call %9 = clo<\"TimeClip\">(newDate)\n  let v = %9\n  dateObject.DateValue = v\n  if (? v: Completion) return v\n  call %10 = clo<\"NormalCompletion\">(v)\n  return %10\n}","def <BUILTIN>:INTRINSICS.Date.prototype.setUTCSeconds(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#951]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop sec < ArgumentsList\n    expand __args__.sec\n  } else let sec = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop ms < ArgumentsList\n    expand __args__.ms\n  } else let ms = undefined\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let t = dateObject.DateValue\n  call %1 = clo<\"ToNumber\">(sec)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let s = %1\n  if (exists __args__.ms) {\n    call %2 = clo<\"ToNumber\">(ms)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let milli = %2\n  }\n  if (= t NaN) {\n    call %3 = clo<\"NormalCompletion\">(NaN)\n    return %3\n  }\n  if (! (exists __args__.ms)) {\n    (yet \"let _milli_ be msFromTime(_t_).\")\n  }\n  call %4 = clo<\"Day\">(t)\n  call %5 = clo<\"HourFromTime\">(t)\n  call %6 = clo<\"MinFromTime\">(t)\n  call %7 = clo<\"MakeTime\">(%5, %6, s, milli)\n  call %8 = clo<\"MakeDate\">(%4, %7)\n  let date = %8\n  call %9 = clo<\"TimeClip\">(date)\n  let v = %9\n  dateObject.DateValue = v\n  if (? v: Completion) return v\n  call %10 = clo<\"NormalCompletion\">(v)\n  return %10\n}","def <BUILTIN>:INTRINSICS.Date.prototype.toDateString(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#952]\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let tv = dateObject.DateValue\n  if (= tv NaN) {\n    call %1 = clo<\"NormalCompletion\">(\"Invalid Date\")\n    return %1\n  }\n  call %2 = clo<\"LocalTime\">(tv)\n  let t = %2\n  call %3 = clo<\"DateString\">(t)\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Date.prototype.toISOString(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#953]\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let tv = dateObject.DateValue\n  if (|| (= tv NaN) (|| (= tv +NUM_INF) (= tv -NUM_INF))) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  (yet \"If _tv_ corresponds with a year that cannot be represented in the <emu-xref href=\\\"#sec-date-time-string-format\\\">Date Time String Format</emu-xref>, throw a *RangeError* exception.\")\n  (yet \"Return a String representation of _tv_ in the <emu-xref href=\\\"#sec-date-time-string-format\\\">Date Time String Format</emu-xref> on the UTC time scale, including all format elements and the UTC offset representation *\\\"Z\\\"*.\")\n}","def <BUILTIN>:INTRINSICS.Date.prototype.toJSON(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#954]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop key < ArgumentsList\n    expand __args__.key\n  } else let key = undefined\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"ToPrimitive\">(O, ~number~)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let tv = %1\n  if (&& (? tv: Number) (|| (= tv NaN) (|| (= tv +NUM_INF) (= tv -NUM_INF)))) {\n    call %2 = clo<\"NormalCompletion\">(null)\n    return %2\n  }\n  call %3 = clo<\"Invoke\">(O, \"toISOString\")\n  assert (? %3: Completion)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Date.prototype.toString(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#955]\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let tv = dateObject.DateValue\n  call %1 = clo<\"ToDateString\">(tv)\n  if (? %1: Completion) return %1\n  call %2 = clo<\"NormalCompletion\">(%1)\n  return %2\n}","def TimeString(\n  tv: Unknown[\"Number,ButNot*NaN*\"],\n): String = {\n  call %0 = clo<\"HourFromTime\">(tv)\n  call %1 = clo<\"ToZeroPaddedDecimalString\">(([math] %0), 2)\n  let hour = %1\n  call %2 = clo<\"MinFromTime\">(tv)\n  call %3 = clo<\"ToZeroPaddedDecimalString\">(([math] %2), 2)\n  let minute = %3\n  call %4 = clo<\"SecFromTime\">(tv)\n  call %5 = clo<\"ToZeroPaddedDecimalString\">(([math] %4), 2)\n  let second = %5\n  return (concat hour \":\" minute \":\" second 32cu \"GMT\")\n}","def DateString(\n  tv: Unknown[\"Number,ButNot*NaN*\"],\n): String = {\n  (yet \"Let _weekday_ be the Name of the entry in <emu-xref href=\\\"#sec-todatestring-day-names\\\"></emu-xref> with the Number WeekDay(_tv_).\")\n  (yet \"Let _month_ be the Name of the entry in <emu-xref href=\\\"#sec-todatestring-month-names\\\"></emu-xref> with the Number MonthFromTime(_tv_).\")\n  call %0 = clo<\"DateFromTime\">(tv)\n  call %1 = clo<\"ToZeroPaddedDecimalString\">(([math] %0), 2)\n  let day = %1\n  call %2 = clo<\"YearFromTime\">(tv)\n  let yv = %2\n  if (|| (= yv 0.0f) (< 0.0f yv)) {\n    let yearSign = \"\"\n  } else {\n    let yearSign = \"-\"\n  }\n  call %3 = clo<\"ToZeroPaddedDecimalString\">((abs ([math] yv)), 4)\n  let paddedYear = %3\n  return (concat weekday 32cu month 32cu day 32cu yearSign paddedYear)\n}","def TimeZoneString(\n  tv: Number[Int],\n): String = {\n  call %0 = clo<\"SystemTimeZoneIdentifier\">()\n  let systemTimeZoneIdentifier = %0\n  call %1 = clo<\"IsTimeZoneOffsetString\">(systemTimeZoneIdentifier)\n  if (= %1 true) {\n    call %2 = clo<\"ParseTimeZoneOffsetString\">(systemTimeZoneIdentifier)\n    let offsetNs = %2\n  } else {\n    call %3 = clo<\"GetNamedTimeZoneOffsetNanoseconds\">(systemTimeZoneIdentifier, ([bigInt] (* ([math] tv) (** 10 6))))\n    let offsetNs = %3\n  }\n  %4 = (/ offsetNs (** 10 6))\n  if (< %4 0) %4 = (- (floor (- %4)))\n  else %4 = (floor %4)\n  let offset = ([number] %4)\n  if (|| (= offset 0.0f) (< 0.0f offset)) {\n    let offsetSign = \"+\"\n    let absOffset = offset\n  } else {\n    let offsetSign = \"-\"\n    let absOffset = (- offset)\n  }\n  call %5 = clo<\"MinFromTime\">(absOffset)\n  call %6 = clo<\"ToZeroPaddedDecimalString\">(([math] %5), 2)\n  let offsetMin = %6\n  call %7 = clo<\"HourFromTime\">(absOffset)\n  call %8 = clo<\"ToZeroPaddedDecimalString\">(([math] %7), 2)\n  let offsetHour = %8\n  (yet \"Let _tzName_ be an implementation-defined string that is either the empty String or the string-concatenation of the code unit 0x0020 (SPACE), the code unit 0x0028 (LEFT PARENTHESIS), an implementation-defined timezone name, and the code unit 0x0029 (RIGHT PARENTHESIS).\")\n  return (concat offsetSign offsetHour offsetMin tzName)\n}","def ToDateString(\n  tv: Number[Int, NaN],\n): String = {\n  if (= tv NaN) {\n    return \"Invalid Date\"\n  }\n  call %0 = clo<\"LocalTime\">(tv)\n  let t = %0\n  call %1 = clo<\"DateString\">(t)\n  call %2 = clo<\"TimeString\">(t)\n  call %3 = clo<\"TimeZoneString\">(tv)\n  return (concat %1 32cu %2 %3)\n}","def <BUILTIN>:INTRINSICS.Date.prototype.toTimeString(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#956]\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let tv = dateObject.DateValue\n  if (= tv NaN) {\n    call %1 = clo<\"NormalCompletion\">(\"Invalid Date\")\n    return %1\n  }\n  call %2 = clo<\"LocalTime\">(tv)\n  let t = %2\n  call %3 = clo<\"TimeString\">(t)\n  call %4 = clo<\"TimeZoneString\">(tv)\n  %5 = (concat %3 %4)\n  if (? %5: Completion) return %5\n  call %6 = clo<\"NormalCompletion\">(%5)\n  return %6\n}","def <BUILTIN>:INTRINSICS.Date.prototype.toUTCString(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#957]\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let tv = dateObject.DateValue\n  if (= tv NaN) {\n    call %1 = clo<\"NormalCompletion\">(\"Invalid Date\")\n    return %1\n  }\n  (yet \"Let _weekday_ be the Name of the entry in <emu-xref href=\\\"#sec-todatestring-day-names\\\"></emu-xref> with the Number WeekDay(_tv_).\")\n  (yet \"Let _month_ be the Name of the entry in <emu-xref href=\\\"#sec-todatestring-month-names\\\"></emu-xref> with the Number MonthFromTime(_tv_).\")\n  call %2 = clo<\"DateFromTime\">(tv)\n  call %3 = clo<\"ToZeroPaddedDecimalString\">(([math] %2), 2)\n  let day = %3\n  call %4 = clo<\"YearFromTime\">(tv)\n  let yv = %4\n  if (|| (= yv 0.0f) (< 0.0f yv)) {\n    let yearSign = \"\"\n  } else {\n    let yearSign = \"-\"\n  }\n  call %5 = clo<\"ToZeroPaddedDecimalString\">((abs ([math] yv)), 4)\n  let paddedYear = %5\n  call %6 = clo<\"TimeString\">(tv)\n  %7 = (concat weekday \",\" 32cu day 32cu month 32cu yearSign paddedYear 32cu %6)\n  if (? %7: Completion) return %7\n  call %8 = clo<\"NormalCompletion\">(%7)\n  return %8\n}","def <BUILTIN>:INTRINSICS.Date.prototype.valueOf(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#958]\n  let dateObject = this\n  call %0 = clo<\"RequireInternalSlot\">(dateObject, \"DateValue\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  %1 = dateObject.DateValue\n  if (? %1: Completion) return %1\n  call %2 = clo<\"NormalCompletion\">(%1)\n  return %2\n}","def <BUILTIN>:INTRINSICS.Date.prototype[@@toPrimitive](\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#959]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop hint < ArgumentsList\n    expand __args__.hint\n  } else let hint = undefined\n  let O = this\n  if (! (? O: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  if (|| (= hint \"string\") (= hint \"default\")) {\n    let tryFirst = ~string~\n  } else {\n    if (= hint \"number\") {\n      let tryFirst = ~number~\n    } else {\n      call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %3 = clo<\"ThrowCompletion\">(%2)\n      return %3\n    }\n  }\n  call %4 = clo<\"OrdinaryToPrimitive\">(O, tryFirst)\n  assert (? %4: Completion)\n  return %4\n}","def <BUILTIN>:INTRINSICS.String(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#960]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  if (! (exists __args__.value)) {\n    let s = \"\"\n  } else {\n    if (&& (= NewTarget undefined) (? value: Record[Symbol])) {\n      call %0 = clo<\"SymbolDescriptiveString\">(value)\n      if (? %0: Completion) return %0\n      call %1 = clo<\"NormalCompletion\">(%0)\n      return %1\n    }\n    call %2 = clo<\"ToString\">(value)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let s = %2\n  }\n  if (= NewTarget undefined) {\n    if (? s: Completion) return s\n    call %3 = clo<\"NormalCompletion\">(s)\n    return %3\n  }\n  call %4 = clo<\"GetPrototypeFromConstructor\">(NewTarget, \"%String.prototype%\")\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  call %5 = clo<\"StringCreate\">(s, %4)\n  if (? %5: Completion) return %5\n  call %6 = clo<\"NormalCompletion\">(%5)\n  return %6\n}","def <BUILTIN>:INTRINSICS.String.fromCharCode(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#961]\n  let codeUnits = ArgumentsList\n  let result = \"\"\n  %1 = codeUnits\n  %0 = 0\n  while (< %0 (sizeof %1)) {\n    let next = %1[%0]\n    (yet \"Let _nextCU_ be the code unit whose numeric value is ‚Ñù(? ToUint16(_next_)).\")\n    result = (concat result nextCU)\n    %0 = (+ %0 1)\n  }\n  if (? result: Completion) return result\n  call %2 = clo<\"NormalCompletion\">(result)\n  return %2\n}","def <BUILTIN>:INTRINSICS.String.fromCodePoint(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#962]\n  let codePoints = ArgumentsList\n  let result = \"\"\n  %1 = codePoints\n  %0 = 0\n  while (< %0 (sizeof %1)) {\n    let next = %1[%0]\n    call %2 = clo<\"ToNumber\">(next)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let nextCP = %2\n    call %3 = clo<\"IsIntegralNumber\">(nextCP)\n    if (= %3 false) {\n      call %4 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n      call %5 = clo<\"ThrowCompletion\">(%4)\n      return %5\n    }\n    if (|| (< ([math] nextCP) 0) (< 1114111 ([math] nextCP))) {\n      call %6 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n      call %7 = clo<\"ThrowCompletion\">(%6)\n      return %7\n    }\n    call %8 = clo<\"UTF16EncodeCodePoint\">(([math] nextCP))\n    result = (concat result %8)\n    %0 = (+ %0 1)\n  }\n  assert (|| (! (= (sizeof codePoints) 0)) (= result \"\"))\n  if (? result: Completion) return result\n  call %9 = clo<\"NormalCompletion\">(result)\n  return %9\n}","def <BUILTIN>:INTRINSICS.String.raw(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#963]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop template < ArgumentsList\n    expand __args__.template\n  } else let template = undefined\n  let substitutions = ArgumentsList\n  let substitutionCount = (sizeof substitutions)\n  call %0 = clo<\"ToObject\">(template)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let cooked = %0\n  call %1 = clo<\"Get\">(cooked, \"raw\")\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  call %2 = clo<\"ToObject\">(%1)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let literals = %2\n  call %3 = clo<\"LengthOfArrayLike\">(literals)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let literalCount = %3\n  if (! (< 0 literalCount)) {\n    call %4 = clo<\"NormalCompletion\">(\"\")\n    return %4\n  }\n  let R = \"\"\n  let nextIndex = 0\n  while true {\n    call %5 = clo<\"ToString\">(([number] nextIndex))\n    assert (? %5: Normal)\n    %5 = %5.Value\n    call %6 = clo<\"Get\">(literals, %5)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    let nextLiteralVal = %6\n    call %7 = clo<\"ToString\">(nextLiteralVal)\n    assert (? %7: Completion)\n    if (? %7: Abrupt) return %7\n    else %7 = %7.Value\n    let nextLiteral = %7\n    R = (concat R nextLiteral)\n    if (== (+ nextIndex 1) literalCount) {\n      if (? R: Completion) return R\n      call %8 = clo<\"NormalCompletion\">(R)\n      return %8\n    }\n    if (< nextIndex substitutionCount) {\n      let nextSubVal = substitutions[nextIndex]\n      call %9 = clo<\"ToString\">(nextSubVal)\n      assert (? %9: Completion)\n      if (? %9: Abrupt) return %9\n      else %9 = %9.Value\n      let nextSub = %9\n      R = (concat R nextSub)\n    }\n    nextIndex = (+ nextIndex 1)\n  }\n}","def <BUILTIN>:INTRINSICS.String.prototype.at(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#964]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop index < ArgumentsList\n    expand __args__.index\n  } else let index = undefined\n  call %0 = clo<\"RequireObjectCoercible\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"ToString\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let S = %1\n  let len = (sizeof S)\n  call %2 = clo<\"ToIntegerOrInfinity\">(index)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let relativeIndex = %2\n  if (! (< relativeIndex 0)) {\n    let k = relativeIndex\n  } else {\n    let k = (+ len relativeIndex)\n  }\n  if (|| (< k 0) (! (< k len))) {\n    call %3 = clo<\"NormalCompletion\">(undefined)\n    return %3\n  }\n  %4 = (substring S k (+ k 1))\n  if (? %4: Completion) return %4\n  call %5 = clo<\"NormalCompletion\">(%4)\n  return %5\n}","def <BUILTIN>:INTRINSICS.String.prototype.charAt(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#965]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop pos < ArgumentsList\n    expand __args__.pos\n  } else let pos = undefined\n  call %0 = clo<\"RequireObjectCoercible\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"ToString\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let S = %1\n  call %2 = clo<\"ToIntegerOrInfinity\">(pos)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let position = %2\n  let size = (sizeof S)\n  if (|| (< position 0) (! (< position size))) {\n    call %3 = clo<\"NormalCompletion\">(\"\")\n    return %3\n  }\n  %4 = (substring S position (+ position 1))\n  if (? %4: Completion) return %4\n  call %5 = clo<\"NormalCompletion\">(%4)\n  return %5\n}","def <BUILTIN>:INTRINSICS.String.prototype.charCodeAt(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#966]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop pos < ArgumentsList\n    expand __args__.pos\n  } else let pos = undefined\n  call %0 = clo<\"RequireObjectCoercible\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"ToString\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let S = %1\n  call %2 = clo<\"ToIntegerOrInfinity\">(pos)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let position = %2\n  let size = (sizeof S)\n  if (|| (< position 0) (! (< position size))) {\n    call %3 = clo<\"NormalCompletion\">(NaN)\n    return %3\n  }\n  %4 = ([number] ([math] S[position]))\n  if (? %4: Completion) return %4\n  call %5 = clo<\"NormalCompletion\">(%4)\n  return %5\n}","def <BUILTIN>:INTRINSICS.String.prototype.codePointAt(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#967]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop pos < ArgumentsList\n    expand __args__.pos\n  } else let pos = undefined\n  call %0 = clo<\"RequireObjectCoercible\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"ToString\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let S = %1\n  call %2 = clo<\"ToIntegerOrInfinity\">(pos)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let position = %2\n  let size = (sizeof S)\n  if (|| (< position 0) (! (< position size))) {\n    call %3 = clo<\"NormalCompletion\">(undefined)\n    return %3\n  }\n  call %4 = clo<\"CodePointAt\">(S, position)\n  let cp = %4\n  %5 = ([number] cp.CodePoint)\n  if (? %5: Completion) return %5\n  call %6 = clo<\"NormalCompletion\">(%5)\n  return %6\n}","def <BUILTIN>:INTRINSICS.String.prototype.concat(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#968]\n  let args = ArgumentsList\n  call %0 = clo<\"RequireObjectCoercible\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"ToString\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let S = %1\n  let R = S\n  %3 = args\n  %2 = 0\n  while (< %2 (sizeof %3)) {\n    let next = %3[%2]\n    call %4 = clo<\"ToString\">(next)\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    let nextString = %4\n    R = (concat R nextString)\n    %2 = (+ %2 1)\n  }\n  if (? R: Completion) return R\n  call %5 = clo<\"NormalCompletion\">(R)\n  return %5\n}","def <BUILTIN>:INTRINSICS.String.prototype.endsWith(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#969]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop searchString < ArgumentsList\n    expand __args__.searchString\n  } else let searchString = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop endPosition < ArgumentsList\n    expand __args__.endPosition\n  } else let endPosition = undefined\n  call %0 = clo<\"RequireObjectCoercible\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"ToString\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let S = %1\n  call %2 = clo<\"IsRegExp\">(searchString)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let isRegExp = %2\n  if (= isRegExp true) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  call %5 = clo<\"ToString\">(searchString)\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  let searchStr = %5\n  let len = (sizeof S)\n  if (= endPosition undefined) {\n    let pos = len\n  } else {\n    call %6 = clo<\"ToIntegerOrInfinity\">(endPosition)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    let pos = %6\n  }\n  call %7 = clo<\"__CLAMP__\">(pos, 0, len)\n  let end = %7\n  let searchLength = (sizeof searchStr)\n  if (== searchLength 0) {\n    call %8 = clo<\"NormalCompletion\">(true)\n    return %8\n  }\n  let start = (- end searchLength)\n  if (< start 0) {\n    call %9 = clo<\"NormalCompletion\">(false)\n    return %9\n  }\n  let substring = (substring S start end)\n  if (= substring searchStr) {\n    call %10 = clo<\"NormalCompletion\">(true)\n    return %10\n  }\n  call %11 = clo<\"NormalCompletion\">(false)\n  return %11\n}","def <BUILTIN>:INTRINSICS.String.prototype.includes(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#970]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop searchString < ArgumentsList\n    expand __args__.searchString\n  } else let searchString = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop position < ArgumentsList\n    expand __args__.position\n  } else let position = undefined\n  call %0 = clo<\"RequireObjectCoercible\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"ToString\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let S = %1\n  call %2 = clo<\"IsRegExp\">(searchString)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let isRegExp = %2\n  if (= isRegExp true) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  call %5 = clo<\"ToString\">(searchString)\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  let searchStr = %5\n  call %6 = clo<\"ToIntegerOrInfinity\">(position)\n  assert (? %6: Completion)\n  if (? %6: Abrupt) return %6\n  else %6 = %6.Value\n  let pos = %6\n  assert (|| (! (= position undefined)) (= pos 0))\n  let len = (sizeof S)\n  call %7 = clo<\"__CLAMP__\">(pos, 0, len)\n  let start = %7\n  call %8 = clo<\"StringIndexOf\">(S, searchStr, start)\n  let index = %8\n  if (! (== index (- 1))) {\n    call %9 = clo<\"NormalCompletion\">(true)\n    return %9\n  }\n  call %10 = clo<\"NormalCompletion\">(false)\n  return %10\n}","def <BUILTIN>:INTRINSICS.String.prototype.indexOf(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#971]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop searchString < ArgumentsList\n    expand __args__.searchString\n  } else let searchString = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop position < ArgumentsList\n    expand __args__.position\n  } else let position = undefined\n  call %0 = clo<\"RequireObjectCoercible\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"ToString\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let S = %1\n  call %2 = clo<\"ToString\">(searchString)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let searchStr = %2\n  call %3 = clo<\"ToIntegerOrInfinity\">(position)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let pos = %3\n  assert (|| (! (= position undefined)) (= pos 0))\n  let len = (sizeof S)\n  call %4 = clo<\"__CLAMP__\">(pos, 0, len)\n  let start = %4\n  call %5 = clo<\"StringIndexOf\">(S, searchStr, start)\n  %6 = ([number] %5)\n  if (? %6: Completion) return %6\n  call %7 = clo<\"NormalCompletion\">(%6)\n  return %7\n}","def <BUILTIN>:INTRINSICS.String.prototype.isWellFormed(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#972]\n  call %0 = clo<\"RequireObjectCoercible\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"ToString\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let S = %1\n  call %2 = clo<\"IsStringWellFormedUnicode\">(S)\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <BUILTIN>:INTRINSICS.String.prototype.lastIndexOf(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#973]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop searchString < ArgumentsList\n    expand __args__.searchString\n  } else let searchString = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop position < ArgumentsList\n    expand __args__.position\n  } else let position = undefined\n  call %0 = clo<\"RequireObjectCoercible\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"ToString\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let S = %1\n  call %2 = clo<\"ToString\">(searchString)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let searchStr = %2\n  call %3 = clo<\"ToNumber\">(position)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let numPos = %3\n  assert (|| (! (= position undefined)) (= numPos NaN))\n  if (= numPos NaN) {\n    let pos = +INF\n  } else {\n    call %4 = clo<\"ToIntegerOrInfinity\">(numPos)\n    assert (? %4: Normal)\n    %4 = %4.Value\n    let pos = %4\n  }\n  let len = (sizeof S)\n  let searchLen = (sizeof searchStr)\n  call %5 = clo<\"__CLAMP__\">(pos, 0, (- len searchLen))\n  let start = %5\n  if (= searchStr \"\") {\n    %6 = ([number] start)\n    if (? %6: Completion) return %6\n    call %7 = clo<\"NormalCompletion\">(%6)\n    return %7\n  }\n  let i = start\n  while (! (< i 0)) {\n    let candidate = (substring S i (+ i searchLen))\n    if (= candidate searchStr) {\n      %8 = ([number] i)\n      if (? %8: Completion) return %8\n      call %9 = clo<\"NormalCompletion\">(%8)\n      return %9\n    }\n    i = (- i 1)\n  }\n  call %10 = clo<\"NormalCompletion\">(-1.0f)\n  return %10\n}","def <BUILTIN>:INTRINSICS.String.prototype.localeCompare(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#974]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop that < ArgumentsList\n    expand __args__.that\n  } else let that = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop reserved1 < ArgumentsList\n    expand __args__.reserved1\n  } else let reserved1 = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop reserved2 < ArgumentsList\n    expand __args__.reserved2\n  } else let reserved2 = undefined\n  call %0 = clo<\"RequireObjectCoercible\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"ToString\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let S = %1\n  call %2 = clo<\"ToString\">(that)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let thatValue = %2\n}","def <BUILTIN>:INTRINSICS.String.prototype.match(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#975]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop regexp < ArgumentsList\n    expand __args__.regexp\n  } else let regexp = undefined\n  call %0 = clo<\"RequireObjectCoercible\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  if (! (|| (= regexp undefined) (= regexp null))) {\n    call %1 = clo<\"GetMethod\">(regexp, @SYMBOL.match)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let matcher = %1\n    if (! (= matcher undefined)) {\n      call %2 = clo<\"Call\">(matcher, regexp, (list [O])[#976])\n      assert (? %2: Completion)\n      return %2\n    }\n  }\n  call %3 = clo<\"ToString\">(O)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let S = %3\n  call %4 = clo<\"RegExpCreate\">(regexp, undefined)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let rx = %4\n  call %5 = clo<\"Invoke\">(rx, @SYMBOL.match, (list [S])[#977])\n  assert (? %5: Completion)\n  return %5\n}","def <BUILTIN>:INTRINSICS.String.prototype.matchAll(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#978]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop regexp < ArgumentsList\n    expand __args__.regexp\n  } else let regexp = undefined\n  call %0 = clo<\"RequireObjectCoercible\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  if (! (|| (= regexp undefined) (= regexp null))) {\n    call %1 = clo<\"IsRegExp\">(regexp)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let isRegExp = %1\n    if (= isRegExp true) {\n      call %2 = clo<\"Get\">(regexp, \"flags\")\n      assert (? %2: Completion)\n      if (? %2: Abrupt) return %2\n      else %2 = %2.Value\n      let flags = %2\n      call %3 = clo<\"RequireObjectCoercible\">(flags)\n      assert (? %3: Completion)\n      if (? %3: Abrupt) return %3\n      else %3 = %3.Value\n      call %4 = clo<\"ToString\">(flags)\n      assert (? %4: Completion)\n      if (? %4: Abrupt) return %4\n      else %4 = %4.Value\n      if (! (contains %4 \"g\")) {\n        call %5 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n        call %6 = clo<\"ThrowCompletion\">(%5)\n        return %6\n      }\n    }\n    call %7 = clo<\"GetMethod\">(regexp, @SYMBOL.matchAll)\n    assert (? %7: Completion)\n    if (? %7: Abrupt) return %7\n    else %7 = %7.Value\n    let matcher = %7\n    if (! (= matcher undefined)) {\n      call %8 = clo<\"Call\">(matcher, regexp, (list [O])[#979])\n      assert (? %8: Completion)\n      return %8\n    }\n  }\n  call %9 = clo<\"ToString\">(O)\n  assert (? %9: Completion)\n  if (? %9: Abrupt) return %9\n  else %9 = %9.Value\n  let S = %9\n  call %10 = clo<\"RegExpCreate\">(regexp, \"g\")\n  assert (? %10: Completion)\n  if (? %10: Abrupt) return %10\n  else %10 = %10.Value\n  let rx = %10\n  call %11 = clo<\"Invoke\">(rx, @SYMBOL.matchAll, (list [S])[#980])\n  assert (? %11: Completion)\n  return %11\n}","def <BUILTIN>:INTRINSICS.String.prototype.normalize(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#981]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop form < ArgumentsList\n    expand __args__.form\n  } else let form = undefined\n  call %0 = clo<\"RequireObjectCoercible\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"ToString\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let S = %1\n  if (= form undefined) {\n    let f = \"NFC\"\n  } else {\n    call %2 = clo<\"ToString\">(form)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let f = %2\n  }\n  if (! (|| (|| (|| (= f \"NFC\") (= f \"NFD\")) (= f \"NFKC\")) (= f \"NFKD\"))) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  (yet \"Let _ns_ be the String value that is the result of normalizing _S_ into the normalization form named by _f_ as specified in <a href=\\\"https://www.unicode.org/versions/latest/ch03.pdf\\\">the latest Unicode Standard, Normalization Forms</a>.\")\n  if (? ns: Completion) return ns\n  call %5 = clo<\"NormalCompletion\">(ns)\n  return %5\n}","def <BUILTIN>:INTRINSICS.String.prototype.padEnd(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#982]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop maxLength < ArgumentsList\n    expand __args__.maxLength\n  } else let maxLength = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop fillString < ArgumentsList\n    expand __args__.fillString\n  } else let fillString = undefined\n  call %0 = clo<\"RequireObjectCoercible\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"StringPaddingBuiltinsImpl\">(O, maxLength, fillString, ~end~)\n  assert (? %1: Completion)\n  return %1\n}","def <BUILTIN>:INTRINSICS.String.prototype.padStart(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#983]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop maxLength < ArgumentsList\n    expand __args__.maxLength\n  } else let maxLength = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop fillString < ArgumentsList\n    expand __args__.fillString\n  } else let fillString = undefined\n  call %0 = clo<\"RequireObjectCoercible\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"StringPaddingBuiltinsImpl\">(O, maxLength, fillString, ~start~)\n  assert (? %1: Completion)\n  return %1\n}","def StringPaddingBuiltinsImpl(\n  O: ESValue,\n  maxLength: ESValue,\n  fillString: ESValue,\n  placement: Enum[~end~, ~start~],\n): Normal[String] | Throw = {\n  call %0 = clo<\"ToString\">(O)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let S = %0\n  call %1 = clo<\"ToLength\">(maxLength)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let intMaxLength = ([math] %1)\n  let stringLength = (sizeof S)\n  if (! (< stringLength intMaxLength)) {\n    if (? S: Completion) return S\n    call %2 = clo<\"NormalCompletion\">(S)\n    return %2\n  }\n  if (= fillString undefined) {\n    (yet \"set _fillString_ to the String value consisting solely of the code unit 0x0020 (SPACE).\")\n  } else {\n    call %3 = clo<\"ToString\">(fillString)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    fillString = %3\n  }\n  call %4 = clo<\"StringPad\">(S, intMaxLength, fillString, placement)\n  if (? %4: Completion) return %4\n  call %5 = clo<\"NormalCompletion\">(%4)\n  return %5\n}","def StringPad(\n  S: String,\n  maxLength: NonNegInt,\n  fillString: String,\n  placement: Enum[~end~, ~start~],\n): String = {\n  let stringLength = (sizeof S)\n  if (! (< stringLength maxLength)) {\n    return S\n  }\n  if (= fillString \"\") {\n    return S\n  }\n  let fillLen = (- maxLength stringLength)\n  (yet \"Let _truncatedStringFiller_ be the String value consisting of repeated concatenations of _fillString_ truncated to length _fillLen_.\")\n  if (= placement ~start~) {\n    return (concat truncatedStringFiller S)\n  } else {\n    return (concat S truncatedStringFiller)\n  }\n}","def ToZeroPaddedDecimalString(\n  n: NonNegInt,\n  minLength: NonNegInt,\n): String = {\n  (yet \"Let _S_ be the String representation of _n_, formatted as a decimal number.\")\n  call %0 = clo<\"StringPad\">(S, minLength, \"0\", ~start~)\n  return %0\n}","def <BUILTIN>:INTRINSICS.String.prototype.repeat(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#984]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop count < ArgumentsList\n    expand __args__.count\n  } else let count = undefined\n  call %0 = clo<\"RequireObjectCoercible\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"ToString\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let S = %1\n  call %2 = clo<\"ToIntegerOrInfinity\">(count)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let n = %2\n  if (|| (< n 0) (== n +INF)) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  if (== n 0) {\n    call %5 = clo<\"NormalCompletion\">(\"\")\n    return %5\n  }\n  (yet \"Return the String value that is made from _n_ copies of _S_ appended together.\")\n}","def <BUILTIN>:INTRINSICS.String.prototype.replace(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#985]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop searchValue < ArgumentsList\n    expand __args__.searchValue\n  } else let searchValue = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop replaceValue < ArgumentsList\n    expand __args__.replaceValue\n  } else let replaceValue = undefined\n  call %0 = clo<\"RequireObjectCoercible\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  if (! (|| (= searchValue undefined) (= searchValue null))) {\n    call %1 = clo<\"GetMethod\">(searchValue, @SYMBOL.replace)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let replacer = %1\n    if (! (= replacer undefined)) {\n      call %2 = clo<\"Call\">(replacer, searchValue, (list [O, replaceValue])[#986])\n      assert (? %2: Completion)\n      return %2\n    }\n  }\n  call %3 = clo<\"ToString\">(O)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let string = %3\n  call %4 = clo<\"ToString\">(searchValue)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let searchString = %4\n  call %5 = clo<\"IsCallable\">(replaceValue)\n  let functionalReplace = %5\n  if (= functionalReplace false) {\n    call %6 = clo<\"ToString\">(replaceValue)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    replaceValue = %6\n  }\n  let searchLength = (sizeof searchString)\n  call %7 = clo<\"StringIndexOf\">(string, searchString, 0)\n  let position = %7\n  if (== position (- 1)) {\n    if (? string: Completion) return string\n    call %8 = clo<\"NormalCompletion\">(string)\n    return %8\n  }\n  let preceding = (substring string 0 position)\n  let following = (substring string (+ position searchLength))\n  if (= functionalReplace true) {\n    call %9 = clo<\"Call\">(replaceValue, undefined, (list [searchString, ([number] position), string])[#987])\n    assert (? %9: Completion)\n    if (? %9: Abrupt) return %9\n    else %9 = %9.Value\n    call %10 = clo<\"ToString\">(%9)\n    assert (? %10: Completion)\n    if (? %10: Abrupt) return %10\n    else %10 = %10.Value\n    let replacement = %10\n  } else {\n    assert (? replaceValue: String)\n    let captures = (list [])[#988]\n    call %11 = clo<\"GetSubstitution\">(searchString, string, position, captures, undefined, replaceValue)\n    assert (? %11: Normal)\n    %11 = %11.Value\n    let replacement = %11\n  }\n  %12 = (concat preceding replacement following)\n  if (? %12: Completion) return %12\n  call %13 = clo<\"NormalCompletion\">(%12)\n  return %13\n}","def GetSubstitution(\n  matched: String,\n  str: String,\n  position: NonNegInt,\n  captures: List[String | Undefined],\n  namedCaptures: Record[Object] | Undefined,\n  replacementTemplate: String,\n): Normal[String] | Throw = {\n  let stringLength = (sizeof str)\n  assert (! (< stringLength position))\n  let result = \"\"\n  let templateRemainder = replacementTemplate\n  while (! (= templateRemainder \"\")) {\n    nop\n    (yet \"If _templateRemainder_ starts with *\\\"$$\\\"*, then\\n  1. Let _ref_ be *\\\"$$\\\"*.\\n  1. Let _refReplacement_ be *\\\"$\\\"*.\")\n    (yet \"Else if _templateRemainder_ starts with *\\\"$`\\\"*, then\\n  1. Let _ref_ be *\\\"$`\\\"*.\\n  1. Let _refReplacement_ be the substring of _str_ from 0 to _position_.\")\n    (yet \"Else if _templateRemainder_ starts with *\\\"$&\\\"*, then\\n  1. Let _ref_ be *\\\"$&\\\"*.\\n  1. Let _refReplacement_ be _matched_.\")\n    (yet \"Else if _templateRemainder_ starts with *\\\"$'\\\"* (0x0024 (DOLLAR SIGN) followed by 0x0027 (APOSTROPHE)), then\\n  1. Let _ref_ be *\\\"$'\\\"*.\\n  1. Let _matchLength_ be the length of _matched_.\\n  1. Let _tailPos_ be _position_ + _matchLength_.\\n  1. Let _refReplacement_ be the substring of _str_ from min(_tailPos_, _stringLength_).\\n  1. NOTE: _tailPos_ can exceed _stringLength_ only if this abstract operation was invoked by a call to the intrinsic @@replace method of %RegExp.prototype% on an object whose *\\\"exec\\\"* property is not the intrinsic %RegExp.prototype.exec%.\")\n    (yet \"Else if _templateRemainder_ starts with *\\\"$\\\"* followed by 1 or more decimal digits, then\\n  1. If _templateRemainder_ starts with *\\\"$\\\"* followed by 2 or more decimal digits, let _digitCount_ be 2. Otherwise, let _digitCount_ be 1.\\n  1. Let _digits_ be the substring of _templateRemainder_ from 1 to 1 + _digitCount_.\\n  1. Let _index_ be ‚Ñù(StringToNumber(_digits_)).\\n  1. Assert: 0 ‚â§ _index_ ‚â§ 99..\\n  1. Let _captureLen_ be the number of elements in _captures_.\\n  1. If _index_ > _captureLen_ and _digitCount_ = 2, then\\n    1. NOTE: When a two-digit replacement pattern specifies an index exceeding the count of capturing groups, it is treated as a one-digit replacement pattern followed by a literal digit.\\n    1. Set _digitCount_ to 1.\\n    1. Set _digits_ to the substring of _digits_ from 0 to 1.\\n    1. Set _index_ to ‚Ñù(StringToNumber(_digits_)).\\n  1. Let _ref_ be the substring of _templateRemainder_ from 0 to 1 + _digitCount_.\\n  1. If 1 ‚â§ _index_ ‚â§ _captureLen_, then\\n    1. Let _capture_ be _captures_[_index_ - 1].\\n    1. If _capture_ is *undefined*, then\\n      1. Let _refReplacement_ be *\\\"\\\"*.\\n    1. Else,\\n      1. Let _refReplacement_ be _capture_.\\n  1. Else,\\n    1. Let _refReplacement_ be _ref_.\")\n    (yet \"Else if _templateRemainder_ starts with *\\\"$<\\\"*, then\\n  1. Let _gtPos_ be StringIndexOf(_templateRemainder_, *\\\">\\\"*, 0).\\n  1. If _gtPos_ = -1 or _namedCaptures_ is *undefined*, then\\n    1. Let _ref_ be *\\\"$<\\\"*.\\n    1. Let _refReplacement_ be _ref_.\\n  1. Else,\\n    1. Let _ref_ be the substring of _templateRemainder_ from 0 to _gtPos_ + 1.\\n    1. Let _groupName_ be the substring of _templateRemainder_ from 2 to _gtPos_.\\n    1. Assert: _namedCaptures_ is a Record[Object].\\n    1. Let _capture_ be ? Get(_namedCaptures_, _groupName_).\\n    1. If _capture_ is *undefined*, then\\n      1. Let _refReplacement_ be *\\\"\\\"*.\\n    1. Else,\\n      1. Let _refReplacement_ be ? ToString(_capture_).\")\n    (yet \"Else,\\n  1. Let _ref_ be the substring of _templateRemainder_ from 0 to 1.\\n  1. Let _refReplacement_ be _ref_.\")\n    let refLength = (sizeof ref)\n    templateRemainder = (substring templateRemainder refLength)\n    result = (concat result refReplacement)\n  }\n  if (? result: Completion) return result\n  call %0 = clo<\"NormalCompletion\">(result)\n  return %0\n}","def <BUILTIN>:INTRINSICS.String.prototype.replaceAll(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#989]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop searchValue < ArgumentsList\n    expand __args__.searchValue\n  } else let searchValue = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop replaceValue < ArgumentsList\n    expand __args__.replaceValue\n  } else let replaceValue = undefined\n  call %0 = clo<\"RequireObjectCoercible\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  if (! (|| (= searchValue undefined) (= searchValue null))) {\n    call %1 = clo<\"IsRegExp\">(searchValue)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let isRegExp = %1\n    if (= isRegExp true) {\n      call %2 = clo<\"Get\">(searchValue, \"flags\")\n      assert (? %2: Completion)\n      if (? %2: Abrupt) return %2\n      else %2 = %2.Value\n      let flags = %2\n      call %3 = clo<\"RequireObjectCoercible\">(flags)\n      assert (? %3: Completion)\n      if (? %3: Abrupt) return %3\n      else %3 = %3.Value\n      call %4 = clo<\"ToString\">(flags)\n      assert (? %4: Completion)\n      if (? %4: Abrupt) return %4\n      else %4 = %4.Value\n      if (! (contains %4 \"g\")) {\n        call %5 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n        call %6 = clo<\"ThrowCompletion\">(%5)\n        return %6\n      }\n    }\n    call %7 = clo<\"GetMethod\">(searchValue, @SYMBOL.replace)\n    assert (? %7: Completion)\n    if (? %7: Abrupt) return %7\n    else %7 = %7.Value\n    let replacer = %7\n    if (! (= replacer undefined)) {\n      call %8 = clo<\"Call\">(replacer, searchValue, (list [O, replaceValue])[#990])\n      assert (? %8: Completion)\n      return %8\n    }\n  }\n  call %9 = clo<\"ToString\">(O)\n  assert (? %9: Completion)\n  if (? %9: Abrupt) return %9\n  else %9 = %9.Value\n  let string = %9\n  call %10 = clo<\"ToString\">(searchValue)\n  assert (? %10: Completion)\n  if (? %10: Abrupt) return %10\n  else %10 = %10.Value\n  let searchString = %10\n  call %11 = clo<\"IsCallable\">(replaceValue)\n  let functionalReplace = %11\n  if (= functionalReplace false) {\n    call %12 = clo<\"ToString\">(replaceValue)\n    assert (? %12: Completion)\n    if (? %12: Abrupt) return %12\n    else %12 = %12.Value\n    replaceValue = %12\n  }\n  let searchLength = (sizeof searchString)\n  let advanceBy = (max 1 searchLength)\n  let matchPositions = (list [])[#991]\n  call %13 = clo<\"StringIndexOf\">(string, searchString, 0)\n  let position = %13\n  while (! (== position (- 1))) {\n    push matchPositions < position\n    call %14 = clo<\"StringIndexOf\">(string, searchString, (+ position advanceBy))\n    position = %14\n  }\n  let endOfLastMatch = 0\n  let result = \"\"\n  %16 = matchPositions\n  %15 = 0\n  while (< %15 (sizeof %16)) {\n    let p = %16[%15]\n    let preserved = (substring string endOfLastMatch p)\n    if (= functionalReplace true) {\n      call %17 = clo<\"Call\">(replaceValue, undefined, (list [searchString, ([number] p), string])[#992])\n      assert (? %17: Completion)\n      if (? %17: Abrupt) return %17\n      else %17 = %17.Value\n      call %18 = clo<\"ToString\">(%17)\n      assert (? %18: Completion)\n      if (? %18: Abrupt) return %18\n      else %18 = %18.Value\n      let replacement = %18\n    } else {\n      assert (? replaceValue: String)\n      let captures = (list [])[#993]\n      call %19 = clo<\"GetSubstitution\">(searchString, string, p, captures, undefined, replaceValue)\n      assert (? %19: Normal)\n      %19 = %19.Value\n      let replacement = %19\n    }\n    result = (concat result preserved replacement)\n    endOfLastMatch = (+ p searchLength)\n    %15 = (+ %15 1)\n  }\n  if (< endOfLastMatch (sizeof string)) {\n    result = (concat result (substring string endOfLastMatch))\n  }\n  if (? result: Completion) return result\n  call %20 = clo<\"NormalCompletion\">(result)\n  return %20\n}","def <BUILTIN>:INTRINSICS.String.prototype.search(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#994]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop regexp < ArgumentsList\n    expand __args__.regexp\n  } else let regexp = undefined\n  call %0 = clo<\"RequireObjectCoercible\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  if (! (|| (= regexp undefined) (= regexp null))) {\n    call %1 = clo<\"GetMethod\">(regexp, @SYMBOL.search)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let searcher = %1\n    if (! (= searcher undefined)) {\n      call %2 = clo<\"Call\">(searcher, regexp, (list [O])[#995])\n      assert (? %2: Completion)\n      return %2\n    }\n  }\n  call %3 = clo<\"ToString\">(O)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let string = %3\n  call %4 = clo<\"RegExpCreate\">(regexp, undefined)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let rx = %4\n  call %5 = clo<\"Invoke\">(rx, @SYMBOL.search, (list [string])[#996])\n  assert (? %5: Completion)\n  return %5\n}","def <BUILTIN>:INTRINSICS.String.prototype.slice(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#997]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop start < ArgumentsList\n    expand __args__.start\n  } else let start = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop end < ArgumentsList\n    expand __args__.end\n  } else let end = undefined\n  call %0 = clo<\"RequireObjectCoercible\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"ToString\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let S = %1\n  let len = (sizeof S)\n  call %2 = clo<\"ToIntegerOrInfinity\">(start)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let intStart = %2\n  if (== intStart -INF) {\n    let from = 0\n  } else {\n    if (< intStart 0) {\n      let from = (max (+ len intStart) 0)\n    } else {\n      let from = (min intStart len)\n    }\n  }\n  if (= end undefined) {\n    let intEnd = len\n  } else {\n    call %3 = clo<\"ToIntegerOrInfinity\">(end)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let intEnd = %3\n  }\n  if (== intEnd -INF) {\n    let to = 0\n  } else {\n    if (< intEnd 0) {\n      let to = (max (+ len intEnd) 0)\n    } else {\n      let to = (min intEnd len)\n    }\n  }\n  if (! (< from to)) {\n    call %4 = clo<\"NormalCompletion\">(\"\")\n    return %4\n  }\n  %5 = (substring S from to)\n  if (? %5: Completion) return %5\n  call %6 = clo<\"NormalCompletion\">(%5)\n  return %6\n}","def <BUILTIN>:INTRINSICS.String.prototype.split(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#998]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop separator < ArgumentsList\n    expand __args__.separator\n  } else let separator = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop limit < ArgumentsList\n    expand __args__.limit\n  } else let limit = undefined\n  call %0 = clo<\"RequireObjectCoercible\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  if (! (|| (= separator undefined) (= separator null))) {\n    call %1 = clo<\"GetMethod\">(separator, @SYMBOL.split)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let splitter = %1\n    if (! (= splitter undefined)) {\n      call %2 = clo<\"Call\">(splitter, separator, (list [O, limit])[#999])\n      assert (? %2: Completion)\n      return %2\n    }\n  }\n  call %3 = clo<\"ToString\">(O)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let S = %3\n  if (= limit undefined) {\n    let lim = (- (** 2 32) 1)\n  } else {\n    call %4 = clo<\"ToUint32\">(limit)\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    let lim = ([math] %4)\n  }\n  call %5 = clo<\"ToString\">(separator)\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  let R = %5\n  if (== lim 0) {\n    call %6 = clo<\"CreateArrayFromList\">((list [])[#1000])\n    if (? %6: Completion) return %6\n    call %7 = clo<\"NormalCompletion\">(%6)\n    return %7\n  }\n  if (= separator undefined) {\n    call %8 = clo<\"CreateArrayFromList\">((list [S])[#1001])\n    if (? %8: Completion) return %8\n    call %9 = clo<\"NormalCompletion\">(%8)\n    return %9\n  }\n  let separatorLength = (sizeof R)\n  if (== separatorLength 0) {\n    let head = (substring S 0 lim)\n    (yet \"Let _codeUnits_ be a List consisting of the sequence of code units that are the elements of _head_.\")\n    call %10 = clo<\"CreateArrayFromList\">(codeUnits)\n    if (? %10: Completion) return %10\n    call %11 = clo<\"NormalCompletion\">(%10)\n    return %11\n  }\n  if (= S \"\") {\n    call %12 = clo<\"CreateArrayFromList\">((list [S])[#1002])\n    if (? %12: Completion) return %12\n    call %13 = clo<\"NormalCompletion\">(%12)\n    return %13\n  }\n  let substrings = (list [])[#1003]\n  let i = 0\n  call %14 = clo<\"StringIndexOf\">(S, R, 0)\n  let j = %14\n  while (! (== j (- 1))) {\n    let T = (substring S i j)\n    push substrings < T\n    if (= (sizeof substrings) lim) {\n      call %15 = clo<\"CreateArrayFromList\">(substrings)\n      if (? %15: Completion) return %15\n      call %16 = clo<\"NormalCompletion\">(%15)\n      return %16\n    }\n    i = (+ j separatorLength)\n    call %17 = clo<\"StringIndexOf\">(S, R, i)\n    j = %17\n  }\n  let T = (substring S i)\n  push substrings < T\n  call %18 = clo<\"CreateArrayFromList\">(substrings)\n  if (? %18: Completion) return %18\n  call %19 = clo<\"NormalCompletion\">(%18)\n  return %19\n}","def <BUILTIN>:INTRINSICS.String.prototype.startsWith(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1004]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop searchString < ArgumentsList\n    expand __args__.searchString\n  } else let searchString = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop position < ArgumentsList\n    expand __args__.position\n  } else let position = undefined\n  call %0 = clo<\"RequireObjectCoercible\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"ToString\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let S = %1\n  call %2 = clo<\"IsRegExp\">(searchString)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let isRegExp = %2\n  if (= isRegExp true) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  call %5 = clo<\"ToString\">(searchString)\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  let searchStr = %5\n  let len = (sizeof S)\n  if (= position undefined) {\n    let pos = 0\n  } else {\n    call %6 = clo<\"ToIntegerOrInfinity\">(position)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    let pos = %6\n  }\n  call %7 = clo<\"__CLAMP__\">(pos, 0, len)\n  let start = %7\n  let searchLength = (sizeof searchStr)\n  if (== searchLength 0) {\n    call %8 = clo<\"NormalCompletion\">(true)\n    return %8\n  }\n  let end = (+ start searchLength)\n  if (< len end) {\n    call %9 = clo<\"NormalCompletion\">(false)\n    return %9\n  }\n  let substring = (substring S start end)\n  if (= substring searchStr) {\n    call %10 = clo<\"NormalCompletion\">(true)\n    return %10\n  }\n  call %11 = clo<\"NormalCompletion\">(false)\n  return %11\n}","def <BUILTIN>:INTRINSICS.String.prototype.substring(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1005]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop start < ArgumentsList\n    expand __args__.start\n  } else let start = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop end < ArgumentsList\n    expand __args__.end\n  } else let end = undefined\n  call %0 = clo<\"RequireObjectCoercible\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"ToString\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let S = %1\n  let len = (sizeof S)\n  call %2 = clo<\"ToIntegerOrInfinity\">(start)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let intStart = %2\n  if (= end undefined) {\n    let intEnd = len\n  } else {\n    call %3 = clo<\"ToIntegerOrInfinity\">(end)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let intEnd = %3\n  }\n  call %4 = clo<\"__CLAMP__\">(intStart, 0, len)\n  let finalStart = %4\n  call %5 = clo<\"__CLAMP__\">(intEnd, 0, len)\n  let finalEnd = %5\n  let from = (min finalStart finalEnd)\n  let to = (max finalStart finalEnd)\n  %6 = (substring S from to)\n  if (? %6: Completion) return %6\n  call %7 = clo<\"NormalCompletion\">(%6)\n  return %7\n}","def <BUILTIN>:INTRINSICS.String.prototype.toLowerCase(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1006]\n  call %0 = clo<\"RequireObjectCoercible\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"ToString\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let S = %1\n  call %2 = clo<\"StringToCodePoints\">(S)\n  let sText = %2\n  (yet \"Let _lowerText_ be the result of toLowercase(_sText_), according to the Unicode Default Case Conversion algorithm.\")\n  call %3 = clo<\"CodePointsToString\">(lowerText)\n  let L = %3\n  if (? L: Completion) return L\n  call %4 = clo<\"NormalCompletion\">(L)\n  return %4\n}","def <BUILTIN>:INTRINSICS.String.prototype.toString(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1007]\n  call %0 = clo<\"ThisStringValue\">(this)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.String.prototype.toWellFormed(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1008]\n  call %0 = clo<\"RequireObjectCoercible\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"ToString\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let S = %1\n  let strLen = (sizeof S)\n  let k = 0\n  let result = \"\"\n  while (< k strLen) {\n    call %2 = clo<\"CodePointAt\">(S, k)\n    let cp = %2\n    if (= cp.IsUnpairedSurrogate true) {\n      result = (concat result 65533cu)\n    } else {\n      call %3 = clo<\"UTF16EncodeCodePoint\">(cp.CodePoint)\n      result = (concat result %3)\n    }\n    k = (+ k cp.CodeUnitCount)\n  }\n  if (? result: Completion) return result\n  call %4 = clo<\"NormalCompletion\">(result)\n  return %4\n}","def <BUILTIN>:INTRINSICS.String.prototype.trim(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1009]\n  let S = this\n  call %0 = clo<\"TrimString\">(S, ~start+end~)\n  assert (? %0: Completion)\n  return %0\n}","def TrimString(\n  string: ESValue,\n  where: Enum[~end~, ~start+end~, ~start~],\n): Normal[String] | Throw = {\n  call %0 = clo<\"RequireObjectCoercible\">(string)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let str = %0\n  call %1 = clo<\"ToString\">(str)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let S = %1\n  if (= where ~start~) {\n    let T = (trim > S)\n  } else {\n    if (= where ~end~) {\n      let T = (trim S <)\n    } else {\n      assert (= where ~start+end~)\n      let T = (trim (trim > S) <)\n    }\n  }\n  if (? T: Completion) return T\n  call %2 = clo<\"NormalCompletion\">(T)\n  return %2\n}","def <BUILTIN>:INTRINSICS.String.prototype.trimEnd(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1010]\n  let S = this\n  call %0 = clo<\"TrimString\">(S, ~end~)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.String.prototype.trimStart(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1011]\n  let S = this\n  call %0 = clo<\"TrimString\">(S, ~start~)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.String.prototype.valueOf(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1012]\n  call %0 = clo<\"ThisStringValue\">(this)\n  assert (? %0: Completion)\n  return %0\n}","def ThisStringValue(\n  value: ESValue,\n): Normal[String] | Throw = {\n  if (? value: String) {\n    if (? value: Completion) return value\n    call %0 = clo<\"NormalCompletion\">(value)\n    return %0\n  }\n  if (&& (? value: Record[Object]) (exists value.StringData)) {\n    let s = value.StringData\n    assert (? s: String)\n    if (? s: Completion) return s\n    call %1 = clo<\"NormalCompletion\">(s)\n    return %1\n  }\n  call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n  call %3 = clo<\"ThrowCompletion\">(%2)\n  return %3\n}","def <CLO>:INTRINSICS.String.prototype[@@iterator]:clo0(\n): Unknown = {\n  let len = (sizeof s)\n  let position = 0\n  while (< position len) {\n    call %0 = clo<\"CodePointAt\">(s, position)\n    let cp = %0\n    let nextIndex = (+ position cp.CodeUnitCount)\n    let resultString = (substring s position nextIndex)\n    position = nextIndex\n    call %1 = clo<\"CreateIterResultObject\">(resultString, false)\n    call %2 = clo<\"GeneratorYield\">(%1)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n  }\n  call %3 = clo<\"NormalCompletion\">(undefined)\n  return %3\n}","def <BUILTIN>:INTRINSICS.String.prototype[@@iterator](\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1013]\n  call %0 = clo<\"RequireObjectCoercible\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"ToString\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let s = %1\n  let closure = clo<\"INTRINSICS.String.prototype[@@iterator]:clo0\", [s]>\n  call %2 = clo<\"CreateIteratorFromClosure\">(closure, \"%StringIteratorPrototype%\", @EXECUTION_STACK[0].Realm.Intrinsics[\"%StringIteratorPrototype%\"])\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <BUILTIN>:INTRINSICS.StringIteratorPrototype.next(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1014]\n  call %0 = clo<\"GeneratorResume\">(this, ~empty~, \"%StringIteratorPrototype%\")\n  assert (? %0: Completion)\n  return %0\n}","def CountLeftCapturingParensWithin(\n  node: Ast,\n): NonNegInt = {\n  assert (yet \"_node_ is an instance of a production in <emu-xref href=\\\"#sec-patterns\\\">the RegExp Pattern grammar</emu-xref>.\")\n  (yet \"Return the number of <emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> Parse Nodes contained within _node_.\")\n}","def CountLeftCapturingParensBefore(\n  node: Ast,\n): NonNegInt = {\n  assert (yet \"_node_ is an instance of a production in <emu-xref href=\\\"#sec-patterns\\\">the RegExp Pattern grammar</emu-xref>.\")\n  (yet \"Let _pattern_ be the |Pattern| containing _node_.\")\n  (yet \"Return the number of <emu-grammar>Atom :: `(` GroupSpecifier? Disjunction `)`</emu-grammar> Parse Nodes contained within _pattern_ that either occur before _node_ or contain _node_.\")\n}","def <SYNTAX>:DecimalEscape[0,0].CapturingGroupNumber(\n  this: Ast[DecimalEscape[0]],\n): PosInt = {\n  sdo-call %0 = this[0]->MV()\n  return %0\n}","def <SYNTAX>:DecimalEscape[0,1].CapturingGroupNumber(\n  this: Ast[DecimalEscape[0]],\n): PosInt = {\n  (yet \"Let _n_ be the number of code points in |DecimalDigits|.\")\n  (yet \"Return (the MV of |NonZeroDigit| √ó 10<sup>_n_</sup> plus the MV of |DecimalDigits|).\")\n}","def <SYNTAX>:ClassAtom[0,0].IsCharacterClass(\n  this: Ast[ClassAtom[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ClassAtomNoDash[0,0].IsCharacterClass(\n  this: Ast[ClassAtomNoDash[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ClassEscape[0,0].IsCharacterClass(\n  this: Ast[ClassEscape[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ClassEscape[1,0].IsCharacterClass(\n  this: Ast[ClassEscape[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ClassEscape[3,0].IsCharacterClass(\n  this: Ast[ClassEscape[3]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ClassEscape[2,0].IsCharacterClass(\n  this: Ast[ClassEscape[2]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:ClassAtom[0,0].CharacterValue(\n  this: Ast[ClassAtom[0]],\n): NonNegInt = {\n  (yet \"Return the numeric value of U+002D (HYPHEN-MINUS).\")\n}","def <SYNTAX>:ClassAtomNoDash[0,0].CharacterValue(\n  this: Ast[ClassAtomNoDash[0]],\n): NonNegInt = {\n  (yet \"Let _ch_ be the code point matched by |SourceCharacter|.\")\n  return ([math] ch)\n}","def <SYNTAX>:ClassEscape[0,0].CharacterValue(\n  this: Ast[ClassEscape[0]],\n): NonNegInt = {\n  (yet \"Return the numeric value of U+0008 (BACKSPACE).\")\n}","def <SYNTAX>:ClassEscape[1,0].CharacterValue(\n  this: Ast[ClassEscape[1]],\n): NonNegInt = {\n  (yet \"Return the numeric value of U+002D (HYPHEN-MINUS).\")\n}","def <SYNTAX>:CharacterEscape[0,0].CharacterValue(\n  this: Ast[CharacterEscape[0]],\n): NonNegInt = {\n  (yet \"Return the numeric value according to <emu-xref href=\\\"#table-controlescape-code-point-values\\\"></emu-xref>.\")\n}","def <SYNTAX>:CharacterEscape[1,0].CharacterValue(\n  this: Ast[CharacterEscape[1]],\n): NonNegInt = {\n  (yet \"Let _ch_ be the code point matched by |AsciiLetter|.\")\n  let i = ([math] ch)\n  (yet \"Return the remainder of dividing _i_ by 32.\")\n}","def <SYNTAX>:CharacterEscape[2,0].CharacterValue(\n  this: Ast[CharacterEscape[2]],\n): NonNegInt = {\n  (yet \"Return the numeric value of U+0000 (NULL).\")\n}","def <SYNTAX>:CharacterEscape[3,0].CharacterValue(\n  this: Ast[CharacterEscape[3]],\n): NonNegInt = {\n  sdo-call %0 = this[0]->MV()\n  return %0\n}","def <SYNTAX>:RegExpUnicodeEscapeSequence[0,0].CharacterValue(\n  this: Ast[RegExpUnicodeEscapeSequence[0]],\n): NonNegInt = {\n  sdo-call %0 = this[0]->CharacterValue()\n  let lead = %0\n  sdo-call %1 = this[1]->CharacterValue()\n  let trail = %1\n  call %2 = clo<\"UTF16SurrogatePairToCodePoint\">(lead, trail)\n  let cp = %2\n  return ([math] cp)\n}","def <SYNTAX>:RegExpUnicodeEscapeSequence[4,0].CharacterValue(\n  this: Ast[RegExpUnicodeEscapeSequence[4]],\n): NonNegInt = {\n  sdo-call %0 = this[0]->MV()\n  return %0\n}","def <SYNTAX>:RegExpUnicodeEscapeSequence[5,0].CharacterValue(\n  this: Ast[RegExpUnicodeEscapeSequence[5]],\n): NonNegInt = {\n  sdo-call %0 = this[0]->MV()\n  return %0\n}","def <SYNTAX>:HexLeadSurrogate[0,0].CharacterValue(\n  this: Ast[HexLeadSurrogate[0]],\n): NonNegInt = {\n  sdo-call %0 = this[0]->MV()\n  return %0\n}","def <SYNTAX>:HexTrailSurrogate[0,0].CharacterValue(\n  this: Ast[HexTrailSurrogate[0]],\n): NonNegInt = {\n  sdo-call %0 = this[0]->MV()\n  return %0\n}","def <SYNTAX>:HexNonSurrogate[0,0].CharacterValue(\n  this: Ast[HexNonSurrogate[0]],\n): NonNegInt = {\n  sdo-call %0 = this[0]->MV()\n  return %0\n}","def <SYNTAX>:CharacterEscape[5,0].CharacterValue(\n  this: Ast[CharacterEscape[5]],\n): NonNegInt = {\n  (yet \"Let _ch_ be the code point matched by |IdentityEscape|.\")\n  return ([math] ch)\n}","def <SYNTAX>:ClassSetCharacter[0,0].CharacterValue(\n  this: Ast[ClassSetCharacter[0]],\n): NonNegInt = {\n  (yet \"Let _ch_ be the code point matched by |SourceCharacter|.\")\n  return ([math] ch)\n}","def <SYNTAX>:ClassSetCharacter[2,0].CharacterValue(\n  this: Ast[ClassSetCharacter[2]],\n): NonNegInt = {\n  (yet \"Let _ch_ be the code point matched by |ClassSetReservedPunctuator|.\")\n  return ([math] ch)\n}","def <SYNTAX>:ClassSetCharacter[3,0].CharacterValue(\n  this: Ast[ClassSetCharacter[3]],\n): NonNegInt = {\n  (yet \"Return the numeric value of U+0008 (BACKSPACE).\")\n}","def <SYNTAX>:CharacterClassEscape[0,0].MayContainStrings(\n  this: Ast[CharacterClassEscape[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:CharacterClassEscape[1,0].MayContainStrings(\n  this: Ast[CharacterClassEscape[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:CharacterClassEscape[2,0].MayContainStrings(\n  this: Ast[CharacterClassEscape[2]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:CharacterClassEscape[3,0].MayContainStrings(\n  this: Ast[CharacterClassEscape[3]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:CharacterClassEscape[4,0].MayContainStrings(\n  this: Ast[CharacterClassEscape[4]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:CharacterClassEscape[5,0].MayContainStrings(\n  this: Ast[CharacterClassEscape[5]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:CharacterClassEscape[7,0].MayContainStrings(\n  this: Ast[CharacterClassEscape[7]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:UnicodePropertyValueExpression[0,0].MayContainStrings(\n  this: Ast[UnicodePropertyValueExpression[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:NestedClass[1,0].MayContainStrings(\n  this: Ast[NestedClass[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ClassContents[0,0].MayContainStrings(\n  this: Ast[ClassContents[0]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ClassContents[1,0].MayContainStrings(\n  this: Ast[ClassContents[1]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:ClassSetOperand[2,0].MayContainStrings(\n  this: Ast[ClassSetOperand[2]],\n): Boolean = {\n  return false\n}","def <SYNTAX>:UnicodePropertyValueExpression[1,0].MayContainStrings(\n  this: Ast[UnicodePropertyValueExpression[1]],\n): Boolean = {\n  (yet \"If the source text matched by |LoneUnicodePropertyNameOrValue| is a binary property of strings listed in the ‚ÄúProperty name‚Äù column of <emu-xref href=\\\"#table-binary-unicode-properties-of-strings\\\"></emu-xref>, return *true*.\")\n  return false\n}","def <SYNTAX>:ClassUnion[0,0].MayContainStrings(\n  this: Ast[ClassUnion[0]],\n): Boolean = {\n  if (exists this[1]) {\n    sdo-call %0 = this[1]->MayContainStrings()\n    return %0\n  }\n  return false\n}","def <SYNTAX>:ClassUnion[0,1].MayContainStrings(\n  this: Ast[ClassUnion[0]],\n): Boolean = {\n  if (exists this[1]) {\n    sdo-call %0 = this[1]->MayContainStrings()\n    return %0\n  }\n  return false\n}","def <SYNTAX>:ClassUnion[1,0].MayContainStrings(\n  this: Ast[ClassUnion[1]],\n): Boolean = {\n  sdo-call %0 = this[0]->MayContainStrings()\n  if (= %0 true) {\n    return true\n  }\n  if (exists this[1]) {\n    sdo-call %1 = this[1]->MayContainStrings()\n    return %1\n  }\n  return false\n}","def <SYNTAX>:ClassUnion[1,1].MayContainStrings(\n  this: Ast[ClassUnion[1]],\n): Boolean = {\n  sdo-call %0 = this[0]->MayContainStrings()\n  if (= %0 true) {\n    return true\n  }\n  if (exists this[1]) {\n    sdo-call %1 = this[1]->MayContainStrings()\n    return %1\n  }\n  return false\n}","def <SYNTAX>:ClassIntersection[0,0].MayContainStrings(\n  this: Ast[ClassIntersection[0]],\n): Boolean = {\n  sdo-call %0 = this[0]->MayContainStrings()\n  if (= %0 false) {\n    return false\n  }\n  sdo-call %1 = this[1]->MayContainStrings()\n  if (= %1 false) {\n    return false\n  }\n  return true\n}","def <SYNTAX>:ClassIntersection[1,0].MayContainStrings(\n  this: Ast[ClassIntersection[1]],\n): Boolean = {\n  sdo-call %0 = this[0]->MayContainStrings()\n  if (= %0 false) {\n    return false\n  }\n  sdo-call %1 = this[1]->MayContainStrings()\n  if (= %1 false) {\n    return false\n  }\n  return true\n}","def <SYNTAX>:ClassSubtraction[0,0].MayContainStrings(\n  this: Ast[ClassSubtraction[0]],\n): Boolean = {\n  sdo-call %0 = this[0]->MayContainStrings()\n  return %0\n}","def <SYNTAX>:ClassSubtraction[1,0].MayContainStrings(\n  this: Ast[ClassSubtraction[1]],\n): Boolean = {\n  sdo-call %0 = this[0]->MayContainStrings()\n  return %0\n}","def <SYNTAX>:ClassStringDisjunctionContents[1,0].MayContainStrings(\n  this: Ast[ClassStringDisjunctionContents[1]],\n): Boolean = {\n  sdo-call %0 = this[0]->MayContainStrings()\n  if (= %0 true) {\n    return true\n  }\n  sdo-call %1 = this[1]->MayContainStrings()\n  return %1\n}","def <SYNTAX>:ClassString[0,0].MayContainStrings(\n  this: Ast[ClassString[0]],\n): Boolean = {\n  return true\n}","def <SYNTAX>:ClassString[1,0].MayContainStrings(\n  this: Ast[ClassString[1]],\n): Boolean = {\n  sdo-call %0 = this[0]->MayContainStrings()\n  return %0\n}","def <SYNTAX>:NonEmptyClassString[0,0].MayContainStrings(\n  this: Ast[NonEmptyClassString[0]],\n): Boolean = {\n  if (exists this[1]) {\n    return true\n  }\n  return false\n}","def <SYNTAX>:NonEmptyClassString[0,1].MayContainStrings(\n  this: Ast[NonEmptyClassString[0]],\n): Boolean = {\n  if (exists this[1]) {\n    return true\n  }\n  return false\n}","def GroupSpecifiersThatMatch(\n  thisGroupName: Unknown[\"GroupNameParseNode\"],\n): Unknown[\"ListOfGroupSpecifierParseNode\"] = {\n  sdo-call %0 = thisGroupName->CapturingGroupName()\n  let name = %0\n  (yet \"Let _pattern_ be the |Pattern| containing _thisGroupName_.\")\n  let result = (list [])[#1015]\n  (yet \"For each |GroupSpecifier| _gs_ that _pattern_ contains, do\\n  1. If CapturingGroupName of _gs_ is _name_, then\\n    1. Append _gs_ to _result_.\")\n  return result\n}","def <SYNTAX>:GroupName[0,0].CapturingGroupName(\n  this: Ast[GroupName[0]],\n): String = {\n  sdo-call %0 = this[0]->RegExpIdentifierCodePoints()\n  let idTextUnescaped = %0\n  call %1 = clo<\"CodePointsToString\">(idTextUnescaped)\n  return %1\n}","def <SYNTAX>:RegExpIdentifierName[0,0].RegExpIdentifierCodePoints(\n  this: Ast[RegExpIdentifierName[0]],\n): Unknown[\"ListOfCodePoint\"] = {\n  sdo-call %0 = this[0]->RegExpIdentifierCodePoint()\n  let cp = %0\n  return (list [cp])[#1016]\n}","def <SYNTAX>:RegExpIdentifierName[1,0].RegExpIdentifierCodePoints(\n  this: Ast[RegExpIdentifierName[1]],\n): Unknown[\"ListOfCodePoint\"] = {\n  (yet \"Let _cps_ be RegExpIdentifierCodePoints of the derived |RegExpIdentifierName|.\")\n  sdo-call %0 = this[1]->RegExpIdentifierCodePoint()\n  let cp = %0\n  call %1 = clo<\"__FLAT_LIST__\">((list [cps, (list [cp])[#1018]])[#1017])\n  return %1\n}","def <SYNTAX>:RegExpIdentifierStart[0,0].RegExpIdentifierCodePoint(\n  this: Ast[RegExpIdentifierStart[0]],\n): Unknown[\"CodePoint\"] = {\n  (yet \"Return the code point matched by |IdentifierStartChar|.\")\n}","def <SYNTAX>:RegExpIdentifierPart[0,0].RegExpIdentifierCodePoint(\n  this: Ast[RegExpIdentifierPart[0]],\n): Unknown[\"CodePoint\"] = {\n  (yet \"Return the code point matched by |IdentifierPartChar|.\")\n}","def <SYNTAX>:RegExpIdentifierStart[1,0].RegExpIdentifierCodePoint(\n  this: Ast[RegExpIdentifierStart[1]],\n): Unknown[\"CodePoint\"] = {\n  (yet \"Return the code point whose numeric value is the CharacterValue of |RegExpUnicodeEscapeSequence|.\")\n}","def <SYNTAX>:RegExpIdentifierPart[1,0].RegExpIdentifierCodePoint(\n  this: Ast[RegExpIdentifierPart[1]],\n): Unknown[\"CodePoint\"] = {\n  (yet \"Return the code point whose numeric value is the CharacterValue of |RegExpUnicodeEscapeSequence|.\")\n}","def <SYNTAX>:RegExpIdentifierStart[2,0].RegExpIdentifierCodePoint(\n  this: Ast[RegExpIdentifierStart[2]],\n): Unknown[\"CodePoint\"] = {\n  (yet \"Let _lead_ be the code unit whose numeric value is the numeric value of the code point matched by |UnicodeLeadSurrogate|.\")\n  (yet \"Let _trail_ be the code unit whose numeric value is the numeric value of the code point matched by |UnicodeTrailSurrogate|.\")\n  call %0 = clo<\"UTF16SurrogatePairToCodePoint\">(lead, trail)\n  return %0\n}","def <SYNTAX>:RegExpIdentifierPart[2,0].RegExpIdentifierCodePoint(\n  this: Ast[RegExpIdentifierPart[2]],\n): Unknown[\"CodePoint\"] = {\n  (yet \"Let _lead_ be the code unit whose numeric value is the numeric value of the code point matched by |UnicodeLeadSurrogate|.\")\n  (yet \"Let _trail_ be the code unit whose numeric value is the numeric value of the code point matched by |UnicodeTrailSurrogate|.\")\n  call %0 = clo<\"UTF16SurrogatePairToCodePoint\">(lead, trail)\n  return %0\n}","def <CLO>:Pattern[0,0].CompilePattern:clo0(\n  Input: Unknown,\n  index: Unknown,\n): Unknown = {\n  assert (yet \"_Input_ is a List of characters.\")\n  assert (yet \"0 ‚â§ _index_ ‚â§ the number of elements in _Input_.\")\n  (yet \"Let _c_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:\\n  1. Assert: _y_ is a Record[MatchState].\\n  1. Return _y_.\")\n  (yet \"Let _cap_ be a List of _rer_.[[CapturingGroupsCount]] *undefined* values, indexed 1 through _rer_.[[CapturingGroupsCount]].\")\n  let x = (record [MatchState] {\n    \"Input\" : Input,\n    \"EndIndex\" : index,\n    \"Captures\" : cap,\n  })[#1019]\n  call %0 = m(x, c)\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <SYNTAX>:Pattern[0,0].CompilePattern(\n  this: Ast[Pattern[0]],\n  rer: Record[RegExpRecord],\n): Unknown[\"AbstractClosureThatTakesAListOfCharactersAndANonnegativeIntegerAndReturnsAMatchResult\"] = {\n  sdo-call %0 = this[0]->CompileSubpattern(rer, ~forward~)\n  let m = %0\n  return clo<\"Pattern[0,0].CompilePattern:clo0\", [rer, m]>\n}","def <SYNTAX>:Disjunction[1,0].CompileSubpattern(\n  this: Ast[Disjunction[1]],\n  rer: Record[RegExpRecord],\n  direction: Enum[~backward~, ~forward~],\n): Record[Matcher] = {\n  sdo-call %0 = this[0]->CompileSubpattern(rer, direction)\n  let m1 = %0\n  sdo-call %1 = this[1]->CompileSubpattern(rer, direction)\n  let m2 = %1\n  call %2 = clo<\"MatchTwoAlternatives\">(m1, m2)\n  return %2\n}","def <SYNTAX>:Alternative[0,0].CompileSubpattern(\n  this: Ast[Alternative[0]],\n  rer: Record[RegExpRecord],\n  direction: Enum[~backward~, ~forward~],\n): Record[Matcher] = {\n  call %0 = clo<\"EmptyMatcher\">()\n  return %0\n}","def <SYNTAX>:Alternative[1,0].CompileSubpattern(\n  this: Ast[Alternative[1]],\n  rer: Record[RegExpRecord],\n  direction: Enum[~backward~, ~forward~],\n): Record[Matcher] = {\n  sdo-call %0 = this[0]->CompileSubpattern(rer, direction)\n  let m1 = %0\n  sdo-call %1 = this[1]->CompileSubpattern(rer, direction)\n  let m2 = %1\n  call %2 = clo<\"MatchSequence\">(m1, m2, direction)\n  return %2\n}","def <SYNTAX>:Term[0,0].CompileSubpattern(\n  this: Ast[Term[0]],\n  rer: Record[RegExpRecord],\n  direction: Enum[~backward~, ~forward~],\n): Record[Matcher] = {\n  sdo-call %0 = this[0]->CompileAssertion(rer)\n  return %0\n}","def <SYNTAX>:Term[1,0].CompileSubpattern(\n  this: Ast[Term[1]],\n  rer: Record[RegExpRecord],\n  direction: Enum[~backward~, ~forward~],\n): Record[Matcher] = {\n  sdo-call %0 = this[0]->CompileAtom(rer, direction)\n  return %0\n}","def <SYNTAX>:Term[2,0].CompileSubpattern(\n  this: Ast[Term[2]],\n  rer: Record[RegExpRecord],\n  direction: Enum[~backward~, ~forward~],\n): Record[Matcher] = {\n  sdo-call %0 = this[0]->CompileAtom(rer, direction)\n  let m = %0\n  sdo-call %1 = this[1]->CompileQuantifier()\n  let q = %1\n  assert (! (< q.Max q.Min))\n  call %2 = clo<\"CountLeftCapturingParensBefore\">(this)\n  let parenIndex = %2\n  call %3 = clo<\"CountLeftCapturingParensWithin\">(this[0])\n  let parenCount = %3\n  (yet \"Return a new Matcher with parameters (_x_, _c_) that captures _m_, _q_, _parenIndex_, and _parenCount_ and performs the following steps when called:\\n  1. Assert: _x_ is a Record[MatchState].\\n  1. Assert: _c_ is a Record[MatcherContinuation].\\n  1. Return RepeatMatcher(_m_, _q_.[[Min]], _q_.[[Max]], _q_.[[Greedy]], _x_, _c_, _parenIndex_, _parenCount_).\")\n}","def RepeatMatcher(\n  m: Record[Matcher],\n  min: NonNegInt,\n  max: NonNegInt | +INF,\n  greedy: Boolean,\n  x: Record[MatchState],\n  c: Record[MatcherContinuation],\n  parenIndex: NonNegInt,\n  parenCount: NonNegInt,\n): Record[MatchResult] = {\n  if (== max 0) {\n    call %0 = c(x)\n    return %0\n  }\n  (yet \"Let _d_ be a new MatcherContinuation with parameters (_y_) that captures _m_, _min_, _max_, _greedy_, _x_, _c_, _parenIndex_, and _parenCount_ and performs the following steps when called:\\n  1. Assert: _y_ is a Record[MatchState].\\n  1. [id=\\\"step-repeatmatcher-done\\\"] If _min_ = 0 and _y_.[[EndIndex]] = _x_.[[EndIndex]], return ~failure~.\\n  1. If _min_ = 0, let _min2_ be 0.\\n  1. Else, let _min2_ be _min_ - 1.\\n  1. If _max_ = +‚àû, let _max2_ be +‚àû.\\n  1. Else, let _max2_ be _max_ - 1.\\n  1. Return RepeatMatcher(_m_, _min2_, _max2_, _greedy_, _y_, _c_, _parenIndex_, _parenCount_).\")\n  (yet \"Let _cap_ be a copy of _x_.[[Captures]].\")\n  (yet \"For each integer _k_ in the inclusive interval from _parenIndex_ + 1 to _parenIndex_ + _parenCount_, set _cap_[_k_] to *undefined*.\")\n  let Input = x.Input\n  let e = x.EndIndex\n  let xr = (record [MatchState] {\n    \"Input\" : Input,\n    \"EndIndex\" : e,\n    \"Captures\" : cap,\n  })[#1020]\n  if (! (== min 0)) {\n    call %1 = m(xr, d)\n    return %1\n  }\n  if (= greedy false) {\n    call %2 = c(x)\n    let z = %2\n    if (! (= z ~failure~)) {\n      return z\n    }\n    call %3 = m(xr, d)\n    return %3\n  }\n  call %4 = m(xr, d)\n  let z = %4\n  if (! (= z ~failure~)) {\n    return z\n  }\n  call %5 = c(x)\n  return %5\n}","def EmptyMatcher(\n): Record[Matcher] = {\n  (yet \"Return a new Matcher with parameters (_x_, _c_) that captures nothing and performs the following steps when called:\\n  1. Assert: _x_ is a Record[MatchState].\\n  1. Assert: _c_ is a Record[MatcherContinuation].\\n  1. Return _c_(_x_).\")\n}","def MatchTwoAlternatives(\n  m1: Record[Matcher],\n  m2: Record[Matcher],\n): Record[Matcher] = {\n  (yet \"Return a new Matcher with parameters (_x_, _c_) that captures _m1_ and _m2_ and performs the following steps when called:\\n  1. Assert: _x_ is a Record[MatchState].\\n  1. Assert: _c_ is a Record[MatcherContinuation].\\n  1. Let _r_ be _m1_(_x_, _c_).\\n  1. If _r_ is not ~failure~, return _r_.\\n  1. Return _m2_(_x_, _c_).\")\n}","def MatchSequence(\n  m1: Record[Matcher],\n  m2: Record[Matcher],\n  direction: Enum[~backward~, ~forward~],\n): Record[Matcher] = {\n  if (= direction ~forward~) {\n    (yet \"Return a new Matcher with parameters (_x_, _c_) that captures _m1_ and _m2_ and performs the following steps when called:\\n  1. Assert: _x_ is a Record[MatchState].\\n  1. Assert: _c_ is a Record[MatcherContinuation].\\n  1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures _c_ and _m2_ and performs the following steps when called:\\n    1. Assert: _y_ is a Record[MatchState].\\n    1. Return _m2_(_y_, _c_).\\n  1. Return _m1_(_x_, _d_).\")\n  } else {\n    assert (= direction ~backward~)\n    (yet \"Return a new Matcher with parameters (_x_, _c_) that captures _m1_ and _m2_ and performs the following steps when called:\\n  1. Assert: _x_ is a Record[MatchState].\\n  1. Assert: _c_ is a Record[MatcherContinuation].\\n  1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures _c_ and _m1_ and performs the following steps when called:\\n    1. Assert: _y_ is a Record[MatchState].\\n    1. Return _m1_(_y_, _c_).\\n  1. Return _m2_(_x_, _d_).\")\n  }\n}","def <SYNTAX>:Assertion[0,0].CompileAssertion(\n  this: Ast[Assertion[0]],\n  rer: Record[RegExpRecord],\n): Record[Matcher] = {\n  (yet \"Return a new Matcher with parameters (_x_, _c_) that captures _rer_ and performs the following steps when called:\\n  1. Assert: _x_ is a Record[MatchState].\\n  1. Assert: _c_ is a Record[MatcherContinuation].\\n  1. Let _Input_ be _x_.[[Input]].\\n  1. Let _e_ be _x_.[[EndIndex]].\\n  1. If _e_ = 0, or if _rer_.[[Multiline]] is *true* and the character _Input_[_e_ - 1] is matched by |LineTerminator|, then\\n    1. Return _c_(_x_).\\n  1. Return ~failure~.\")\n}","def <SYNTAX>:Assertion[1,0].CompileAssertion(\n  this: Ast[Assertion[1]],\n  rer: Record[RegExpRecord],\n): Record[Matcher] = {\n  (yet \"Return a new Matcher with parameters (_x_, _c_) that captures _rer_ and performs the following steps when called:\\n  1. Assert: _x_ is a Record[MatchState].\\n  1. Assert: _c_ is a Record[MatcherContinuation].\\n  1. Let _Input_ be _x_.[[Input]].\\n  1. Let _e_ be _x_.[[EndIndex]].\\n  1. Let _InputLength_ be the number of elements in _Input_.\\n  1. If _e_ = _InputLength_, or if _rer_.[[Multiline]] is *true* and the character _Input_[_e_] is matched by |LineTerminator|, then\\n    1. Return _c_(_x_).\\n  1. Return ~failure~.\")\n}","def <SYNTAX>:Assertion[2,0].CompileAssertion(\n  this: Ast[Assertion[2]],\n  rer: Record[RegExpRecord],\n): Record[Matcher] = {\n  (yet \"Return a new Matcher with parameters (_x_, _c_) that captures _rer_ and performs the following steps when called:\\n  1. Assert: _x_ is a Record[MatchState].\\n  1. Assert: _c_ is a Record[MatcherContinuation].\\n  1. Let _Input_ be _x_.[[Input]].\\n  1. Let _e_ be _x_.[[EndIndex]].\\n  1. Let _a_ be IsWordChar(_rer_, _Input_, _e_ - 1).\\n  1. Let _b_ be IsWordChar(_rer_, _Input_, _e_).\\n  1. If _a_ is *true* and _b_ is *false* or _a_ is *false* and _b_ is *true*, return _c_(_x_).\\n  1. Return ~failure~.\")\n}","def <SYNTAX>:Assertion[3,0].CompileAssertion(\n  this: Ast[Assertion[3]],\n  rer: Record[RegExpRecord],\n): Record[Matcher] = {\n  (yet \"Return a new Matcher with parameters (_x_, _c_) that captures _rer_ and performs the following steps when called:\\n  1. Assert: _x_ is a Record[MatchState].\\n  1. Assert: _c_ is a Record[MatcherContinuation].\\n  1. Let _Input_ be _x_.[[Input]].\\n  1. Let _e_ be _x_.[[EndIndex]].\\n  1. Let _a_ be IsWordChar(_rer_, _Input_, _e_ - 1).\\n  1. Let _b_ be IsWordChar(_rer_, _Input_, _e_).\\n  1. If _a_ is *true* and _b_ is *true* or _a_ is *false* and _b_ is *false*, return _c_(_x_).\\n  1. Return ~failure~.\")\n}","def <SYNTAX>:Assertion[4,0].CompileAssertion(\n  this: Ast[Assertion[4]],\n  rer: Record[RegExpRecord],\n): Record[Matcher] = {\n  sdo-call %0 = this[0]->CompileSubpattern(rer, ~forward~)\n  let m = %0\n  (yet \"Return a new Matcher with parameters (_x_, _c_) that captures _m_ and performs the following steps when called:\\n  1. Assert: _x_ is a Record[MatchState].\\n  1. Assert: _c_ is a Record[MatcherContinuation].\\n  1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:\\n    1. Assert: _y_ is a Record[MatchState].\\n    1. Return _y_.\\n  1. Let _r_ be _m_(_x_, _d_).\\n  1. If _r_ is ~failure~, return ~failure~.\\n  1. Assert: _r_ is a Record[MatchState].\\n  1. Let _cap_ be _r_.[[Captures]].\\n  1. Let _Input_ be _x_.[[Input]].\\n  1. Let _xe_ be _x_.[[EndIndex]].\\n  1. Let _z_ be MatchState { [[Input]]: _Input_, [[EndIndex]]: _xe_, [[Captures]]: _cap_ }.\\n  1. Return _c_(_z_).\")\n}","def <SYNTAX>:Assertion[5,0].CompileAssertion(\n  this: Ast[Assertion[5]],\n  rer: Record[RegExpRecord],\n): Record[Matcher] = {\n  sdo-call %0 = this[0]->CompileSubpattern(rer, ~forward~)\n  let m = %0\n  (yet \"Return a new Matcher with parameters (_x_, _c_) that captures _m_ and performs the following steps when called:\\n  1. Assert: _x_ is a Record[MatchState].\\n  1. Assert: _c_ is a Record[MatcherContinuation].\\n  1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:\\n    1. Assert: _y_ is a Record[MatchState].\\n    1. Return _y_.\\n  1. Let _r_ be _m_(_x_, _d_).\\n  1. If _r_ is not ~failure~, return ~failure~.\\n  1. Return _c_(_x_).\")\n}","def <SYNTAX>:Assertion[6,0].CompileAssertion(\n  this: Ast[Assertion[6]],\n  rer: Record[RegExpRecord],\n): Record[Matcher] = {\n  sdo-call %0 = this[0]->CompileSubpattern(rer, ~backward~)\n  let m = %0\n  (yet \"Return a new Matcher with parameters (_x_, _c_) that captures _m_ and performs the following steps when called:\\n  1. Assert: _x_ is a Record[MatchState].\\n  1. Assert: _c_ is a Record[MatcherContinuation].\\n  1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:\\n    1. Assert: _y_ is a Record[MatchState].\\n    1. Return _y_.\\n  1. Let _r_ be _m_(_x_, _d_).\\n  1. If _r_ is ~failure~, return ~failure~.\\n  1. Assert: _r_ is a Record[MatchState].\\n  1. Let _cap_ be _r_.[[Captures]].\\n  1. Let _Input_ be _x_.[[Input]].\\n  1. Let _xe_ be _x_.[[EndIndex]].\\n  1. Let _z_ be MatchState { [[Input]]: _Input_, [[EndIndex]]: _xe_, [[Captures]]: _cap_ }.\\n  1. Return _c_(_z_).\")\n}","def <SYNTAX>:Assertion[7,0].CompileAssertion(\n  this: Ast[Assertion[7]],\n  rer: Record[RegExpRecord],\n): Record[Matcher] = {\n  sdo-call %0 = this[0]->CompileSubpattern(rer, ~backward~)\n  let m = %0\n  (yet \"Return a new Matcher with parameters (_x_, _c_) that captures _m_ and performs the following steps when called:\\n  1. Assert: _x_ is a Record[MatchState].\\n  1. Assert: _c_ is a Record[MatcherContinuation].\\n  1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures nothing and performs the following steps when called:\\n    1. Assert: _y_ is a Record[MatchState].\\n    1. Return _y_.\\n  1. Let _r_ be _m_(_x_, _d_).\\n  1. If _r_ is not ~failure~, return ~failure~.\\n  1. Return _c_(_x_).\")\n}","def IsWordChar(\n  rer: Record[RegExpRecord],\n  Input: Unknown[\"ListOfCharacter\"],\n  e: Int,\n): Boolean = {\n  let InputLength = (sizeof Input)\n  if (|| (== e (- 1)) (== e InputLength)) {\n    return false\n  }\n  (yet \"Let _c_ be the character _Input_[_e_].\")\n  call %0 = clo<\"WordCharacters\">(rer)\n  if (contains %0 c) {\n    return true\n  }\n  return false\n}","def <SYNTAX>:Quantifier[0,0].CompileQuantifier(\n  this: Ast[Quantifier[0]],\n): Unknown[\"RecordWithFields[[Min]](aNonnegativeInteger),[[Max]](aNonnegativeIntegerOr+‚àû),And[[Greedy]](aBoolean)\"] = {\n  sdo-call %0 = this[0]->CompileQuantifierPrefix()\n  let qp = %0\n  return (record {\n    \"Min\" : qp.Min,\n    \"Max\" : qp.Max,\n    \"Greedy\" : true,\n  })[#1021]\n}","def <SYNTAX>:Quantifier[1,0].CompileQuantifier(\n  this: Ast[Quantifier[1]],\n): Unknown[\"RecordWithFields[[Min]](aNonnegativeInteger),[[Max]](aNonnegativeIntegerOr+‚àû),And[[Greedy]](aBoolean)\"] = {\n  sdo-call %0 = this[0]->CompileQuantifierPrefix()\n  let qp = %0\n  return (record {\n    \"Min\" : qp.Min,\n    \"Max\" : qp.Max,\n    \"Greedy\" : false,\n  })[#1022]\n}","def <SYNTAX>:QuantifierPrefix[0,0].CompileQuantifierPrefix(\n  this: Ast[QuantifierPrefix[0]],\n): Unknown[\"RecordWithFields[[Min]](aNonnegativeInteger)And[[Max]](aNonnegativeIntegerOr+‚àû)\"] = {\n  return (record {\n    \"Min\" : 0,\n    \"Max\" : +INF,\n  })[#1023]\n}","def <SYNTAX>:QuantifierPrefix[1,0].CompileQuantifierPrefix(\n  this: Ast[QuantifierPrefix[1]],\n): Unknown[\"RecordWithFields[[Min]](aNonnegativeInteger)And[[Max]](aNonnegativeIntegerOr+‚àû)\"] = {\n  return (record {\n    \"Min\" : 1,\n    \"Max\" : +INF,\n  })[#1024]\n}","def <SYNTAX>:QuantifierPrefix[2,0].CompileQuantifierPrefix(\n  this: Ast[QuantifierPrefix[2]],\n): Unknown[\"RecordWithFields[[Min]](aNonnegativeInteger)And[[Max]](aNonnegativeIntegerOr+‚àû)\"] = {\n  return (record {\n    \"Min\" : 0,\n    \"Max\" : 1,\n  })[#1025]\n}","def <SYNTAX>:QuantifierPrefix[3,0].CompileQuantifierPrefix(\n  this: Ast[QuantifierPrefix[3]],\n): Unknown[\"RecordWithFields[[Min]](aNonnegativeInteger)And[[Max]](aNonnegativeIntegerOr+‚àû)\"] = {\n  sdo-call %0 = this[0]->MV()\n  let i = %0\n  return (record {\n    \"Min\" : i,\n    \"Max\" : i,\n  })[#1026]\n}","def <SYNTAX>:QuantifierPrefix[4,0].CompileQuantifierPrefix(\n  this: Ast[QuantifierPrefix[4]],\n): Unknown[\"RecordWithFields[[Min]](aNonnegativeInteger)And[[Max]](aNonnegativeIntegerOr+‚àû)\"] = {\n  sdo-call %0 = this[0]->MV()\n  let i = %0\n  return (record {\n    \"Min\" : i,\n    \"Max\" : +INF,\n  })[#1027]\n}","def <SYNTAX>:QuantifierPrefix[5,0].CompileQuantifierPrefix(\n  this: Ast[QuantifierPrefix[5]],\n): Unknown[\"RecordWithFields[[Min]](aNonnegativeInteger)And[[Max]](aNonnegativeIntegerOr+‚àû)\"] = {\n  sdo-call %0 = this[0]->MV()\n  let i = %0\n  sdo-call %1 = this[1]->MV()\n  let j = %1\n  return (record {\n    \"Min\" : i,\n    \"Max\" : j,\n  })[#1028]\n}","def <SYNTAX>:Atom[0,0].CompileAtom(\n  this: Ast[Atom[0]],\n  rer: Record[RegExpRecord],\n  direction: Enum[~backward~, ~forward~],\n): Record[Matcher] = {\n  (yet \"Let _ch_ be the character matched by |PatternCharacter|.\")\n  (yet \"Let _A_ be a one-element CharSet containing the character _ch_.\")\n  call %0 = clo<\"CharacterSetMatcher\">(rer, A, false, direction)\n  return %0\n}","def <SYNTAX>:Atom[1,0].CompileAtom(\n  this: Ast[Atom[1]],\n  rer: Record[RegExpRecord],\n  direction: Enum[~backward~, ~forward~],\n): Record[Matcher] = {\n  call %0 = clo<\"AllCharacters\">(rer)\n  let A = %0\n  if (! (= rer.DotAll true)) {\n    (yet \"Remove from _A_ all characters corresponding to a code point on the right-hand side of the |LineTerminator| production.\")\n  }\n  call %1 = clo<\"CharacterSetMatcher\">(rer, A, false, direction)\n  return %1\n}","def <SYNTAX>:Atom[3,0].CompileAtom(\n  this: Ast[Atom[3]],\n  rer: Record[RegExpRecord],\n  direction: Enum[~backward~, ~forward~],\n): Record[Matcher] = {\n  sdo-call %0 = this[0]->CompileCharacterClass(rer)\n  let cc = %0\n  let cs = cc.CharSet\n  if (= rer.UnicodeSets false) {\n    (yet \"or if every CharSetElement of _cs_ consists of a single character (including if _cs_ is empty), return CharacterSetMatcher(_rer_, _cs_, _cc_.[[Invert]], _direction_).\")\n  }\n  assert (= cc.Invert false)\n  (yet \"Let _lm_ be an empty List of Matchers.\")\n  (yet \"For each CharSetElement _s_ in _cs_ containing more than 1 character, iterating in descending order of length, do\\n  1. Let _cs2_ be a one-element CharSet containing the last code point of _s_.\\n  1. Let _m2_ be CharacterSetMatcher(_rer_, _cs2_, *false*, _direction_).\\n  1. For each code point _c1_ in _s_, iterating backwards from its second-to-last code point, do\\n    1. Let _cs1_ be a one-element CharSet containing _c1_.\\n    1. Let _m1_ be CharacterSetMatcher(_rer_, _cs1_, *false*, _direction_).\\n    1. Set _m2_ to MatchSequence(_m1_, _m2_, _direction_).\\n  1. Append _m2_ to _lm_.\")\n  (yet \"Let _singles_ be the CharSet containing every CharSetElement of _cs_ that consists of a single character.\")\n  call %1 = clo<\"CharacterSetMatcher\">(rer, singles, false, direction)\n  push lm < %1\n  (yet \"If _cs_ contains the empty sequence of characters, append EmptyMatcher() to _lm_.\")\n  (yet \"Let _m2_ be the last Matcher in _lm_.\")\n  (yet \"For each Matcher _m1_ of _lm_, iterating backwards from its second-to-last element, do\\n  1. Set _m2_ to MatchTwoAlternatives(_m1_, _m2_).\")\n  return m2\n}","def <SYNTAX>:Atom[4,0].CompileAtom(\n  this: Ast[Atom[4]],\n  rer: Record[RegExpRecord],\n  direction: Enum[~backward~, ~forward~],\n): Record[Matcher] = {\n  sdo-call %0 = this[1]->CompileSubpattern(rer, direction)\n  let m = %0\n  call %1 = clo<\"CountLeftCapturingParensBefore\">(this)\n  let parenIndex = %1\n  (yet \"Return a new Matcher with parameters (_x_, _c_) that captures _direction_, _m_, and _parenIndex_ and performs the following steps when called:\\n  1. Assert: _x_ is a Record[MatchState].\\n  1. Assert: _c_ is a Record[MatcherContinuation].\\n  1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures _x_, _c_, _direction_, and _parenIndex_ and performs the following steps when called:\\n    1. Assert: _y_ is a Record[MatchState].\\n    1. Let _cap_ be a copy of _y_.[[Captures]].\\n    1. Let _Input_ be _x_.[[Input]].\\n    1. Let _xe_ be _x_.[[EndIndex]].\\n    1. Let _ye_ be _y_.[[EndIndex]].\\n    1. If _direction_ is ~forward~, then\\n      1. Assert: _xe_ ‚â§ _ye_.\\n      1. Let _r_ be CaptureRange { [[StartIndex]]: _xe_, [[EndIndex]]: _ye_ }.\\n    1. Else,\\n      1. Assert: _direction_ is ~backward~.\\n      1. Assert: _ye_ ‚â§ _xe_.\\n      1. Let _r_ be CaptureRange { [[StartIndex]]: _ye_, [[EndIndex]]: _xe_ }.\\n    1. Set _cap_[_parenIndex_ + 1] to _r_.\\n    1. Let _z_ be MatchState { [[Input]]: _Input_, [[EndIndex]]: _ye_, [[Captures]]: _cap_ }.\\n    1. Return _c_(_z_).\\n  1. Return _m_(_x_, _d_).\")\n}","def <SYNTAX>:Atom[4,1].CompileAtom(\n  this: Ast[Atom[4]],\n  rer: Record[RegExpRecord],\n  direction: Enum[~backward~, ~forward~],\n): Record[Matcher] = {\n  sdo-call %0 = this[1]->CompileSubpattern(rer, direction)\n  let m = %0\n  call %1 = clo<\"CountLeftCapturingParensBefore\">(this)\n  let parenIndex = %1\n  (yet \"Return a new Matcher with parameters (_x_, _c_) that captures _direction_, _m_, and _parenIndex_ and performs the following steps when called:\\n  1. Assert: _x_ is a Record[MatchState].\\n  1. Assert: _c_ is a Record[MatcherContinuation].\\n  1. Let _d_ be a new MatcherContinuation with parameters (_y_) that captures _x_, _c_, _direction_, and _parenIndex_ and performs the following steps when called:\\n    1. Assert: _y_ is a Record[MatchState].\\n    1. Let _cap_ be a copy of _y_.[[Captures]].\\n    1. Let _Input_ be _x_.[[Input]].\\n    1. Let _xe_ be _x_.[[EndIndex]].\\n    1. Let _ye_ be _y_.[[EndIndex]].\\n    1. If _direction_ is ~forward~, then\\n      1. Assert: _xe_ ‚â§ _ye_.\\n      1. Let _r_ be CaptureRange { [[StartIndex]]: _xe_, [[EndIndex]]: _ye_ }.\\n    1. Else,\\n      1. Assert: _direction_ is ~backward~.\\n      1. Assert: _ye_ ‚â§ _xe_.\\n      1. Let _r_ be CaptureRange { [[StartIndex]]: _ye_, [[EndIndex]]: _xe_ }.\\n    1. Set _cap_[_parenIndex_ + 1] to _r_.\\n    1. Let _z_ be MatchState { [[Input]]: _Input_, [[EndIndex]]: _ye_, [[Captures]]: _cap_ }.\\n    1. Return _c_(_z_).\\n  1. Return _m_(_x_, _d_).\")\n}","def <SYNTAX>:Atom[5,0].CompileAtom(\n  this: Ast[Atom[5]],\n  rer: Record[RegExpRecord],\n  direction: Enum[~backward~, ~forward~],\n): Record[Matcher] = {\n  sdo-call %0 = this[0]->CompileSubpattern(rer, direction)\n  return %0\n}","def <SYNTAX>:AtomEscape[0,0].CompileAtom(\n  this: Ast[AtomEscape[0]],\n  rer: Record[RegExpRecord],\n  direction: Enum[~backward~, ~forward~],\n): Record[Matcher] = {\n  sdo-call %0 = this[0]->CapturingGroupNumber()\n  let n = %0\n  assert (! (< rer.CapturingGroupsCount n))\n  call %1 = clo<\"BackreferenceMatcher\">(rer, n, direction)\n  return %1\n}","def <SYNTAX>:AtomEscape[2,0].CompileAtom(\n  this: Ast[AtomEscape[2]],\n  rer: Record[RegExpRecord],\n  direction: Enum[~backward~, ~forward~],\n): Record[Matcher] = {\n  sdo-call %0 = this[0]->CharacterValue()\n  let cv = %0\n  (yet \"Let _ch_ be the character whose character value is _cv_.\")\n  (yet \"Let _A_ be a one-element CharSet containing the character _ch_.\")\n  call %1 = clo<\"CharacterSetMatcher\">(rer, A, false, direction)\n  return %1\n}","def <SYNTAX>:AtomEscape[1,0].CompileAtom(\n  this: Ast[AtomEscape[1]],\n  rer: Record[RegExpRecord],\n  direction: Enum[~backward~, ~forward~],\n): Record[Matcher] = {\n  sdo-call %0 = this[0]->CompileToCharSet(rer)\n  let cs = %0\n  if (= rer.UnicodeSets false) {\n    (yet \"or if every CharSetElement of _cs_ consists of a single character (including if _cs_ is empty), return CharacterSetMatcher(_rer_, _cs_, *false*, _direction_).\")\n  }\n  (yet \"Let _lm_ be an empty List of Matchers.\")\n  (yet \"For each CharSetElement _s_ in _cs_ containing more than 1 character, iterating in descending order of length, do\\n  1. Let _cs2_ be a one-element CharSet containing the last code point of _s_.\\n  1. Let _m2_ be CharacterSetMatcher(_rer_, _cs2_, *false*, _direction_).\\n  1. For each code point _c1_ in _s_, iterating backwards from its second-to-last code point, do\\n    1. Let _cs1_ be a one-element CharSet containing _c1_.\\n    1. Let _m1_ be CharacterSetMatcher(_rer_, _cs1_, *false*, _direction_).\\n    1. Set _m2_ to MatchSequence(_m1_, _m2_, _direction_).\\n  1. Append _m2_ to _lm_.\")\n  (yet \"Let _singles_ be the CharSet containing every CharSetElement of _cs_ that consists of a single character.\")\n  call %1 = clo<\"CharacterSetMatcher\">(rer, singles, false, direction)\n  push lm < %1\n  (yet \"If _cs_ contains the empty sequence of characters, append EmptyMatcher() to _lm_.\")\n  (yet \"Let _m2_ be the last Matcher in _lm_.\")\n  (yet \"For each Matcher _m1_ of _lm_, iterating backwards from its second-to-last element, do\\n  1. Set _m2_ to MatchTwoAlternatives(_m1_, _m2_).\")\n  return m2\n}","def <SYNTAX>:AtomEscape[3,0].CompileAtom(\n  this: Ast[AtomEscape[3]],\n  rer: Record[RegExpRecord],\n  direction: Enum[~backward~, ~forward~],\n): Record[Matcher] = {\n  call %0 = clo<\"GroupSpecifiersThatMatch\">(this[0])\n  let matchingGroupSpecifiers = %0\n  assert (yet \"_matchingGroupSpecifiers_ contains a single |GroupSpecifier|.\")\n  let groupSpecifier = matchingGroupSpecifiers[0]\n  call %1 = clo<\"CountLeftCapturingParensBefore\">(groupSpecifier)\n  let parenIndex = %1\n  call %2 = clo<\"BackreferenceMatcher\">(rer, parenIndex, direction)\n  return %2\n}","def CharacterSetMatcher(\n  rer: Record[RegExpRecord],\n  A: Record[CharSet],\n  invert: Boolean,\n  direction: Enum[~backward~, ~forward~],\n): Record[Matcher] = {\n  if (= rer.UnicodeSets true) {\n    assert (= invert false)\n    assert (yet \"Every CharSetElement of _A_ consists of a single character.\")\n  }\n  (yet \"Return a new Matcher with parameters (_x_, _c_) that captures _rer_, _A_, _invert_, and _direction_ and performs the following steps when called:\\n  1. Assert: _x_ is a Record[MatchState].\\n  1. Assert: _c_ is a Record[MatcherContinuation].\\n  1. Let _Input_ be _x_.[[Input]].\\n  1. Let _e_ be _x_.[[EndIndex]].\\n  1. If _direction_ is ~forward~, let _f_ be _e_ + 1.\\n  1. Else, let _f_ be _e_ - 1.\\n  1. Let _InputLength_ be the number of elements in _Input_.\\n  1. If _f_ < 0 or _f_ > _InputLength_, return ~failure~.\\n  1. Let _index_ be min(_e_, _f_).\\n  1. Let _ch_ be the character _Input_[_index_].\\n  1. Let _cc_ be Canonicalize(_rer_, _ch_).\\n  1. If there exists a CharSetElement in _A_ containing exactly one character _a_ such that Canonicalize(_rer_, _a_) is _cc_, let _found_ be *true*. Otherwise, let _found_ be *false*.\\n  1. If _invert_ is *false* and _found_ is *false*, return ~failure~.\\n  1. If _invert_ is *true* and _found_ is *true*, return ~failure~.\\n  1. Let _cap_ be _x_.[[Captures]].\\n  1. Let _y_ be MatchState { [[Input]]: _Input_, [[EndIndex]]: _f_, [[Captures]]: _cap_ }.\\n  1. Return _c_(_y_).\")\n}","def BackreferenceMatcher(\n  rer: Record[RegExpRecord],\n  n: PosInt,\n  direction: Enum[~backward~, ~forward~],\n): Record[Matcher] = {\n  assert (! (< n 1))\n  (yet \"Return a new Matcher with parameters (_x_, _c_) that captures _rer_, _n_, and _direction_ and performs the following steps when called:\\n  1. Assert: _x_ is a Record[MatchState].\\n  1. Assert: _c_ is a Record[MatcherContinuation].\\n  1. Let _Input_ be _x_.[[Input]].\\n  1. Let _cap_ be _x_.[[Captures]].\\n  1. Let _r_ be _cap_[_n_].\\n  1. If _r_ is *undefined*, return _c_(_x_).\\n  1. Let _e_ be _x_.[[EndIndex]].\\n  1. Let _rs_ be _r_.[[StartIndex]].\\n  1. Let _re_ be _r_.[[EndIndex]].\\n  1. Let _len_ be _re_ - _rs_.\\n  1. If _direction_ is ~forward~, let _f_ be _e_ + _len_.\\n  1. Else, let _f_ be _e_ - _len_.\\n  1. Let _InputLength_ be the number of elements in _Input_.\\n  1. If _f_ < 0 or _f_ > _InputLength_, return ~failure~.\\n  1. Let _g_ be min(_e_, _f_).\\n  1. If there exists an integer _i_ in the interval from 0 (inclusive) to _len_ (exclusive) such that Canonicalize(_rer_, _Input_[_rs_ + _i_]) is not Canonicalize(_rer_, _Input_[_g_ + _i_]), return ~failure~.\\n  1. Let _y_ be MatchState { [[Input]]: _Input_, [[EndIndex]]: _f_, [[Captures]]: _cap_ }.\\n  1. Return _c_(_y_).\")\n}","def Canonicalize(\n  rer: Record[RegExpRecord],\n  ch: Unknown[\"Character\"],\n): Unknown[\"Character\"] = {\n  call %0 = clo<\"HasEitherUnicodeFlag\">(rer)\n  if (&& (= %0 true) (= rer.IgnoreCase true)) {\n    (yet \"If the file <a href=\\\"https://unicode.org/Public/UCD/latest/ucd/CaseFolding.txt\\\"><code>CaseFolding.txt</code></a> of the Unicode Character Database provides a simple or common case folding mapping for _ch_, return the result of applying that mapping to _ch_.\")\n    return ch\n  }\n  if (= rer.IgnoreCase false) {\n    return ch\n  }\n  assert (yet \"_ch_ is a UTF-16 code unit.\")\n  (yet \"Let _cp_ be the code point whose numeric value is the numeric value of _ch_.\")\n  (yet \"Let _u_ be the result of toUppercase(¬´ _cp_ ¬ª), according to the Unicode Default Case Conversion algorithm.\")\n  call %1 = clo<\"CodePointsToString\">(u)\n  let uStr = %1\n  if (! (== (sizeof uStr) 1)) {\n    return ch\n  }\n  (yet \"Let _cu_ be _uStr_'s single code unit element.\")\n  if (&& (! (< ([math] ch) 128)) (< ([math] cu) 128)) {\n    return ch\n  }\n  return cu\n}","def <SYNTAX>:CharacterClass[0,0].CompileCharacterClass(\n  this: Ast[CharacterClass[0]],\n  rer: Record[RegExpRecord],\n): Unknown[\"RecordWithFields[[CharSet]](aCharSet)And[[Invert]](aBoolean)\"] = {\n  sdo-call %0 = this[0]->CompileToCharSet(rer)\n  let A = %0\n  return (record {\n    \"CharSet\" : A,\n    \"Invert\" : false,\n  })[#1029]\n}","def <SYNTAX>:CharacterClass[1,0].CompileCharacterClass(\n  this: Ast[CharacterClass[1]],\n  rer: Record[RegExpRecord],\n): Unknown[\"RecordWithFields[[CharSet]](aCharSet)And[[Invert]](aBoolean)\"] = {\n  sdo-call %0 = this[0]->CompileToCharSet(rer)\n  let A = %0\n  if (= rer.UnicodeSets true) {\n    call %1 = clo<\"CharacterComplement\">(rer, A)\n    return (record {\n      \"CharSet\" : %1,\n      \"Invert\" : false,\n    })[#1030]\n  }\n  return (record {\n    \"CharSet\" : A,\n    \"Invert\" : true,\n  })[#1031]\n}","def <SYNTAX>:ClassContents[0,0].CompileToCharSet(\n  this: Ast[ClassContents[0]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  (yet \"Return the empty CharSet.\")\n}","def <SYNTAX>:NonemptyClassRanges[1,0].CompileToCharSet(\n  this: Ast[NonemptyClassRanges[1]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this[0]->CompileToCharSet(rer)\n  let A = %0\n  sdo-call %1 = this[1]->CompileToCharSet(rer)\n  let B = %1\n  (yet \"Return the union of CharSets _A_ and _B_.\")\n}","def <SYNTAX>:NonemptyClassRanges[2,0].CompileToCharSet(\n  this: Ast[NonemptyClassRanges[2]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this[0]->CompileToCharSet(rer)\n  let A = %0\n  sdo-call %1 = this[1]->CompileToCharSet(rer)\n  let B = %1\n  sdo-call %2 = this[2]->CompileToCharSet(rer)\n  let C = %2\n  call %3 = clo<\"CharacterRange\">(A, B)\n  let D = %3\n  (yet \"Return the union of _D_ and _C_.\")\n}","def <SYNTAX>:NonemptyClassRangesNoDash[1,0].CompileToCharSet(\n  this: Ast[NonemptyClassRangesNoDash[1]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this[0]->CompileToCharSet(rer)\n  let A = %0\n  sdo-call %1 = this[1]->CompileToCharSet(rer)\n  let B = %1\n  (yet \"Return the union of CharSets _A_ and _B_.\")\n}","def <SYNTAX>:NonemptyClassRangesNoDash[2,0].CompileToCharSet(\n  this: Ast[NonemptyClassRangesNoDash[2]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this[0]->CompileToCharSet(rer)\n  let A = %0\n  sdo-call %1 = this[1]->CompileToCharSet(rer)\n  let B = %1\n  sdo-call %2 = this[2]->CompileToCharSet(rer)\n  let C = %2\n  call %3 = clo<\"CharacterRange\">(A, B)\n  let D = %3\n  (yet \"Return the union of _D_ and _C_.\")\n}","def <SYNTAX>:ClassAtom[0,0].CompileToCharSet(\n  this: Ast[ClassAtom[0]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  (yet \"Return the CharSet containing the single character `-` U+002D (HYPHEN-MINUS).\")\n}","def <SYNTAX>:ClassAtomNoDash[0,0].CompileToCharSet(\n  this: Ast[ClassAtomNoDash[0]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  (yet \"Return the CharSet containing the character matched by |SourceCharacter|.\")\n}","def <SYNTAX>:ClassEscape[0,0].CompileToCharSet(\n  this: Ast[ClassEscape[0]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this->CharacterValue()\n  let cv = %0\n  (yet \"Let _c_ be the character whose character value is _cv_.\")\n  (yet \"Return the CharSet containing the single character _c_.\")\n}","def <SYNTAX>:ClassEscape[1,0].CompileToCharSet(\n  this: Ast[ClassEscape[1]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this->CharacterValue()\n  let cv = %0\n  (yet \"Let _c_ be the character whose character value is _cv_.\")\n  (yet \"Return the CharSet containing the single character _c_.\")\n}","def <SYNTAX>:ClassEscape[3,0].CompileToCharSet(\n  this: Ast[ClassEscape[3]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this->CharacterValue()\n  let cv = %0\n  (yet \"Let _c_ be the character whose character value is _cv_.\")\n  (yet \"Return the CharSet containing the single character _c_.\")\n}","def <SYNTAX>:CharacterClassEscape[0,0].CompileToCharSet(\n  this: Ast[CharacterClassEscape[0]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  (yet \"Return the ten-element CharSet containing the characters `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, and `9`.\")\n}","def <SYNTAX>:CharacterClassEscape[1,0].CompileToCharSet(\n  this: Ast[CharacterClassEscape[1]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  (yet \"Let _S_ be the CharSet returned by <emu-grammar>CharacterClassEscape :: `d`</emu-grammar>.\")\n  call %0 = clo<\"CharacterComplement\">(rer, S)\n  return %0\n}","def <SYNTAX>:CharacterClassEscape[2,0].CompileToCharSet(\n  this: Ast[CharacterClassEscape[2]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  (yet \"Return the CharSet containing all characters corresponding to a code point on the right-hand side of the |WhiteSpace| or |LineTerminator| productions.\")\n}","def <SYNTAX>:CharacterClassEscape[3,0].CompileToCharSet(\n  this: Ast[CharacterClassEscape[3]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  (yet \"Let _S_ be the CharSet returned by <emu-grammar>CharacterClassEscape :: `s`</emu-grammar>.\")\n  call %0 = clo<\"CharacterComplement\">(rer, S)\n  return %0\n}","def <SYNTAX>:CharacterClassEscape[4,0].CompileToCharSet(\n  this: Ast[CharacterClassEscape[4]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  call %0 = clo<\"WordCharacters\">(rer)\n  call %1 = clo<\"MaybeSimpleCaseFolding\">(rer, %0)\n  return %1\n}","def <SYNTAX>:CharacterClassEscape[5,0].CompileToCharSet(\n  this: Ast[CharacterClassEscape[5]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  (yet \"Let _S_ be the CharSet returned by <emu-grammar>CharacterClassEscape :: `w`</emu-grammar>.\")\n  call %0 = clo<\"CharacterComplement\">(rer, S)\n  return %0\n}","def <SYNTAX>:CharacterClassEscape[6,0].CompileToCharSet(\n  this: Ast[CharacterClassEscape[6]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this[0]->CompileToCharSet(rer)\n  return %0\n}","def <SYNTAX>:CharacterClassEscape[7,0].CompileToCharSet(\n  this: Ast[CharacterClassEscape[7]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this[0]->CompileToCharSet(rer)\n  let S = %0\n  assert (yet \"_S_ contains only single code points.\")\n  call %1 = clo<\"CharacterComplement\">(rer, S)\n  return %1\n}","def <SYNTAX>:UnicodePropertyValueExpression[0,0].CompileToCharSet(\n  this: Ast[UnicodePropertyValueExpression[0]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  let ps = (source-text this[0])\n  call %0 = clo<\"UnicodeMatchProperty\">(rer, ps)\n  let p = %0\n  assert (yet \"_p_ is a Unicode property name or property alias listed in the ‚ÄúProperty name and aliases‚Äù column of <emu-xref href=\\\"#table-nonbinary-unicode-properties\\\"></emu-xref>.\")\n  let vs = (source-text this[1])\n  call %1 = clo<\"UnicodeMatchPropertyValue\">(p, vs)\n  let v = %1\n  (yet \"Let _A_ be the CharSet containing all Unicode code points whose character database definition includes the property _p_ with value _v_.\")\n  call %2 = clo<\"MaybeSimpleCaseFolding\">(rer, A)\n  return %2\n}","def <SYNTAX>:UnicodePropertyValueExpression[1,0].CompileToCharSet(\n  this: Ast[UnicodePropertyValueExpression[1]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  let s = (source-text this[0])\n  (yet \"If UnicodeMatchPropertyValue(`General_Category`, _s_) is a Unicode property value or property value alias for the General_Category (gc) property listed in <a href=\\\"https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt\\\"><code>PropertyValueAliases.txt</code></a>, then\\n  1. Return the CharSet containing all Unicode code points whose character database definition includes the property ‚ÄúGeneral_Category‚Äù with value _s_.\")\n  call %0 = clo<\"UnicodeMatchProperty\">(rer, s)\n  let p = %0\n  assert (yet \"_p_ is a binary Unicode property or binary property alias listed in the ‚Äú<emu-not-ref>Property name</emu-not-ref> and aliases‚Äù column of <emu-xref href=\\\"#table-binary-unicode-properties\\\"></emu-xref>, or a binary Unicode property of strings listed in the ‚Äú<emu-not-ref>Property name</emu-not-ref>‚Äù column of <emu-xref href=\\\"#table-binary-unicode-properties-of-strings\\\"></emu-xref>.\")\n  (yet \"Let _A_ be the CharSet containing all CharSetElements whose character database definition includes the property _p_ with value ‚ÄúTrue‚Äù.\")\n  call %1 = clo<\"MaybeSimpleCaseFolding\">(rer, A)\n  return %1\n}","def <SYNTAX>:ClassUnion[0,0].CompileToCharSet(\n  this: Ast[ClassUnion[0]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this[0]->CompileToCharSet(rer)\n  let A = %0\n  if (exists this[1]) {\n    sdo-call %1 = this[1]->CompileToCharSet(rer)\n    let B = %1\n    (yet \"Return the union of CharSets _A_ and _B_.\")\n  }\n  return A\n}","def <SYNTAX>:ClassUnion[0,1].CompileToCharSet(\n  this: Ast[ClassUnion[0]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this[0]->CompileToCharSet(rer)\n  let A = %0\n  if (exists this[1]) {\n    sdo-call %1 = this[1]->CompileToCharSet(rer)\n    let B = %1\n    (yet \"Return the union of CharSets _A_ and _B_.\")\n  }\n  return A\n}","def <SYNTAX>:ClassUnion[1,0].CompileToCharSet(\n  this: Ast[ClassUnion[1]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this[0]->CompileToCharSet(rer)\n  let A = %0\n  if (exists this[1]) {\n    sdo-call %1 = this[1]->CompileToCharSet(rer)\n    let B = %1\n    (yet \"Return the union of CharSets _A_ and _B_.\")\n  }\n  return A\n}","def <SYNTAX>:ClassUnion[1,1].CompileToCharSet(\n  this: Ast[ClassUnion[1]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this[0]->CompileToCharSet(rer)\n  let A = %0\n  if (exists this[1]) {\n    sdo-call %1 = this[1]->CompileToCharSet(rer)\n    let B = %1\n    (yet \"Return the union of CharSets _A_ and _B_.\")\n  }\n  return A\n}","def <SYNTAX>:ClassIntersection[0,0].CompileToCharSet(\n  this: Ast[ClassIntersection[0]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this[0]->CompileToCharSet(rer)\n  let A = %0\n  sdo-call %1 = this[1]->CompileToCharSet(rer)\n  let B = %1\n  (yet \"Return the intersection of CharSets _A_ and _B_.\")\n}","def <SYNTAX>:ClassIntersection[1,0].CompileToCharSet(\n  this: Ast[ClassIntersection[1]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this[0]->CompileToCharSet(rer)\n  let A = %0\n  sdo-call %1 = this[1]->CompileToCharSet(rer)\n  let B = %1\n  (yet \"Return the intersection of CharSets _A_ and _B_.\")\n}","def <SYNTAX>:ClassSubtraction[0,0].CompileToCharSet(\n  this: Ast[ClassSubtraction[0]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this[0]->CompileToCharSet(rer)\n  let A = %0\n  sdo-call %1 = this[1]->CompileToCharSet(rer)\n  let B = %1\n  (yet \"Return the CharSet containing the CharSetElements of _A_ which are not also CharSetElements of _B_.\")\n}","def <SYNTAX>:ClassSubtraction[1,0].CompileToCharSet(\n  this: Ast[ClassSubtraction[1]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this[0]->CompileToCharSet(rer)\n  let A = %0\n  sdo-call %1 = this[1]->CompileToCharSet(rer)\n  let B = %1\n  (yet \"Return the CharSet containing the CharSetElements of _A_ which are not also CharSetElements of _B_.\")\n}","def <SYNTAX>:ClassSetRange[0,0].CompileToCharSet(\n  this: Ast[ClassSetRange[0]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this[0]->CompileToCharSet(rer)\n  let A = %0\n  sdo-call %1 = this[1]->CompileToCharSet(rer)\n  let B = %1\n  call %2 = clo<\"CharacterRange\">(A, B)\n  call %3 = clo<\"MaybeSimpleCaseFolding\">(rer, %2)\n  return %3\n}","def <SYNTAX>:ClassSetOperand[2,0].CompileToCharSet(\n  this: Ast[ClassSetOperand[2]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this[0]->CompileToCharSet(rer)\n  let A = %0\n  call %1 = clo<\"MaybeSimpleCaseFolding\">(rer, A)\n  return %1\n}","def <SYNTAX>:ClassSetOperand[1,0].CompileToCharSet(\n  this: Ast[ClassSetOperand[1]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this[0]->CompileToCharSet(rer)\n  let A = %0\n  call %1 = clo<\"MaybeSimpleCaseFolding\">(rer, A)\n  return %1\n}","def <SYNTAX>:ClassSetOperand[0,0].CompileToCharSet(\n  this: Ast[ClassSetOperand[0]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this[0]->CompileToCharSet(rer)\n  return %0\n}","def <SYNTAX>:NestedClass[0,0].CompileToCharSet(\n  this: Ast[NestedClass[0]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this[0]->CompileToCharSet(rer)\n  return %0\n}","def <SYNTAX>:NestedClass[1,0].CompileToCharSet(\n  this: Ast[NestedClass[1]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this[0]->CompileToCharSet(rer)\n  let A = %0\n  call %1 = clo<\"CharacterComplement\">(rer, A)\n  return %1\n}","def <SYNTAX>:NestedClass[2,0].CompileToCharSet(\n  this: Ast[NestedClass[2]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this[0]->CompileToCharSet(rer)\n  return %0\n}","def <SYNTAX>:ClassStringDisjunction[0,0].CompileToCharSet(\n  this: Ast[ClassStringDisjunction[0]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this[0]->CompileToCharSet(rer)\n  return %0\n}","def <SYNTAX>:ClassStringDisjunctionContents[0,0].CompileToCharSet(\n  this: Ast[ClassStringDisjunctionContents[0]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this[0]->CompileClassSetString(rer)\n  let s = %0\n  (yet \"Return the CharSet containing the one string _s_.\")\n}","def <SYNTAX>:ClassStringDisjunctionContents[1,0].CompileToCharSet(\n  this: Ast[ClassStringDisjunctionContents[1]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this[0]->CompileClassSetString(rer)\n  let s = %0\n  (yet \"Let _A_ be the CharSet containing the one string _s_.\")\n  sdo-call %1 = this[1]->CompileToCharSet(rer)\n  let B = %1\n  (yet \"Return the union of CharSets _A_ and _B_.\")\n}","def <SYNTAX>:ClassSetCharacter[0,0].CompileToCharSet(\n  this: Ast[ClassSetCharacter[0]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this->CharacterValue()\n  let cv = %0\n  (yet \"Let _c_ be the character whose character value is _cv_.\")\n  (yet \"Return the CharSet containing the single character _c_.\")\n}","def <SYNTAX>:ClassSetCharacter[1,0].CompileToCharSet(\n  this: Ast[ClassSetCharacter[1]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this->CharacterValue()\n  let cv = %0\n  (yet \"Let _c_ be the character whose character value is _cv_.\")\n  (yet \"Return the CharSet containing the single character _c_.\")\n}","def <SYNTAX>:ClassSetCharacter[2,0].CompileToCharSet(\n  this: Ast[ClassSetCharacter[2]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  sdo-call %0 = this->CharacterValue()\n  let cv = %0\n  (yet \"Let _c_ be the character whose character value is _cv_.\")\n  (yet \"Return the CharSet containing the single character _c_.\")\n}","def <SYNTAX>:ClassSetCharacter[3,0].CompileToCharSet(\n  this: Ast[ClassSetCharacter[3]],\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  (yet \"Return the CharSet containing the single character U+0008 (BACKSPACE).\")\n}","def CharacterRange(\n  A: Record[CharSet],\n  B: Record[CharSet],\n): Record[CharSet] = {\n  assert (yet \"_A_ and _B_ each contain exactly one character.\")\n  (yet \"Let _a_ be the one character in CharSet _A_.\")\n  (yet \"Let _b_ be the one character in CharSet _B_.\")\n  (yet \"Let _i_ be the character value of character _a_.\")\n  (yet \"Let _j_ be the character value of character _b_.\")\n  assert (! (< j i))\n  (yet \"Return the CharSet containing all characters with a character value in the inclusive interval from _i_ to _j_.\")\n}","def HasEitherUnicodeFlag(\n  rer: Record[RegExpRecord],\n): Boolean = {\n  if (|| (= rer.Unicode true) (= rer.UnicodeSets true)) {\n    return true\n  }\n  return false\n}","def WordCharacters(\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  (yet \"Let _basicWordChars_ be the CharSet containing every character in the ASCII word characters.\")\n  (yet \"Let _extraWordChars_ be the CharSet containing all characters _c_ such that _c_ is not in _basicWordChars_ but Canonicalize(_rer_, _c_) is in _basicWordChars_.\")\n  assert (yet \"_extraWordChars_ is empty unless HasEitherUnicodeFlag(_rer_) is *true* and _rer_.[[IgnoreCase]] is *true*.\")\n  (yet \"Return the union of _basicWordChars_ and _extraWordChars_.\")\n}","def AllCharacters(\n  rer: Record[RegExpRecord],\n): Record[CharSet] = {\n  if (&& (= rer.UnicodeSets true) (= rer.IgnoreCase true)) {\n    (yet \"Return the CharSet containing all Unicode code points _c_ that do not have a <a href=\\\"https://www.unicode.org/reports/tr44/#Simple_Case_Folding\\\">Simple Case Folding</a> mapping (that is, scf(_c_)=_c_).\")\n  } else {\n    call %0 = clo<\"HasEitherUnicodeFlag\">(rer)\n    if (= %0 true) {\n      (yet \"Return the CharSet containing all code point values.\")\n    } else {\n      (yet \"Return the CharSet containing all code unit values.\")\n    }\n  }\n}","def MaybeSimpleCaseFolding(\n  rer: Record[RegExpRecord],\n  A: Record[CharSet],\n): Record[CharSet] = {\n  if (|| (= rer.UnicodeSets false) (= rer.IgnoreCase false)) {\n    return A\n  }\n  (yet \"Let _B_ be a new empty CharSet.\")\n  %1 = A\n  %0 = 0\n  while (< %0 (sizeof %1)) {\n    let s = %1[%0]\n    if (? s: Record[CharSetElement]) {\n      (yet \"Let _t_ be an empty sequence of characters.\")\n      (yet \"For each single code point _cp_ in _s_, do\\n  1. Append scf(_cp_) to _t_.\")\n      push B < t\n    }\n    %0 = (+ %0 1)\n  }\n  return B\n}","def CharacterComplement(\n  rer: Record[RegExpRecord],\n  S: Record[CharSet],\n): Record[CharSet] = {\n  call %0 = clo<\"AllCharacters\">(rer)\n  let A = %0\n  (yet \"Return the CharSet containing the CharSetElements of _A_ which are not also CharSetElements of _S_.\")\n}","def UnicodeMatchProperty(\n  rer: Record[RegExpRecord],\n  p: Unknown[\"ECMAScriptSourceText\"],\n): Unknown[\"UnicodePropertyName\"] = {\n  (yet \"If _rer_.[[UnicodeSets]] is *true* and _p_ is a Unicode <emu-not-ref>property name</emu-not-ref> listed in the ‚Äú<emu-not-ref>Property name</emu-not-ref>‚Äù column of <emu-xref href=\\\"#table-binary-unicode-properties-of-strings\\\"></emu-xref>, then\\n  1. Return the List of Unicode code points _p_.\")\n  assert (yet \"_p_ is a Unicode <emu-not-ref>property name</emu-not-ref> or property alias listed in the ‚Äú<emu-not-ref>Property name</emu-not-ref> and aliases‚Äù column of <emu-xref href=\\\"#table-nonbinary-unicode-properties\\\"></emu-xref> or <emu-xref href=\\\"#table-binary-unicode-properties\\\"></emu-xref>.\")\n  (yet \"Let _c_ be the canonical <emu-not-ref>property name</emu-not-ref> of _p_ as given in the ‚ÄúCanonical <emu-not-ref>property name</emu-not-ref>‚Äù column of the corresponding row.\")\n  (yet \"Return the List of Unicode code points _c_.\")\n}","def UnicodeMatchPropertyValue(\n  p: Unknown[\"ECMAScriptSourceText\"],\n  v: Unknown[\"ECMAScriptSourceText\"],\n): Unknown[\"UnicodePropertyValue\"] = {\n  assert (yet \"_p_ is a canonical, unaliased Unicode property name listed in the ‚ÄúCanonical property name‚Äù column of <emu-xref href=\\\"#table-nonbinary-unicode-properties\\\"></emu-xref>.\")\n  assert (yet \"_v_ is a property value or property value alias for the Unicode property _p_ listed in <a href=\\\"https://unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt\\\"><code>PropertyValueAliases.txt</code></a>.\")\n  (yet \"Let _value_ be the canonical property value of _v_ as given in the ‚ÄúCanonical property value‚Äù column of the corresponding row.\")\n  (yet \"Return the List of Unicode code points _value_.\")\n}","def <SYNTAX>:ClassString[0,0].CompileClassSetString(\n  this: Ast[ClassString[0]],\n  rer: Record[RegExpRecord],\n): Unknown[\"SequenceOfCharacter\"] = {\n  (yet \"Return an empty sequence of characters.\")\n}","def <SYNTAX>:ClassString[1,0].CompileClassSetString(\n  this: Ast[ClassString[1]],\n  rer: Record[RegExpRecord],\n): Unknown[\"SequenceOfCharacter\"] = {\n  sdo-call %0 = this[0]->CompileClassSetString(rer)\n  return %0\n}","def <SYNTAX>:NonEmptyClassString[0,0].CompileClassSetString(\n  this: Ast[NonEmptyClassString[0]],\n  rer: Record[RegExpRecord],\n): Unknown[\"SequenceOfCharacter\"] = {\n  sdo-call %0 = this[0]->CompileToCharSet(rer)\n  let cs = %0\n  (yet \"Let _s1_ be the sequence of characters that is the single CharSetElement of _cs_.\")\n  if (exists this[1]) {\n    sdo-call %1 = this[1]->CompileClassSetString(rer)\n    let s2 = %1\n    (yet \"Return the concatenation of _s1_ and _s2_.\")\n  }\n  return s1\n}","def <SYNTAX>:NonEmptyClassString[0,1].CompileClassSetString(\n  this: Ast[NonEmptyClassString[0]],\n  rer: Record[RegExpRecord],\n): Unknown[\"SequenceOfCharacter\"] = {\n  sdo-call %0 = this[0]->CompileToCharSet(rer)\n  let cs = %0\n  (yet \"Let _s1_ be the sequence of characters that is the single CharSetElement of _cs_.\")\n  if (exists this[1]) {\n    sdo-call %1 = this[1]->CompileClassSetString(rer)\n    let s2 = %1\n    (yet \"Return the concatenation of _s1_ and _s2_.\")\n  }\n  return s1\n}","def RegExpCreate(\n  P: ESValue,\n  F: String | Undefined,\n): Normal[Record[Object]] | Throw = {\n  call %0 = clo<\"RegExpAlloc\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%RegExp%\"])\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let obj = %0\n  call %1 = clo<\"RegExpInitialize\">(obj, P, F)\n  assert (? %1: Completion)\n  return %1\n}","def RegExpAlloc(\n  newTarget: Record[Constructor],\n): Normal[Record[Object]] | Throw = {\n  call %0 = clo<\"OrdinaryCreateFromConstructor\">(newTarget, \"%RegExp.prototype%\", (list [\"OriginalSource\", \"OriginalFlags\", \"RegExpRecord\", \"RegExpMatcher\"])[#1032])\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let obj = %0\n  call %1 = clo<\"DefinePropertyOrThrow\">(obj, \"lastIndex\", (record [PropertyDescriptor] {\n    \"Writable\" : true,\n    \"Enumerable\" : false,\n    \"Configurable\" : false,\n  })[#1033])\n  assert (? %1: Normal)\n  %1 = %1.Value\n  if (? obj: Completion) return obj\n  call %2 = clo<\"NormalCompletion\">(obj)\n  return %2\n}","def RegExpInitialize(\n  obj: Record[Object],\n  pattern: ESValue,\n  flags: ESValue,\n): Normal[Record[Object]] | Throw = {\n  if (= pattern undefined) {\n    let P = \"\"\n  } else {\n    call %0 = clo<\"ToString\">(pattern)\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let P = %0\n  }\n  if (= flags undefined) {\n    let F = \"\"\n  } else {\n    call %1 = clo<\"ToString\">(flags)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let F = %1\n  }\n  (yet \"If _F_ contains any code unit other than *\\\"d\\\"*, *\\\"g\\\"*, *\\\"i\\\"*, *\\\"m\\\"*, *\\\"s\\\"*, *\\\"u\\\"*, *\\\"v\\\"*, or *\\\"y\\\"*, or if _F_ contains any code unit more than once, throw a *SyntaxError* exception.\")\n  if (contains F \"i\") {\n    let i = true\n  } else {\n    let i = false\n  }\n  if (contains F \"m\") {\n    let m = true\n  } else {\n    let m = false\n  }\n  if (contains F \"s\") {\n    let s = true\n  } else {\n    let s = false\n  }\n  if (contains F \"u\") {\n    let u = true\n  } else {\n    let u = false\n  }\n  if (contains F \"v\") {\n    let v = true\n  } else {\n    let v = false\n  }\n  if (|| (= u true) (= v true)) {\n    call %2 = clo<\"StringToCodePoints\">(P)\n    let patternText = %2\n  } else {\n    (yet \"Let _patternText_ be the result of interpreting each of _P_'s 16-bit elements as a Unicode BMP code point. UTF-16 decoding is not applied to the elements.\")\n  }\n  call %3 = clo<\"ParsePattern\">(patternText, u, v)\n  let parseResult = %3\n  (yet \"If _parseResult_ is a non-empty List of *SyntaxError* objects, throw a *SyntaxError* exception.\")\n  assert (yet \"_parseResult_ is a |Pattern| Parse Node.\")\n  obj.OriginalSource = P\n  obj.OriginalFlags = F\n  call %4 = clo<\"CountLeftCapturingParensWithin\">(parseResult)\n  let capturingGroupsCount = %4\n  let rer = (record [RegExpRecord] {\n    \"IgnoreCase\" : i,\n    \"Multiline\" : m,\n    \"DotAll\" : s,\n    \"Unicode\" : u,\n    \"UnicodeSets\" : v,\n    \"CapturingGroupsCount\" : capturingGroupsCount,\n  })[#1034]\n  obj.RegExpRecord = rer\n  sdo-call %5 = parseResult->CompilePattern(rer)\n  obj.RegExpMatcher = %5\n  call %6 = clo<\"Set\">(obj, \"lastIndex\", 0.0f, true)\n  assert (? %6: Completion)\n  if (? %6: Abrupt) return %6\n  else %6 = %6.Value\n  if (? obj: Completion) return obj\n  call %7 = clo<\"NormalCompletion\">(obj)\n  return %7\n}","def ParsePattern(\n  patternText: Unknown[\"SequenceOfUnicodeCodePoint\"],\n  u: Boolean,\n  v: Boolean,\n): Unknown[\"ParseNodeOrANonemptyListOf*SyntaxError*Object\"] = {\n  if (&& (= v true) (= u true)) {\n    (yet \"Let _parseResult_ be a List containing one or more *SyntaxError* objects.\")\n  } else {\n    if (= v true) {\n      (yet \"Let _parseResult_ be ParseText(_patternText_, |Pattern[+UnicodeMode, +UnicodeSetsMode, +NamedCaptureGroups]|).\")\n    } else {\n      if (= u true) {\n        (yet \"Let _parseResult_ be ParseText(_patternText_, |Pattern[+UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]|).\")\n      } else {\n        (yet \"Let _parseResult_ be ParseText(_patternText_, |Pattern[~UnicodeMode, ~UnicodeSetsMode, +NamedCaptureGroups]|).\")\n      }\n    }\n  }\n  return parseResult\n}","def <BUILTIN>:INTRINSICS.RegExp(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1035]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop pattern < ArgumentsList\n    expand __args__.pattern\n  } else let pattern = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop flags < ArgumentsList\n    expand __args__.flags\n  } else let flags = undefined\n  call %0 = clo<\"IsRegExp\">(pattern)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let patternIsRegExp = %0\n  if (= NewTarget undefined) {\n    let newTarget = @EXECUTION_STACK[0].Function\n    if (&& (= patternIsRegExp true) (= flags undefined)) {\n      call %1 = clo<\"Get\">(pattern, \"constructor\")\n      assert (? %1: Completion)\n      if (? %1: Abrupt) return %1\n      else %1 = %1.Value\n      let patternConstructor = %1\n      call %2 = clo<\"SameValue\">(newTarget, patternConstructor)\n      if (= %2 true) {\n        if (? pattern: Completion) return pattern\n        call %3 = clo<\"NormalCompletion\">(pattern)\n        return %3\n      }\n    }\n  } else {\n    let newTarget = NewTarget\n  }\n  if (&& (? pattern: Record[Object]) (exists pattern.RegExpMatcher)) {\n    let P = pattern.OriginalSource\n    if (= flags undefined) {\n      let F = pattern.OriginalFlags\n    } else {\n      let F = flags\n    }\n  } else {\n    if (= patternIsRegExp true) {\n      call %4 = clo<\"Get\">(pattern, \"source\")\n      assert (? %4: Completion)\n      if (? %4: Abrupt) return %4\n      else %4 = %4.Value\n      let P = %4\n      if (= flags undefined) {\n        call %5 = clo<\"Get\">(pattern, \"flags\")\n        assert (? %5: Completion)\n        if (? %5: Abrupt) return %5\n        else %5 = %5.Value\n        let F = %5\n      } else {\n        let F = flags\n      }\n    } else {\n      let P = pattern\n      let F = flags\n    }\n  }\n  call %6 = clo<\"RegExpAlloc\">(newTarget)\n  assert (? %6: Completion)\n  if (? %6: Abrupt) return %6\n  else %6 = %6.Value\n  let O = %6\n  call %7 = clo<\"RegExpInitialize\">(O, P, F)\n  assert (? %7: Completion)\n  return %7\n}","def <BUILTIN>:INTRINSICS.get RegExp[@@species](\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1036]\n  if (? this: Completion) return this\n  call %0 = clo<\"NormalCompletion\">(this)\n  return %0\n}","def <BUILTIN>:INTRINSICS.RegExp.prototype.exec(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1037]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop string < ArgumentsList\n    expand __args__.string\n  } else let string = undefined\n  let R = this\n  call %0 = clo<\"RequireInternalSlot\">(R, \"RegExpMatcher\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"ToString\">(string)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let S = %1\n  call %2 = clo<\"RegExpBuiltinExec\">(R, S)\n  assert (? %2: Completion)\n  return %2\n}","def <BUILTIN>:INTRINSICS.get RegExp.prototype.dotAll(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1038]\n  let R = this\n  let cu = 115cu\n  call %0 = clo<\"RegExpHasFlag\">(R, cu)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.get RegExp.prototype.flags(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1039]\n  let R = this\n  if (! (? R: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  let codeUnits = (list [])[#1040]\n  call %2 = clo<\"Get\">(R, \"hasIndices\")\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  call %3 = clo<\"ToBoolean\">(%2)\n  let hasIndices = %3\n  if (= hasIndices true) {\n    push codeUnits < 100cu\n  }\n  call %4 = clo<\"Get\">(R, \"global\")\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  call %5 = clo<\"ToBoolean\">(%4)\n  let global = %5\n  if (= global true) {\n    push codeUnits < 103cu\n  }\n  call %6 = clo<\"Get\">(R, \"ignoreCase\")\n  assert (? %6: Completion)\n  if (? %6: Abrupt) return %6\n  else %6 = %6.Value\n  call %7 = clo<\"ToBoolean\">(%6)\n  let ignoreCase = %7\n  if (= ignoreCase true) {\n    push codeUnits < 105cu\n  }\n  call %8 = clo<\"Get\">(R, \"multiline\")\n  assert (? %8: Completion)\n  if (? %8: Abrupt) return %8\n  else %8 = %8.Value\n  call %9 = clo<\"ToBoolean\">(%8)\n  let multiline = %9\n  if (= multiline true) {\n    push codeUnits < 109cu\n  }\n  call %10 = clo<\"Get\">(R, \"dotAll\")\n  assert (? %10: Completion)\n  if (? %10: Abrupt) return %10\n  else %10 = %10.Value\n  call %11 = clo<\"ToBoolean\">(%10)\n  let dotAll = %11\n  if (= dotAll true) {\n    push codeUnits < 115cu\n  }\n  call %12 = clo<\"Get\">(R, \"unicode\")\n  assert (? %12: Completion)\n  if (? %12: Abrupt) return %12\n  else %12 = %12.Value\n  call %13 = clo<\"ToBoolean\">(%12)\n  let unicode = %13\n  if (= unicode true) {\n    push codeUnits < 117cu\n  }\n  call %14 = clo<\"Get\">(R, \"unicodeSets\")\n  assert (? %14: Completion)\n  if (? %14: Abrupt) return %14\n  else %14 = %14.Value\n  call %15 = clo<\"ToBoolean\">(%14)\n  let unicodeSets = %15\n  if (= unicodeSets true) {\n    push codeUnits < 118cu\n  }\n  call %16 = clo<\"Get\">(R, \"sticky\")\n  assert (? %16: Completion)\n  if (? %16: Abrupt) return %16\n  else %16 = %16.Value\n  call %17 = clo<\"ToBoolean\">(%16)\n  let sticky = %17\n  if (= sticky true) {\n    push codeUnits < 121cu\n  }\n  (yet \"Return the String value whose code units are the elements of the List _codeUnits_. If _codeUnits_ has no elements, the empty String is returned.\")\n}","def RegExpHasFlag(\n  R: ESValue,\n  codeUnit: Unknown[\"CodeUnit\"],\n): Normal[Boolean | Undefined] | Throw = {\n  if (! (? R: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  if (! (exists R.OriginalFlags)) {\n    call %2 = clo<\"SameValue\">(R, @EXECUTION_STACK[0].Realm.Intrinsics[\"%RegExp.prototype%\"])\n    if (= %2 true) {\n      call %3 = clo<\"NormalCompletion\">(undefined)\n      return %3\n    } else {\n      call %4 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %5 = clo<\"ThrowCompletion\">(%4)\n      return %5\n    }\n  }\n  let flags = R.OriginalFlags\n  if (contains flags codeUnit) {\n    call %6 = clo<\"NormalCompletion\">(true)\n    return %6\n  }\n  call %7 = clo<\"NormalCompletion\">(false)\n  return %7\n}","def <BUILTIN>:INTRINSICS.get RegExp.prototype.global(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1041]\n  let R = this\n  let cu = 103cu\n  call %0 = clo<\"RegExpHasFlag\">(R, cu)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.get RegExp.prototype.hasIndices(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1042]\n  let R = this\n  let cu = 100cu\n  call %0 = clo<\"RegExpHasFlag\">(R, cu)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.get RegExp.prototype.ignoreCase(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1043]\n  let R = this\n  let cu = 105cu\n  call %0 = clo<\"RegExpHasFlag\">(R, cu)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.RegExp.prototype[@@match](\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1044]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop string < ArgumentsList\n    expand __args__.string\n  } else let string = undefined\n  let rx = this\n  if (! (? rx: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"ToString\">(string)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let S = %2\n  call %3 = clo<\"Get\">(rx, \"flags\")\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  call %4 = clo<\"ToString\">(%3)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let flags = %4\n  if (! (contains flags \"g\")) {\n    call %5 = clo<\"RegExpExec\">(rx, S)\n    assert (? %5: Completion)\n    return %5\n  } else {\n    if (|| (contains flags \"u\") (contains flags \"v\")) {\n      let fullUnicode = true\n    } else {\n      let fullUnicode = false\n    }\n    call %6 = clo<\"Set\">(rx, \"lastIndex\", 0.0f, true)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    call %7 = clo<\"ArrayCreate\">(0)\n    assert (? %7: Normal)\n    %7 = %7.Value\n    let A = %7\n    let n = 0\n    while true {\n      call %8 = clo<\"RegExpExec\">(rx, S)\n      assert (? %8: Completion)\n      if (? %8: Abrupt) return %8\n      else %8 = %8.Value\n      let result = %8\n      if (= result null) {\n        if (== n 0) {\n          call %9 = clo<\"NormalCompletion\">(null)\n          return %9\n        }\n        if (? A: Completion) return A\n        call %10 = clo<\"NormalCompletion\">(A)\n        return %10\n      } else {\n        call %11 = clo<\"Get\">(result, \"0\")\n        assert (? %11: Completion)\n        if (? %11: Abrupt) return %11\n        else %11 = %11.Value\n        call %12 = clo<\"ToString\">(%11)\n        assert (? %12: Completion)\n        if (? %12: Abrupt) return %12\n        else %12 = %12.Value\n        let matchStr = %12\n        call %13 = clo<\"ToString\">(([number] n))\n        assert (? %13: Normal)\n        %13 = %13.Value\n        call %14 = clo<\"CreateDataPropertyOrThrow\">(A, %13, matchStr)\n        assert (? %14: Normal)\n        %14 = %14.Value\n        if (= matchStr \"\") {\n          call %15 = clo<\"Get\">(rx, \"lastIndex\")\n          assert (? %15: Completion)\n          if (? %15: Abrupt) return %15\n          else %15 = %15.Value\n          call %16 = clo<\"ToLength\">(%15)\n          assert (? %16: Completion)\n          if (? %16: Abrupt) return %16\n          else %16 = %16.Value\n          let thisIndex = ([math] %16)\n          call %17 = clo<\"AdvanceStringIndex\">(S, thisIndex, fullUnicode)\n          let nextIndex = %17\n          call %18 = clo<\"Set\">(rx, \"lastIndex\", ([number] nextIndex), true)\n          assert (? %18: Completion)\n          if (? %18: Abrupt) return %18\n          else %18 = %18.Value\n        }\n        n = (+ n 1)\n      }\n    }\n  }\n}","def <BUILTIN>:INTRINSICS.RegExp.prototype[@@matchAll](\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1045]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop string < ArgumentsList\n    expand __args__.string\n  } else let string = undefined\n  let R = this\n  if (! (? R: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"ToString\">(string)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let S = %2\n  call %3 = clo<\"SpeciesConstructor\">(R, @EXECUTION_STACK[0].Realm.Intrinsics[\"%RegExp%\"])\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let C = %3\n  call %4 = clo<\"Get\">(R, \"flags\")\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  call %5 = clo<\"ToString\">(%4)\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  let flags = %5\n  call %6 = clo<\"Construct\">(C, (list [R, flags])[#1046])\n  assert (? %6: Completion)\n  if (? %6: Abrupt) return %6\n  else %6 = %6.Value\n  let matcher = %6\n  call %7 = clo<\"Get\">(R, \"lastIndex\")\n  assert (? %7: Completion)\n  if (? %7: Abrupt) return %7\n  else %7 = %7.Value\n  call %8 = clo<\"ToLength\">(%7)\n  assert (? %8: Completion)\n  if (? %8: Abrupt) return %8\n  else %8 = %8.Value\n  let lastIndex = %8\n  call %9 = clo<\"Set\">(matcher, \"lastIndex\", lastIndex, true)\n  assert (? %9: Completion)\n  if (? %9: Abrupt) return %9\n  else %9 = %9.Value\n  if (contains flags \"g\") {\n    let global = true\n  } else {\n    let global = false\n  }\n  if (|| (contains flags \"u\") (contains flags \"v\")) {\n    let fullUnicode = true\n  } else {\n    let fullUnicode = false\n  }\n  call %10 = clo<\"CreateRegExpStringIterator\">(matcher, S, global, fullUnicode)\n  if (? %10: Completion) return %10\n  call %11 = clo<\"NormalCompletion\">(%10)\n  return %11\n}","def <BUILTIN>:INTRINSICS.get RegExp.prototype.multiline(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1047]\n  let R = this\n  let cu = 109cu\n  call %0 = clo<\"RegExpHasFlag\">(R, cu)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.RegExp.prototype[@@replace](\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1048]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop string < ArgumentsList\n    expand __args__.string\n  } else let string = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop replaceValue < ArgumentsList\n    expand __args__.replaceValue\n  } else let replaceValue = undefined\n  let rx = this\n  if (! (? rx: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"ToString\">(string)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let S = %2\n  let lengthS = (sizeof S)\n  call %3 = clo<\"IsCallable\">(replaceValue)\n  let functionalReplace = %3\n  if (= functionalReplace false) {\n    call %4 = clo<\"ToString\">(replaceValue)\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    replaceValue = %4\n  }\n  call %5 = clo<\"Get\">(rx, \"flags\")\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  call %6 = clo<\"ToString\">(%5)\n  assert (? %6: Completion)\n  if (? %6: Abrupt) return %6\n  else %6 = %6.Value\n  let flags = %6\n  if (contains flags \"g\") {\n    let global = true\n  } else {\n    let global = false\n  }\n  if (= global true) {\n    call %7 = clo<\"Set\">(rx, \"lastIndex\", 0.0f, true)\n    assert (? %7: Completion)\n    if (? %7: Abrupt) return %7\n    else %7 = %7.Value\n  }\n  let results = (list [])[#1049]\n  let done = false\n  while (= done false) {\n    call %8 = clo<\"RegExpExec\">(rx, S)\n    assert (? %8: Completion)\n    if (? %8: Abrupt) return %8\n    else %8 = %8.Value\n    let result = %8\n    if (= result null) {\n      done = true\n    } else {\n      push results < result\n      if (= global false) {\n        done = true\n      } else {\n        call %9 = clo<\"Get\">(result, \"0\")\n        assert (? %9: Completion)\n        if (? %9: Abrupt) return %9\n        else %9 = %9.Value\n        call %10 = clo<\"ToString\">(%9)\n        assert (? %10: Completion)\n        if (? %10: Abrupt) return %10\n        else %10 = %10.Value\n        let matchStr = %10\n        if (= matchStr \"\") {\n          call %11 = clo<\"Get\">(rx, \"lastIndex\")\n          assert (? %11: Completion)\n          if (? %11: Abrupt) return %11\n          else %11 = %11.Value\n          call %12 = clo<\"ToLength\">(%11)\n          assert (? %12: Completion)\n          if (? %12: Abrupt) return %12\n          else %12 = %12.Value\n          let thisIndex = ([math] %12)\n          if (|| (contains flags \"u\") (contains flags \"v\")) {\n            let fullUnicode = true\n          } else {\n            let fullUnicode = false\n          }\n          call %13 = clo<\"AdvanceStringIndex\">(S, thisIndex, fullUnicode)\n          let nextIndex = %13\n          call %14 = clo<\"Set\">(rx, \"lastIndex\", ([number] nextIndex), true)\n          assert (? %14: Completion)\n          if (? %14: Abrupt) return %14\n          else %14 = %14.Value\n        }\n      }\n    }\n  }\n  let accumulatedResult = \"\"\n  let nextSourcePosition = 0\n  %16 = results\n  %15 = 0\n  while (< %15 (sizeof %16)) {\n    let result = %16[%15]\n    call %17 = clo<\"LengthOfArrayLike\">(result)\n    assert (? %17: Completion)\n    if (? %17: Abrupt) return %17\n    else %17 = %17.Value\n    let resultLength = %17\n    let nCaptures = (max (- resultLength 1) 0)\n    call %18 = clo<\"Get\">(result, \"0\")\n    assert (? %18: Completion)\n    if (? %18: Abrupt) return %18\n    else %18 = %18.Value\n    call %19 = clo<\"ToString\">(%18)\n    assert (? %19: Completion)\n    if (? %19: Abrupt) return %19\n    else %19 = %19.Value\n    let matched = %19\n    let matchLength = (sizeof matched)\n    call %20 = clo<\"Get\">(result, \"index\")\n    assert (? %20: Completion)\n    if (? %20: Abrupt) return %20\n    else %20 = %20.Value\n    call %21 = clo<\"ToIntegerOrInfinity\">(%20)\n    assert (? %21: Completion)\n    if (? %21: Abrupt) return %21\n    else %21 = %21.Value\n    let position = %21\n    call %22 = clo<\"__CLAMP__\">(position, 0, lengthS)\n    position = %22\n    let captures = (list [])[#1050]\n    let n = 1\n    while (! (< nCaptures n)) {\n      call %23 = clo<\"ToString\">(([number] n))\n      assert (? %23: Normal)\n      %23 = %23.Value\n      call %24 = clo<\"Get\">(result, %23)\n      assert (? %24: Completion)\n      if (? %24: Abrupt) return %24\n      else %24 = %24.Value\n      let capN = %24\n      if (! (= capN undefined)) {\n        call %25 = clo<\"ToString\">(capN)\n        assert (? %25: Completion)\n        if (? %25: Abrupt) return %25\n        else %25 = %25.Value\n        capN = %25\n      }\n      push captures < capN\n      nop\n      n = (+ n 1)\n    }\n    call %26 = clo<\"Get\">(result, \"groups\")\n    assert (? %26: Completion)\n    if (? %26: Abrupt) return %26\n    else %26 = %26.Value\n    let namedCaptures = %26\n    if (= functionalReplace true) {\n      call %27 = clo<\"__FLAT_LIST__\">((list [(list [matched])[#1052], captures, (list [([number] position), S])[#1053]])[#1051])\n      let replacerArgs = %27\n      if (! (= namedCaptures undefined)) {\n        push replacerArgs < namedCaptures\n      }\n      call %28 = clo<\"Call\">(replaceValue, undefined, replacerArgs)\n      assert (? %28: Completion)\n      if (? %28: Abrupt) return %28\n      else %28 = %28.Value\n      let replValue = %28\n      call %29 = clo<\"ToString\">(replValue)\n      assert (? %29: Completion)\n      if (? %29: Abrupt) return %29\n      else %29 = %29.Value\n      let replacement = %29\n    } else {\n      if (! (= namedCaptures undefined)) {\n        call %30 = clo<\"ToObject\">(namedCaptures)\n        assert (? %30: Completion)\n        if (? %30: Abrupt) return %30\n        else %30 = %30.Value\n        namedCaptures = %30\n      }\n      call %31 = clo<\"GetSubstitution\">(matched, S, position, captures, namedCaptures, replaceValue)\n      assert (? %31: Completion)\n      if (? %31: Abrupt) return %31\n      else %31 = %31.Value\n      let replacement = %31\n    }\n    if (! (< position nextSourcePosition)) {\n      nop\n      accumulatedResult = (concat accumulatedResult (substring S nextSourcePosition position) replacement)\n      nextSourcePosition = (+ position matchLength)\n    }\n    %15 = (+ %15 1)\n  }\n  if (! (< nextSourcePosition lengthS)) {\n    if (? accumulatedResult: Completion) return accumulatedResult\n    call %32 = clo<\"NormalCompletion\">(accumulatedResult)\n    return %32\n  }\n  %33 = (concat accumulatedResult (substring S nextSourcePosition))\n  if (? %33: Completion) return %33\n  call %34 = clo<\"NormalCompletion\">(%33)\n  return %34\n}","def <BUILTIN>:INTRINSICS.RegExp.prototype[@@search](\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1054]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop string < ArgumentsList\n    expand __args__.string\n  } else let string = undefined\n  let rx = this\n  if (! (? rx: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"ToString\">(string)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let S = %2\n  call %3 = clo<\"Get\">(rx, \"lastIndex\")\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let previousLastIndex = %3\n  call %4 = clo<\"SameValue\">(previousLastIndex, 0.0f)\n  if (= %4 false) {\n    call %5 = clo<\"Set\">(rx, \"lastIndex\", 0.0f, true)\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n  }\n  call %6 = clo<\"RegExpExec\">(rx, S)\n  assert (? %6: Completion)\n  if (? %6: Abrupt) return %6\n  else %6 = %6.Value\n  let result = %6\n  call %7 = clo<\"Get\">(rx, \"lastIndex\")\n  assert (? %7: Completion)\n  if (? %7: Abrupt) return %7\n  else %7 = %7.Value\n  let currentLastIndex = %7\n  call %8 = clo<\"SameValue\">(currentLastIndex, previousLastIndex)\n  if (= %8 false) {\n    call %9 = clo<\"Set\">(rx, \"lastIndex\", previousLastIndex, true)\n    assert (? %9: Completion)\n    if (? %9: Abrupt) return %9\n    else %9 = %9.Value\n  }\n  if (= result null) {\n    call %10 = clo<\"NormalCompletion\">(-1.0f)\n    return %10\n  }\n  call %11 = clo<\"Get\">(result, \"index\")\n  assert (? %11: Completion)\n  return %11\n}","def <BUILTIN>:INTRINSICS.get RegExp.prototype.source(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1055]\n  let R = this\n  if (! (? R: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  if (! (exists R.OriginalSource)) {\n    call %2 = clo<\"SameValue\">(R, @EXECUTION_STACK[0].Realm.Intrinsics[\"%RegExp.prototype%\"])\n    if (= %2 true) {\n      call %3 = clo<\"NormalCompletion\">(\"(?:)\")\n      return %3\n    } else {\n      call %4 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %5 = clo<\"ThrowCompletion\">(%4)\n      return %5\n    }\n  }\n  assert (exists R.OriginalFlags)\n  let src = R.OriginalSource\n  let flags = R.OriginalFlags\n  call %6 = clo<\"EscapeRegExpPattern\">(src, flags)\n  if (? %6: Completion) return %6\n  call %7 = clo<\"NormalCompletion\">(%6)\n  return %7\n}","def EscapeRegExpPattern(\n  P: String,\n  F: String,\n): String = {\n  if (contains F \"v\") {\n    (yet \"Let _patternSymbol_ be |Pattern[+UnicodeMode, +UnicodeSetsMode]|.\")\n  } else {\n    if (contains F \"u\") {\n      (yet \"Let _patternSymbol_ be |Pattern[+UnicodeMode, ~UnicodeSetsMode]|.\")\n    } else {\n      (yet \"Let _patternSymbol_ be |Pattern[~UnicodeMode, ~UnicodeSetsMode]|.\")\n    }\n  }\n  (yet \"Let _S_ be a String in the form of a _patternSymbol_ equivalent to _P_ interpreted as UTF-16 encoded Unicode code points (<emu-xref href=\\\"#sec-ecmascript-language-types-string-type\\\"></emu-xref>), in which certain code points are escaped as described below. _S_ may or may not differ from _P_; however, the Abstract Closure that would result from evaluating _S_ as a _patternSymbol_ must behave identically to the Abstract Closure given by the constructed object's [[RegExpMatcher]] internal slot. Multiple calls to this abstract operation using the same values for _P_ and _F_ must produce identical results.\")\n  (yet \"The code points `/` or any |LineTerminator| occurring in the pattern shall be escaped in _S_ as necessary to ensure that the string-concatenation of *\\\"/\\\"*, _S_, *\\\"/\\\"*, and _F_ can be parsed (in an appropriate lexical context) as a |RegularExpressionLiteral| that behaves identically to the constructed regular expression. For example, if _P_ is *\\\"/\\\"*, then _S_ could be *\\\"\\\\\\\\/\\\"* or *\\\"\\\\\\\\u002F\\\"*, among other possibilities, but not *\\\"/\\\"*, because `///` followed by _F_ would be parsed as a |SingleLineComment| rather than a |RegularExpressionLiteral|. If _P_ is the empty String, this specification can be met by letting _S_ be *\\\"(?:)\\\"*.\")\n  return S\n}","def <BUILTIN>:INTRINSICS.RegExp.prototype[@@split](\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1056]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop string < ArgumentsList\n    expand __args__.string\n  } else let string = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop limit < ArgumentsList\n    expand __args__.limit\n  } else let limit = undefined\n  let rx = this\n  if (! (? rx: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"ToString\">(string)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let S = %2\n  call %3 = clo<\"SpeciesConstructor\">(rx, @EXECUTION_STACK[0].Realm.Intrinsics[\"%RegExp%\"])\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let C = %3\n  call %4 = clo<\"Get\">(rx, \"flags\")\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  call %5 = clo<\"ToString\">(%4)\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  let flags = %5\n  if (|| (contains flags \"u\") (contains flags \"v\")) {\n    let unicodeMatching = true\n  } else {\n    let unicodeMatching = false\n  }\n  if (contains flags \"y\") {\n    let newFlags = flags\n  } else {\n    let newFlags = (concat flags \"y\")\n  }\n  call %6 = clo<\"Construct\">(C, (list [rx, newFlags])[#1057])\n  assert (? %6: Completion)\n  if (? %6: Abrupt) return %6\n  else %6 = %6.Value\n  let splitter = %6\n  call %7 = clo<\"ArrayCreate\">(0)\n  assert (? %7: Normal)\n  %7 = %7.Value\n  let A = %7\n  let lengthA = 0\n  if (= limit undefined) {\n    let lim = (- (** 2 32) 1)\n  } else {\n    call %8 = clo<\"ToUint32\">(limit)\n    assert (? %8: Completion)\n    if (? %8: Abrupt) return %8\n    else %8 = %8.Value\n    let lim = ([math] %8)\n  }\n  if (== lim 0) {\n    if (? A: Completion) return A\n    call %9 = clo<\"NormalCompletion\">(A)\n    return %9\n  }\n  if (= S \"\") {\n    call %10 = clo<\"RegExpExec\">(splitter, S)\n    assert (? %10: Completion)\n    if (? %10: Abrupt) return %10\n    else %10 = %10.Value\n    let z = %10\n    if (! (= z null)) {\n      if (? A: Completion) return A\n      call %11 = clo<\"NormalCompletion\">(A)\n      return %11\n    }\n    call %12 = clo<\"CreateDataPropertyOrThrow\">(A, \"0\", S)\n    assert (? %12: Normal)\n    %12 = %12.Value\n    if (? A: Completion) return A\n    call %13 = clo<\"NormalCompletion\">(A)\n    return %13\n  }\n  let size = (sizeof S)\n  let p = 0\n  let q = p\n  while (< q size) {\n    call %14 = clo<\"Set\">(splitter, \"lastIndex\", ([number] q), true)\n    assert (? %14: Completion)\n    if (? %14: Abrupt) return %14\n    else %14 = %14.Value\n    call %15 = clo<\"RegExpExec\">(splitter, S)\n    assert (? %15: Completion)\n    if (? %15: Abrupt) return %15\n    else %15 = %15.Value\n    let z = %15\n    if (= z null) {\n      call %16 = clo<\"AdvanceStringIndex\">(S, q, unicodeMatching)\n      q = %16\n    } else {\n      call %17 = clo<\"Get\">(splitter, \"lastIndex\")\n      assert (? %17: Completion)\n      if (? %17: Abrupt) return %17\n      else %17 = %17.Value\n      call %18 = clo<\"ToLength\">(%17)\n      assert (? %18: Completion)\n      if (? %18: Abrupt) return %18\n      else %18 = %18.Value\n      let e = ([math] %18)\n      e = (min e size)\n      if (== e p) {\n        call %19 = clo<\"AdvanceStringIndex\">(S, q, unicodeMatching)\n        q = %19\n      } else {\n        let T = (substring S p q)\n        call %20 = clo<\"ToString\">(([number] lengthA))\n        assert (? %20: Normal)\n        %20 = %20.Value\n        call %21 = clo<\"CreateDataPropertyOrThrow\">(A, %20, T)\n        assert (? %21: Normal)\n        %21 = %21.Value\n        lengthA = (+ lengthA 1)\n        if (== lengthA lim) {\n          if (? A: Completion) return A\n          call %22 = clo<\"NormalCompletion\">(A)\n          return %22\n        }\n        p = e\n        call %23 = clo<\"LengthOfArrayLike\">(z)\n        assert (? %23: Completion)\n        if (? %23: Abrupt) return %23\n        else %23 = %23.Value\n        let numberOfCaptures = %23\n        numberOfCaptures = (max (- numberOfCaptures 1) 0)\n        let i = 1\n        while (! (< numberOfCaptures i)) {\n          call %24 = clo<\"ToString\">(([number] i))\n          assert (? %24: Normal)\n          %24 = %24.Value\n          call %25 = clo<\"Get\">(z, %24)\n          assert (? %25: Completion)\n          if (? %25: Abrupt) return %25\n          else %25 = %25.Value\n          let nextCapture = %25\n          call %26 = clo<\"ToString\">(([number] lengthA))\n          assert (? %26: Normal)\n          %26 = %26.Value\n          call %27 = clo<\"CreateDataPropertyOrThrow\">(A, %26, nextCapture)\n          assert (? %27: Normal)\n          %27 = %27.Value\n          i = (+ i 1)\n          lengthA = (+ lengthA 1)\n          if (== lengthA lim) {\n            if (? A: Completion) return A\n            call %28 = clo<\"NormalCompletion\">(A)\n            return %28\n          }\n        }\n        q = p\n      }\n    }\n  }\n  let T = (substring S p size)\n  call %29 = clo<\"ToString\">(([number] lengthA))\n  assert (? %29: Normal)\n  %29 = %29.Value\n  call %30 = clo<\"CreateDataPropertyOrThrow\">(A, %29, T)\n  assert (? %30: Normal)\n  %30 = %30.Value\n  if (? A: Completion) return A\n  call %31 = clo<\"NormalCompletion\">(A)\n  return %31\n}","def <BUILTIN>:INTRINSICS.get RegExp.prototype.sticky(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1058]\n  let R = this\n  let cu = 121cu\n  call %0 = clo<\"RegExpHasFlag\">(R, cu)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.RegExp.prototype.test(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1059]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop S < ArgumentsList\n    expand __args__.S\n  } else let S = undefined\n  let R = this\n  if (! (? R: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"ToString\">(S)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let string = %2\n  call %3 = clo<\"RegExpExec\">(R, string)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let match = %3\n  if (! (= match null)) {\n    call %4 = clo<\"NormalCompletion\">(true)\n    return %4\n  } else {\n    call %5 = clo<\"NormalCompletion\">(false)\n    return %5\n  }\n}","def <BUILTIN>:INTRINSICS.RegExp.prototype.toString(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1060]\n  let R = this\n  if (! (? R: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"Get\">(R, \"source\")\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  call %3 = clo<\"ToString\">(%2)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let pattern = %3\n  call %4 = clo<\"Get\">(R, \"flags\")\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  call %5 = clo<\"ToString\">(%4)\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  let flags = %5\n  let result = (concat \"/\" pattern \"/\" flags)\n  if (? result: Completion) return result\n  call %6 = clo<\"NormalCompletion\">(result)\n  return %6\n}","def <BUILTIN>:INTRINSICS.get RegExp.prototype.unicode(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1061]\n  let R = this\n  let cu = 117cu\n  call %0 = clo<\"RegExpHasFlag\">(R, cu)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.get RegExp.prototype.unicodeSets(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1062]\n  let R = this\n  let cu = 118cu\n  call %0 = clo<\"RegExpHasFlag\">(R, cu)\n  assert (? %0: Completion)\n  return %0\n}","def RegExpExec(\n  R: Record[Object],\n  S: String,\n): Normal[Record[Object] | Null] | Throw = {\n  call %0 = clo<\"Get\">(R, \"exec\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let exec = %0\n  call %1 = clo<\"IsCallable\">(exec)\n  if (= %1 true) {\n    call %2 = clo<\"Call\">(exec, R, (list [S])[#1063])\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let result = %2\n    if (&& (! (? result: Record[Object])) (! (= result null))) {\n      call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %4 = clo<\"ThrowCompletion\">(%3)\n      return %4\n    }\n    if (? result: Completion) return result\n    call %5 = clo<\"NormalCompletion\">(result)\n    return %5\n  }\n  call %6 = clo<\"RequireInternalSlot\">(R, \"RegExpMatcher\")\n  assert (? %6: Completion)\n  if (? %6: Abrupt) return %6\n  else %6 = %6.Value\n  call %7 = clo<\"RegExpBuiltinExec\">(R, S)\n  assert (? %7: Completion)\n  return %7\n}","def RegExpBuiltinExec(\n  R: Record[RegExp],\n  S: String,\n): Normal[Record[Array] | Null] | Throw = {\n  let length = (sizeof S)\n  call %0 = clo<\"Get\">(R, \"lastIndex\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"ToLength\">(%0)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let lastIndex = ([math] %1)\n  let flags = R.OriginalFlags\n  if (contains flags \"g\") {\n    let global = true\n  } else {\n    let global = false\n  }\n  if (contains flags \"y\") {\n    let sticky = true\n  } else {\n    let sticky = false\n  }\n  if (contains flags \"d\") {\n    let hasIndices = true\n  } else {\n    let hasIndices = false\n  }\n  if (&& (= global false) (= sticky false)) {\n    lastIndex = 0\n  }\n  let matcher = R.RegExpMatcher\n  if (|| (contains flags \"u\") (contains flags \"v\")) {\n    let fullUnicode = true\n  } else {\n    let fullUnicode = false\n  }\n  let matchSucceeded = false\n  if (= fullUnicode true) {\n    call %2 = clo<\"StringToCodePoints\">(S)\n    let input = %2\n  } else {\n    (yet \"let _input_ be a List whose elements are the code units that are the elements of _S_.\")\n  }\n  nop\n  while (= matchSucceeded false) {\n    if (< length lastIndex) {\n      if (|| (= global true) (= sticky true)) {\n        call %3 = clo<\"Set\">(R, \"lastIndex\", 0.0f, true)\n        assert (? %3: Completion)\n        if (? %3: Abrupt) return %3\n        else %3 = %3.Value\n      }\n      call %4 = clo<\"NormalCompletion\">(null)\n      return %4\n    }\n    (yet \"Let _inputIndex_ be the index into _input_ of the character that was obtained from element _lastIndex_ of _S_.\")\n    call %5 = matcher(input, inputIndex)\n    let r = %5\n    if (= r ~failure~) {\n      if (= sticky true) {\n        call %6 = clo<\"Set\">(R, \"lastIndex\", 0.0f, true)\n        assert (? %6: Completion)\n        if (? %6: Abrupt) return %6\n        else %6 = %6.Value\n        call %7 = clo<\"NormalCompletion\">(null)\n        return %7\n      }\n      call %8 = clo<\"AdvanceStringIndex\">(S, lastIndex, fullUnicode)\n      lastIndex = %8\n    } else {\n      assert (? r: Record[MatchState])\n      matchSucceeded = true\n    }\n  }\n  let e = r.EndIndex\n  if (= fullUnicode true) {\n    call %9 = clo<\"GetStringIndex\">(S, e)\n    e = %9\n  }\n  if (|| (= global true) (= sticky true)) {\n    call %10 = clo<\"Set\">(R, \"lastIndex\", ([number] e), true)\n    assert (? %10: Completion)\n    if (? %10: Abrupt) return %10\n    else %10 = %10.Value\n  }\n  let n = (sizeof r.Captures)\n  assert (== n R.RegExpRecord.CapturingGroupsCount)\n  assert (< n (- (** 2 32) 1))\n  call %11 = clo<\"ArrayCreate\">((+ n 1))\n  assert (? %11: Normal)\n  %11 = %11.Value\n  let A = %11\n  assert (yet \"The mathematical value of _A_'s *\\\"length\\\"* property is _n_ + 1.\")\n  call %12 = clo<\"CreateDataPropertyOrThrow\">(A, \"index\", ([number] lastIndex))\n  assert (? %12: Normal)\n  %12 = %12.Value\n  call %13 = clo<\"CreateDataPropertyOrThrow\">(A, \"input\", S)\n  assert (? %13: Normal)\n  %13 = %13.Value\n  let match = (record [MatchRecord] {\n    \"StartIndex\" : lastIndex,\n    \"EndIndex\" : e,\n  })[#1064]\n  let indices = (list [])[#1065]\n  let groupNames = (list [])[#1066]\n  push indices < match\n  call %14 = clo<\"GetMatchString\">(S, match)\n  let matchedSubstr = %14\n  call %15 = clo<\"CreateDataPropertyOrThrow\">(A, \"0\", matchedSubstr)\n  assert (? %15: Normal)\n  %15 = %15.Value\n  (yet \"If _R_ contains any |GroupName|, then\\n  1. Let _groups_ be OrdinaryObjectCreate(*null*).\\n  1. Let _hasGroups_ be *true*.\")\n  (yet \"Else,\\n  1. Let _groups_ be *undefined*.\\n  1. Let _hasGroups_ be *false*.\")\n  call %16 = clo<\"CreateDataPropertyOrThrow\">(A, \"groups\", groups)\n  assert (? %16: Normal)\n  %16 = %16.Value\n  let i = 1\n  while (! (< n i)) {\n    (yet \"Let _captureI_ be _i_<sup>th</sup> element of _r_.[[Captures]].\")\n    if (= captureI undefined) {\n      let capturedValue = undefined\n      push indices < undefined\n    } else {\n      let captureStart = captureI.StartIndex\n      let captureEnd = captureI.EndIndex\n      if (= fullUnicode true) {\n        call %17 = clo<\"GetStringIndex\">(S, captureStart)\n        captureStart = %17\n        call %18 = clo<\"GetStringIndex\">(S, captureEnd)\n        captureEnd = %18\n      }\n      let capture = (record [MatchRecord] {\n        \"StartIndex\" : captureStart,\n        \"EndIndex\" : captureEnd,\n      })[#1067]\n      call %19 = clo<\"GetMatchString\">(S, capture)\n      let capturedValue = %19\n      push indices < capture\n    }\n    call %20 = clo<\"ToString\">(([number] i))\n    assert (? %20: Normal)\n    %20 = %20.Value\n    call %21 = clo<\"CreateDataPropertyOrThrow\">(A, %20, capturedValue)\n    assert (? %21: Normal)\n    %21 = %21.Value\n    (yet \"If the _i_<sup>th</sup> capture of _R_ was defined with a |GroupName|, then\\n  1. Let _s_ be the CapturingGroupName of that |GroupName|.\\n  1. Perform ! CreateDataPropertyOrThrow(_groups_, _s_, _capturedValue_).\\n  1. Append _s_ to _groupNames_.\")\n    (yet \"Else,\\n  1. Append *undefined* to _groupNames_.\")\n    i = (+ i 1)\n  }\n  if (= hasIndices true) {\n    call %22 = clo<\"MakeMatchIndicesIndexPairArray\">(S, indices, groupNames, hasGroups)\n    let indicesArray = %22\n    call %23 = clo<\"CreateDataPropertyOrThrow\">(A, \"indices\", indicesArray)\n    assert (? %23: Normal)\n    %23 = %23.Value\n  }\n  if (? A: Completion) return A\n  call %24 = clo<\"NormalCompletion\">(A)\n  return %24\n}","def AdvanceStringIndex(\n  S: String,\n  index: NonNegInt,\n  unicode: Boolean,\n): Int = {\n  assert (! (< (- (** 2 53) 1) index))\n  if (= unicode false) {\n    return (+ index 1)\n  }\n  let length = (sizeof S)\n  if (! (< (+ index 1) length)) {\n    return (+ index 1)\n  }\n  call %0 = clo<\"CodePointAt\">(S, index)\n  let cp = %0\n  return (+ index cp.CodeUnitCount)\n}","def GetStringIndex(\n  S: String,\n  codePointIndex: NonNegInt,\n): NonNegInt = {\n  if (= S \"\") {\n    return 0\n  }\n  let len = (sizeof S)\n  let codeUnitCount = 0\n  let codePointCount = 0\n  while (< codeUnitCount len) {\n    if (== codePointCount codePointIndex) {\n      return codeUnitCount\n    }\n    call %0 = clo<\"CodePointAt\">(S, codeUnitCount)\n    let cp = %0\n    codeUnitCount = (+ codeUnitCount cp.CodeUnitCount)\n    codePointCount = (+ codePointCount 1)\n  }\n  return len\n}","def GetMatchString(\n  S: String,\n  match: Record[MatchRecord],\n): String = {\n  assert (yet \"_match_.[[StartIndex]] ‚â§ _match_.[[EndIndex]] ‚â§ the length of _S_.\")\n  return (substring S match.StartIndex match.EndIndex)\n}","def GetMatchIndexPair(\n  S: String,\n  match: Record[MatchRecord],\n): Record[Array] = {\n  assert (yet \"_match_.[[StartIndex]] ‚â§ _match_.[[EndIndex]] ‚â§ the length of _S_.\")\n  call %0 = clo<\"CreateArrayFromList\">((list [([number] match.StartIndex), ([number] match.EndIndex)])[#1068])\n  return %0\n}","def MakeMatchIndicesIndexPairArray(\n  S: String,\n  indices: List[Record[MatchRecord] | Undefined],\n  groupNames: List[String | Undefined],\n  hasGroups: Boolean,\n): Record[Array] = {\n  let n = (sizeof indices)\n  assert (< n (- (** 2 32) 1))\n  assert (yet \"_groupNames_ has _n_ - 1 elements.\")\n  nop\n  call %0 = clo<\"ArrayCreate\">(n)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let A = %0\n  if (= hasGroups true) {\n    call %1 = clo<\"OrdinaryObjectCreate\">(null)\n    let groups = %1\n  } else {\n    let groups = undefined\n  }\n  call %2 = clo<\"CreateDataPropertyOrThrow\">(A, \"groups\", groups)\n  assert (? %2: Normal)\n  %2 = %2.Value\n  let i = 0\n  while (! (< (- n 1) i)) {\n    let matchIndices = indices[i]\n    if (! (= matchIndices undefined)) {\n      call %3 = clo<\"GetMatchIndexPair\">(S, matchIndices)\n      let matchIndexPair = %3\n    } else {\n      let matchIndexPair = undefined\n    }\n    call %4 = clo<\"ToString\">(([number] i))\n    assert (? %4: Normal)\n    %4 = %4.Value\n    call %5 = clo<\"CreateDataPropertyOrThrow\">(A, %4, matchIndexPair)\n    assert (? %5: Normal)\n    %5 = %5.Value\n    if (&& (< 0 i) (! (= groupNames[(- i 1)] undefined))) {\n      assert (! (= groups undefined))\n      call %6 = clo<\"CreateDataPropertyOrThrow\">(groups, groupNames[(- i 1)], matchIndexPair)\n      assert (? %6: Normal)\n      %6 = %6.Value\n    }\n    i = (+ i 1)\n  }\n  return A\n}","def <CLO>:CreateRegExpStringIterator:clo0(\n): Unknown = {\n  while true {\n    call %0 = clo<\"RegExpExec\">(R, S)\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let match = %0\n    if (= match null) {\n      call %1 = clo<\"NormalCompletion\">(undefined)\n      return %1\n    }\n    if (= global false) {\n      call %2 = clo<\"CreateIterResultObject\">(match, false)\n      call %3 = clo<\"GeneratorYield\">(%2)\n      assert (? %3: Completion)\n      if (? %3: Abrupt) return %3\n      else %3 = %3.Value\n      call %4 = clo<\"NormalCompletion\">(undefined)\n      return %4\n    }\n    call %5 = clo<\"Get\">(match, \"0\")\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n    call %6 = clo<\"ToString\">(%5)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    let matchStr = %6\n    if (= matchStr \"\") {\n      call %7 = clo<\"Get\">(R, \"lastIndex\")\n      assert (? %7: Completion)\n      if (? %7: Abrupt) return %7\n      else %7 = %7.Value\n      call %8 = clo<\"ToLength\">(%7)\n      assert (? %8: Completion)\n      if (? %8: Abrupt) return %8\n      else %8 = %8.Value\n      let thisIndex = ([math] %8)\n      call %9 = clo<\"AdvanceStringIndex\">(S, thisIndex, fullUnicode)\n      let nextIndex = %9\n      call %10 = clo<\"Set\">(R, \"lastIndex\", ([number] nextIndex), true)\n      assert (? %10: Completion)\n      if (? %10: Abrupt) return %10\n      else %10 = %10.Value\n    }\n    call %11 = clo<\"CreateIterResultObject\">(match, false)\n    call %12 = clo<\"GeneratorYield\">(%11)\n    assert (? %12: Completion)\n    if (? %12: Abrupt) return %12\n    else %12 = %12.Value\n  }\n}","def CreateRegExpStringIterator(\n  R: Record[Object],\n  S: String,\n  global: Boolean,\n  fullUnicode: Boolean,\n): Record[Generator] = {\n  let closure = clo<\"CreateRegExpStringIterator:clo0\", [R, S, global, fullUnicode]>\n  call %0 = clo<\"CreateIteratorFromClosure\">(closure, \"%RegExpStringIteratorPrototype%\", @EXECUTION_STACK[0].Realm.Intrinsics[\"%RegExpStringIteratorPrototype%\"])\n  return %0\n}","def <BUILTIN>:INTRINSICS.RegExpStringIteratorPrototype.next(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1069]\n  call %0 = clo<\"GeneratorResume\">(this, ~empty~, \"%RegExpStringIteratorPrototype%\")\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.Array(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1070]\n  let values = ArgumentsList\n  if (= NewTarget undefined) {\n    let newTarget = @EXECUTION_STACK[0].Function\n  } else {\n    let newTarget = NewTarget\n  }\n  call %0 = clo<\"GetPrototypeFromConstructor\">(newTarget, \"%Array.prototype%\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let proto = %0\n  let numberOfArgs = (sizeof values)\n  if (== numberOfArgs 0) {\n    call %1 = clo<\"ArrayCreate\">(0, proto)\n    assert (? %1: Normal)\n    return %1\n  } else {\n    if (== numberOfArgs 1) {\n      let len = values[0]\n      call %2 = clo<\"ArrayCreate\">(0, proto)\n      assert (? %2: Normal)\n      %2 = %2.Value\n      let array = %2\n      if (! (? len: Number)) {\n        call %3 = clo<\"CreateDataPropertyOrThrow\">(array, \"0\", len)\n        assert (? %3: Normal)\n        %3 = %3.Value\n        let intLen = 1.0f\n      } else {\n        call %4 = clo<\"ToUint32\">(len)\n        assert (? %4: Normal)\n        %4 = %4.Value\n        let intLen = %4\n        call %5 = clo<\"SameValueZero\">(intLen, len)\n        if (= %5 false) {\n          call %6 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n          call %7 = clo<\"ThrowCompletion\">(%6)\n          return %7\n        }\n      }\n      call %8 = clo<\"Set\">(array, \"length\", intLen, true)\n      assert (? %8: Normal)\n      %8 = %8.Value\n      if (? array: Completion) return array\n      call %9 = clo<\"NormalCompletion\">(array)\n      return %9\n    } else {\n      assert (! (< numberOfArgs 2))\n      call %10 = clo<\"ArrayCreate\">(numberOfArgs, proto)\n      assert (? %10: Completion)\n      if (? %10: Abrupt) return %10\n      else %10 = %10.Value\n      let array = %10\n      let k = 0\n      while (< k numberOfArgs) {\n        call %11 = clo<\"ToString\">(([number] k))\n        assert (? %11: Normal)\n        %11 = %11.Value\n        let Pk = %11\n        let itemK = values[k]\n        call %12 = clo<\"CreateDataPropertyOrThrow\">(array, Pk, itemK)\n        assert (? %12: Normal)\n        %12 = %12.Value\n        k = (+ k 1)\n      }\n      assert (yet \"The mathematical value of _array_'s *\\\"length\\\"* property is _numberOfArgs_.\")\n      if (? array: Completion) return array\n      call %13 = clo<\"NormalCompletion\">(array)\n      return %13\n    }\n  }\n}","def <BUILTIN>:INTRINSICS.Array.from(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1071]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop items < ArgumentsList\n    expand __args__.items\n  } else let items = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop mapfn < ArgumentsList\n    expand __args__.mapfn\n  } else let mapfn = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop thisArg < ArgumentsList\n    expand __args__.thisArg\n  } else let thisArg = undefined\n  let C = this\n  if (= mapfn undefined) {\n    let mapping = false\n  } else {\n    call %0 = clo<\"IsCallable\">(mapfn)\n    if (= %0 false) {\n      call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %2 = clo<\"ThrowCompletion\">(%1)\n      return %2\n    }\n    let mapping = true\n  }\n  call %3 = clo<\"GetMethod\">(items, @SYMBOL.iterator)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let usingIterator = %3\n  if (! (= usingIterator undefined)) {\n    call %4 = clo<\"IsConstructor\">(C)\n    if (= %4 true) {\n      call %5 = clo<\"Construct\">(C)\n      assert (? %5: Completion)\n      if (? %5: Abrupt) return %5\n      else %5 = %5.Value\n      let A = %5\n    } else {\n      call %6 = clo<\"ArrayCreate\">(0)\n      assert (? %6: Normal)\n      %6 = %6.Value\n      let A = %6\n    }\n    call %7 = clo<\"GetIteratorFromMethod\">(items, usingIterator)\n    assert (? %7: Completion)\n    if (? %7: Abrupt) return %7\n    else %7 = %7.Value\n    let iteratorRecord = %7\n    let k = 0\n    while true {\n      if (! (< k (- (** 2 53) 1))) {\n        call %8 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n        call %9 = clo<\"ThrowCompletion\">(%8)\n        let error = %9\n        call %10 = clo<\"IteratorClose\">(iteratorRecord, error)\n        assert (? %10: Completion)\n        return %10\n      }\n      call %11 = clo<\"ToString\">(([number] k))\n      assert (? %11: Normal)\n      %11 = %11.Value\n      let Pk = %11\n      call %12 = clo<\"IteratorStepValue\">(iteratorRecord)\n      assert (? %12: Completion)\n      if (? %12: Abrupt) return %12\n      else %12 = %12.Value\n      let next = %12\n      if (= next ~done~) {\n        call %13 = clo<\"Set\">(A, \"length\", ([number] k), true)\n        assert (? %13: Completion)\n        if (? %13: Abrupt) return %13\n        else %13 = %13.Value\n        if (? A: Completion) return A\n        call %14 = clo<\"NormalCompletion\">(A)\n        return %14\n      }\n      if (= mapping true) {\n        call %15 = clo<\"Call\">(mapfn, thisArg, (list [next, ([number] k)])[#1072])\n        call %16 = clo<\"Completion\">(%15)\n        let mappedValue = %16\n        assert (? mappedValue: Completion)\n        if (&& (? mappedValue: Completion) (! (= mappedValue.Type ~normal~))) {\n          call %17 = clo<\"IteratorClose\">(iteratorRecord, mappedValue)\n          assert (? %17: Completion)\n          return %17\n        } else {\n          assert (? mappedValue: Normal)\n          mappedValue = mappedValue.Value\n          mappedValue = mappedValue\n        }\n      } else {\n        let mappedValue = next\n      }\n      call %18 = clo<\"CreateDataPropertyOrThrow\">(A, Pk, mappedValue)\n      call %19 = clo<\"Completion\">(%18)\n      let defineStatus = %19\n      assert (? defineStatus: Completion)\n      if (&& (? defineStatus: Completion) (! (= defineStatus.Type ~normal~))) {\n        call %20 = clo<\"IteratorClose\">(iteratorRecord, defineStatus)\n        assert (? %20: Completion)\n        return %20\n      } else {\n        assert (? defineStatus: Normal)\n        defineStatus = defineStatus.Value\n        defineStatus = defineStatus\n      }\n      k = (+ k 1)\n    }\n  }\n  nop\n  call %21 = clo<\"ToObject\">(items)\n  assert (? %21: Normal)\n  %21 = %21.Value\n  let arrayLike = %21\n  call %22 = clo<\"LengthOfArrayLike\">(arrayLike)\n  assert (? %22: Completion)\n  if (? %22: Abrupt) return %22\n  else %22 = %22.Value\n  let len = %22\n  call %23 = clo<\"IsConstructor\">(C)\n  if (= %23 true) {\n    call %24 = clo<\"Construct\">(C, (list [([number] len)])[#1073])\n    assert (? %24: Completion)\n    if (? %24: Abrupt) return %24\n    else %24 = %24.Value\n    let A = %24\n  } else {\n    call %25 = clo<\"ArrayCreate\">(len)\n    assert (? %25: Completion)\n    if (? %25: Abrupt) return %25\n    else %25 = %25.Value\n    let A = %25\n  }\n  let k = 0\n  while (< k len) {\n    call %26 = clo<\"ToString\">(([number] k))\n    assert (? %26: Normal)\n    %26 = %26.Value\n    let Pk = %26\n    call %27 = clo<\"Get\">(arrayLike, Pk)\n    assert (? %27: Completion)\n    if (? %27: Abrupt) return %27\n    else %27 = %27.Value\n    let kValue = %27\n    if (= mapping true) {\n      call %28 = clo<\"Call\">(mapfn, thisArg, (list [kValue, ([number] k)])[#1074])\n      assert (? %28: Completion)\n      if (? %28: Abrupt) return %28\n      else %28 = %28.Value\n      let mappedValue = %28\n    } else {\n      let mappedValue = kValue\n    }\n    call %29 = clo<\"CreateDataPropertyOrThrow\">(A, Pk, mappedValue)\n    assert (? %29: Completion)\n    if (? %29: Abrupt) return %29\n    else %29 = %29.Value\n    k = (+ k 1)\n  }\n  call %30 = clo<\"Set\">(A, \"length\", ([number] len), true)\n  assert (? %30: Completion)\n  if (? %30: Abrupt) return %30\n  else %30 = %30.Value\n  if (? A: Completion) return A\n  call %31 = clo<\"NormalCompletion\">(A)\n  return %31\n}","def <BUILTIN>:INTRINSICS.Array.isArray(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1075]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop arg < ArgumentsList\n    expand __args__.arg\n  } else let arg = undefined\n  call %0 = clo<\"IsArray\">(arg)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.Array.of(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1076]\n  let items = ArgumentsList\n  let len = (sizeof items)\n  let lenNumber = ([number] len)\n  let C = this\n  call %0 = clo<\"IsConstructor\">(C)\n  if (= %0 true) {\n    call %1 = clo<\"Construct\">(C, (list [lenNumber])[#1077])\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let A = %1\n  } else {\n    call %2 = clo<\"ArrayCreate\">(len)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let A = %2\n  }\n  let k = 0\n  while (< k len) {\n    let kValue = items[k]\n    call %3 = clo<\"ToString\">(([number] k))\n    assert (? %3: Normal)\n    %3 = %3.Value\n    let Pk = %3\n    call %4 = clo<\"CreateDataPropertyOrThrow\">(A, Pk, kValue)\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    k = (+ k 1)\n  }\n  call %5 = clo<\"Set\">(A, \"length\", lenNumber, true)\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  if (? A: Completion) return A\n  call %6 = clo<\"NormalCompletion\">(A)\n  return %6\n}","def <BUILTIN>:INTRINSICS.get Array[@@species](\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1078]\n  if (? this: Completion) return this\n  call %0 = clo<\"NormalCompletion\">(this)\n  return %0\n}","def <BUILTIN>:INTRINSICS.Array.prototype.at(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1079]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop index < ArgumentsList\n    expand __args__.index\n  } else let index = undefined\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let len = %1\n  call %2 = clo<\"ToIntegerOrInfinity\">(index)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let relativeIndex = %2\n  if (! (< relativeIndex 0)) {\n    let k = relativeIndex\n  } else {\n    let k = (+ len relativeIndex)\n  }\n  if (|| (< k 0) (! (< k len))) {\n    call %3 = clo<\"NormalCompletion\">(undefined)\n    return %3\n  }\n  call %4 = clo<\"ToString\">(([number] k))\n  assert (? %4: Normal)\n  %4 = %4.Value\n  call %5 = clo<\"Get\">(O, %4)\n  assert (? %5: Completion)\n  return %5\n}","def <BUILTIN>:INTRINSICS.Array.prototype.concat(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1080]\n  let items = ArgumentsList\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"ArraySpeciesCreate\">(O, 0)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let A = %1\n  let n = 0\n  push O > items\n  %3 = items\n  %2 = 0\n  while (< %2 (sizeof %3)) {\n    let E = %3[%2]\n    call %4 = clo<\"IsConcatSpreadable\">(E)\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    let spreadable = %4\n    if (= spreadable true) {\n      call %5 = clo<\"LengthOfArrayLike\">(E)\n      assert (? %5: Completion)\n      if (? %5: Abrupt) return %5\n      else %5 = %5.Value\n      let len = %5\n      if (< (- (** 2 53) 1) (+ n len)) {\n        call %6 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n        call %7 = clo<\"ThrowCompletion\">(%6)\n        return %7\n      }\n      let k = 0\n      while (< k len) {\n        call %8 = clo<\"ToString\">(([number] k))\n        assert (? %8: Normal)\n        %8 = %8.Value\n        let Pk = %8\n        call %9 = clo<\"HasProperty\">(E, Pk)\n        assert (? %9: Completion)\n        if (? %9: Abrupt) return %9\n        else %9 = %9.Value\n        let exists = %9\n        if (= exists true) {\n          call %10 = clo<\"Get\">(E, Pk)\n          assert (? %10: Completion)\n          if (? %10: Abrupt) return %10\n          else %10 = %10.Value\n          let subElement = %10\n          call %11 = clo<\"ToString\">(([number] n))\n          assert (? %11: Normal)\n          %11 = %11.Value\n          call %12 = clo<\"CreateDataPropertyOrThrow\">(A, %11, subElement)\n          assert (? %12: Completion)\n          if (? %12: Abrupt) return %12\n          else %12 = %12.Value\n        }\n        n = (+ n 1)\n        k = (+ k 1)\n      }\n    } else {\n      nop\n      if (! (< n (- (** 2 53) 1))) {\n        call %13 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n        call %14 = clo<\"ThrowCompletion\">(%13)\n        return %14\n      }\n      call %15 = clo<\"ToString\">(([number] n))\n      assert (? %15: Normal)\n      %15 = %15.Value\n      call %16 = clo<\"CreateDataPropertyOrThrow\">(A, %15, E)\n      assert (? %16: Completion)\n      if (? %16: Abrupt) return %16\n      else %16 = %16.Value\n      n = (+ n 1)\n    }\n    %2 = (+ %2 1)\n  }\n  call %17 = clo<\"Set\">(A, \"length\", ([number] n), true)\n  assert (? %17: Completion)\n  if (? %17: Abrupt) return %17\n  else %17 = %17.Value\n  if (? A: Completion) return A\n  call %18 = clo<\"NormalCompletion\">(A)\n  return %18\n}","def IsConcatSpreadable(\n  O: ESValue,\n): Normal[Boolean] | Throw = {\n  if (! (? O: Record[Object])) {\n    call %0 = clo<\"NormalCompletion\">(false)\n    return %0\n  }\n  call %1 = clo<\"Get\">(O, @SYMBOL.isConcatSpreadable)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let spreadable = %1\n  if (! (= spreadable undefined)) {\n    call %2 = clo<\"ToBoolean\">(spreadable)\n    if (? %2: Completion) return %2\n    call %3 = clo<\"NormalCompletion\">(%2)\n    return %3\n  }\n  call %4 = clo<\"IsArray\">(O)\n  assert (? %4: Completion)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Array.prototype.copyWithin(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1081]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop target < ArgumentsList\n    expand __args__.target\n  } else let target = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop start < ArgumentsList\n    expand __args__.start\n  } else let start = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop end < ArgumentsList\n    expand __args__.end\n  } else let end = undefined\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let len = %1\n  call %2 = clo<\"ToIntegerOrInfinity\">(target)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let relativeTarget = %2\n  if (== relativeTarget -INF) {\n    let to = 0\n  } else {\n    if (< relativeTarget 0) {\n      let to = (max (+ len relativeTarget) 0)\n    } else {\n      let to = (min relativeTarget len)\n    }\n  }\n  call %3 = clo<\"ToIntegerOrInfinity\">(start)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let relativeStart = %3\n  if (== relativeStart -INF) {\n    let from = 0\n  } else {\n    if (< relativeStart 0) {\n      let from = (max (+ len relativeStart) 0)\n    } else {\n      let from = (min relativeStart len)\n    }\n  }\n  if (= end undefined) {\n    let relativeEnd = len\n  } else {\n    call %4 = clo<\"ToIntegerOrInfinity\">(end)\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    let relativeEnd = %4\n  }\n  if (== relativeEnd -INF) {\n    let final = 0\n  } else {\n    if (< relativeEnd 0) {\n      let final = (max (+ len relativeEnd) 0)\n    } else {\n      let final = (min relativeEnd len)\n    }\n  }\n  let count = (min (- final from) (- len to))\n  if (&& (< from to) (< to (+ from count))) {\n    let direction = (- 1)\n    from = (- (+ from count) 1)\n    to = (- (+ to count) 1)\n  } else {\n    let direction = 1\n  }\n  while (< 0 count) {\n    call %5 = clo<\"ToString\">(([number] from))\n    assert (? %5: Normal)\n    %5 = %5.Value\n    let fromKey = %5\n    call %6 = clo<\"ToString\">(([number] to))\n    assert (? %6: Normal)\n    %6 = %6.Value\n    let toKey = %6\n    call %7 = clo<\"HasProperty\">(O, fromKey)\n    assert (? %7: Completion)\n    if (? %7: Abrupt) return %7\n    else %7 = %7.Value\n    let fromPresent = %7\n    if (= fromPresent true) {\n      call %8 = clo<\"Get\">(O, fromKey)\n      assert (? %8: Completion)\n      if (? %8: Abrupt) return %8\n      else %8 = %8.Value\n      let fromVal = %8\n      call %9 = clo<\"Set\">(O, toKey, fromVal, true)\n      assert (? %9: Completion)\n      if (? %9: Abrupt) return %9\n      else %9 = %9.Value\n    } else {\n      assert (= fromPresent false)\n      call %10 = clo<\"DeletePropertyOrThrow\">(O, toKey)\n      assert (? %10: Completion)\n      if (? %10: Abrupt) return %10\n      else %10 = %10.Value\n    }\n    from = (+ from direction)\n    to = (+ to direction)\n    count = (- count 1)\n  }\n  if (? O: Completion) return O\n  call %11 = clo<\"NormalCompletion\">(O)\n  return %11\n}","def <BUILTIN>:INTRINSICS.Array.prototype.entries(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1082]\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"CreateArrayIterator\">(O, ~key+value~)\n  if (? %1: Completion) return %1\n  call %2 = clo<\"NormalCompletion\">(%1)\n  return %2\n}","def <BUILTIN>:INTRINSICS.Array.prototype.every(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1083]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop callbackfn < ArgumentsList\n    expand __args__.callbackfn\n  } else let callbackfn = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop thisArg < ArgumentsList\n    expand __args__.thisArg\n  } else let thisArg = undefined\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let len = %1\n  call %2 = clo<\"IsCallable\">(callbackfn)\n  if (= %2 false) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  let k = 0\n  while (< k len) {\n    call %5 = clo<\"ToString\">(([number] k))\n    assert (? %5: Normal)\n    %5 = %5.Value\n    let Pk = %5\n    call %6 = clo<\"HasProperty\">(O, Pk)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    let kPresent = %6\n    if (= kPresent true) {\n      call %7 = clo<\"Get\">(O, Pk)\n      assert (? %7: Completion)\n      if (? %7: Abrupt) return %7\n      else %7 = %7.Value\n      let kValue = %7\n      call %8 = clo<\"Call\">(callbackfn, thisArg, (list [kValue, ([number] k), O])[#1084])\n      assert (? %8: Completion)\n      if (? %8: Abrupt) return %8\n      else %8 = %8.Value\n      call %9 = clo<\"ToBoolean\">(%8)\n      let testResult = %9\n      if (= testResult false) {\n        call %10 = clo<\"NormalCompletion\">(false)\n        return %10\n      }\n    }\n    k = (+ k 1)\n  }\n  call %11 = clo<\"NormalCompletion\">(true)\n  return %11\n}","def <BUILTIN>:INTRINSICS.Array.prototype.fill(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1085]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop start < ArgumentsList\n    expand __args__.start\n  } else let start = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop end < ArgumentsList\n    expand __args__.end\n  } else let end = undefined\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let len = %1\n  call %2 = clo<\"ToIntegerOrInfinity\">(start)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let relativeStart = %2\n  if (== relativeStart -INF) {\n    let k = 0\n  } else {\n    if (< relativeStart 0) {\n      let k = (max (+ len relativeStart) 0)\n    } else {\n      let k = (min relativeStart len)\n    }\n  }\n  if (= end undefined) {\n    let relativeEnd = len\n  } else {\n    call %3 = clo<\"ToIntegerOrInfinity\">(end)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let relativeEnd = %3\n  }\n  if (== relativeEnd -INF) {\n    let final = 0\n  } else {\n    if (< relativeEnd 0) {\n      let final = (max (+ len relativeEnd) 0)\n    } else {\n      let final = (min relativeEnd len)\n    }\n  }\n  while (< k final) {\n    call %4 = clo<\"ToString\">(([number] k))\n    assert (? %4: Normal)\n    %4 = %4.Value\n    let Pk = %4\n    call %5 = clo<\"Set\">(O, Pk, value, true)\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n    k = (+ k 1)\n  }\n  if (? O: Completion) return O\n  call %6 = clo<\"NormalCompletion\">(O)\n  return %6\n}","def <BUILTIN>:INTRINSICS.Array.prototype.filter(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1086]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop callbackfn < ArgumentsList\n    expand __args__.callbackfn\n  } else let callbackfn = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop thisArg < ArgumentsList\n    expand __args__.thisArg\n  } else let thisArg = undefined\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let len = %1\n  call %2 = clo<\"IsCallable\">(callbackfn)\n  if (= %2 false) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  call %5 = clo<\"ArraySpeciesCreate\">(O, 0)\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  let A = %5\n  let k = 0\n  let to = 0\n  while (< k len) {\n    call %6 = clo<\"ToString\">(([number] k))\n    assert (? %6: Normal)\n    %6 = %6.Value\n    let Pk = %6\n    call %7 = clo<\"HasProperty\">(O, Pk)\n    assert (? %7: Completion)\n    if (? %7: Abrupt) return %7\n    else %7 = %7.Value\n    let kPresent = %7\n    if (= kPresent true) {\n      call %8 = clo<\"Get\">(O, Pk)\n      assert (? %8: Completion)\n      if (? %8: Abrupt) return %8\n      else %8 = %8.Value\n      let kValue = %8\n      call %9 = clo<\"Call\">(callbackfn, thisArg, (list [kValue, ([number] k), O])[#1087])\n      assert (? %9: Completion)\n      if (? %9: Abrupt) return %9\n      else %9 = %9.Value\n      call %10 = clo<\"ToBoolean\">(%9)\n      let selected = %10\n      if (= selected true) {\n        call %11 = clo<\"ToString\">(([number] to))\n        assert (? %11: Normal)\n        %11 = %11.Value\n        call %12 = clo<\"CreateDataPropertyOrThrow\">(A, %11, kValue)\n        assert (? %12: Completion)\n        if (? %12: Abrupt) return %12\n        else %12 = %12.Value\n        to = (+ to 1)\n      }\n    }\n    k = (+ k 1)\n  }\n  if (? A: Completion) return A\n  call %13 = clo<\"NormalCompletion\">(A)\n  return %13\n}","def <BUILTIN>:INTRINSICS.Array.prototype.find(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1088]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop predicate < ArgumentsList\n    expand __args__.predicate\n  } else let predicate = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop thisArg < ArgumentsList\n    expand __args__.thisArg\n  } else let thisArg = undefined\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let len = %1\n  call %2 = clo<\"FindViaPredicate\">(O, len, ~ascending~, predicate, thisArg)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let findRec = %2\n  %3 = findRec.Value\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Array.prototype.findIndex(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1089]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop predicate < ArgumentsList\n    expand __args__.predicate\n  } else let predicate = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop thisArg < ArgumentsList\n    expand __args__.thisArg\n  } else let thisArg = undefined\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let len = %1\n  call %2 = clo<\"FindViaPredicate\">(O, len, ~ascending~, predicate, thisArg)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let findRec = %2\n  %3 = findRec.Index\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Array.prototype.findLast(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1090]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop predicate < ArgumentsList\n    expand __args__.predicate\n  } else let predicate = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop thisArg < ArgumentsList\n    expand __args__.thisArg\n  } else let thisArg = undefined\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let len = %1\n  call %2 = clo<\"FindViaPredicate\">(O, len, ~descending~, predicate, thisArg)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let findRec = %2\n  %3 = findRec.Value\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Array.prototype.findLastIndex(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1091]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop predicate < ArgumentsList\n    expand __args__.predicate\n  } else let predicate = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop thisArg < ArgumentsList\n    expand __args__.thisArg\n  } else let thisArg = undefined\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let len = %1\n  call %2 = clo<\"FindViaPredicate\">(O, len, ~descending~, predicate, thisArg)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let findRec = %2\n  %3 = findRec.Index\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def FindViaPredicate(\n  O: Record[Object],\n  len: NonNegInt,\n  direction: Enum[~ascending~, ~descending~],\n  predicate: ESValue,\n  thisArg: ESValue,\n): Unknown[\"EitherANormalCompletionContainingARecordWithFields[[Index]](anIntegralNumber)And[[Value]](anECMAScriptLanguageValue)OrAThrowCompletion\"] = {\n  call %0 = clo<\"IsCallable\">(predicate)\n  if (= %0 false) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  if (= direction ~ascending~) {\n    %3 = 0\n    %4 = len\n    %5 = %3\n    %6 = (list [])[#1092]\n    while (< %5 %4) {\n      push %6 < %5\n      %5 = (+ %5 1)\n    }\n    let indices = %6\n  } else {\n    %7 = 0\n    %8 = len\n    %9 = (- %8 1)\n    %10 = (list [])[#1093]\n    while (< (- %7 1) %9) {\n      push %10 < %9\n      %9 = (- %9 1)\n    }\n    let indices = %10\n  }\n  %12 = indices\n  %11 = 0\n  while (< %11 (sizeof %12)) {\n    let k = %12[%11]\n    if (? k: Int) {\n      call %13 = clo<\"ToString\">(([number] k))\n      assert (? %13: Normal)\n      %13 = %13.Value\n      let Pk = %13\n      nop\n      call %14 = clo<\"Get\">(O, Pk)\n      assert (? %14: Completion)\n      if (? %14: Abrupt) return %14\n      else %14 = %14.Value\n      let kValue = %14\n      call %15 = clo<\"Call\">(predicate, thisArg, (list [kValue, ([number] k), O])[#1094])\n      assert (? %15: Completion)\n      if (? %15: Abrupt) return %15\n      else %15 = %15.Value\n      let testResult = %15\n      call %16 = clo<\"ToBoolean\">(testResult)\n      if (= %16 true) {\n        %17 = (record {\n          \"Index\" : ([number] k),\n          \"Value\" : kValue,\n        })[#1095]\n        if (? %17: Completion) return %17\n        call %18 = clo<\"NormalCompletion\">(%17)\n        return %18\n      }\n    }\n    %11 = (+ %11 1)\n  }\n  %19 = (record {\n    \"Index\" : -1.0f,\n    \"Value\" : undefined,\n  })[#1096]\n  if (? %19: Completion) return %19\n  call %20 = clo<\"NormalCompletion\">(%19)\n  return %20\n}","def <BUILTIN>:INTRINSICS.Array.prototype.flat(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1097]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop depth < ArgumentsList\n    expand __args__.depth\n  } else let depth = undefined\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let sourceLen = %1\n  let depthNum = 1\n  if (! (= depth undefined)) {\n    call %2 = clo<\"ToIntegerOrInfinity\">(depth)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    depthNum = %2\n    if (< depthNum 0) {\n      depthNum = 0\n    }\n  }\n  call %3 = clo<\"ArraySpeciesCreate\">(O, 0)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let A = %3\n  call %4 = clo<\"FlattenIntoArray\">(A, O, sourceLen, 0, depthNum)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  if (? A: Completion) return A\n  call %5 = clo<\"NormalCompletion\">(A)\n  return %5\n}","def FlattenIntoArray(\n  target: Record[Object],\n  source: Record[Object],\n  sourceLen: NonNegInt,\n  start: NonNegInt,\n  depth: NonNegInt | +INF,\n  mapperFunction?: Record[FunctionObject],\n  thisArg?: ESValue,\n): Normal[NonNegInt] | Throw = {\n  assert (yet \"If _mapperFunction_ is present, then IsCallable(_mapperFunction_) is *true*, _thisArg_ is present, and _depth_ is 1.\")\n  let targetIndex = start\n  let sourceIndex = 0.0f\n  while (< ([math] sourceIndex) sourceLen) {\n    call %0 = clo<\"ToString\">(sourceIndex)\n    assert (? %0: Normal)\n    %0 = %0.Value\n    let P = %0\n    call %1 = clo<\"HasProperty\">(source, P)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let exists = %1\n    if (= exists true) {\n      call %2 = clo<\"Get\">(source, P)\n      assert (? %2: Completion)\n      if (? %2: Abrupt) return %2\n      else %2 = %2.Value\n      let element = %2\n      if (exists mapperFunction) {\n        call %3 = clo<\"Call\">(mapperFunction, thisArg, (list [element, sourceIndex, source])[#1098])\n        assert (? %3: Completion)\n        if (? %3: Abrupt) return %3\n        else %3 = %3.Value\n        element = %3\n      }\n      let shouldFlatten = false\n      if (< 0 depth) {\n        call %4 = clo<\"IsArray\">(element)\n        assert (? %4: Completion)\n        if (? %4: Abrupt) return %4\n        else %4 = %4.Value\n        shouldFlatten = %4\n      }\n      if (= shouldFlatten true) {\n        if (== depth +INF) {\n          let newDepth = +INF\n        } else {\n          let newDepth = (- depth 1)\n        }\n        call %5 = clo<\"LengthOfArrayLike\">(element)\n        assert (? %5: Completion)\n        if (? %5: Abrupt) return %5\n        else %5 = %5.Value\n        let elementLen = %5\n        call %6 = clo<\"FlattenIntoArray\">(target, element, elementLen, targetIndex, newDepth)\n        assert (? %6: Completion)\n        if (? %6: Abrupt) return %6\n        else %6 = %6.Value\n        targetIndex = %6\n      } else {\n        if (! (< targetIndex (- (** 2 53) 1))) {\n          call %7 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n          call %8 = clo<\"ThrowCompletion\">(%7)\n          return %8\n        }\n        call %9 = clo<\"ToString\">(([number] targetIndex))\n        assert (? %9: Normal)\n        %9 = %9.Value\n        call %10 = clo<\"CreateDataPropertyOrThrow\">(target, %9, element)\n        assert (? %10: Completion)\n        if (? %10: Abrupt) return %10\n        else %10 = %10.Value\n        targetIndex = (+ targetIndex 1)\n      }\n    }\n    sourceIndex = (+ sourceIndex 1.0f)\n  }\n  if (? targetIndex: Completion) return targetIndex\n  call %11 = clo<\"NormalCompletion\">(targetIndex)\n  return %11\n}","def <BUILTIN>:INTRINSICS.Array.prototype.flatMap(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1099]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop mapperFunction < ArgumentsList\n    expand __args__.mapperFunction\n  } else let mapperFunction = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop thisArg < ArgumentsList\n    expand __args__.thisArg\n  } else let thisArg = undefined\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let sourceLen = %1\n  call %2 = clo<\"IsCallable\">(mapperFunction)\n  if (= %2 false) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  call %5 = clo<\"ArraySpeciesCreate\">(O, 0)\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  let A = %5\n  call %6 = clo<\"FlattenIntoArray\">(A, O, sourceLen, 0, 1, mapperFunction, thisArg)\n  assert (? %6: Completion)\n  if (? %6: Abrupt) return %6\n  else %6 = %6.Value\n  if (? A: Completion) return A\n  call %7 = clo<\"NormalCompletion\">(A)\n  return %7\n}","def <BUILTIN>:INTRINSICS.Array.prototype.forEach(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1100]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop callbackfn < ArgumentsList\n    expand __args__.callbackfn\n  } else let callbackfn = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop thisArg < ArgumentsList\n    expand __args__.thisArg\n  } else let thisArg = undefined\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let len = %1\n  call %2 = clo<\"IsCallable\">(callbackfn)\n  if (= %2 false) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  let k = 0\n  while (< k len) {\n    call %5 = clo<\"ToString\">(([number] k))\n    assert (? %5: Normal)\n    %5 = %5.Value\n    let Pk = %5\n    call %6 = clo<\"HasProperty\">(O, Pk)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    let kPresent = %6\n    if (= kPresent true) {\n      call %7 = clo<\"Get\">(O, Pk)\n      assert (? %7: Completion)\n      if (? %7: Abrupt) return %7\n      else %7 = %7.Value\n      let kValue = %7\n      call %8 = clo<\"Call\">(callbackfn, thisArg, (list [kValue, ([number] k), O])[#1101])\n      assert (? %8: Completion)\n      if (? %8: Abrupt) return %8\n      else %8 = %8.Value\n    }\n    k = (+ k 1)\n  }\n  call %9 = clo<\"NormalCompletion\">(undefined)\n  return %9\n}","def <BUILTIN>:INTRINSICS.Array.prototype.includes(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1102]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop searchElement < ArgumentsList\n    expand __args__.searchElement\n  } else let searchElement = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop fromIndex < ArgumentsList\n    expand __args__.fromIndex\n  } else let fromIndex = undefined\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let len = %1\n  if (== len 0) {\n    call %2 = clo<\"NormalCompletion\">(false)\n    return %2\n  }\n  call %3 = clo<\"ToIntegerOrInfinity\">(fromIndex)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let n = %3\n  assert (|| (! (= fromIndex undefined)) (= n 0))\n  if (== n +INF) {\n    call %4 = clo<\"NormalCompletion\">(false)\n    return %4\n  } else {\n    if (== n -INF) {\n      n = 0\n    }\n  }\n  if (! (< n 0)) {\n    let k = n\n  } else {\n    let k = (+ len n)\n    if (< k 0) {\n      k = 0\n    }\n  }\n  while (< k len) {\n    call %5 = clo<\"ToString\">(([number] k))\n    assert (? %5: Normal)\n    %5 = %5.Value\n    call %6 = clo<\"Get\">(O, %5)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    let elementK = %6\n    call %7 = clo<\"SameValueZero\">(searchElement, elementK)\n    if (= %7 true) {\n      call %8 = clo<\"NormalCompletion\">(true)\n      return %8\n    }\n    k = (+ k 1)\n  }\n  call %9 = clo<\"NormalCompletion\">(false)\n  return %9\n}","def <BUILTIN>:INTRINSICS.Array.prototype.indexOf(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1103]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop searchElement < ArgumentsList\n    expand __args__.searchElement\n  } else let searchElement = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop fromIndex < ArgumentsList\n    expand __args__.fromIndex\n  } else let fromIndex = undefined\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let len = %1\n  if (== len 0) {\n    call %2 = clo<\"NormalCompletion\">(-1.0f)\n    return %2\n  }\n  call %3 = clo<\"ToIntegerOrInfinity\">(fromIndex)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let n = %3\n  assert (|| (! (= fromIndex undefined)) (= n 0))\n  if (== n +INF) {\n    call %4 = clo<\"NormalCompletion\">(-1.0f)\n    return %4\n  } else {\n    if (== n -INF) {\n      n = 0\n    }\n  }\n  if (! (< n 0)) {\n    let k = n\n  } else {\n    let k = (+ len n)\n    if (< k 0) {\n      k = 0\n    }\n  }\n  while (< k len) {\n    call %5 = clo<\"ToString\">(([number] k))\n    assert (? %5: Normal)\n    %5 = %5.Value\n    call %6 = clo<\"HasProperty\">(O, %5)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    let kPresent = %6\n    if (= kPresent true) {\n      call %7 = clo<\"ToString\">(([number] k))\n      assert (? %7: Normal)\n      %7 = %7.Value\n      call %8 = clo<\"Get\">(O, %7)\n      assert (? %8: Completion)\n      if (? %8: Abrupt) return %8\n      else %8 = %8.Value\n      let elementK = %8\n      call %9 = clo<\"IsStrictlyEqual\">(searchElement, elementK)\n      if (= %9 true) {\n        %10 = ([number] k)\n        if (? %10: Completion) return %10\n        call %11 = clo<\"NormalCompletion\">(%10)\n        return %11\n      }\n    }\n    k = (+ k 1)\n  }\n  call %12 = clo<\"NormalCompletion\">(-1.0f)\n  return %12\n}","def <BUILTIN>:INTRINSICS.Array.prototype.join(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1104]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop separator < ArgumentsList\n    expand __args__.separator\n  } else let separator = undefined\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let len = %1\n  if (= separator undefined) {\n    let sep = \",\"\n  } else {\n    call %2 = clo<\"ToString\">(separator)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let sep = %2\n  }\n  let R = \"\"\n  let k = 0\n  while (< k len) {\n    if (< 0 k) {\n      R = (concat R sep)\n    }\n    call %3 = clo<\"ToString\">(([number] k))\n    assert (? %3: Normal)\n    %3 = %3.Value\n    call %4 = clo<\"Get\">(O, %3)\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    let element = %4\n    if (|| (= element undefined) (= element null)) {\n      let next = \"\"\n    } else {\n      call %5 = clo<\"ToString\">(element)\n      assert (? %5: Completion)\n      if (? %5: Abrupt) return %5\n      else %5 = %5.Value\n      let next = %5\n    }\n    R = (concat R next)\n    k = (+ k 1)\n  }\n  if (? R: Completion) return R\n  call %6 = clo<\"NormalCompletion\">(R)\n  return %6\n}","def <BUILTIN>:INTRINSICS.Array.prototype.keys(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1105]\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"CreateArrayIterator\">(O, ~key~)\n  if (? %1: Completion) return %1\n  call %2 = clo<\"NormalCompletion\">(%1)\n  return %2\n}","def <BUILTIN>:INTRINSICS.Array.prototype.lastIndexOf(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1106]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop searchElement < ArgumentsList\n    expand __args__.searchElement\n  } else let searchElement = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop fromIndex < ArgumentsList\n    expand __args__.fromIndex\n  } else let fromIndex = undefined\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let len = %1\n  if (== len 0) {\n    call %2 = clo<\"NormalCompletion\">(-1.0f)\n    return %2\n  }\n  if (exists __args__.fromIndex) {\n    call %3 = clo<\"ToIntegerOrInfinity\">(fromIndex)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let n = %3\n  } else {\n    let n = (- len 1)\n  }\n  if (== n -INF) {\n    call %4 = clo<\"NormalCompletion\">(-1.0f)\n    return %4\n  }\n  if (! (< n 0)) {\n    let k = (min n (- len 1))\n  } else {\n    let k = (+ len n)\n  }\n  while (! (< k 0)) {\n    call %5 = clo<\"ToString\">(([number] k))\n    assert (? %5: Normal)\n    %5 = %5.Value\n    call %6 = clo<\"HasProperty\">(O, %5)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    let kPresent = %6\n    if (= kPresent true) {\n      call %7 = clo<\"ToString\">(([number] k))\n      assert (? %7: Normal)\n      %7 = %7.Value\n      call %8 = clo<\"Get\">(O, %7)\n      assert (? %8: Completion)\n      if (? %8: Abrupt) return %8\n      else %8 = %8.Value\n      let elementK = %8\n      call %9 = clo<\"IsStrictlyEqual\">(searchElement, elementK)\n      if (= %9 true) {\n        %10 = ([number] k)\n        if (? %10: Completion) return %10\n        call %11 = clo<\"NormalCompletion\">(%10)\n        return %11\n      }\n    }\n    k = (- k 1)\n  }\n  call %12 = clo<\"NormalCompletion\">(-1.0f)\n  return %12\n}","def <BUILTIN>:INTRINSICS.Array.prototype.map(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1107]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop callbackfn < ArgumentsList\n    expand __args__.callbackfn\n  } else let callbackfn = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop thisArg < ArgumentsList\n    expand __args__.thisArg\n  } else let thisArg = undefined\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let len = %1\n  call %2 = clo<\"IsCallable\">(callbackfn)\n  if (= %2 false) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  call %5 = clo<\"ArraySpeciesCreate\">(O, len)\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  let A = %5\n  let k = 0\n  while (< k len) {\n    call %6 = clo<\"ToString\">(([number] k))\n    assert (? %6: Normal)\n    %6 = %6.Value\n    let Pk = %6\n    call %7 = clo<\"HasProperty\">(O, Pk)\n    assert (? %7: Completion)\n    if (? %7: Abrupt) return %7\n    else %7 = %7.Value\n    let kPresent = %7\n    if (= kPresent true) {\n      call %8 = clo<\"Get\">(O, Pk)\n      assert (? %8: Completion)\n      if (? %8: Abrupt) return %8\n      else %8 = %8.Value\n      let kValue = %8\n      call %9 = clo<\"Call\">(callbackfn, thisArg, (list [kValue, ([number] k), O])[#1108])\n      assert (? %9: Completion)\n      if (? %9: Abrupt) return %9\n      else %9 = %9.Value\n      let mappedValue = %9\n      call %10 = clo<\"CreateDataPropertyOrThrow\">(A, Pk, mappedValue)\n      assert (? %10: Completion)\n      if (? %10: Abrupt) return %10\n      else %10 = %10.Value\n    }\n    k = (+ k 1)\n  }\n  if (? A: Completion) return A\n  call %11 = clo<\"NormalCompletion\">(A)\n  return %11\n}","def <BUILTIN>:INTRINSICS.Array.prototype.pop(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1109]\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let len = %1\n  if (== len 0) {\n    call %2 = clo<\"Set\">(O, \"length\", 0.0f, true)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    call %3 = clo<\"NormalCompletion\">(undefined)\n    return %3\n  } else {\n    assert (< 0 len)\n    let newLen = ([number] (- len 1))\n    call %4 = clo<\"ToString\">(newLen)\n    assert (? %4: Normal)\n    %4 = %4.Value\n    let index = %4\n    call %5 = clo<\"Get\">(O, index)\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n    let element = %5\n    call %6 = clo<\"DeletePropertyOrThrow\">(O, index)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    call %7 = clo<\"Set\">(O, \"length\", newLen, true)\n    assert (? %7: Completion)\n    if (? %7: Abrupt) return %7\n    else %7 = %7.Value\n    if (? element: Completion) return element\n    call %8 = clo<\"NormalCompletion\">(element)\n    return %8\n  }\n}","def <BUILTIN>:INTRINSICS.Array.prototype.push(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1110]\n  let items = ArgumentsList\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let len = %1\n  let argCount = (sizeof items)\n  if (< (- (** 2 53) 1) (+ len argCount)) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  %5 = items\n  %4 = 0\n  while (< %4 (sizeof %5)) {\n    let E = %5[%4]\n    call %6 = clo<\"ToString\">(([number] len))\n    assert (? %6: Normal)\n    %6 = %6.Value\n    call %7 = clo<\"Set\">(O, %6, E, true)\n    assert (? %7: Completion)\n    if (? %7: Abrupt) return %7\n    else %7 = %7.Value\n    len = (+ len 1)\n    %4 = (+ %4 1)\n  }\n  call %8 = clo<\"Set\">(O, \"length\", ([number] len), true)\n  assert (? %8: Completion)\n  if (? %8: Abrupt) return %8\n  else %8 = %8.Value\n  %9 = ([number] len)\n  if (? %9: Completion) return %9\n  call %10 = clo<\"NormalCompletion\">(%9)\n  return %10\n}","def <BUILTIN>:INTRINSICS.Array.prototype.reduce(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1111]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop callbackfn < ArgumentsList\n    expand __args__.callbackfn\n  } else let callbackfn = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop initialValue < ArgumentsList\n    expand __args__.initialValue\n  } else let initialValue = undefined\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let len = %1\n  call %2 = clo<\"IsCallable\">(callbackfn)\n  if (= %2 false) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  if (&& (== len 0) (! (exists __args__.initialValue))) {\n    call %5 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %6 = clo<\"ThrowCompletion\">(%5)\n    return %6\n  }\n  let k = 0\n  let accumulator = undefined\n  if (exists __args__.initialValue) {\n    accumulator = initialValue\n  } else {\n    let kPresent = false\n    while (&& (= kPresent false) (< k len)) {\n      call %7 = clo<\"ToString\">(([number] k))\n      assert (? %7: Normal)\n      %7 = %7.Value\n      let Pk = %7\n      call %8 = clo<\"HasProperty\">(O, Pk)\n      assert (? %8: Completion)\n      if (? %8: Abrupt) return %8\n      else %8 = %8.Value\n      kPresent = %8\n      if (= kPresent true) {\n        call %9 = clo<\"Get\">(O, Pk)\n        assert (? %9: Completion)\n        if (? %9: Abrupt) return %9\n        else %9 = %9.Value\n        accumulator = %9\n      }\n      k = (+ k 1)\n    }\n    if (= kPresent false) {\n      call %10 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %11 = clo<\"ThrowCompletion\">(%10)\n      return %11\n    }\n  }\n  while (< k len) {\n    call %12 = clo<\"ToString\">(([number] k))\n    assert (? %12: Normal)\n    %12 = %12.Value\n    let Pk = %12\n    call %13 = clo<\"HasProperty\">(O, Pk)\n    assert (? %13: Completion)\n    if (? %13: Abrupt) return %13\n    else %13 = %13.Value\n    let kPresent = %13\n    if (= kPresent true) {\n      call %14 = clo<\"Get\">(O, Pk)\n      assert (? %14: Completion)\n      if (? %14: Abrupt) return %14\n      else %14 = %14.Value\n      let kValue = %14\n      call %15 = clo<\"Call\">(callbackfn, undefined, (list [accumulator, kValue, ([number] k), O])[#1112])\n      assert (? %15: Completion)\n      if (? %15: Abrupt) return %15\n      else %15 = %15.Value\n      accumulator = %15\n    }\n    k = (+ k 1)\n  }\n  if (? accumulator: Completion) return accumulator\n  call %16 = clo<\"NormalCompletion\">(accumulator)\n  return %16\n}","def <BUILTIN>:INTRINSICS.Array.prototype.reduceRight(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1113]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop callbackfn < ArgumentsList\n    expand __args__.callbackfn\n  } else let callbackfn = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop initialValue < ArgumentsList\n    expand __args__.initialValue\n  } else let initialValue = undefined\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let len = %1\n  call %2 = clo<\"IsCallable\">(callbackfn)\n  if (= %2 false) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  if (&& (== len 0) (! (exists __args__.initialValue))) {\n    call %5 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %6 = clo<\"ThrowCompletion\">(%5)\n    return %6\n  }\n  let k = (- len 1)\n  let accumulator = undefined\n  if (exists __args__.initialValue) {\n    accumulator = initialValue\n  } else {\n    let kPresent = false\n    while (&& (= kPresent false) (! (< k 0))) {\n      call %7 = clo<\"ToString\">(([number] k))\n      assert (? %7: Normal)\n      %7 = %7.Value\n      let Pk = %7\n      call %8 = clo<\"HasProperty\">(O, Pk)\n      assert (? %8: Completion)\n      if (? %8: Abrupt) return %8\n      else %8 = %8.Value\n      kPresent = %8\n      if (= kPresent true) {\n        call %9 = clo<\"Get\">(O, Pk)\n        assert (? %9: Completion)\n        if (? %9: Abrupt) return %9\n        else %9 = %9.Value\n        accumulator = %9\n      }\n      k = (- k 1)\n    }\n    if (= kPresent false) {\n      call %10 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %11 = clo<\"ThrowCompletion\">(%10)\n      return %11\n    }\n  }\n  while (! (< k 0)) {\n    call %12 = clo<\"ToString\">(([number] k))\n    assert (? %12: Normal)\n    %12 = %12.Value\n    let Pk = %12\n    call %13 = clo<\"HasProperty\">(O, Pk)\n    assert (? %13: Completion)\n    if (? %13: Abrupt) return %13\n    else %13 = %13.Value\n    let kPresent = %13\n    if (= kPresent true) {\n      call %14 = clo<\"Get\">(O, Pk)\n      assert (? %14: Completion)\n      if (? %14: Abrupt) return %14\n      else %14 = %14.Value\n      let kValue = %14\n      call %15 = clo<\"Call\">(callbackfn, undefined, (list [accumulator, kValue, ([number] k), O])[#1114])\n      assert (? %15: Completion)\n      if (? %15: Abrupt) return %15\n      else %15 = %15.Value\n      accumulator = %15\n    }\n    k = (- k 1)\n  }\n  if (? accumulator: Completion) return accumulator\n  call %16 = clo<\"NormalCompletion\">(accumulator)\n  return %16\n}","def <BUILTIN>:INTRINSICS.Array.prototype.reverse(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1115]\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let len = %1\n  let middle = (floor (/ len 2))\n  let lower = 0\n  while (! (== lower middle)) {\n    let upper = (- (- len lower) 1)\n    call %2 = clo<\"ToString\">(([number] upper))\n    assert (? %2: Normal)\n    %2 = %2.Value\n    let upperP = %2\n    call %3 = clo<\"ToString\">(([number] lower))\n    assert (? %3: Normal)\n    %3 = %3.Value\n    let lowerP = %3\n    call %4 = clo<\"HasProperty\">(O, lowerP)\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    let lowerExists = %4\n    if (= lowerExists true) {\n      call %5 = clo<\"Get\">(O, lowerP)\n      assert (? %5: Completion)\n      if (? %5: Abrupt) return %5\n      else %5 = %5.Value\n      let lowerValue = %5\n    }\n    call %6 = clo<\"HasProperty\">(O, upperP)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    let upperExists = %6\n    if (= upperExists true) {\n      call %7 = clo<\"Get\">(O, upperP)\n      assert (? %7: Completion)\n      if (? %7: Abrupt) return %7\n      else %7 = %7.Value\n      let upperValue = %7\n    }\n    if (&& (= lowerExists true) (= upperExists true)) {\n      call %8 = clo<\"Set\">(O, lowerP, upperValue, true)\n      assert (? %8: Completion)\n      if (? %8: Abrupt) return %8\n      else %8 = %8.Value\n      call %9 = clo<\"Set\">(O, upperP, lowerValue, true)\n      assert (? %9: Completion)\n      if (? %9: Abrupt) return %9\n      else %9 = %9.Value\n    } else {\n      if (&& (= lowerExists false) (= upperExists true)) {\n        call %10 = clo<\"Set\">(O, lowerP, upperValue, true)\n        assert (? %10: Completion)\n        if (? %10: Abrupt) return %10\n        else %10 = %10.Value\n        call %11 = clo<\"DeletePropertyOrThrow\">(O, upperP)\n        assert (? %11: Completion)\n        if (? %11: Abrupt) return %11\n        else %11 = %11.Value\n      } else {\n        if (&& (= lowerExists true) (= upperExists false)) {\n          call %12 = clo<\"DeletePropertyOrThrow\">(O, lowerP)\n          assert (? %12: Completion)\n          if (? %12: Abrupt) return %12\n          else %12 = %12.Value\n          call %13 = clo<\"Set\">(O, upperP, lowerValue, true)\n          assert (? %13: Completion)\n          if (? %13: Abrupt) return %13\n          else %13 = %13.Value\n        } else {\n          assert (&& (= lowerExists false) (= upperExists false))\n          nop\n        }\n      }\n    }\n    lower = (+ lower 1)\n  }\n  if (? O: Completion) return O\n  call %14 = clo<\"NormalCompletion\">(O)\n  return %14\n}","def <BUILTIN>:INTRINSICS.Array.prototype.shift(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1116]\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let len = %1\n  if (== len 0) {\n    call %2 = clo<\"Set\">(O, \"length\", 0.0f, true)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    call %3 = clo<\"NormalCompletion\">(undefined)\n    return %3\n  }\n  call %4 = clo<\"Get\">(O, \"0\")\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let first = %4\n  let k = 1\n  while (< k len) {\n    call %5 = clo<\"ToString\">(([number] k))\n    assert (? %5: Normal)\n    %5 = %5.Value\n    let from = %5\n    call %6 = clo<\"ToString\">(([number] (- k 1)))\n    assert (? %6: Normal)\n    %6 = %6.Value\n    let to = %6\n    call %7 = clo<\"HasProperty\">(O, from)\n    assert (? %7: Completion)\n    if (? %7: Abrupt) return %7\n    else %7 = %7.Value\n    let fromPresent = %7\n    if (= fromPresent true) {\n      call %8 = clo<\"Get\">(O, from)\n      assert (? %8: Completion)\n      if (? %8: Abrupt) return %8\n      else %8 = %8.Value\n      let fromVal = %8\n      call %9 = clo<\"Set\">(O, to, fromVal, true)\n      assert (? %9: Completion)\n      if (? %9: Abrupt) return %9\n      else %9 = %9.Value\n    } else {\n      assert (= fromPresent false)\n      call %10 = clo<\"DeletePropertyOrThrow\">(O, to)\n      assert (? %10: Completion)\n      if (? %10: Abrupt) return %10\n      else %10 = %10.Value\n    }\n    k = (+ k 1)\n  }\n  call %11 = clo<\"ToString\">(([number] (- len 1)))\n  assert (? %11: Normal)\n  %11 = %11.Value\n  call %12 = clo<\"DeletePropertyOrThrow\">(O, %11)\n  assert (? %12: Completion)\n  if (? %12: Abrupt) return %12\n  else %12 = %12.Value\n  call %13 = clo<\"Set\">(O, \"length\", ([number] (- len 1)), true)\n  assert (? %13: Completion)\n  if (? %13: Abrupt) return %13\n  else %13 = %13.Value\n  if (? first: Completion) return first\n  call %14 = clo<\"NormalCompletion\">(first)\n  return %14\n}","def <BUILTIN>:INTRINSICS.Array.prototype.slice(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1117]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop start < ArgumentsList\n    expand __args__.start\n  } else let start = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop end < ArgumentsList\n    expand __args__.end\n  } else let end = undefined\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let len = %1\n  call %2 = clo<\"ToIntegerOrInfinity\">(start)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let relativeStart = %2\n  if (== relativeStart -INF) {\n    let k = 0\n  } else {\n    if (< relativeStart 0) {\n      let k = (max (+ len relativeStart) 0)\n    } else {\n      let k = (min relativeStart len)\n    }\n  }\n  if (= end undefined) {\n    let relativeEnd = len\n  } else {\n    call %3 = clo<\"ToIntegerOrInfinity\">(end)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let relativeEnd = %3\n  }\n  if (== relativeEnd -INF) {\n    let final = 0\n  } else {\n    if (< relativeEnd 0) {\n      let final = (max (+ len relativeEnd) 0)\n    } else {\n      let final = (min relativeEnd len)\n    }\n  }\n  let count = (max (- final k) 0)\n  call %4 = clo<\"ArraySpeciesCreate\">(O, count)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let A = %4\n  let n = 0\n  while (< k final) {\n    call %5 = clo<\"ToString\">(([number] k))\n    assert (? %5: Normal)\n    %5 = %5.Value\n    let Pk = %5\n    call %6 = clo<\"HasProperty\">(O, Pk)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    let kPresent = %6\n    if (= kPresent true) {\n      call %7 = clo<\"Get\">(O, Pk)\n      assert (? %7: Completion)\n      if (? %7: Abrupt) return %7\n      else %7 = %7.Value\n      let kValue = %7\n      call %8 = clo<\"ToString\">(([number] n))\n      assert (? %8: Normal)\n      %8 = %8.Value\n      call %9 = clo<\"CreateDataPropertyOrThrow\">(A, %8, kValue)\n      assert (? %9: Completion)\n      if (? %9: Abrupt) return %9\n      else %9 = %9.Value\n    }\n    k = (+ k 1)\n    n = (+ n 1)\n  }\n  call %10 = clo<\"Set\">(A, \"length\", ([number] n), true)\n  assert (? %10: Completion)\n  if (? %10: Abrupt) return %10\n  else %10 = %10.Value\n  if (? A: Completion) return A\n  call %11 = clo<\"NormalCompletion\">(A)\n  return %11\n}","def <BUILTIN>:INTRINSICS.Array.prototype.some(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1118]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop callbackfn < ArgumentsList\n    expand __args__.callbackfn\n  } else let callbackfn = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop thisArg < ArgumentsList\n    expand __args__.thisArg\n  } else let thisArg = undefined\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let len = %1\n  call %2 = clo<\"IsCallable\">(callbackfn)\n  if (= %2 false) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  let k = 0\n  while (< k len) {\n    call %5 = clo<\"ToString\">(([number] k))\n    assert (? %5: Normal)\n    %5 = %5.Value\n    let Pk = %5\n    call %6 = clo<\"HasProperty\">(O, Pk)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    let kPresent = %6\n    if (= kPresent true) {\n      call %7 = clo<\"Get\">(O, Pk)\n      assert (? %7: Completion)\n      if (? %7: Abrupt) return %7\n      else %7 = %7.Value\n      let kValue = %7\n      call %8 = clo<\"Call\">(callbackfn, thisArg, (list [kValue, ([number] k), O])[#1119])\n      assert (? %8: Completion)\n      if (? %8: Abrupt) return %8\n      else %8 = %8.Value\n      call %9 = clo<\"ToBoolean\">(%8)\n      let testResult = %9\n      if (= testResult true) {\n        call %10 = clo<\"NormalCompletion\">(true)\n        return %10\n      }\n    }\n    k = (+ k 1)\n  }\n  call %11 = clo<\"NormalCompletion\">(false)\n  return %11\n}","def <CLO>:INTRINSICS.Array.prototype.sort:clo0(\n  x: Unknown,\n  y: Unknown,\n): Unknown = {\n  call %0 = clo<\"CompareArrayElements\">(x, y, comparefn)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.Array.prototype.sort(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1120]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop comparefn < ArgumentsList\n    expand __args__.comparefn\n  } else let comparefn = undefined\n  %0 = (! (= comparefn undefined))\n  if %0 {\n    call %1 = clo<\"IsCallable\">(comparefn)\n    %0 = (= %1 false)\n  }\n  if %0 {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  call %4 = clo<\"ToObject\">(this)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let obj = %4\n  call %5 = clo<\"LengthOfArrayLike\">(obj)\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  let len = %5\n  let SortCompare = clo<\"INTRINSICS.Array.prototype.sort:clo0\", [comparefn]>\n  call %6 = clo<\"SortIndexedProperties\">(obj, len, SortCompare, ~skip-holes~)\n  assert (? %6: Completion)\n  if (? %6: Abrupt) return %6\n  else %6 = %6.Value\n  let sortedList = %6\n  let itemCount = (sizeof sortedList)\n  let j = 0\n  while (< j itemCount) {\n    call %7 = clo<\"ToString\">(([number] j))\n    assert (? %7: Normal)\n    %7 = %7.Value\n    call %8 = clo<\"Set\">(obj, %7, sortedList[j], true)\n    assert (? %8: Completion)\n    if (? %8: Abrupt) return %8\n    else %8 = %8.Value\n    j = (+ j 1)\n  }\n  nop\n  while (< j len) {\n    call %9 = clo<\"ToString\">(([number] j))\n    assert (? %9: Normal)\n    %9 = %9.Value\n    call %10 = clo<\"DeletePropertyOrThrow\">(obj, %9)\n    assert (? %10: Completion)\n    if (? %10: Abrupt) return %10\n    else %10 = %10.Value\n    j = (+ j 1)\n  }\n  if (? obj: Completion) return obj\n  call %11 = clo<\"NormalCompletion\">(obj)\n  return %11\n}","def SortIndexedProperties(\n  obj: Record[Object],\n  len: NonNegInt,\n  SortCompare: Unknown[\"AbstractClosureWithTwoParameter\"],\n  holes: Enum[~read-through-holes~, ~skip-holes~],\n): Normal[List[ESValue]] | Throw = {\n  let items = (list [])[#1121]\n  let k = 0\n  while (< k len) {\n    call %0 = clo<\"ToString\">(([number] k))\n    assert (? %0: Normal)\n    %0 = %0.Value\n    let Pk = %0\n    if (= holes ~skip-holes~) {\n      call %1 = clo<\"HasProperty\">(obj, Pk)\n      assert (? %1: Completion)\n      if (? %1: Abrupt) return %1\n      else %1 = %1.Value\n      let kRead = %1\n    } else {\n      assert (= holes ~read-through-holes~)\n      let kRead = true\n    }\n    if (= kRead true) {\n      call %2 = clo<\"Get\">(obj, Pk)\n      assert (? %2: Completion)\n      if (? %2: Abrupt) return %2\n      else %2 = %2.Value\n      let kValue = %2\n      push items < kValue\n    }\n    k = (+ k 1)\n  }\n  (yet \"Sort _items_ using an implementation-defined sequence of <emu-meta effects=\\\"user-code\\\">calls to _SortCompare_</emu-meta>. If any such call returns an abrupt completion, stop before performing any further calls to _SortCompare_ and return that Completion Record.\")\n  if (? items: Completion) return items\n  call %3 = clo<\"NormalCompletion\">(items)\n  return %3\n}","def CompareArrayElements(\n  x: ESValue,\n  y: ESValue,\n  comparefn: Record[FunctionObject] | Undefined,\n): Normal[Number] | Abrupt = {\n  if (&& (= x undefined) (= y undefined)) {\n    call %0 = clo<\"NormalCompletion\">(0.0f)\n    return %0\n  }\n  if (= x undefined) {\n    call %1 = clo<\"NormalCompletion\">(1.0f)\n    return %1\n  }\n  if (= y undefined) {\n    call %2 = clo<\"NormalCompletion\">(-1.0f)\n    return %2\n  }\n  if (! (= comparefn undefined)) {\n    call %3 = clo<\"Call\">(comparefn, undefined, (list [x, y])[#1122])\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    call %4 = clo<\"ToNumber\">(%3)\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    let v = %4\n    if (= v NaN) {\n      call %5 = clo<\"NormalCompletion\">(0.0f)\n      return %5\n    }\n    if (? v: Completion) return v\n    call %6 = clo<\"NormalCompletion\">(v)\n    return %6\n  }\n  call %7 = clo<\"ToString\">(x)\n  assert (? %7: Completion)\n  if (? %7: Abrupt) return %7\n  else %7 = %7.Value\n  let xString = %7\n  call %8 = clo<\"ToString\">(y)\n  assert (? %8: Completion)\n  if (? %8: Abrupt) return %8\n  else %8 = %8.Value\n  let yString = %8\n  call %9 = clo<\"IsLessThan\">(xString, yString, true)\n  assert (? %9: Normal)\n  %9 = %9.Value\n  let xSmaller = %9\n  if (= xSmaller true) {\n    call %10 = clo<\"NormalCompletion\">(-1.0f)\n    return %10\n  }\n  call %11 = clo<\"IsLessThan\">(yString, xString, true)\n  assert (? %11: Normal)\n  %11 = %11.Value\n  let ySmaller = %11\n  if (= ySmaller true) {\n    call %12 = clo<\"NormalCompletion\">(1.0f)\n    return %12\n  }\n  call %13 = clo<\"NormalCompletion\">(0.0f)\n  return %13\n}","def <BUILTIN>:INTRINSICS.Array.prototype.splice(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1123]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop start < ArgumentsList\n    expand __args__.start\n  } else let start = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop deleteCount < ArgumentsList\n    expand __args__.deleteCount\n  } else let deleteCount = undefined\n  let items = ArgumentsList\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let len = %1\n  call %2 = clo<\"ToIntegerOrInfinity\">(start)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let relativeStart = %2\n  if (== relativeStart -INF) {\n    let actualStart = 0\n  } else {\n    if (< relativeStart 0) {\n      let actualStart = (max (+ len relativeStart) 0)\n    } else {\n      let actualStart = (min relativeStart len)\n    }\n  }\n  let itemCount = (sizeof items)\n  if (! (exists __args__.start)) {\n    let actualDeleteCount = 0\n  } else {\n    if (! (exists __args__.deleteCount)) {\n      let actualDeleteCount = (- len actualStart)\n    } else {\n      call %3 = clo<\"ToIntegerOrInfinity\">(deleteCount)\n      assert (? %3: Completion)\n      if (? %3: Abrupt) return %3\n      else %3 = %3.Value\n      let dc = %3\n      call %4 = clo<\"__CLAMP__\">(dc, 0, (- len actualStart))\n      let actualDeleteCount = %4\n    }\n  }\n  if (< (- (** 2 53) 1) (- (+ len itemCount) actualDeleteCount)) {\n    call %5 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %6 = clo<\"ThrowCompletion\">(%5)\n    return %6\n  }\n  call %7 = clo<\"ArraySpeciesCreate\">(O, actualDeleteCount)\n  assert (? %7: Completion)\n  if (? %7: Abrupt) return %7\n  else %7 = %7.Value\n  let A = %7\n  let k = 0\n  while (< k actualDeleteCount) {\n    call %8 = clo<\"ToString\">(([number] (+ actualStart k)))\n    assert (? %8: Normal)\n    %8 = %8.Value\n    let from = %8\n    call %9 = clo<\"HasProperty\">(O, from)\n    assert (? %9: Completion)\n    if (? %9: Abrupt) return %9\n    else %9 = %9.Value\n    if (= %9 true) {\n      call %10 = clo<\"Get\">(O, from)\n      assert (? %10: Completion)\n      if (? %10: Abrupt) return %10\n      else %10 = %10.Value\n      let fromValue = %10\n      call %11 = clo<\"ToString\">(([number] k))\n      assert (? %11: Normal)\n      %11 = %11.Value\n      call %12 = clo<\"CreateDataPropertyOrThrow\">(A, %11, fromValue)\n      assert (? %12: Completion)\n      if (? %12: Abrupt) return %12\n      else %12 = %12.Value\n    }\n    k = (+ k 1)\n  }\n  call %13 = clo<\"Set\">(A, \"length\", ([number] actualDeleteCount), true)\n  assert (? %13: Completion)\n  if (? %13: Abrupt) return %13\n  else %13 = %13.Value\n  if (< itemCount actualDeleteCount) {\n    k = actualStart\n    while (< k (- len actualDeleteCount)) {\n      call %14 = clo<\"ToString\">(([number] (+ k actualDeleteCount)))\n      assert (? %14: Normal)\n      %14 = %14.Value\n      let from = %14\n      call %15 = clo<\"ToString\">(([number] (+ k itemCount)))\n      assert (? %15: Normal)\n      %15 = %15.Value\n      let to = %15\n      call %16 = clo<\"HasProperty\">(O, from)\n      assert (? %16: Completion)\n      if (? %16: Abrupt) return %16\n      else %16 = %16.Value\n      if (= %16 true) {\n        call %17 = clo<\"Get\">(O, from)\n        assert (? %17: Completion)\n        if (? %17: Abrupt) return %17\n        else %17 = %17.Value\n        let fromValue = %17\n        call %18 = clo<\"Set\">(O, to, fromValue, true)\n        assert (? %18: Completion)\n        if (? %18: Abrupt) return %18\n        else %18 = %18.Value\n      } else {\n        call %19 = clo<\"DeletePropertyOrThrow\">(O, to)\n        assert (? %19: Completion)\n        if (? %19: Abrupt) return %19\n        else %19 = %19.Value\n      }\n      k = (+ k 1)\n    }\n    k = len\n    while (< (+ (- len actualDeleteCount) itemCount) k) {\n      call %20 = clo<\"ToString\">(([number] (- k 1)))\n      assert (? %20: Normal)\n      %20 = %20.Value\n      call %21 = clo<\"DeletePropertyOrThrow\">(O, %20)\n      assert (? %21: Completion)\n      if (? %21: Abrupt) return %21\n      else %21 = %21.Value\n      k = (- k 1)\n    }\n  } else {\n    if (< actualDeleteCount itemCount) {\n      k = (- len actualDeleteCount)\n      while (< actualStart k) {\n        call %22 = clo<\"ToString\">(([number] (- (+ k actualDeleteCount) 1)))\n        assert (? %22: Normal)\n        %22 = %22.Value\n        let from = %22\n        call %23 = clo<\"ToString\">(([number] (- (+ k itemCount) 1)))\n        assert (? %23: Normal)\n        %23 = %23.Value\n        let to = %23\n        call %24 = clo<\"HasProperty\">(O, from)\n        assert (? %24: Completion)\n        if (? %24: Abrupt) return %24\n        else %24 = %24.Value\n        if (= %24 true) {\n          call %25 = clo<\"Get\">(O, from)\n          assert (? %25: Completion)\n          if (? %25: Abrupt) return %25\n          else %25 = %25.Value\n          let fromValue = %25\n          call %26 = clo<\"Set\">(O, to, fromValue, true)\n          assert (? %26: Completion)\n          if (? %26: Abrupt) return %26\n          else %26 = %26.Value\n        } else {\n          call %27 = clo<\"DeletePropertyOrThrow\">(O, to)\n          assert (? %27: Completion)\n          if (? %27: Abrupt) return %27\n          else %27 = %27.Value\n        }\n        k = (- k 1)\n      }\n    }\n  }\n  k = actualStart\n  %29 = items\n  %28 = 0\n  while (< %28 (sizeof %29)) {\n    let E = %29[%28]\n    call %30 = clo<\"ToString\">(([number] k))\n    assert (? %30: Normal)\n    %30 = %30.Value\n    call %31 = clo<\"Set\">(O, %30, E, true)\n    assert (? %31: Completion)\n    if (? %31: Abrupt) return %31\n    else %31 = %31.Value\n    k = (+ k 1)\n    %28 = (+ %28 1)\n  }\n  call %32 = clo<\"Set\">(O, \"length\", ([number] (+ (- len actualDeleteCount) itemCount)), true)\n  assert (? %32: Completion)\n  if (? %32: Abrupt) return %32\n  else %32 = %32.Value\n  if (? A: Completion) return A\n  call %33 = clo<\"NormalCompletion\">(A)\n  return %33\n}","def <BUILTIN>:INTRINSICS.Array.prototype.toLocaleString(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1124]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop reserved1 < ArgumentsList\n    expand __args__.reserved1\n  } else let reserved1 = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop reserved2 < ArgumentsList\n    expand __args__.reserved2\n  } else let reserved2 = undefined\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let array = %0\n  call %1 = clo<\"LengthOfArrayLike\">(array)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let len = %1\n  (yet \"Let _separator_ be the implementation-defined list-separator String value appropriate for the host environment's current locale (such as *\\\", \\\"*).\")\n  let R = \"\"\n  let k = 0\n  while (< k len) {\n    if (< 0 k) {\n      R = (concat R separator)\n    }\n    call %2 = clo<\"ToString\">(([number] k))\n    assert (? %2: Normal)\n    %2 = %2.Value\n    call %3 = clo<\"Get\">(array, %2)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let nextElement = %3\n    if (! (|| (= nextElement undefined) (= nextElement null))) {\n      call %4 = clo<\"Invoke\">(nextElement, \"toLocaleString\")\n      assert (? %4: Completion)\n      if (? %4: Abrupt) return %4\n      else %4 = %4.Value\n      call %5 = clo<\"ToString\">(%4)\n      assert (? %5: Completion)\n      if (? %5: Abrupt) return %5\n      else %5 = %5.Value\n      let S = %5\n      R = (concat R S)\n    }\n    k = (+ k 1)\n  }\n  if (? R: Completion) return R\n  call %6 = clo<\"NormalCompletion\">(R)\n  return %6\n}","def <BUILTIN>:INTRINSICS.Array.prototype.toReversed(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1125]\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let len = %1\n  call %2 = clo<\"ArrayCreate\">(len)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let A = %2\n  let k = 0\n  while (< k len) {\n    call %3 = clo<\"ToString\">(([number] (- (- len k) 1)))\n    assert (? %3: Normal)\n    %3 = %3.Value\n    let from = %3\n    call %4 = clo<\"ToString\">(([number] k))\n    assert (? %4: Normal)\n    %4 = %4.Value\n    let Pk = %4\n    call %5 = clo<\"Get\">(O, from)\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n    let fromValue = %5\n    call %6 = clo<\"CreateDataPropertyOrThrow\">(A, Pk, fromValue)\n    assert (? %6: Normal)\n    %6 = %6.Value\n    k = (+ k 1)\n  }\n  if (? A: Completion) return A\n  call %7 = clo<\"NormalCompletion\">(A)\n  return %7\n}","def <CLO>:INTRINSICS.Array.prototype.toSorted:clo0(\n  x: Unknown,\n  y: Unknown,\n): Unknown = {\n  call %0 = clo<\"CompareArrayElements\">(x, y, comparefn)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.Array.prototype.toSorted(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1126]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop comparefn < ArgumentsList\n    expand __args__.comparefn\n  } else let comparefn = undefined\n  %0 = (! (= comparefn undefined))\n  if %0 {\n    call %1 = clo<\"IsCallable\">(comparefn)\n    %0 = (= %1 false)\n  }\n  if %0 {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  call %4 = clo<\"ToObject\">(this)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let O = %4\n  call %5 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  let len = %5\n  call %6 = clo<\"ArrayCreate\">(len)\n  assert (? %6: Completion)\n  if (? %6: Abrupt) return %6\n  else %6 = %6.Value\n  let A = %6\n  let SortCompare = clo<\"INTRINSICS.Array.prototype.toSorted:clo0\", [comparefn]>\n  call %7 = clo<\"SortIndexedProperties\">(O, len, SortCompare, ~read-through-holes~)\n  assert (? %7: Completion)\n  if (? %7: Abrupt) return %7\n  else %7 = %7.Value\n  let sortedList = %7\n  let j = 0\n  while (< j len) {\n    call %8 = clo<\"ToString\">(([number] j))\n    assert (? %8: Normal)\n    %8 = %8.Value\n    call %9 = clo<\"CreateDataPropertyOrThrow\">(A, %8, sortedList[j])\n    assert (? %9: Normal)\n    %9 = %9.Value\n    j = (+ j 1)\n  }\n  if (? A: Completion) return A\n  call %10 = clo<\"NormalCompletion\">(A)\n  return %10\n}","def <BUILTIN>:INTRINSICS.Array.prototype.toSpliced(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1127]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop start < ArgumentsList\n    expand __args__.start\n  } else let start = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop skipCount < ArgumentsList\n    expand __args__.skipCount\n  } else let skipCount = undefined\n  let items = ArgumentsList\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let len = %1\n  call %2 = clo<\"ToIntegerOrInfinity\">(start)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let relativeStart = %2\n  if (= relativeStart -INF) {\n    let actualStart = 0\n  } else {\n    if (< relativeStart 0) {\n      let actualStart = (max (+ len relativeStart) 0)\n    } else {\n      let actualStart = (min relativeStart len)\n    }\n  }\n  let insertCount = (sizeof items)\n  if (! (exists __args__.start)) {\n    let actualSkipCount = 0\n  } else {\n    if (! (exists __args__.skipCount)) {\n      let actualSkipCount = (- len actualStart)\n    } else {\n      call %3 = clo<\"ToIntegerOrInfinity\">(skipCount)\n      assert (? %3: Completion)\n      if (? %3: Abrupt) return %3\n      else %3 = %3.Value\n      let sc = %3\n      call %4 = clo<\"__CLAMP__\">(sc, 0, (- len actualStart))\n      let actualSkipCount = %4\n    }\n  }\n  let newLen = (- (+ len insertCount) actualSkipCount)\n  if (< (- (** 2 53) 1) newLen) {\n    call %5 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %6 = clo<\"ThrowCompletion\">(%5)\n    return %6\n  }\n  call %7 = clo<\"ArrayCreate\">(newLen)\n  assert (? %7: Completion)\n  if (? %7: Abrupt) return %7\n  else %7 = %7.Value\n  let A = %7\n  let i = 0\n  let r = (+ actualStart actualSkipCount)\n  while (< i actualStart) {\n    call %8 = clo<\"ToString\">(([number] i))\n    assert (? %8: Normal)\n    %8 = %8.Value\n    let Pi = %8\n    call %9 = clo<\"Get\">(O, Pi)\n    assert (? %9: Completion)\n    if (? %9: Abrupt) return %9\n    else %9 = %9.Value\n    let iValue = %9\n    call %10 = clo<\"CreateDataPropertyOrThrow\">(A, Pi, iValue)\n    assert (? %10: Normal)\n    %10 = %10.Value\n    i = (+ i 1)\n  }\n  %12 = items\n  %11 = 0\n  while (< %11 (sizeof %12)) {\n    let E = %12[%11]\n    call %13 = clo<\"ToString\">(([number] i))\n    assert (? %13: Normal)\n    %13 = %13.Value\n    let Pi = %13\n    call %14 = clo<\"CreateDataPropertyOrThrow\">(A, Pi, E)\n    assert (? %14: Normal)\n    %14 = %14.Value\n    i = (+ i 1)\n    %11 = (+ %11 1)\n  }\n  while (< i newLen) {\n    call %15 = clo<\"ToString\">(([number] i))\n    assert (? %15: Normal)\n    %15 = %15.Value\n    let Pi = %15\n    call %16 = clo<\"ToString\">(([number] r))\n    assert (? %16: Normal)\n    %16 = %16.Value\n    let from = %16\n    call %17 = clo<\"Get\">(O, from)\n    assert (? %17: Completion)\n    if (? %17: Abrupt) return %17\n    else %17 = %17.Value\n    let fromValue = %17\n    call %18 = clo<\"CreateDataPropertyOrThrow\">(A, Pi, fromValue)\n    assert (? %18: Normal)\n    %18 = %18.Value\n    i = (+ i 1)\n    r = (+ r 1)\n  }\n  if (? A: Completion) return A\n  call %19 = clo<\"NormalCompletion\">(A)\n  return %19\n}","def <BUILTIN>:INTRINSICS.Array.prototype.toString(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1128]\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let array = %0\n  call %1 = clo<\"Get\">(array, \"join\")\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let func = %1\n  call %2 = clo<\"IsCallable\">(func)\n  if (= %2 false) {\n    func = @EXECUTION_STACK[0].Realm.Intrinsics[\"%Object.prototype.toString%\"]\n  }\n  call %3 = clo<\"Call\">(func, array)\n  assert (? %3: Completion)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Array.prototype.unshift(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1129]\n  let items = ArgumentsList\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let len = %1\n  let argCount = (sizeof items)\n  if (< 0 argCount) {\n    if (< (- (** 2 53) 1) (+ len argCount)) {\n      call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %3 = clo<\"ThrowCompletion\">(%2)\n      return %3\n    }\n    let k = len\n    while (< 0 k) {\n      call %4 = clo<\"ToString\">(([number] (- k 1)))\n      assert (? %4: Normal)\n      %4 = %4.Value\n      let from = %4\n      call %5 = clo<\"ToString\">(([number] (- (+ k argCount) 1)))\n      assert (? %5: Normal)\n      %5 = %5.Value\n      let to = %5\n      call %6 = clo<\"HasProperty\">(O, from)\n      assert (? %6: Completion)\n      if (? %6: Abrupt) return %6\n      else %6 = %6.Value\n      let fromPresent = %6\n      if (= fromPresent true) {\n        call %7 = clo<\"Get\">(O, from)\n        assert (? %7: Completion)\n        if (? %7: Abrupt) return %7\n        else %7 = %7.Value\n        let fromValue = %7\n        call %8 = clo<\"Set\">(O, to, fromValue, true)\n        assert (? %8: Completion)\n        if (? %8: Abrupt) return %8\n        else %8 = %8.Value\n      } else {\n        assert (= fromPresent false)\n        call %9 = clo<\"DeletePropertyOrThrow\">(O, to)\n        assert (? %9: Completion)\n        if (? %9: Abrupt) return %9\n        else %9 = %9.Value\n      }\n      k = (- k 1)\n    }\n    let j = 0.0f\n    %11 = items\n    %10 = 0\n    while (< %10 (sizeof %11)) {\n      let E = %11[%10]\n      call %12 = clo<\"ToString\">(j)\n      assert (? %12: Normal)\n      %12 = %12.Value\n      call %13 = clo<\"Set\">(O, %12, E, true)\n      assert (? %13: Completion)\n      if (? %13: Abrupt) return %13\n      else %13 = %13.Value\n      j = (+ j 1.0f)\n      %10 = (+ %10 1)\n    }\n  }\n  call %14 = clo<\"Set\">(O, \"length\", ([number] (+ len argCount)), true)\n  assert (? %14: Completion)\n  if (? %14: Abrupt) return %14\n  else %14 = %14.Value\n  %15 = ([number] (+ len argCount))\n  if (? %15: Completion) return %15\n  call %16 = clo<\"NormalCompletion\">(%15)\n  return %16\n}","def <BUILTIN>:INTRINSICS.Array.prototype.values(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1130]\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"CreateArrayIterator\">(O, ~value~)\n  if (? %1: Completion) return %1\n  call %2 = clo<\"NormalCompletion\">(%1)\n  return %2\n}","def <BUILTIN>:INTRINSICS.Array.prototype.with(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1131]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop index < ArgumentsList\n    expand __args__.index\n  } else let index = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  call %0 = clo<\"ToObject\">(this)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let O = %0\n  call %1 = clo<\"LengthOfArrayLike\">(O)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let len = %1\n  call %2 = clo<\"ToIntegerOrInfinity\">(index)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let relativeIndex = %2\n  if (! (< relativeIndex 0)) {\n    let actualIndex = relativeIndex\n  } else {\n    let actualIndex = (+ len relativeIndex)\n  }\n  if (|| (! (< actualIndex len)) (< actualIndex 0)) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  call %5 = clo<\"ArrayCreate\">(len)\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  let A = %5\n  let k = 0\n  while (< k len) {\n    call %6 = clo<\"ToString\">(([number] k))\n    assert (? %6: Normal)\n    %6 = %6.Value\n    let Pk = %6\n    if (= k actualIndex) {\n      let fromValue = value\n    } else {\n      call %7 = clo<\"Get\">(O, Pk)\n      assert (? %7: Completion)\n      if (? %7: Abrupt) return %7\n      else %7 = %7.Value\n      let fromValue = %7\n    }\n    call %8 = clo<\"CreateDataPropertyOrThrow\">(A, Pk, fromValue)\n    assert (? %8: Normal)\n    %8 = %8.Value\n    k = (+ k 1)\n  }\n  if (? A: Completion) return A\n  call %9 = clo<\"NormalCompletion\">(A)\n  return %9\n}","def <CLO>:CreateArrayIterator:clo0(\n): Unknown = {\n  let index = 0\n  while true {\n    if (exists array.TypedArrayName) {\n      call %0 = clo<\"MakeTypedArrayWithBufferWitnessRecord\">(array, ~seq-cst~)\n      let taRecord = %0\n      call %1 = clo<\"IsTypedArrayOutOfBounds\">(taRecord)\n      if (= %1 true) {\n        call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n        call %3 = clo<\"ThrowCompletion\">(%2)\n        return %3\n      }\n      call %4 = clo<\"TypedArrayLength\">(taRecord)\n      let len = %4\n    } else {\n      call %5 = clo<\"LengthOfArrayLike\">(array)\n      assert (? %5: Completion)\n      if (? %5: Abrupt) return %5\n      else %5 = %5.Value\n      let len = %5\n    }\n    if (! (< index len)) {\n      call %6 = clo<\"NormalCompletion\">(undefined)\n      if (? %6: Completion) return %6\n      call %7 = clo<\"NormalCompletion\">(%6)\n      return %7\n    }\n    let indexNumber = ([number] index)\n    if (= kind ~key~) {\n      let result = indexNumber\n    } else {\n      call %8 = clo<\"ToString\">(indexNumber)\n      assert (? %8: Normal)\n      %8 = %8.Value\n      let elementKey = %8\n      call %9 = clo<\"Get\">(array, elementKey)\n      assert (? %9: Completion)\n      if (? %9: Abrupt) return %9\n      else %9 = %9.Value\n      let elementValue = %9\n      if (= kind ~value~) {\n        let result = elementValue\n      } else {\n        assert (= kind ~key+value~)\n        call %10 = clo<\"CreateArrayFromList\">((list [indexNumber, elementValue])[#1132])\n        let result = %10\n      }\n    }\n    call %11 = clo<\"CreateIterResultObject\">(result, false)\n    call %12 = clo<\"GeneratorYield\">(%11)\n    assert (? %12: Completion)\n    if (? %12: Abrupt) return %12\n    else %12 = %12.Value\n    index = (+ index 1)\n  }\n}","def CreateArrayIterator(\n  array: Record[Object],\n  kind: Enum[~key+value~, ~key~, ~value~],\n): Record[Generator] = {\n  let closure = clo<\"CreateArrayIterator:clo0\", [kind, array]>\n  call %0 = clo<\"CreateIteratorFromClosure\">(closure, \"%ArrayIteratorPrototype%\", @EXECUTION_STACK[0].Realm.Intrinsics[\"%ArrayIteratorPrototype%\"])\n  return %0\n}","def <BUILTIN>:INTRINSICS.ArrayIteratorPrototype.next(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1133]\n  call %0 = clo<\"GeneratorResume\">(this, ~empty~, \"%ArrayIteratorPrototype%\")\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.TypedArray(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1134]\n  call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n  call %1 = clo<\"ThrowCompletion\">(%0)\n  return %1\n}","def <BUILTIN>:INTRINSICS.TypedArray.from(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1135]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop source < ArgumentsList\n    expand __args__.source\n  } else let source = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop mapfn < ArgumentsList\n    expand __args__.mapfn\n  } else let mapfn = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop thisArg < ArgumentsList\n    expand __args__.thisArg\n  } else let thisArg = undefined\n  let C = this\n  call %0 = clo<\"IsConstructor\">(C)\n  if (= %0 false) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  if (= mapfn undefined) {\n    let mapping = false\n  } else {\n    call %3 = clo<\"IsCallable\">(mapfn)\n    if (= %3 false) {\n      call %4 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %5 = clo<\"ThrowCompletion\">(%4)\n      return %5\n    }\n    let mapping = true\n  }\n  call %6 = clo<\"GetMethod\">(source, @SYMBOL.iterator)\n  assert (? %6: Completion)\n  if (? %6: Abrupt) return %6\n  else %6 = %6.Value\n  let usingIterator = %6\n  if (! (= usingIterator undefined)) {\n    call %7 = clo<\"GetIteratorFromMethod\">(source, usingIterator)\n    assert (? %7: Completion)\n    if (? %7: Abrupt) return %7\n    else %7 = %7.Value\n    call %8 = clo<\"IteratorToList\">(%7)\n    assert (? %8: Completion)\n    if (? %8: Abrupt) return %8\n    else %8 = %8.Value\n    let values = %8\n    let len = (sizeof values)\n    call %9 = clo<\"TypedArrayCreateFromConstructor\">(C, (list [([number] len)])[#1136])\n    assert (? %9: Completion)\n    if (? %9: Abrupt) return %9\n    else %9 = %9.Value\n    let targetObj = %9\n    let k = 0\n    while (< k len) {\n      call %10 = clo<\"ToString\">(([number] k))\n      assert (? %10: Normal)\n      %10 = %10.Value\n      let Pk = %10\n      let kValue = values[0]\n      pop %11 < values\n      if (= mapping true) {\n        call %12 = clo<\"Call\">(mapfn, thisArg, (list [kValue, ([number] k)])[#1137])\n        assert (? %12: Completion)\n        if (? %12: Abrupt) return %12\n        else %12 = %12.Value\n        let mappedValue = %12\n      } else {\n        let mappedValue = kValue\n      }\n      call %13 = clo<\"Set\">(targetObj, Pk, mappedValue, true)\n      assert (? %13: Completion)\n      if (? %13: Abrupt) return %13\n      else %13 = %13.Value\n      k = (+ k 1)\n    }\n    assert (yet \"_values_ is now an empty List.\")\n    if (? targetObj: Completion) return targetObj\n    call %14 = clo<\"NormalCompletion\">(targetObj)\n    return %14\n  }\n  nop\n  call %15 = clo<\"ToObject\">(source)\n  assert (? %15: Normal)\n  %15 = %15.Value\n  let arrayLike = %15\n  call %16 = clo<\"LengthOfArrayLike\">(arrayLike)\n  assert (? %16: Completion)\n  if (? %16: Abrupt) return %16\n  else %16 = %16.Value\n  let len = %16\n  call %17 = clo<\"TypedArrayCreateFromConstructor\">(C, (list [([number] len)])[#1138])\n  assert (? %17: Completion)\n  if (? %17: Abrupt) return %17\n  else %17 = %17.Value\n  let targetObj = %17\n  let k = 0\n  while (< k len) {\n    call %18 = clo<\"ToString\">(([number] k))\n    assert (? %18: Normal)\n    %18 = %18.Value\n    let Pk = %18\n    call %19 = clo<\"Get\">(arrayLike, Pk)\n    assert (? %19: Completion)\n    if (? %19: Abrupt) return %19\n    else %19 = %19.Value\n    let kValue = %19\n    if (= mapping true) {\n      call %20 = clo<\"Call\">(mapfn, thisArg, (list [kValue, ([number] k)])[#1139])\n      assert (? %20: Completion)\n      if (? %20: Abrupt) return %20\n      else %20 = %20.Value\n      let mappedValue = %20\n    } else {\n      let mappedValue = kValue\n    }\n    call %21 = clo<\"Set\">(targetObj, Pk, mappedValue, true)\n    assert (? %21: Completion)\n    if (? %21: Abrupt) return %21\n    else %21 = %21.Value\n    k = (+ k 1)\n  }\n  if (? targetObj: Completion) return targetObj\n  call %22 = clo<\"NormalCompletion\">(targetObj)\n  return %22\n}","def <BUILTIN>:INTRINSICS.TypedArray.of(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1140]\n  let items = ArgumentsList\n  let len = (sizeof items)\n  let C = this\n  call %0 = clo<\"IsConstructor\">(C)\n  if (= %0 false) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  call %3 = clo<\"TypedArrayCreateFromConstructor\">(C, (list [([number] len)])[#1141])\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let newObj = %3\n  let k = 0\n  while (< k len) {\n    let kValue = items[k]\n    call %4 = clo<\"ToString\">(([number] k))\n    assert (? %4: Normal)\n    %4 = %4.Value\n    let Pk = %4\n    call %5 = clo<\"Set\">(newObj, Pk, kValue, true)\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n    k = (+ k 1)\n  }\n  if (? newObj: Completion) return newObj\n  call %6 = clo<\"NormalCompletion\">(newObj)\n  return %6\n}","def <BUILTIN>:INTRINSICS.get TypedArray[@@species](\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1142]\n  if (? this: Completion) return this\n  call %0 = clo<\"NormalCompletion\">(this)\n  return %0\n}","def <BUILTIN>:INTRINSICS.TypedArray.prototype.at(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1143]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop index < ArgumentsList\n    expand __args__.index\n  } else let index = undefined\n  let O = this\n  call %0 = clo<\"ValidateTypedArray\">(O, ~seq-cst~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let taRecord = %0\n  call %1 = clo<\"TypedArrayLength\">(taRecord)\n  let len = %1\n  call %2 = clo<\"ToIntegerOrInfinity\">(index)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let relativeIndex = %2\n  if (! (< relativeIndex 0)) {\n    let k = relativeIndex\n  } else {\n    let k = (+ len relativeIndex)\n  }\n  if (|| (< k 0) (! (< k len))) {\n    call %3 = clo<\"NormalCompletion\">(undefined)\n    return %3\n  }\n  call %4 = clo<\"ToString\">(([number] k))\n  assert (? %4: Normal)\n  %4 = %4.Value\n  call %5 = clo<\"Get\">(O, %4)\n  assert (? %5: Normal)\n  return %5\n}","def <BUILTIN>:INTRINSICS.get TypedArray.prototype.buffer(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1144]\n  let O = this\n  call %0 = clo<\"RequireInternalSlot\">(O, \"TypedArrayName\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  assert (exists O.ViewedArrayBuffer)\n  let buffer = O.ViewedArrayBuffer\n  if (? buffer: Completion) return buffer\n  call %1 = clo<\"NormalCompletion\">(buffer)\n  return %1\n}","def <BUILTIN>:INTRINSICS.get TypedArray.prototype.byteLength(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1145]\n  let O = this\n  call %0 = clo<\"RequireInternalSlot\">(O, \"TypedArrayName\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  assert (exists O.ViewedArrayBuffer)\n  call %1 = clo<\"MakeTypedArrayWithBufferWitnessRecord\">(O, ~seq-cst~)\n  let taRecord = %1\n  call %2 = clo<\"TypedArrayByteLength\">(taRecord)\n  let size = %2\n  %3 = ([number] size)\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.get TypedArray.prototype.byteOffset(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1146]\n  let O = this\n  call %0 = clo<\"RequireInternalSlot\">(O, \"TypedArrayName\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  assert (exists O.ViewedArrayBuffer)\n  call %1 = clo<\"MakeTypedArrayWithBufferWitnessRecord\">(O, ~seq-cst~)\n  let taRecord = %1\n  call %2 = clo<\"IsTypedArrayOutOfBounds\">(taRecord)\n  if (= %2 true) {\n    call %3 = clo<\"NormalCompletion\">(0.0f)\n    return %3\n  }\n  let offset = O.ByteOffset\n  %4 = ([number] offset)\n  if (? %4: Completion) return %4\n  call %5 = clo<\"NormalCompletion\">(%4)\n  return %5\n}","def <BUILTIN>:INTRINSICS.TypedArray.prototype.copyWithin(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1147]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop target < ArgumentsList\n    expand __args__.target\n  } else let target = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop start < ArgumentsList\n    expand __args__.start\n  } else let start = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop end < ArgumentsList\n    expand __args__.end\n  } else let end = undefined\n  let O = this\n  call %0 = clo<\"ValidateTypedArray\">(O, ~seq-cst~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let taRecord = %0\n  call %1 = clo<\"TypedArrayLength\">(taRecord)\n  let len = %1\n  call %2 = clo<\"ToIntegerOrInfinity\">(target)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let relativeTarget = %2\n  if (== relativeTarget -INF) {\n    let targetIndex = 0\n  } else {\n    if (< relativeTarget 0) {\n      let targetIndex = (max (+ len relativeTarget) 0)\n    } else {\n      let targetIndex = (min relativeTarget len)\n    }\n  }\n  call %3 = clo<\"ToIntegerOrInfinity\">(start)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let relativeStart = %3\n  if (== relativeStart -INF) {\n    let startIndex = 0\n  } else {\n    if (< relativeStart 0) {\n      let startIndex = (max (+ len relativeStart) 0)\n    } else {\n      let startIndex = (min relativeStart len)\n    }\n  }\n  if (= end undefined) {\n    let relativeEnd = len\n  } else {\n    call %4 = clo<\"ToIntegerOrInfinity\">(end)\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    let relativeEnd = %4\n  }\n  if (== relativeEnd -INF) {\n    let endIndex = 0\n  } else {\n    if (< relativeEnd 0) {\n      let endIndex = (max (+ len relativeEnd) 0)\n    } else {\n      let endIndex = (min relativeEnd len)\n    }\n  }\n  let count = (min (- endIndex startIndex) (- len targetIndex))\n  if (< 0 count) {\n    nop\n    let buffer = O.ViewedArrayBuffer\n    call %5 = clo<\"MakeTypedArrayWithBufferWitnessRecord\">(O, ~seq-cst~)\n    taRecord = %5\n    call %6 = clo<\"IsTypedArrayOutOfBounds\">(taRecord)\n    if (= %6 true) {\n      call %7 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %8 = clo<\"ThrowCompletion\">(%7)\n      return %8\n    }\n    call %9 = clo<\"TypedArrayLength\">(taRecord)\n    len = %9\n    call %10 = clo<\"TypedArrayElementSize\">(O)\n    let elementSize = %10\n    let byteOffset = O.ByteOffset\n    let bufferByteLimit = (+ (* len elementSize) byteOffset)\n    let toByteIndex = (+ (* targetIndex elementSize) byteOffset)\n    let fromByteIndex = (+ (* startIndex elementSize) byteOffset)\n    let countBytes = (* count elementSize)\n    if (&& (< fromByteIndex toByteIndex) (< toByteIndex (+ fromByteIndex countBytes))) {\n      let direction = (- 1)\n      fromByteIndex = (- (+ fromByteIndex countBytes) 1)\n      toByteIndex = (- (+ toByteIndex countBytes) 1)\n    } else {\n      let direction = 1\n    }\n    while (< 0 countBytes) {\n      if (&& (< fromByteIndex bufferByteLimit) (< toByteIndex bufferByteLimit)) {\n        call %11 = clo<\"GetValueFromBuffer\">(buffer, fromByteIndex, ~uint8~, true, ~unordered~)\n        let value = %11\n        call %12 = clo<\"SetValueInBuffer\">(buffer, toByteIndex, ~uint8~, value, true, ~unordered~)\n        fromByteIndex = (+ fromByteIndex direction)\n        toByteIndex = (+ toByteIndex direction)\n        countBytes = (- countBytes 1)\n      } else {\n        countBytes = 0\n      }\n    }\n  }\n  if (? O: Completion) return O\n  call %13 = clo<\"NormalCompletion\">(O)\n  return %13\n}","def <BUILTIN>:INTRINSICS.TypedArray.prototype.entries(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1148]\n  let O = this\n  call %0 = clo<\"ValidateTypedArray\">(O, ~seq-cst~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"CreateArrayIterator\">(O, ~key+value~)\n  if (? %1: Completion) return %1\n  call %2 = clo<\"NormalCompletion\">(%1)\n  return %2\n}","def <BUILTIN>:INTRINSICS.TypedArray.prototype.every(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1149]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop callbackfn < ArgumentsList\n    expand __args__.callbackfn\n  } else let callbackfn = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop thisArg < ArgumentsList\n    expand __args__.thisArg\n  } else let thisArg = undefined\n  let O = this\n  call %0 = clo<\"ValidateTypedArray\">(O, ~seq-cst~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let taRecord = %0\n  call %1 = clo<\"TypedArrayLength\">(taRecord)\n  let len = %1\n  call %2 = clo<\"IsCallable\">(callbackfn)\n  if (= %2 false) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  let k = 0\n  while (< k len) {\n    call %5 = clo<\"ToString\">(([number] k))\n    assert (? %5: Normal)\n    %5 = %5.Value\n    let Pk = %5\n    call %6 = clo<\"Get\">(O, Pk)\n    assert (? %6: Normal)\n    %6 = %6.Value\n    let kValue = %6\n    call %7 = clo<\"Call\">(callbackfn, thisArg, (list [kValue, ([number] k), O])[#1150])\n    assert (? %7: Completion)\n    if (? %7: Abrupt) return %7\n    else %7 = %7.Value\n    call %8 = clo<\"ToBoolean\">(%7)\n    let testResult = %8\n    if (= testResult false) {\n      call %9 = clo<\"NormalCompletion\">(false)\n      return %9\n    }\n    k = (+ k 1)\n  }\n  call %10 = clo<\"NormalCompletion\">(true)\n  return %10\n}","def <BUILTIN>:INTRINSICS.TypedArray.prototype.fill(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1151]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop start < ArgumentsList\n    expand __args__.start\n  } else let start = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop end < ArgumentsList\n    expand __args__.end\n  } else let end = undefined\n  let O = this\n  call %0 = clo<\"ValidateTypedArray\">(O, ~seq-cst~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let taRecord = %0\n  call %1 = clo<\"TypedArrayLength\">(taRecord)\n  let len = %1\n  if (= O.ContentType ~bigint~) {\n    call %2 = clo<\"ToBigInt\">(value)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    value = %2\n  } else {\n    call %3 = clo<\"ToNumber\">(value)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    value = %3\n  }\n  call %4 = clo<\"ToIntegerOrInfinity\">(start)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let relativeStart = %4\n  if (== relativeStart -INF) {\n    let startIndex = 0\n  } else {\n    if (< relativeStart 0) {\n      let startIndex = (max (+ len relativeStart) 0)\n    } else {\n      let startIndex = (min relativeStart len)\n    }\n  }\n  if (= end undefined) {\n    let relativeEnd = len\n  } else {\n    call %5 = clo<\"ToIntegerOrInfinity\">(end)\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n    let relativeEnd = %5\n  }\n  if (== relativeEnd -INF) {\n    let endIndex = 0\n  } else {\n    if (< relativeEnd 0) {\n      let endIndex = (max (+ len relativeEnd) 0)\n    } else {\n      let endIndex = (min relativeEnd len)\n    }\n  }\n  call %6 = clo<\"MakeTypedArrayWithBufferWitnessRecord\">(O, ~seq-cst~)\n  taRecord = %6\n  call %7 = clo<\"IsTypedArrayOutOfBounds\">(taRecord)\n  if (= %7 true) {\n    call %8 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %9 = clo<\"ThrowCompletion\">(%8)\n    return %9\n  }\n  call %10 = clo<\"TypedArrayLength\">(taRecord)\n  len = %10\n  endIndex = (min endIndex len)\n  let k = startIndex\n  while (< k endIndex) {\n    call %11 = clo<\"ToString\">(([number] k))\n    assert (? %11: Normal)\n    %11 = %11.Value\n    let Pk = %11\n    call %12 = clo<\"Set\">(O, Pk, value, true)\n    assert (? %12: Normal)\n    %12 = %12.Value\n    k = (+ k 1)\n  }\n  if (? O: Completion) return O\n  call %13 = clo<\"NormalCompletion\">(O)\n  return %13\n}","def <BUILTIN>:INTRINSICS.TypedArray.prototype.filter(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1152]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop callbackfn < ArgumentsList\n    expand __args__.callbackfn\n  } else let callbackfn = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop thisArg < ArgumentsList\n    expand __args__.thisArg\n  } else let thisArg = undefined\n  let O = this\n  call %0 = clo<\"ValidateTypedArray\">(O, ~seq-cst~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let taRecord = %0\n  call %1 = clo<\"TypedArrayLength\">(taRecord)\n  let len = %1\n  call %2 = clo<\"IsCallable\">(callbackfn)\n  if (= %2 false) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  let kept = (list [])[#1153]\n  let captured = 0\n  let k = 0\n  while (< k len) {\n    call %5 = clo<\"ToString\">(([number] k))\n    assert (? %5: Normal)\n    %5 = %5.Value\n    let Pk = %5\n    call %6 = clo<\"Get\">(O, Pk)\n    assert (? %6: Normal)\n    %6 = %6.Value\n    let kValue = %6\n    call %7 = clo<\"Call\">(callbackfn, thisArg, (list [kValue, ([number] k), O])[#1154])\n    assert (? %7: Completion)\n    if (? %7: Abrupt) return %7\n    else %7 = %7.Value\n    call %8 = clo<\"ToBoolean\">(%7)\n    let selected = %8\n    if (= selected true) {\n      push kept < kValue\n      captured = (+ captured 1)\n    }\n    k = (+ k 1)\n  }\n  call %9 = clo<\"TypedArraySpeciesCreate\">(O, (list [([number] captured)])[#1155])\n  assert (? %9: Completion)\n  if (? %9: Abrupt) return %9\n  else %9 = %9.Value\n  let A = %9\n  let n = 0\n  %11 = kept\n  %10 = 0\n  while (< %10 (sizeof %11)) {\n    let e = %11[%10]\n    call %12 = clo<\"ToString\">(([number] n))\n    assert (? %12: Normal)\n    %12 = %12.Value\n    call %13 = clo<\"Set\">(A, %12, e, true)\n    assert (? %13: Normal)\n    %13 = %13.Value\n    n = (+ n 1)\n    %10 = (+ %10 1)\n  }\n  if (? A: Completion) return A\n  call %14 = clo<\"NormalCompletion\">(A)\n  return %14\n}","def <BUILTIN>:INTRINSICS.TypedArray.prototype.find(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1156]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop predicate < ArgumentsList\n    expand __args__.predicate\n  } else let predicate = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop thisArg < ArgumentsList\n    expand __args__.thisArg\n  } else let thisArg = undefined\n  let O = this\n  call %0 = clo<\"ValidateTypedArray\">(O, ~seq-cst~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let taRecord = %0\n  call %1 = clo<\"TypedArrayLength\">(taRecord)\n  let len = %1\n  call %2 = clo<\"FindViaPredicate\">(O, len, ~ascending~, predicate, thisArg)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let findRec = %2\n  %3 = findRec.Value\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.TypedArray.prototype.findIndex(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1157]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop predicate < ArgumentsList\n    expand __args__.predicate\n  } else let predicate = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop thisArg < ArgumentsList\n    expand __args__.thisArg\n  } else let thisArg = undefined\n  let O = this\n  call %0 = clo<\"ValidateTypedArray\">(O, ~seq-cst~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let taRecord = %0\n  call %1 = clo<\"TypedArrayLength\">(taRecord)\n  let len = %1\n  call %2 = clo<\"FindViaPredicate\">(O, len, ~ascending~, predicate, thisArg)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let findRec = %2\n  %3 = findRec.Index\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.TypedArray.prototype.findLast(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1158]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop predicate < ArgumentsList\n    expand __args__.predicate\n  } else let predicate = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop thisArg < ArgumentsList\n    expand __args__.thisArg\n  } else let thisArg = undefined\n  let O = this\n  call %0 = clo<\"ValidateTypedArray\">(O, ~seq-cst~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let taRecord = %0\n  call %1 = clo<\"TypedArrayLength\">(taRecord)\n  let len = %1\n  call %2 = clo<\"FindViaPredicate\">(O, len, ~descending~, predicate, thisArg)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let findRec = %2\n  %3 = findRec.Value\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.TypedArray.prototype.findLastIndex(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1159]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop predicate < ArgumentsList\n    expand __args__.predicate\n  } else let predicate = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop thisArg < ArgumentsList\n    expand __args__.thisArg\n  } else let thisArg = undefined\n  let O = this\n  call %0 = clo<\"ValidateTypedArray\">(O, ~seq-cst~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let taRecord = %0\n  call %1 = clo<\"TypedArrayLength\">(taRecord)\n  let len = %1\n  call %2 = clo<\"FindViaPredicate\">(O, len, ~descending~, predicate, thisArg)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let findRec = %2\n  %3 = findRec.Index\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.TypedArray.prototype.forEach(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1160]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop callbackfn < ArgumentsList\n    expand __args__.callbackfn\n  } else let callbackfn = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop thisArg < ArgumentsList\n    expand __args__.thisArg\n  } else let thisArg = undefined\n  let O = this\n  call %0 = clo<\"ValidateTypedArray\">(O, ~seq-cst~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let taRecord = %0\n  call %1 = clo<\"TypedArrayLength\">(taRecord)\n  let len = %1\n  call %2 = clo<\"IsCallable\">(callbackfn)\n  if (= %2 false) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  let k = 0\n  while (< k len) {\n    call %5 = clo<\"ToString\">(([number] k))\n    assert (? %5: Normal)\n    %5 = %5.Value\n    let Pk = %5\n    call %6 = clo<\"Get\">(O, Pk)\n    assert (? %6: Normal)\n    %6 = %6.Value\n    let kValue = %6\n    call %7 = clo<\"Call\">(callbackfn, thisArg, (list [kValue, ([number] k), O])[#1161])\n    assert (? %7: Completion)\n    if (? %7: Abrupt) return %7\n    else %7 = %7.Value\n    k = (+ k 1)\n  }\n  call %8 = clo<\"NormalCompletion\">(undefined)\n  return %8\n}","def <BUILTIN>:INTRINSICS.TypedArray.prototype.includes(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1162]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop searchElement < ArgumentsList\n    expand __args__.searchElement\n  } else let searchElement = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop fromIndex < ArgumentsList\n    expand __args__.fromIndex\n  } else let fromIndex = undefined\n  let O = this\n  call %0 = clo<\"ValidateTypedArray\">(O, ~seq-cst~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let taRecord = %0\n  call %1 = clo<\"TypedArrayLength\">(taRecord)\n  let len = %1\n  if (== len 0) {\n    call %2 = clo<\"NormalCompletion\">(false)\n    return %2\n  }\n  call %3 = clo<\"ToIntegerOrInfinity\">(fromIndex)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let n = %3\n  assert (|| (! (= fromIndex undefined)) (= n 0))\n  if (== n +INF) {\n    call %4 = clo<\"NormalCompletion\">(false)\n    return %4\n  } else {\n    if (== n -INF) {\n      n = 0\n    }\n  }\n  if (! (< n 0)) {\n    let k = n\n  } else {\n    let k = (+ len n)\n    if (< k 0) {\n      k = 0\n    }\n  }\n  while (< k len) {\n    call %5 = clo<\"ToString\">(([number] k))\n    assert (? %5: Normal)\n    %5 = %5.Value\n    call %6 = clo<\"Get\">(O, %5)\n    assert (? %6: Normal)\n    %6 = %6.Value\n    let elementK = %6\n    call %7 = clo<\"SameValueZero\">(searchElement, elementK)\n    if (= %7 true) {\n      call %8 = clo<\"NormalCompletion\">(true)\n      return %8\n    }\n    k = (+ k 1)\n  }\n  call %9 = clo<\"NormalCompletion\">(false)\n  return %9\n}","def <BUILTIN>:INTRINSICS.TypedArray.prototype.indexOf(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1163]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop searchElement < ArgumentsList\n    expand __args__.searchElement\n  } else let searchElement = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop fromIndex < ArgumentsList\n    expand __args__.fromIndex\n  } else let fromIndex = undefined\n  let O = this\n  call %0 = clo<\"ValidateTypedArray\">(O, ~seq-cst~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let taRecord = %0\n  call %1 = clo<\"TypedArrayLength\">(taRecord)\n  let len = %1\n  if (== len 0) {\n    call %2 = clo<\"NormalCompletion\">(-1.0f)\n    return %2\n  }\n  call %3 = clo<\"ToIntegerOrInfinity\">(fromIndex)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let n = %3\n  assert (|| (! (= fromIndex undefined)) (= n 0))\n  if (== n +INF) {\n    call %4 = clo<\"NormalCompletion\">(-1.0f)\n    return %4\n  } else {\n    if (== n -INF) {\n      n = 0\n    }\n  }\n  if (! (< n 0)) {\n    let k = n\n  } else {\n    let k = (+ len n)\n    if (< k 0) {\n      k = 0\n    }\n  }\n  while (< k len) {\n    call %5 = clo<\"ToString\">(([number] k))\n    assert (? %5: Normal)\n    %5 = %5.Value\n    call %6 = clo<\"HasProperty\">(O, %5)\n    assert (? %6: Normal)\n    %6 = %6.Value\n    let kPresent = %6\n    if (= kPresent true) {\n      call %7 = clo<\"ToString\">(([number] k))\n      assert (? %7: Normal)\n      %7 = %7.Value\n      call %8 = clo<\"Get\">(O, %7)\n      assert (? %8: Normal)\n      %8 = %8.Value\n      let elementK = %8\n      call %9 = clo<\"IsStrictlyEqual\">(searchElement, elementK)\n      if (= %9 true) {\n        %10 = ([number] k)\n        if (? %10: Completion) return %10\n        call %11 = clo<\"NormalCompletion\">(%10)\n        return %11\n      }\n    }\n    k = (+ k 1)\n  }\n  call %12 = clo<\"NormalCompletion\">(-1.0f)\n  return %12\n}","def <BUILTIN>:INTRINSICS.TypedArray.prototype.join(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1164]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop separator < ArgumentsList\n    expand __args__.separator\n  } else let separator = undefined\n  let O = this\n  call %0 = clo<\"ValidateTypedArray\">(O, ~seq-cst~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let taRecord = %0\n  call %1 = clo<\"TypedArrayLength\">(taRecord)\n  let len = %1\n  if (= separator undefined) {\n    let sep = \",\"\n  } else {\n    call %2 = clo<\"ToString\">(separator)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let sep = %2\n  }\n  let R = \"\"\n  let k = 0\n  while (< k len) {\n    if (< 0 k) {\n      R = (concat R sep)\n    }\n    call %3 = clo<\"ToString\">(([number] k))\n    assert (? %3: Normal)\n    %3 = %3.Value\n    call %4 = clo<\"Get\">(O, %3)\n    assert (? %4: Normal)\n    %4 = %4.Value\n    let element = %4\n    if (= element undefined) {\n      let next = \"\"\n    } else {\n      call %5 = clo<\"ToString\">(element)\n      assert (? %5: Normal)\n      %5 = %5.Value\n      let next = %5\n    }\n    R = (concat R next)\n    k = (+ k 1)\n  }\n  if (? R: Completion) return R\n  call %6 = clo<\"NormalCompletion\">(R)\n  return %6\n}","def <BUILTIN>:INTRINSICS.TypedArray.prototype.keys(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1165]\n  let O = this\n  call %0 = clo<\"ValidateTypedArray\">(O, ~seq-cst~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"CreateArrayIterator\">(O, ~key~)\n  if (? %1: Completion) return %1\n  call %2 = clo<\"NormalCompletion\">(%1)\n  return %2\n}","def <BUILTIN>:INTRINSICS.TypedArray.prototype.lastIndexOf(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1166]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop searchElement < ArgumentsList\n    expand __args__.searchElement\n  } else let searchElement = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop fromIndex < ArgumentsList\n    expand __args__.fromIndex\n  } else let fromIndex = undefined\n  let O = this\n  call %0 = clo<\"ValidateTypedArray\">(O, ~seq-cst~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let taRecord = %0\n  call %1 = clo<\"TypedArrayLength\">(taRecord)\n  let len = %1\n  if (== len 0) {\n    call %2 = clo<\"NormalCompletion\">(-1.0f)\n    return %2\n  }\n  if (exists __args__.fromIndex) {\n    call %3 = clo<\"ToIntegerOrInfinity\">(fromIndex)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let n = %3\n  } else {\n    let n = (- len 1)\n  }\n  if (== n -INF) {\n    call %4 = clo<\"NormalCompletion\">(-1.0f)\n    return %4\n  }\n  if (! (< n 0)) {\n    let k = (min n (- len 1))\n  } else {\n    let k = (+ len n)\n  }\n  while (! (< k 0)) {\n    call %5 = clo<\"ToString\">(([number] k))\n    assert (? %5: Normal)\n    %5 = %5.Value\n    call %6 = clo<\"HasProperty\">(O, %5)\n    assert (? %6: Normal)\n    %6 = %6.Value\n    let kPresent = %6\n    if (= kPresent true) {\n      call %7 = clo<\"ToString\">(([number] k))\n      assert (? %7: Normal)\n      %7 = %7.Value\n      call %8 = clo<\"Get\">(O, %7)\n      assert (? %8: Normal)\n      %8 = %8.Value\n      let elementK = %8\n      call %9 = clo<\"IsStrictlyEqual\">(searchElement, elementK)\n      if (= %9 true) {\n        %10 = ([number] k)\n        if (? %10: Completion) return %10\n        call %11 = clo<\"NormalCompletion\">(%10)\n        return %11\n      }\n    }\n    k = (- k 1)\n  }\n  call %12 = clo<\"NormalCompletion\">(-1.0f)\n  return %12\n}","def <BUILTIN>:INTRINSICS.get TypedArray.prototype.length(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1167]\n  let O = this\n  call %0 = clo<\"RequireInternalSlot\">(O, \"TypedArrayName\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  assert (yet \"_O_ has [[ViewedArrayBuffer]] and [[ArrayLength]] internal slots.\")\n  call %1 = clo<\"MakeTypedArrayWithBufferWitnessRecord\">(O, ~seq-cst~)\n  let taRecord = %1\n  call %2 = clo<\"IsTypedArrayOutOfBounds\">(taRecord)\n  if (= %2 true) {\n    call %3 = clo<\"NormalCompletion\">(0.0f)\n    return %3\n  }\n  call %4 = clo<\"TypedArrayLength\">(taRecord)\n  let length = %4\n  %5 = ([number] length)\n  if (? %5: Completion) return %5\n  call %6 = clo<\"NormalCompletion\">(%5)\n  return %6\n}","def <BUILTIN>:INTRINSICS.TypedArray.prototype.map(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1168]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop callbackfn < ArgumentsList\n    expand __args__.callbackfn\n  } else let callbackfn = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop thisArg < ArgumentsList\n    expand __args__.thisArg\n  } else let thisArg = undefined\n  let O = this\n  call %0 = clo<\"ValidateTypedArray\">(O, ~seq-cst~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let taRecord = %0\n  call %1 = clo<\"TypedArrayLength\">(taRecord)\n  let len = %1\n  call %2 = clo<\"IsCallable\">(callbackfn)\n  if (= %2 false) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  call %5 = clo<\"TypedArraySpeciesCreate\">(O, (list [([number] len)])[#1169])\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  let A = %5\n  let k = 0\n  while (< k len) {\n    call %6 = clo<\"ToString\">(([number] k))\n    assert (? %6: Normal)\n    %6 = %6.Value\n    let Pk = %6\n    call %7 = clo<\"Get\">(O, Pk)\n    assert (? %7: Normal)\n    %7 = %7.Value\n    let kValue = %7\n    call %8 = clo<\"Call\">(callbackfn, thisArg, (list [kValue, ([number] k), O])[#1170])\n    assert (? %8: Completion)\n    if (? %8: Abrupt) return %8\n    else %8 = %8.Value\n    let mappedValue = %8\n    call %9 = clo<\"Set\">(A, Pk, mappedValue, true)\n    assert (? %9: Completion)\n    if (? %9: Abrupt) return %9\n    else %9 = %9.Value\n    k = (+ k 1)\n  }\n  if (? A: Completion) return A\n  call %10 = clo<\"NormalCompletion\">(A)\n  return %10\n}","def <BUILTIN>:INTRINSICS.TypedArray.prototype.reduce(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1171]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop callbackfn < ArgumentsList\n    expand __args__.callbackfn\n  } else let callbackfn = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop initialValue < ArgumentsList\n    expand __args__.initialValue\n  } else let initialValue = undefined\n  let O = this\n  call %0 = clo<\"ValidateTypedArray\">(O, ~seq-cst~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let taRecord = %0\n  call %1 = clo<\"TypedArrayLength\">(taRecord)\n  let len = %1\n  call %2 = clo<\"IsCallable\">(callbackfn)\n  if (= %2 false) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  if (&& (== len 0) (! (exists __args__.initialValue))) {\n    call %5 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %6 = clo<\"ThrowCompletion\">(%5)\n    return %6\n  }\n  let k = 0\n  let accumulator = undefined\n  if (exists __args__.initialValue) {\n    accumulator = initialValue\n  } else {\n    call %7 = clo<\"ToString\">(([number] k))\n    assert (? %7: Normal)\n    %7 = %7.Value\n    let Pk = %7\n    call %8 = clo<\"Get\">(O, Pk)\n    assert (? %8: Normal)\n    %8 = %8.Value\n    accumulator = %8\n    k = (+ k 1)\n  }\n  while (< k len) {\n    call %9 = clo<\"ToString\">(([number] k))\n    assert (? %9: Normal)\n    %9 = %9.Value\n    let Pk = %9\n    call %10 = clo<\"Get\">(O, Pk)\n    assert (? %10: Normal)\n    %10 = %10.Value\n    let kValue = %10\n    call %11 = clo<\"Call\">(callbackfn, undefined, (list [accumulator, kValue, ([number] k), O])[#1172])\n    assert (? %11: Completion)\n    if (? %11: Abrupt) return %11\n    else %11 = %11.Value\n    accumulator = %11\n    k = (+ k 1)\n  }\n  if (? accumulator: Completion) return accumulator\n  call %12 = clo<\"NormalCompletion\">(accumulator)\n  return %12\n}","def <BUILTIN>:INTRINSICS.TypedArray.prototype.reduceRight(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1173]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop callbackfn < ArgumentsList\n    expand __args__.callbackfn\n  } else let callbackfn = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop initialValue < ArgumentsList\n    expand __args__.initialValue\n  } else let initialValue = undefined\n  let O = this\n  call %0 = clo<\"ValidateTypedArray\">(O, ~seq-cst~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let taRecord = %0\n  call %1 = clo<\"TypedArrayLength\">(taRecord)\n  let len = %1\n  call %2 = clo<\"IsCallable\">(callbackfn)\n  if (= %2 false) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  if (&& (== len 0) (! (exists __args__.initialValue))) {\n    call %5 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %6 = clo<\"ThrowCompletion\">(%5)\n    return %6\n  }\n  let k = (- len 1)\n  let accumulator = undefined\n  if (exists __args__.initialValue) {\n    accumulator = initialValue\n  } else {\n    call %7 = clo<\"ToString\">(([number] k))\n    assert (? %7: Normal)\n    %7 = %7.Value\n    let Pk = %7\n    call %8 = clo<\"Get\">(O, Pk)\n    assert (? %8: Normal)\n    %8 = %8.Value\n    accumulator = %8\n    k = (- k 1)\n  }\n  while (! (< k 0)) {\n    call %9 = clo<\"ToString\">(([number] k))\n    assert (? %9: Normal)\n    %9 = %9.Value\n    let Pk = %9\n    call %10 = clo<\"Get\">(O, Pk)\n    assert (? %10: Normal)\n    %10 = %10.Value\n    let kValue = %10\n    call %11 = clo<\"Call\">(callbackfn, undefined, (list [accumulator, kValue, ([number] k), O])[#1174])\n    assert (? %11: Completion)\n    if (? %11: Abrupt) return %11\n    else %11 = %11.Value\n    accumulator = %11\n    k = (- k 1)\n  }\n  if (? accumulator: Completion) return accumulator\n  call %12 = clo<\"NormalCompletion\">(accumulator)\n  return %12\n}","def <BUILTIN>:INTRINSICS.TypedArray.prototype.reverse(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1175]\n  let O = this\n  call %0 = clo<\"ValidateTypedArray\">(O, ~seq-cst~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let taRecord = %0\n  call %1 = clo<\"TypedArrayLength\">(taRecord)\n  let len = %1\n  let middle = (floor (/ len 2))\n  let lower = 0\n  while (! (== lower middle)) {\n    let upper = (- (- len lower) 1)\n    call %2 = clo<\"ToString\">(([number] upper))\n    assert (? %2: Normal)\n    %2 = %2.Value\n    let upperP = %2\n    call %3 = clo<\"ToString\">(([number] lower))\n    assert (? %3: Normal)\n    %3 = %3.Value\n    let lowerP = %3\n    call %4 = clo<\"Get\">(O, lowerP)\n    assert (? %4: Normal)\n    %4 = %4.Value\n    let lowerValue = %4\n    call %5 = clo<\"Get\">(O, upperP)\n    assert (? %5: Normal)\n    %5 = %5.Value\n    let upperValue = %5\n    call %6 = clo<\"Set\">(O, lowerP, upperValue, true)\n    assert (? %6: Normal)\n    %6 = %6.Value\n    call %7 = clo<\"Set\">(O, upperP, lowerValue, true)\n    assert (? %7: Normal)\n    %7 = %7.Value\n    lower = (+ lower 1)\n  }\n  if (? O: Completion) return O\n  call %8 = clo<\"NormalCompletion\">(O)\n  return %8\n}","def <BUILTIN>:INTRINSICS.TypedArray.prototype.set(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1176]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop source < ArgumentsList\n    expand __args__.source\n  } else let source = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop offset < ArgumentsList\n    expand __args__.offset\n  } else let offset = undefined\n  let target = this\n  call %0 = clo<\"RequireInternalSlot\">(target, \"TypedArrayName\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  assert (exists target.ViewedArrayBuffer)\n  call %1 = clo<\"ToIntegerOrInfinity\">(offset)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let targetOffset = %1\n  if (< targetOffset 0) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  (yet \"If _source_ is an Object that has a [[TypedArrayName]] internal slot, then\\n  1. Perform ? SetTypedArrayFromTypedArray(_target_, _targetOffset_, _source_).\")\n  (yet \"Else,\\n  1. Perform ? SetTypedArrayFromArrayLike(_target_, _targetOffset_, _source_).\")\n  call %4 = clo<\"NormalCompletion\">(undefined)\n  return %4\n}","def SetTypedArrayFromTypedArray(\n  target: Record[TypedArray],\n  targetOffset: NonNegInt | +INF,\n  source: Record[TypedArray],\n): Normal[Enum[~unused~]] | Throw = {\n  let targetBuffer = target.ViewedArrayBuffer\n  call %0 = clo<\"MakeTypedArrayWithBufferWitnessRecord\">(target, ~seq-cst~)\n  let targetRecord = %0\n  call %1 = clo<\"IsTypedArrayOutOfBounds\">(targetRecord)\n  if (= %1 true) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  call %4 = clo<\"TypedArrayLength\">(targetRecord)\n  let targetLength = %4\n  let srcBuffer = source.ViewedArrayBuffer\n  call %5 = clo<\"MakeTypedArrayWithBufferWitnessRecord\">(source, ~seq-cst~)\n  let srcRecord = %5\n  call %6 = clo<\"IsTypedArrayOutOfBounds\">(srcRecord)\n  if (= %6 true) {\n    call %7 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %8 = clo<\"ThrowCompletion\">(%7)\n    return %8\n  }\n  call %9 = clo<\"TypedArrayLength\">(srcRecord)\n  let srcLength = %9\n  call %10 = clo<\"TypedArrayElementType\">(target)\n  let targetType = %10\n  call %11 = clo<\"TypedArrayElementSize\">(target)\n  let targetElementSize = %11\n  let targetByteOffset = target.ByteOffset\n  call %12 = clo<\"TypedArrayElementType\">(source)\n  let srcType = %12\n  call %13 = clo<\"TypedArrayElementSize\">(source)\n  let srcElementSize = %13\n  let srcByteOffset = source.ByteOffset\n  if (== targetOffset +INF) {\n    call %14 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %15 = clo<\"ThrowCompletion\">(%14)\n    return %15\n  }\n  if (< targetLength (+ srcLength targetOffset)) {\n    call %16 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %17 = clo<\"ThrowCompletion\">(%16)\n    return %17\n  }\n  if (! (= target.ContentType source.ContentType)) {\n    call %18 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %19 = clo<\"ThrowCompletion\">(%18)\n    return %19\n  }\n  call %21 = clo<\"IsSharedArrayBuffer\">(srcBuffer)\n  %20 = (= %21 true)\n  if %20 {\n    call %22 = clo<\"IsSharedArrayBuffer\">(targetBuffer)\n    %20 = (= %22 true)\n    if %20 {\n      %20 = (= srcBuffer.ArrayBufferData targetBuffer.ArrayBufferData)\n    }\n  }\n  if %20 {\n    let sameSharedArrayBuffer = true\n  } else {\n    let sameSharedArrayBuffer = false\n  }\n  call %23 = clo<\"SameValue\">(srcBuffer, targetBuffer)\n  if (|| (= %23 true) (= sameSharedArrayBuffer true)) {\n    call %24 = clo<\"TypedArrayByteLength\">(srcRecord)\n    let srcByteLength = %24\n    call %25 = clo<\"CloneArrayBuffer\">(srcBuffer, srcByteOffset, srcByteLength)\n    assert (? %25: Completion)\n    if (? %25: Abrupt) return %25\n    else %25 = %25.Value\n    srcBuffer = %25\n    let srcByteIndex = 0\n  } else {\n    let srcByteIndex = srcByteOffset\n  }\n  let targetByteIndex = (+ (* targetOffset targetElementSize) targetByteOffset)\n  let limit = (+ targetByteIndex (* targetElementSize srcLength))\n  if (= srcType targetType) {\n    nop\n    while (< targetByteIndex limit) {\n      call %26 = clo<\"GetValueFromBuffer\">(srcBuffer, srcByteIndex, ~uint8~, true, ~unordered~)\n      let value = %26\n      call %27 = clo<\"SetValueInBuffer\">(targetBuffer, targetByteIndex, ~uint8~, value, true, ~unordered~)\n      srcByteIndex = (+ srcByteIndex 1)\n      targetByteIndex = (+ targetByteIndex 1)\n    }\n  } else {\n    while (< targetByteIndex limit) {\n      call %28 = clo<\"GetValueFromBuffer\">(srcBuffer, srcByteIndex, srcType, true, ~unordered~)\n      let value = %28\n      call %29 = clo<\"SetValueInBuffer\">(targetBuffer, targetByteIndex, targetType, value, true, ~unordered~)\n      srcByteIndex = (+ srcByteIndex srcElementSize)\n      targetByteIndex = (+ targetByteIndex targetElementSize)\n    }\n  }\n  call %30 = clo<\"NormalCompletion\">(~unused~)\n  return %30\n}","def SetTypedArrayFromArrayLike(\n  target: Record[TypedArray],\n  targetOffset: NonNegInt | +INF,\n  source: Unknown[\"ECMAScriptLanguageValue,ButNotATypedArray\"],\n): Normal[Enum[~unused~]] | Throw = {\n  call %0 = clo<\"MakeTypedArrayWithBufferWitnessRecord\">(target, ~seq-cst~)\n  let targetRecord = %0\n  call %1 = clo<\"IsTypedArrayOutOfBounds\">(targetRecord)\n  if (= %1 true) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  call %4 = clo<\"TypedArrayLength\">(targetRecord)\n  let targetLength = %4\n  call %5 = clo<\"ToObject\">(source)\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  let src = %5\n  call %6 = clo<\"LengthOfArrayLike\">(src)\n  assert (? %6: Completion)\n  if (? %6: Abrupt) return %6\n  else %6 = %6.Value\n  let srcLength = %6\n  if (== targetOffset +INF) {\n    call %7 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %8 = clo<\"ThrowCompletion\">(%7)\n    return %8\n  }\n  if (< targetLength (+ srcLength targetOffset)) {\n    call %9 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %10 = clo<\"ThrowCompletion\">(%9)\n    return %10\n  }\n  let k = 0\n  while (< k srcLength) {\n    call %11 = clo<\"ToString\">(([number] k))\n    assert (? %11: Normal)\n    %11 = %11.Value\n    let Pk = %11\n    call %12 = clo<\"Get\">(src, Pk)\n    assert (? %12: Completion)\n    if (? %12: Abrupt) return %12\n    else %12 = %12.Value\n    let value = %12\n    let targetIndex = ([number] (+ targetOffset k))\n    call %13 = clo<\"TypedArraySetElement\">(target, targetIndex, value)\n    assert (? %13: Completion)\n    if (? %13: Abrupt) return %13\n    else %13 = %13.Value\n    k = (+ k 1)\n  }\n  call %14 = clo<\"NormalCompletion\">(~unused~)\n  return %14\n}","def <BUILTIN>:INTRINSICS.TypedArray.prototype.slice(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1177]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop start < ArgumentsList\n    expand __args__.start\n  } else let start = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop end < ArgumentsList\n    expand __args__.end\n  } else let end = undefined\n  let O = this\n  call %0 = clo<\"ValidateTypedArray\">(O, ~seq-cst~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let taRecord = %0\n  call %1 = clo<\"TypedArrayLength\">(taRecord)\n  let srcArrayLength = %1\n  call %2 = clo<\"ToIntegerOrInfinity\">(start)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let relativeStart = %2\n  if (== relativeStart -INF) {\n    let startIndex = 0\n  } else {\n    if (< relativeStart 0) {\n      let startIndex = (max (+ srcArrayLength relativeStart) 0)\n    } else {\n      let startIndex = (min relativeStart srcArrayLength)\n    }\n  }\n  if (= end undefined) {\n    let relativeEnd = srcArrayLength\n  } else {\n    call %3 = clo<\"ToIntegerOrInfinity\">(end)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let relativeEnd = %3\n  }\n  if (== relativeEnd -INF) {\n    let endIndex = 0\n  } else {\n    if (< relativeEnd 0) {\n      let endIndex = (max (+ srcArrayLength relativeEnd) 0)\n    } else {\n      let endIndex = (min relativeEnd srcArrayLength)\n    }\n  }\n  let countBytes = (max (- endIndex startIndex) 0)\n  call %4 = clo<\"TypedArraySpeciesCreate\">(O, (list [([number] countBytes)])[#1178])\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let A = %4\n  if (< 0 countBytes) {\n    call %5 = clo<\"MakeTypedArrayWithBufferWitnessRecord\">(O, ~seq-cst~)\n    taRecord = %5\n    call %6 = clo<\"IsTypedArrayOutOfBounds\">(taRecord)\n    if (= %6 true) {\n      call %7 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %8 = clo<\"ThrowCompletion\">(%7)\n      return %8\n    }\n    (yet \"Set _endIndex_ to min(_endIndex_, TypedArrayLength(_taRecord_)).\")\n    countBytes = (max (- endIndex startIndex) 0)\n    call %9 = clo<\"TypedArrayElementType\">(O)\n    let srcType = %9\n    call %10 = clo<\"TypedArrayElementType\">(A)\n    let targetType = %10\n    if (= srcType targetType) {\n      nop\n      let srcBuffer = O.ViewedArrayBuffer\n      let targetBuffer = A.ViewedArrayBuffer\n      call %11 = clo<\"TypedArrayElementSize\">(O)\n      let elementSize = %11\n      let srcByteOffset = O.ByteOffset\n      let srcByteIndex = (+ (* startIndex elementSize) srcByteOffset)\n      let targetByteIndex = A.ByteOffset\n      let endByteIndex = (+ targetByteIndex (* countBytes elementSize))\n      while (< targetByteIndex endByteIndex) {\n        call %12 = clo<\"GetValueFromBuffer\">(srcBuffer, srcByteIndex, ~uint8~, true, ~unordered~)\n        let value = %12\n        call %13 = clo<\"SetValueInBuffer\">(targetBuffer, targetByteIndex, ~uint8~, value, true, ~unordered~)\n        srcByteIndex = (+ srcByteIndex 1)\n        targetByteIndex = (+ targetByteIndex 1)\n      }\n    } else {\n      let n = 0\n      let k = startIndex\n      while (< k endIndex) {\n        call %14 = clo<\"ToString\">(([number] k))\n        assert (? %14: Normal)\n        %14 = %14.Value\n        let Pk = %14\n        call %15 = clo<\"Get\">(O, Pk)\n        assert (? %15: Normal)\n        %15 = %15.Value\n        let kValue = %15\n        call %16 = clo<\"ToString\">(([number] n))\n        assert (? %16: Normal)\n        %16 = %16.Value\n        call %17 = clo<\"Set\">(A, %16, kValue, true)\n        assert (? %17: Normal)\n        %17 = %17.Value\n        k = (+ k 1)\n        n = (+ n 1)\n      }\n    }\n  }\n  if (? A: Completion) return A\n  call %18 = clo<\"NormalCompletion\">(A)\n  return %18\n}","def <BUILTIN>:INTRINSICS.TypedArray.prototype.some(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1179]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop callbackfn < ArgumentsList\n    expand __args__.callbackfn\n  } else let callbackfn = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop thisArg < ArgumentsList\n    expand __args__.thisArg\n  } else let thisArg = undefined\n  let O = this\n  call %0 = clo<\"ValidateTypedArray\">(O, ~seq-cst~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let taRecord = %0\n  call %1 = clo<\"TypedArrayLength\">(taRecord)\n  let len = %1\n  call %2 = clo<\"IsCallable\">(callbackfn)\n  if (= %2 false) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  let k = 0\n  while (< k len) {\n    call %5 = clo<\"ToString\">(([number] k))\n    assert (? %5: Normal)\n    %5 = %5.Value\n    let Pk = %5\n    call %6 = clo<\"Get\">(O, Pk)\n    assert (? %6: Normal)\n    %6 = %6.Value\n    let kValue = %6\n    call %7 = clo<\"Call\">(callbackfn, thisArg, (list [kValue, ([number] k), O])[#1180])\n    assert (? %7: Completion)\n    if (? %7: Abrupt) return %7\n    else %7 = %7.Value\n    call %8 = clo<\"ToBoolean\">(%7)\n    let testResult = %8\n    if (= testResult true) {\n      call %9 = clo<\"NormalCompletion\">(true)\n      return %9\n    }\n    k = (+ k 1)\n  }\n  call %10 = clo<\"NormalCompletion\">(false)\n  return %10\n}","def <CLO>:INTRINSICS.TypedArray.prototype.sort:clo0(\n  x: Unknown,\n  y: Unknown,\n): Unknown = {\n  call %0 = clo<\"CompareTypedArrayElements\">(x, y, comparefn)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.TypedArray.prototype.sort(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1181]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop comparefn < ArgumentsList\n    expand __args__.comparefn\n  } else let comparefn = undefined\n  %0 = (! (= comparefn undefined))\n  if %0 {\n    call %1 = clo<\"IsCallable\">(comparefn)\n    %0 = (= %1 false)\n  }\n  if %0 {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  let obj = this\n  call %4 = clo<\"ValidateTypedArray\">(obj, ~seq-cst~)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let taRecord = %4\n  call %5 = clo<\"TypedArrayLength\">(taRecord)\n  let len = %5\n  nop\n  let SortCompare = clo<\"INTRINSICS.TypedArray.prototype.sort:clo0\", [comparefn]>\n  call %6 = clo<\"SortIndexedProperties\">(obj, len, SortCompare, ~read-through-holes~)\n  assert (? %6: Completion)\n  if (? %6: Abrupt) return %6\n  else %6 = %6.Value\n  let sortedList = %6\n  let j = 0\n  while (< j len) {\n    call %7 = clo<\"ToString\">(([number] j))\n    assert (? %7: Normal)\n    %7 = %7.Value\n    call %8 = clo<\"Set\">(obj, %7, sortedList[j], true)\n    assert (? %8: Normal)\n    %8 = %8.Value\n    j = (+ j 1)\n  }\n  if (? obj: Completion) return obj\n  call %9 = clo<\"NormalCompletion\">(obj)\n  return %9\n}","def <BUILTIN>:INTRINSICS.TypedArray.prototype.subarray(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1182]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop start < ArgumentsList\n    expand __args__.start\n  } else let start = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop end < ArgumentsList\n    expand __args__.end\n  } else let end = undefined\n  let O = this\n  call %0 = clo<\"RequireInternalSlot\">(O, \"TypedArrayName\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  assert (exists O.ViewedArrayBuffer)\n  let buffer = O.ViewedArrayBuffer\n  call %1 = clo<\"MakeTypedArrayWithBufferWitnessRecord\">(O, ~seq-cst~)\n  let srcRecord = %1\n  call %2 = clo<\"IsTypedArrayOutOfBounds\">(srcRecord)\n  if (= %2 true) {\n    let srcLength = 0\n  } else {\n    call %3 = clo<\"TypedArrayLength\">(srcRecord)\n    let srcLength = %3\n  }\n  call %4 = clo<\"ToIntegerOrInfinity\">(start)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let relativeStart = %4\n  if (== relativeStart -INF) {\n    let startIndex = 0\n  } else {\n    if (< relativeStart 0) {\n      let startIndex = (max (+ srcLength relativeStart) 0)\n    } else {\n      let startIndex = (min relativeStart srcLength)\n    }\n  }\n  call %5 = clo<\"TypedArrayElementSize\">(O)\n  let elementSize = %5\n  let srcByteOffset = O.ByteOffset\n  let beginByteOffset = (+ srcByteOffset (* startIndex elementSize))\n  if (&& (= O.ArrayLength ~auto~) (= end undefined)) {\n    let argumentsList = (list [buffer, ([number] beginByteOffset)])[#1183]\n  } else {\n    if (= end undefined) {\n      let relativeEnd = srcLength\n    } else {\n      call %6 = clo<\"ToIntegerOrInfinity\">(end)\n      assert (? %6: Completion)\n      if (? %6: Abrupt) return %6\n      else %6 = %6.Value\n      let relativeEnd = %6\n    }\n    if (== relativeEnd -INF) {\n      let endIndex = 0\n    } else {\n      if (< relativeEnd 0) {\n        let endIndex = (max (+ srcLength relativeEnd) 0)\n      } else {\n        let endIndex = (min relativeEnd srcLength)\n      }\n    }\n    let newLength = (max (- endIndex startIndex) 0)\n    let argumentsList = (list [buffer, ([number] beginByteOffset), ([number] newLength)])[#1184]\n  }\n  call %7 = clo<\"TypedArraySpeciesCreate\">(O, argumentsList)\n  assert (? %7: Completion)\n  return %7\n}","def <BUILTIN>:INTRINSICS.TypedArray.prototype.toReversed(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1185]\n  let O = this\n  call %0 = clo<\"ValidateTypedArray\">(O, ~seq-cst~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let taRecord = %0\n  call %1 = clo<\"TypedArrayLength\">(taRecord)\n  let length = %1\n  call %2 = clo<\"TypedArrayCreateSameType\">(O, (list [([number] length)])[#1186])\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let A = %2\n  let k = 0\n  while (< k length) {\n    call %3 = clo<\"ToString\">(([number] (- (- length k) 1)))\n    assert (? %3: Normal)\n    %3 = %3.Value\n    let from = %3\n    call %4 = clo<\"ToString\">(([number] k))\n    assert (? %4: Normal)\n    %4 = %4.Value\n    let Pk = %4\n    call %5 = clo<\"Get\">(O, from)\n    assert (? %5: Normal)\n    %5 = %5.Value\n    let fromValue = %5\n    call %6 = clo<\"Set\">(A, Pk, fromValue, true)\n    assert (? %6: Normal)\n    %6 = %6.Value\n    k = (+ k 1)\n  }\n  if (? A: Completion) return A\n  call %7 = clo<\"NormalCompletion\">(A)\n  return %7\n}","def <CLO>:INTRINSICS.TypedArray.prototype.toSorted:clo0(\n  x: Unknown,\n  y: Unknown,\n): Unknown = {\n  call %0 = clo<\"CompareTypedArrayElements\">(x, y, comparefn)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.TypedArray.prototype.toSorted(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1187]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop comparefn < ArgumentsList\n    expand __args__.comparefn\n  } else let comparefn = undefined\n  %0 = (! (= comparefn undefined))\n  if %0 {\n    call %1 = clo<\"IsCallable\">(comparefn)\n    %0 = (= %1 false)\n  }\n  if %0 {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  let O = this\n  call %4 = clo<\"ValidateTypedArray\">(O, ~seq-cst~)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let taRecord = %4\n  call %5 = clo<\"TypedArrayLength\">(taRecord)\n  let len = %5\n  call %6 = clo<\"TypedArrayCreateSameType\">(O, (list [([number] len)])[#1188])\n  assert (? %6: Completion)\n  if (? %6: Abrupt) return %6\n  else %6 = %6.Value\n  let A = %6\n  nop\n  let SortCompare = clo<\"INTRINSICS.TypedArray.prototype.toSorted:clo0\", [comparefn]>\n  call %7 = clo<\"SortIndexedProperties\">(O, len, SortCompare, ~read-through-holes~)\n  assert (? %7: Completion)\n  if (? %7: Abrupt) return %7\n  else %7 = %7.Value\n  let sortedList = %7\n  let j = 0\n  while (< j len) {\n    call %8 = clo<\"ToString\">(([number] j))\n    assert (? %8: Normal)\n    %8 = %8.Value\n    call %9 = clo<\"Set\">(A, %8, sortedList[j], true)\n    assert (? %9: Normal)\n    %9 = %9.Value\n    j = (+ j 1)\n  }\n  if (? A: Completion) return A\n  call %10 = clo<\"NormalCompletion\">(A)\n  return %10\n}","def <BUILTIN>:INTRINSICS.TypedArray.prototype.values(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1189]\n  let O = this\n  call %0 = clo<\"ValidateTypedArray\">(O, ~seq-cst~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"CreateArrayIterator\">(O, ~value~)\n  if (? %1: Completion) return %1\n  call %2 = clo<\"NormalCompletion\">(%1)\n  return %2\n}","def <BUILTIN>:INTRINSICS.TypedArray.prototype.with(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1190]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop index < ArgumentsList\n    expand __args__.index\n  } else let index = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  let O = this\n  call %0 = clo<\"ValidateTypedArray\">(O, ~seq-cst~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let taRecord = %0\n  call %1 = clo<\"TypedArrayLength\">(taRecord)\n  let len = %1\n  call %2 = clo<\"ToIntegerOrInfinity\">(index)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let relativeIndex = %2\n  if (! (< relativeIndex 0)) {\n    let actualIndex = relativeIndex\n  } else {\n    let actualIndex = (+ len relativeIndex)\n  }\n  if (= O.ContentType ~bigint~) {\n    call %3 = clo<\"ToBigInt\">(value)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let numericValue = %3\n  } else {\n    call %4 = clo<\"ToNumber\">(value)\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    let numericValue = %4\n  }\n  call %5 = clo<\"IsValidIntegerIndex\">(O, ([number] actualIndex))\n  if (= %5 false) {\n    call %6 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %7 = clo<\"ThrowCompletion\">(%6)\n    return %7\n  }\n  call %8 = clo<\"TypedArrayCreateSameType\">(O, (list [([number] len)])[#1191])\n  assert (? %8: Completion)\n  if (? %8: Abrupt) return %8\n  else %8 = %8.Value\n  let A = %8\n  let k = 0\n  while (< k len) {\n    call %9 = clo<\"ToString\">(([number] k))\n    assert (? %9: Normal)\n    %9 = %9.Value\n    let Pk = %9\n    if (= k actualIndex) {\n      let fromValue = numericValue\n    } else {\n      call %10 = clo<\"Get\">(O, Pk)\n      assert (? %10: Normal)\n      %10 = %10.Value\n      let fromValue = %10\n    }\n    call %11 = clo<\"Set\">(A, Pk, fromValue, true)\n    assert (? %11: Normal)\n    %11 = %11.Value\n    k = (+ k 1)\n  }\n  if (? A: Completion) return A\n  call %12 = clo<\"NormalCompletion\">(A)\n  return %12\n}","def <BUILTIN>:INTRINSICS.get TypedArray.prototype[@@toStringTag](\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1192]\n  let O = this\n  if (! (? O: Record[Object])) {\n    call %0 = clo<\"NormalCompletion\">(undefined)\n    return %0\n  }\n  if (! (exists O.TypedArrayName)) {\n    call %1 = clo<\"NormalCompletion\">(undefined)\n    return %1\n  }\n  let name = O.TypedArrayName\n  assert (? name: String)\n  if (? name: Completion) return name\n  call %2 = clo<\"NormalCompletion\">(name)\n  return %2\n}","def TypedArraySpeciesCreate(\n  exemplar: Record[TypedArray],\n  argumentList: List[ESValue],\n): Normal[Record[TypedArray]] | Throw = {\n  (yet \"Let _defaultConstructor_ be the intrinsic object associated with the constructor name _exemplar_.[[TypedArrayName]] in <emu-xref href=\\\"#table-the-typedarray-constructors\\\"></emu-xref>.\")\n  call %0 = clo<\"SpeciesConstructor\">(exemplar, defaultConstructor)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let constructor = %0\n  call %1 = clo<\"TypedArrayCreateFromConstructor\">(constructor, argumentList)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let result = %1\n  assert (yet \"_result_ has [[TypedArrayName]] and [[ContentType]] internal slots.\")\n  if (! (= result.ContentType exemplar.ContentType)) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  if (? result: Completion) return result\n  call %4 = clo<\"NormalCompletion\">(result)\n  return %4\n}","def TypedArrayCreateFromConstructor(\n  constructor: Record[Constructor],\n  argumentList: List[ESValue],\n): Normal[Record[TypedArray]] | Throw = {\n  call %0 = clo<\"Construct\">(constructor, argumentList)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let newTypedArray = %0\n  call %1 = clo<\"ValidateTypedArray\">(newTypedArray, ~seq-cst~)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let taRecord = %1\n  if (&& (= (sizeof argumentList) 1) (? argumentList[0]: Number)) {\n    call %2 = clo<\"IsTypedArrayOutOfBounds\">(taRecord)\n    if (= %2 true) {\n      call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %4 = clo<\"ThrowCompletion\">(%3)\n      return %4\n    }\n    call %5 = clo<\"TypedArrayLength\">(taRecord)\n    let length = %5\n    if (< length ([math] argumentList[0])) {\n      call %6 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %7 = clo<\"ThrowCompletion\">(%6)\n      return %7\n    }\n  }\n  if (? newTypedArray: Completion) return newTypedArray\n  call %8 = clo<\"NormalCompletion\">(newTypedArray)\n  return %8\n}","def TypedArrayCreateSameType(\n  exemplar: Record[TypedArray],\n  argumentList: List[ESValue],\n): Normal[Record[TypedArray]] | Throw = {\n  (yet \"Let _constructor_ be the intrinsic object associated with the constructor name _exemplar_.[[TypedArrayName]] in <emu-xref href=\\\"#table-the-typedarray-constructors\\\"></emu-xref>.\")\n  call %0 = clo<\"TypedArrayCreateFromConstructor\">(constructor, argumentList)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let result = %0\n  assert (yet \"_result_ has [[TypedArrayName]] and [[ContentType]] internal slots.\")\n  assert (= result.ContentType exemplar.ContentType)\n  if (? result: Completion) return result\n  call %1 = clo<\"NormalCompletion\">(result)\n  return %1\n}","def ValidateTypedArray(\n  O: ESValue,\n  order: Enum[~seq-cst~, ~unordered~],\n): Normal[Record[TypedArrayWithBufferWitnessRecord]] | Throw = {\n  call %0 = clo<\"RequireInternalSlot\">(O, \"TypedArrayName\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  assert (exists O.ViewedArrayBuffer)\n  call %1 = clo<\"MakeTypedArrayWithBufferWitnessRecord\">(O, order)\n  let taRecord = %1\n  call %2 = clo<\"IsTypedArrayOutOfBounds\">(taRecord)\n  if (= %2 true) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  if (? taRecord: Completion) return taRecord\n  call %5 = clo<\"NormalCompletion\">(taRecord)\n  return %5\n}","def TypedArrayElementSize(\n  O: Record[TypedArray],\n): NonNegInt = {\n  (yet \"Return the Element Size value specified in <emu-xref href=\\\"#table-the-typedarray-constructors\\\"></emu-xref> for _O_.[[TypedArrayName]].\")\n}","def TypedArrayElementType(\n  O: Record[TypedArray],\n): Unknown[\"TypedArrayElementType\"] = {\n  (yet \"Return the Element Type value specified in <emu-xref href=\\\"#table-the-typedarray-constructors\\\"></emu-xref> for _O_.[[TypedArrayName]].\")\n}","def CompareTypedArrayElements(\n  x: Number | BigInt,\n  y: Number | BigInt,\n  comparefn: Record[FunctionObject] | Undefined,\n): Normal[Number] | Abrupt = {\n  assert (|| (&& (? x: Number) (? y: Number)) (&& (? x: BigInt) (? y: BigInt)))\n  if (! (= comparefn undefined)) {\n    call %0 = clo<\"Call\">(comparefn, undefined, (list [x, y])[#1193])\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    call %1 = clo<\"ToNumber\">(%0)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let v = %1\n    if (= v NaN) {\n      call %2 = clo<\"NormalCompletion\">(0.0f)\n      return %2\n    }\n    if (? v: Completion) return v\n    call %3 = clo<\"NormalCompletion\">(v)\n    return %3\n  }\n  if (&& (= x NaN) (= y NaN)) {\n    call %4 = clo<\"NormalCompletion\">(0.0f)\n    return %4\n  }\n  if (= x NaN) {\n    call %5 = clo<\"NormalCompletion\">(1.0f)\n    return %5\n  }\n  if (= y NaN) {\n    call %6 = clo<\"NormalCompletion\">(-1.0f)\n    return %6\n  }\n  if (< x y) {\n    call %7 = clo<\"NormalCompletion\">(-1.0f)\n    return %7\n  }\n  if (< y x) {\n    call %8 = clo<\"NormalCompletion\">(1.0f)\n    return %8\n  }\n  if (&& (= x -0.0f) (= y 0.0f)) {\n    call %9 = clo<\"NormalCompletion\">(-1.0f)\n    return %9\n  }\n  if (&& (= x 0.0f) (= y -0.0f)) {\n    call %10 = clo<\"NormalCompletion\">(1.0f)\n    return %10\n  }\n  call %11 = clo<\"NormalCompletion\">(0.0f)\n  return %11\n}","def <BUILTIN>:INTRINSICS._TypedArray_(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1194]\n  let args = ArgumentsList\n  if (= NewTarget undefined) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  (yet \"Let _constructorName_ be the String value of the Constructor Name value specified in <emu-xref href=\\\"#table-the-typedarray-constructors\\\"></emu-xref> for this <var>TypedArray</var> constructor.\")\n  (yet \"Let _proto_ be <code>\\\"%<var>TypedArray</var>.prototype%\\\"</code>.\")\n  let numberOfArgs = (sizeof args)\n  if (== numberOfArgs 0) {\n    call %2 = clo<\"AllocateTypedArray\">(constructorName, NewTarget, proto, 0)\n    assert (? %2: Completion)\n    return %2\n  } else {\n    let firstArgument = args[0]\n    if (? firstArgument: Record[Object]) {\n      call %3 = clo<\"AllocateTypedArray\">(constructorName, NewTarget, proto)\n      assert (? %3: Completion)\n      if (? %3: Abrupt) return %3\n      else %3 = %3.Value\n      let O = %3\n      if (exists firstArgument.TypedArrayName) {\n        call %4 = clo<\"InitializeTypedArrayFromTypedArray\">(O, firstArgument)\n        assert (? %4: Completion)\n        if (? %4: Abrupt) return %4\n        else %4 = %4.Value\n      } else {\n        if (exists firstArgument.ArrayBufferData) {\n          if (< 1 numberOfArgs) {\n            let byteOffset = args[1]\n          } else {\n            let byteOffset = undefined\n          }\n          if (< 2 numberOfArgs) {\n            let length = args[2]\n          } else {\n            let length = undefined\n          }\n          call %5 = clo<\"InitializeTypedArrayFromArrayBuffer\">(O, firstArgument, byteOffset, length)\n          assert (? %5: Completion)\n          if (? %5: Abrupt) return %5\n          else %5 = %5.Value\n        } else {\n          assert (yet \"_firstArgument_ is an Object and _firstArgument_ does not have either a [[TypedArrayName]] or an [[ArrayBufferData]] internal slot.\")\n          call %6 = clo<\"GetMethod\">(firstArgument, @SYMBOL.iterator)\n          assert (? %6: Completion)\n          if (? %6: Abrupt) return %6\n          else %6 = %6.Value\n          let usingIterator = %6\n          if (! (= usingIterator undefined)) {\n            call %7 = clo<\"GetIteratorFromMethod\">(firstArgument, usingIterator)\n            assert (? %7: Completion)\n            if (? %7: Abrupt) return %7\n            else %7 = %7.Value\n            call %8 = clo<\"IteratorToList\">(%7)\n            assert (? %8: Completion)\n            if (? %8: Abrupt) return %8\n            else %8 = %8.Value\n            let values = %8\n            call %9 = clo<\"InitializeTypedArrayFromList\">(O, values)\n            assert (? %9: Completion)\n            if (? %9: Abrupt) return %9\n            else %9 = %9.Value\n          } else {\n            nop\n            call %10 = clo<\"InitializeTypedArrayFromArrayLike\">(O, firstArgument)\n            assert (? %10: Completion)\n            if (? %10: Abrupt) return %10\n            else %10 = %10.Value\n          }\n        }\n      }\n      if (? O: Completion) return O\n      call %11 = clo<\"NormalCompletion\">(O)\n      return %11\n    } else {\n      assert (! (? firstArgument: Record[Object]))\n      call %12 = clo<\"ToIndex\">(firstArgument)\n      assert (? %12: Completion)\n      if (? %12: Abrupt) return %12\n      else %12 = %12.Value\n      let elementLength = %12\n      call %13 = clo<\"AllocateTypedArray\">(constructorName, NewTarget, proto, elementLength)\n      assert (? %13: Completion)\n      return %13\n    }\n  }\n}","def AllocateTypedArray(\n  constructorName: String,\n  newTarget: Record[Constructor],\n  defaultProto: String,\n  length?: NonNegInt,\n): Normal[Record[TypedArray]] | Throw = {\n  call %0 = clo<\"GetPrototypeFromConstructor\">(newTarget, defaultProto)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let proto = %0\n  call %1 = clo<\"TypedArrayCreate\">(proto)\n  let obj = %1\n  assert (= obj.ViewedArrayBuffer undefined)\n  obj.TypedArrayName = constructorName\n  if (|| (= constructorName \"BigInt64Array\") (= constructorName \"BigUint64Array\")) {\n    obj.ContentType = ~bigint~\n  } else {\n    obj.ContentType = ~number~\n  }\n  if (! (exists length)) {\n    obj.ByteLength = 0\n    obj.ByteOffset = 0\n    obj.ArrayLength = 0\n  } else {\n    call %2 = clo<\"AllocateTypedArrayBuffer\">(obj, length)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n  }\n  if (? obj: Completion) return obj\n  call %3 = clo<\"NormalCompletion\">(obj)\n  return %3\n}","def InitializeTypedArrayFromTypedArray(\n  O: Record[TypedArray],\n  srcArray: Record[TypedArray],\n): Normal[Enum[~unused~]] | Throw = {\n  let srcData = srcArray.ViewedArrayBuffer\n  call %0 = clo<\"TypedArrayElementType\">(O)\n  let elementType = %0\n  call %1 = clo<\"TypedArrayElementSize\">(O)\n  let elementSize = %1\n  call %2 = clo<\"TypedArrayElementType\">(srcArray)\n  let srcType = %2\n  call %3 = clo<\"TypedArrayElementSize\">(srcArray)\n  let srcElementSize = %3\n  let srcByteOffset = srcArray.ByteOffset\n  call %4 = clo<\"MakeTypedArrayWithBufferWitnessRecord\">(srcArray, ~seq-cst~)\n  let srcRecord = %4\n  call %5 = clo<\"IsTypedArrayOutOfBounds\">(srcRecord)\n  if (= %5 true) {\n    call %6 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %7 = clo<\"ThrowCompletion\">(%6)\n    return %7\n  }\n  call %8 = clo<\"TypedArrayLength\">(srcRecord)\n  let elementLength = %8\n  let byteLength = (* elementSize elementLength)\n  if (= elementType srcType) {\n    call %9 = clo<\"CloneArrayBuffer\">(srcData, srcByteOffset, byteLength)\n    assert (? %9: Completion)\n    if (? %9: Abrupt) return %9\n    else %9 = %9.Value\n    let data = %9\n  } else {\n    call %10 = clo<\"AllocateArrayBuffer\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%ArrayBuffer%\"], byteLength)\n    assert (? %10: Completion)\n    if (? %10: Abrupt) return %10\n    else %10 = %10.Value\n    let data = %10\n    if (! (= srcArray.ContentType O.ContentType)) {\n      call %11 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %12 = clo<\"ThrowCompletion\">(%11)\n      return %12\n    }\n    let srcByteIndex = srcByteOffset\n    let targetByteIndex = 0\n    let count = elementLength\n    while (< 0 count) {\n      call %13 = clo<\"GetValueFromBuffer\">(srcData, srcByteIndex, srcType, true, ~unordered~)\n      let value = %13\n      call %14 = clo<\"SetValueInBuffer\">(data, targetByteIndex, elementType, value, true, ~unordered~)\n      srcByteIndex = (+ srcByteIndex srcElementSize)\n      targetByteIndex = (+ targetByteIndex elementSize)\n      count = (- count 1)\n    }\n  }\n  O.ViewedArrayBuffer = data\n  O.ByteLength = byteLength\n  O.ByteOffset = 0\n  O.ArrayLength = elementLength\n  call %15 = clo<\"NormalCompletion\">(~unused~)\n  return %15\n}","def InitializeTypedArrayFromArrayBuffer(\n  O: Record[TypedArray],\n  buffer: Record[ArrayBuffer | SharedArrayBuffer],\n  byteOffset: ESValue,\n  length: ESValue,\n): Normal[Enum[~unused~]] | Throw = {\n  call %0 = clo<\"TypedArrayElementSize\">(O)\n  let elementSize = %0\n  call %1 = clo<\"ToIndex\">(byteOffset)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let offset = %1\n  if (! (== (% offset elementSize) 0)) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  call %4 = clo<\"IsFixedLengthArrayBuffer\">(buffer)\n  let bufferIsFixedLength = %4\n  if (! (= length undefined)) {\n    call %5 = clo<\"ToIndex\">(length)\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n    let newLength = %5\n  }\n  call %6 = clo<\"IsDetachedBuffer\">(buffer)\n  if (= %6 true) {\n    call %7 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %8 = clo<\"ThrowCompletion\">(%7)\n    return %8\n  }\n  call %9 = clo<\"ArrayBufferByteLength\">(buffer, ~seq-cst~)\n  let bufferByteLength = %9\n  if (&& (= length undefined) (= bufferIsFixedLength false)) {\n    if (< bufferByteLength offset) {\n      call %10 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n      call %11 = clo<\"ThrowCompletion\">(%10)\n      return %11\n    }\n    O.ByteLength = ~auto~\n    O.ArrayLength = ~auto~\n  } else {\n    if (= length undefined) {\n      if (! (== (% bufferByteLength elementSize) 0)) {\n        call %12 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n        call %13 = clo<\"ThrowCompletion\">(%12)\n        return %13\n      }\n      let newByteLength = (- bufferByteLength offset)\n      if (< newByteLength 0) {\n        call %14 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n        call %15 = clo<\"ThrowCompletion\">(%14)\n        return %15\n      }\n    } else {\n      let newByteLength = (* newLength elementSize)\n      if (< bufferByteLength (+ offset newByteLength)) {\n        call %16 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n        call %17 = clo<\"ThrowCompletion\">(%16)\n        return %17\n      }\n    }\n    O.ByteLength = newByteLength\n    O.ArrayLength = (/ newByteLength elementSize)\n  }\n  O.ViewedArrayBuffer = buffer\n  O.ByteOffset = offset\n  call %18 = clo<\"NormalCompletion\">(~unused~)\n  return %18\n}","def InitializeTypedArrayFromList(\n  O: Record[TypedArray],\n  values: List[ESValue],\n): Normal[Enum[~unused~]] | Throw = {\n  let len = (sizeof values)\n  call %0 = clo<\"AllocateTypedArrayBuffer\">(O, len)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let k = 0\n  while (< k len) {\n    call %1 = clo<\"ToString\">(([number] k))\n    assert (? %1: Normal)\n    %1 = %1.Value\n    let Pk = %1\n    let kValue = values[0]\n    pop %2 < values\n    call %3 = clo<\"Set\">(O, Pk, kValue, true)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    k = (+ k 1)\n  }\n  assert (yet \"_values_ is now an empty List.\")\n  call %4 = clo<\"NormalCompletion\">(~unused~)\n  return %4\n}","def InitializeTypedArrayFromArrayLike(\n  O: Record[TypedArray],\n  arrayLike: Unknown[\"Object,ButNotATypedArrayOrAnArrayBuffer\"],\n): Normal[Enum[~unused~]] | Throw = {\n  call %0 = clo<\"LengthOfArrayLike\">(arrayLike)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let len = %0\n  call %1 = clo<\"AllocateTypedArrayBuffer\">(O, len)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let k = 0\n  while (< k len) {\n    call %2 = clo<\"ToString\">(([number] k))\n    assert (? %2: Normal)\n    %2 = %2.Value\n    let Pk = %2\n    call %3 = clo<\"Get\">(arrayLike, Pk)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let kValue = %3\n    call %4 = clo<\"Set\">(O, Pk, kValue, true)\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    k = (+ k 1)\n  }\n  call %5 = clo<\"NormalCompletion\">(~unused~)\n  return %5\n}","def AllocateTypedArrayBuffer(\n  O: Record[TypedArray],\n  length: NonNegInt,\n): Normal[Enum[~unused~]] | Throw = {\n  assert (= O.ViewedArrayBuffer undefined)\n  call %0 = clo<\"TypedArrayElementSize\">(O)\n  let elementSize = %0\n  let byteLength = (* elementSize length)\n  call %1 = clo<\"AllocateArrayBuffer\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%ArrayBuffer%\"], byteLength)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let data = %1\n  O.ViewedArrayBuffer = data\n  O.ByteLength = byteLength\n  O.ByteOffset = 0\n  O.ArrayLength = length\n  call %2 = clo<\"NormalCompletion\">(~unused~)\n  return %2\n}","def <BUILTIN>:INTRINSICS.Map(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1195]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop iterable < ArgumentsList\n    expand __args__.iterable\n  } else let iterable = undefined\n  if (= NewTarget undefined) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"OrdinaryCreateFromConstructor\">(NewTarget, \"%Map.prototype%\", (list [\"MapData\"])[#1196])\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let map = %2\n  map.MapData = (list [])[#1197]\n  if (|| (= iterable undefined) (= iterable null)) {\n    if (? map: Completion) return map\n    call %3 = clo<\"NormalCompletion\">(map)\n    return %3\n  }\n  call %4 = clo<\"Get\">(map, \"set\")\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let adder = %4\n  call %5 = clo<\"IsCallable\">(adder)\n  if (= %5 false) {\n    call %6 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %7 = clo<\"ThrowCompletion\">(%6)\n    return %7\n  }\n  call %8 = clo<\"AddEntriesFromIterable\">(map, iterable, adder)\n  assert (? %8: Completion)\n  return %8\n}","def AddEntriesFromIterable(\n  target: Record[Object],\n  iterable: Unknown[\"ECMAScriptLanguageValue,ButNot*undefined*Or*null*\"],\n  adder: Record[FunctionObject],\n): Normal[ESValue] | Throw = {\n  call %0 = clo<\"GetIterator\">(iterable, ~sync~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let iteratorRecord = %0\n  while true {\n    call %1 = clo<\"IteratorStepValue\">(iteratorRecord)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let next = %1\n    if (= next ~done~) {\n      if (? target: Completion) return target\n      call %2 = clo<\"NormalCompletion\">(target)\n      return %2\n    }\n    if (! (? next: Record[Object])) {\n      call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %4 = clo<\"ThrowCompletion\">(%3)\n      let error = %4\n      call %5 = clo<\"IteratorClose\">(iteratorRecord, error)\n      assert (? %5: Completion)\n      return %5\n    }\n    call %6 = clo<\"Get\">(next, \"0\")\n    call %7 = clo<\"Completion\">(%6)\n    let k = %7\n    assert (? k: Completion)\n    if (&& (? k: Completion) (! (= k.Type ~normal~))) {\n      call %8 = clo<\"IteratorClose\">(iteratorRecord, k)\n      assert (? %8: Completion)\n      return %8\n    } else {\n      assert (? k: Normal)\n      k = k.Value\n      k = k\n    }\n    call %9 = clo<\"Get\">(next, \"1\")\n    call %10 = clo<\"Completion\">(%9)\n    let v = %10\n    assert (? v: Completion)\n    if (&& (? v: Completion) (! (= v.Type ~normal~))) {\n      call %11 = clo<\"IteratorClose\">(iteratorRecord, v)\n      assert (? %11: Completion)\n      return %11\n    } else {\n      assert (? v: Normal)\n      v = v.Value\n      v = v\n    }\n    call %12 = clo<\"Call\">(adder, target, (list [k, v])[#1198])\n    call %13 = clo<\"Completion\">(%12)\n    let status = %13\n    assert (? status: Completion)\n    if (&& (? status: Completion) (! (= status.Type ~normal~))) {\n      call %14 = clo<\"IteratorClose\">(iteratorRecord, status)\n      assert (? %14: Completion)\n      return %14\n    } else {\n      assert (? status: Normal)\n      status = status.Value\n      status = status\n    }\n  }\n}","def <BUILTIN>:INTRINSICS.Map.groupBy(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1199]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop items < ArgumentsList\n    expand __args__.items\n  } else let items = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop callbackfn < ArgumentsList\n    expand __args__.callbackfn\n  } else let callbackfn = undefined\n  call %0 = clo<\"GroupBy\">(items, callbackfn, ~zero~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let groups = %0\n  call %1 = clo<\"Construct\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Map%\"])\n  assert (? %1: Normal)\n  %1 = %1.Value\n  let map = %1\n  %3 = groups\n  %2 = 0\n  while (< %2 (sizeof %3)) {\n    let g = %3[%2]\n    if (? g: Record[{ Elements, Key }]) {\n      call %4 = clo<\"CreateArrayFromList\">(g.Elements)\n      let elements = %4\n      let entry = (record {\n        \"Key\" : g.Key,\n        \"Value\" : elements,\n      })[#1200]\n      push map.MapData < entry\n    }\n    %2 = (+ %2 1)\n  }\n  if (? map: Completion) return map\n  call %5 = clo<\"NormalCompletion\">(map)\n  return %5\n}","def <BUILTIN>:INTRINSICS.get Map[@@species](\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1201]\n  if (? this: Completion) return this\n  call %0 = clo<\"NormalCompletion\">(this)\n  return %0\n}","def <BUILTIN>:INTRINSICS.Map.prototype.clear(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1202]\n  let M = this\n  call %0 = clo<\"RequireInternalSlot\">(M, \"MapData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  %2 = M.MapData\n  %1 = 0\n  while (< %1 (sizeof %2)) {\n    let p = %2[%1]\n    if (? p: Record[{ Key, Value }]) {\n      p.Key = ~empty~\n      p.Value = ~empty~\n    }\n    %1 = (+ %1 1)\n  }\n  call %3 = clo<\"NormalCompletion\">(undefined)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Map.prototype.delete(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1203]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop key < ArgumentsList\n    expand __args__.key\n  } else let key = undefined\n  let M = this\n  call %0 = clo<\"RequireInternalSlot\">(M, \"MapData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  %2 = M.MapData\n  %1 = 0\n  while (< %1 (sizeof %2)) {\n    let p = %2[%1]\n    if (? p: Record[{ Key, Value }]) {\n      %3 = (! (= p.Key ~empty~))\n      if %3 {\n        call %4 = clo<\"SameValueZero\">(p.Key, key)\n        %3 = (= %4 true)\n      }\n      if %3 {\n        p.Key = ~empty~\n        p.Value = ~empty~\n        call %5 = clo<\"NormalCompletion\">(true)\n        return %5\n      }\n    }\n    %1 = (+ %1 1)\n  }\n  call %6 = clo<\"NormalCompletion\">(false)\n  return %6\n}","def <BUILTIN>:INTRINSICS.Map.prototype.entries(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1204]\n  let M = this\n  call %0 = clo<\"CreateMapIterator\">(M, ~key+value~)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.Map.prototype.forEach(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1205]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop callbackfn < ArgumentsList\n    expand __args__.callbackfn\n  } else let callbackfn = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop thisArg < ArgumentsList\n    expand __args__.thisArg\n  } else let thisArg = undefined\n  let M = this\n  call %0 = clo<\"RequireInternalSlot\">(M, \"MapData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"IsCallable\">(callbackfn)\n  if (= %1 false) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  let entries = M.MapData\n  let numEntries = (sizeof entries)\n  let index = 0\n  while (< index numEntries) {\n    let e = entries[index]\n    index = (+ index 1)\n    if (! (= e.Key ~empty~)) {\n      call %4 = clo<\"Call\">(callbackfn, thisArg, (list [e.Value, e.Key, M])[#1206])\n      assert (? %4: Completion)\n      if (? %4: Abrupt) return %4\n      else %4 = %4.Value\n      nop\n      numEntries = (sizeof entries)\n    }\n  }\n  call %5 = clo<\"NormalCompletion\">(undefined)\n  return %5\n}","def <BUILTIN>:INTRINSICS.Map.prototype.get(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1207]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop key < ArgumentsList\n    expand __args__.key\n  } else let key = undefined\n  let M = this\n  call %0 = clo<\"RequireInternalSlot\">(M, \"MapData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  %2 = M.MapData\n  %1 = 0\n  while (< %1 (sizeof %2)) {\n    let p = %2[%1]\n    if (? p: Record[{ Key, Value }]) {\n      %3 = (! (= p.Key ~empty~))\n      if %3 {\n        call %4 = clo<\"SameValueZero\">(p.Key, key)\n        %3 = (= %4 true)\n      }\n      if %3 {\n        %5 = p.Value\n        if (? %5: Completion) return %5\n        call %6 = clo<\"NormalCompletion\">(%5)\n        return %6\n      }\n    }\n    %1 = (+ %1 1)\n  }\n  call %7 = clo<\"NormalCompletion\">(undefined)\n  return %7\n}","def <BUILTIN>:INTRINSICS.Map.prototype.has(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1208]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop key < ArgumentsList\n    expand __args__.key\n  } else let key = undefined\n  let M = this\n  call %0 = clo<\"RequireInternalSlot\">(M, \"MapData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  %2 = M.MapData\n  %1 = 0\n  while (< %1 (sizeof %2)) {\n    let p = %2[%1]\n    if (? p: Record[{ Key, Value }]) {\n      %3 = (! (= p.Key ~empty~))\n      if %3 {\n        call %4 = clo<\"SameValueZero\">(p.Key, key)\n        %3 = (= %4 true)\n      }\n      if %3 {\n        call %5 = clo<\"NormalCompletion\">(true)\n        return %5\n      }\n    }\n    %1 = (+ %1 1)\n  }\n  call %6 = clo<\"NormalCompletion\">(false)\n  return %6\n}","def <BUILTIN>:INTRINSICS.Map.prototype.keys(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1209]\n  let M = this\n  call %0 = clo<\"CreateMapIterator\">(M, ~key~)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.Map.prototype.set(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1210]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop key < ArgumentsList\n    expand __args__.key\n  } else let key = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  let M = this\n  call %0 = clo<\"RequireInternalSlot\">(M, \"MapData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  %2 = M.MapData\n  %1 = 0\n  while (< %1 (sizeof %2)) {\n    let p = %2[%1]\n    if (? p: Record[{ Key, Value }]) {\n      %3 = (! (= p.Key ~empty~))\n      if %3 {\n        call %4 = clo<\"SameValueZero\">(p.Key, key)\n        %3 = (= %4 true)\n      }\n      if %3 {\n        p.Value = value\n        if (? M: Completion) return M\n        call %5 = clo<\"NormalCompletion\">(M)\n        return %5\n      }\n    }\n    %1 = (+ %1 1)\n  }\n  if (= key -0.0f) {\n    key = 0.0f\n  }\n  let p = (record {\n    \"Key\" : key,\n    \"Value\" : value,\n  })[#1211]\n  push M.MapData < p\n  if (? M: Completion) return M\n  call %6 = clo<\"NormalCompletion\">(M)\n  return %6\n}","def <BUILTIN>:INTRINSICS.get Map.prototype.size(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1212]\n  let M = this\n  call %0 = clo<\"RequireInternalSlot\">(M, \"MapData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let count = 0\n  %2 = M.MapData\n  %1 = 0\n  while (< %1 (sizeof %2)) {\n    let p = %2[%1]\n    if (? p: Record[{ Key, Value }]) {\n      if (! (= p.Key ~empty~)) {\n        count = (+ count 1)\n      }\n    }\n    %1 = (+ %1 1)\n  }\n  %3 = ([number] count)\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Map.prototype.values(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1213]\n  let M = this\n  call %0 = clo<\"CreateMapIterator\">(M, ~value~)\n  assert (? %0: Completion)\n  return %0\n}","def <CLO>:CreateMapIterator:clo0(\n): Unknown = {\n  let entries = map.MapData\n  let index = 0\n  let numEntries = (sizeof entries)\n  while (< index numEntries) {\n    let e = entries[index]\n    index = (+ index 1)\n    if (! (= e.Key ~empty~)) {\n      if (= kind ~key~) {\n        let result = e.Key\n      } else {\n        if (= kind ~value~) {\n          let result = e.Value\n        } else {\n          assert (= kind ~key+value~)\n          call %0 = clo<\"CreateArrayFromList\">((list [e.Key, e.Value])[#1214])\n          let result = %0\n        }\n      }\n      call %1 = clo<\"CreateIterResultObject\">(result, false)\n      call %2 = clo<\"GeneratorYield\">(%1)\n      assert (? %2: Completion)\n      if (? %2: Abrupt) return %2\n      else %2 = %2.Value\n      nop\n      numEntries = (sizeof entries)\n    }\n  }\n  call %3 = clo<\"NormalCompletion\">(undefined)\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def CreateMapIterator(\n  map: ESValue,\n  kind: Enum[~key+value~, ~key~, ~value~],\n): Normal[Record[Generator]] | Throw = {\n  call %0 = clo<\"RequireInternalSlot\">(map, \"MapData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let closure = clo<\"CreateMapIterator:clo0\", [map, kind]>\n  call %1 = clo<\"CreateIteratorFromClosure\">(closure, \"%MapIteratorPrototype%\", @EXECUTION_STACK[0].Realm.Intrinsics[\"%MapIteratorPrototype%\"])\n  if (? %1: Completion) return %1\n  call %2 = clo<\"NormalCompletion\">(%1)\n  return %2\n}","def <BUILTIN>:INTRINSICS.MapIteratorPrototype.next(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1215]\n  call %0 = clo<\"GeneratorResume\">(this, ~empty~, \"%MapIteratorPrototype%\")\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.Set(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1216]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop iterable < ArgumentsList\n    expand __args__.iterable\n  } else let iterable = undefined\n  if (= NewTarget undefined) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"OrdinaryCreateFromConstructor\">(NewTarget, \"%Set.prototype%\", (list [\"SetData\"])[#1217])\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let set = %2\n  set.SetData = (list [])[#1218]\n  if (|| (= iterable undefined) (= iterable null)) {\n    if (? set: Completion) return set\n    call %3 = clo<\"NormalCompletion\">(set)\n    return %3\n  }\n  call %4 = clo<\"Get\">(set, \"add\")\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let adder = %4\n  call %5 = clo<\"IsCallable\">(adder)\n  if (= %5 false) {\n    call %6 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %7 = clo<\"ThrowCompletion\">(%6)\n    return %7\n  }\n  call %8 = clo<\"GetIterator\">(iterable, ~sync~)\n  assert (? %8: Completion)\n  if (? %8: Abrupt) return %8\n  else %8 = %8.Value\n  let iteratorRecord = %8\n  while true {\n    call %9 = clo<\"IteratorStepValue\">(iteratorRecord)\n    assert (? %9: Completion)\n    if (? %9: Abrupt) return %9\n    else %9 = %9.Value\n    let next = %9\n    if (= next ~done~) {\n      if (? set: Completion) return set\n      call %10 = clo<\"NormalCompletion\">(set)\n      return %10\n    }\n    call %11 = clo<\"Call\">(adder, set, (list [next])[#1219])\n    call %12 = clo<\"Completion\">(%11)\n    let status = %12\n    assert (? status: Completion)\n    if (&& (? status: Completion) (! (= status.Type ~normal~))) {\n      call %13 = clo<\"IteratorClose\">(iteratorRecord, status)\n      assert (? %13: Completion)\n      return %13\n    } else {\n      assert (? status: Normal)\n      status = status.Value\n      status = status\n    }\n  }\n}","def <BUILTIN>:INTRINSICS.get Set[@@species](\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1220]\n  if (? this: Completion) return this\n  call %0 = clo<\"NormalCompletion\">(this)\n  return %0\n}","def <BUILTIN>:INTRINSICS.Set.prototype.add(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1221]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  let S = this\n  call %0 = clo<\"RequireInternalSlot\">(S, \"SetData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  %2 = S.SetData\n  %1 = 0\n  while (< %1 (sizeof %2)) {\n    let e = %2[%1]\n    %3 = (! (= e ~empty~))\n    if %3 {\n      call %4 = clo<\"SameValueZero\">(e, value)\n      %3 = (= %4 true)\n    }\n    if %3 {\n      if (? S: Completion) return S\n      call %5 = clo<\"NormalCompletion\">(S)\n      return %5\n    }\n    %1 = (+ %1 1)\n  }\n  if (= value -0.0f) {\n    value = 0.0f\n  }\n  push S.SetData < value\n  if (? S: Completion) return S\n  call %6 = clo<\"NormalCompletion\">(S)\n  return %6\n}","def <BUILTIN>:INTRINSICS.Set.prototype.clear(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1222]\n  let S = this\n  call %0 = clo<\"RequireInternalSlot\">(S, \"SetData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  %2 = S.SetData\n  %1 = 0\n  while (< %1 (sizeof %2)) {\n    let e = %2[%1]\n    (yet \"Replace the element of _S_.[[SetData]] whose value is _e_ with an element whose value is ~empty~.\")\n    %1 = (+ %1 1)\n  }\n  call %3 = clo<\"NormalCompletion\">(undefined)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Set.prototype.delete(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1223]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  let S = this\n  call %0 = clo<\"RequireInternalSlot\">(S, \"SetData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  %2 = S.SetData\n  %1 = 0\n  while (< %1 (sizeof %2)) {\n    let e = %2[%1]\n    %3 = (! (= e ~empty~))\n    if %3 {\n      call %4 = clo<\"SameValueZero\">(e, value)\n      %3 = (= %4 true)\n    }\n    if %3 {\n      (yet \"Replace the element of _S_.[[SetData]] whose value is _e_ with an element whose value is ~empty~.\")\n      call %5 = clo<\"NormalCompletion\">(true)\n      return %5\n    }\n    %1 = (+ %1 1)\n  }\n  call %6 = clo<\"NormalCompletion\">(false)\n  return %6\n}","def <BUILTIN>:INTRINSICS.Set.prototype.entries(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1224]\n  let S = this\n  call %0 = clo<\"CreateSetIterator\">(S, ~key+value~)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.Set.prototype.forEach(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1225]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop callbackfn < ArgumentsList\n    expand __args__.callbackfn\n  } else let callbackfn = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop thisArg < ArgumentsList\n    expand __args__.thisArg\n  } else let thisArg = undefined\n  let S = this\n  call %0 = clo<\"RequireInternalSlot\">(S, \"SetData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"IsCallable\">(callbackfn)\n  if (= %1 false) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  let entries = S.SetData\n  let numEntries = (sizeof entries)\n  let index = 0\n  while (< index numEntries) {\n    let e = entries[index]\n    index = (+ index 1)\n    if (! (= e ~empty~)) {\n      call %4 = clo<\"Call\">(callbackfn, thisArg, (list [e, e, S])[#1226])\n      assert (? %4: Completion)\n      if (? %4: Abrupt) return %4\n      else %4 = %4.Value\n      nop\n      numEntries = (sizeof entries)\n    }\n  }\n  call %5 = clo<\"NormalCompletion\">(undefined)\n  return %5\n}","def <BUILTIN>:INTRINSICS.Set.prototype.has(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1227]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  let S = this\n  call %0 = clo<\"RequireInternalSlot\">(S, \"SetData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  %2 = S.SetData\n  %1 = 0\n  while (< %1 (sizeof %2)) {\n    let e = %2[%1]\n    %3 = (! (= e ~empty~))\n    if %3 {\n      call %4 = clo<\"SameValueZero\">(e, value)\n      %3 = (= %4 true)\n    }\n    if %3 {\n      call %5 = clo<\"NormalCompletion\">(true)\n      return %5\n    }\n    %1 = (+ %1 1)\n  }\n  call %6 = clo<\"NormalCompletion\">(false)\n  return %6\n}","def <BUILTIN>:INTRINSICS.get Set.prototype.size(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1228]\n  let S = this\n  call %0 = clo<\"RequireInternalSlot\">(S, \"SetData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let count = 0\n  %2 = S.SetData\n  %1 = 0\n  while (< %1 (sizeof %2)) {\n    let e = %2[%1]\n    if (! (= e ~empty~)) {\n      count = (+ count 1)\n    }\n    %1 = (+ %1 1)\n  }\n  %3 = ([number] count)\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Set.prototype.values(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1229]\n  let S = this\n  call %0 = clo<\"CreateSetIterator\">(S, ~value~)\n  assert (? %0: Completion)\n  return %0\n}","def <CLO>:CreateSetIterator:clo0(\n): Unknown = {\n  let index = 0\n  let entries = set.SetData\n  let numEntries = (sizeof entries)\n  while (< index numEntries) {\n    let e = entries[index]\n    index = (+ index 1)\n    if (! (= e ~empty~)) {\n      if (= kind ~key+value~) {\n        call %0 = clo<\"CreateArrayFromList\">((list [e, e])[#1230])\n        let result = %0\n        call %1 = clo<\"CreateIterResultObject\">(result, false)\n        call %2 = clo<\"GeneratorYield\">(%1)\n        assert (? %2: Completion)\n        if (? %2: Abrupt) return %2\n        else %2 = %2.Value\n      } else {\n        assert (= kind ~value~)\n        call %3 = clo<\"CreateIterResultObject\">(e, false)\n        call %4 = clo<\"GeneratorYield\">(%3)\n        assert (? %4: Completion)\n        if (? %4: Abrupt) return %4\n        else %4 = %4.Value\n      }\n      nop\n      numEntries = (sizeof entries)\n    }\n  }\n  call %5 = clo<\"NormalCompletion\">(undefined)\n  if (? %5: Completion) return %5\n  call %6 = clo<\"NormalCompletion\">(%5)\n  return %6\n}","def CreateSetIterator(\n  set: ESValue,\n  kind: Enum[~key+value~, ~value~],\n): Normal[Record[Generator]] | Throw = {\n  call %0 = clo<\"RequireInternalSlot\">(set, \"SetData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let closure = clo<\"CreateSetIterator:clo0\", [set, kind]>\n  call %1 = clo<\"CreateIteratorFromClosure\">(closure, \"%SetIteratorPrototype%\", @EXECUTION_STACK[0].Realm.Intrinsics[\"%SetIteratorPrototype%\"])\n  if (? %1: Completion) return %1\n  call %2 = clo<\"NormalCompletion\">(%1)\n  return %2\n}","def <BUILTIN>:INTRINSICS.SetIteratorPrototype.next(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1231]\n  call %0 = clo<\"GeneratorResume\">(this, ~empty~, \"%SetIteratorPrototype%\")\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.WeakMap(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1232]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop iterable < ArgumentsList\n    expand __args__.iterable\n  } else let iterable = undefined\n  if (= NewTarget undefined) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"OrdinaryCreateFromConstructor\">(NewTarget, \"%WeakMap.prototype%\", (list [\"WeakMapData\"])[#1233])\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let map = %2\n  map.WeakMapData = (list [])[#1234]\n  if (|| (= iterable undefined) (= iterable null)) {\n    if (? map: Completion) return map\n    call %3 = clo<\"NormalCompletion\">(map)\n    return %3\n  }\n  call %4 = clo<\"Get\">(map, \"set\")\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let adder = %4\n  call %5 = clo<\"IsCallable\">(adder)\n  if (= %5 false) {\n    call %6 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %7 = clo<\"ThrowCompletion\">(%6)\n    return %7\n  }\n  call %8 = clo<\"AddEntriesFromIterable\">(map, iterable, adder)\n  assert (? %8: Completion)\n  return %8\n}","def <BUILTIN>:INTRINSICS.WeakMap.prototype.delete(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1235]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop key < ArgumentsList\n    expand __args__.key\n  } else let key = undefined\n  let M = this\n  call %0 = clo<\"RequireInternalSlot\">(M, \"WeakMapData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"CanBeHeldWeakly\">(key)\n  if (= %1 false) {\n    call %2 = clo<\"NormalCompletion\">(false)\n    return %2\n  }\n  %4 = M.WeakMapData\n  %3 = 0\n  while (< %3 (sizeof %4)) {\n    let p = %4[%3]\n    if (? p: Record[{ Key, Value }]) {\n      %5 = (! (= p.Key ~empty~))\n      if %5 {\n        call %6 = clo<\"SameValue\">(p.Key, key)\n        %5 = (= %6 true)\n      }\n      if %5 {\n        p.Key = ~empty~\n        p.Value = ~empty~\n        call %7 = clo<\"NormalCompletion\">(true)\n        return %7\n      }\n    }\n    %3 = (+ %3 1)\n  }\n  call %8 = clo<\"NormalCompletion\">(false)\n  return %8\n}","def <BUILTIN>:INTRINSICS.WeakMap.prototype.get(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1236]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop key < ArgumentsList\n    expand __args__.key\n  } else let key = undefined\n  let M = this\n  call %0 = clo<\"RequireInternalSlot\">(M, \"WeakMapData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"CanBeHeldWeakly\">(key)\n  if (= %1 false) {\n    call %2 = clo<\"NormalCompletion\">(undefined)\n    return %2\n  }\n  %4 = M.WeakMapData\n  %3 = 0\n  while (< %3 (sizeof %4)) {\n    let p = %4[%3]\n    if (? p: Record[{ Key, Value }]) {\n      %5 = (! (= p.Key ~empty~))\n      if %5 {\n        call %6 = clo<\"SameValue\">(p.Key, key)\n        %5 = (= %6 true)\n      }\n      if %5 {\n        %7 = p.Value\n        if (? %7: Completion) return %7\n        call %8 = clo<\"NormalCompletion\">(%7)\n        return %8\n      }\n    }\n    %3 = (+ %3 1)\n  }\n  call %9 = clo<\"NormalCompletion\">(undefined)\n  return %9\n}","def <BUILTIN>:INTRINSICS.WeakMap.prototype.has(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1237]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop key < ArgumentsList\n    expand __args__.key\n  } else let key = undefined\n  let M = this\n  call %0 = clo<\"RequireInternalSlot\">(M, \"WeakMapData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"CanBeHeldWeakly\">(key)\n  if (= %1 false) {\n    call %2 = clo<\"NormalCompletion\">(false)\n    return %2\n  }\n  %4 = M.WeakMapData\n  %3 = 0\n  while (< %3 (sizeof %4)) {\n    let p = %4[%3]\n    if (? p: Record[{ Key, Value }]) {\n      %5 = (! (= p.Key ~empty~))\n      if %5 {\n        call %6 = clo<\"SameValue\">(p.Key, key)\n        %5 = (= %6 true)\n      }\n      if %5 {\n        call %7 = clo<\"NormalCompletion\">(true)\n        return %7\n      }\n    }\n    %3 = (+ %3 1)\n  }\n  call %8 = clo<\"NormalCompletion\">(false)\n  return %8\n}","def <BUILTIN>:INTRINSICS.WeakMap.prototype.set(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1238]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop key < ArgumentsList\n    expand __args__.key\n  } else let key = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  let M = this\n  call %0 = clo<\"RequireInternalSlot\">(M, \"WeakMapData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"CanBeHeldWeakly\">(key)\n  if (= %1 false) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  %5 = M.WeakMapData\n  %4 = 0\n  while (< %4 (sizeof %5)) {\n    let p = %5[%4]\n    if (? p: Record[{ Key, Value }]) {\n      %6 = (! (= p.Key ~empty~))\n      if %6 {\n        call %7 = clo<\"SameValue\">(p.Key, key)\n        %6 = (= %7 true)\n      }\n      if %6 {\n        p.Value = value\n        if (? M: Completion) return M\n        call %8 = clo<\"NormalCompletion\">(M)\n        return %8\n      }\n    }\n    %4 = (+ %4 1)\n  }\n  let p = (record {\n    \"Key\" : key,\n    \"Value\" : value,\n  })[#1239]\n  push M.WeakMapData < p\n  if (? M: Completion) return M\n  call %9 = clo<\"NormalCompletion\">(M)\n  return %9\n}","def <BUILTIN>:INTRINSICS.WeakSet(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1240]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop iterable < ArgumentsList\n    expand __args__.iterable\n  } else let iterable = undefined\n  if (= NewTarget undefined) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"OrdinaryCreateFromConstructor\">(NewTarget, \"%WeakSet.prototype%\", (list [\"WeakSetData\"])[#1241])\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let set = %2\n  set.WeakSetData = (list [])[#1242]\n  if (|| (= iterable undefined) (= iterable null)) {\n    if (? set: Completion) return set\n    call %3 = clo<\"NormalCompletion\">(set)\n    return %3\n  }\n  call %4 = clo<\"Get\">(set, \"add\")\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let adder = %4\n  call %5 = clo<\"IsCallable\">(adder)\n  if (= %5 false) {\n    call %6 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %7 = clo<\"ThrowCompletion\">(%6)\n    return %7\n  }\n  call %8 = clo<\"GetIterator\">(iterable, ~sync~)\n  assert (? %8: Completion)\n  if (? %8: Abrupt) return %8\n  else %8 = %8.Value\n  let iteratorRecord = %8\n  while true {\n    call %9 = clo<\"IteratorStepValue\">(iteratorRecord)\n    assert (? %9: Completion)\n    if (? %9: Abrupt) return %9\n    else %9 = %9.Value\n    let next = %9\n    if (= next ~done~) {\n      if (? set: Completion) return set\n      call %10 = clo<\"NormalCompletion\">(set)\n      return %10\n    }\n    call %11 = clo<\"Call\">(adder, set, (list [next])[#1243])\n    call %12 = clo<\"Completion\">(%11)\n    let status = %12\n    assert (? status: Completion)\n    if (&& (? status: Completion) (! (= status.Type ~normal~))) {\n      call %13 = clo<\"IteratorClose\">(iteratorRecord, status)\n      assert (? %13: Completion)\n      return %13\n    } else {\n      assert (? status: Normal)\n      status = status.Value\n      status = status\n    }\n  }\n}","def <BUILTIN>:INTRINSICS.WeakSet.prototype.add(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1244]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  let S = this\n  call %0 = clo<\"RequireInternalSlot\">(S, \"WeakSetData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"CanBeHeldWeakly\">(value)\n  if (= %1 false) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  %5 = S.WeakSetData\n  %4 = 0\n  while (< %4 (sizeof %5)) {\n    let e = %5[%4]\n    %6 = (! (= e ~empty~))\n    if %6 {\n      call %7 = clo<\"SameValue\">(e, value)\n      %6 = (= %7 true)\n    }\n    if %6 {\n      if (? S: Completion) return S\n      call %8 = clo<\"NormalCompletion\">(S)\n      return %8\n    }\n    %4 = (+ %4 1)\n  }\n  push S.WeakSetData < value\n  if (? S: Completion) return S\n  call %9 = clo<\"NormalCompletion\">(S)\n  return %9\n}","def <BUILTIN>:INTRINSICS.WeakSet.prototype.delete(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1245]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  let S = this\n  call %0 = clo<\"RequireInternalSlot\">(S, \"WeakSetData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"CanBeHeldWeakly\">(value)\n  if (= %1 false) {\n    call %2 = clo<\"NormalCompletion\">(false)\n    return %2\n  }\n  %4 = S.WeakSetData\n  %3 = 0\n  while (< %3 (sizeof %4)) {\n    let e = %4[%3]\n    %5 = (! (= e ~empty~))\n    if %5 {\n      call %6 = clo<\"SameValue\">(e, value)\n      %5 = (= %6 true)\n    }\n    if %5 {\n      (yet \"Replace the element of _S_.[[WeakSetData]] whose value is _e_ with an element whose value is ~empty~.\")\n      call %7 = clo<\"NormalCompletion\">(true)\n      return %7\n    }\n    %3 = (+ %3 1)\n  }\n  call %8 = clo<\"NormalCompletion\">(false)\n  return %8\n}","def <BUILTIN>:INTRINSICS.WeakSet.prototype.has(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1246]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  let S = this\n  call %0 = clo<\"RequireInternalSlot\">(S, \"WeakSetData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"CanBeHeldWeakly\">(value)\n  if (= %1 false) {\n    call %2 = clo<\"NormalCompletion\">(false)\n    return %2\n  }\n  %4 = S.WeakSetData\n  %3 = 0\n  while (< %3 (sizeof %4)) {\n    let e = %4[%3]\n    %5 = (! (= e ~empty~))\n    if %5 {\n      call %6 = clo<\"SameValue\">(e, value)\n      %5 = (= %6 true)\n    }\n    if %5 {\n      call %7 = clo<\"NormalCompletion\">(true)\n      return %7\n    }\n    %3 = (+ %3 1)\n  }\n  call %8 = clo<\"NormalCompletion\">(false)\n  return %8\n}","def AllocateArrayBuffer(\n  constructor: Record[Constructor],\n  byteLength: NonNegInt,\n  maxByteLength?: Enum[~empty~] | NonNegInt,\n): Normal[Record[ArrayBuffer]] | Throw = {\n  let slots = (list [\"ArrayBufferData\", \"ArrayBufferByteLength\", \"ArrayBufferDetachKey\"])[#1247]\n  if (&& (exists maxByteLength) (! (= maxByteLength ~empty~))) {\n    let allocatingResizableBuffer = true\n  } else {\n    let allocatingResizableBuffer = false\n  }\n  if (= allocatingResizableBuffer true) {\n    if (< maxByteLength byteLength) {\n      call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n      call %1 = clo<\"ThrowCompletion\">(%0)\n      return %1\n    }\n    push slots < \"ArrayBufferMaxByteLength\"\n  }\n  call %2 = clo<\"OrdinaryCreateFromConstructor\">(constructor, \"%ArrayBuffer.prototype%\", slots)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let obj = %2\n  call %3 = clo<\"CreateByteDataBlock\">(byteLength)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let block = %3\n  obj.ArrayBufferData = block\n  obj.ArrayBufferByteLength = byteLength\n  if (= allocatingResizableBuffer true) {\n    (yet \"If it is not possible to create a Data Block _block_ consisting of _maxByteLength_ bytes, throw a *RangeError* exception.\")\n    nop\n    obj.ArrayBufferMaxByteLength = maxByteLength\n  }\n  if (? obj: Completion) return obj\n  call %4 = clo<\"NormalCompletion\">(obj)\n  return %4\n}","def ArrayBufferByteLength(\n  arrayBuffer: Record[ArrayBuffer | SharedArrayBuffer],\n  order: Enum[~seq-cst~, ~unordered~],\n): NonNegInt = {\n  call %0 = clo<\"IsSharedArrayBuffer\">(arrayBuffer)\n  if (&& (= %0 true) (exists arrayBuffer.ArrayBufferByteLengthData)) {\n    let bufferByteLengthBlock = arrayBuffer.ArrayBufferByteLengthData\n    call %1 = clo<\"GetRawBytesFromSharedBlock\">(bufferByteLengthBlock, 0, ~biguint64~, true, order)\n    let rawLength = %1\n    (yet \"Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\")\n    call %2 = clo<\"RawBytesToNumeric\">(~biguint64~, rawLength, isLittleEndian)\n    return ([math] %2)\n  }\n  call %3 = clo<\"IsDetachedBuffer\">(arrayBuffer)\n  assert (= %3 false)\n  return arrayBuffer.ArrayBufferByteLength\n}","def ArrayBufferCopyAndDetach(\n  arrayBuffer: ESValue,\n  newLength: ESValue,\n  preserveResizability: Enum[~fixed-length~, ~preserve-resizability~],\n): Normal[Record[ArrayBuffer]] | Throw = {\n  call %0 = clo<\"RequireInternalSlot\">(arrayBuffer, \"ArrayBufferData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"IsSharedArrayBuffer\">(arrayBuffer)\n  if (= %1 true) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  if (= newLength undefined) {\n    let newByteLength = arrayBuffer.ArrayBufferByteLength\n  } else {\n    call %4 = clo<\"ToIndex\">(newLength)\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    let newByteLength = %4\n  }\n  call %5 = clo<\"IsDetachedBuffer\">(arrayBuffer)\n  if (= %5 true) {\n    call %6 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %7 = clo<\"ThrowCompletion\">(%6)\n    return %7\n  }\n  %8 = (= preserveResizability ~preserve-resizability~)\n  if %8 {\n    call %9 = clo<\"IsFixedLengthArrayBuffer\">(arrayBuffer)\n    %8 = (= %9 false)\n  }\n  if %8 {\n    let newMaxByteLength = arrayBuffer.ArrayBufferMaxByteLength\n  } else {\n    let newMaxByteLength = ~empty~\n  }\n  if (! (= arrayBuffer.ArrayBufferDetachKey undefined)) {\n    call %10 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %11 = clo<\"ThrowCompletion\">(%10)\n    return %11\n  }\n  call %12 = clo<\"AllocateArrayBuffer\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%ArrayBuffer%\"], newByteLength, newMaxByteLength)\n  assert (? %12: Completion)\n  if (? %12: Abrupt) return %12\n  else %12 = %12.Value\n  let newBuffer = %12\n  let copyLength = (min newByteLength arrayBuffer.ArrayBufferByteLength)\n  let fromBlock = arrayBuffer.ArrayBufferData\n  let toBlock = newBuffer.ArrayBufferData\n  call %13 = clo<\"CopyDataBlockBytes\">(toBlock, 0, fromBlock, 0, copyLength)\n  nop\n  call %14 = clo<\"DetachArrayBuffer\">(arrayBuffer)\n  assert (? %14: Normal)\n  %14 = %14.Value\n  if (? newBuffer: Completion) return newBuffer\n  call %15 = clo<\"NormalCompletion\">(newBuffer)\n  return %15\n}","def IsDetachedBuffer(\n  arrayBuffer: Record[ArrayBuffer | SharedArrayBuffer],\n): Boolean = {\n  if (= arrayBuffer.ArrayBufferData null) {\n    return true\n  }\n  return false\n}","def DetachArrayBuffer(\n  arrayBuffer: Record[ArrayBuffer],\n  key?: Unknown[\"Anything\"],\n): Normal[Enum[~unused~]] | Throw = {\n  call %0 = clo<\"IsSharedArrayBuffer\">(arrayBuffer)\n  assert (= %0 false)\n  if (! (exists key)) {\n    key = undefined\n  }\n  if (! (= arrayBuffer.ArrayBufferDetachKey key)) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  arrayBuffer.ArrayBufferData = null\n  arrayBuffer.ArrayBufferByteLength = 0\n  call %3 = clo<\"NormalCompletion\">(~unused~)\n  return %3\n}","def CloneArrayBuffer(\n  srcBuffer: Record[ArrayBuffer | SharedArrayBuffer],\n  srcByteOffset: NonNegInt,\n  srcLength: NonNegInt,\n): Normal[Record[ArrayBuffer]] | Throw = {\n  call %0 = clo<\"IsDetachedBuffer\">(srcBuffer)\n  assert (= %0 false)\n  call %1 = clo<\"AllocateArrayBuffer\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%ArrayBuffer%\"], srcLength)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let targetBuffer = %1\n  let srcBlock = srcBuffer.ArrayBufferData\n  let targetBlock = targetBuffer.ArrayBufferData\n  call %2 = clo<\"CopyDataBlockBytes\">(targetBlock, 0, srcBlock, srcByteOffset, srcLength)\n  if (? targetBuffer: Completion) return targetBuffer\n  call %3 = clo<\"NormalCompletion\">(targetBuffer)\n  return %3\n}","def GetArrayBufferMaxByteLengthOption(\n  options: ESValue,\n): Normal[Enum[~empty~] | NonNegInt] | Throw = {\n  if (! (? options: Record[Object])) {\n    call %0 = clo<\"NormalCompletion\">(~empty~)\n    return %0\n  }\n  call %1 = clo<\"Get\">(options, \"maxByteLength\")\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let maxByteLength = %1\n  if (= maxByteLength undefined) {\n    call %2 = clo<\"NormalCompletion\">(~empty~)\n    return %2\n  }\n  call %3 = clo<\"ToIndex\">(maxByteLength)\n  assert (? %3: Completion)\n  return %3\n}","def IsFixedLengthArrayBuffer(\n  arrayBuffer: Record[ArrayBuffer | SharedArrayBuffer],\n): Boolean = {\n  if (exists arrayBuffer.ArrayBufferMaxByteLength) {\n    return false\n  }\n  return true\n}","def IsUnsignedElementType(\n  type: Unknown[\"TypedArrayElementType\"],\n): Boolean = {\n  if (|| (|| (|| (|| (= type ~uint8~) (= type ~uint8clamped~)) (= type ~uint16~)) (= type ~uint32~)) (= type ~biguint64~)) {\n    return true\n  }\n  return false\n}","def IsUnclampedIntegerElementType(\n  type: Unknown[\"TypedArrayElementType\"],\n): Boolean = {\n  if (|| (|| (|| (|| (|| (= type ~int8~) (= type ~uint8~)) (= type ~int16~)) (= type ~uint16~)) (= type ~int32~)) (= type ~uint32~)) {\n    return true\n  }\n  return false\n}","def IsBigIntElementType(\n  type: Unknown[\"TypedArrayElementType\"],\n): Boolean = {\n  if (|| (= type ~biguint64~) (= type ~bigint64~)) {\n    return true\n  }\n  return false\n}","def IsNoTearConfiguration(\n  type: Unknown[\"TypedArrayElementType\"],\n  order: Enum[~init~, ~seq-cst~, ~unordered~],\n): Boolean = {\n  call %0 = clo<\"IsUnclampedIntegerElementType\">(type)\n  if (= %0 true) {\n    return true\n  }\n  call %1 = clo<\"IsBigIntElementType\">(type)\n  if (&& (= %1 true) (! (|| (= order ~init~) (= order ~unordered~)))) {\n    return true\n  }\n  return false\n}","def RawBytesToNumeric(\n  type: Unknown[\"TypedArrayElementType\"],\n  rawBytes: Unknown[\"ListOfByteValue\"],\n  isLittleEndian: Boolean,\n): Number | BigInt = {\n  (yet \"Let _elementSize_ be the Element Size value specified in <emu-xref href=\\\"#table-the-typedarray-constructors\\\"></emu-xref> for Element Type _type_.\")\n  if (= isLittleEndian false) {\n    (yet \"reverse the order of the elements of _rawBytes_.\")\n  }\n  if (= type ~float32~) {\n    (yet \"Let _value_ be the byte elements of _rawBytes_ concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2019 binary32 value.\")\n    (yet \"If _value_ is an IEEE 754-2019 binary32 NaN value, return the *NaN* Number value.\")\n    (yet \"Return the Number value that corresponds to _value_.\")\n  }\n  if (= type ~float64~) {\n    (yet \"Let _value_ be the byte elements of _rawBytes_ concatenated and interpreted as a little-endian bit string encoding of an IEEE 754-2019 binary64 value.\")\n    (yet \"If _value_ is an IEEE 754-2019 binary64 NaN value, return the *NaN* Number value.\")\n    (yet \"Return the Number value that corresponds to _value_.\")\n  }\n  call %0 = clo<\"IsUnsignedElementType\">(type)\n  if (= %0 true) {\n    (yet \"Let _intValue_ be the byte elements of _rawBytes_ concatenated and interpreted as a bit string encoding of an unsigned little-endian binary number.\")\n  } else {\n    (yet \"Let _intValue_ be the byte elements of _rawBytes_ concatenated and interpreted as a bit string encoding of a binary little-endian two's complement number of bit length _elementSize_ √ó 8.\")\n  }\n  call %1 = clo<\"IsBigIntElementType\">(type)\n  if (= %1 true) {\n    (yet \"return the BigInt value that corresponds to _intValue_.\")\n  } else {\n    (yet \"return the Number value that corresponds to _intValue_.\")\n  }\n}","def GetRawBytesFromSharedBlock(\n  block: Record[SharedDataBlock],\n  byteIndex: NonNegInt,\n  type: Unknown[\"TypedArrayElementType\"],\n  isTypedArray: Boolean,\n  order: Enum[~seq-cst~, ~unordered~],\n): Unknown[\"ListOfByteValue\"] = {\n  (yet \"Let _elementSize_ be the Element Size value specified in <emu-xref href=\\\"#table-the-typedarray-constructors\\\"></emu-xref> for Element Type _type_.\")\n  (yet \"Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\")\n  (yet \"Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\")\n  %0 = (= isTypedArray true)\n  if %0 {\n    call %1 = clo<\"IsNoTearConfiguration\">(type, order)\n    %0 = (= %1 true)\n  }\n  if %0 {\n    let noTear = true\n  } else {\n    let noTear = false\n  }\n  (yet \"Let _rawValue_ be a List of length _elementSize_ whose elements are nondeterministically chosen byte values.\")\n  nop\n  let readEvent = (record [ReadSharedMemory] {\n    \"Order\" : order,\n    \"NoTear\" : noTear,\n    \"Block\" : block,\n    \"ByteIndex\" : byteIndex,\n    \"ElementSize\" : elementSize,\n  })[#1248]\n  push eventsRecord.EventList < readEvent\n  push execution.ChosenValues < (record [ChosenValueRecord] {\n    \"Event\" : readEvent,\n    \"ChosenValue\" : rawValue,\n  })[#1249]\n  return rawValue\n}","def GetValueFromBuffer(\n  arrayBuffer: Record[ArrayBuffer | SharedArrayBuffer],\n  byteIndex: NonNegInt,\n  type: Unknown[\"TypedArrayElementType\"],\n  isTypedArray: Boolean,\n  order: Enum[~seq-cst~, ~unordered~],\n  isLittleEndian?: Boolean,\n): Number | BigInt = {\n  call %0 = clo<\"IsDetachedBuffer\">(arrayBuffer)\n  assert (= %0 false)\n  assert (yet \"There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.\")\n  let block = arrayBuffer.ArrayBufferData\n  (yet \"Let _elementSize_ be the Element Size value specified in <emu-xref href=\\\"#table-the-typedarray-constructors\\\"></emu-xref> for Element Type _type_.\")\n  call %1 = clo<\"IsSharedArrayBuffer\">(arrayBuffer)\n  if (= %1 true) {\n    assert (? block: Record[SharedDataBlock])\n    call %2 = clo<\"GetRawBytesFromSharedBlock\">(block, byteIndex, type, isTypedArray, order)\n    let rawValue = %2\n  } else {\n    (yet \"Let _rawValue_ be a List whose elements are bytes from _block_ at indices in the interval from _byteIndex_ (inclusive) to _byteIndex_ + _elementSize_ (exclusive).\")\n  }\n  assert (= (sizeof rawValue) elementSize)\n  if (! (exists isLittleEndian)) {\n    (yet \"set _isLittleEndian_ to the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\")\n  }\n  call %3 = clo<\"RawBytesToNumeric\">(type, rawValue, isLittleEndian)\n  return %3\n}","def NumericToRawBytes(\n  type: Unknown[\"TypedArrayElementType\"],\n  value: Number | BigInt,\n  isLittleEndian: Boolean,\n): Unknown[\"ListOfByteValue\"] = {\n  if (= type ~float32~) {\n    (yet \"Let _rawBytes_ be a List whose elements are the 4 bytes that are the result of converting _value_ to IEEE 754-2019 binary32 format using roundTiesToEven mode. The bytes are arranged in little endian order. If _value_ is *NaN*, _rawBytes_ may be set to any implementation chosen IEEE 754-2019 binary32 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable *NaN* value.\")\n  } else {\n    if (= type ~float64~) {\n      (yet \"Let _rawBytes_ be a List whose elements are the 8 bytes that are the IEEE 754-2019 binary64 format encoding of _value_. The bytes are arranged in little endian order. If _value_ is *NaN*, _rawBytes_ may be set to any implementation chosen IEEE 754-2019 binary64 format Not-a-Number encoding. An implementation must always choose the same encoding for each implementation distinguishable *NaN* value.\")\n    } else {\n      (yet \"Let _n_ be the Element Size value specified in <emu-xref href=\\\"#table-the-typedarray-constructors\\\"></emu-xref> for Element Type _type_.\")\n      (yet \"Let _convOp_ be the abstract operation named in the Conversion Operation column in <emu-xref href=\\\"#table-the-typedarray-constructors\\\"></emu-xref> for Element Type _type_.\")\n      call %0 = convOp(value)\n      let intValue = ([math] %0)\n      if (! (< intValue 0)) {\n        (yet \"Let _rawBytes_ be a List whose elements are the _n_-byte binary encoding of _intValue_. The bytes are ordered in little endian order.\")\n      } else {\n        (yet \"Let _rawBytes_ be a List whose elements are the _n_-byte binary two's complement encoding of _intValue_. The bytes are ordered in little endian order.\")\n      }\n    }\n  }\n  if (= isLittleEndian false) {\n    (yet \"reverse the order of the elements of _rawBytes_.\")\n  }\n  return rawBytes\n}","def SetValueInBuffer(\n  arrayBuffer: Record[ArrayBuffer | SharedArrayBuffer],\n  byteIndex: NonNegInt,\n  type: Unknown[\"TypedArrayElementType\"],\n  value: Number | BigInt,\n  isTypedArray: Boolean,\n  order: Enum[~init~, ~seq-cst~, ~unordered~],\n  isLittleEndian?: Boolean,\n): Enum[~unused~] = {\n  call %0 = clo<\"IsDetachedBuffer\">(arrayBuffer)\n  assert (= %0 false)\n  assert (yet \"There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.\")\n  assert (yet \"_value_ is a BigInt if IsBigIntElementType(_type_) is *true*; otherwise, _value_ is a Number.\")\n  let block = arrayBuffer.ArrayBufferData\n  (yet \"Let _elementSize_ be the Element Size value specified in <emu-xref href=\\\"#table-the-typedarray-constructors\\\"></emu-xref> for Element Type _type_.\")\n  if (! (exists isLittleEndian)) {\n    (yet \"set _isLittleEndian_ to the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\")\n  }\n  call %1 = clo<\"NumericToRawBytes\">(type, value, isLittleEndian)\n  let rawBytes = %1\n  call %2 = clo<\"IsSharedArrayBuffer\">(arrayBuffer)\n  if (= %2 true) {\n    (yet \"Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\")\n    (yet \"Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\")\n    %3 = (= isTypedArray true)\n    if %3 {\n      call %4 = clo<\"IsNoTearConfiguration\">(type, order)\n      %3 = (= %4 true)\n    }\n    if %3 {\n      let noTear = true\n    } else {\n      let noTear = false\n    }\n    push eventsRecord.EventList < (record [WriteSharedMemory] {\n      \"Order\" : order,\n      \"NoTear\" : noTear,\n      \"Block\" : block,\n      \"ByteIndex\" : byteIndex,\n      \"ElementSize\" : elementSize,\n      \"Payload\" : rawBytes,\n    })[#1250]\n  } else {\n    (yet \"Store the individual bytes of _rawBytes_ into _block_, starting at _block_[_byteIndex_].\")\n  }\n  return ~unused~\n}","def GetModifySetValueInBuffer(\n  arrayBuffer: Record[ArrayBuffer | SharedArrayBuffer],\n  byteIndex: NonNegInt,\n  type: Unknown[\"TypedArrayElementType\"],\n  value: Number | BigInt,\n  op: Unknown[\"ReadmodifywriteModificationFunction\"],\n): Number | BigInt = {\n  call %0 = clo<\"IsDetachedBuffer\">(arrayBuffer)\n  assert (= %0 false)\n  assert (yet \"There are sufficient bytes in _arrayBuffer_ starting at _byteIndex_ to represent a value of _type_.\")\n  assert (yet \"_value_ is a BigInt if IsBigIntElementType(_type_) is *true*; otherwise, _value_ is a Number.\")\n  let block = arrayBuffer.ArrayBufferData\n  (yet \"Let _elementSize_ be the Element Size value specified in <emu-xref href=\\\"#table-the-typedarray-constructors\\\"></emu-xref> for Element Type _type_.\")\n  (yet \"Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\")\n  call %1 = clo<\"NumericToRawBytes\">(type, value, isLittleEndian)\n  let rawBytes = %1\n  call %2 = clo<\"IsSharedArrayBuffer\">(arrayBuffer)\n  if (= %2 true) {\n    (yet \"Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\")\n    (yet \"Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\")\n    (yet \"Let _rawBytesRead_ be a List of length _elementSize_ whose elements are nondeterministically chosen byte values.\")\n    nop\n    let rmwEvent = (record [ReadModifyWriteSharedMemory] {\n      \"Order\" : ~seq-cst~,\n      \"NoTear\" : true,\n      \"Block\" : block,\n      \"ByteIndex\" : byteIndex,\n      \"ElementSize\" : elementSize,\n      \"Payload\" : rawBytes,\n      \"ModifyOp\" : op,\n    })[#1251]\n    push eventsRecord.EventList < rmwEvent\n    push execution.ChosenValues < (record [ChosenValueRecord] {\n      \"Event\" : rmwEvent,\n      \"ChosenValue\" : rawBytesRead,\n    })[#1252]\n  } else {\n    (yet \"Let _rawBytesRead_ be a List of length _elementSize_ whose elements are the sequence of _elementSize_ bytes starting with _block_[_byteIndex_].\")\n    call %3 = op(rawBytesRead, rawBytes)\n    let rawBytesModified = %3\n    (yet \"Store the individual bytes of _rawBytesModified_ into _block_, starting at _block_[_byteIndex_].\")\n  }\n  call %4 = clo<\"RawBytesToNumeric\">(type, rawBytesRead, isLittleEndian)\n  return %4\n}","def <BUILTIN>:INTRINSICS.ArrayBuffer(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1253]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop length < ArgumentsList\n    expand __args__.length\n  } else let length = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop options < ArgumentsList\n    expand __args__.options\n  } else let options = undefined\n  if (= NewTarget undefined) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"ToIndex\">(length)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let byteLength = %2\n  call %3 = clo<\"GetArrayBufferMaxByteLengthOption\">(options)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let requestedMaxByteLength = %3\n  call %4 = clo<\"AllocateArrayBuffer\">(NewTarget, byteLength, requestedMaxByteLength)\n  assert (? %4: Completion)\n  return %4\n}","def <BUILTIN>:INTRINSICS.ArrayBuffer.isView(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1254]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop arg < ArgumentsList\n    expand __args__.arg\n  } else let arg = undefined\n  if (! (? arg: Record[Object])) {\n    call %0 = clo<\"NormalCompletion\">(false)\n    return %0\n  }\n  if (exists arg.ViewedArrayBuffer) {\n    call %1 = clo<\"NormalCompletion\">(true)\n    return %1\n  }\n  call %2 = clo<\"NormalCompletion\">(false)\n  return %2\n}","def <BUILTIN>:INTRINSICS.get ArrayBuffer[@@species](\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1255]\n  if (? this: Completion) return this\n  call %0 = clo<\"NormalCompletion\">(this)\n  return %0\n}","def <BUILTIN>:INTRINSICS.get ArrayBuffer.prototype.byteLength(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1256]\n  let O = this\n  call %0 = clo<\"RequireInternalSlot\">(O, \"ArrayBufferData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"IsSharedArrayBuffer\">(O)\n  if (= %1 true) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  call %4 = clo<\"IsDetachedBuffer\">(O)\n  if (= %4 true) {\n    call %5 = clo<\"NormalCompletion\">(0.0f)\n    return %5\n  }\n  let length = O.ArrayBufferByteLength\n  %6 = ([number] length)\n  if (? %6: Completion) return %6\n  call %7 = clo<\"NormalCompletion\">(%6)\n  return %7\n}","def <BUILTIN>:INTRINSICS.get ArrayBuffer.prototype.detached(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1257]\n  let O = this\n  call %0 = clo<\"RequireInternalSlot\">(O, \"ArrayBufferData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"IsSharedArrayBuffer\">(O)\n  if (= %1 true) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  call %4 = clo<\"IsDetachedBuffer\">(O)\n  if (? %4: Completion) return %4\n  call %5 = clo<\"NormalCompletion\">(%4)\n  return %5\n}","def <BUILTIN>:INTRINSICS.get ArrayBuffer.prototype.maxByteLength(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1258]\n  let O = this\n  call %0 = clo<\"RequireInternalSlot\">(O, \"ArrayBufferData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"IsSharedArrayBuffer\">(O)\n  if (= %1 true) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  call %4 = clo<\"IsDetachedBuffer\">(O)\n  if (= %4 true) {\n    call %5 = clo<\"NormalCompletion\">(0.0f)\n    return %5\n  }\n  call %6 = clo<\"IsFixedLengthArrayBuffer\">(O)\n  if (= %6 true) {\n    let length = O.ArrayBufferByteLength\n  } else {\n    let length = O.ArrayBufferMaxByteLength\n  }\n  %7 = ([number] length)\n  if (? %7: Completion) return %7\n  call %8 = clo<\"NormalCompletion\">(%7)\n  return %8\n}","def <BUILTIN>:INTRINSICS.get ArrayBuffer.prototype.resizable(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1259]\n  let O = this\n  call %0 = clo<\"RequireInternalSlot\">(O, \"ArrayBufferData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"IsSharedArrayBuffer\">(O)\n  if (= %1 true) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  call %4 = clo<\"IsFixedLengthArrayBuffer\">(O)\n  if (= %4 false) {\n    call %5 = clo<\"NormalCompletion\">(true)\n    return %5\n  } else {\n    call %6 = clo<\"NormalCompletion\">(false)\n    return %6\n  }\n}","def <BUILTIN>:INTRINSICS.ArrayBuffer.prototype.resize(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1260]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop newLength < ArgumentsList\n    expand __args__.newLength\n  } else let newLength = undefined\n  let O = this\n  call %0 = clo<\"RequireInternalSlot\">(O, \"ArrayBufferMaxByteLength\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"IsSharedArrayBuffer\">(O)\n  if (= %1 true) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  call %4 = clo<\"ToIndex\">(newLength)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let newByteLength = %4\n  call %5 = clo<\"IsDetachedBuffer\">(O)\n  if (= %5 true) {\n    call %6 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %7 = clo<\"ThrowCompletion\">(%6)\n    return %7\n  }\n  if (< O.ArrayBufferMaxByteLength newByteLength) {\n    call %8 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %9 = clo<\"ThrowCompletion\">(%8)\n    return %9\n  }\n  call %10 = clo<\"HostResizeArrayBuffer\">(O, newByteLength)\n  assert (? %10: Completion)\n  if (? %10: Abrupt) return %10\n  else %10 = %10.Value\n  let hostHandled = %10\n  if (= hostHandled ~handled~) {\n    call %11 = clo<\"NormalCompletion\">(undefined)\n    return %11\n  }\n  let oldBlock = O.ArrayBufferData\n  call %12 = clo<\"CreateByteDataBlock\">(newByteLength)\n  assert (? %12: Completion)\n  if (? %12: Abrupt) return %12\n  else %12 = %12.Value\n  let newBlock = %12\n  let copyLength = (min newByteLength O.ArrayBufferByteLength)\n  call %13 = clo<\"CopyDataBlockBytes\">(newBlock, 0, oldBlock, 0, copyLength)\n  nop\n  O.ArrayBufferData = newBlock\n  O.ArrayBufferByteLength = newByteLength\n  call %14 = clo<\"NormalCompletion\">(undefined)\n  return %14\n}","def <BUILTIN>:INTRINSICS.ArrayBuffer.prototype.slice(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1261]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop start < ArgumentsList\n    expand __args__.start\n  } else let start = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop end < ArgumentsList\n    expand __args__.end\n  } else let end = undefined\n  let O = this\n  call %0 = clo<\"RequireInternalSlot\">(O, \"ArrayBufferData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"IsSharedArrayBuffer\">(O)\n  if (= %1 true) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  call %4 = clo<\"IsDetachedBuffer\">(O)\n  if (= %4 true) {\n    call %5 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %6 = clo<\"ThrowCompletion\">(%5)\n    return %6\n  }\n  let len = O.ArrayBufferByteLength\n  call %7 = clo<\"ToIntegerOrInfinity\">(start)\n  assert (? %7: Completion)\n  if (? %7: Abrupt) return %7\n  else %7 = %7.Value\n  let relativeStart = %7\n  if (== relativeStart -INF) {\n    let first = 0\n  } else {\n    if (< relativeStart 0) {\n      let first = (max (+ len relativeStart) 0)\n    } else {\n      let first = (min relativeStart len)\n    }\n  }\n  if (= end undefined) {\n    let relativeEnd = len\n  } else {\n    call %8 = clo<\"ToIntegerOrInfinity\">(end)\n    assert (? %8: Completion)\n    if (? %8: Abrupt) return %8\n    else %8 = %8.Value\n    let relativeEnd = %8\n  }\n  if (== relativeEnd -INF) {\n    let final = 0\n  } else {\n    if (< relativeEnd 0) {\n      let final = (max (+ len relativeEnd) 0)\n    } else {\n      let final = (min relativeEnd len)\n    }\n  }\n  let newLen = (max (- final first) 0)\n  call %9 = clo<\"SpeciesConstructor\">(O, @EXECUTION_STACK[0].Realm.Intrinsics[\"%ArrayBuffer%\"])\n  assert (? %9: Completion)\n  if (? %9: Abrupt) return %9\n  else %9 = %9.Value\n  let ctor = %9\n  call %10 = clo<\"Construct\">(ctor, (list [([number] newLen)])[#1262])\n  assert (? %10: Completion)\n  if (? %10: Abrupt) return %10\n  else %10 = %10.Value\n  let new = %10\n  call %11 = clo<\"RequireInternalSlot\">(new, \"ArrayBufferData\")\n  assert (? %11: Completion)\n  if (? %11: Abrupt) return %11\n  else %11 = %11.Value\n  call %12 = clo<\"IsSharedArrayBuffer\">(new)\n  if (= %12 true) {\n    call %13 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %14 = clo<\"ThrowCompletion\">(%13)\n    return %14\n  }\n  call %15 = clo<\"IsDetachedBuffer\">(new)\n  if (= %15 true) {\n    call %16 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %17 = clo<\"ThrowCompletion\">(%16)\n    return %17\n  }\n  call %18 = clo<\"SameValue\">(new, O)\n  if (= %18 true) {\n    call %19 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %20 = clo<\"ThrowCompletion\">(%19)\n    return %20\n  }\n  if (< new.ArrayBufferByteLength newLen) {\n    call %21 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %22 = clo<\"ThrowCompletion\">(%21)\n    return %22\n  }\n  nop\n  call %23 = clo<\"IsDetachedBuffer\">(O)\n  if (= %23 true) {\n    call %24 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %25 = clo<\"ThrowCompletion\">(%24)\n    return %25\n  }\n  let fromBuf = O.ArrayBufferData\n  let toBuf = new.ArrayBufferData\n  let currentLen = O.ArrayBufferByteLength\n  if (< first currentLen) {\n    let count = (min newLen (- currentLen first))\n    call %26 = clo<\"CopyDataBlockBytes\">(toBuf, 0, fromBuf, first, count)\n  }\n  if (? new: Completion) return new\n  call %27 = clo<\"NormalCompletion\">(new)\n  return %27\n}","def <BUILTIN>:INTRINSICS.ArrayBuffer.prototype.transfer(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1263]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop newLength < ArgumentsList\n    expand __args__.newLength\n  } else let newLength = undefined\n  let O = this\n  call %0 = clo<\"ArrayBufferCopyAndDetach\">(O, newLength, ~preserve-resizability~)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.ArrayBuffer.prototype.transferToFixedLength(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1264]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop newLength < ArgumentsList\n    expand __args__.newLength\n  } else let newLength = undefined\n  let O = this\n  call %0 = clo<\"ArrayBufferCopyAndDetach\">(O, newLength, ~fixed-length~)\n  assert (? %0: Completion)\n  return %0\n}","def AllocateSharedArrayBuffer(\n  constructor: Record[Constructor],\n  byteLength: NonNegInt,\n  maxByteLength?: Enum[~empty~] | NonNegInt,\n): Normal[Record[SharedArrayBuffer]] | Throw = {\n  let slots = (list [\"ArrayBufferData\"])[#1265]\n  if (&& (exists maxByteLength) (! (= maxByteLength ~empty~))) {\n    let allocatingGrowableBuffer = true\n  } else {\n    let allocatingGrowableBuffer = false\n  }\n  if (= allocatingGrowableBuffer true) {\n    if (< maxByteLength byteLength) {\n      call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n      call %1 = clo<\"ThrowCompletion\">(%0)\n      return %1\n    }\n    (yet \"Append [[ArrayBufferByteLengthData]] and [[ArrayBufferMaxByteLength]] to _slots_.\")\n  } else {\n    push slots < \"ArrayBufferByteLength\"\n  }\n  call %2 = clo<\"OrdinaryCreateFromConstructor\">(constructor, \"%SharedArrayBuffer.prototype%\", slots)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let obj = %2\n  if (= allocatingGrowableBuffer true) {\n    let allocLength = maxByteLength\n  } else {\n    let allocLength = byteLength\n  }\n  call %3 = clo<\"CreateSharedByteDataBlock\">(allocLength)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let block = %3\n  obj.ArrayBufferData = block\n  if (= allocatingGrowableBuffer true) {\n    assert (! (< maxByteLength byteLength))\n    call %4 = clo<\"CreateSharedByteDataBlock\">(8)\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    let byteLengthBlock = %4\n    call %5 = clo<\"SetValueInBuffer\">(byteLengthBlock, 0, ~biguint64~, ([bigInt] byteLength), true, ~seq-cst~)\n    obj.ArrayBufferByteLengthData = byteLengthBlock\n    obj.ArrayBufferMaxByteLength = maxByteLength\n  } else {\n    obj.ArrayBufferByteLength = byteLength\n  }\n  if (? obj: Completion) return obj\n  call %6 = clo<\"NormalCompletion\">(obj)\n  return %6\n}","def IsSharedArrayBuffer(\n  obj: Record[ArrayBuffer | SharedArrayBuffer],\n): Boolean = {\n  let bufferData = obj.ArrayBufferData\n  if (= bufferData null) {\n    return false\n  }\n  if (? bufferData: Record[DataBlock]) {\n    return false\n  }\n  assert (? bufferData: Record[SharedDataBlock])\n  return true\n}","def <BUILTIN>:INTRINSICS.SharedArrayBuffer(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1266]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop length < ArgumentsList\n    expand __args__.length\n  } else let length = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop options < ArgumentsList\n    expand __args__.options\n  } else let options = undefined\n  if (= NewTarget undefined) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"ToIndex\">(length)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let byteLength = %2\n  call %3 = clo<\"GetArrayBufferMaxByteLengthOption\">(options)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let requestedMaxByteLength = %3\n  call %4 = clo<\"AllocateSharedArrayBuffer\">(NewTarget, byteLength, requestedMaxByteLength)\n  assert (? %4: Completion)\n  return %4\n}","def <BUILTIN>:INTRINSICS.get SharedArrayBuffer[@@species](\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1267]\n  if (? this: Completion) return this\n  call %0 = clo<\"NormalCompletion\">(this)\n  return %0\n}","def <BUILTIN>:INTRINSICS.get SharedArrayBuffer.prototype.byteLength(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1268]\n  let O = this\n  call %0 = clo<\"RequireInternalSlot\">(O, \"ArrayBufferData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"IsSharedArrayBuffer\">(O)\n  if (= %1 false) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  call %4 = clo<\"ArrayBufferByteLength\">(O, ~seq-cst~)\n  let length = %4\n  %5 = ([number] length)\n  if (? %5: Completion) return %5\n  call %6 = clo<\"NormalCompletion\">(%5)\n  return %6\n}","def <BUILTIN>:INTRINSICS.SharedArrayBuffer.prototype.grow(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1269]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop newLength < ArgumentsList\n    expand __args__.newLength\n  } else let newLength = undefined\n  let O = this\n  call %0 = clo<\"RequireInternalSlot\">(O, \"ArrayBufferMaxByteLength\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"IsSharedArrayBuffer\">(O)\n  if (= %1 false) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  call %4 = clo<\"ToIndex\">(newLength)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let newByteLength = %4\n  call %5 = clo<\"HostGrowSharedArrayBuffer\">(O, newByteLength)\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  let hostHandled = %5\n  if (= hostHandled ~handled~) {\n    call %6 = clo<\"NormalCompletion\">(undefined)\n    return %6\n  }\n  (yet \"Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\")\n  let byteLengthBlock = O.ArrayBufferByteLengthData\n  call %7 = clo<\"GetRawBytesFromSharedBlock\">(byteLengthBlock, 0, ~biguint64~, true, ~seq-cst~)\n  let currentByteLengthRawBytes = %7\n  call %8 = clo<\"NumericToRawBytes\">(~biguint64~, ([bigInt] newByteLength), isLittleEndian)\n  let newByteLengthRawBytes = %8\n  while true {\n    nop\n    call %9 = clo<\"RawBytesToNumeric\">(~biguint64~, currentByteLengthRawBytes, isLittleEndian)\n    let currentByteLength = ([math] %9)\n    if (== newByteLength currentByteLength) {\n      call %10 = clo<\"NormalCompletion\">(undefined)\n      return %10\n    }\n    if (|| (< newByteLength currentByteLength) (< O.ArrayBufferMaxByteLength newByteLength)) {\n      call %11 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n      call %12 = clo<\"ThrowCompletion\">(%11)\n      return %12\n    }\n    let byteLengthDelta = (- newByteLength currentByteLength)\n    (yet \"If it is impossible to create a new Shared Data Block value consisting of _byteLengthDelta_ bytes, throw a *RangeError* exception.\")\n    nop\n    call %13 = clo<\"AtomicCompareExchangeInSharedBlock\">(byteLengthBlock, 0, 8, currentByteLengthRawBytes, newByteLengthRawBytes)\n    let readByteLengthRawBytes = %13\n    call %14 = clo<\"ByteListEqual\">(readByteLengthRawBytes, currentByteLengthRawBytes)\n    if (= %14 true) {\n      call %15 = clo<\"NormalCompletion\">(undefined)\n      return %15\n    }\n    currentByteLengthRawBytes = readByteLengthRawBytes\n  }\n}","def <BUILTIN>:INTRINSICS.get SharedArrayBuffer.prototype.growable(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1270]\n  let O = this\n  call %0 = clo<\"RequireInternalSlot\">(O, \"ArrayBufferData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"IsSharedArrayBuffer\">(O)\n  if (= %1 false) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  call %4 = clo<\"IsFixedLengthArrayBuffer\">(O)\n  if (= %4 false) {\n    call %5 = clo<\"NormalCompletion\">(true)\n    return %5\n  } else {\n    call %6 = clo<\"NormalCompletion\">(false)\n    return %6\n  }\n}","def <BUILTIN>:INTRINSICS.get SharedArrayBuffer.prototype.maxByteLength(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1271]\n  let O = this\n  call %0 = clo<\"RequireInternalSlot\">(O, \"ArrayBufferData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"IsSharedArrayBuffer\">(O)\n  if (= %1 false) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  call %4 = clo<\"IsFixedLengthArrayBuffer\">(O)\n  if (= %4 true) {\n    let length = O.ArrayBufferByteLength\n  } else {\n    let length = O.ArrayBufferMaxByteLength\n  }\n  %5 = ([number] length)\n  if (? %5: Completion) return %5\n  call %6 = clo<\"NormalCompletion\">(%5)\n  return %6\n}","def <BUILTIN>:INTRINSICS.SharedArrayBuffer.prototype.slice(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1272]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop start < ArgumentsList\n    expand __args__.start\n  } else let start = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop end < ArgumentsList\n    expand __args__.end\n  } else let end = undefined\n  let O = this\n  call %0 = clo<\"RequireInternalSlot\">(O, \"ArrayBufferData\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"IsSharedArrayBuffer\">(O)\n  if (= %1 false) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  call %4 = clo<\"ArrayBufferByteLength\">(O, ~seq-cst~)\n  let len = %4\n  call %5 = clo<\"ToIntegerOrInfinity\">(start)\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  let relativeStart = %5\n  if (== relativeStart -INF) {\n    let first = 0\n  } else {\n    if (< relativeStart 0) {\n      let first = (max (+ len relativeStart) 0)\n    } else {\n      let first = (min relativeStart len)\n    }\n  }\n  if (= end undefined) {\n    let relativeEnd = len\n  } else {\n    call %6 = clo<\"ToIntegerOrInfinity\">(end)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    let relativeEnd = %6\n  }\n  if (== relativeEnd -INF) {\n    let final = 0\n  } else {\n    if (< relativeEnd 0) {\n      let final = (max (+ len relativeEnd) 0)\n    } else {\n      let final = (min relativeEnd len)\n    }\n  }\n  let newLen = (max (- final first) 0)\n  call %7 = clo<\"SpeciesConstructor\">(O, @EXECUTION_STACK[0].Realm.Intrinsics[\"%SharedArrayBuffer%\"])\n  assert (? %7: Completion)\n  if (? %7: Abrupt) return %7\n  else %7 = %7.Value\n  let ctor = %7\n  call %8 = clo<\"Construct\">(ctor, (list [([number] newLen)])[#1273])\n  assert (? %8: Completion)\n  if (? %8: Abrupt) return %8\n  else %8 = %8.Value\n  let new = %8\n  call %9 = clo<\"RequireInternalSlot\">(new, \"ArrayBufferData\")\n  assert (? %9: Completion)\n  if (? %9: Abrupt) return %9\n  else %9 = %9.Value\n  call %10 = clo<\"IsSharedArrayBuffer\">(new)\n  if (= %10 false) {\n    call %11 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %12 = clo<\"ThrowCompletion\">(%11)\n    return %12\n  }\n  if (= new.ArrayBufferData O.ArrayBufferData) {\n    call %13 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %14 = clo<\"ThrowCompletion\">(%13)\n    return %14\n  }\n  call %15 = clo<\"ArrayBufferByteLength\">(new, ~seq-cst~)\n  if (< %15 newLen) {\n    call %16 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %17 = clo<\"ThrowCompletion\">(%16)\n    return %17\n  }\n  let fromBuf = O.ArrayBufferData\n  let toBuf = new.ArrayBufferData\n  call %18 = clo<\"CopyDataBlockBytes\">(toBuf, 0, fromBuf, first, newLen)\n  if (? new: Completion) return new\n  call %19 = clo<\"NormalCompletion\">(new)\n  return %19\n}","def MakeDataViewWithBufferWitnessRecord(\n  obj: Record[DataView],\n  order: Enum[~seq-cst~, ~unordered~],\n): Record[DataViewWithBufferWitnessRecord] = {\n  let buffer = obj.ViewedArrayBuffer\n  call %0 = clo<\"IsDetachedBuffer\">(buffer)\n  if (= %0 true) {\n    let byteLength = ~detached~\n  } else {\n    call %1 = clo<\"ArrayBufferByteLength\">(buffer, order)\n    let byteLength = %1\n  }\n  return (record [DataViewWithBufferWitnessRecord] {\n    \"Object\" : obj,\n    \"CachedBufferByteLength\" : byteLength,\n  })[#1274]\n}","def GetViewByteLength(\n  viewRecord: Record[DataViewWithBufferWitnessRecord],\n): NonNegInt = {\n  call %0 = clo<\"IsViewOutOfBounds\">(viewRecord)\n  assert (= %0 false)\n  let view = viewRecord.Object\n  if (! (= view.ByteLength ~auto~)) {\n    return view.ByteLength\n  }\n  call %1 = clo<\"IsFixedLengthArrayBuffer\">(view.ViewedArrayBuffer)\n  assert (= %1 false)\n  let byteOffset = view.ByteOffset\n  let byteLength = viewRecord.CachedBufferByteLength\n  assert (! (= byteLength ~detached~))\n  return (- byteLength byteOffset)\n}","def IsViewOutOfBounds(\n  viewRecord: Record[DataViewWithBufferWitnessRecord],\n): Boolean = {\n  let view = viewRecord.Object\n  let bufferByteLength = viewRecord.CachedBufferByteLength\n  assert (yet \"IsDetachedBuffer(_view_.[[ViewedArrayBuffer]]) is *true* if and only if _bufferByteLength_ is ~detached~.\")\n  if (= bufferByteLength ~detached~) {\n    return true\n  }\n  let byteOffsetStart = view.ByteOffset\n  if (= view.ByteLength ~auto~) {\n    let byteOffsetEnd = bufferByteLength\n  } else {\n    let byteOffsetEnd = (+ byteOffsetStart view.ByteLength)\n  }\n  if (|| (< bufferByteLength byteOffsetStart) (< bufferByteLength byteOffsetEnd)) {\n    return true\n  }\n  nop\n  return false\n}","def GetViewValue(\n  view: ESValue,\n  requestIndex: ESValue,\n  isLittleEndian: ESValue,\n  type: Unknown[\"TypedArrayElementType\"],\n): Normal[Number | BigInt] | Throw = {\n  call %0 = clo<\"RequireInternalSlot\">(view, \"DataView\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  assert (exists view.ViewedArrayBuffer)\n  call %1 = clo<\"ToIndex\">(requestIndex)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let getIndex = %1\n  call %2 = clo<\"ToBoolean\">(isLittleEndian)\n  isLittleEndian = %2\n  let viewOffset = view.ByteOffset\n  call %3 = clo<\"MakeDataViewWithBufferWitnessRecord\">(view, ~unordered~)\n  let viewRecord = %3\n  nop\n  call %4 = clo<\"IsViewOutOfBounds\">(viewRecord)\n  if (= %4 true) {\n    call %5 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %6 = clo<\"ThrowCompletion\">(%5)\n    return %6\n  }\n  call %7 = clo<\"GetViewByteLength\">(viewRecord)\n  let viewSize = %7\n  (yet \"Let _elementSize_ be the Element Size value specified in <emu-xref href=\\\"#table-the-typedarray-constructors\\\"></emu-xref> for Element Type _type_.\")\n  if (< viewSize (+ getIndex elementSize)) {\n    call %8 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %9 = clo<\"ThrowCompletion\">(%8)\n    return %9\n  }\n  let bufferIndex = (+ getIndex viewOffset)\n  call %10 = clo<\"GetValueFromBuffer\">(view.ViewedArrayBuffer, bufferIndex, type, false, ~unordered~, isLittleEndian)\n  if (? %10: Completion) return %10\n  call %11 = clo<\"NormalCompletion\">(%10)\n  return %11\n}","def SetViewValue(\n  view: ESValue,\n  requestIndex: ESValue,\n  isLittleEndian: ESValue,\n  type: Unknown[\"TypedArrayElementType\"],\n  value: ESValue,\n): Normal[Undefined] | Throw = {\n  call %0 = clo<\"RequireInternalSlot\">(view, \"DataView\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  assert (exists view.ViewedArrayBuffer)\n  call %1 = clo<\"ToIndex\">(requestIndex)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let getIndex = %1\n  call %2 = clo<\"IsBigIntElementType\">(type)\n  if (= %2 true) {\n    call %3 = clo<\"ToBigInt\">(value)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let numberValue = %3\n  } else {\n    call %4 = clo<\"ToNumber\">(value)\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    let numberValue = %4\n  }\n  call %5 = clo<\"ToBoolean\">(isLittleEndian)\n  isLittleEndian = %5\n  let viewOffset = view.ByteOffset\n  call %6 = clo<\"MakeDataViewWithBufferWitnessRecord\">(view, ~unordered~)\n  let viewRecord = %6\n  nop\n  call %7 = clo<\"IsViewOutOfBounds\">(viewRecord)\n  if (= %7 true) {\n    call %8 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %9 = clo<\"ThrowCompletion\">(%8)\n    return %9\n  }\n  call %10 = clo<\"GetViewByteLength\">(viewRecord)\n  let viewSize = %10\n  (yet \"Let _elementSize_ be the Element Size value specified in <emu-xref href=\\\"#table-the-typedarray-constructors\\\"></emu-xref> for Element Type _type_.\")\n  if (< viewSize (+ getIndex elementSize)) {\n    call %11 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %12 = clo<\"ThrowCompletion\">(%11)\n    return %12\n  }\n  let bufferIndex = (+ getIndex viewOffset)\n  call %13 = clo<\"SetValueInBuffer\">(view.ViewedArrayBuffer, bufferIndex, type, numberValue, false, ~unordered~, isLittleEndian)\n  call %14 = clo<\"NormalCompletion\">(undefined)\n  return %14\n}","def <BUILTIN>:INTRINSICS.DataView(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1275]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop buffer < ArgumentsList\n    expand __args__.buffer\n  } else let buffer = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop byteOffset < ArgumentsList\n    expand __args__.byteOffset\n  } else let byteOffset = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop byteLength < ArgumentsList\n    expand __args__.byteLength\n  } else let byteLength = undefined\n  if (= NewTarget undefined) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"RequireInternalSlot\">(buffer, \"ArrayBufferData\")\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  call %3 = clo<\"ToIndex\">(byteOffset)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let offset = %3\n  call %4 = clo<\"IsDetachedBuffer\">(buffer)\n  if (= %4 true) {\n    call %5 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %6 = clo<\"ThrowCompletion\">(%5)\n    return %6\n  }\n  call %7 = clo<\"ArrayBufferByteLength\">(buffer, ~seq-cst~)\n  let bufferByteLength = %7\n  if (< bufferByteLength offset) {\n    call %8 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %9 = clo<\"ThrowCompletion\">(%8)\n    return %9\n  }\n  call %10 = clo<\"IsFixedLengthArrayBuffer\">(buffer)\n  let bufferIsFixedLength = %10\n  if (= byteLength undefined) {\n    if (= bufferIsFixedLength true) {\n      let viewByteLength = (- bufferByteLength offset)\n    } else {\n      let viewByteLength = ~auto~\n    }\n  } else {\n    call %11 = clo<\"ToIndex\">(byteLength)\n    assert (? %11: Completion)\n    if (? %11: Abrupt) return %11\n    else %11 = %11.Value\n    let viewByteLength = %11\n    if (< bufferByteLength (+ offset viewByteLength)) {\n      call %12 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n      call %13 = clo<\"ThrowCompletion\">(%12)\n      return %13\n    }\n  }\n  call %14 = clo<\"OrdinaryCreateFromConstructor\">(NewTarget, \"%DataView.prototype%\", (list [\"DataView\", \"ViewedArrayBuffer\", \"ByteLength\", \"ByteOffset\"])[#1276])\n  assert (? %14: Completion)\n  if (? %14: Abrupt) return %14\n  else %14 = %14.Value\n  let O = %14\n  call %15 = clo<\"IsDetachedBuffer\">(buffer)\n  if (= %15 true) {\n    call %16 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %17 = clo<\"ThrowCompletion\">(%16)\n    return %17\n  }\n  call %18 = clo<\"ArrayBufferByteLength\">(buffer, ~seq-cst~)\n  bufferByteLength = %18\n  if (< bufferByteLength offset) {\n    call %19 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %20 = clo<\"ThrowCompletion\">(%19)\n    return %20\n  }\n  if (! (= byteLength undefined)) {\n    if (< bufferByteLength (+ offset viewByteLength)) {\n      call %21 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n      call %22 = clo<\"ThrowCompletion\">(%21)\n      return %22\n    }\n  }\n  O.ViewedArrayBuffer = buffer\n  O.ByteLength = viewByteLength\n  O.ByteOffset = offset\n  if (? O: Completion) return O\n  call %23 = clo<\"NormalCompletion\">(O)\n  return %23\n}","def <BUILTIN>:INTRINSICS.get DataView.prototype.buffer(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1277]\n  let O = this\n  call %0 = clo<\"RequireInternalSlot\">(O, \"DataView\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  assert (exists O.ViewedArrayBuffer)\n  let buffer = O.ViewedArrayBuffer\n  if (? buffer: Completion) return buffer\n  call %1 = clo<\"NormalCompletion\">(buffer)\n  return %1\n}","def <BUILTIN>:INTRINSICS.get DataView.prototype.byteLength(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1278]\n  let O = this\n  call %0 = clo<\"RequireInternalSlot\">(O, \"DataView\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  assert (exists O.ViewedArrayBuffer)\n  call %1 = clo<\"MakeDataViewWithBufferWitnessRecord\">(O, ~seq-cst~)\n  let viewRecord = %1\n  call %2 = clo<\"IsViewOutOfBounds\">(viewRecord)\n  if (= %2 true) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  call %5 = clo<\"GetViewByteLength\">(viewRecord)\n  let size = %5\n  %6 = ([number] size)\n  if (? %6: Completion) return %6\n  call %7 = clo<\"NormalCompletion\">(%6)\n  return %7\n}","def <BUILTIN>:INTRINSICS.get DataView.prototype.byteOffset(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1279]\n  let O = this\n  call %0 = clo<\"RequireInternalSlot\">(O, \"DataView\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  assert (exists O.ViewedArrayBuffer)\n  call %1 = clo<\"MakeDataViewWithBufferWitnessRecord\">(O, ~seq-cst~)\n  let viewRecord = %1\n  call %2 = clo<\"IsViewOutOfBounds\">(viewRecord)\n  if (= %2 true) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  let offset = O.ByteOffset\n  %5 = ([number] offset)\n  if (? %5: Completion) return %5\n  call %6 = clo<\"NormalCompletion\">(%5)\n  return %6\n}","def <BUILTIN>:INTRINSICS.DataView.prototype.getBigInt64(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1280]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop byteOffset < ArgumentsList\n    expand __args__.byteOffset\n  } else let byteOffset = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop littleEndian < ArgumentsList\n    expand __args__.littleEndian\n  } else let littleEndian = undefined\n  let v = this\n  call %0 = clo<\"GetViewValue\">(v, byteOffset, littleEndian, ~bigint64~)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.DataView.prototype.getBigUint64(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1281]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop byteOffset < ArgumentsList\n    expand __args__.byteOffset\n  } else let byteOffset = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop littleEndian < ArgumentsList\n    expand __args__.littleEndian\n  } else let littleEndian = undefined\n  let v = this\n  call %0 = clo<\"GetViewValue\">(v, byteOffset, littleEndian, ~biguint64~)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.DataView.prototype.getFloat32(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1282]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop byteOffset < ArgumentsList\n    expand __args__.byteOffset\n  } else let byteOffset = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop littleEndian < ArgumentsList\n    expand __args__.littleEndian\n  } else let littleEndian = undefined\n  let v = this\n  if (! (exists __args__.littleEndian)) {\n    littleEndian = false\n  }\n  call %0 = clo<\"GetViewValue\">(v, byteOffset, littleEndian, ~float32~)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.DataView.prototype.getFloat64(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1283]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop byteOffset < ArgumentsList\n    expand __args__.byteOffset\n  } else let byteOffset = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop littleEndian < ArgumentsList\n    expand __args__.littleEndian\n  } else let littleEndian = undefined\n  let v = this\n  if (! (exists __args__.littleEndian)) {\n    littleEndian = false\n  }\n  call %0 = clo<\"GetViewValue\">(v, byteOffset, littleEndian, ~float64~)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.DataView.prototype.getInt8(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1284]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop byteOffset < ArgumentsList\n    expand __args__.byteOffset\n  } else let byteOffset = undefined\n  let v = this\n  call %0 = clo<\"GetViewValue\">(v, byteOffset, true, ~int8~)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.DataView.prototype.getInt16(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1285]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop byteOffset < ArgumentsList\n    expand __args__.byteOffset\n  } else let byteOffset = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop littleEndian < ArgumentsList\n    expand __args__.littleEndian\n  } else let littleEndian = undefined\n  let v = this\n  if (! (exists __args__.littleEndian)) {\n    littleEndian = false\n  }\n  call %0 = clo<\"GetViewValue\">(v, byteOffset, littleEndian, ~int16~)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.DataView.prototype.getInt32(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1286]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop byteOffset < ArgumentsList\n    expand __args__.byteOffset\n  } else let byteOffset = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop littleEndian < ArgumentsList\n    expand __args__.littleEndian\n  } else let littleEndian = undefined\n  let v = this\n  if (! (exists __args__.littleEndian)) {\n    littleEndian = false\n  }\n  call %0 = clo<\"GetViewValue\">(v, byteOffset, littleEndian, ~int32~)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.DataView.prototype.getUint8(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1287]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop byteOffset < ArgumentsList\n    expand __args__.byteOffset\n  } else let byteOffset = undefined\n  let v = this\n  call %0 = clo<\"GetViewValue\">(v, byteOffset, true, ~uint8~)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.DataView.prototype.getUint16(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1288]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop byteOffset < ArgumentsList\n    expand __args__.byteOffset\n  } else let byteOffset = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop littleEndian < ArgumentsList\n    expand __args__.littleEndian\n  } else let littleEndian = undefined\n  let v = this\n  if (! (exists __args__.littleEndian)) {\n    littleEndian = false\n  }\n  call %0 = clo<\"GetViewValue\">(v, byteOffset, littleEndian, ~uint16~)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.DataView.prototype.getUint32(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1289]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop byteOffset < ArgumentsList\n    expand __args__.byteOffset\n  } else let byteOffset = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop littleEndian < ArgumentsList\n    expand __args__.littleEndian\n  } else let littleEndian = undefined\n  let v = this\n  if (! (exists __args__.littleEndian)) {\n    littleEndian = false\n  }\n  call %0 = clo<\"GetViewValue\">(v, byteOffset, littleEndian, ~uint32~)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.DataView.prototype.setBigInt64(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1290]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop byteOffset < ArgumentsList\n    expand __args__.byteOffset\n  } else let byteOffset = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop littleEndian < ArgumentsList\n    expand __args__.littleEndian\n  } else let littleEndian = undefined\n  let v = this\n  call %0 = clo<\"SetViewValue\">(v, byteOffset, littleEndian, ~bigint64~, value)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.DataView.prototype.setBigUint64(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1291]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop byteOffset < ArgumentsList\n    expand __args__.byteOffset\n  } else let byteOffset = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop littleEndian < ArgumentsList\n    expand __args__.littleEndian\n  } else let littleEndian = undefined\n  let v = this\n  call %0 = clo<\"SetViewValue\">(v, byteOffset, littleEndian, ~biguint64~, value)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.DataView.prototype.setFloat32(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1292]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop byteOffset < ArgumentsList\n    expand __args__.byteOffset\n  } else let byteOffset = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop littleEndian < ArgumentsList\n    expand __args__.littleEndian\n  } else let littleEndian = undefined\n  let v = this\n  if (! (exists __args__.littleEndian)) {\n    littleEndian = false\n  }\n  call %0 = clo<\"SetViewValue\">(v, byteOffset, littleEndian, ~float32~, value)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.DataView.prototype.setFloat64(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1293]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop byteOffset < ArgumentsList\n    expand __args__.byteOffset\n  } else let byteOffset = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop littleEndian < ArgumentsList\n    expand __args__.littleEndian\n  } else let littleEndian = undefined\n  let v = this\n  if (! (exists __args__.littleEndian)) {\n    littleEndian = false\n  }\n  call %0 = clo<\"SetViewValue\">(v, byteOffset, littleEndian, ~float64~, value)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.DataView.prototype.setInt8(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1294]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop byteOffset < ArgumentsList\n    expand __args__.byteOffset\n  } else let byteOffset = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  let v = this\n  call %0 = clo<\"SetViewValue\">(v, byteOffset, true, ~int8~, value)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.DataView.prototype.setInt16(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1295]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop byteOffset < ArgumentsList\n    expand __args__.byteOffset\n  } else let byteOffset = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop littleEndian < ArgumentsList\n    expand __args__.littleEndian\n  } else let littleEndian = undefined\n  let v = this\n  if (! (exists __args__.littleEndian)) {\n    littleEndian = false\n  }\n  call %0 = clo<\"SetViewValue\">(v, byteOffset, littleEndian, ~int16~, value)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.DataView.prototype.setInt32(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1296]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop byteOffset < ArgumentsList\n    expand __args__.byteOffset\n  } else let byteOffset = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop littleEndian < ArgumentsList\n    expand __args__.littleEndian\n  } else let littleEndian = undefined\n  let v = this\n  if (! (exists __args__.littleEndian)) {\n    littleEndian = false\n  }\n  call %0 = clo<\"SetViewValue\">(v, byteOffset, littleEndian, ~int32~, value)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.DataView.prototype.setUint8(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1297]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop byteOffset < ArgumentsList\n    expand __args__.byteOffset\n  } else let byteOffset = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  let v = this\n  call %0 = clo<\"SetViewValue\">(v, byteOffset, true, ~uint8~, value)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.DataView.prototype.setUint16(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1298]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop byteOffset < ArgumentsList\n    expand __args__.byteOffset\n  } else let byteOffset = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop littleEndian < ArgumentsList\n    expand __args__.littleEndian\n  } else let littleEndian = undefined\n  let v = this\n  if (! (exists __args__.littleEndian)) {\n    littleEndian = false\n  }\n  call %0 = clo<\"SetViewValue\">(v, byteOffset, littleEndian, ~uint16~, value)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.DataView.prototype.setUint32(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1299]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop byteOffset < ArgumentsList\n    expand __args__.byteOffset\n  } else let byteOffset = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop littleEndian < ArgumentsList\n    expand __args__.littleEndian\n  } else let littleEndian = undefined\n  let v = this\n  if (! (exists __args__.littleEndian)) {\n    littleEndian = false\n  }\n  call %0 = clo<\"SetViewValue\">(v, byteOffset, littleEndian, ~uint32~, value)\n  assert (? %0: Completion)\n  return %0\n}","def ValidateIntegerTypedArray(\n  typedArray: ESValue,\n  waitable: Boolean,\n): Normal[Record[TypedArrayWithBufferWitnessRecord]] | Throw = {\n  call %0 = clo<\"ValidateTypedArray\">(typedArray, ~unordered~)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let taRecord = %0\n  nop\n  if (= waitable true) {\n    if (! (|| (= typedArray.TypedArrayName \"Int32Array\") (= typedArray.TypedArrayName \"BigInt64Array\"))) {\n      call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %2 = clo<\"ThrowCompletion\">(%1)\n      return %2\n    }\n  } else {\n    call %3 = clo<\"TypedArrayElementType\">(typedArray)\n    let type = %3\n    call %5 = clo<\"IsUnclampedIntegerElementType\">(type)\n    %4 = (= %5 false)\n    if %4 {\n      call %6 = clo<\"IsBigIntElementType\">(type)\n      %4 = (= %6 false)\n    }\n    if %4 {\n      call %7 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %8 = clo<\"ThrowCompletion\">(%7)\n      return %8\n    }\n  }\n  if (? taRecord: Completion) return taRecord\n  call %9 = clo<\"NormalCompletion\">(taRecord)\n  return %9\n}","def ValidateAtomicAccess(\n  taRecord: Record[TypedArrayWithBufferWitnessRecord],\n  requestIndex: ESValue,\n): Normal[Int] | Throw = {\n  call %0 = clo<\"TypedArrayLength\">(taRecord)\n  let length = %0\n  call %1 = clo<\"ToIndex\">(requestIndex)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let accessIndex = %1\n  assert (! (< accessIndex 0))\n  if (! (< accessIndex length)) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  let typedArray = taRecord.Object\n  call %4 = clo<\"TypedArrayElementSize\">(typedArray)\n  let elementSize = %4\n  let offset = typedArray.ByteOffset\n  %5 = (+ (* accessIndex elementSize) offset)\n  if (? %5: Completion) return %5\n  call %6 = clo<\"NormalCompletion\">(%5)\n  return %6\n}","def ValidateAtomicAccessOnIntegerTypedArray(\n  typedArray: ESValue,\n  requestIndex: ESValue,\n  waitable?: Boolean,\n): Normal[Int] | Throw = {\n  if (! (exists waitable)) {\n    waitable = false\n  }\n  call %0 = clo<\"ValidateIntegerTypedArray\">(typedArray, waitable)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let taRecord = %0\n  call %1 = clo<\"ValidateAtomicAccess\">(taRecord, requestIndex)\n  assert (? %1: Completion)\n  return %1\n}","def RevalidateAtomicAccess(\n  typedArray: Record[TypedArray],\n  byteIndexInBuffer: Int,\n): Normal[Enum[~unused~]] | Throw = {\n  call %0 = clo<\"MakeTypedArrayWithBufferWitnessRecord\">(typedArray, ~unordered~)\n  let taRecord = %0\n  nop\n  call %1 = clo<\"IsTypedArrayOutOfBounds\">(taRecord)\n  if (= %1 true) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  assert (! (< byteIndexInBuffer typedArray.ByteOffset))\n  if (! (< byteIndexInBuffer taRecord.CachedBufferByteLength)) {\n    call %4 = clo<\"__NEW_ERROR_OBJ__\">(\"%RangeError.prototype%\")\n    call %5 = clo<\"ThrowCompletion\">(%4)\n    return %5\n  }\n  call %6 = clo<\"NormalCompletion\">(~unused~)\n  return %6\n}","def GetWaiterList(\n  block: Record[SharedDataBlock],\n  i: Unknown[\"NonnegativeIntegerThatIsEvenlyDivisibleBy4\"],\n): Record[WaiterListRecord] = {\n  assert (yet \"_i_ and _i_ + 3 are valid byte offsets within the memory of _block_.\")\n  (yet \"Return the WaiterList Record that is referenced by the pair (_block_, _i_).\")\n}","def EnterCriticalSection(\n  WL: Record[WaiterListRecord],\n): Enum[~unused~] = {\n  assert (yet \"The surrounding agent is not in the critical section for any WaiterList Record.\")\n  (yet \"Wait until no agent is in the critical section for _WL_, then enter the critical section for _WL_ (without allowing any other agent to enter).\")\n  if (! (= WL.MostRecentLeaveEvent ~empty~)) {\n    nop\n    (yet \"Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\")\n    (yet \"Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\")\n    (yet \"Let _enterEvent_ be a new Synchronize event.\")\n    push eventsRecord.EventList < enterEvent\n    (yet \"Append (_WL_.[[MostRecentLeaveEvent]], _enterEvent_) to _eventsRecord_.[[AgentSynchronizesWith]].\")\n  }\n  return ~unused~\n}","def LeaveCriticalSection(\n  WL: Record[WaiterListRecord],\n): Enum[~unused~] = {\n  assert (yet \"The surrounding agent is in the critical section for _WL_.\")\n  (yet \"Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\")\n  (yet \"Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\")\n  (yet \"Let _leaveEvent_ be a new Synchronize event.\")\n  push eventsRecord.EventList < leaveEvent\n  WL.MostRecentLeaveEvent = leaveEvent\n  (yet \"Leave the critical section for _WL_.\")\n  return ~unused~\n}","def AddWaiter(\n  WL: Record[WaiterListRecord],\n  waiterRecord: Record[WaiterRecord],\n): Enum[~unused~] = {\n  assert (yet \"The surrounding agent is in the critical section for _WL_.\")\n  assert (yet \"There is no Waiter Record in _WL_.[[Waiters]] whose [[PromiseCapability]] field is _waiterRecord_.[[PromiseCapability]] and whose [[AgentSignifier]] field is _waiterRecord_.[[AgentSignifier]].\")\n  push WL.Waiters < waiterRecord\n  return ~unused~\n}","def RemoveWaiter(\n  WL: Record[WaiterListRecord],\n  waiterRecord: Record[WaiterRecord],\n): Enum[~unused~] = {\n  assert (yet \"The surrounding agent is in the critical section for _WL_.\")\n  assert (contains WL.Waiters waiterRecord)\n  call %0 = clo<\"__REMOVE_ELEM__\">(waiterRecord, WL.Waiters)\n  return ~unused~\n}","def RemoveWaiters(\n  WL: Record[WaiterListRecord],\n  c: NonNegInt | +INF,\n): List[Record[WaiterRecord]] = {\n  assert (yet \"The surrounding agent is in the critical section for _WL_.\")\n  let len = (sizeof WL.Waiters)\n  let n = (min c len)\n  (yet \"Let _L_ be a List whose elements are the first _n_ elements of _WL_.[[Waiters]].\")\n  (yet \"Remove the first _n_ elements of _WL_.[[Waiters]].\")\n  return L\n}","def SuspendThisAgent(\n  WL: Record[WaiterListRecord],\n  waiterRecord: Record[WaiterRecord],\n): Enum[~unused~] = {\n  assert (yet \"The surrounding agent is in the critical section for _WL_.\")\n  assert (contains WL.Waiters waiterRecord)\n  call %0 = clo<\"AgentSignifier\">()\n  let thisAgent = %0\n  assert (= waiterRecord.AgentSignifier thisAgent)\n  assert (= waiterRecord.PromiseCapability ~blocking~)\n  call %1 = clo<\"AgentCanSuspend\">()\n  assert (= %1 true)\n  (yet \"Perform LeaveCriticalSection(_WL_) and suspend the surrounding agent until the time is _waiterRecord_.[[TimeoutTime]], performing the combined operation in such a way that a notification that arrives after the critical section is exited but before the suspension takes effect is not lost. The surrounding agent can only wake from suspension due to a timeout or due to another agent calling NotifyWaiter with arguments _WL_ and _thisAgent_ (i.e. via a call to `Atomics.notify`).\")\n  call %2 = clo<\"EnterCriticalSection\">(WL)\n  return ~unused~\n}","def NotifyWaiter(\n  WL: Record[WaiterListRecord],\n  waiterRecord: Record[WaiterRecord],\n): Enum[~unused~] = {\n  assert (yet \"The surrounding agent is in the critical section for _WL_.\")\n  if (= waiterRecord.PromiseCapability ~blocking~) {\n    (yet \"Wake the agent whose signifier is _waiterRecord_.[[AgentSignifier]] from suspension.\")\n    nop\n  } else {\n    call %0 = clo<\"AgentSignifier\">()\n    if (= %0 waiterRecord.AgentSignifier) {\n      let promiseCapability = waiterRecord.PromiseCapability\n      call %1 = clo<\"Call\">(promiseCapability.Resolve, undefined, (list [waiterRecord.Result])[#1300])\n      assert (? %1: Normal)\n      %1 = %1.Value\n    } else {\n      call %2 = clo<\"EnqueueResolveInAgentJob\">(waiterRecord.AgentSignifier, waiterRecord.PromiseCapability, waiterRecord.Result)\n    }\n  }\n  return ~unused~\n}","def <CLO>:EnqueueResolveInAgentJob:clo0(\n): Unknown = {\n  call %0 = clo<\"AgentSignifier\">()\n  assert (= %0 agentSignifier)\n  call %1 = clo<\"Call\">(promiseCapability.Resolve, undefined, (list [resolution])[#1301])\n  assert (? %1: Normal)\n  %1 = %1.Value\n  call %2 = clo<\"NormalCompletion\">(~unused~)\n  return %2\n}","def EnqueueResolveInAgentJob(\n  agentSignifier: Unknown[\"AgentSignifier\"],\n  promiseCapability: Record[PromiseCapabilityRecord],\n  resolution: ESValue,\n): Enum[~unused~] = {\n  let resolveJob = clo<\"EnqueueResolveInAgentJob:clo0\", [agentSignifier, promiseCapability, resolution]>\n  call %0 = clo<\"GetFunctionRealm\">(promiseCapability.Resolve)\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let realmInTargetAgent = %0\n  assert (= agentSignifier realmInTargetAgent.AgentSignifier)\n  call %1 = clo<\"HostEnqueueGenericJob\">(resolveJob, realmInTargetAgent)\n  return ~unused~\n}","def DoWait(\n  mode: Enum[~async~, ~sync~],\n  typedArray: ESValue,\n  index: ESValue,\n  value: ESValue,\n  timeout: ESValue,\n): Unknown[\"EitherANormalCompletionContainingEitherAnObject,*\\\"notequal\\\"*,*\\\"timedout\\\"*,Or*\\\"ok\\\"*,OrAThrowCompletion\"] = {\n  call %0 = clo<\"ValidateIntegerTypedArray\">(typedArray, true)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let taRecord = %0\n  let buffer = taRecord.Object.ViewedArrayBuffer\n  call %1 = clo<\"IsSharedArrayBuffer\">(buffer)\n  if (= %1 false) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  call %4 = clo<\"ValidateAtomicAccess\">(taRecord, index)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let i = %4\n  let arrayTypeName = typedArray.TypedArrayName\n  if (= arrayTypeName \"BigInt64Array\") {\n    call %5 = clo<\"ToBigInt64\">(value)\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n    let v = %5\n  } else {\n    call %6 = clo<\"ToInt32\">(value)\n    assert (? %6: Completion)\n    if (? %6: Abrupt) return %6\n    else %6 = %6.Value\n    let v = %6\n  }\n  call %7 = clo<\"ToNumber\">(timeout)\n  assert (? %7: Completion)\n  if (? %7: Abrupt) return %7\n  else %7 = %7.Value\n  let q = %7\n  if (|| (= q NaN) (= q +NUM_INF)) {\n    let t = +INF\n  } else {\n    if (= q -NUM_INF) {\n      let t = 0\n    } else {\n      let t = (max ([math] q) 0)\n    }\n  }\n  %8 = (= mode ~sync~)\n  if %8 {\n    call %9 = clo<\"AgentCanSuspend\">()\n    %8 = (= %9 false)\n  }\n  if %8 {\n    call %10 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %11 = clo<\"ThrowCompletion\">(%10)\n    return %11\n  }\n  let block = buffer.ArrayBufferData\n  let offset = typedArray.ByteOffset\n  let byteIndexInBuffer = (+ (* i 4) offset)\n  call %12 = clo<\"GetWaiterList\">(block, byteIndexInBuffer)\n  let WL = %12\n  if (= mode ~sync~) {\n    let promiseCapability = ~blocking~\n    let resultObject = undefined\n  } else {\n    call %13 = clo<\"NewPromiseCapability\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Promise%\"])\n    assert (? %13: Normal)\n    %13 = %13.Value\n    let promiseCapability = %13\n    call %14 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Object.prototype%\"])\n    let resultObject = %14\n  }\n  call %15 = clo<\"EnterCriticalSection\">(WL)\n  call %16 = clo<\"TypedArrayElementType\">(typedArray)\n  let elementType = %16\n  call %17 = clo<\"GetValueFromBuffer\">(buffer, byteIndexInBuffer, elementType, true, ~seq-cst~)\n  let w = %17\n  if (! (== v w)) {\n    call %18 = clo<\"LeaveCriticalSection\">(WL)\n    if (= mode ~sync~) {\n      call %19 = clo<\"NormalCompletion\">(\"not-equal\")\n      return %19\n    }\n    call %20 = clo<\"CreateDataPropertyOrThrow\">(resultObject, \"async\", false)\n    assert (? %20: Normal)\n    %20 = %20.Value\n    call %21 = clo<\"CreateDataPropertyOrThrow\">(resultObject, \"value\", \"not-equal\")\n    assert (? %21: Normal)\n    %21 = %21.Value\n    if (? resultObject: Completion) return resultObject\n    call %22 = clo<\"NormalCompletion\">(resultObject)\n    return %22\n  }\n  if (&& (= t 0) (= mode ~async~)) {\n    nop\n    call %23 = clo<\"LeaveCriticalSection\">(WL)\n    call %24 = clo<\"CreateDataPropertyOrThrow\">(resultObject, \"async\", false)\n    assert (? %24: Normal)\n    %24 = %24.Value\n    call %25 = clo<\"CreateDataPropertyOrThrow\">(resultObject, \"value\", \"timed-out\")\n    assert (? %25: Normal)\n    %25 = %25.Value\n    if (? resultObject: Completion) return resultObject\n    call %26 = clo<\"NormalCompletion\">(resultObject)\n    return %26\n  }\n  call %27 = clo<\"AgentSignifier\">()\n  let thisAgent = %27\n  (yet \"Let _now_ be the time value (UTC) identifying the current time.\")\n  (yet \"Let _additionalTimeout_ be an implementation-defined non-negative mathematical value.\")\n  let timeoutTime = (+ (+ ([math] now) t) additionalTimeout)\n  nop\n  (yet \"Let _waiterRecord_ be a new Waiter Record { [[AgentSignifier]]: _thisAgent_, [[PromiseCapability]]: _promiseCapability_, [[TimeoutTime]]: _timeoutTime_, [[Result]]: *\\\"ok\\\"* }.\")\n  call %28 = clo<\"AddWaiter\">(WL, waiterRecord)\n  if (= mode ~sync~) {\n    call %29 = clo<\"SuspendThisAgent\">(WL, waiterRecord)\n  } else {\n    if (! (|| (= timeoutTime NaN) (|| (= timeoutTime +NUM_INF) (= timeoutTime -NUM_INF)))) {\n      call %30 = clo<\"EnqueueAtomicsWaitAsyncTimeoutJob\">(WL, waiterRecord)\n    }\n  }\n  call %31 = clo<\"LeaveCriticalSection\">(WL)\n  if (= mode ~sync~) {\n    %32 = waiterRecord.Result\n    if (? %32: Completion) return %32\n    call %33 = clo<\"NormalCompletion\">(%32)\n    return %33\n  }\n  call %34 = clo<\"CreateDataPropertyOrThrow\">(resultObject, \"async\", true)\n  assert (? %34: Normal)\n  %34 = %34.Value\n  call %35 = clo<\"CreateDataPropertyOrThrow\">(resultObject, \"value\", promiseCapability.Promise)\n  assert (? %35: Normal)\n  %35 = %35.Value\n  if (? resultObject: Completion) return resultObject\n  call %36 = clo<\"NormalCompletion\">(resultObject)\n  return %36\n}","def <CLO>:EnqueueAtomicsWaitAsyncTimeoutJob:clo0(\n): Unknown = {\n  call %0 = clo<\"EnterCriticalSection\">(WL)\n  if (contains WL.Waiters waiterRecord) {\n    (yet \"Let _timeOfJobExecution_ be the time value (UTC) identifying the current time.\")\n    assert (yet \"‚Ñù(_timeOfJobExecution_) ‚â• _waiterRecord_.[[TimeoutTime]] (ignoring potential non-monotonicity of time values).\")\n    waiterRecord.Result = \"timed-out\"\n    call %1 = clo<\"RemoveWaiter\">(WL, waiterRecord)\n    call %2 = clo<\"NotifyWaiter\">(WL, waiterRecord)\n  }\n  call %3 = clo<\"LeaveCriticalSection\">(WL)\n  call %4 = clo<\"NormalCompletion\">(~unused~)\n  return %4\n}","def EnqueueAtomicsWaitAsyncTimeoutJob(\n  WL: Record[WaiterListRecord],\n  waiterRecord: Record[WaiterRecord],\n): Enum[~unused~] = {\n  let timeoutJob = clo<\"EnqueueAtomicsWaitAsyncTimeoutJob:clo0\", [WL, waiterRecord]>\n  (yet \"Let _now_ be the time value (UTC) identifying the current time.\")\n  let currentRealm = @EXECUTION_STACK[0].Realm\n  call %0 = clo<\"HostEnqueueTimeoutJob\">(timeoutJob, currentRealm, (- ([number] waiterRecord.TimeoutTime) now))\n  return ~unused~\n}","def AtomicCompareExchangeInSharedBlock(\n  block: Record[SharedDataBlock],\n  byteIndexInBuffer: Int,\n  elementSize: NonNegInt,\n  expectedBytes: Unknown[\"ListOfByteValue\"],\n  replacementBytes: Unknown[\"ListOfByteValue\"],\n): Unknown[\"ListOfByteValue\"] = {\n  (yet \"Let _execution_ be the [[CandidateExecution]] field of the surrounding agent's Agent Record.\")\n  (yet \"Let _eventsRecord_ be the Agent Events Record of _execution_.[[EventsRecords]] whose [[AgentSignifier]] is AgentSignifier().\")\n  (yet \"Let _rawBytesRead_ be a List of length _elementSize_ whose elements are nondeterministically chosen byte values.\")\n  nop\n  nop\n  call %0 = clo<\"ByteListEqual\">(rawBytesRead, expectedBytes)\n  if (= %0 true) {\n    (yet \"Let _second_ be a new read-modify-write modification function with parameters (_oldBytes_, _newBytes_) that captures nothing and performs the following steps atomically when called:\\n  1. Return _newBytes_.\")\n    let event = (record [ReadModifyWriteSharedMemory] {\n      \"Order\" : ~seq-cst~,\n      \"NoTear\" : true,\n      \"Block\" : block,\n      \"ByteIndex\" : byteIndexInBuffer,\n      \"ElementSize\" : elementSize,\n      \"Payload\" : replacementBytes,\n      \"ModifyOp\" : second,\n    })[#1302]\n  } else {\n    let event = (record [ReadSharedMemory] {\n      \"Order\" : ~seq-cst~,\n      \"NoTear\" : true,\n      \"Block\" : block,\n      \"ByteIndex\" : byteIndexInBuffer,\n      \"ElementSize\" : elementSize,\n    })[#1303]\n  }\n  push eventsRecord.EventList < event\n  push execution.ChosenValues < (record [ChosenValueRecord] {\n    \"Event\" : event,\n    \"ChosenValue\" : rawBytesRead,\n  })[#1304]\n  return rawBytesRead\n}","def AtomicReadModifyWrite(\n  typedArray: ESValue,\n  index: ESValue,\n  value: ESValue,\n  op: Unknown[\"ReadmodifywriteModificationFunction\"],\n): Normal[Number | BigInt] | Throw = {\n  call %0 = clo<\"ValidateAtomicAccessOnIntegerTypedArray\">(typedArray, index)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let byteIndexInBuffer = %0\n  if (= typedArray.ContentType ~bigint~) {\n    call %1 = clo<\"ToBigInt\">(value)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let v = %1\n  } else {\n    call %2 = clo<\"ToIntegerOrInfinity\">(value)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let v = ([number] %2)\n  }\n  call %3 = clo<\"RevalidateAtomicAccess\">(typedArray, byteIndexInBuffer)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let buffer = typedArray.ViewedArrayBuffer\n  call %4 = clo<\"TypedArrayElementType\">(typedArray)\n  let elementType = %4\n  call %5 = clo<\"GetModifySetValueInBuffer\">(buffer, byteIndexInBuffer, elementType, v, op)\n  if (? %5: Completion) return %5\n  call %6 = clo<\"NormalCompletion\">(%5)\n  return %6\n}","def ByteListBitwiseOp(\n  op: Unknown[\"`&`,`^`,Or``\"],\n  xBytes: Unknown[\"ListOfByteValue\"],\n  yBytes: Unknown[\"ListOfByteValue\"],\n): Unknown[\"ListOfByteValue\"] = {\n  assert (yet \"_xBytes_ and _yBytes_ have the same number of elements.\")\n  let result = (list [])[#1305]\n  let i = 0\n  %1 = xBytes\n  %0 = 0\n  while (< %0 (sizeof %1)) {\n    let xByte = %1[%0]\n    let yByte = yBytes[i]\n    if (= op \"&\") {\n      let resultByte = (& xByte yByte)\n    } else {\n      if (= op \"^\") {\n        let resultByte = (^ xByte yByte)\n      } else {\n        assert (= op \"|\")\n        let resultByte = (| xByte yByte)\n      }\n    }\n    i = (+ i 1)\n    push result < resultByte\n    %0 = (+ %0 1)\n  }\n  return result\n}","def ByteListEqual(\n  xBytes: Unknown[\"ListOfByteValue\"],\n  yBytes: Unknown[\"ListOfByteValue\"],\n): Boolean = {\n  (yet \"If _xBytes_ and _yBytes_ do not have the same number of elements, return *false*.\")\n  let i = 0\n  %1 = xBytes\n  %0 = 0\n  while (< %0 (sizeof %1)) {\n    let xByte = %1[%0]\n    let yByte = yBytes[i]\n    if (! (== xByte yByte)) {\n      return false\n    }\n    i = (+ i 1)\n    %0 = (+ %0 1)\n  }\n  return true\n}","def <BUILTIN>:INTRINSICS.Atomics.add(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1306]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop typedArray < ArgumentsList\n    expand __args__.typedArray\n  } else let typedArray = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop index < ArgumentsList\n    expand __args__.index\n  } else let index = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  call %0 = clo<\"TypedArrayElementType\">(typedArray)\n  let type = %0\n  (yet \"Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\")\n  (yet \"Let _add_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures _type_ and _isLittleEndian_ and performs the following steps atomically when called:\\n  1. Let _x_ be RawBytesToNumeric(_type_, _xBytes_, _isLittleEndian_).\\n  1. Let _y_ be RawBytesToNumeric(_type_, _yBytes_, _isLittleEndian_).\\n  1. If _x_ is a Number, then\\n    1. Let _sum_ be Number::add(_x_, _y_).\\n  1. Else,\\n    1. Assert: _x_ is a BigInt.\\n    1. Let _sum_ be BigInt::add(_x_, _y_).\\n  1. Let _sumBytes_ be NumericToRawBytes(_type_, _sum_, _isLittleEndian_).\\n  1. Assert: _sumBytes_, _xBytes_, and _yBytes_ have the same number of elements..\\n  1. Return _sumBytes_.\")\n  call %1 = clo<\"AtomicReadModifyWrite\">(typedArray, index, value, add)\n  assert (? %1: Completion)\n  return %1\n}","def <BUILTIN>:INTRINSICS.Atomics.and(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1307]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop typedArray < ArgumentsList\n    expand __args__.typedArray\n  } else let typedArray = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop index < ArgumentsList\n    expand __args__.index\n  } else let index = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  (yet \"Let _and_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures nothing and performs the following steps atomically when called:\\n  1. Return ByteListBitwiseOp(`&`, _xBytes_, _yBytes_).\")\n  call %0 = clo<\"AtomicReadModifyWrite\">(typedArray, index, value, and)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.Atomics.compareExchange(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1308]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop typedArray < ArgumentsList\n    expand __args__.typedArray\n  } else let typedArray = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop index < ArgumentsList\n    expand __args__.index\n  } else let index = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop expectedValue < ArgumentsList\n    expand __args__.expectedValue\n  } else let expectedValue = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop replacementValue < ArgumentsList\n    expand __args__.replacementValue\n  } else let replacementValue = undefined\n  call %0 = clo<\"ValidateAtomicAccessOnIntegerTypedArray\">(typedArray, index)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let byteIndexInBuffer = %0\n  let buffer = typedArray.ViewedArrayBuffer\n  let block = buffer.ArrayBufferData\n  if (= typedArray.ContentType ~bigint~) {\n    call %1 = clo<\"ToBigInt\">(expectedValue)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let expected = %1\n    call %2 = clo<\"ToBigInt\">(replacementValue)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let replacement = %2\n  } else {\n    call %3 = clo<\"ToIntegerOrInfinity\">(expectedValue)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let expected = ([number] %3)\n    call %4 = clo<\"ToIntegerOrInfinity\">(replacementValue)\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    let replacement = ([number] %4)\n  }\n  call %5 = clo<\"RevalidateAtomicAccess\">(typedArray, byteIndexInBuffer)\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  call %6 = clo<\"TypedArrayElementType\">(typedArray)\n  let elementType = %6\n  call %7 = clo<\"TypedArrayElementSize\">(typedArray)\n  let elementSize = %7\n  (yet \"Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\")\n  call %8 = clo<\"NumericToRawBytes\">(elementType, expected, isLittleEndian)\n  let expectedBytes = %8\n  call %9 = clo<\"NumericToRawBytes\">(elementType, replacement, isLittleEndian)\n  let replacementBytes = %9\n  call %10 = clo<\"IsSharedArrayBuffer\">(buffer)\n  if (= %10 true) {\n    call %11 = clo<\"AtomicCompareExchangeInSharedBlock\">(block, byteIndexInBuffer, elementSize, expectedBytes, replacementBytes)\n    let rawBytesRead = %11\n  } else {\n    (yet \"Let _rawBytesRead_ be a List of length _elementSize_ whose elements are the sequence of _elementSize_ bytes starting with _block_[_byteIndexInBuffer_].\")\n    call %12 = clo<\"ByteListEqual\">(rawBytesRead, expectedBytes)\n    if (= %12 true) {\n      (yet \"Store the individual bytes of _replacementBytes_ into _block_, starting at _block_[_byteIndexInBuffer_].\")\n    }\n  }\n  call %13 = clo<\"RawBytesToNumeric\">(elementType, rawBytesRead, isLittleEndian)\n  if (? %13: Completion) return %13\n  call %14 = clo<\"NormalCompletion\">(%13)\n  return %14\n}","def <BUILTIN>:INTRINSICS.Atomics.exchange(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1309]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop typedArray < ArgumentsList\n    expand __args__.typedArray\n  } else let typedArray = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop index < ArgumentsList\n    expand __args__.index\n  } else let index = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  (yet \"Let _second_ be a new read-modify-write modification function with parameters (_oldBytes_, _newBytes_) that captures nothing and performs the following steps atomically when called:\\n  1. Return _newBytes_.\")\n  call %0 = clo<\"AtomicReadModifyWrite\">(typedArray, index, value, second)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.Atomics.isLockFree(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1310]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop size < ArgumentsList\n    expand __args__.size\n  } else let size = undefined\n  call %0 = clo<\"ToIntegerOrInfinity\">(size)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let n = %0\n  let AR = @AGENT_RECORD\n  if (== n 1) {\n    %1 = AR.IsLockFree1\n    if (? %1: Completion) return %1\n    call %2 = clo<\"NormalCompletion\">(%1)\n    return %2\n  }\n  if (== n 2) {\n    %3 = AR.IsLockFree2\n    if (? %3: Completion) return %3\n    call %4 = clo<\"NormalCompletion\">(%3)\n    return %4\n  }\n  if (== n 4) {\n    call %5 = clo<\"NormalCompletion\">(true)\n    return %5\n  }\n  if (== n 8) {\n    %6 = AR.IsLockFree8\n    if (? %6: Completion) return %6\n    call %7 = clo<\"NormalCompletion\">(%6)\n    return %7\n  }\n  call %8 = clo<\"NormalCompletion\">(false)\n  return %8\n}","def <BUILTIN>:INTRINSICS.Atomics.load(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1311]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop typedArray < ArgumentsList\n    expand __args__.typedArray\n  } else let typedArray = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop index < ArgumentsList\n    expand __args__.index\n  } else let index = undefined\n  call %0 = clo<\"ValidateAtomicAccessOnIntegerTypedArray\">(typedArray, index)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let byteIndexInBuffer = %0\n  call %1 = clo<\"RevalidateAtomicAccess\">(typedArray, byteIndexInBuffer)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let buffer = typedArray.ViewedArrayBuffer\n  call %2 = clo<\"TypedArrayElementType\">(typedArray)\n  let elementType = %2\n  call %3 = clo<\"GetValueFromBuffer\">(buffer, byteIndexInBuffer, elementType, true, ~seq-cst~)\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Atomics.or(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1312]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop typedArray < ArgumentsList\n    expand __args__.typedArray\n  } else let typedArray = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop index < ArgumentsList\n    expand __args__.index\n  } else let index = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  (yet \"Let _or_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures nothing and performs the following steps atomically when called:\\n  1. Return ByteListBitwiseOp(`|`, _xBytes_, _yBytes_).\")\n  call %0 = clo<\"AtomicReadModifyWrite\">(typedArray, index, value, or)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.Atomics.store(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1313]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop typedArray < ArgumentsList\n    expand __args__.typedArray\n  } else let typedArray = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop index < ArgumentsList\n    expand __args__.index\n  } else let index = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  call %0 = clo<\"ValidateAtomicAccessOnIntegerTypedArray\">(typedArray, index)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let byteIndexInBuffer = %0\n  if (= typedArray.ContentType ~bigint~) {\n    call %1 = clo<\"ToBigInt\">(value)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let v = %1\n  } else {\n    call %2 = clo<\"ToIntegerOrInfinity\">(value)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let v = ([number] %2)\n  }\n  call %3 = clo<\"RevalidateAtomicAccess\">(typedArray, byteIndexInBuffer)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let buffer = typedArray.ViewedArrayBuffer\n  call %4 = clo<\"TypedArrayElementType\">(typedArray)\n  let elementType = %4\n  call %5 = clo<\"SetValueInBuffer\">(buffer, byteIndexInBuffer, elementType, v, true, ~seq-cst~)\n  if (? v: Completion) return v\n  call %6 = clo<\"NormalCompletion\">(v)\n  return %6\n}","def <BUILTIN>:INTRINSICS.Atomics.sub(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1314]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop typedArray < ArgumentsList\n    expand __args__.typedArray\n  } else let typedArray = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop index < ArgumentsList\n    expand __args__.index\n  } else let index = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  call %0 = clo<\"TypedArrayElementType\">(typedArray)\n  let type = %0\n  (yet \"Let _isLittleEndian_ be the value of the [[LittleEndian]] field of the surrounding agent's Agent Record.\")\n  (yet \"Let _subtract_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures _type_ and _isLittleEndian_ and performs the following steps atomically when called:\\n  1. Let _x_ be RawBytesToNumeric(_type_, _xBytes_, _isLittleEndian_).\\n  1. Let _y_ be RawBytesToNumeric(_type_, _yBytes_, _isLittleEndian_).\\n  1. If _x_ is a Number, then\\n    1. Let _difference_ be Number::subtract(_x_, _y_).\\n  1. Else,\\n    1. Assert: _x_ is a BigInt.\\n    1. Let _difference_ be BigInt::subtract(_x_, _y_).\\n  1. Let _differenceBytes_ be NumericToRawBytes(_type_, _difference_, _isLittleEndian_).\\n  1. Assert: _differenceBytes_, _xBytes_, and _yBytes_ have the same number of elements..\\n  1. Return _differenceBytes_.\")\n  call %1 = clo<\"AtomicReadModifyWrite\">(typedArray, index, value, subtract)\n  assert (? %1: Completion)\n  return %1\n}","def <BUILTIN>:INTRINSICS.Atomics.wait(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1315]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop typedArray < ArgumentsList\n    expand __args__.typedArray\n  } else let typedArray = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop index < ArgumentsList\n    expand __args__.index\n  } else let index = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop timeout < ArgumentsList\n    expand __args__.timeout\n  } else let timeout = undefined\n  call %0 = clo<\"DoWait\">(~sync~, typedArray, index, value, timeout)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.Atomics.waitAsync(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1316]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop typedArray < ArgumentsList\n    expand __args__.typedArray\n  } else let typedArray = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop index < ArgumentsList\n    expand __args__.index\n  } else let index = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop timeout < ArgumentsList\n    expand __args__.timeout\n  } else let timeout = undefined\n  call %0 = clo<\"DoWait\">(~async~, typedArray, index, value, timeout)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.Atomics.notify(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1317]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop typedArray < ArgumentsList\n    expand __args__.typedArray\n  } else let typedArray = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop index < ArgumentsList\n    expand __args__.index\n  } else let index = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop count < ArgumentsList\n    expand __args__.count\n  } else let count = undefined\n  call %0 = clo<\"ValidateAtomicAccessOnIntegerTypedArray\">(typedArray, index, true)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let byteIndexInBuffer = %0\n  if (= count undefined) {\n    let c = +INF\n  } else {\n    call %1 = clo<\"ToIntegerOrInfinity\">(count)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let intCount = %1\n    let c = (max intCount 0)\n  }\n  let buffer = typedArray.ViewedArrayBuffer\n  let block = buffer.ArrayBufferData\n  call %2 = clo<\"IsSharedArrayBuffer\">(buffer)\n  if (= %2 false) {\n    call %3 = clo<\"NormalCompletion\">(0.0f)\n    return %3\n  }\n  call %4 = clo<\"GetWaiterList\">(block, byteIndexInBuffer)\n  let WL = %4\n  call %5 = clo<\"EnterCriticalSection\">(WL)\n  call %6 = clo<\"RemoveWaiters\">(WL, c)\n  let S = %6\n  %8 = S\n  %7 = 0\n  while (< %7 (sizeof %8)) {\n    let W = %8[%7]\n    call %9 = clo<\"NotifyWaiter\">(WL, W)\n    %7 = (+ %7 1)\n  }\n  call %10 = clo<\"LeaveCriticalSection\">(WL)\n  let n = (sizeof S)\n  %11 = ([number] n)\n  if (? %11: Completion) return %11\n  call %12 = clo<\"NormalCompletion\">(%11)\n  return %12\n}","def <BUILTIN>:INTRINSICS.Atomics.xor(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1318]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop typedArray < ArgumentsList\n    expand __args__.typedArray\n  } else let typedArray = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop index < ArgumentsList\n    expand __args__.index\n  } else let index = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  (yet \"Let _xor_ be a new read-modify-write modification function with parameters (_xBytes_, _yBytes_) that captures nothing and performs the following steps atomically when called:\\n  1. Return ByteListBitwiseOp(`^`, _xBytes_, _yBytes_).\")\n  call %0 = clo<\"AtomicReadModifyWrite\">(typedArray, index, value, xor)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.JSON.parse(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1319]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop text < ArgumentsList\n    expand __args__.text\n  } else let text = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop reviver < ArgumentsList\n    expand __args__.reviver\n  } else let reviver = undefined\n  call %0 = clo<\"ToString\">(text)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let jsonString = %0\n  (yet \"Parse StringToCodePoints(_jsonString_) as a JSON text as specified in ECMA-404. Throw a *SyntaxError* exception if it is not a valid JSON text as defined in that specification.\")\n  let scriptString = (concat \"(\" jsonString \");\")\n  call %1 = clo<\"StringToCodePoints\">(scriptString)\n  let script = (parse %1 (grammar-symbol |Script|))\n  nop\n  assert (? script: Ast)\n  sdo-call %2 = script->Evaluation()\n  call %3 = clo<\"Completion\">(%2)\n  let completion = %3\n  nop\n  let unfiltered = completion.Value\n  assert (yet \"_unfiltered_ is either a String, a Number, a Boolean, an Object that is defined by either an |ArrayLiteral| or an |ObjectLiteral|, or *null*.\")\n  call %4 = clo<\"IsCallable\">(reviver)\n  if (= %4 true) {\n    call %5 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Object.prototype%\"])\n    let root = %5\n    let rootName = \"\"\n    call %6 = clo<\"CreateDataPropertyOrThrow\">(root, rootName, unfiltered)\n    assert (? %6: Normal)\n    %6 = %6.Value\n    call %7 = clo<\"InternalizeJSONProperty\">(root, rootName, reviver)\n    assert (? %7: Completion)\n    return %7\n  } else {\n    if (? unfiltered: Completion) return unfiltered\n    call %8 = clo<\"NormalCompletion\">(unfiltered)\n    return %8\n  }\n}","def InternalizeJSONProperty(\n  holder: Record[Object],\n  name: String,\n  reviver: Record[FunctionObject],\n): Normal[ESValue] | Throw = {\n  call %0 = clo<\"Get\">(holder, name)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let val = %0\n  if (? val: Record[Object]) {\n    call %1 = clo<\"IsArray\">(val)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let isArray = %1\n    if (= isArray true) {\n      call %2 = clo<\"LengthOfArrayLike\">(val)\n      assert (? %2: Completion)\n      if (? %2: Abrupt) return %2\n      else %2 = %2.Value\n      let len = %2\n      let I = 0\n      while (< I len) {\n        call %3 = clo<\"ToString\">(([number] I))\n        assert (? %3: Normal)\n        %3 = %3.Value\n        let prop = %3\n        call %4 = clo<\"InternalizeJSONProperty\">(val, prop, reviver)\n        assert (? %4: Completion)\n        if (? %4: Abrupt) return %4\n        else %4 = %4.Value\n        let newElement = %4\n        if (= newElement undefined) {\n          call %5 = val.Delete(val, prop)\n          assert (? %5: Completion)\n          if (? %5: Abrupt) return %5\n          else %5 = %5.Value\n        } else {\n          call %6 = clo<\"CreateDataProperty\">(val, prop, newElement)\n          assert (? %6: Completion)\n          if (? %6: Abrupt) return %6\n          else %6 = %6.Value\n        }\n        I = (+ I 1)\n      }\n    } else {\n      call %7 = clo<\"EnumerableOwnProperties\">(val, ~key~)\n      assert (? %7: Completion)\n      if (? %7: Abrupt) return %7\n      else %7 = %7.Value\n      let keys = %7\n      %9 = keys\n      %8 = 0\n      while (< %8 (sizeof %9)) {\n        let P = %9[%8]\n        if (? P: String) {\n          call %10 = clo<\"InternalizeJSONProperty\">(val, P, reviver)\n          assert (? %10: Completion)\n          if (? %10: Abrupt) return %10\n          else %10 = %10.Value\n          let newElement = %10\n          if (= newElement undefined) {\n            call %11 = val.Delete(val, P)\n            assert (? %11: Completion)\n            if (? %11: Abrupt) return %11\n            else %11 = %11.Value\n          } else {\n            call %12 = clo<\"CreateDataProperty\">(val, P, newElement)\n            assert (? %12: Completion)\n            if (? %12: Abrupt) return %12\n            else %12 = %12.Value\n          }\n        }\n        %8 = (+ %8 1)\n      }\n    }\n  }\n  call %13 = clo<\"Call\">(reviver, holder, (list [name, val])[#1320])\n  assert (? %13: Completion)\n  return %13\n}","def <BUILTIN>:INTRINSICS.JSON.stringify(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1321]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop replacer < ArgumentsList\n    expand __args__.replacer\n  } else let replacer = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop space < ArgumentsList\n    expand __args__.space\n  } else let space = undefined\n  let stack = (list [])[#1322]\n  let indent = \"\"\n  let PropertyList = undefined\n  let ReplacerFunction = undefined\n  if (? replacer: Record[Object]) {\n    call %0 = clo<\"IsCallable\">(replacer)\n    if (= %0 true) {\n      ReplacerFunction = replacer\n    } else {\n      call %1 = clo<\"IsArray\">(replacer)\n      assert (? %1: Completion)\n      if (? %1: Abrupt) return %1\n      else %1 = %1.Value\n      let isArray = %1\n      if (= isArray true) {\n        PropertyList = (list [])[#1323]\n        call %2 = clo<\"LengthOfArrayLike\">(replacer)\n        assert (? %2: Completion)\n        if (? %2: Abrupt) return %2\n        else %2 = %2.Value\n        let len = %2\n        let k = 0\n        while (< k len) {\n          call %3 = clo<\"ToString\">(([number] k))\n          assert (? %3: Normal)\n          %3 = %3.Value\n          let prop = %3\n          call %4 = clo<\"Get\">(replacer, prop)\n          assert (? %4: Completion)\n          if (? %4: Abrupt) return %4\n          else %4 = %4.Value\n          let v = %4\n          let item = undefined\n          if (? v: String) {\n            item = v\n          } else {\n            if (? v: Number) {\n              call %5 = clo<\"ToString\">(v)\n              assert (? %5: Normal)\n              %5 = %5.Value\n              item = %5\n            } else {\n              if (? v: Record[Object]) {\n                (yet \"If _v_ has a [[StringData]] or [[NumberData]] internal slot, set _item_ to ? ToString(_v_).\")\n              }\n            }\n          }\n          if (&& (! (= item undefined)) (! (contains PropertyList item))) {\n            push PropertyList < item\n          }\n          k = (+ k 1)\n        }\n      }\n    }\n  }\n  if (? space: Record[Object]) {\n    if (exists space.NumberData) {\n      call %6 = clo<\"ToNumber\">(space)\n      assert (? %6: Completion)\n      if (? %6: Abrupt) return %6\n      else %6 = %6.Value\n      space = %6\n    } else {\n      if (exists space.StringData) {\n        call %7 = clo<\"ToString\">(space)\n        assert (? %7: Completion)\n        if (? %7: Abrupt) return %7\n        else %7 = %7.Value\n        space = %7\n      }\n    }\n  }\n  if (? space: Number) {\n    call %8 = clo<\"ToIntegerOrInfinity\">(space)\n    assert (? %8: Normal)\n    %8 = %8.Value\n    let spaceMV = %8\n    spaceMV = (min 10 spaceMV)\n    if (< spaceMV 1) {\n      let gap = \"\"\n    } else {\n      (yet \"let _gap_ be the String value containing _spaceMV_ occurrences of the code unit 0x0020 (SPACE).\")\n    }\n  } else {\n    if (? space: String) {\n      if (! (< 10 (sizeof space))) {\n        let gap = space\n      } else {\n        let gap = (substring space 0 10)\n      }\n    } else {\n      let gap = \"\"\n    }\n  }\n  call %9 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Object.prototype%\"])\n  let wrapper = %9\n  call %10 = clo<\"CreateDataPropertyOrThrow\">(wrapper, \"\", value)\n  assert (? %10: Normal)\n  %10 = %10.Value\n  let state = (record [JSONSerializationRecord] {\n    \"ReplacerFunction\" : ReplacerFunction,\n    \"Stack\" : stack,\n    \"Indent\" : indent,\n    \"Gap\" : gap,\n    \"PropertyList\" : PropertyList,\n  })[#1324]\n  call %11 = clo<\"SerializeJSONProperty\">(state, \"\", wrapper)\n  assert (? %11: Completion)\n  return %11\n}","def SerializeJSONProperty(\n  state: Record[JSONSerializationRecord],\n  key: String,\n  holder: Record[Object],\n): Normal[String | Undefined] | Throw = {\n  call %0 = clo<\"Get\">(holder, key)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let value = %0\n  if (|| (? value: Record[Object]) (? value: BigInt)) {\n    call %1 = clo<\"GetV\">(value, \"toJSON\")\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let toJSON = %1\n    call %2 = clo<\"IsCallable\">(toJSON)\n    if (= %2 true) {\n      call %3 = clo<\"Call\">(toJSON, value, (list [key])[#1325])\n      assert (? %3: Completion)\n      if (? %3: Abrupt) return %3\n      else %3 = %3.Value\n      value = %3\n    }\n  }\n  if (! (= state.ReplacerFunction undefined)) {\n    call %4 = clo<\"Call\">(state.ReplacerFunction, holder, (list [key, value])[#1326])\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n    value = %4\n  }\n  if (? value: Record[Object]) {\n    if (exists value.NumberData) {\n      call %5 = clo<\"ToNumber\">(value)\n      assert (? %5: Completion)\n      if (? %5: Abrupt) return %5\n      else %5 = %5.Value\n      value = %5\n    } else {\n      if (exists value.StringData) {\n        call %6 = clo<\"ToString\">(value)\n        assert (? %6: Completion)\n        if (? %6: Abrupt) return %6\n        else %6 = %6.Value\n        value = %6\n      } else {\n        if (exists value.BooleanData) {\n          value = value.BooleanData\n        } else {\n          if (exists value.BigIntData) {\n            value = value.BigIntData\n          }\n        }\n      }\n    }\n  }\n  if (= value null) {\n    call %7 = clo<\"NormalCompletion\">(\"null\")\n    return %7\n  }\n  if (= value true) {\n    call %8 = clo<\"NormalCompletion\">(\"true\")\n    return %8\n  }\n  if (= value false) {\n    call %9 = clo<\"NormalCompletion\">(\"false\")\n    return %9\n  }\n  if (? value: String) {\n    call %10 = clo<\"QuoteJSONString\">(value)\n    if (? %10: Completion) return %10\n    call %11 = clo<\"NormalCompletion\">(%10)\n    return %11\n  }\n  if (? value: Number) {\n    if (! (|| (= value NaN) (|| (= value +NUM_INF) (= value -NUM_INF)))) {\n      call %12 = clo<\"ToString\">(value)\n      assert (? %12: Normal)\n      return %12\n    }\n    call %13 = clo<\"NormalCompletion\">(\"null\")\n    return %13\n  }\n  if (? value: BigInt) {\n    call %14 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %15 = clo<\"ThrowCompletion\">(%14)\n    return %15\n  }\n  %16 = (? value: Record[Object])\n  if %16 {\n    call %17 = clo<\"IsCallable\">(value)\n    %16 = (= %17 false)\n  }\n  if %16 {\n    call %18 = clo<\"IsArray\">(value)\n    assert (? %18: Completion)\n    if (? %18: Abrupt) return %18\n    else %18 = %18.Value\n    let isArray = %18\n    if (= isArray true) {\n      call %19 = clo<\"SerializeJSONArray\">(state, value)\n      assert (? %19: Completion)\n      return %19\n    }\n    call %20 = clo<\"SerializeJSONObject\">(state, value)\n    assert (? %20: Completion)\n    return %20\n  }\n  call %21 = clo<\"NormalCompletion\">(undefined)\n  return %21\n}","def QuoteJSONString(\n  value: String,\n): String = {\n  (yet \"Let _product_ be the String value consisting solely of the code unit 0x0022 (QUOTATION MARK).\")\n  (yet \"For each code point _C_ of StringToCodePoints(_value_), do\\n  1. If _C_ is listed in the ‚ÄúCode Point‚Äù column of <emu-xref href=\\\"#table-json-single-character-escapes\\\"></emu-xref>, then\\n    1. Set _product_ to the string-concatenation of _product_ and the escape sequence for _C_ as specified in the ‚ÄúEscape Sequence‚Äù column of the corresponding row.\\n  1. Else if _C_ has a numeric value less than 0x0020 (SPACE) or _C_ has the same numeric value as a leading surrogate or trailing surrogate, then\\n    1. Let _unit_ be the code unit whose numeric value is the numeric value of _C_.\\n    1. Set _product_ to the string-concatenation of _product_ and UnicodeEscape(_unit_).\\n  1. Else,\\n    1. Set _product_ to the string-concatenation of _product_ and UTF16EncodeCodePoint(_C_).\")\n  product = (concat product 34cu)\n  return product\n}","def UnicodeEscape(\n  C: Unknown[\"CodeUnit\"],\n): String = {\n  let n = ([math] C)\n  assert (! (< 65535 n))\n  (yet \"Let _hex_ be the String representation of _n_, formatted as a lowercase hexadecimal number.\")\n  call %0 = clo<\"StringPad\">(hex, 4, \"0\", ~start~)\n  return (concat 92cu \"u\" %0)\n}","def SerializeJSONObject(\n  state: Record[JSONSerializationRecord],\n  value: Record[Object],\n): Normal[String] | Throw = {\n  if (contains state.Stack value) {\n    (yet \"throw a *TypeError* exception because the structure is cyclical.\")\n  }\n  push state.Stack < value\n  let stepback = state.Indent\n  state.Indent = (concat state.Indent state.Gap)\n  if (! (= state.PropertyList undefined)) {\n    let K = state.PropertyList\n  } else {\n    call %0 = clo<\"EnumerableOwnProperties\">(value, ~key~)\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let K = %0\n  }\n  let partial = (list [])[#1327]\n  %2 = K\n  %1 = 0\n  while (< %1 (sizeof %2)) {\n    let P = %2[%1]\n    call %3 = clo<\"SerializeJSONProperty\">(state, P, value)\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let strP = %3\n    if (! (= strP undefined)) {\n      call %4 = clo<\"QuoteJSONString\">(P)\n      let member = %4\n      member = (concat member \":\")\n      if (! (= state.Gap \"\")) {\n        member = (concat member 32cu)\n      }\n      member = (concat member strP)\n      push partial < member\n    }\n    %1 = (+ %1 1)\n  }\n  if (= (sizeof partial) 0) {\n    let final = \"{}\"\n  } else {\n    if (= state.Gap \"\") {\n      (yet \"Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with the code unit 0x002C (COMMA). A comma is not inserted either before the first String or after the last String.\")\n      let final = (concat \"{\" properties \"}\")\n    } else {\n      let separator = (concat 44cu 10cu state.Indent)\n      (yet \"Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with _separator_. The _separator_ String is not inserted either before the first String or after the last String.\")\n      let final = (concat \"{\" 10cu state.Indent properties 10cu stepback \"}\")\n    }\n  }\n  (yet \"Remove the last element of _state_.[[Stack]].\")\n  state.Indent = stepback\n  if (? final: Completion) return final\n  call %5 = clo<\"NormalCompletion\">(final)\n  return %5\n}","def SerializeJSONArray(\n  state: Record[JSONSerializationRecord],\n  value: ESValue,\n): Normal[String] | Throw = {\n  if (contains state.Stack value) {\n    (yet \"throw a *TypeError* exception because the structure is cyclical.\")\n  }\n  push state.Stack < value\n  let stepback = state.Indent\n  state.Indent = (concat state.Indent state.Gap)\n  let partial = (list [])[#1328]\n  call %0 = clo<\"LengthOfArrayLike\">(value)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let len = %0\n  let index = 0\n  while (< index len) {\n    call %1 = clo<\"ToString\">(([number] index))\n    assert (? %1: Normal)\n    %1 = %1.Value\n    call %2 = clo<\"SerializeJSONProperty\">(state, %1, value)\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    let strP = %2\n    if (= strP undefined) {\n      push partial < \"null\"\n    } else {\n      push partial < strP\n    }\n    index = (+ index 1)\n  }\n  if (= (sizeof partial) 0) {\n    let final = \"[]\"\n  } else {\n    if (= state.Gap \"\") {\n      (yet \"Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with the code unit 0x002C (COMMA). A comma is not inserted either before the first String or after the last String.\")\n      let final = (concat \"[\" properties \"]\")\n    } else {\n      let separator = (concat 44cu 10cu state.Indent)\n      (yet \"Let _properties_ be the String value formed by concatenating all the element Strings of _partial_ with each adjacent pair of Strings separated with _separator_. The _separator_ String is not inserted either before the first String or after the last String.\")\n      let final = (concat \"[\" 10cu state.Indent properties 10cu stepback \"]\")\n    }\n  }\n  (yet \"Remove the last element of _state_.[[Stack]].\")\n  state.Indent = stepback\n  if (? final: Completion) return final\n  call %3 = clo<\"NormalCompletion\">(final)\n  return %3\n}","def <BUILTIN>:INTRINSICS.WeakRef(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1329]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop target < ArgumentsList\n    expand __args__.target\n  } else let target = undefined\n  if (= NewTarget undefined) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"CanBeHeldWeakly\">(target)\n  if (= %2 false) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  call %5 = clo<\"OrdinaryCreateFromConstructor\">(NewTarget, \"%WeakRef.prototype%\", (list [\"WeakRefTarget\"])[#1330])\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  let weakRef = %5\n  call %6 = clo<\"AddToKeptObjects\">(target)\n  weakRef.WeakRefTarget = target\n  if (? weakRef: Completion) return weakRef\n  call %7 = clo<\"NormalCompletion\">(weakRef)\n  return %7\n}","def <BUILTIN>:INTRINSICS.WeakRef.prototype.deref(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1331]\n  let weakRef = this\n  call %0 = clo<\"RequireInternalSlot\">(weakRef, \"WeakRefTarget\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"WeakRefDeref\">(weakRef)\n  if (? %1: Completion) return %1\n  call %2 = clo<\"NormalCompletion\">(%1)\n  return %2\n}","def WeakRefDeref(\n  weakRef: Record[WeakRef],\n): ESValue = {\n  let target = weakRef.WeakRefTarget\n  if (! (= target ~empty~)) {\n    call %0 = clo<\"AddToKeptObjects\">(target)\n    return target\n  }\n  return undefined\n}","def <BUILTIN>:INTRINSICS.FinalizationRegistry(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1332]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop cleanupCallback < ArgumentsList\n    expand __args__.cleanupCallback\n  } else let cleanupCallback = undefined\n  if (= NewTarget undefined) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"IsCallable\">(cleanupCallback)\n  if (= %2 false) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  call %5 = clo<\"OrdinaryCreateFromConstructor\">(NewTarget, \"%FinalizationRegistry.prototype%\", (list [\"Realm\", \"CleanupCallback\", \"Cells\"])[#1333])\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  let finalizationRegistry = %5\n  let fn = @EXECUTION_STACK[0].Function\n  finalizationRegistry.Realm = fn.Realm\n  call %6 = clo<\"HostMakeJobCallback\">(cleanupCallback)\n  finalizationRegistry.CleanupCallback = %6\n  finalizationRegistry.Cells = (list [])[#1334]\n  if (? finalizationRegistry: Completion) return finalizationRegistry\n  call %7 = clo<\"NormalCompletion\">(finalizationRegistry)\n  return %7\n}","def <BUILTIN>:INTRINSICS.FinalizationRegistry.prototype.register(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1335]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop target < ArgumentsList\n    expand __args__.target\n  } else let target = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop heldValue < ArgumentsList\n    expand __args__.heldValue\n  } else let heldValue = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop unregisterToken < ArgumentsList\n    expand __args__.unregisterToken\n  } else let unregisterToken = undefined\n  let finalizationRegistry = this\n  call %0 = clo<\"RequireInternalSlot\">(finalizationRegistry, \"Cells\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"CanBeHeldWeakly\">(target)\n  if (= %1 false) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  call %4 = clo<\"SameValue\">(target, heldValue)\n  if (= %4 true) {\n    call %5 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %6 = clo<\"ThrowCompletion\">(%5)\n    return %6\n  }\n  call %7 = clo<\"CanBeHeldWeakly\">(unregisterToken)\n  if (= %7 false) {\n    if (! (= unregisterToken undefined)) {\n      call %8 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %9 = clo<\"ThrowCompletion\">(%8)\n      return %9\n    }\n    unregisterToken = ~empty~\n  }\n  let cell = (record {\n    \"WeakRefTarget\" : target,\n    \"HeldValue\" : heldValue,\n    \"UnregisterToken\" : unregisterToken,\n  })[#1336]\n  push finalizationRegistry.Cells < cell\n  call %10 = clo<\"NormalCompletion\">(undefined)\n  return %10\n}","def <BUILTIN>:INTRINSICS.FinalizationRegistry.prototype.unregister(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1337]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop unregisterToken < ArgumentsList\n    expand __args__.unregisterToken\n  } else let unregisterToken = undefined\n  let finalizationRegistry = this\n  call %0 = clo<\"RequireInternalSlot\">(finalizationRegistry, \"Cells\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"CanBeHeldWeakly\">(unregisterToken)\n  if (= %1 false) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  let removed = false\n  %5 = finalizationRegistry.Cells\n  %4 = 0\n  while (< %4 (sizeof %5)) {\n    let cell = %5[%4]\n    if (? cell: Record[{ HeldValue, UnregisterToken, WeakRefTarget }]) {\n      %6 = (! (= cell.UnregisterToken ~empty~))\n      if %6 {\n        call %7 = clo<\"SameValue\">(cell.UnregisterToken, unregisterToken)\n        %6 = (= %7 true)\n      }\n      if %6 {\n        call %8 = clo<\"__REMOVE_ELEM__\">(cell, finalizationRegistry.Cells)\n        removed = true\n      }\n    }\n    %4 = (+ %4 1)\n  }\n  if (? removed: Completion) return removed\n  call %9 = clo<\"NormalCompletion\">(removed)\n  return %9\n}","def <BUILTIN>:INTRINSICS.IteratorPrototype[@@iterator](\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1338]\n  if (? this: Completion) return this\n  call %0 = clo<\"NormalCompletion\">(this)\n  return %0\n}","def <BUILTIN>:INTRINSICS.AsyncIteratorPrototype[@@asyncIterator](\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1339]\n  if (? this: Completion) return this\n  call %0 = clo<\"NormalCompletion\">(this)\n  return %0\n}","def CreateAsyncFromSyncIterator(\n  syncIteratorRecord: Record[IteratorRecord],\n): Record[IteratorRecord] = {\n  call %0 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%AsyncFromSyncIteratorPrototype%\"], (list [\"SyncIteratorRecord\"])[#1340])\n  let asyncIterator = %0\n  asyncIterator.SyncIteratorRecord = syncIteratorRecord\n  call %1 = clo<\"Get\">(asyncIterator, \"next\")\n  assert (? %1: Normal)\n  %1 = %1.Value\n  let nextMethod = %1\n  let iteratorRecord = (record [IteratorRecord] {\n    \"Iterator\" : asyncIterator,\n    \"NextMethod\" : nextMethod,\n    \"Done\" : false,\n  })[#1341]\n  return iteratorRecord\n}","def <BUILTIN>:INTRINSICS.AsyncFromSyncIteratorPrototype.next(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1342]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  let O = this\n  assert (&& (? O: Record[Object]) (exists O.SyncIteratorRecord))\n  call %0 = clo<\"NewPromiseCapability\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Promise%\"])\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let promiseCapability = %0\n  let syncIteratorRecord = O.SyncIteratorRecord\n  if (exists __args__.value) {\n    call %1 = clo<\"IteratorNext\">(syncIteratorRecord, value)\n    call %2 = clo<\"Completion\">(%1)\n    let result = %2\n  } else {\n    call %3 = clo<\"IteratorNext\">(syncIteratorRecord)\n    call %4 = clo<\"Completion\">(%3)\n    let result = %4\n  }\n  assert (? result: Completion)\n  if (&& (? result: Completion) (! (= result.Type ~normal~))) {\n    call %5 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [result.Value])[#1343])\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n    %6 = promiseCapability.Promise\n    if (? %6: Completion) return %6\n    call %7 = clo<\"NormalCompletion\">(%6)\n    return %7\n  } else {\n    assert (? result: Normal)\n    result = result.Value\n    result = result\n  }\n  call %8 = clo<\"AsyncFromSyncIteratorContinuation\">(result, promiseCapability)\n  if (? %8: Completion) return %8\n  call %9 = clo<\"NormalCompletion\">(%8)\n  return %9\n}","def <BUILTIN>:INTRINSICS.AsyncFromSyncIteratorPrototype.return(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1344]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  let O = this\n  assert (&& (? O: Record[Object]) (exists O.SyncIteratorRecord))\n  call %0 = clo<\"NewPromiseCapability\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Promise%\"])\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let promiseCapability = %0\n  let syncIterator = O.SyncIteratorRecord.Iterator\n  call %1 = clo<\"GetMethod\">(syncIterator, \"return\")\n  call %2 = clo<\"Completion\">(%1)\n  let return = %2\n  assert (? return: Completion)\n  if (&& (? return: Completion) (! (= return.Type ~normal~))) {\n    call %3 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [return.Value])[#1345])\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    %4 = promiseCapability.Promise\n    if (? %4: Completion) return %4\n    call %5 = clo<\"NormalCompletion\">(%4)\n    return %5\n  } else {\n    assert (? return: Normal)\n    return = return.Value\n    return = return\n  }\n  if (= return undefined) {\n    call %6 = clo<\"CreateIterResultObject\">(value, true)\n    let iterResult = %6\n    call %7 = clo<\"Call\">(promiseCapability.Resolve, undefined, (list [iterResult])[#1346])\n    assert (? %7: Normal)\n    %7 = %7.Value\n    %8 = promiseCapability.Promise\n    if (? %8: Completion) return %8\n    call %9 = clo<\"NormalCompletion\">(%8)\n    return %9\n  }\n  if (exists __args__.value) {\n    call %10 = clo<\"Call\">(return, syncIterator, (list [value])[#1347])\n    call %11 = clo<\"Completion\">(%10)\n    let result = %11\n  } else {\n    call %12 = clo<\"Call\">(return, syncIterator)\n    call %13 = clo<\"Completion\">(%12)\n    let result = %13\n  }\n  assert (? result: Completion)\n  if (&& (? result: Completion) (! (= result.Type ~normal~))) {\n    call %14 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [result.Value])[#1348])\n    assert (? %14: Completion)\n    if (? %14: Abrupt) return %14\n    else %14 = %14.Value\n    %15 = promiseCapability.Promise\n    if (? %15: Completion) return %15\n    call %16 = clo<\"NormalCompletion\">(%15)\n    return %16\n  } else {\n    assert (? result: Normal)\n    result = result.Value\n    result = result\n  }\n  if (! (? result: Record[Object])) {\n    call %17 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %18 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [%17])[#1349])\n    assert (? %18: Normal)\n    %18 = %18.Value\n    %19 = promiseCapability.Promise\n    if (? %19: Completion) return %19\n    call %20 = clo<\"NormalCompletion\">(%19)\n    return %20\n  }\n  call %21 = clo<\"AsyncFromSyncIteratorContinuation\">(result, promiseCapability)\n  if (? %21: Completion) return %21\n  call %22 = clo<\"NormalCompletion\">(%21)\n  return %22\n}","def <BUILTIN>:INTRINSICS.AsyncFromSyncIteratorPrototype.throw(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1350]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  let O = this\n  assert (&& (? O: Record[Object]) (exists O.SyncIteratorRecord))\n  call %0 = clo<\"NewPromiseCapability\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Promise%\"])\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let promiseCapability = %0\n  let syncIterator = O.SyncIteratorRecord.Iterator\n  call %1 = clo<\"GetMethod\">(syncIterator, \"throw\")\n  call %2 = clo<\"Completion\">(%1)\n  let throw = %2\n  assert (? throw: Completion)\n  if (&& (? throw: Completion) (! (= throw.Type ~normal~))) {\n    call %3 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [throw.Value])[#1351])\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    %4 = promiseCapability.Promise\n    if (? %4: Completion) return %4\n    call %5 = clo<\"NormalCompletion\">(%4)\n    return %5\n  } else {\n    assert (? throw: Normal)\n    throw = throw.Value\n    throw = throw\n  }\n  if (= throw undefined) {\n    call %6 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [value])[#1352])\n    assert (? %6: Normal)\n    %6 = %6.Value\n    %7 = promiseCapability.Promise\n    if (? %7: Completion) return %7\n    call %8 = clo<\"NormalCompletion\">(%7)\n    return %8\n  }\n  if (exists __args__.value) {\n    call %9 = clo<\"Call\">(throw, syncIterator, (list [value])[#1353])\n    call %10 = clo<\"Completion\">(%9)\n    let result = %10\n  } else {\n    call %11 = clo<\"Call\">(throw, syncIterator)\n    call %12 = clo<\"Completion\">(%11)\n    let result = %12\n  }\n  assert (? result: Completion)\n  if (&& (? result: Completion) (! (= result.Type ~normal~))) {\n    call %13 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [result.Value])[#1354])\n    assert (? %13: Completion)\n    if (? %13: Abrupt) return %13\n    else %13 = %13.Value\n    %14 = promiseCapability.Promise\n    if (? %14: Completion) return %14\n    call %15 = clo<\"NormalCompletion\">(%14)\n    return %15\n  } else {\n    assert (? result: Normal)\n    result = result.Value\n    result = result\n  }\n  if (! (? result: Record[Object])) {\n    call %16 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %17 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [%16])[#1355])\n    assert (? %17: Normal)\n    %17 = %17.Value\n    %18 = promiseCapability.Promise\n    if (? %18: Completion) return %18\n    call %19 = clo<\"NormalCompletion\">(%18)\n    return %19\n  }\n  call %20 = clo<\"AsyncFromSyncIteratorContinuation\">(result, promiseCapability)\n  if (? %20: Completion) return %20\n  call %21 = clo<\"NormalCompletion\">(%20)\n  return %21\n}","def <CLO>:AsyncFromSyncIteratorContinuation:clo0(\n  this: Unknown,\n  ArgumentsList: Unknown,\n  NewTarget: Unknown,\n): Unknown = {\n  let __args__ = (record)[#1356]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop v < ArgumentsList\n    expand __args__.v\n  } else let v = undefined\n  call %0 = clo<\"CreateIterResultObject\">(v, done)\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def AsyncFromSyncIteratorContinuation(\n  result: Record[Object],\n  promiseCapability: Unknown[\"PromiseCapabilityRecordForAnIntrinsic%Promise%\"],\n): Record[Promise] = {\n  nop\n  call %0 = clo<\"IteratorComplete\">(result)\n  call %1 = clo<\"Completion\">(%0)\n  let done = %1\n  assert (? done: Completion)\n  if (&& (? done: Completion) (! (= done.Type ~normal~))) {\n    call %2 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [done.Value])[#1357])\n    assert (? %2: Completion)\n    if (? %2: Abrupt) return %2\n    else %2 = %2.Value\n    return promiseCapability.Promise\n  } else {\n    assert (? done: Normal)\n    done = done.Value\n    done = done\n  }\n  call %3 = clo<\"IteratorValue\">(result)\n  call %4 = clo<\"Completion\">(%3)\n  let value = %4\n  assert (? value: Completion)\n  if (&& (? value: Completion) (! (= value.Type ~normal~))) {\n    call %5 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [value.Value])[#1358])\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n    return promiseCapability.Promise\n  } else {\n    assert (? value: Normal)\n    value = value.Value\n    value = value\n  }\n  call %6 = clo<\"PromiseResolve\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Promise%\"], value)\n  call %7 = clo<\"Completion\">(%6)\n  let valueWrapper = %7\n  assert (? valueWrapper: Completion)\n  if (&& (? valueWrapper: Completion) (! (= valueWrapper.Type ~normal~))) {\n    call %8 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [valueWrapper.Value])[#1359])\n    assert (? %8: Completion)\n    if (? %8: Abrupt) return %8\n    else %8 = %8.Value\n    return promiseCapability.Promise\n  } else {\n    assert (? valueWrapper: Normal)\n    valueWrapper = valueWrapper.Value\n    valueWrapper = valueWrapper\n  }\n  let unwrap = clo<\"AsyncFromSyncIteratorContinuation:clo0\", [done]>\n  call %9 = clo<\"CreateBuiltinFunction\">(unwrap, 1, \"\", (list [])[#1360])\n  let onFulfilled = %9\n  nop\n  call %10 = clo<\"PerformPromiseThen\">(valueWrapper, onFulfilled, undefined, promiseCapability)\n  return promiseCapability.Promise\n}","def CreateResolvingFunctions(\n  promise: Record[Promise],\n): Unknown[\"RecordWithFields[[Resolve]](aFunctionObject)And[[Reject]](aFunctionObject)\"] = {\n  let alreadyResolved = (record {\n    \"Value\" : false,\n  })[#1361]\n  let stepsResolve = clo<\"INTRINSICS.yet:PromiseResolveFunction\">\n  let lengthResolve = 1\n  call %0 = clo<\"CreateBuiltinFunction\">(stepsResolve, lengthResolve, \"\", (list [\"Promise\", \"AlreadyResolved\"])[#1362])\n  let resolve = %0\n  resolve.Promise = promise\n  resolve.AlreadyResolved = alreadyResolved\n  let stepsReject = clo<\"INTRINSICS.yet:PromiseRejectFunction\">\n  let lengthReject = 1\n  call %1 = clo<\"CreateBuiltinFunction\">(stepsReject, lengthReject, \"\", (list [\"Promise\", \"AlreadyResolved\"])[#1363])\n  let reject = %1\n  reject.Promise = promise\n  reject.AlreadyResolved = alreadyResolved\n  return (record {\n    \"Resolve\" : resolve,\n    \"Reject\" : reject,\n  })[#1364]\n}","def <BUILTIN>:INTRINSICS.yet:PromiseRejectFunction(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1365]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop reason < ArgumentsList\n    expand __args__.reason\n  } else let reason = undefined\n  let F = @EXECUTION_STACK[0].Function\n  assert (&& (exists F.Promise) (? F.Promise: Record[Object]))\n  let promise = F.Promise\n  let alreadyResolved = F.AlreadyResolved\n  if (= alreadyResolved.Value true) {\n    call %0 = clo<\"NormalCompletion\">(undefined)\n    return %0\n  }\n  alreadyResolved.Value = true\n  call %1 = clo<\"RejectPromise\">(promise, reason)\n  call %2 = clo<\"NormalCompletion\">(undefined)\n  return %2\n}","def <BUILTIN>:INTRINSICS.yet:PromiseResolveFunction(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1366]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop resolution < ArgumentsList\n    expand __args__.resolution\n  } else let resolution = undefined\n  let F = @EXECUTION_STACK[0].Function\n  assert (&& (exists F.Promise) (? F.Promise: Record[Object]))\n  let promise = F.Promise\n  let alreadyResolved = F.AlreadyResolved\n  if (= alreadyResolved.Value true) {\n    call %0 = clo<\"NormalCompletion\">(undefined)\n    return %0\n  }\n  alreadyResolved.Value = true\n  call %1 = clo<\"SameValue\">(resolution, promise)\n  if (= %1 true) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    let selfResolutionError = %2\n    call %3 = clo<\"RejectPromise\">(promise, selfResolutionError)\n    call %4 = clo<\"NormalCompletion\">(undefined)\n    return %4\n  }\n  if (! (? resolution: Record[Object])) {\n    call %5 = clo<\"FulfillPromise\">(promise, resolution)\n    call %6 = clo<\"NormalCompletion\">(undefined)\n    return %6\n  }\n  call %7 = clo<\"Get\">(resolution, \"then\")\n  call %8 = clo<\"Completion\">(%7)\n  let then = %8\n  if (&& (? then: Completion) (! (= then.Type ~normal~))) {\n    call %9 = clo<\"RejectPromise\">(promise, then.Value)\n    call %10 = clo<\"NormalCompletion\">(undefined)\n    return %10\n  }\n  let thenAction = then.Value\n  call %11 = clo<\"IsCallable\">(thenAction)\n  if (= %11 false) {\n    call %12 = clo<\"FulfillPromise\">(promise, resolution)\n    call %13 = clo<\"NormalCompletion\">(undefined)\n    return %13\n  }\n  call %14 = clo<\"HostMakeJobCallback\">(thenAction)\n  let thenJobCallback = %14\n  call %15 = clo<\"NewPromiseResolveThenableJob\">(promise, resolution, thenJobCallback)\n  let job = %15\n  call %16 = clo<\"HostEnqueuePromiseJob\">(job.Job, job.Realm)\n  call %17 = clo<\"NormalCompletion\">(undefined)\n  return %17\n}","def FulfillPromise(\n  promise: Record[Promise],\n  value: ESValue,\n): Enum[~unused~] = {\n  assert (= promise.PromiseState ~pending~)\n  let reactions = promise.PromiseFulfillReactions\n  promise.PromiseResult = value\n  promise.PromiseFulfillReactions = undefined\n  promise.PromiseRejectReactions = undefined\n  promise.PromiseState = ~fulfilled~\n  call %0 = clo<\"TriggerPromiseReactions\">(reactions, value)\n  return ~unused~\n}","def <CLO>:NewPromiseCapability:clo0(\n  this: Unknown,\n  ArgumentsList: Unknown,\n  NewTarget: Unknown,\n): Unknown = {\n  let __args__ = (record)[#1367]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop resolve < ArgumentsList\n    expand __args__.resolve\n  } else let resolve = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop reject < ArgumentsList\n    expand __args__.reject\n  } else let reject = undefined\n  if (! (= resolvingFunctions.Resolve undefined)) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  if (! (= resolvingFunctions.Reject undefined)) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  resolvingFunctions.Resolve = resolve\n  resolvingFunctions.Reject = reject\n  call %4 = clo<\"NormalCompletion\">(undefined)\n  return %4\n}","def NewPromiseCapability(\n  C: ESValue,\n): Normal[Record[PromiseCapabilityRecord]] | Throw = {\n  call %0 = clo<\"IsConstructor\">(C)\n  if (= %0 false) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  nop\n  let resolvingFunctions = (record {\n    \"Resolve\" : undefined,\n    \"Reject\" : undefined,\n  })[#1368]\n  let executorClosure = clo<\"NewPromiseCapability:clo0\", [resolvingFunctions]>\n  call %3 = clo<\"CreateBuiltinFunction\">(executorClosure, 2, \"\", (list [])[#1369])\n  let executor = %3\n  call %4 = clo<\"Construct\">(C, (list [executor])[#1370])\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let promise = %4\n  call %5 = clo<\"IsCallable\">(resolvingFunctions.Resolve)\n  if (= %5 false) {\n    call %6 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %7 = clo<\"ThrowCompletion\">(%6)\n    return %7\n  }\n  call %8 = clo<\"IsCallable\">(resolvingFunctions.Reject)\n  if (= %8 false) {\n    call %9 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %10 = clo<\"ThrowCompletion\">(%9)\n    return %10\n  }\n  %11 = (record [PromiseCapabilityRecord] {\n    \"Promise\" : promise,\n    \"Resolve\" : resolvingFunctions.Resolve,\n    \"Reject\" : resolvingFunctions.Reject,\n  })[#1371]\n  if (? %11: Completion) return %11\n  call %12 = clo<\"NormalCompletion\">(%11)\n  return %12\n}","def IsPromise(\n  x: ESValue,\n): Boolean = {\n  if (! (? x: Record[Object])) {\n    return false\n  }\n  if (! (exists x.PromiseState)) {\n    return false\n  }\n  return true\n}","def RejectPromise(\n  promise: Record[Promise],\n  reason: ESValue,\n): Enum[~unused~] = {\n  assert (= promise.PromiseState ~pending~)\n  let reactions = promise.PromiseRejectReactions\n  promise.PromiseResult = reason\n  promise.PromiseFulfillReactions = undefined\n  promise.PromiseRejectReactions = undefined\n  promise.PromiseState = ~rejected~\n  if (= promise.PromiseIsHandled false) {\n    call %0 = clo<\"HostPromiseRejectionTracker\">(promise, \"reject\")\n  }\n  call %1 = clo<\"TriggerPromiseReactions\">(reactions, reason)\n  return ~unused~\n}","def TriggerPromiseReactions(\n  reactions: List[Record[PromiseReactionRecord]],\n  argument: ESValue,\n): Enum[~unused~] = {\n  %1 = reactions\n  %0 = 0\n  while (< %0 (sizeof %1)) {\n    let reaction = %1[%0]\n    call %2 = clo<\"NewPromiseReactionJob\">(reaction, argument)\n    let job = %2\n    call %3 = clo<\"HostEnqueuePromiseJob\">(job.Job, job.Realm)\n    %0 = (+ %0 1)\n  }\n  return ~unused~\n}","def <CLO>:NewPromiseReactionJob:clo0(\n): Unknown = {\n  let promiseCapability = reaction.Capability\n  let type = reaction.Type\n  let handler = reaction.Handler\n  if (= handler ~empty~) {\n    if (= type ~fulfill~) {\n      call %0 = clo<\"NormalCompletion\">(argument)\n      let handlerResult = %0\n    } else {\n      assert (= type ~reject~)\n      call %1 = clo<\"ThrowCompletion\">(argument)\n      let handlerResult = %1\n    }\n  } else {\n    call %2 = clo<\"HostCallJobCallback\">(handler, undefined, (list [argument])[#1372])\n    call %3 = clo<\"Completion\">(%2)\n    let handlerResult = %3\n  }\n  if (= promiseCapability undefined) {\n    assert (! (&& (? handlerResult: Completion) (! (= handlerResult.Type ~normal~))))\n    call %4 = clo<\"NormalCompletion\">(~empty~)\n    return %4\n  }\n  assert (? promiseCapability: Record[PromiseCapabilityRecord])\n  if (&& (? handlerResult: Completion) (! (= handlerResult.Type ~normal~))) {\n    call %5 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [handlerResult.Value])[#1373])\n    assert (? %5: Completion)\n    return %5\n  } else {\n    call %6 = clo<\"Call\">(promiseCapability.Resolve, undefined, (list [handlerResult.Value])[#1374])\n    assert (? %6: Completion)\n    return %6\n  }\n}","def NewPromiseReactionJob(\n  reaction: Record[PromiseReactionRecord],\n  argument: ESValue,\n): Unknown[\"RecordWithFields[[Job]](aJobAbstractClosure)And[[Realm]](aRealmRecordOr*null*)\"] = {\n  let job = clo<\"NewPromiseReactionJob:clo0\", [reaction, argument]>\n  let handlerRealm = null\n  if (! (= reaction.Handler ~empty~)) {\n    call %0 = clo<\"GetFunctionRealm\">(reaction.Handler.Callback)\n    call %1 = clo<\"Completion\">(%0)\n    let getHandlerRealmResult = %1\n    if (&& (? getHandlerRealmResult: Completion) (= getHandlerRealmResult.Type ~normal~)) {\n      handlerRealm = getHandlerRealmResult.Value\n    } else {\n      handlerRealm = @EXECUTION_STACK[0].Realm\n    }\n    nop\n  }\n  return (record {\n    \"Job\" : job,\n    \"Realm\" : handlerRealm,\n  })[#1375]\n}","def <CLO>:NewPromiseResolveThenableJob:clo0(\n): Unknown = {\n  call %0 = clo<\"CreateResolvingFunctions\">(promiseToResolve)\n  let resolvingFunctions = %0\n  call %1 = clo<\"HostCallJobCallback\">(then, thenable, (list [resolvingFunctions.Resolve, resolvingFunctions.Reject])[#1376])\n  call %2 = clo<\"Completion\">(%1)\n  let thenCallResult = %2\n  if (&& (? thenCallResult: Completion) (! (= thenCallResult.Type ~normal~))) {\n    call %3 = clo<\"Call\">(resolvingFunctions.Reject, undefined, (list [thenCallResult.Value])[#1377])\n    assert (? %3: Completion)\n    return %3\n  }\n  assert (? thenCallResult: Completion)\n  return thenCallResult\n}","def NewPromiseResolveThenableJob(\n  promiseToResolve: Record[Promise],\n  thenable: Record[Object],\n  then: Record[JobCallbackRecord],\n): Unknown[\"RecordWithFields[[Job]](aJobAbstractClosure)And[[Realm]](aRealmRecord)\"] = {\n  let job = clo<\"NewPromiseResolveThenableJob:clo0\", [promiseToResolve, thenable, then]>\n  call %0 = clo<\"GetFunctionRealm\">(then.Callback)\n  call %1 = clo<\"Completion\">(%0)\n  let getThenRealmResult = %1\n  if (&& (? getThenRealmResult: Completion) (= getThenRealmResult.Type ~normal~)) {\n    let thenRealm = getThenRealmResult.Value\n  } else {\n    let thenRealm = @EXECUTION_STACK[0].Realm\n  }\n  nop\n  return (record {\n    \"Job\" : job,\n    \"Realm\" : thenRealm,\n  })[#1378]\n}","def <BUILTIN>:INTRINSICS.Promise(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1379]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop executor < ArgumentsList\n    expand __args__.executor\n  } else let executor = undefined\n  if (= NewTarget undefined) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"IsCallable\">(executor)\n  if (= %2 false) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  call %5 = clo<\"OrdinaryCreateFromConstructor\">(NewTarget, \"%Promise.prototype%\", (list [\"PromiseState\", \"PromiseResult\", \"PromiseFulfillReactions\", \"PromiseRejectReactions\", \"PromiseIsHandled\"])[#1380])\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  let promise = %5\n  promise.PromiseState = ~pending~\n  promise.PromiseFulfillReactions = (list [])[#1381]\n  promise.PromiseRejectReactions = (list [])[#1382]\n  promise.PromiseIsHandled = false\n  call %6 = clo<\"CreateResolvingFunctions\">(promise)\n  let resolvingFunctions = %6\n  call %7 = clo<\"Call\">(executor, undefined, (list [resolvingFunctions.Resolve, resolvingFunctions.Reject])[#1383])\n  call %8 = clo<\"Completion\">(%7)\n  let completion = %8\n  if (&& (? completion: Completion) (! (= completion.Type ~normal~))) {\n    call %9 = clo<\"Call\">(resolvingFunctions.Reject, undefined, (list [completion.Value])[#1384])\n    assert (? %9: Completion)\n    if (? %9: Abrupt) return %9\n    else %9 = %9.Value\n  }\n  if (? promise: Completion) return promise\n  call %10 = clo<\"NormalCompletion\">(promise)\n  return %10\n}","def <BUILTIN>:INTRINSICS.Promise.all(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1385]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop iterable < ArgumentsList\n    expand __args__.iterable\n  } else let iterable = undefined\n  let C = this\n  call %0 = clo<\"NewPromiseCapability\">(C)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let promiseCapability = %0\n  call %1 = clo<\"GetPromiseResolve\">(C)\n  call %2 = clo<\"Completion\">(%1)\n  let promiseResolve = %2\n  assert (? promiseResolve: Completion)\n  if (&& (? promiseResolve: Completion) (! (= promiseResolve.Type ~normal~))) {\n    call %3 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [promiseResolve.Value])[#1386])\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    %4 = promiseCapability.Promise\n    if (? %4: Completion) return %4\n    call %5 = clo<\"NormalCompletion\">(%4)\n    return %5\n  } else {\n    assert (? promiseResolve: Normal)\n    promiseResolve = promiseResolve.Value\n    promiseResolve = promiseResolve\n  }\n  call %6 = clo<\"GetIterator\">(iterable, ~sync~)\n  call %7 = clo<\"Completion\">(%6)\n  let iteratorRecord = %7\n  assert (? iteratorRecord: Completion)\n  if (&& (? iteratorRecord: Completion) (! (= iteratorRecord.Type ~normal~))) {\n    call %8 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [iteratorRecord.Value])[#1387])\n    assert (? %8: Completion)\n    if (? %8: Abrupt) return %8\n    else %8 = %8.Value\n    %9 = promiseCapability.Promise\n    if (? %9: Completion) return %9\n    call %10 = clo<\"NormalCompletion\">(%9)\n    return %10\n  } else {\n    assert (? iteratorRecord: Normal)\n    iteratorRecord = iteratorRecord.Value\n    iteratorRecord = iteratorRecord\n  }\n  call %11 = clo<\"PerformPromiseAll\">(iteratorRecord, C, promiseCapability, promiseResolve)\n  call %12 = clo<\"Completion\">(%11)\n  let result = %12\n  if (&& (? result: Completion) (! (= result.Type ~normal~))) {\n    if (= iteratorRecord.Done false) {\n      call %13 = clo<\"IteratorClose\">(iteratorRecord, result)\n      call %14 = clo<\"Completion\">(%13)\n      result = %14\n    }\n    assert (? result: Completion)\n    if (&& (? result: Completion) (! (= result.Type ~normal~))) {\n      call %15 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [result.Value])[#1388])\n      assert (? %15: Completion)\n      if (? %15: Abrupt) return %15\n      else %15 = %15.Value\n      %16 = promiseCapability.Promise\n      if (? %16: Completion) return %16\n      call %17 = clo<\"NormalCompletion\">(%16)\n      return %17\n    } else {\n      assert (? result: Normal)\n      result = result.Value\n      result = result\n    }\n  }\n  assert (? result: Completion)\n  return result\n}","def GetPromiseResolve(\n  promiseConstructor: Record[Constructor],\n): Normal[Record[FunctionObject]] | Throw = {\n  call %0 = clo<\"Get\">(promiseConstructor, \"resolve\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let promiseResolve = %0\n  call %1 = clo<\"IsCallable\">(promiseResolve)\n  if (= %1 false) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  if (? promiseResolve: Completion) return promiseResolve\n  call %4 = clo<\"NormalCompletion\">(promiseResolve)\n  return %4\n}","def PerformPromiseAll(\n  iteratorRecord: Record[IteratorRecord],\n  constructor: Record[Constructor],\n  resultCapability: Record[PromiseCapabilityRecord],\n  promiseResolve: Record[FunctionObject],\n): Normal[ESValue] | Throw = {\n  let values = (list [])[#1389]\n  let remainingElementsCount = (record {\n    \"Value\" : 1,\n  })[#1390]\n  let index = 0\n  while true {\n    call %0 = clo<\"IteratorStepValue\">(iteratorRecord)\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let next = %0\n    if (= next ~done~) {\n      remainingElementsCount.Value = (- remainingElementsCount.Value 1)\n      if (== remainingElementsCount.Value 0) {\n        call %1 = clo<\"CreateArrayFromList\">(values)\n        let valuesArray = %1\n        call %2 = clo<\"Call\">(resultCapability.Resolve, undefined, (list [valuesArray])[#1391])\n        assert (? %2: Completion)\n        if (? %2: Abrupt) return %2\n        else %2 = %2.Value\n      }\n      %3 = resultCapability.Promise\n      if (? %3: Completion) return %3\n      call %4 = clo<\"NormalCompletion\">(%3)\n      return %4\n    }\n    push values < undefined\n    call %5 = clo<\"Call\">(promiseResolve, constructor, (list [next])[#1392])\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n    let nextPromise = %5\n    let steps = clo<\"INTRINSICS.yet:`Promise.all`ResolveElementFunction\">\n    let length = 1\n    call %6 = clo<\"CreateBuiltinFunction\">(steps, length, \"\", (list [\"AlreadyCalled\", \"Index\", \"Values\", \"Capability\", \"RemainingElements\"])[#1393])\n    let onFulfilled = %6\n    onFulfilled.AlreadyCalled = false\n    onFulfilled.Index = index\n    onFulfilled.Values = values\n    onFulfilled.Capability = resultCapability\n    onFulfilled.RemainingElements = remainingElementsCount\n    remainingElementsCount.Value = (+ remainingElementsCount.Value 1)\n    call %7 = clo<\"Invoke\">(nextPromise, \"then\", (list [onFulfilled, resultCapability.Reject])[#1394])\n    assert (? %7: Completion)\n    if (? %7: Abrupt) return %7\n    else %7 = %7.Value\n    index = (+ index 1)\n  }\n}","def <BUILTIN>:INTRINSICS.yet:`Promise.all`ResolveElementFunction(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1395]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  let F = @EXECUTION_STACK[0].Function\n  if (= F.AlreadyCalled true) {\n    call %0 = clo<\"NormalCompletion\">(undefined)\n    return %0\n  }\n  F.AlreadyCalled = true\n  let index = F.Index\n  let values = F.Values\n  let promiseCapability = F.Capability\n  let remainingElementsCount = F.RemainingElements\n  values[index] = x\n  remainingElementsCount.Value = (- remainingElementsCount.Value 1)\n  if (== remainingElementsCount.Value 0) {\n    call %1 = clo<\"CreateArrayFromList\">(values)\n    let valuesArray = %1\n    call %2 = clo<\"Call\">(promiseCapability.Resolve, undefined, (list [valuesArray])[#1396])\n    assert (? %2: Completion)\n    return %2\n  }\n  call %3 = clo<\"NormalCompletion\">(undefined)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Promise.allSettled(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1397]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop iterable < ArgumentsList\n    expand __args__.iterable\n  } else let iterable = undefined\n  let C = this\n  call %0 = clo<\"NewPromiseCapability\">(C)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let promiseCapability = %0\n  call %1 = clo<\"GetPromiseResolve\">(C)\n  call %2 = clo<\"Completion\">(%1)\n  let promiseResolve = %2\n  assert (? promiseResolve: Completion)\n  if (&& (? promiseResolve: Completion) (! (= promiseResolve.Type ~normal~))) {\n    call %3 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [promiseResolve.Value])[#1398])\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    %4 = promiseCapability.Promise\n    if (? %4: Completion) return %4\n    call %5 = clo<\"NormalCompletion\">(%4)\n    return %5\n  } else {\n    assert (? promiseResolve: Normal)\n    promiseResolve = promiseResolve.Value\n    promiseResolve = promiseResolve\n  }\n  call %6 = clo<\"GetIterator\">(iterable, ~sync~)\n  call %7 = clo<\"Completion\">(%6)\n  let iteratorRecord = %7\n  assert (? iteratorRecord: Completion)\n  if (&& (? iteratorRecord: Completion) (! (= iteratorRecord.Type ~normal~))) {\n    call %8 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [iteratorRecord.Value])[#1399])\n    assert (? %8: Completion)\n    if (? %8: Abrupt) return %8\n    else %8 = %8.Value\n    %9 = promiseCapability.Promise\n    if (? %9: Completion) return %9\n    call %10 = clo<\"NormalCompletion\">(%9)\n    return %10\n  } else {\n    assert (? iteratorRecord: Normal)\n    iteratorRecord = iteratorRecord.Value\n    iteratorRecord = iteratorRecord\n  }\n  call %11 = clo<\"PerformPromiseAllSettled\">(iteratorRecord, C, promiseCapability, promiseResolve)\n  call %12 = clo<\"Completion\">(%11)\n  let result = %12\n  if (&& (? result: Completion) (! (= result.Type ~normal~))) {\n    if (= iteratorRecord.Done false) {\n      call %13 = clo<\"IteratorClose\">(iteratorRecord, result)\n      call %14 = clo<\"Completion\">(%13)\n      result = %14\n    }\n    assert (? result: Completion)\n    if (&& (? result: Completion) (! (= result.Type ~normal~))) {\n      call %15 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [result.Value])[#1400])\n      assert (? %15: Completion)\n      if (? %15: Abrupt) return %15\n      else %15 = %15.Value\n      %16 = promiseCapability.Promise\n      if (? %16: Completion) return %16\n      call %17 = clo<\"NormalCompletion\">(%16)\n      return %17\n    } else {\n      assert (? result: Normal)\n      result = result.Value\n      result = result\n    }\n  }\n  assert (? result: Completion)\n  return result\n}","def PerformPromiseAllSettled(\n  iteratorRecord: Record[IteratorRecord],\n  constructor: Record[Constructor],\n  resultCapability: Record[PromiseCapabilityRecord],\n  promiseResolve: Record[FunctionObject],\n): Normal[ESValue] | Throw = {\n  let values = (list [])[#1401]\n  let remainingElementsCount = (record {\n    \"Value\" : 1,\n  })[#1402]\n  let index = 0\n  while true {\n    call %0 = clo<\"IteratorStepValue\">(iteratorRecord)\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let next = %0\n    if (= next ~done~) {\n      remainingElementsCount.Value = (- remainingElementsCount.Value 1)\n      if (== remainingElementsCount.Value 0) {\n        call %1 = clo<\"CreateArrayFromList\">(values)\n        let valuesArray = %1\n        call %2 = clo<\"Call\">(resultCapability.Resolve, undefined, (list [valuesArray])[#1403])\n        assert (? %2: Completion)\n        if (? %2: Abrupt) return %2\n        else %2 = %2.Value\n      }\n      %3 = resultCapability.Promise\n      if (? %3: Completion) return %3\n      call %4 = clo<\"NormalCompletion\">(%3)\n      return %4\n    }\n    push values < undefined\n    call %5 = clo<\"Call\">(promiseResolve, constructor, (list [next])[#1404])\n    assert (? %5: Completion)\n    if (? %5: Abrupt) return %5\n    else %5 = %5.Value\n    let nextPromise = %5\n    let stepsFulfilled = clo<\"INTRINSICS.yet:`Promise.allSettled`ResolveElementFunction\">\n    let lengthFulfilled = 1\n    call %6 = clo<\"CreateBuiltinFunction\">(stepsFulfilled, lengthFulfilled, \"\", (list [\"AlreadyCalled\", \"Index\", \"Values\", \"Capability\", \"RemainingElements\"])[#1405])\n    let onFulfilled = %6\n    let alreadyCalled = (record {\n      \"Value\" : false,\n    })[#1406]\n    onFulfilled.AlreadyCalled = alreadyCalled\n    onFulfilled.Index = index\n    onFulfilled.Values = values\n    onFulfilled.Capability = resultCapability\n    onFulfilled.RemainingElements = remainingElementsCount\n    let stepsRejected = clo<\"INTRINSICS.yet:`Promise.allSettled`RejectElementFunction\">\n    let lengthRejected = 1\n    call %7 = clo<\"CreateBuiltinFunction\">(stepsRejected, lengthRejected, \"\", (list [\"AlreadyCalled\", \"Index\", \"Values\", \"Capability\", \"RemainingElements\"])[#1407])\n    let onRejected = %7\n    onRejected.AlreadyCalled = alreadyCalled\n    onRejected.Index = index\n    onRejected.Values = values\n    onRejected.Capability = resultCapability\n    onRejected.RemainingElements = remainingElementsCount\n    remainingElementsCount.Value = (+ remainingElementsCount.Value 1)\n    call %8 = clo<\"Invoke\">(nextPromise, \"then\", (list [onFulfilled, onRejected])[#1408])\n    assert (? %8: Completion)\n    if (? %8: Abrupt) return %8\n    else %8 = %8.Value\n    index = (+ index 1)\n  }\n}","def <BUILTIN>:INTRINSICS.yet:`Promise.allSettled`ResolveElementFunction(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1409]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  let F = @EXECUTION_STACK[0].Function\n  let alreadyCalled = F.AlreadyCalled\n  if (= alreadyCalled.Value true) {\n    call %0 = clo<\"NormalCompletion\">(undefined)\n    return %0\n  }\n  alreadyCalled.Value = true\n  let index = F.Index\n  let values = F.Values\n  let promiseCapability = F.Capability\n  let remainingElementsCount = F.RemainingElements\n  call %1 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Object.prototype%\"])\n  let obj = %1\n  call %2 = clo<\"CreateDataPropertyOrThrow\">(obj, \"status\", \"fulfilled\")\n  assert (? %2: Normal)\n  %2 = %2.Value\n  call %3 = clo<\"CreateDataPropertyOrThrow\">(obj, \"value\", x)\n  assert (? %3: Normal)\n  %3 = %3.Value\n  values[index] = obj\n  remainingElementsCount.Value = (- remainingElementsCount.Value 1)\n  if (== remainingElementsCount.Value 0) {\n    call %4 = clo<\"CreateArrayFromList\">(values)\n    let valuesArray = %4\n    call %5 = clo<\"Call\">(promiseCapability.Resolve, undefined, (list [valuesArray])[#1410])\n    assert (? %5: Completion)\n    return %5\n  }\n  call %6 = clo<\"NormalCompletion\">(undefined)\n  return %6\n}","def <BUILTIN>:INTRINSICS.yet:`Promise.allSettled`RejectElementFunction(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1411]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  let F = @EXECUTION_STACK[0].Function\n  let alreadyCalled = F.AlreadyCalled\n  if (= alreadyCalled.Value true) {\n    call %0 = clo<\"NormalCompletion\">(undefined)\n    return %0\n  }\n  alreadyCalled.Value = true\n  let index = F.Index\n  let values = F.Values\n  let promiseCapability = F.Capability\n  let remainingElementsCount = F.RemainingElements\n  call %1 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Object.prototype%\"])\n  let obj = %1\n  call %2 = clo<\"CreateDataPropertyOrThrow\">(obj, \"status\", \"rejected\")\n  assert (? %2: Normal)\n  %2 = %2.Value\n  call %3 = clo<\"CreateDataPropertyOrThrow\">(obj, \"reason\", x)\n  assert (? %3: Normal)\n  %3 = %3.Value\n  values[index] = obj\n  remainingElementsCount.Value = (- remainingElementsCount.Value 1)\n  if (== remainingElementsCount.Value 0) {\n    call %4 = clo<\"CreateArrayFromList\">(values)\n    let valuesArray = %4\n    call %5 = clo<\"Call\">(promiseCapability.Resolve, undefined, (list [valuesArray])[#1412])\n    assert (? %5: Completion)\n    return %5\n  }\n  call %6 = clo<\"NormalCompletion\">(undefined)\n  return %6\n}","def <BUILTIN>:INTRINSICS.Promise.any(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1413]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop iterable < ArgumentsList\n    expand __args__.iterable\n  } else let iterable = undefined\n  let C = this\n  call %0 = clo<\"NewPromiseCapability\">(C)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let promiseCapability = %0\n  call %1 = clo<\"GetPromiseResolve\">(C)\n  call %2 = clo<\"Completion\">(%1)\n  let promiseResolve = %2\n  assert (? promiseResolve: Completion)\n  if (&& (? promiseResolve: Completion) (! (= promiseResolve.Type ~normal~))) {\n    call %3 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [promiseResolve.Value])[#1414])\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    %4 = promiseCapability.Promise\n    if (? %4: Completion) return %4\n    call %5 = clo<\"NormalCompletion\">(%4)\n    return %5\n  } else {\n    assert (? promiseResolve: Normal)\n    promiseResolve = promiseResolve.Value\n    promiseResolve = promiseResolve\n  }\n  call %6 = clo<\"GetIterator\">(iterable, ~sync~)\n  call %7 = clo<\"Completion\">(%6)\n  let iteratorRecord = %7\n  assert (? iteratorRecord: Completion)\n  if (&& (? iteratorRecord: Completion) (! (= iteratorRecord.Type ~normal~))) {\n    call %8 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [iteratorRecord.Value])[#1415])\n    assert (? %8: Completion)\n    if (? %8: Abrupt) return %8\n    else %8 = %8.Value\n    %9 = promiseCapability.Promise\n    if (? %9: Completion) return %9\n    call %10 = clo<\"NormalCompletion\">(%9)\n    return %10\n  } else {\n    assert (? iteratorRecord: Normal)\n    iteratorRecord = iteratorRecord.Value\n    iteratorRecord = iteratorRecord\n  }\n  call %11 = clo<\"PerformPromiseAny\">(iteratorRecord, C, promiseCapability, promiseResolve)\n  call %12 = clo<\"Completion\">(%11)\n  let result = %12\n  if (&& (? result: Completion) (! (= result.Type ~normal~))) {\n    if (= iteratorRecord.Done false) {\n      call %13 = clo<\"IteratorClose\">(iteratorRecord, result)\n      call %14 = clo<\"Completion\">(%13)\n      result = %14\n    }\n    assert (? result: Completion)\n    if (&& (? result: Completion) (! (= result.Type ~normal~))) {\n      call %15 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [result.Value])[#1416])\n      assert (? %15: Completion)\n      if (? %15: Abrupt) return %15\n      else %15 = %15.Value\n      %16 = promiseCapability.Promise\n      if (? %16: Completion) return %16\n      call %17 = clo<\"NormalCompletion\">(%16)\n      return %17\n    } else {\n      assert (? result: Normal)\n      result = result.Value\n      result = result\n    }\n  }\n  assert (? result: Completion)\n  return result\n}","def PerformPromiseAny(\n  iteratorRecord: Record[IteratorRecord],\n  constructor: Record[Constructor],\n  resultCapability: Record[PromiseCapabilityRecord],\n  promiseResolve: Record[FunctionObject],\n): Normal[ESValue] | Throw = {\n  let errors = (list [])[#1417]\n  let remainingElementsCount = (record {\n    \"Value\" : 1,\n  })[#1418]\n  let index = 0\n  while true {\n    call %0 = clo<\"IteratorStepValue\">(iteratorRecord)\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let next = %0\n    if (= next ~done~) {\n      remainingElementsCount.Value = (- remainingElementsCount.Value 1)\n      if (== remainingElementsCount.Value 0) {\n        call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%AggregateError.prototype%\")\n        let error = %1\n        call %2 = clo<\"CreateArrayFromList\">(errors)\n        call %3 = clo<\"DefinePropertyOrThrow\">(error, \"errors\", (record [PropertyDescriptor] {\n          \"Configurable\" : true,\n          \"Enumerable\" : false,\n          \"Writable\" : true,\n          \"Value\" : %2,\n        })[#1419])\n        assert (? %3: Normal)\n        %3 = %3.Value\n        call %4 = clo<\"ThrowCompletion\">(error)\n        if (? %4: Completion) return %4\n        call %5 = clo<\"NormalCompletion\">(%4)\n        return %5\n      }\n      %6 = resultCapability.Promise\n      if (? %6: Completion) return %6\n      call %7 = clo<\"NormalCompletion\">(%6)\n      return %7\n    }\n    push errors < undefined\n    call %8 = clo<\"Call\">(promiseResolve, constructor, (list [next])[#1420])\n    assert (? %8: Completion)\n    if (? %8: Abrupt) return %8\n    else %8 = %8.Value\n    let nextPromise = %8\n    let stepsRejected = clo<\"INTRINSICS.yet:`Promise.any`RejectElementFunction\">\n    let lengthRejected = 1\n    call %9 = clo<\"CreateBuiltinFunction\">(stepsRejected, lengthRejected, \"\", (list [\"AlreadyCalled\", \"Index\", \"Errors\", \"Capability\", \"RemainingElements\"])[#1421])\n    let onRejected = %9\n    onRejected.AlreadyCalled = false\n    onRejected.Index = index\n    onRejected.Errors = errors\n    onRejected.Capability = resultCapability\n    onRejected.RemainingElements = remainingElementsCount\n    remainingElementsCount.Value = (+ remainingElementsCount.Value 1)\n    call %10 = clo<\"Invoke\">(nextPromise, \"then\", (list [resultCapability.Resolve, onRejected])[#1422])\n    assert (? %10: Completion)\n    if (? %10: Abrupt) return %10\n    else %10 = %10.Value\n    index = (+ index 1)\n  }\n}","def <BUILTIN>:INTRINSICS.yet:`Promise.any`RejectElementFunction(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1423]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  let F = @EXECUTION_STACK[0].Function\n  if (= F.AlreadyCalled true) {\n    call %0 = clo<\"NormalCompletion\">(undefined)\n    return %0\n  }\n  F.AlreadyCalled = true\n  let index = F.Index\n  let errors = F.Errors\n  let promiseCapability = F.Capability\n  let remainingElementsCount = F.RemainingElements\n  errors[index] = x\n  remainingElementsCount.Value = (- remainingElementsCount.Value 1)\n  if (== remainingElementsCount.Value 0) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%AggregateError.prototype%\")\n    let error = %1\n    call %2 = clo<\"CreateArrayFromList\">(errors)\n    call %3 = clo<\"DefinePropertyOrThrow\">(error, \"errors\", (record [PropertyDescriptor] {\n      \"Configurable\" : true,\n      \"Enumerable\" : false,\n      \"Writable\" : true,\n      \"Value\" : %2,\n    })[#1424])\n    assert (? %3: Normal)\n    %3 = %3.Value\n    call %4 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [error])[#1425])\n    assert (? %4: Completion)\n    return %4\n  }\n  call %5 = clo<\"NormalCompletion\">(undefined)\n  return %5\n}","def <BUILTIN>:INTRINSICS.Promise.race(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1426]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop iterable < ArgumentsList\n    expand __args__.iterable\n  } else let iterable = undefined\n  let C = this\n  call %0 = clo<\"NewPromiseCapability\">(C)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let promiseCapability = %0\n  call %1 = clo<\"GetPromiseResolve\">(C)\n  call %2 = clo<\"Completion\">(%1)\n  let promiseResolve = %2\n  assert (? promiseResolve: Completion)\n  if (&& (? promiseResolve: Completion) (! (= promiseResolve.Type ~normal~))) {\n    call %3 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [promiseResolve.Value])[#1427])\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    %4 = promiseCapability.Promise\n    if (? %4: Completion) return %4\n    call %5 = clo<\"NormalCompletion\">(%4)\n    return %5\n  } else {\n    assert (? promiseResolve: Normal)\n    promiseResolve = promiseResolve.Value\n    promiseResolve = promiseResolve\n  }\n  call %6 = clo<\"GetIterator\">(iterable, ~sync~)\n  call %7 = clo<\"Completion\">(%6)\n  let iteratorRecord = %7\n  assert (? iteratorRecord: Completion)\n  if (&& (? iteratorRecord: Completion) (! (= iteratorRecord.Type ~normal~))) {\n    call %8 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [iteratorRecord.Value])[#1428])\n    assert (? %8: Completion)\n    if (? %8: Abrupt) return %8\n    else %8 = %8.Value\n    %9 = promiseCapability.Promise\n    if (? %9: Completion) return %9\n    call %10 = clo<\"NormalCompletion\">(%9)\n    return %10\n  } else {\n    assert (? iteratorRecord: Normal)\n    iteratorRecord = iteratorRecord.Value\n    iteratorRecord = iteratorRecord\n  }\n  call %11 = clo<\"PerformPromiseRace\">(iteratorRecord, C, promiseCapability, promiseResolve)\n  call %12 = clo<\"Completion\">(%11)\n  let result = %12\n  if (&& (? result: Completion) (! (= result.Type ~normal~))) {\n    if (= iteratorRecord.Done false) {\n      call %13 = clo<\"IteratorClose\">(iteratorRecord, result)\n      call %14 = clo<\"Completion\">(%13)\n      result = %14\n    }\n    assert (? result: Completion)\n    if (&& (? result: Completion) (! (= result.Type ~normal~))) {\n      call %15 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [result.Value])[#1429])\n      assert (? %15: Completion)\n      if (? %15: Abrupt) return %15\n      else %15 = %15.Value\n      %16 = promiseCapability.Promise\n      if (? %16: Completion) return %16\n      call %17 = clo<\"NormalCompletion\">(%16)\n      return %17\n    } else {\n      assert (? result: Normal)\n      result = result.Value\n      result = result\n    }\n  }\n  assert (? result: Completion)\n  return result\n}","def PerformPromiseRace(\n  iteratorRecord: Record[IteratorRecord],\n  constructor: Record[Constructor],\n  resultCapability: Record[PromiseCapabilityRecord],\n  promiseResolve: Record[FunctionObject],\n): Normal[ESValue] | Throw = {\n  while true {\n    call %0 = clo<\"IteratorStepValue\">(iteratorRecord)\n    assert (? %0: Completion)\n    if (? %0: Abrupt) return %0\n    else %0 = %0.Value\n    let next = %0\n    if (= next ~done~) {\n      %1 = resultCapability.Promise\n      if (? %1: Completion) return %1\n      call %2 = clo<\"NormalCompletion\">(%1)\n      return %2\n    }\n    call %3 = clo<\"Call\">(promiseResolve, constructor, (list [next])[#1430])\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    let nextPromise = %3\n    call %4 = clo<\"Invoke\">(nextPromise, \"then\", (list [resultCapability.Resolve, resultCapability.Reject])[#1431])\n    assert (? %4: Completion)\n    if (? %4: Abrupt) return %4\n    else %4 = %4.Value\n  }\n}","def <BUILTIN>:INTRINSICS.Promise.reject(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1432]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop r < ArgumentsList\n    expand __args__.r\n  } else let r = undefined\n  let C = this\n  call %0 = clo<\"NewPromiseCapability\">(C)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let promiseCapability = %0\n  call %1 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [r])[#1433])\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  %2 = promiseCapability.Promise\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Promise.resolve(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1434]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop x < ArgumentsList\n    expand __args__.x\n  } else let x = undefined\n  let C = this\n  if (! (? C: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"PromiseResolve\">(C, x)\n  assert (? %2: Completion)\n  return %2\n}","def PromiseResolve(\n  C: Record[Constructor],\n  x: ESValue,\n): Normal[ESValue] | Throw = {\n  call %0 = clo<\"IsPromise\">(x)\n  if (= %0 true) {\n    call %1 = clo<\"Get\">(x, \"constructor\")\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    let xConstructor = %1\n    call %2 = clo<\"SameValue\">(xConstructor, C)\n    if (= %2 true) {\n      if (? x: Completion) return x\n      call %3 = clo<\"NormalCompletion\">(x)\n      return %3\n    }\n  }\n  call %4 = clo<\"NewPromiseCapability\">(C)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let promiseCapability = %4\n  call %5 = clo<\"Call\">(promiseCapability.Resolve, undefined, (list [x])[#1435])\n  assert (? %5: Completion)\n  if (? %5: Abrupt) return %5\n  else %5 = %5.Value\n  %6 = promiseCapability.Promise\n  if (? %6: Completion) return %6\n  call %7 = clo<\"NormalCompletion\">(%6)\n  return %7\n}","def <BUILTIN>:INTRINSICS.Promise.withResolvers(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1436]\n  let C = this\n  call %0 = clo<\"NewPromiseCapability\">(C)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let promiseCapability = %0\n  call %1 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Object.prototype%\"])\n  let obj = %1\n  call %2 = clo<\"CreateDataPropertyOrThrow\">(obj, \"promise\", promiseCapability.Promise)\n  assert (? %2: Normal)\n  %2 = %2.Value\n  call %3 = clo<\"CreateDataPropertyOrThrow\">(obj, \"resolve\", promiseCapability.Resolve)\n  assert (? %3: Normal)\n  %3 = %3.Value\n  call %4 = clo<\"CreateDataPropertyOrThrow\">(obj, \"reject\", promiseCapability.Reject)\n  assert (? %4: Normal)\n  %4 = %4.Value\n  if (? obj: Completion) return obj\n  call %5 = clo<\"NormalCompletion\">(obj)\n  return %5\n}","def <BUILTIN>:INTRINSICS.get Promise[@@species](\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1437]\n  if (? this: Completion) return this\n  call %0 = clo<\"NormalCompletion\">(this)\n  return %0\n}","def <BUILTIN>:INTRINSICS.Promise.prototype.catch(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1438]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop onRejected < ArgumentsList\n    expand __args__.onRejected\n  } else let onRejected = undefined\n  let promise = this\n  call %0 = clo<\"Invoke\">(promise, \"then\", (list [undefined, onRejected])[#1439])\n  assert (? %0: Completion)\n  return %0\n}","def <CLO>:INTRINSICS.Promise.prototype.finally:clo0:clo0(\n  this: Unknown,\n  ArgumentsList: Unknown,\n  NewTarget: Unknown,\n): Unknown = {\n  let __args__ = (record)[#1440]\n  if (? value: Completion) return value\n  call %0 = clo<\"NormalCompletion\">(value)\n  return %0\n}","def <CLO>:INTRINSICS.Promise.prototype.finally:clo0(\n  this: Unknown,\n  ArgumentsList: Unknown,\n  NewTarget: Unknown,\n): Unknown = {\n  let __args__ = (record)[#1441]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  call %0 = clo<\"Call\">(onFinally, undefined)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let result = %0\n  call %1 = clo<\"PromiseResolve\">(C, result)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let p = %1\n  let returnValue = clo<\"INTRINSICS.Promise.prototype.finally:clo0:clo0\", [value]>\n  call %2 = clo<\"CreateBuiltinFunction\">(returnValue, 0, \"\", (list [])[#1442])\n  let valueThunk = %2\n  call %3 = clo<\"Invoke\">(p, \"then\", (list [valueThunk])[#1443])\n  assert (? %3: Completion)\n  return %3\n}","def <CLO>:INTRINSICS.Promise.prototype.finally:clo1:clo0(\n  this: Unknown,\n  ArgumentsList: Unknown,\n  NewTarget: Unknown,\n): Unknown = {\n  let __args__ = (record)[#1444]\n  call %0 = clo<\"ThrowCompletion\">(reason)\n  if (? %0: Completion) return %0\n  call %1 = clo<\"NormalCompletion\">(%0)\n  return %1\n}","def <CLO>:INTRINSICS.Promise.prototype.finally:clo1(\n  this: Unknown,\n  ArgumentsList: Unknown,\n  NewTarget: Unknown,\n): Unknown = {\n  let __args__ = (record)[#1445]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop reason < ArgumentsList\n    expand __args__.reason\n  } else let reason = undefined\n  call %0 = clo<\"Call\">(onFinally, undefined)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let result = %0\n  call %1 = clo<\"PromiseResolve\">(C, result)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let p = %1\n  let throwReason = clo<\"INTRINSICS.Promise.prototype.finally:clo1:clo0\", [reason]>\n  call %2 = clo<\"CreateBuiltinFunction\">(throwReason, 0, \"\", (list [])[#1446])\n  let thrower = %2\n  call %3 = clo<\"Invoke\">(p, \"then\", (list [thrower])[#1447])\n  assert (? %3: Completion)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Promise.prototype.finally(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1448]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop onFinally < ArgumentsList\n    expand __args__.onFinally\n  } else let onFinally = undefined\n  let promise = this\n  if (! (? promise: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"SpeciesConstructor\">(promise, @EXECUTION_STACK[0].Realm.Intrinsics[\"%Promise%\"])\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let C = %2\n  call %3 = clo<\"IsConstructor\">(C)\n  assert (= %3 true)\n  call %4 = clo<\"IsCallable\">(onFinally)\n  if (= %4 false) {\n    let thenFinally = onFinally\n    let catchFinally = onFinally\n  } else {\n    let thenFinallyClosure = clo<\"INTRINSICS.Promise.prototype.finally:clo0\", [onFinally, C]>\n    call %5 = clo<\"CreateBuiltinFunction\">(thenFinallyClosure, 1, \"\", (list [])[#1449])\n    let thenFinally = %5\n    let catchFinallyClosure = clo<\"INTRINSICS.Promise.prototype.finally:clo1\", [onFinally, C]>\n    call %6 = clo<\"CreateBuiltinFunction\">(catchFinallyClosure, 1, \"\", (list [])[#1450])\n    let catchFinally = %6\n  }\n  call %7 = clo<\"Invoke\">(promise, \"then\", (list [thenFinally, catchFinally])[#1451])\n  assert (? %7: Completion)\n  return %7\n}","def <BUILTIN>:INTRINSICS.Promise.prototype.then(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1452]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop onFulfilled < ArgumentsList\n    expand __args__.onFulfilled\n  } else let onFulfilled = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop onRejected < ArgumentsList\n    expand __args__.onRejected\n  } else let onRejected = undefined\n  let promise = this\n  call %0 = clo<\"IsPromise\">(promise)\n  if (= %0 false) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  call %3 = clo<\"SpeciesConstructor\">(promise, @EXECUTION_STACK[0].Realm.Intrinsics[\"%Promise%\"])\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let C = %3\n  call %4 = clo<\"NewPromiseCapability\">(C)\n  assert (? %4: Completion)\n  if (? %4: Abrupt) return %4\n  else %4 = %4.Value\n  let resultCapability = %4\n  call %5 = clo<\"PerformPromiseThen\">(promise, onFulfilled, onRejected, resultCapability)\n  if (? %5: Completion) return %5\n  call %6 = clo<\"NormalCompletion\">(%5)\n  return %6\n}","def PerformPromiseThen(\n  promise: Record[Promise],\n  onFulfilled: ESValue,\n  onRejected: ESValue,\n  resultCapability?: Record[PromiseCapabilityRecord],\n): ESValue = {\n  call %0 = clo<\"IsPromise\">(promise)\n  assert (= %0 true)\n  if (! (exists resultCapability)) {\n    resultCapability = undefined\n  }\n  call %1 = clo<\"IsCallable\">(onFulfilled)\n  if (= %1 false) {\n    let onFulfilledJobCallback = ~empty~\n  } else {\n    call %2 = clo<\"HostMakeJobCallback\">(onFulfilled)\n    let onFulfilledJobCallback = %2\n  }\n  call %3 = clo<\"IsCallable\">(onRejected)\n  if (= %3 false) {\n    let onRejectedJobCallback = ~empty~\n  } else {\n    call %4 = clo<\"HostMakeJobCallback\">(onRejected)\n    let onRejectedJobCallback = %4\n  }\n  let fulfillReaction = (record [PromiseReactionRecord] {\n    \"Capability\" : resultCapability,\n    \"Type\" : ~fulfill~,\n    \"Handler\" : onFulfilledJobCallback,\n  })[#1453]\n  let rejectReaction = (record [PromiseReactionRecord] {\n    \"Capability\" : resultCapability,\n    \"Type\" : ~reject~,\n    \"Handler\" : onRejectedJobCallback,\n  })[#1454]\n  if (= promise.PromiseState ~pending~) {\n    push promise.PromiseFulfillReactions < fulfillReaction\n    push promise.PromiseRejectReactions < rejectReaction\n  } else {\n    if (= promise.PromiseState ~fulfilled~) {\n      let value = promise.PromiseResult\n      call %5 = clo<\"NewPromiseReactionJob\">(fulfillReaction, value)\n      let fulfillJob = %5\n      call %6 = clo<\"HostEnqueuePromiseJob\">(fulfillJob.Job, fulfillJob.Realm)\n    } else {\n      assert (= promise.PromiseState ~rejected~)\n      let reason = promise.PromiseResult\n      if (= promise.PromiseIsHandled false) {\n        call %7 = clo<\"HostPromiseRejectionTracker\">(promise, \"handle\")\n      }\n      call %8 = clo<\"NewPromiseReactionJob\">(rejectReaction, reason)\n      let rejectJob = %8\n      call %9 = clo<\"HostEnqueuePromiseJob\">(rejectJob.Job, rejectJob.Realm)\n    }\n  }\n  promise.PromiseIsHandled = true\n  if (= resultCapability undefined) {\n    return undefined\n  } else {\n    return resultCapability.Promise\n  }\n}","def <BUILTIN>:INTRINSICS.GeneratorFunction(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1455]\n  let parameterArgs = (list [])[#1456]\n  while (< 1 (sizeof ArgumentsList)) {\n    pop %0 < ArgumentsList\n    push parameterArgs < %0\n  }\n  if (< 0 (sizeof ArgumentsList)) {\n    pop bodyArg < ArgumentsList\n    expand __args__.bodyArg\n  } else let bodyArg = undefined\n  let C = @EXECUTION_STACK[0].Function\n  if (! (exists __args__.bodyArg)) {\n    bodyArg = \"\"\n  }\n  call %1 = clo<\"CreateDynamicFunction\">(C, NewTarget, ~generator~, parameterArgs, bodyArg)\n  assert (? %1: Completion)\n  return %1\n}","def <BUILTIN>:INTRINSICS.AsyncGeneratorFunction(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1457]\n  let parameterArgs = (list [])[#1458]\n  while (< 1 (sizeof ArgumentsList)) {\n    pop %0 < ArgumentsList\n    push parameterArgs < %0\n  }\n  if (< 0 (sizeof ArgumentsList)) {\n    pop bodyArg < ArgumentsList\n    expand __args__.bodyArg\n  } else let bodyArg = undefined\n  let C = @EXECUTION_STACK[0].Function\n  if (! (exists __args__.bodyArg)) {\n    bodyArg = \"\"\n  }\n  call %1 = clo<\"CreateDynamicFunction\">(C, NewTarget, ~async-generator~, parameterArgs, bodyArg)\n  assert (? %1: Completion)\n  return %1\n}","def <BUILTIN>:INTRINSICS.GeneratorFunction.prototype.prototype.next(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1459]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  call %0 = clo<\"GeneratorResume\">(this, value, ~empty~)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.GeneratorFunction.prototype.prototype.return(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1460]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  let g = this\n  let C = (record [CompletionRecord] {\n    \"Type\" : ~return~,\n    \"Value\" : value,\n    \"Target\" : ~empty~,\n  })[#1461]\n  call %0 = clo<\"GeneratorResumeAbrupt\">(g, C, ~empty~)\n  assert (? %0: Completion)\n  return %0\n}","def <BUILTIN>:INTRINSICS.GeneratorFunction.prototype.prototype.throw(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1462]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop exception < ArgumentsList\n    expand __args__.exception\n  } else let exception = undefined\n  let g = this\n  call %0 = clo<\"ThrowCompletion\">(exception)\n  let C = %0\n  call %1 = clo<\"GeneratorResumeAbrupt\">(g, C, ~empty~)\n  assert (? %1: Completion)\n  return %1\n}","def <CLO>:GeneratorStart:clo0(\n): Unknown = {\n  let acGenContext = @EXECUTION_STACK[0]\n  let acGenerator = acGenContext.Generator\n  if (? generatorBody: Ast) {\n    sdo-call %0 = generatorBody->Evaluation()\n    call %1 = clo<\"Completion\">(%0)\n    let result = %1\n  } else {\n    assert (? generatorBody: Clo)\n    call %2 = generatorBody()\n    let result = %2\n  }\n  assert (yet \"If we return here, the generator either threw an exception or performed either an implicit or explicit return.\")\n  pop %3 < @EXECUTION_STACK\n  acGenerator.GeneratorState = ~completed~\n  nop\n  if (&& (? result: Completion) (= result.Type ~normal~)) {\n    let resultValue = undefined\n  } else {\n    if (&& (? result: Completion) (= result.Type ~return~)) {\n      let resultValue = result.Value\n    } else {\n      assert (&& (? result: Completion) (= result.Type ~throw~))\n      assert (? result: Completion)\n      return result\n    }\n  }\n  call %4 = clo<\"CreateIterResultObject\">(resultValue, true)\n  if (? %4: Completion) return %4\n  call %5 = clo<\"NormalCompletion\">(%4)\n  return %5\n}","def <CONT>:GeneratorStart:cont1(\n): Enum[~unused~] = {\n  call %0 = closure()\n  pop %1 < genContext.ReturnCont\n  call %2 = %1(%0)\n}","def GeneratorStart(\n  generator: Record[Generator],\n  generatorBody: Unknown[\"FunctionBodyParseNodeOrAnAbstractClosureWithNoParameter\"],\n): Enum[~unused~] = {\n  assert (= generator.GeneratorState undefined)\n  let genContext = @EXECUTION_STACK[0]\n  genContext.Generator = generator\n  let closure = clo<\"GeneratorStart:clo0\", [generatorBody]>\n  genContext.ResumeCont = cont<\"GeneratorStart:cont1\">\n  generator.GeneratorContext = genContext\n  generator.GeneratorState = ~suspended-start~\n  return ~unused~\n}","def GeneratorValidate(\n  generator: ESValue,\n  generatorBrand: Enum[~empty~] | String,\n): Unknown[\"EitherANormalCompletionContainingOneOf~suspendedstart~,~suspendedyield~,Or~completed~,OrAThrowCompletion\"] = {\n  call %0 = clo<\"RequireInternalSlot\">(generator, \"GeneratorState\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"RequireInternalSlot\">(generator, \"GeneratorBrand\")\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  if (! (= generator.GeneratorBrand generatorBrand)) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  assert (exists generator.GeneratorContext)\n  let state = generator.GeneratorState\n  if (= state ~executing~) {\n    call %4 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %5 = clo<\"ThrowCompletion\">(%4)\n    return %5\n  }\n  if (? state: Completion) return state\n  call %6 = clo<\"NormalCompletion\">(state)\n  return %6\n}","def <CONT>:GeneratorResume:cont0(\n  result: Unknown,\n): Normal[ESValue] | Throw = {\n  assert (= methodContext @EXECUTION_STACK[0])\n  assert (? result: Completion)\n  return result\n}","def GeneratorResume(\n  generator: ESValue,\n  value: ESValue | Enum[~empty~],\n  generatorBrand: Enum[~empty~] | String,\n): Normal[ESValue] | Throw = {\n  call %0 = clo<\"GeneratorValidate\">(generator, generatorBrand)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let state = %0\n  if (= state ~completed~) {\n    call %1 = clo<\"CreateIterResultObject\">(undefined, true)\n    if (? %1: Completion) return %1\n    call %2 = clo<\"NormalCompletion\">(%1)\n    return %2\n  }\n  assert (|| (= state ~suspended-start~) (= state ~suspended-yield~))\n  let genContext = generator.GeneratorContext\n  let methodContext = @EXECUTION_STACK[0]\n  nop\n  generator.GeneratorState = ~executing~\n  push genContext > @EXECUTION_STACK\n  call %4 = clo<\"NormalCompletion\">(value)\n  if (! (exists genContext.ReturnCont)) genContext.ReturnCont = (list [])[#1463]\n  push cont<\"GeneratorResume:cont0\"> > genContext.ReturnCont\n  call %3 = genContext.ResumeCont(%4)\n}","def <CONT>:GeneratorResumeAbrupt:cont0(\n  result: Unknown,\n): Normal[ESValue] | Throw = {\n  assert (= methodContext @EXECUTION_STACK[0])\n  assert (? result: Completion)\n  return result\n}","def GeneratorResumeAbrupt(\n  generator: ESValue,\n  abruptCompletion: Return | Throw,\n  generatorBrand: Enum[~empty~] | String,\n): Normal[ESValue] | Throw = {\n  call %0 = clo<\"GeneratorValidate\">(generator, generatorBrand)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let state = %0\n  if (= state ~suspended-start~) {\n    generator.GeneratorState = ~completed~\n    nop\n    state = ~completed~\n  }\n  if (= state ~completed~) {\n    if (&& (? abruptCompletion: Completion) (= abruptCompletion.Type ~return~)) {\n      call %1 = clo<\"CreateIterResultObject\">(abruptCompletion.Value, true)\n      if (? %1: Completion) return %1\n      call %2 = clo<\"NormalCompletion\">(%1)\n      return %2\n    }\n    assert (? abruptCompletion: Completion)\n    return abruptCompletion\n  }\n  assert (= state ~suspended-yield~)\n  let genContext = generator.GeneratorContext\n  let methodContext = @EXECUTION_STACK[0]\n  nop\n  generator.GeneratorState = ~executing~\n  push genContext > @EXECUTION_STACK\n  if (! (exists genContext.ReturnCont)) genContext.ReturnCont = (list [])[#1464]\n  push cont<\"GeneratorResumeAbrupt:cont0\"> > genContext.ReturnCont\n  call %3 = genContext.ResumeCont(abruptCompletion)\n}","def GetGeneratorKind(\n): Enum[~async~, ~non-generator~, ~sync~] = {\n  let genContext = @EXECUTION_STACK[0]\n  if (! (exists genContext.Generator)) return ~non-generator~\n  let generator = genContext.Generator\n  if (exists generator.AsyncGeneratorState) {\n    return ~async~\n  } else {\n    return ~sync~\n  }\n}","def <CONT>:GeneratorYield:cont0(\n  resumptionValue: Unknown,\n): Normal[ESValue] | Abrupt = {\n  assert (= genContext @EXECUTION_STACK[0])\n  if (? resumptionValue: Completion) return resumptionValue\n  call %0 = clo<\"NormalCompletion\">(resumptionValue)\n  return %0\n}","def GeneratorYield(\n  iterNextObj: Unknown[\"ObjectThatConformsToThe<i>IteratorResult</i>Interface\"],\n): Normal[ESValue] | Abrupt = {\n  let genContext = @EXECUTION_STACK[0]\n  assert (? genContext: Record[GeneratorExecutionContext])\n  let generator = genContext.Generator\n  call %0 = clo<\"GetGeneratorKind\">()\n  assert (= %0 ~sync~)\n  generator.GeneratorState = ~suspended-yield~\n  pop %1 < @EXECUTION_STACK\n  let callerContext = @EXECUTION_STACK[0]\n  genContext.ResumeCont = cont<\"GeneratorYield:cont0\">\n  call %2 = clo<\"NormalCompletion\">(iterNextObj)\n  pop %3 < genContext.ReturnCont\n  call %4 = %3(%2)\n}","def Yield(\n  value: ESValue,\n): Normal[ESValue] | Abrupt = {\n  call %0 = clo<\"GetGeneratorKind\">()\n  let generatorKind = %0\n  if (= generatorKind ~async~) {\n    call %1 = clo<\"Await\">(value)\n    assert (? %1: Completion)\n    if (? %1: Abrupt) return %1\n    else %1 = %1.Value\n    call %2 = clo<\"AsyncGeneratorYield\">(%1)\n    assert (? %2: Completion)\n    return %2\n  } else {\n    call %3 = clo<\"CreateIterResultObject\">(value, false)\n    call %4 = clo<\"GeneratorYield\">(%3)\n    assert (? %4: Completion)\n    return %4\n  }\n}","def CreateIteratorFromClosure(\n  closure: Clo,\n  generatorBrand: Enum[~empty~] | String,\n  generatorPrototype: Record[Object],\n): Record[Generator] = {\n  nop\n  let internalSlotsList = (list [\"GeneratorState\", \"GeneratorContext\", \"GeneratorBrand\"])[#1465]\n  call %0 = clo<\"OrdinaryObjectCreate\">(generatorPrototype, internalSlotsList)\n  let generator = %0\n  generator.GeneratorBrand = generatorBrand\n  generator.GeneratorState = undefined\n  let callerContext = @EXECUTION_STACK[0]\n  let calleeContext = (record [ExecutionContext])[#1466]\n  calleeContext.Function = null\n  calleeContext.Realm = @EXECUTION_STACK[0].Realm\n  calleeContext.ScriptOrModule = callerContext.ScriptOrModule\n  nop\n  push calleeContext > @EXECUTION_STACK\n  call %1 = clo<\"GeneratorStart\">(generator, closure)\n  pop %2 < @EXECUTION_STACK\n  return generator\n}","def <BUILTIN>:INTRINSICS.AsyncGeneratorFunction.prototype.prototype.next(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1467]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  let generator = this\n  call %0 = clo<\"NewPromiseCapability\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Promise%\"])\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let promiseCapability = %0\n  call %1 = clo<\"AsyncGeneratorValidate\">(generator, ~empty~)\n  call %2 = clo<\"Completion\">(%1)\n  let result = %2\n  assert (? result: Completion)\n  if (&& (? result: Completion) (! (= result.Type ~normal~))) {\n    call %3 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [result.Value])[#1468])\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    %4 = promiseCapability.Promise\n    if (? %4: Completion) return %4\n    call %5 = clo<\"NormalCompletion\">(%4)\n    return %5\n  } else {\n    assert (? result: Normal)\n    result = result.Value\n    result = result\n  }\n  let state = generator.AsyncGeneratorState\n  if (= state ~completed~) {\n    call %6 = clo<\"CreateIterResultObject\">(undefined, true)\n    let iteratorResult = %6\n    call %7 = clo<\"Call\">(promiseCapability.Resolve, undefined, (list [iteratorResult])[#1469])\n    assert (? %7: Normal)\n    %7 = %7.Value\n    %8 = promiseCapability.Promise\n    if (? %8: Completion) return %8\n    call %9 = clo<\"NormalCompletion\">(%8)\n    return %9\n  }\n  call %10 = clo<\"NormalCompletion\">(value)\n  let completion = %10\n  call %11 = clo<\"AsyncGeneratorEnqueue\">(generator, completion, promiseCapability)\n  if (|| (= state ~suspended-start~) (= state ~suspended-yield~)) {\n    call %12 = clo<\"AsyncGeneratorResume\">(generator, completion)\n  } else {\n    assert (|| (= state ~executing~) (= state ~awaiting-return~))\n  }\n  %13 = promiseCapability.Promise\n  if (? %13: Completion) return %13\n  call %14 = clo<\"NormalCompletion\">(%13)\n  return %14\n}","def <BUILTIN>:INTRINSICS.AsyncGeneratorFunction.prototype.prototype.return(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1470]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  let generator = this\n  call %0 = clo<\"NewPromiseCapability\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Promise%\"])\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let promiseCapability = %0\n  call %1 = clo<\"AsyncGeneratorValidate\">(generator, ~empty~)\n  call %2 = clo<\"Completion\">(%1)\n  let result = %2\n  assert (? result: Completion)\n  if (&& (? result: Completion) (! (= result.Type ~normal~))) {\n    call %3 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [result.Value])[#1471])\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    %4 = promiseCapability.Promise\n    if (? %4: Completion) return %4\n    call %5 = clo<\"NormalCompletion\">(%4)\n    return %5\n  } else {\n    assert (? result: Normal)\n    result = result.Value\n    result = result\n  }\n  let completion = (record [CompletionRecord] {\n    \"Type\" : ~return~,\n    \"Value\" : value,\n    \"Target\" : ~empty~,\n  })[#1472]\n  call %6 = clo<\"AsyncGeneratorEnqueue\">(generator, completion, promiseCapability)\n  let state = generator.AsyncGeneratorState\n  if (|| (= state ~suspended-start~) (= state ~completed~)) {\n    generator.AsyncGeneratorState = ~awaiting-return~\n    call %7 = clo<\"AsyncGeneratorAwaitReturn\">(generator)\n    assert (? %7: Normal)\n    %7 = %7.Value\n  } else {\n    if (= state ~suspended-yield~) {\n      call %8 = clo<\"AsyncGeneratorResume\">(generator, completion)\n    } else {\n      assert (|| (= state ~executing~) (= state ~awaiting-return~))\n    }\n  }\n  %9 = promiseCapability.Promise\n  if (? %9: Completion) return %9\n  call %10 = clo<\"NormalCompletion\">(%9)\n  return %10\n}","def <BUILTIN>:INTRINSICS.AsyncGeneratorFunction.prototype.prototype.throw(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1473]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop exception < ArgumentsList\n    expand __args__.exception\n  } else let exception = undefined\n  let generator = this\n  call %0 = clo<\"NewPromiseCapability\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Promise%\"])\n  assert (? %0: Normal)\n  %0 = %0.Value\n  let promiseCapability = %0\n  call %1 = clo<\"AsyncGeneratorValidate\">(generator, ~empty~)\n  call %2 = clo<\"Completion\">(%1)\n  let result = %2\n  assert (? result: Completion)\n  if (&& (? result: Completion) (! (= result.Type ~normal~))) {\n    call %3 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [result.Value])[#1474])\n    assert (? %3: Completion)\n    if (? %3: Abrupt) return %3\n    else %3 = %3.Value\n    %4 = promiseCapability.Promise\n    if (? %4: Completion) return %4\n    call %5 = clo<\"NormalCompletion\">(%4)\n    return %5\n  } else {\n    assert (? result: Normal)\n    result = result.Value\n    result = result\n  }\n  let state = generator.AsyncGeneratorState\n  if (= state ~suspended-start~) {\n    generator.AsyncGeneratorState = ~completed~\n    state = ~completed~\n  }\n  if (= state ~completed~) {\n    call %6 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [exception])[#1475])\n    assert (? %6: Normal)\n    %6 = %6.Value\n    %7 = promiseCapability.Promise\n    if (? %7: Completion) return %7\n    call %8 = clo<\"NormalCompletion\">(%7)\n    return %8\n  }\n  call %9 = clo<\"ThrowCompletion\">(exception)\n  let completion = %9\n  call %10 = clo<\"AsyncGeneratorEnqueue\">(generator, completion, promiseCapability)\n  if (= state ~suspended-yield~) {\n    call %11 = clo<\"AsyncGeneratorResume\">(generator, completion)\n  } else {\n    assert (|| (= state ~executing~) (= state ~awaiting-return~))\n  }\n  %12 = promiseCapability.Promise\n  if (? %12: Completion) return %12\n  call %13 = clo<\"NormalCompletion\">(%12)\n  return %13\n}","def <CLO>:AsyncGeneratorStart:clo0(\n): Unknown = {\n  let acGenContext = @EXECUTION_STACK[0]\n  let acGenerator = acGenContext.Generator\n  if (? generatorBody: Ast) {\n    sdo-call %0 = generatorBody->Evaluation()\n    call %1 = clo<\"Completion\">(%0)\n    let result = %1\n  } else {\n    assert (? generatorBody: Clo)\n    call %2 = generatorBody()\n    call %3 = clo<\"Completion\">(%2)\n    let result = %3\n  }\n  assert (yet \"If we return here, the async generator either threw an exception or performed either an implicit or explicit return.\")\n  pop %4 < @EXECUTION_STACK\n  acGenerator.AsyncGeneratorState = ~completed~\n  if (&& (? result: Completion) (= result.Type ~normal~)) {\n    call %5 = clo<\"NormalCompletion\">(undefined)\n    result = %5\n  }\n  if (&& (? result: Completion) (= result.Type ~return~)) {\n    call %6 = clo<\"NormalCompletion\">(result.Value)\n    result = %6\n  }\n  call %7 = clo<\"AsyncGeneratorCompleteStep\">(acGenerator, result, true)\n  call %8 = clo<\"AsyncGeneratorDrainQueue\">(acGenerator)\n  call %9 = clo<\"NormalCompletion\">(undefined)\n  return %9\n}","def <CONT>:AsyncGeneratorStart:cont1(\n): Enum[~unused~] = {\n  call %0 = closure()\n  pop %1 < genContext.ReturnCont\n  call %2 = %1(%0)\n}","def AsyncGeneratorStart(\n  generator: Record[AsyncGenerator],\n  generatorBody: Unknown[\"FunctionBodyParseNodeOrAnAbstractClosureWithNoParameter\"],\n): Enum[~unused~] = {\n  assert (= generator.AsyncGeneratorState undefined)\n  let genContext = @EXECUTION_STACK[0]\n  genContext.Generator = generator\n  let closure = clo<\"AsyncGeneratorStart:clo0\", [generatorBody]>\n  genContext.ResumeCont = cont<\"AsyncGeneratorStart:cont1\">\n  generator.AsyncGeneratorContext = genContext\n  generator.AsyncGeneratorState = ~suspended-start~\n  generator.AsyncGeneratorQueue = (list [])[#1476]\n  return ~unused~\n}","def AsyncGeneratorValidate(\n  generator: ESValue,\n  generatorBrand: Enum[~empty~] | String,\n): Normal[Enum[~unused~]] | Throw = {\n  call %0 = clo<\"RequireInternalSlot\">(generator, \"AsyncGeneratorContext\")\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  call %1 = clo<\"RequireInternalSlot\">(generator, \"AsyncGeneratorState\")\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  call %2 = clo<\"RequireInternalSlot\">(generator, \"AsyncGeneratorQueue\")\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  if (! (= generator.GeneratorBrand generatorBrand)) {\n    call %3 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %4 = clo<\"ThrowCompletion\">(%3)\n    return %4\n  }\n  call %5 = clo<\"NormalCompletion\">(~unused~)\n  return %5\n}","def AsyncGeneratorEnqueue(\n  generator: Record[AsyncGenerator],\n  completion: Completion,\n  promiseCapability: Record[PromiseCapabilityRecord],\n): Enum[~unused~] = {\n  let request = (record [AsyncGeneratorRequest] {\n    \"Completion\" : completion,\n    \"Capability\" : promiseCapability,\n  })[#1477]\n  push generator.AsyncGeneratorQueue < request\n  return ~unused~\n}","def AsyncGeneratorCompleteStep(\n  generator: Record[AsyncGenerator],\n  completion: Completion,\n  done: Boolean,\n  realm?: Record[RealmRecord],\n): Enum[~unused~] = {\n  assert (! (= (sizeof generator.AsyncGeneratorQueue) 0))\n  let next = generator.AsyncGeneratorQueue[0]\n  pop %0 < generator.AsyncGeneratorQueue\n  let promiseCapability = next.Capability\n  let value = completion.Value\n  if (&& (? completion: Completion) (= completion.Type ~throw~)) {\n    call %1 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [value])[#1478])\n    assert (? %1: Normal)\n    %1 = %1.Value\n  } else {\n    assert (&& (? completion: Completion) (= completion.Type ~normal~))\n    if (exists realm) {\n      let oldRealm = @EXECUTION_STACK[0].Realm\n      @EXECUTION_STACK[0].Realm = realm\n      call %2 = clo<\"CreateIterResultObject\">(value, done)\n      let iteratorResult = %2\n      @EXECUTION_STACK[0].Realm = oldRealm\n    } else {\n      call %3 = clo<\"CreateIterResultObject\">(value, done)\n      let iteratorResult = %3\n    }\n    call %4 = clo<\"Call\">(promiseCapability.Resolve, undefined, (list [iteratorResult])[#1479])\n    assert (? %4: Normal)\n    %4 = %4.Value\n  }\n  return ~unused~\n}","def <CONT>:AsyncGeneratorResume:cont0(\n  result: Unknown,\n): Enum[~unused~] = {\n  assert (|| (! (? result: Completion)) (= result.Type ~normal~))\n  assert (&& (= callerContext @EXECUTION_STACK[0]) (! (= genContext @EXECUTION_STACK[0])))\n  return ~unused~\n}","def AsyncGeneratorResume(\n  generator: Record[AsyncGenerator],\n  completion: Completion,\n): Enum[~unused~] = {\n  assert (|| (= generator.AsyncGeneratorState ~suspended-start~) (= generator.AsyncGeneratorState ~suspended-yield~))\n  let genContext = generator.AsyncGeneratorContext\n  let callerContext = @EXECUTION_STACK[0]\n  nop\n  generator.AsyncGeneratorState = ~executing~\n  push genContext > @EXECUTION_STACK\n  if (! (exists genContext.ReturnCont)) genContext.ReturnCont = (list [])[#1480]\n  push cont<\"AsyncGeneratorResume:cont0\"> > genContext.ReturnCont\n  call %0 = genContext.ResumeCont(completion)\n}","def AsyncGeneratorUnwrapYieldResumption(\n  resumptionValue: Completion,\n): Normal[ESValue] | Abrupt = {\n  if (! (&& (? resumptionValue: Completion) (= resumptionValue.Type ~return~))) {\n    assert (? resumptionValue: Completion)\n    return resumptionValue\n  }\n  call %0 = clo<\"Await\">(resumptionValue.Value)\n  call %1 = clo<\"Completion\">(%0)\n  let awaited = %1\n  if (&& (? awaited: Completion) (= awaited.Type ~throw~)) {\n    assert (? awaited: Completion)\n    return awaited\n  }\n  assert (&& (? awaited: Completion) (= awaited.Type ~normal~))\n  %2 = (record [CompletionRecord] {\n    \"Type\" : ~return~,\n    \"Value\" : awaited.Value,\n    \"Target\" : ~empty~,\n  })[#1481]\n  if (? %2: Completion) return %2\n  call %3 = clo<\"NormalCompletion\">(%2)\n  return %3\n}","def <CONT>:AsyncGeneratorYield:cont0(\n  resumptionValue: Unknown,\n): Normal[ESValue] | Abrupt = {\n  assert (= genContext @EXECUTION_STACK[0])\n  call %0 = clo<\"AsyncGeneratorUnwrapYieldResumption\">(resumptionValue)\n  assert (? %0: Completion)\n  return %0\n}","def AsyncGeneratorYield(\n  value: ESValue,\n): Normal[ESValue] | Abrupt = {\n  let genContext = @EXECUTION_STACK[0]\n  assert (? genContext: Record[GeneratorExecutionContext])\n  let generator = genContext.Generator\n  call %0 = clo<\"GetGeneratorKind\">()\n  assert (= %0 ~async~)\n  call %1 = clo<\"NormalCompletion\">(value)\n  let completion = %1\n  assert (< 1 (sizeof @EXECUTION_STACK))\n  let previousContext = @EXECUTION_STACK[1]\n  let previousRealm = previousContext.Realm\n  call %2 = clo<\"AsyncGeneratorCompleteStep\">(generator, completion, false, previousRealm)\n  let queue = generator.AsyncGeneratorQueue\n  if (! (= (sizeof queue) 0)) {\n    nop\n    let toYield = queue[0]\n    call %3 = clo<\"Completion\">(toYield.Completion)\n    let resumptionValue = %3\n    call %4 = clo<\"AsyncGeneratorUnwrapYieldResumption\">(resumptionValue)\n    assert (? %4: Completion)\n    return %4\n  } else {\n    generator.AsyncGeneratorState = ~suspended-yield~\n    pop %5 < @EXECUTION_STACK\n    let callerContext = @EXECUTION_STACK[0]\n    genContext.ResumeCont = cont<\"AsyncGeneratorYield:cont0\">\n    pop %6 < genContext.ReturnCont\n    call %7 = %6(undefined)\n  }\n}","def <CLO>:AsyncGeneratorAwaitReturn:clo0(\n  this: Unknown,\n  ArgumentsList: Unknown,\n  NewTarget: Unknown,\n): Unknown = {\n  let __args__ = (record)[#1482]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop value < ArgumentsList\n    expand __args__.value\n  } else let value = undefined\n  generator.AsyncGeneratorState = ~completed~\n  call %0 = clo<\"NormalCompletion\">(value)\n  let result = %0\n  call %1 = clo<\"AsyncGeneratorCompleteStep\">(generator, result, true)\n  call %2 = clo<\"AsyncGeneratorDrainQueue\">(generator)\n  call %3 = clo<\"NormalCompletion\">(undefined)\n  return %3\n}","def <CLO>:AsyncGeneratorAwaitReturn:clo1(\n  this: Unknown,\n  ArgumentsList: Unknown,\n  NewTarget: Unknown,\n): Unknown = {\n  let __args__ = (record)[#1483]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop reason < ArgumentsList\n    expand __args__.reason\n  } else let reason = undefined\n  generator.AsyncGeneratorState = ~completed~\n  call %0 = clo<\"ThrowCompletion\">(reason)\n  let result = %0\n  call %1 = clo<\"AsyncGeneratorCompleteStep\">(generator, result, true)\n  call %2 = clo<\"AsyncGeneratorDrainQueue\">(generator)\n  call %3 = clo<\"NormalCompletion\">(undefined)\n  return %3\n}","def AsyncGeneratorAwaitReturn(\n  generator: Record[AsyncGenerator],\n): Normal[Enum[~unused~]] | Throw = {\n  let queue = generator.AsyncGeneratorQueue\n  assert (! (= (sizeof queue) 0))\n  let next = queue[0]\n  call %0 = clo<\"Completion\">(next.Completion)\n  let completion = %0\n  assert (&& (? completion: Completion) (= completion.Type ~return~))\n  call %1 = clo<\"PromiseResolve\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Promise%\"], completion.Value)\n  assert (? %1: Completion)\n  if (? %1: Abrupt) return %1\n  else %1 = %1.Value\n  let promise = %1\n  let fulfilledClosure = clo<\"AsyncGeneratorAwaitReturn:clo0\", [generator]>\n  call %2 = clo<\"CreateBuiltinFunction\">(fulfilledClosure, 1, \"\", (list [])[#1484])\n  let onFulfilled = %2\n  let rejectedClosure = clo<\"AsyncGeneratorAwaitReturn:clo1\", [generator]>\n  call %3 = clo<\"CreateBuiltinFunction\">(rejectedClosure, 1, \"\", (list [])[#1485])\n  let onRejected = %3\n  call %4 = clo<\"PerformPromiseThen\">(promise, onFulfilled, onRejected)\n  call %5 = clo<\"NormalCompletion\">(~unused~)\n  return %5\n}","def AsyncGeneratorDrainQueue(\n  generator: Record[AsyncGenerator],\n): Enum[~unused~] = {\n  assert (= generator.AsyncGeneratorState ~completed~)\n  let queue = generator.AsyncGeneratorQueue\n  if (= (sizeof queue) 0) {\n    return ~unused~\n  }\n  let done = false\n  while (= done false) {\n    let next = queue[0]\n    call %0 = clo<\"Completion\">(next.Completion)\n    let completion = %0\n    if (&& (? completion: Completion) (= completion.Type ~return~)) {\n      generator.AsyncGeneratorState = ~awaiting-return~\n      call %1 = clo<\"AsyncGeneratorAwaitReturn\">(generator)\n      assert (? %1: Normal)\n      %1 = %1.Value\n      done = true\n    } else {\n      if (&& (? completion: Completion) (= completion.Type ~normal~)) {\n        call %2 = clo<\"NormalCompletion\">(undefined)\n        completion = %2\n      }\n      call %3 = clo<\"AsyncGeneratorCompleteStep\">(generator, completion, true)\n      if (= (sizeof queue) 0) {\n        done = true\n      }\n    }\n  }\n  return ~unused~\n}","def CreateAsyncIteratorFromClosure(\n  closure: Clo,\n  generatorBrand: Enum[~empty~] | String,\n  generatorPrototype: Record[Object],\n): Record[AsyncGenerator] = {\n  nop\n  let internalSlotsList = (list [\"AsyncGeneratorState\", \"AsyncGeneratorContext\", \"AsyncGeneratorQueue\", \"GeneratorBrand\"])[#1486]\n  call %0 = clo<\"OrdinaryObjectCreate\">(generatorPrototype, internalSlotsList)\n  let generator = %0\n  generator.GeneratorBrand = generatorBrand\n  generator.AsyncGeneratorState = undefined\n  let callerContext = @EXECUTION_STACK[0]\n  let calleeContext = (record [ExecutionContext])[#1487]\n  calleeContext.Function = null\n  calleeContext.Realm = @EXECUTION_STACK[0].Realm\n  calleeContext.ScriptOrModule = callerContext.ScriptOrModule\n  nop\n  push calleeContext > @EXECUTION_STACK\n  call %1 = clo<\"AsyncGeneratorStart\">(generator, closure)\n  pop %2 < @EXECUTION_STACK\n  return generator\n}","def <BUILTIN>:INTRINSICS.AsyncFunction(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1488]\n  let parameterArgs = (list [])[#1489]\n  while (< 1 (sizeof ArgumentsList)) {\n    pop %0 < ArgumentsList\n    push parameterArgs < %0\n  }\n  if (< 0 (sizeof ArgumentsList)) {\n    pop bodyArg < ArgumentsList\n    expand __args__.bodyArg\n  } else let bodyArg = undefined\n  let C = @EXECUTION_STACK[0].Function\n  if (! (exists __args__.bodyArg)) {\n    bodyArg = \"\"\n  }\n  call %1 = clo<\"CreateDynamicFunction\">(C, NewTarget, ~async~, parameterArgs, bodyArg)\n  assert (? %1: Completion)\n  return %1\n}","def AsyncFunctionStart(\n  promiseCapability: Record[PromiseCapabilityRecord],\n  asyncFunctionBody: Unknown[\"FunctionBodyParseNodeOrAnExpressionBodyParseNode\"],\n): Enum[~unused~] = {\n  let runningContext = @EXECUTION_STACK[0]\n  let asyncContext = (copy runningContext)[#1490]\n  nop\n  call %0 = clo<\"AsyncBlockStart\">(promiseCapability, asyncFunctionBody, asyncContext)\n  return ~unused~\n}","def <CLO>:AsyncBlockStart:clo0(\n): Unknown = {\n  let acAsyncContext = @EXECUTION_STACK[0]\n  sdo-call %0 = asyncBody->Evaluation()\n  call %1 = clo<\"Completion\">(%0)\n  let result = %1\n  assert (yet \"If we return here, the async function either threw an exception or performed an implicit or explicit return; all awaiting is done.\")\n  pop %2 < @EXECUTION_STACK\n  if (&& (? result: Completion) (= result.Type ~normal~)) {\n    call %3 = clo<\"Call\">(promiseCapability.Resolve, undefined, (list [undefined])[#1491])\n    assert (? %3: Normal)\n    %3 = %3.Value\n  } else {\n    if (&& (? result: Completion) (= result.Type ~return~)) {\n      call %4 = clo<\"Call\">(promiseCapability.Resolve, undefined, (list [result.Value])[#1492])\n      assert (? %4: Normal)\n      %4 = %4.Value\n    } else {\n      assert (&& (? result: Completion) (= result.Type ~throw~))\n      call %5 = clo<\"Call\">(promiseCapability.Reject, undefined, (list [result.Value])[#1493])\n      assert (? %5: Normal)\n      %5 = %5.Value\n    }\n  }\n  call %6 = clo<\"NormalCompletion\">(~unused~)\n  return %6\n}","def <CONT>:AsyncBlockStart:cont1(\n): Enum[~unused~] = {\n  call %0 = closure()\n  pop %1 < asyncContext.ReturnCont\n  call %2 = %1(%0)\n}","def <CONT>:AsyncBlockStart:cont2(\n  result: Unknown,\n): Enum[~unused~] = {\n  assert (&& (= runningContext @EXECUTION_STACK[0]) (! (= asyncContext @EXECUTION_STACK[0])))\n  assert (yet \"_result_ is a normal completion with a value of ~unused~. The possible sources of this value are Await or, if the async function doesn't await anything, step <emu-xref href=\\\"#step-asyncblockstart-return-undefined\\\"></emu-xref> above.\")\n  return ~unused~\n}","def AsyncBlockStart(\n  promiseCapability: Record[PromiseCapabilityRecord],\n  asyncBody: Ast,\n  asyncContext: Record[ExecutionContext],\n): Enum[~unused~] = {\n  assert (? promiseCapability: Record[PromiseCapabilityRecord])\n  let runningContext = @EXECUTION_STACK[0]\n  let closure = clo<\"AsyncBlockStart:clo0\", [promiseCapability, asyncBody]>\n  asyncContext.ResumeCont = cont<\"AsyncBlockStart:cont1\">\n  push asyncContext > @EXECUTION_STACK\n  if (! (exists asyncContext.ReturnCont)) asyncContext.ReturnCont = (list [])[#1494]\n  push cont<\"AsyncBlockStart:cont2\"> > asyncContext.ReturnCont\n  call %0 = asyncContext.ResumeCont()\n}","def <CONT>:Await:clo0:cont0(\n): Unknown = {\n  assert (&& (= prevContext @EXECUTION_STACK[0]) (! (= asyncContext @EXECUTION_STACK[0])))\n  call %0 = clo<\"NormalCompletion\">(undefined)\n  return %0\n}","def <CLO>:Await:clo0(\n  this: Unknown,\n  ArgumentsList: Unknown,\n  NewTarget: Unknown,\n): Unknown = {\n  let __args__ = (record)[#1495]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop v < ArgumentsList\n    expand __args__.v\n  } else let v = undefined\n  let prevContext = @EXECUTION_STACK[0]\n  nop\n  push asyncContext > @EXECUTION_STACK\n  call %1 = clo<\"NormalCompletion\">(v)\n  if (! (exists asyncContext.ReturnCont)) asyncContext.ReturnCont = (list [])[#1496]\n  push cont<\"Await:clo0:cont0\"> > asyncContext.ReturnCont\n  call %0 = asyncContext.ResumeCont(%1)\n}","def <CONT>:Await:clo1:cont0(\n): Unknown = {\n  assert (&& (= prevContext @EXECUTION_STACK[0]) (! (= asyncContext @EXECUTION_STACK[0])))\n  call %0 = clo<\"NormalCompletion\">(undefined)\n  return %0\n}","def <CLO>:Await:clo1(\n  this: Unknown,\n  ArgumentsList: Unknown,\n  NewTarget: Unknown,\n): Unknown = {\n  let __args__ = (record)[#1497]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop reason < ArgumentsList\n    expand __args__.reason\n  } else let reason = undefined\n  let prevContext = @EXECUTION_STACK[0]\n  nop\n  push asyncContext > @EXECUTION_STACK\n  call %1 = clo<\"ThrowCompletion\">(reason)\n  if (! (exists asyncContext.ReturnCont)) asyncContext.ReturnCont = (list [])[#1498]\n  push cont<\"Await:clo1:cont0\"> > asyncContext.ReturnCont\n  call %0 = asyncContext.ResumeCont(%1)\n}","def <CONT>:Await:cont2(\n  completion: Unknown,\n): Normal[ESValue | Enum[~empty~]] | Throw = {\n  assert (yet \"If control reaches here, then _asyncContext_ is the running execution context again.\")\n  if (? completion: Completion) return completion\n  call %0 = clo<\"NormalCompletion\">(completion)\n  return %0\n}","def Await(\n  value: ESValue,\n): Normal[ESValue | Enum[~empty~]] | Throw = {\n  let asyncContext = @EXECUTION_STACK[0]\n  call %0 = clo<\"PromiseResolve\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Promise%\"], value)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let promise = %0\n  let fulfilledClosure = clo<\"Await:clo0\", [asyncContext]>\n  call %1 = clo<\"CreateBuiltinFunction\">(fulfilledClosure, 1, \"\", (list [])[#1499])\n  let onFulfilled = %1\n  let rejectedClosure = clo<\"Await:clo1\", [asyncContext]>\n  call %2 = clo<\"CreateBuiltinFunction\">(rejectedClosure, 1, \"\", (list [])[#1500])\n  let onRejected = %2\n  call %3 = clo<\"PerformPromiseThen\">(promise, onFulfilled, onRejected)\n  pop %4 < @EXECUTION_STACK\n  let callerContext = @EXECUTION_STACK[0]\n  asyncContext.ResumeCont = cont<\"Await:cont2\">\n  pop %5 < asyncContext.ReturnCont\n  call %6 = %5(~empty~)\n}","def <BUILTIN>:INTRINSICS.Reflect.apply(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1501]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop target < ArgumentsList\n    expand __args__.target\n  } else let target = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop thisArgument < ArgumentsList\n    expand __args__.thisArgument\n  } else let thisArgument = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop argumentsList < ArgumentsList\n    expand __args__.argumentsList\n  } else let argumentsList = undefined\n  call %0 = clo<\"IsCallable\">(target)\n  if (= %0 false) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  call %3 = clo<\"CreateListFromArrayLike\">(argumentsList)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let args = %3\n  call %4 = clo<\"PrepareForTailCall\">()\n  call %5 = clo<\"Call\">(target, thisArgument, args)\n  assert (? %5: Completion)\n  return %5\n}","def <BUILTIN>:INTRINSICS.Reflect.construct(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1502]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop target < ArgumentsList\n    expand __args__.target\n  } else let target = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop argumentsList < ArgumentsList\n    expand __args__.argumentsList\n  } else let argumentsList = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop newTarget < ArgumentsList\n    expand __args__.newTarget\n  } else let newTarget = undefined\n  call %0 = clo<\"IsConstructor\">(target)\n  if (= %0 false) {\n    call %1 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %2 = clo<\"ThrowCompletion\">(%1)\n    return %2\n  }\n  if (! (exists __args__.newTarget)) {\n    newTarget = target\n  } else {\n    call %3 = clo<\"IsConstructor\">(newTarget)\n    if (= %3 false) {\n      call %4 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n      call %5 = clo<\"ThrowCompletion\">(%4)\n      return %5\n    }\n  }\n  call %6 = clo<\"CreateListFromArrayLike\">(argumentsList)\n  assert (? %6: Completion)\n  if (? %6: Abrupt) return %6\n  else %6 = %6.Value\n  let args = %6\n  call %7 = clo<\"Construct\">(target, args, newTarget)\n  assert (? %7: Completion)\n  return %7\n}","def <BUILTIN>:INTRINSICS.Reflect.defineProperty(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1503]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop target < ArgumentsList\n    expand __args__.target\n  } else let target = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop propertyKey < ArgumentsList\n    expand __args__.propertyKey\n  } else let propertyKey = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop attributes < ArgumentsList\n    expand __args__.attributes\n  } else let attributes = undefined\n  if (! (? target: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"ToPropertyKey\">(propertyKey)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let key = %2\n  call %3 = clo<\"ToPropertyDescriptor\">(attributes)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let desc = %3\n  call %4 = target.DefineOwnProperty(target, key, desc)\n  assert (? %4: Completion)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Reflect.deleteProperty(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1504]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop target < ArgumentsList\n    expand __args__.target\n  } else let target = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop propertyKey < ArgumentsList\n    expand __args__.propertyKey\n  } else let propertyKey = undefined\n  if (! (? target: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"ToPropertyKey\">(propertyKey)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let key = %2\n  call %3 = target.Delete(target, key)\n  assert (? %3: Completion)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Reflect.get(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1505]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop target < ArgumentsList\n    expand __args__.target\n  } else let target = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop propertyKey < ArgumentsList\n    expand __args__.propertyKey\n  } else let propertyKey = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop receiver < ArgumentsList\n    expand __args__.receiver\n  } else let receiver = undefined\n  if (! (? target: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"ToPropertyKey\">(propertyKey)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let key = %2\n  if (! (exists __args__.receiver)) {\n    receiver = target\n  }\n  call %3 = target.Get(target, key, receiver)\n  assert (? %3: Completion)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Reflect.getOwnPropertyDescriptor(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1506]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop target < ArgumentsList\n    expand __args__.target\n  } else let target = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop propertyKey < ArgumentsList\n    expand __args__.propertyKey\n  } else let propertyKey = undefined\n  if (! (? target: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"ToPropertyKey\">(propertyKey)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let key = %2\n  call %3 = target.GetOwnProperty(target, key)\n  assert (? %3: Completion)\n  if (? %3: Abrupt) return %3\n  else %3 = %3.Value\n  let desc = %3\n  call %4 = clo<\"FromPropertyDescriptor\">(desc)\n  if (? %4: Completion) return %4\n  call %5 = clo<\"NormalCompletion\">(%4)\n  return %5\n}","def <BUILTIN>:INTRINSICS.Reflect.getPrototypeOf(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1507]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop target < ArgumentsList\n    expand __args__.target\n  } else let target = undefined\n  if (! (? target: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = target.GetPrototypeOf(target)\n  assert (? %2: Completion)\n  return %2\n}","def <BUILTIN>:INTRINSICS.Reflect.has(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1508]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop target < ArgumentsList\n    expand __args__.target\n  } else let target = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop propertyKey < ArgumentsList\n    expand __args__.propertyKey\n  } else let propertyKey = undefined\n  if (! (? target: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"ToPropertyKey\">(propertyKey)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let key = %2\n  call %3 = target.HasProperty(target, key)\n  assert (? %3: Completion)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Reflect.isExtensible(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1509]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop target < ArgumentsList\n    expand __args__.target\n  } else let target = undefined\n  if (! (? target: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = target.IsExtensible(target)\n  assert (? %2: Completion)\n  return %2\n}","def <BUILTIN>:INTRINSICS.Reflect.ownKeys(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1510]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop target < ArgumentsList\n    expand __args__.target\n  } else let target = undefined\n  if (! (? target: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = target.OwnPropertyKeys(target)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let keys = %2\n  call %3 = clo<\"CreateArrayFromList\">(keys)\n  if (? %3: Completion) return %3\n  call %4 = clo<\"NormalCompletion\">(%3)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Reflect.preventExtensions(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1511]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop target < ArgumentsList\n    expand __args__.target\n  } else let target = undefined\n  if (! (? target: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = target.PreventExtensions(target)\n  assert (? %2: Completion)\n  return %2\n}","def <BUILTIN>:INTRINSICS.Reflect.set(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1512]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop target < ArgumentsList\n    expand __args__.target\n  } else let target = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop propertyKey < ArgumentsList\n    expand __args__.propertyKey\n  } else let propertyKey = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop V < ArgumentsList\n    expand __args__.V\n  } else let V = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop receiver < ArgumentsList\n    expand __args__.receiver\n  } else let receiver = undefined\n  if (! (? target: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"ToPropertyKey\">(propertyKey)\n  assert (? %2: Completion)\n  if (? %2: Abrupt) return %2\n  else %2 = %2.Value\n  let key = %2\n  if (! (exists __args__.receiver)) {\n    receiver = target\n  }\n  call %3 = target.Set(target, key, V, receiver)\n  assert (? %3: Completion)\n  return %3\n}","def <BUILTIN>:INTRINSICS.Reflect.setPrototypeOf(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1513]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop target < ArgumentsList\n    expand __args__.target\n  } else let target = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop proto < ArgumentsList\n    expand __args__.proto\n  } else let proto = undefined\n  if (! (? target: Record[Object])) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  if (&& (! (? proto: Record[Object])) (! (= proto null))) {\n    call %2 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %3 = clo<\"ThrowCompletion\">(%2)\n    return %3\n  }\n  call %4 = target.SetPrototypeOf(target, proto)\n  assert (? %4: Completion)\n  return %4\n}","def <BUILTIN>:INTRINSICS.Proxy(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1514]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop target < ArgumentsList\n    expand __args__.target\n  } else let target = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop handler < ArgumentsList\n    expand __args__.handler\n  } else let handler = undefined\n  if (= NewTarget undefined) {\n    call %0 = clo<\"__NEW_ERROR_OBJ__\">(\"%TypeError.prototype%\")\n    call %1 = clo<\"ThrowCompletion\">(%0)\n    return %1\n  }\n  call %2 = clo<\"ProxyCreate\">(target, handler)\n  assert (? %2: Completion)\n  return %2\n}","def <CLO>:INTRINSICS.Proxy.revocable:clo0(\n  this: Unknown,\n  ArgumentsList: Unknown,\n  NewTarget: Unknown,\n): Unknown = {\n  let __args__ = (record)[#1515]\n  let F = @EXECUTION_STACK[0].Function\n  let p = F.RevocableProxy\n  if (= p null) {\n    call %0 = clo<\"NormalCompletion\">(undefined)\n    return %0\n  }\n  F.RevocableProxy = null\n  assert (? p: Record[ProxyExoticObject])\n  p.ProxyTarget = null\n  p.ProxyHandler = null\n  call %1 = clo<\"NormalCompletion\">(undefined)\n  return %1\n}","def <BUILTIN>:INTRINSICS.Proxy.revocable(\n  this: ESValue,\n  ArgumentsList: List[ESValue],\n  NewTarget: Record[Constructor] | Undefined,\n): Unknown = {\n  let __args__ = (record)[#1516]\n  if (< 0 (sizeof ArgumentsList)) {\n    pop target < ArgumentsList\n    expand __args__.target\n  } else let target = undefined\n  if (< 0 (sizeof ArgumentsList)) {\n    pop handler < ArgumentsList\n    expand __args__.handler\n  } else let handler = undefined\n  call %0 = clo<\"ProxyCreate\">(target, handler)\n  assert (? %0: Completion)\n  if (? %0: Abrupt) return %0\n  else %0 = %0.Value\n  let proxy = %0\n  let revokerClosure = clo<\"INTRINSICS.Proxy.revocable:clo0\">\n  call %1 = clo<\"CreateBuiltinFunction\">(revokerClosure, 0, \"\", (list [\"RevocableProxy\"])[#1517])\n  let revoker = %1\n  revoker.RevocableProxy = proxy\n  call %2 = clo<\"OrdinaryObjectCreate\">(@EXECUTION_STACK[0].Realm.Intrinsics[\"%Object.prototype%\"])\n  let result = %2\n  call %3 = clo<\"CreateDataPropertyOrThrow\">(result, \"proxy\", proxy)\n  assert (? %3: Normal)\n  %3 = %3.Value\n  call %4 = clo<\"CreateDataPropertyOrThrow\">(result, \"revoke\", revoker)\n  assert (? %4: Normal)\n  %4 = %4.Value\n  if (? result: Completion) return result\n  call %5 = clo<\"NormalCompletion\">(result)\n  return %5\n}","def EventSet(\n  execution: Unknown[\"CandidateExecution\"],\n): Unknown[\"SetOfEvent\"] = {\n  (yet \"Let _events_ be an empty Set.\")\n  %1 = execution.EventsRecords\n  %0 = 0\n  while (< %0 (sizeof %1)) {\n    let aer = %1[%0]\n    if (? aer: Record[AgentEventsRecord]) {\n      (yet \"For each event _E_ of _aer_.[[EventList]], do\\n  1. Append _E_ to _events_.\")\n    }\n    %0 = (+ %0 1)\n  }\n  return events\n}","def SharedDataBlockEventSet(\n  execution: Unknown[\"CandidateExecution\"],\n): Unknown[\"SetOfEvent\"] = {\n  (yet \"Let _events_ be an empty Set.\")\n  (yet \"For each event _E_ of EventSet(_execution_), do\\n  1. If _E_ is a ReadSharedMemory, WriteSharedMemory, or ReadModifyWriteSharedMemory event, add _E_ to _events_.\")\n  return events\n}","def HostEventSet(\n  execution: Unknown[\"CandidateExecution\"],\n): Unknown[\"SetOfEvent\"] = {\n  (yet \"Let _events_ be an empty Set.\")\n  (yet \"For each event _E_ of EventSet(_execution_), do\\n  1. If _E_ is not in SharedDataBlockEventSet(_execution_), add _E_ to _events_.\")\n  return events\n}","def ComposeWriteEventBytes(\n  execution: Unknown[\"CandidateExecution\"],\n  byteIndex: NonNegInt,\n  Ws: Unknown[\"ListOfEitherWriteSharedMemoryOrReadModifyWriteSharedMemoryEvent\"],\n): Unknown[\"ListOfByteValue\"] = {\n  let byteLocation = byteIndex\n  let bytesRead = (list [])[#1518]\n  %1 = Ws\n  %0 = 0\n  while (< %0 (sizeof %1)) {\n    let W = %1[%0]\n    assert (yet \"_W_ has _byteLocation_ in its range.\")\n    let payloadIndex = (- byteLocation W.ByteIndex)\n    (yet \"If _W_ is a WriteSharedMemory event, then\\n  1. Let _byte_ be _W_.[[Payload]][_payloadIndex_].\")\n    (yet \"Else,\\n  1. Assert: _W_ is a ReadModifyWriteSharedMemory event..\\n  1. Let _bytes_ be ValueOfReadEvent(_execution_, _W_).\\n  1. Let _bytesModified_ be _W_.[[ModifyOp]](_bytes_, _W_.[[Payload]]).\\n  1. Let _byte_ be _bytesModified_[_payloadIndex_].\")\n    push bytesRead < byte\n    byteLocation = (+ byteLocation 1)\n    %0 = (+ %0 1)\n  }\n  return bytesRead\n}","def ValueOfReadEvent(\n  execution: Unknown[\"CandidateExecution\"],\n  R: Unknown[\"ReadSharedMemoryOrReadModifyWriteSharedMemoryEvent\"],\n): Unknown[\"ListOfByteValue\"] = {\n  call %0 = execution.ReadsBytesFrom(execution, R)\n  let Ws = %0\n  assert (yet \"_Ws_ is a List of WriteSharedMemory or ReadModifyWriteSharedMemory events with length equal to _R_.[[ElementSize]].\")\n  call %1 = clo<\"ComposeWriteEventBytes\">(execution, R.ByteIndex, Ws)\n  return %1\n}"]